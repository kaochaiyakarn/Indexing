semantics types programming languages carl gunter contents types programming higher types 
recursive types 
parametric polymorphism 
subtypes 
simple types sets types equations 
sets model 
type frames 
completeness sets 
simple types domains programming language computable functions 
operational semantics 
operational equivalence 
bc domains di domains 
full abstraction 
types invariants runtime safety 
implicit types 
runtime safety assignments continuations 
types subsets untyped calculus 
model untyped calculus 
models untyped calculus 
inclusive subsets types 
subtyping subset inclusion 
types partial equivalence relations sets model ml types 
carl gunter typing system ml polymorphic calculus 
sets model polymorphic types 
simple types 
model polymorphic types 
semantics types programming languages twentieth century lines development notion type 
uses types conquer problems foundations mathematics 
example type distinctions resolve troubling paradoxes lead inconsistent systems 
second line investigation types pursues application programming languages 
computer architectures suggest type distinctions higher level programming languages generally classification data types serve variety different purposes 
motives doing 
earliest reasons types programming languages fortran enhancement efficiency 
example variable declared array integers having number entries possible provide space management variable computer memory 
programmer indication type datum save pointless testing running program 
types remained basic motivation presence modern languages remain important application 
second motivation types appreciated 
role programming discipline 
types enforce restrictions shape formed programs 
key benefit doing possibility detecting flaws programs form compiletime type errors 
mistake program detected point program submitted compilation machine code mistake corrected promptly discovered run program data 
software engineering gains obtained way widely recognized price paid 
constraining programmer type system apparently reasonable programs rejected runtime behavior acceptable 
second typing system extensive programmer annotations timeconsuming write tedious read 
reducing impact drawbacks central objective types programming languages 
third motivation types programming languages understood role supporting data abstraction modularity 
cornerstones software engineering principle achieved extent types programming languages employ type system enforces hiding data type representations supports specification modules 
example languages support separation package specification consists collection type declarations body package carl gunter provides programs implementing procedures appear specification 
units automatically analyzed determine type correctness code generated compilation 
fourth motivation types primary topic chapter role conceptual tool classifying programs way permits understanding meanings 
virtually language semantics classify objects structure elevating conceptually sequences bits compiled 
abstraction fundamental type systems 
types programming section discusses collection programming examples intended illustrate motivations various type structures 
handy pair languages making comparison scheme viewed untyped calculus ml viewed typed calculus 
languages specifications clear finds languages usually difficult tell meaning program language specified 
ieee standard scheme introduced iee ml standard version milner examples 
designed semantic clarity key objective designs sensitive efficiency issues compilers widely 
functional fragments scheme ml employ call value evaluation strategy chance confusing operational differences differences type system philosophy reduced 
higher types 
discoveries researchers investigating mathematical semantics programming languages late usefulness higher order functions describing denotations programs 
higher order functions programming understood earlier incorporated constructs programming methodology lisp 
programmers languages scheme ml employ higher order functions tool writing clear succinct code capturing abstractions 
hand higher order functions costs worthwhile discuss ways functions useful 
usefulness tool semantics programming languages adequately argued books articles semantics types programming languages employ extensively semantic descriptions tennent provides starting point 
review subject perspective consider briefly useful programming 
consider familiar mathematical operation derivative continuous real valued function 
derivative function function dx gamma dx infinitesimal dx 
purposes estimate simplify discussion bind dx small number say 
course passed parameter necessary point 
scheme program computing derivative coded follows define deriv dx dx derivative higher order takes function parameter coded returning numerical value argument returning new function case mathematical derivative 
lead problems distinction properly observed 
example program deriv deriv mistakenly intended compute second derivative yield runtime type error deriv wrong number arguments 
course second derivative successfully calculated explicit abstraction deriv lambda deriv 
lambda eliminated making local definition intrusion lambda abstraction considered undesirable 
approaches generalize poorly case wanted third derivative fourth derivative 
accommodate cases possible include parameter th iteration differentiation definition deriv elegant understandable quit fighting mathematical usage programming start coding 
derivative takes function argument produces function value define deriv lambda dx dx second derivative properly coded carl gunter deriv deriv mathematical notation primes denote operation function 
calculate th derivatives possible write function takes function number arguments produces function ffi ffi delta delta delta ffi copies value 
powerful abstraction ways function key idea composition exponential modularly derivative mixed code th derivative function 
types come 
lying heart distinction just discussed notion currying passage function type theta type 

case derivative function coded function arguments real valued function real number coded ml looks fun deriv real 
real real real dx dx 
ml type checker indicates type real 
real real 
real way read think definition function deriv product type abstraction described pattern matching 
second curried way program function fun deriv fn real 
dx dx real ml syntax fn 
term type real 
real 
real 
real example usefulness higher order functions comes powerful programming techniques obtain combining assignments 
example drawn abelson sussman appears table 
procedure account takes starting balance argument produces account object value 
account object higher order function returned dispatch local state contents instance variable balance contains current balance object 
arguments taken object include messages represented atoms withdraw deposit arguments message sends appear formal parameters amount method definitions withdraw deposit 
create account balance object semantics types programming languages table 
local variables higher order functions scheme define account balance define withdraw amount balance amount sequence set 
balance balance amount balance insufficient funds define deposit amount set 
balance balance amount balance define dispatch cond eq 
withdraw withdraw eq 
deposit deposit error unknown request dispatch initialized applying account number starting value instance variable 
example dan defined value account george defined value account account objects correctly maintain separate balance levels sequence messages sends describing financial history objects 
finding suitable system types classify programs written object oriented style major area research chapter written 
recursive types 
consider pair programs define lambda lambda lambda lambda define 
compiled comment scheme 
illustrate trade type checking programs 
program call value fixed point combinator 
interesting program carl gunter recursive definitions explicit recursive equations 
second program contains semantic error form bad addition 
actual bugs encountered programs despite silly looks simple example 
programs executed scheme second program probably cause runtime type error 
examples rendered ml follows fun fn 
fn 
fn 
fn 
fun 
ml type checker reject having type errors 
second case rejection occur expression purports add string operation allowed 
program rejected application variable type inferred ml type checker 
viewpoint programmer see type checking useful diagnostic second program hindrance 
programming language said static type checking type correctness program established program compiled 
scheme carry check ml 
course type correctness relative typing discipline language design issue 
language allows programs accepted type correct compiletime necessary carry various runtime type checks errors caught type checker may detected quickly desire 
alternate extreme way ensure runtime type errors reject programs having type errors compiletime 
course programming language typing discipline strict languages restrictive reasonable 
right balance language discipline programming order provide useful diagnostic testing errors ruling programs capture useful abstractions efficient algorithms 
example languages check types programs compiling compensate problem just mentioned employing general type inference system ml allowing programmer explicit recursive types 
ml version call value fixed point combinator table 
understand program think annotation earlier program coercions types subterms explicit 
fact type ml program semantics types programming languages table 
ml version call value fixed point combinator local datatype fix fun fix 
fun fun fun fn 
fn 
fun fn 
fn 


type variables hoped carry detailed analysis program just consider couple points 
definition procedure lines code recursive appears left hand side defining equation 
recursion lies datatype declaration local bindings unary operator fix written postfix notation defined recursive equation 
expression symbol represents type variable 
mathematical way writing datatype declaration indicate fix fix fun fix fix defines isomorphism 
inverse isomorphism function fix 
fix defined third line program 
remove declaration type isomorphisms ml program obtain definition rejected having type errors 
parametric polymorphism 
recursive types powerful tool recovering losses incurred imposing type discipline subtle concept way certain abstractions formed untyped language 
scheme program appends lists elements carl gunter define append null 
cons car append cdr scheme programmers need concern types elements lists appended program equally pair arguments long lists 
languages programmers declare types impossible obtain level abstraction 
may necessary write program appends lists integers program appends lists string arrays 
avoid losing abstractions languages static type checking deal problem polymorphism 
word polymorphism means having forms typed programming languages ordinarily refers idea symbol may types 
simplest forms polymorphism arises variable specifies indeterminate parameterized type expression 
called parametric polymorphism 
basic form parametric polymorphism views kind macro expansion 
example ada programming language construct known generic serves purpose 
procedure declared generic ada explicitly instantiated type abstraction unnecessary rewrite piece code equally different types 
example function appends lists takes pair lists elements type argument returns list elements type result 
particular type unimportant replaced variable type indicated list list 
see example consider function takes cells exchanges contents 
obviously operation independent types elements cells polymorphic swapping function 
ml coded follows fun swap val temp temp exclamation marks dereferencing operation denotes contents cell novelty ml programming language inference algorithm infer polymorphic type programs need programmer annotations 
specifically ml syntax type inferred swap ref ref 
unit 
semantics types programming languages function swap works side effect change memory output unimportant taken unique value type unit 
type swap indicates type type variable arguments 
means type correct swap contents integer swap contents string program swap contents integer string rejected type error compiled 
anticipate precise definition ml polymorphism discussion limitations programming 
type inference excellent tool cutting tedium providing type annotations programs great deal abstraction lost compromises ml polymorphic types 
consider example scheme program define lambda cons hi defines procedure takes function argument forms cons cell results applying number string hi 
difficult think interesting things applied hi keep things simple consider lambda evaluates cell hi 
simple natural ml type inference algorithm unwilling see program type correct 
particular program fn 
hi rejected indication function take hi arguments different types 
bit dull light scheme example evidently shows perfectly programs take arguments 
ml construct allows level polymorphism 
program fun hi type correct clearly fails achieve abstraction scheme program sense value case 
obtain program written scheme necessary introduce expressive type system ml 
girard reynolds polymorphic calculus section desired expressiveness 
carl gunter subtypes 
kind programming language polymorphism modern languages notion subtype 
form type polymorphism arises classification data collections attributes 
perspective draws inspiration hierarchical systems categories taxonomy animal kingdom variation parameter quantifiers predicate logic 
get spirit kind typing informal example kind hierarchy form order classify individuals finds university call individuals academics 
academic associated university department university 
university professors teach courses students attend courses taught professors 
students employees university capacity teaching assistants ta research assistants ra supported research 
various classes individuals associated attributes 
instance consider typical semester attribute professors teaching assistants courses teaching teaching load 
capacity teachers professors ta employees salary associated 
ra project attribute research project working 
bring order assortment groups attributes helpful organize hierarchy groups classified defining attributes 
list group attributes 
type persons members include academics employees name attribute 
addition name academic university employee salary social security number tax purposes employer 
addition attributes inherited roles academics student advisor professor teaching load boolean tenure attribute 
professors employees possess attributes employees academics 
classify assortment common attributes form poset relations academic employee person student professor academic ra ta professor employee ra ta student relations obtained assumption transitive reflexive 
point poset represents type individual semantics types programming languages attributes individual possess 
type greater type poset means kind attribute individual type possesses individual type say subtype fact professor social security number conclude fact type professors subtype employees fact employee social security number 
types example viewed kind product components tuple having type attributes 
programming languages generally called records attributes called fields record 
records usually written curly brackets parentheses tuples 
semantically similar tuples field labels relieve need write record fields particular order 
common record syntax sequence pairs form label term associated label 
term generally called field record 
example records name carl gunter university university pennsylvania university university pennsylvania name carl gunter considered equivalent type records equivalent pair record type expressions name string university string university string name string 
mix records dual notion variant 
written square opposed curly brackets 
instance biological classification system include declaration type male female defining familiar partition collection reproductive systems 
expression male female labels fields variant types fields respectively 
order fields written insignificant 
classification system vehicles type type vehicle air carl gunter table 
declarations subtype hierarchy type thing age int type machine thing fuel string type machine int type int int type surface string int type int int land water vehicles classified preferred milieu 
term type come possible components 
example air term type vehicle term type 
water term type vehicle term type 
see little detail types consider declarations table 
defined types record type 
notation succinct plus sign written indicate instance machine record having field fuel fields thing age field 
consider subtype type vehicle 
case records subtype fields supertype 
variant dual holds 
instance type air land subtype vehicle type semantics types programming languages int type int 
intuitively wheeled vehicle air vehicle wheels land vehicle wheels 
forget wheels wheeled vehicle viewed simply vehicle 
example illustrates just fact fewer fields matters variants types fields exist subtypes corresponding fields supertype 
looking point view term type note value mycar land age fuel gasoline surface type vehicle field indicates number wheels omitted 
provides intuition subtyping relation records variants type constructor generalize idea function space operator 
suppose instance need function string 
machine kind fuel described string returns example machine uses fuel 
context function needed just easily function string 
kind fuel described string returns example uses fuel 
suffices kind machine 
suppose need function having type start place finish place mode 
int type place record consisting latitude longitude function calculates lower bound soon mode transport start finish 
suppose hand function start place finish place carl gunter mode 
int calculates value arguments naive way distance places maximum speed argument 
serve purpose special kind 
method calculate instance type applies instance 
examples suggest take string 
machine subtype string 
take start place finish place mode 
int subtype start place finish place mode 
int 
general case want generalize subtype just case subtype subtype note change ordering respect arguments simple types sets simply typed calculus basic typed calculi higher order functions 
described collection terms types independent systems typing judgements equational judgements 
types terms grammar variable mm variable possibly infinite collection primitive syntactic objects called variables 
discussions letters alphabet letters subscripts superscripts range variables handy letters variables cases 
types generally written letters terms generally written letters letters annotated superscripts subscripts may convenient 
type called ground type types semantics types programming languages called higher types 
terms form called abstractions form mn called applications 
parentheses indicate expression parsed modulo standard parsing conventions 
types association operator right instance parses 

dually application operations associate left application lmn parsed lm expression xyz unambiguously parses xy wish write expression applies result applying rendered yz 
application binds tightly abstraction instance expression mn parsed mn 
expression xyz unambiguously parses xy 
superfluous parentheses sprinkled expression emphasize grouping 
distinction common surround operand application parentheses mimic mathematical notation function applied argument 
terms treated equivalent renaming bound variables ff equivalence 
avoid tedious repetitions assumptions names bound variables helpful convention bound variable naming convention 
term representing ff equivalence class chosen name bound variable representative taken distinct names free variables terms discussed 
syntactic identity terms denoted relation terms variable expression term obtained substituting done modulo renaming bound variables avoid capturing free variables types equations 
describe typing system simply typed calculus notation associating types free variables required 
type assignment list xn pairs variables types variables distinct 
empty type assignment degenerate case pairs 
write case said occurs appears may abbreviated writing define type typing judgement triple consisting type assignment term type free variables appear relation written form read assignment term type 
defined carl gunter table 
typing rules simply typed calculus proj abs appl relation satisfying axiom rules table 
demonstration rules called typing derivation 
basic fact system lemma 
appear free general interested terms type assignments type term said type assignment type example fails type type assignment 
term type assignment type unique sense lemma 
type tags placed bound variables abstractions just lemma true 
try simplify notation allowing terms form typing rule form abs gamma lemma fail 
example 
important properties type system lemma 
semantics types programming languages lemma 
equation simply typed lambda calculus tuple type assignment terms type 
tuple readable helpful replace commas separating components tuple suggestive symbols write triangular marker intended indicate interesting part tuple begins 
heart tuple pair terms side equation symbol provide typing information terms 
equational theory set equations equation viewed formal symbol 
judgement equation provable define relation theories equations relation satisfying rules table 
assertion called equational judgement 
course turnstile symbol typing judgements overloading problem different appearance forms judgement 
related fact lemma 
theory basic property lemma 
suppose type assignment fv fv 

discussion typed calculus including interesting syntactic properties hindley seldin barendregt sets model 
standard model simply typed calculus interprets types sets higher types sets functions sets 
semantics relative choice set serves interpretation base type 
meaning type set defined inductively follows carl gunter table 
equational rules simply typed calculus fv fv ffig fjg fv semantics types programming languages ffl ffl ff function example 
set functions function hand set functions function element describing meanings terms difficult describing meanings types require vocabulary notation 
type assignment associates types variables environment associates values variables 
environments classified type assignments type assignment environment function ae variables maps value ae 
ae environment define ae 
ae ae 
update operation 
read ae 
environment ae value updated 
notation similar syntactic substitution note operation environments written postfix 
way read ae 
environment ae 
note assignment ae 
environment 
meaning term described relative type assignment type notation meaning term relative case equations earlier triangle intended kind marker separator type assignment term written meaning confuses relation typing judgements syntactic punctuation expression semantic brackets 
important remember sense meaning function environments 
semantics defined induction typing derivation ffl projection ae ae 
ffl abstraction ae function 
ae 
function defined ae 
carl gunter ffl application ae value obtained applying function ae argument ae unique type save quite bit ink drop parentheses appear part expressions ae 
simply write ae 

doing appears violate convention associating applications left little chance confusion case expressions 
adopt convention postfix update operator binds tightly general application 
shown assignment meanings respects equational rules 
soundness property semantic interpretation theorem soundness 

proved induction height derivation tree equational judgements examining case rule employed 
example soundness rule depends fact lemma 
suppose term ae 
ae 
lemma essentially asserts meaning term type environment depends values assigns free variables may calculate ae 
ae 

ae 

ae ae third equality follows lemma 
application soundness interpretation consider theorem 
simply typed calculus non trivial 
type pair distinct variables case 
proof 
suppose contrary 
set element consider model semantics types programming languages simply typed calculus generated hard see distinct elements ae environment ae ae ae ae ae ae 
contradicts soundness interpretation 
instructive exercise purpose providing semantic interpretation calculus try proving theorem directly principles rules calculus syntactic means 
soundness result provides simple way demonstrating properties rules calculus dually syntax proving properties model sets functions 
type frames 
way associate meaning triple demonstrated assignment meaning preserves required equations table provide rigorous description ground rules saying assignment really model simply typed calculus 
fact way depending considers important model 
choice definition may matter style convenience different choices may reflect significant distinctions 
form model described section generally refered extensional environment model 
discussion follows treatment friedman primary objective discuss completeness theorems proves theorems 
sake convenience definition broken parts 
models called frames defined terms general structure called pre frame 
definition 
pre frame pair functions delta types pairs types respectively ffl non empty set view interpretation type ffl theta function view interpretation application element element extensionality property holds carl gunter notation cumbersome write pre frame represent pair 
pre frames easy find 
example take set natural numbers define product implies extensionality property clearly satisfied 
multiplication pre frame provide evident interpretation terms reader may wish try exercise proving satisfying equational rules 
frame pre frame sensible interpretation terms 
definition 
type frame frame pre frame type function term defined triples environment function ae variables meanings ae type term function environments type 
function term delta required satisfy equations 
term ae ae 
term ae term ae term ae 
term ae term ae 

pre frame extension frame extension unique 
lemma 
type pre frame term delta term delta define frames 
term term general convenient notation type delta term delta 
lemma says application operation determines simplifies matters write pair frame 
frame viewed model calculus write ae ae environment ae 
cause confusion helps drop typing information write set equations equation define semantics types programming languages standard frame uses sets functions set full frame fx fx delta fx ffl fx fx set functions fx fx ffl ordinary function application ffl terms fx delta function delta defined previous section 
easy see definition semantic function delta corresponds exactly conditions definition frame 
essentially properties proof soundness property interpretation possible 
precise theorem soundness frames 
theory frame 
empty corollary 
frame important class examples frames formed equivalence classes typed terms simply typed calculus 
define frames need notation type assignments 
extended type assignment infinite list pairs finite prefix type assignment type appears infinitely type infinitely appears 
note fix extended type assignment say theory theory theory 
define fm hg defines equivalence relation terms proof left exercise 
empty set drop subscript type define hg pair types define tt theta tt tt defined congruence rule application 
shown carl gunter lemma 
pair pre frame 
pre frame frame called term model see need notation simultaneous substitutions 
write oe mn xn function maps variable term acts identity variables 
assumed xn distinct 
support substitution set variables substitution identity course support mn xn subset fx xng 
substitution oe mn xn extended substitution terms inductively defining ffl oe oe oe ffl oe oe support oe fv oe support oe 
generalizes earlier notation may viewed substitution support fxg 
support oe write oe 
oe mn xn 
ae environment term pre frame ae tt say substitution oe represents ae term oe representative term model equivalence class ae 
lemma 
ae oe oe substitution representing ae type frame 
type frames form complete class models theories calculus theorem completeness frames 
follows immediately lemma theorem 
suppose theory tt 
proof 
necessity follows immediately soundness theorem frames fact term model frame 
prove sufficiency choose ae identity environment ae 
identity substitution oe 
represents oe tt ae tt ae oe lemma 
particularly important example frame class term models induced empty theory particular term model semantics types programming languages convenient drop subscript 
instance theorem corollary 
completeness sets 
collection mathematical structures usually fruitful find study collections structure preserving transformations mappings 
homomorphisms algebras example continuous maps real numbers example 
kinds mappings type frames take structure preserving 
definition seek goal section obtained spirit homomorphisms algebras permitting partial structure preserving mappings requiring maps surjective 
provide concept needed prove full type frame complete 
definition 
frames 
partial homomorphism phi family surjective partial functions phi 
phi phi domain definition phi phi 
element satisfies equation phi undefined 
suppose solutions equation 
phi surjection 
extensionality implies equal 
solution equation unique 
basic fact partial homomorphisms implies corollary preservation equations partial homomorphisms 
lemma 
frames 
phi partial homomorphism ae environment ae environment phi ae ae variable phi ae ae carl gunter corollary 
partial homomorphism phi 
proof 
suppose ae environment choose ae ae phi ae possible phi surjection 
ae phi ae phi ae ae lemma 
ae ae equal assumption 
lemma 
type frame suppose surjection set 
partial homomorphism fx full type frame proof 
phi surjection 
suppose phi fx phi fx partial surjections 
define phi unique element exists phi phi phi domain definition phi proof defines surjection carried induction structure types 
holds assumption ground types suppose phi phi surjections 
choose fx fx fx domain definition phi phi gamma phi 
possible phi surjection 
type frame extensionality implies phi definition phi partial homomorphism 
theorem completeness full type frame 
infinite fx 
proof 
proved soundness earlier 
prove sufficiency noting lemma implies partial homomorphism full type frame fx term model chosen fx corollary 
theorem means desired 
partial special instance general notion called logical relation serves basic tools reasoning types 
properties logical relations developed tait statman howard howard statman statman statman statman tait semantics types programming languages continue topic interest applications 
general survey logical relations included mitchell burn furnishes example logical relations applied static analysis programs 
simple types domains simply typed calculus primitive serve programming language programming language typically provides notion evaluation simply equational theory 
directed equations simply typed calculus taken operational semantics resulting language somewhat 
evaluation considered structures needed model types account semantics computational concepts divergence recursive definitions 
section considers theory domains related semantics types basic language extends simply typed calculus judicious collection primitives order provide power programming language 
programming language computable functions 
system known pcf programming language computable functions introduced dana scott scott variant scott system described taken breazu tannen types terms defined follows num bool true false succ pred zero mm syntax pcf essentially includes terms simply typed calculus ground types num bool 
conventions pcf syntax similar basic simply typed calculus 
typing rules pcf simply typed calculus table table 
basic facts type system lemma 

carl gunter table 
typing rules pcf zero num true true bool false false bool pred num pred num succ num succ num iszero num zero bool cond bool rec parts analogs lemmas respectively 
operational semantics 
see pcf programming language need describe welltyped programs evaluated 
approach describing semantics indicate term evaluates term defining relation closed terms set evaluation rules 
goal rewriting obtain value rules apply 
order define precisely term related value define binary transition relation relation pairs pcf terms satisfies axioms rules table 
set evaluation rules form called structural operational semantics sos hypotheses rules involve evaluation proper structural components expressions 
approach semantics developed gordon plotkin plotkin plotkin say term evaluates value just case transitive reflexive closure transition relation value term generated grammar semantics types programming languages table 
transition rules call name evaluation pcf pred pred pred pred succ zero zero zero true zero succ false succ succ true false true false succ letters range values 
transition relation deterministic lemma 
way emphasize rules table represent grammar 
evaluation context pcf described grammar pred zero succ intended represent hole pcf term 
term pcf obtained evaluation context filling hole context term written 
examination grammar carl gunter reveals context exactly hole 
take analogs axioms opposed rules table pred pred succ zero true zero succ false true false desired relation defined rule approach describing structural operational semantics introduced felleisen friedman approaches describing evaluation programming language 
idea describe relation directly new set rules 
description known natural operational semantics semantics form resembles natural deduction system logic 
early instance semantics appears martin lof examples cl ement kahn standard ml milner milner tofte comparative discussion gunter look semantics pcf 
binary relation closed terms calculus 
binary relation defined relation satisfies axioms rules table 
description rules terms appear right side written letters values arbitrary terms 
read rules assume range terms 
proved induction height derivation terms term generated grammar 
words rules succ pred written form succ pred possible prove form value semantics types programming languages table 
natural rules call name evaluation pcf true true false false pred succ pred succ succ zero true succ zero false true false hard check partial function 
possible show gives semantics pcf sos theorem 
operational equivalence 
question various formulations operational semantics pcf types system 
assume perspective previous section consider question interpretations pcf types 
interpreting sets simply typed calculus leads problems wish interpret recursion 
best known approach resolving difficulty impose additional structure interpretations types certain kinds ordered sets ordinarily known domains 
assuming semantics interprets term type element interpretation modulo values free variables key issue relationship form semantics carl gunter operational semantics language described 
need analogs soundness completeness theorems earlier results relative operational semantics equational theory 
trick effect generate equational theory operational semantics study properties relative 
precisely done relative pre order imposed terms pre order induces desired equations 
pcf context essentially pcf term missing subterm marked place holder 
pcf term obtained filling hole term term denoted 
similar substitution placement context permits free variables bound variable scopes determined 
particular contexts terms considered equivalent modulo renaming bound variables 
evaluation contexts special class contexts missing subterm special position 
define key notion operational equivalence follows 
suppose terms type 
say operational approximation write context closed terms ground type implies possible prove pre order terms operationally equivalent write semantics delta said adequate implies said fully sound implies 
known adequate semantics pcf bc domains interpretation delta di domains interpretation delta 
describe briefly knowledge domain theory assumed definitions background abramsky jung bc domains di domains 
bc domain algebraic complete partial order bounded complete subset upper bound upper bound lub 
bc domains space continuous functions pointwise order bc domain 
domains model pcf types interpreting ground type expressions num bool flat cpo 
numbers element truth values true false respectively higher types 
meanings defined triples environment ae partial function assigns variable value semantics types programming languages ae 
meaning function assigns environment ae value ae definition function follows structure expression equivalently proof 
simply typed calculus fragment pcf interpretation looks 
arithmetic conditional expressions straight forward interpretation 
interpretation recursive functions takes advantage additional structure domains compared sets interpretation types ae fix 
ae 
fix function gives fixed point continuous function 
show definition sense proves lemma 
type assignment function 
ae 
continuous environment ae 
property easy establish induction height derivation tree proposition 

proving adequacy holds delta somewhat harder scope chapter 
interpretation pcf obtained bc domains distributive property define properties precisely stand upper bound greatest lower bound operators respectively 
definition 
bc domain said distributive xu tz fx yg upper bound 
algebraic cpo property fx ag finite compact element distributive bc domain satisfies property called di domain 
interpreting types pcf di domains requires crucial idea 
hard find di domains property continuous function space pointwise order di domain 
higher types model di domains interpreted construct 
key idea carl gunter definition 
continuous function di domains stable fx yg upper bound 
stable stable ordering write implies possible show di domains poset stable functions stable ordering di domain 
di domains give semantics delta pcf basically way bc domains give semantics delta 
prove analog lemma lemma 
function 
ae 
stable 
full abstraction 
algebraic cpo bounded completeness model calculus developed dana scott scott scott scott scott gunter scott di domains introduced gerard berry berry berry berry effort find fully model pcf gordon plotkin plotkin demonstrated bc domains model pcf fully 
plotkin proved failure directly operational semantics pcf result obtained semantically di domains non standard model 
need demonstrate terms operational behavior ground contexts fail equal model 
bool 
bool bool bool pcf terms table 
table omega divergent program boolean type instance bool 
term occurrence false fifth line 
programs operational behavior ground contexts 
see suffices adequacy di domains model show 
show fact 
arid environment semantics types programming languages table 
operationally equivalent programs different denotations bool 
bool bool true omega gamma omega gamma true false false omega true omega omega bool 
bool bool true omega gamma omega gamma true false false omega false omega omega assignments 
suppose 
happen true 
uncurrying 
true true true true true stable 
hand false false false false false contradicts monotonicity similar argument applies conclude terms operational behavior 
operational behavior omega gamma switching interpretations terms bc domain semantics show 
consider function por called parallel defined left truth table table values left column argument values top row second argument 
contrasted truth table left right sequential defined bool bool true note difference value true truth table table 
function por monotone finite domain carl gunter table 
truth tables parallel sequential disjunction por true false true true true true false true false 
true 
true false true true true true false true false continuous element interpretation bool 
bool bool 
por true false por delta fully 
shown berry di domains fully 
brief semantic proof bc domains model nonstandard interpretation 
show terms different meanings di domains model operational behavior 
define monotone functions truth value poset 
true function ae true 
function pointwise order functions unrelated stable order 
noting possible see function element bool bool bool true false 
consider programs omega true omega omega false omega type tags dropped reduce clutter 
clearly 
operational behavior 
see equation holds just note true function monotone pointwise ordered monotone functions type bool bool true 
semantics types programming languages problem finding fully model pcf long history 
ask pcf model ask extension pcf fully respect say bc domains semantics 
plotkin plotkin showed case language pcf fully bc domains model adds primitive computing parallel disjunction por stoughton interestingly similar way extending language di domains model jim meyer details full abstraction related topics gunter current research directions indicated concluding section chapter 
types invariants section idea presenting operational semantics pcf described 
semantics types terms domains interpretation related equivalence induced operational semantics 
basic relationship show operational semantics types language simple idea types invariants operational semantics 
property known subject reduction 
pcf sos table expressed follows theorem 
subject reduction theorem corollary 
form theorem useful proving certain kinds runtime errors avoided programs type correct 
runtime safety 
properties expected evaluation type correct program may hold arbitrary 
appreciate significance types look operational rules table 
take typical rule application call name rule describes derive value application attempt prove value carl gunter 
rule requires hypotheses established 
focus 
remarked value unique value satisfies relationship 
possibilities result attempt find value 
value 
term 
term form occur divergence reason 
second reach find value 
third case arises abnormal situation abstraction applied argument 
example happen attempted evaluate application number 
type correctness ensures third possibility occurs 
example clear type num type num required applied number 
third cases mean value important difference way failure occurs 
particular desired form possible report immediately attempt find value failed 
possible case failure find value may due infinite regression attempts apply operational rules happen term num example 
attempt determine case effective procedure fail tantamount solving halting problem 
case special 
guidance consider difference possibilities programming language 
example scheme program diverge applied argument define evaluating read eval print loop boring activity probably ended interruption programmer 
program diverges value 
hand happens attempt evaluate program read eval print loop 
value expression receive instant warning limitation may look application inapplicable object semantics types programming languages table 
operational rules type errors tyerr tyerr boolean tyerr number pred tyerr number succ tyerr number zero tyerr lambda tyerr difference outcomes arises distinction divergence runtime type error 
divergence generally undetectable runtime type error reported arises 
study ideas rigorously focus specific language 
grammar defines syntax type expressions terms calculus called pcf type errors 
extended calculus pcf inclusion new constant called tyerr 
expanded grammar num bool tyerr succ pred true false zero mm typing rules extended pcf pcf 
note particular relation tyerr fails typing rule proving relation 
rules natural operational semantics earlier table error rules table 
values new language pcf term tyerr type error 
rules table defined syntactic judgements boolean boolean set values boolean 
rules number set values numerical type numerals lambda higher type abstractions 
expanded set rules properties similar system explicit error elements 
example relation full language partial function differentiates system previous fact hypotheses rules cover possible patterns outcome evaluation 
evaluation term calls evaluation terms error rules indicate done result evaluating terms type error yields having wrong form 
carl gunter prove theorem says evaluation typed term produce type error 
precise statement theorem 
case tyerr 
result need show absence runtime type errors proved form subject reduction theorem 
case result proved relative typing system pcf evaluation relation defined relation satisfying rules table table 
theorem subject reduction 
term extended pcf 
proof 
proof induction height evaluation cases predecessor application recursion 
case pred 
possibilities step derivation employ induction hypothesis conclude num 
particular means number step derivation application rule succ number pred succ 
desired immediate num 
hand way succ num num possibility leads desired 
case 
say operational rules may apply evaluation application 
error rule table apply inductive hypotheses step evaluation form induction hypothesis lemma follows induction hypothesis case case lemma induction hypothesis 
theorem follows immediately tyerr type 
semantics types programming languages interest theorem intended assert evaluation typed program yield type error depends entirely nature error rules 
important examine closely see encode circumstances expect type error reported 
problem way asserting freedom runtime errors mistakenly omitting rule table theorem easier prove 
way express freedom runtime errors sos language assert result guarantee computation get stuck non value 
assertion pcf theorem 
value implicit types 
having type viewed primarily property program ensures desirable runtime behavior may convenience type correctness inferred automatically programmers relieved far possible need write type annotations 
leads idea implicit type explicitly part program 
program explicit types naturally provides type information key technical issue arises programs discussion focused entirely languages type term uniquely determined type tags property viewed differently type tags omitted 
consider calculus type tags 
tags gave types explicitly new system called implicitly typed simply typed calculus 
syntax language simply mm various syntactic conventions exactly ones earlier simply typed calculus type tags 
typing rules implicit system explicit calculus abstraction rule different properties 
rules table 
consider find type term respect rules table recalling shown earlier abs gamma leads failure lemma 
term form types need form type needs assuming type case looking type term type find type instances projection application rule carl gunter table 
implicitly typed calculus proj abs gamma appl choice arbitrary types form form precisely characterizes types type consider slightly interesting example typing derivation type steps form 
letting assignment derivation hypothesis top form match application rule case form hard see choice satisfying condition derivable type short types exactly characterized form 
suggests may way reconstruct general form type term implicit calculus 
types viewed variables type say type satisfies just case substitution instance 
important prospect type term semantics types programming languages determined type tags missing 
calculus pcf possible omit type tags ensure kind security asserted typed terms language theorem 
course terms type sense 
easy see pcf constants term clearly meaningless 
calculus gray area sensible term 
implicit system table judges term explicitly typed calculus table obtained erasing tags 
example impossible find type implicit typing system 
see suppose contrary term type 
derivation type instance abs gamma proof hypothesis instance appl axiom proj means type property type proper subterm 
contexts term sense 
example argued term harmless abstraction bound argument application applied 
calculus ml introduce type system viewed compromise implicit type discipline table essentially simply typed calculus untyped calculus typing system 
ml core representation system ml programming language 
goal provide level additional flexibility implicit typing discipline maintaining close link simply typed calculus 
key idea system inclusion syntax class parameterized types 
full grammar language follows pia mm addition primitive syntax class term variables new syntax class type variables added 
type scheme form carl gunter pia pia pia type variables bind occurrences variables type usual rules substitution ff equivalence apply type schemes expressions taken modulo ff equivalence substitution result free variable substituted type bound substitution 
words substitution oe oe pia pia pia pia oe implicitly assumed bound variable convention support oe free occurrence oe support oe 
write ftv free type variables scheme language includes new construct terms called 
expression free occurrences free occur bound 
typing rules ml include generalization projection rule implicit system allows type variable type obtained instantiating pi bound variables scheme associated type assignment 
definition 
type said instance type scheme pia pia substitution oe support contained fa ang oe instance write assignments ml defined similarly assignments simple types ml type assignment associates type schemes term variables 
specifically assignment list pairs term variable type scheme 
set free type variables ftv assignment union sets ftv give typing rules system necessary define notion closure type relative assignment 
function assignments types close pia pia fa ang ftv gamma ftv 
assumed function close chooses particular order pi bindings matter order simply assume typing judgements defined relative particular choice function close 
typing judgement triple fl assignment term type 
typing rules system appear table 
symbol fl place system distinguish implicit system table system compared table precise 
rules semantics types programming languages table 
typing rules ml proj fl abs gamma fl fl appl fl fl fl fl close fl fl abstraction application implicit typing system 
rule proj variables different type variable instance type scheme 
rule construct gives type assignment type associated closure type note rule clause term grammar language hypotheses rule judgements subterms term 
basic property type variables substitution system lemma 
fl fl particular ftv fl implies fl implicit simply typed system ml type term 
bound appropriate value term type 
see specific example take identity combinator type variable show type fl fl follows proj abs gamma proj hypotheses instance abs gamma pia fl pia fl 
pia fl carl gunter note particular possible instantiate pi bound variable type hypothesis simply 
derivations hypotheses instance rule fl pia fl fl important characteristics typing system fact determine term type assignment 
assignment substitution oe oe assignment associates oe xn tn oe oe xn oe assignment term define set pairs oe oe substitution type oe fl algorithm provides element algorithm succeeds 
describe algorithm background substitutions required 
oe substitutions 
oe said general substitution oe oe ffi oe types unifier substitution oe oe oe 
general unifier unifier oe general unifier types 
theorem 
unifier pair types general unifier 
theorem algorithm calculating general unifiers introduced robinson reason introducing unifiers point describe algorithm robin milner milner called algorithm induction structure cases ffl case value identity substitution paired instantiation scheme collection fresh type variables 
words pia pia new type variables id id identity map 
value failure 
ffl case suppose new type variable oe 
semantics types programming languages oe oe hand value failure 
ffl case 
suppose oe oe oe 
new type variable 
general unifier oe oe oe ffi oe ffi oe oea event unifier value oe failure value 
ffl case suppose oe oe close oe 
oe oe ffi oe hand value failure value 
prove algorithm sound helps lemma 
pia pia fl close fl understand note bound variable convention insists variables appear ftv 
desired soundness property stated precisely follows theorem 
exists element 
proof 
suppose exists show oe fl proof induction structure variable instantiation 
means fl typing rule variables 
case oe oe fl inductive hypothesis 
oe oe fl oe fl oe typing rule abstraction 
means oe oe 
case 
oe oe oe inductive hypothesis oe fl oe oe fl exists substitution oe oe oe carl gunter oe oe oe 
lemma oe ffi oe ffi oe fl oe ffi oe oe ffi oe ffi oe fl oe oe inductive hypothesis oe ffi oe ffi oe fl oe combining facts rule typing applications conclude oe ffi oe ffi oe fl oe means 
case oe oe oe close oe inductive hypothesis oe fl oe fl lemma oe ffi oe fl oe pia pia close oe oe ffi oe pia pia oe fl lemma oe ffi oe close oe ffi oe oe fl rule typing lets says oe ffi oe 
course proves answer calculated sound question addressed damas milner led formulation theorem describing sense type inferred algorithm best type possible 
precise definition 
principal type pair oe pair substitution oe ffl oe ffi oe ffl instance oe close oe 
case empty assignment boils saying closed term type type semantics types programming languages type type type substitution damas milner state theorem 
type fl principal type scheme proof appears thesis damas practice optimizations done provide efficient implementation principal type scheme inference 
discussion implementation appears cardelli books ml include discussion ml type inference instance provides code unification inference standard ml module system 
runtime safety assignments continuations 
appreciate value algorithm necessary consider connection way programs evaluated 
specified mean matter trivial unimportant contrary topic requires careful consideration pitfalls avoided 
straight forward approach semantics term treat operationally application typing system ml treats terms differently possible treat operationally 
approach taken standard ml definition 
leads complexities considers interaction certain computational extensions evaluation order 
consider issue look possible solution proposed leroy assume language call value evaluation order extended primitives rule pairs appear table 
desired sequencing operator included syntactic sugar appear algorithm easily adapted deal extra constructs 
new primitives treated free variables appropriate type schemes inference pairs done componentwise 
unfortunately approach causes difficulties taken usual evaluation order construct construct viewed syntactic sugar application described 
classic example difficulty algorithm language program written pseudo code compromise standard ml ml ref fn 
update fn 
deref true carl gunter table 
assignments continuations pairs 
ref pia ref deref pia ref update pia ref theta callcc pia cont throw pia pib theta cont fst pia pib theta snd pia pib theta theta program pass algorithm type pia ref suppose primitives ref update deref treated having semantics standard ml analogs ref semantics sml 
runtime error dereferenced attempt add true 
problem update operation instantiates type type dereferenced value inappropriate specialization polymorphic type point applied true 
similar problem arises addition control primitives callcc throw language 
suppose primitives semantics callcc application continuations scheme 
duba harper macqueen duba noted algorithm may typecheck programs constructs yield runtime errors 
example leroy callcc fn 
fn 
fn 
throw fn 
print hello world second fn 
invoked continuation essentially carries reassignment identifier 
see problem trace semantics types programming languages evaluation 
binding coordinate identity function invoked string printed 
second coordinate invoked function thrown coordinate pair previously captured continuation point evaluation proceeds manner program fn 
fn 
print hello world second fn 
leads type error applied leads addition string 
variety proposals deal problems restricting ml type system damas tofte alternative change evaluation order expressions 
illustrate idea consider extension ml call ml grammar theta ref cont pia mm ref deref update callcc throw fst snd typing rules ml types constants pairs 
inclusion assignments language leads incorporate notions environment store semantics inclusion class continuations leads consider control 
earlier semantics idea store ignored 
environments avoided syntactic substitution instantiate formal parameters actual parameters control expressed indirectly hypotheses rules sos natural semantics 
consider alternative way describing semantics essentially machine 
machine described collection transition rules environments store control explicit 
machine essentially reformulation natural semantics appearing leroy closely resembles machine felleisen friedman describe require concepts 
grammar defines values continuations thunks terms environments ae stores oe carl gunter location closure ae apply ae apply pair ae pair thunk ae environment ae partial function finite domain called environment maps variable value thunk store oe partial function finite domain called store maps locations values machine terms set rewrite rules involving operators push pop 
operator push ae oe takes term environment ae store oe continuation arguments 
operator pop oe takes value store oe continuation arguments 
terminate rewrite rules produce pair oe type error tyerr 
relation defined satisfying rules table 
assume function new stores locations new oe location domain definition oe 
function semantics ref constant allocating new locations memory 
intuitively push machine evaluates term stages delaying parts calculation pushing chores represents continuation stack 
evaluation reaches value pop machine invoked consult continuation stack determine done value 
key result theorem 
type correct case push tyerr proof requires establishing set type invariants environments stores continuations 
fact shown suitable formulation types values push 
oe type oe approach dealing semantics restrict declaration polymorphism permitted expressions require evaluation 
illegal write programs higher order composition function expansion write fn 

andrew wright introduced idea wright able demonstrate practicality number substantial sml programs 
semantics types programming languages table 
machine ml push ae oe pop ae oe ae value push ae oe push ae oe ae thunk ae push ae oe pop closure ae oe push mn ae oe push ae oe apply ae push ae oe pop oe push ae oe push ae oe pair ae push ae oe push ae 
thunk ae oe push ae oe tyerr cases pop oe apply ae push ae oe apply pop oe apply closure ae push ae 
oe pop oe apply ref pop new oe oe new oe 
pop oe apply deref pop oe oe pop oe apply update pop oe 
pop closure ae oe apply callcc push ae 
oe pop oe apply throw pop oe pop oe apply fst pop oe pop oe apply snd pop oe pop oe pair ae push ae oe pair pop oe pair pop oe pop oe 
oe pop oe tyerr cases types subsets far modeled types objects drawn collection spaces syntactic invariants 
closed typed term denotes value space interprets type expresses property unchanged evaluation term 
consider perspective type viewed subset universe elements modeling terms 
approach meaning closed typed term member universe lies subset universe interprets type ways view subsets resulting different models 
discussion begins carl gunter examination interpretation untyped calculus model simply typed calculus satisfies special equation 
consider model untyped calculus viewed model typed interpreting types subsets 
untyped calculus 
untyped calculus essentially calculus obtained removing type system simply typed calculus 
terms untyped calculus generated grammar mm abstraction variable term binds free variable occurrences 
terms implicitly typed system 
expressions range untyped terms typed terms context determine class terms intended 
discussions relating typed untyped calculi terms type tags tags 
untyped terms subject conventions bound variables applied earlier terms type tags bound variables 
particular terms considered equivalent renaming bound variables renaming leads capture variable new binding 
equational rules untyped fi calculus table 
similar typed calculus 
untyped fij calculus obtained including untyped version rule fjg variable appear free expression hard see term simply typed calculus gives rise term untyped calculus obtained erasing type tags free variables 
precisely define erasure erase term simply typed calculus induction follows erase erase erase erase erase erase term untyped calculus obtained erasure tagged case untyped term obtained erasure typed tagged term 
example erase context type expression semantics types programming languages table 
equational rules untyped fi calculus ffig course distinct typed terms may erasure differ tags bound variables erase erase model untyped calculus 
possible describe semantics untyped calculus simply typed calculus 
interpretation deal concept self application see term care applied explaining untyped term interpreted typed setting operation type correct 
approach follows meyer view application entailing implicit coercion converts application instance value corresponding function 
precisely assume constants phi 
psi equational theory equation phi ffi psi carl gunter call theory fi model theory fi tuple phi psi type frame phi psi satisfy 
simplify notation distinction phi psi constant symbols calculus interpretations model 
may model theory fi interpret untyped fi calculus way 
define syntactic translation converts untyped term term type tags induction follows psi phi example follows xx xx psi phi psi phi phi psi phi phi possible demonstrate basic fact translation proposition 
untyped term 
xn type context includes free variables translation possible assign meaning untyped term au see respects equational rules table note lemma 
prove fi rule untyped calculus calculation typed phi phi psi au axioms rules difficult 
semantics types programming languages theory fij theory fi equation psi ffi phi asserts effect phi isomorphism ground type functions model theory fi model theory fij satisfies rule fi rule 
see suppose variable appear free term psi psi phi psi phi 
summary result 
theorem 
model fi au model untyped fi calculus 
model fij model untyped fij calculus 
models untyped calculus 
having established models theories fi fij provide models untyped fi fij calculi respectively tempting conclude completed quest models untyped calculus 
fact done easy part 
shown models theories fi fij exist 
see problem consider full type frame fx set find functions phi 
psi set functions satisfy equation produced desired model 
equation implies function phi surjection set functions cantor theorem surjection exists exactly point 
means full type frame yield trivial model untyped calculus choice phi psi 
problem lies fact interpretation full type frame functions 
find model untyped calculus look type frame parsimonious interpretation higher types 
techniques finding models satisfy properties primary purpose theory domains scope carl gunter chapter discuss done detail 
sake concreteness build domain explicitly 
set set finite subsets define operation xg starting set xn xn 
take dx set 
xn subsets union xn 
ordered set inclusion algebraic lattice compact elements finite sets 
see viewed model untyped calculus consider element xn 
pair viewed piece function output subset input 
suppose dx intuition define function phi dx dx phi fx dg dx words view inducing function argument result applying set elements piece element subset input continuous function dx dx define psi dx psi says represented recording pairs part result applying element contains difficult check phi psi continuous 
suppose dx dx continuous 
phi psi fx psi dg fx dg ff dg step follows fact continuous function algebraic cpo determined action compact elements 
model simply typed calculus defined dx interpretation ground type interpreting higher types pointwise ordered continuous function spaces 
follows calculation continuous type frame generated dx continuous functions phi psi model untyped fi calculus 
obviously non trivial distinct elements 
semantics types programming languages dx model untyped fij calculus 
suppose dx attempt calculate equation psi phi phi dg arbitrary subset xn clear superset relation may fail equality 
demonstrated model fij calculus 
cpo continuous functions need cpo 
domain theory helpful finding spaces needed properties 
know find non trivial domains satisfy isomorphisms details domains constructed see abramsky jung inclusive subsets types 
domain universe interpreting types generally called universal domain 
desirable arbitrary subsets universal domain denote types certain properties needed establish invariants 
consider widely conditions 
definition 
subset cpo inclusive downward closed closed upper bound chains 
term inclusive notion slightly non standard historical perspective 
condition introduced milner common term ideal macqueen clashes common usage ideal alternate term inclusive 
universal domain possible inclusive subsets model simple types 
domain suppose solution domain equation phi equation operator phi coalesced sum takes disjoint union arguments identifies respective elements 
model untyped calculus psi injection cpo continuous functions right component note function 
set phi phi ae psi continuous carl gunter easy see phi ffi psi id associate inclusive subsets types simply typed calculus define psi lemma 
type subset inclusive subset 
type assignment environment ae defined function variables ae interpretation induction structure relative environment ae follows ae ae ae phi ae ae ae psi 
ae 
key result relating interpretation interpretations types theorem 
ae environment ae 
problem interpreting types way equational rules satisfied 
see case suppose domain equation element define terms meaning calculated psi 

psi 
psi 

psi 
psi 
phi 

psi 
psi 
phi value psi 

psi 
suppose 
phi phi 
see calculate phi phi psi 
psi 
phi semantics types programming languages psi 
phi psi 

psi 
phi phi psi 
terms provably equal equational theory 
projection rule rule equation satisfied model 
problem lie 
rule originally suspect rule satisfied interpretation 
problem soundness rule terms denote functions applied model elements wrong type values may differ 
construction solves problem consider model useful satisfying full equational theory calculus 
idea milner give semantic proof result theorem 
milner proof calculus ml idea illustrated adequately pcf 
look analog theorem pcf type errors pcf new expression tyerr type expanding operational rules table include rules type errors table 
give fixed point model calculus domain isomorphism phi 
phi phi equation operation 
lift adds new bottom element domain obvious maps 
relating domain space lattice denote non bottom element tyerr save notation meaning term tyerr 
carl gunter write injection element component sum 
example 
injection 
second component usual semantics term relative environment ae 
ffl ae ae 
ffl ae ae tyerr tyerr ae 

ffl ae ae ae ae tyerr 
ffl ae fix 
ae 

ffl tyerr ae tyerr 
remaining constructs pcf straight forward interpretation true lemma 
type inclusive subset 

ae environment ae 

point lemma theorem 
tyerr 
see note 
tyerr follows tyerr case tyerr 
subtyping subset inclusion 
return topic subtype discussed section 
discussion idea subtype subset intuition 
inclusive predicates possible intuition formal model 
illustrate consider pair extensions pcf 
type system considered ideas reynolds cardelli semantics basically cardelli semantics types programming languages table 
typing rules records variants delta delta delta mn tn fl mng fl tng fl tng tn tn tn delta delta delta mn tn case delta delta delta mn extend pcf language includes records variants extension called pcf pcf plus records variants 
define terms require primitive syntax class labels label 
grammar variable label num bool fl tg true false succ pred zero mm fl mg case ellipsis notation dots indicate finite lists pairs records variants 
types terms pcf expressions generated grammar repeated labels lists label type label term pairs 
terms pcf taken modulo ff conversion renaming bound variables order fields records variants written 
similar equivalence assumed record variant type expressions 
typing rules pcf pcf tables rules records variants table 
quite similar rules products sums 
sum essential label variations ensure variant unique type 
general carl gunter table 
rules subtyping num num bool bool delta delta delta fl fl ng delta delta delta theorem 
true calculus pcf consider 
pcf extension pcf allow subtyping relation types 
binary relation subtyping type expressions defined rules table 
possible show poset type expressions 
calculus pcf pcf typing rules pcf extended addition subsumption rule 
type derived term subsumption derived essential distinguish typing judgements pcf pcf 
write sub relation contains relation pcf satisfies sub sub operational semantics pcf pcf similar pcf language evaluated call value call byname 
rules table pcf pcf rule evaluation applications replaced rule evaluation records variants rules table 
model pcf extending inclusive subsets interpretation pcf 
need domain similar equation 
define phi 
phi phi label phi label theta phi semantics types programming languages table 
rules call value evaluation records variants delta delta delta mn vn fl mn fl vng fl vn case fn write injection element component sum 
example injection continuous function third component semantics types defined follows ffl fl fr label ng ffl fe label theta ffl ff semantics term sub relative environment ae 
ffl fl mn ae label ae ae tyerr ffl ae ae ae label tyerr ffl ae ae label theta ffl case delta delta delta mn ae ae label theta ae carl gunter ae tyerr difficult check property interpretation lemma 
type subset ae inclusive 
suitable choice definitions arithmetic expressions possible arrange case tyerr types pcf 
interpretation allows intuitive liberty thinking meaning meaning subset meaning theorem 

converse theorem holds assume solution equation algebraic cpo countable basis 
theorem 
ae environment ae 



tyerr 
types partial equivalence relations resume discussion parametric polymorphism begun earlier considering type systems express notion 
goal study distinction predicative impredicative definitions types show modeled interpreting types equivalence relations subsets universal domain 
system ml example predicative system demonstrating settheoretic model system considering alternative presentation typing rules 
system generalized best known impredicative system girard reynolds polymorphic calculus 
modeling impredicativity girard reynolds system demands subtlety shown done interpreting types equivalence relations subsets universal domain 
semantics types programming languages sets model ml types 
go back consider semantics ml goal provide model polymorphic types analogous full type frame simple types 
recall syntax types type schemes terms language pia mm necessary forms environment model language 
types may contain variables need notion type value environment function maps types semantic domains 
environment mapping ae assigns element ae 
ml sets drawn collection obtained constructing full type frame 
non empty set serve analog interpretation ground type 
sets define set functions define fx dn fy dn dn universe interpretation set 
dn model types ml interpret type schemes types 
operator set define dependent product determined set pi consists functions precise nature maps taken functions domain range satisfying constraint 
interpretation types type schemes follows ffl ffl ffl pia pi 
easy see element type universe closed exponentiation 
note pia need element despite fact type variables mapped elements implicitly working universes 
interpreting types second contains carl gunter sets interpretations type schemes 
precise define vn vn vn meaning pia ae type scheme element second universe 
vn interpretation terms ml subtle types 
write equations semantics full consider describe defined function 
ffl suppose fl pia pia oe substitution oe letting oe define ae ae delta delta delta xn 
ffl ae function defined 
ae 

ffl ae ae ae 
ffl suppose close pia pia fl define close delta delta delta xn 
xn ae ae close ae 

primary question sense definition concerns type value environment 
xn semantic equation construct compatible environment ae ae environment 
question resolved recalling type variables ftv noting lemma 
ae environment ftv 
environment 
follows fact 
free typing system ml light semantics just gave type system ml appears slightly indirect ways 
rule instance meaning term calculated parameterized version meaning bound environment 
similarly meaning variable drawn environment instantiated type assigned permitting judgements form type scheme rules generalization instantiation lead elementary system 
semantics types programming languages table 
typing rules ml pi elimination proj abs gamma appl pi intro gamma ftv pia pi elim gamma pia possible reformulate typing system ml way 
rules deriving judgements appear table 
rules abstraction application remain unchanged rules projections constructs reflect general form judgement system 
new system projection rule looks way systems considered having somewhat different form table 
close operator longer rule term hypothesis may type scheme type generalized variables real difference systems lies presence rules elimination pi bindings 
particular difference addition rules fact derivation judgement uniquely determined fact superficially distinct proofs judgement obtained alternating application rules pi intro gamma pi elim gamma possible show systems essentially judgements types 
proposition 
type assignment term type 

fl 
fl carl gunter polymorphic calculus 
calculi considered type annotations terms force typeable term unique type 
rules tagged superscript minus sign typing system ml described table cause property fail 
recover place type tags bound variables rules pi intro gamma pi elim gamma pose problem 
effect terms contain indication generalization instantiation type variables types uniquely determined 
consider important generalization ml explicit abstraction application type variables terms 
system called girard reynolds polymorphic calculus system discovered independently girard girard working proof theoretic problem reynolds reynolds interested programming language design 
possible exception ml polymorphism best known polymorphic type system simply called polymorphic calculus 
reader refered survey scedrov fuller discussion polymorphic calculus including historical background 
terms language follows pia term form called type abstraction form called type application 
types form pia called pi types type variable bound pia pi quantification 
clauses define free type variables types terms ffl ftv ffl ftv ftv ftv ffl ftv pia ftv gamma fag ffl ftv ffl ftv ftv ftv ffl ftv ftv ftv ffl ftv ftv gamma fag ffl ftv ftv ftv assignment set free type variables ftv union free type variables substitution semantics types programming languages table 
typing rules polymorphic calculus pi intro ftv pia pi elim pia types terms respect bindings sense free variable term substituted captured binding term substitution 
types terms polymorphic calculus may built type variables 
example typed term type 
ml systems polymorphic calculus allows type variables explicitly abstracted terms 
example term type pia pib 
possible instantiate abstracted type variables form application 
types example equivalent term 
term type 
precise typing rules polymorphic calculus table rules appear table 
course rules table understood applying terms polymorphic calculus grammar language just terms simply typed calculus 
earlier calculi type tags bound variables ensure lemma 
type assignment term type expressions virtue polymorphic calculus express general algorithms clear way 
example return problem illustrated earlier program define lambda cons hi function takes function argument applies components pair returning pair result 
carl gunter table 
equational rules polymorphic calculus pia ftype pia ftype fig fsg ftype jg pia pia restrictions ffl ftype free occurrence type variable ffl ftype jg type variable appear free similar program written polymorphic calculus extended pairs pib types explicitly instantiated part application program general written ml convincing programming examples shows phenomenon arises quite naturally 
equational rules pure polymorphic calculus table rules appear table modulo theory appears left hand sides 
new rules ftype assert type application type abstraction congruences 
fundamental new rules type level analogs ftype fig ftype jg fi rules 
sets model polymorphic types 
interpretation polymorphic calculus serious challenges semantics programming languages 
course define polymorphic calculus generally relative theory discussion empty theory 
semantics types programming languages possible construct term model calculus earlier simply typed calculus 
finding model analogous full type frame harder 
appreciate primary reason difficulty attempt provide model partial analogy ml need notion type value environment maps type variables semantic interpretations sets 
interpretation type function takes type assignments indicating meanings free variables sets 
full type frame define arrow right full function space operator 
central question interpret pia 
naively take product sets indexed sets element pia function associates set element set 

function called section indexed family 


improve readability expressions involving sections write application section set argument subscript 
example section 



provide semantic interpretation terms want know form substitution lemma holds types 

type value environment type assignment say ae environment ae interpretation function takes type value environment environment argument returns value 
helps drop type information interpreted expression write ae save clutter types clear context 
interpretation terms defined induction structure 
interpretation abstraction ae term variables function defined 
ae 
hand interpretation application term term usual application function argument ae ae ae 
considering interpretation application term pia type recall pia ae section indexed family 


take ae pia ae 
squares claim 

meaning type abstraction pia ae section indexed family 



ae 
show ae 
value environment follows restriction pi intro says type variable appear semantics just sketched sufficiently simple convincing early discussions semantics carl gunter calculus reynolds stands problem interpretation types 
type presumably function type value environments sets 
consider type pia naively interpreted family sections indexed family 
words pia product sets 
assume product set needed interpretation 
consider instance term pia 
term interpreted section sets interpreted application section meaning pia leads foundational question concerning collections considered sets 
crucial discoveries logicians late nineteenth early twentieth centuries fact care taken collections entities formed troubling paradoxes avoided 
paradoxes caused intricate carefully constructed theories foundations mathematics collapse nonsense 
best known important paradoxes russell paradox named philosopher logician bertrand russell 
described quite simply follows 
assume property define collection entities 
define collection collections having property element clear think know means entity part collection 
ask 
property common elements member 
contradiction postulated member 
suppose hand member 
contradiction defined collections having exactly property 
returning polymorphic calculus problem interpretation avoid russell paradox 
technically problem restrictions placed formation sets impossible view product sets set 
underlying phenomenon recognized russell mathematician philosopher science henri poincar property called impredicativity 
set entity defined member defined definition said impredicative 
clearly case russell paradox applies class semantic domains attempting modeling types polymorphic calculus domain serve interpretation pia problem resolution dealing sets shown reynolds reynolds refined treatment appears reynolds plotkin look class semantics domains interpret types 
semantics types programming languages simple types 
recall problem cited earlier inclusive predicates model types rule satisfied 
approach solving problem equivalence relation subsets universal domain induce needed equalities 
particular definition 
set 
partial equivalence relation relation theta transitive symmetric 
domain partial equivalence relation set dom fa ag 
write mean note set domain axioms 
suppose model untyped calculus 
say phi psi satisfy phi ffi psi id take define interpretations types structural induction follows 
suppose iff implies phi phi 
easy check relations partial equivalence 
see interpret terms semantic function gives untyped meaning typed terms 
term simply typed calculus meaning untyped term erase pair phi psi 
element dom equivalence class relative fe 
term typed calculus meaning relative function ae variables ae domain relation function called environment interpretation 
interpretation term quite simple ae ae basic facts proved interpretation 
type interpretation domain relation 
second equational rules typed calculus satisfied 
establishing properties involves proving slightly general facts 
environments ae define ae ae 
carl gunter lemma 
suppose ae environments ae ae 
proof 
proof induction structure ae implies desired 
case suppose phi ae phi psi 
ae 
ae 
similarly phi 

ae 

inductive hypothesis 
desired follows definition 
case inductive hypothesis ae 
inductive hypothesis phi ae ae ae phi 
corollary 
ae environment ae domain relation 
lemma 
ae environments ae proof 
proof induction height derivation judgement 
way illustration consider case step proof instance rule 
suppose step derivation instance inductive hypothesis ae 

ae definition 
ae 
corollary 

semantics types programming languages model polymorphic types 
seen model phi psi untyped calculus interpret types simply typed calculus consider interpret types polymorphic calculus 
extension define meaning type relative type value environment maps type variables 
interpret pia indexed family type value environment free type variables pia domain 
want define meaning product relations 
ranges says related modulo 
pia 
defines partial equivalence relation intersection 
notice role impredicativity equation intersection ranges class 
course interprets pia collection problem existence case intersection set sets set 
interpretation function spaces 
erasure term polymorphic calculus defined induction follows ffl erase ffl erase erase ffl erase erase erase ffl erase erase ffl erase erase meaning term defined meaning untyped term erasure 
assume retraction define meaning untyped term erase element dom equivalence class relative fe 
term polymorphic calculus meaning relative type value environment function ae variables ae domain relation 
interpretation term ae ae carl gunter complete demonstration defines model shown term type interpretation relative environment domain relation equational rules polymorphic calculus satisfied 
treatment follows general pattern argument interpretation simple types 
start basic lemma 


lemma 
suppose ae environments ae ae proof 
proof induction structure look cases type abstraction application 
pia ae 
inductive hypothesis 
erase erase interpretation pia intersection form 
ae pia suppose fsg 
pia applying inductive hypothesis ae 
particular ae 
erase erase lemma ae corollary 
ae environment ae domain relation 
semantics types programming languages lemma 
ae environments ae ae corollary 

detailed treatment topics chapter including complete proofs theorems gunter great deal material semantics types chapters handbook 
said models described sections example seminal bruce longo bruce longo quite successful model subtypes parametric polymorphism glean scedrov just scratched surface said model parametric polymorphism 
models ones covered subject semantics types categorical objects omitted see poign rapidly evolving theory types games abramsky particularly hosts type systems discussed chapter 
large category touched types object oriented programming languages 
reader pursue topic gunter mitchell palsberg 
second semantics recursive types importance hinted section discussed detail remainder chapter reader pursue topic consulting gunter third important class type systems modules starting point harper mitchell moggi acknowledge samson abramsky encouraging undertake discussion semantics types 
sandip biswas roy crole narciso mart oliet help proof reading drafts 
abelson sussman abelson sussman 
structure interpretation computer programs 
mit press 
abramsky jung abramsky jung 
domains 
abramsky gabbay maibaum editors handbook logic theoretical computer science pages 
oxford university press 
abramsky abramsky jagadeesan malacaria 
games full abstraction pcf ii second preliminary announcement 
manuscript 
barendregt barendregt 
lambda calculi types 
abramsky gabbay maibaum editors handbook logic theoretical computer science volume background computational structures pages 
oxford university press 
berry berry 
curien 
levy 
full abstraction sequential languages state art 
nivat reynolds editors algebraic methods semantics pages 
cambridge university press 
berry berry 
stable models typed calculus 
international colloquium automata languages programs pages 
lecture notes computer science vol 
springer 
berry berry 
mod eles compl ad des typ es 
th ese etat university paris vii 
breazu tannen breazu tannen gunter scedrov 
computing coercions 
wand editor lisp functional programming pages 
acm 
bruce longo bruce longo 
modest model records inheritance bounded quantification 
information computation 
burn burn hankin abramsky 
strictness analysis higher order functions 
science computer programming 
cardelli cardelli 
basic polymorphic typechecking 
science computer programming 
cardelli cardelli 
semantics multiple inheritance 
information computation 
cl ement cl ement despeyroux despeyroux kahn 
simple applicative language mini ml 
symposium lisp functional programming pages 
acm 
damas milner damas milner 
principal type schemes functional programs 
principles programming languages pages 
acm 
damas damas 
type assignment programming languages 
phd thesis edinburgh university 
duba duba harper macqueen 
typing class ml 
conference record eighteenth annual acm symposium principles programming languages pages 
acm 
felleisen friedman felleisen friedman 
control operators secd machine calculus 
wirsing editor formal description programming concepts iii pages 
north holland 
friedman friedman 
equality functionals 
parikh editor proceedings logic pages 
lecture notes mathematics vol 
springer 
girard girard 
interpr etation fonctionelle elimination des coupures de arithm etique ordre sup erieur 
th ese etat university paris vii 
gunter mitchell gunter mitchell editors 
theoretical aspects object oriented programming types semantics language design 
mit press 
gunter scott gunter scott 
semantic domains 
van leeuwen editor handbook theoretical computer science pages 
north holland 
gunter gunter 
semantics programming languages structures techniques 
foundations computing 
mit press 
gunter gunter 
forms semantic specification 
rozenberg salomaa editors current trends theoretical computer science essays tutorials pages 
world scientific publishers 
harper mitchell harper mitchell 
type structure standard ml 
acm transactions programming languages systems 
appear 
hindley seldin hindley seldin 
combinators calculus 
cambridge university press 
howard howard 
hereditarily functionals finite type 
troelstra editor metamathematical investigation intuitionistic arithmetic analysis pages 
lecture notes mathematics vol springer 
iee ieee computer society new york 
ieee standard scheme programming language ieee standard edition 
jim meyer jim meyer 
full abstraction context lemma 
ito meyer editors theoretical aspects computer software volume lecture notes computer science pages 
springer verlag september 
kahn gilles kahn 
natural semantics 
proceedings symposium theoretical aspects computer science pages 
springer verlag 
leroy leroy 
polymorphism name continuations 
graham editor conference record twentieth annual acm sigplan sigact symposium principles programming languages pages 
acm 
macqueen macqueen plotkin sethi 
ideal model recursive polymorphic types 
information control 
martin martin lof 
intuitionistic theory types 
unpublished 
meyer meyer 
model lambda calculus 
information control 
milner tofte milner tofte 
commentary standard ml 
mit press 
milner milner tofte harper 
definition standard ml 
mit press 
milner milner 
theory type polymorphism programming 
journal computer system sciences 
mitchell mitchell 
types systems programming languages 
van leeuwen editor handbook theoretical computer science pages 
north holland 
moggi moggi 
category theoretic account program modules 
mathematical structures computer science 
palsberg palsberg 
objectoriented type systems 
wiley 
plotkin plotkin 
powerdomain construction 
siam journal computing 
plotkin plotkin 
structural approach operational semantics 
technical report fn computer science department aarhus university ny munkegade dk aarhus denmark 
poign poign 
basic category theory 
abramsky gabbay maibaum editors handbook logic theoretical computer science volume background mathematical structures pages 
oxford university press 
reynolds plotkin reynolds plotkin 
functors expressible polymorphic typed lambda calculus 
erard huet editor logical foundations functional programming university texas austin year programming pages 
addison wesley reading massachusetts 
reynolds reynolds 
theory type structure 
robinet editor programming symposium pages 
lecture notes computer science vol 
springer 
reynolds reynolds 
category theory design implicit conversions generic operators 
jones editor semantics directed compiler generation pages 
lecture notes computer science vol 
springer 
reynolds reynolds 
types abstraction parametric polymorphism 
mason editor information processing pages amsterdam 
elsevier science publishers 
north holland 
reynolds reynolds 
polymorphism set theoretic 
kahn macqueen plotkin editors semantics data types pages 
lecture notes computer science vol 
springer 
robinson robinson 
machine oriented logic resolution principle 
journal acm 
scedrov scedrov 
guide polymorphic types 
odifreddi editor logic computer science pages 
academic press 
scott scott 
type theoretical alternative cuch iswim 
unpublished manuscript 
scott scott 
data types lattices 
siam journal computing 
scott scott 
ordered sets computer science 
rival editor ordered sets pages 
reidel 
scott scott 
domains denotational semantics 
nielsen schmidt editors international colloquium automata languages programs pages 
lecture notes computer science vol 
springer 
scott scott 
lectures mathematical theory computation 
broy schmidt editors theoretical foundations programming methodology pages 
nato advanced study institutes series reidel 

applicative high order programming standard ml perspective 
chapman hall 
statman statman 
completeness invariance definability 
journal symbolic logic 
statman statman 
equality functionals 
harvey friedman research foundations mathematics pages 
northholland 
statman statman 
logical relations typed calculus 
information control 
statman statman 
translating lambda terms combinators basis problem 
meyer editor symposium logic computer science pages 
acm 
stoughton stoughton 
parallel operations pcf 
theoretical computer science 
tait tait 
intensional interpretation functionals finite type 
journal symbolic logic 
tennent tennent 
denotational semantics 
abramsky gabbay maibaum editors handbook logic theoretical computer science 
oxford university press 
tofte tofte 
type inference polymorphic 
information computation 
wright wright 
polymorphism imperative languages imperative types 
technical report comp tr department computer rice university 
