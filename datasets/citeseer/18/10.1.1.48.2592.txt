formal specification prototyping program specializer philippe cedric iie jean vry cedex france iie cnam fr www iie cnam fr 
reports formal specifications development software maintenance tool specializing imperative programs complex due extensive modifications 
tool specified terms inference rules operates induction syntax 
correctness rules proved rule induction 
prolog prototype derived fortran programs centaur programming environment 
keywords structured operational semantics vdm software maintenance program specialization proof correctness rule induction centaur 
developed original technique specializing programs difficult maintain general 
programs written imperative language noted sequel 
technique aims understanding old programs complex due extensive modifications 
program form restriction usage knowledge specific values input variables technique provides simplified program behaves initial restriction 
approach particularly adapted programs evolved application domains increase continually 
technique variant partial evaluation known technique optimization derive compilers interpreters 
partial evaluation subject program respect input variables values gives residual program input variables executions produce results 
program obtained replacing variables constant values propagating constant values modifying statements instance replacing alternative condition simplifies constant value corresponding branch unfolding loops possible 
aim differs traditional partial evaluation 
try optimize code improve readability mainly simplifying 
example expand loops 
explained aim tool development 
focus formal concepts developing 
residual programs maintenance 
visualized locate anomalies debugging independent programs initial ones 
tool software maintenance tool published proceedings tapsoft aarhus may lncs pp 
introduce absolutely unforeseen changes programs 
formally specify specializer prove correctness specification respect standard semantics eventually third step prove correctness implemented tool respect specialization rules 
develop steps process 
specification prolog prototype systematically derived centaur programming environment 
industrial tool developed specification 
specification expressed inference rules operating syntax language precisely natural semantics formalism augmented vdm operators 
natural semantics origin plotkin 
name structured operational semantics gives inference rules direct formalization intuitive operational semantics rules define inductively transitions interpreter 
natural semantics extends applying idea formal system different kinds semantic analysis interpretation typing translation organized follows 
detail section inference rules formally specify specializer 
section presents proofs correctness specializer rules respect dynamic semantics imperative language section explains prototyped specializer gives quantitative results implementation prototype specializing fortran programs 
section presents 
inference rules specialization specialization strategy explained want specialize program readability purposes optimization ones want simplify 
mean simplify program context 
believe remove useless code beneficial program understanding 
case objective compatible program optimization dead code elimination certainly case general 
hand replacement occurences variables values obvious 
benefit depends variables mean user variables pi tax rate kept code contrary intermediate variables decompose computations may meaningful user may prefer removed 
replacing variables values may lead dead code making assignments variables useless gives opportunities remove code 
certainly sufficient reason systematic replacement 
course replacement known value variable kept environment simplification rules give opportunities remove useless code instance condition alternative may evaluated knowledge branch may removed 
benefit replacement depends kind variable kind user user knows application program may prefer keep variables meaning known user trying understand application program know may prefer see variables possible 
fact experiments shown system flexible respect 
system works follows 
options replacement systematic replacement replacement depending user 
specify partial evaluation inference rules operating syntax 
part section presents rules defining constant propagation process simplification process 
third part details rules partial evaluation statements 
new rules combine propagation rules simplification rules 
note techniques new specify novel way 
rules assignment alternative statements 
rules 
propagation simplification rules sequents propagation simplification combination propagation simplification 
sequents environment associating values variables values known executing modelled vdm map shown collection pairs contained set braces variable constant pairs elements 
system initializes maps list variables initial values supplied user 
statement expressed linear form syntax 
simplified statement hypothesis modified execution superscript turnstile simpl pe denotes set rules sequent belongs 
sequents exhibited map operators dom domain operator dom yields set elements pairs map 
union operator yields union maps domains disjoint vdm operator undefined domains overlap 
intersection operator maps yields pairs common maps 
equality operator maps yields true pair map pair map reciprocally 
map override operator operands maps yields map contains pairs second map pairs map elements domain second map 
applied set map map deletion operator yields pairs simpl pe map elements set 
examples illustrate definitions map operators 
fig 

map operators written inference rules explain sequents obtained sequents 
propagation rules special case program verification rules perform forward analysis propagate equalities variables constants 
presents simplification propagation rules alternatives 
condition alternative evaluates true environment resulting propagation alternative obtained propagating statements branch rule propagation simplification alternative simplification branch second rule simplification 
way rules alternative condition evaluates false rules true false 
rules similar rules appear 
shown partial evaluation rules 
fig 
propagation simplification rules alternatives condition alternative partially evaluated propagation simplification proceed branches alternative propagation branch leads environment 
tr ue dom tr ue fa ls fa ls tr ue fa ls rue se fi bool true eval simpl fi bool true eval intersection environments final environment variable value environments value kept final environment removed final environment third rule propagation 
simplification alternative yields alternative condition partially evaluated condition branches simplified branches initial alternative fourth rule simplification 
fig 
cont propagation simplification rules alternatives fifth rule propagation rule 
shows information derived equality tests control alternatives 
condition alternative expressed equality variable belong domain environment evaluates constant pair added environment related branch 
statements fi fi semantically equivalent corresponding rule sixth rule condition alternative expressed inequality case pair added environment related branch 
rules express equalities variables constants added environment 
information expressed condition taken account partial evaluator 
rules generalized conditions alternatives expressed conjunctions equalities disjunctions inequalities rules 
rules generalized denoted denoted 
fi eval bool simpl fi fi eval simpl simpl boo fig 
propagation simplification rules alternatives simplification performed context propagation propagation uses simplification expressions chosen combine propagation simplification rules 
combined rules fortran statement written rules describe combination propagation simplification systems 
combination systems defined rule may define inductively relation 
instance specifies rules partial evaluation assignments 
eval notation refers formal system rules simplifies expressions 
fi dom number eval fi dom number eval fi dom number eval fi ni number eval dom ni iff pe simpl expression evaluates numerical constant environment modified value value 
kind propagation perform assignment removed possible uses occurrence value instance sequence code fi value propagated expression assignment removed assignment comes value value 
sequence simplified code fi eliminate assignments useless partial evaluation classical dead code elimination algorithms 
elimination redundant assignments performed separate optimization phase 
partially evaluable expression modified part assignment variable removed environment value unknown 
fig 

partial evaluation assignments examples illustrate cases 
ex value variable known new value assigned variable introduced environment 
suppose assignment removed reduced program 
ex partial evaluation expression value unknown 
case happens constant values 
rules partial evaluation alternatives defined 
condition alternative evaluates logical constant alternative simplified corresponding simplified branch 
partially evaluated partial evaluation proceeds branches alternative final environment intersection environments resulting simplification branches explained previously fig 
rule 
number eval eval number skip ex ex fig 

partial evaluation alternatives correctness partial evaluation aim section show prove specialization correct respect dynamic semantics natural semantics formalism 
show expressed inference rules expressing soundness result residual program correct respect initial program expressing completeness correct result computed residual program 
term completeness result completeness avoid confusion completely different notion specialization completeness specialization done issue 
programs deterministic rule equality demonstration rules complicated general applicable nondeterministic programs 
examples proofs assignment alternative statements detailed section 
rules proving soundness completeness prove simplification need formal dynamic semantics prove soundness completeness simplification rules respect dynamic semantics 
express dynamic semantics formalism natural semantics simplification 
semantic rules give generate theorems form meaning environment execution statement leads environment evaluation expression gives value 
rules proved supposed define ex semantics plotkin kahn languages ml 
prove rules mean formal semantics denotational prove rules sound complete respect 
official semantics imperative language 
proof bool false eval fi bool true eval fi eval fi fi bool sem proof consistency dynamic semantics give 
outside scope want prove consistency simplification dynamic semantics dynamic semantics 
prove specialization system sound complete respect dynamic semantics system 
usual situation formal system intended model formal systems specialization system noted pe dynamic semantics system noted sem 
program simplified hypothesis input variables theorem specialization system 
call environment containing values remaining input variables 
environment containing values input variables 
initial environment evaluates theorem dynamic semantics sem system 
similar way evaluates theorem sem system soundness specialization respect dynamic semantics means result computed residual program computed initial program 
simplified hypothesis executes hypothesis executes hypothesis soundness simplification respect dynamic semantics formally expressed rule 
completeness simplification respect dynamic semantics means result computed initial program computed residual program 
expressed second inference rule 
fact approach prove simplification close approach prove correctness translators dynamic semantics translation formal systems correctness translation respect dynamic semantics source object languages formalized inference rules proved induction length proof rule induction 
note rules restricting rules instance initial environment ho allow partial simplification 
fig 

correctness program simplification ho ho sem ho sem ho ho completeness ho ho ho soundness sem sem sem ho sem prove rules concerning programs prove hold statement specialize remember analyze data declarations 
prove rules hold 
rules denotes statement denotes corresponding specialized statement 
fig 

correctness statements partial evaluation dynamic semantics formalized sem system 
dynamic semantics rules assignments alternatives propagation rules shown 
reason sem system overloaded symbol representing system new symbol 
sem fig 

dynamic semantics rules assignments alternatives prove validity completeness soundness rules rule induction partial evaluation dynamic semantics 
pe sem systems defined inductively 
inductive hypothesis soundness property defined follows ho ho 
inductive hypothesis completeness defined similar way 
rule ho completeness ho ho soundness sem sem sem ho sem ho ho pe pe number eval fi bool true eval ho pe ho sem ho sem induction operating formal system pe sem states quadruples obtained rules belonging formal system 
construct proof trees property prop states variable value pairs added environment ho proved environment ho holds new environment ho examples proofs soundness examples deal proofs soundness 
proofs completeness similar 
start treating simple statements composed statements 
form basic cases proof 
shows proof statement 
possible removal assignment appear proof tree performed dead code elimination phase subsequently evaluation expression assignment 
fig 

proof soundness assignment partial evaluation ho eval ho eval prop proving holds 
assume partial evaluation rule holds rule sem system assignment ho ho number eval proving proof tree holds ho number eval ho number eval prop rule assignment number eval belonging sem system simple statements proved prove soundness rule holds composite statements 
shows proof soundness alternative condition evaluates true 
similar proof case condition evaluates false 
fig 

proof soundness alternative condition evaluates true implementation prototype section describes architecture specializer 
gives quantitative results measured fortran specializer 
architecture specializer specialization rules close ones implemented centaur environment 
centaur system generic programming environment parametrized syntax semantics programming languages 
provided description particular programming language including syntax semantics centaur produces language specific environment 
resulting environment consists structured editor interpreter debugger tools uniform graphical interface 
furthermore centaur program texts represented syntax trees 
textual graphical representation syntax trees nodes may specified pretty printing rules 
centaur provides default representation 
resulting environment centaur build specializer 
centaur implemented environment specialization programs written assume rule ho bool true eval fi ho ho pe inductive hypothesis hold deduce pe ho ho 
furthermore dynamic semantics statement states fi bool true eval state ho ho ho fi 
proving fi holds 
sem sem sem sem shows architecture environment centaur represented grey part 
fig 

centaur environment centaur environment written programs implement specification rules 
language specifying semantic aspects languages included centaur system restricted manipulations solely syntax 
implementation natural semantics 
specify implement static semantics dynamic semantics translations 
programs compiled prolog code 
executing programs prolog engine deductive system 
shows examples rules rule specializing assignment expression evaluate constant value rule specializing alternative branch 
rules show prolog primitives implementing map operators identifiers italicized nodes syntax trees written bold calls programs printing stands relief 
fig 

rules assignments alternatives initial program written constraints input variables tree manipulation tools programs parsers syntax trees pretty printers tree builders concrete syntaxes specializer residual program eval deletion env ass name ass name env eval logic cst false struct tag stat quantitative results fortran programs chosen fortran implement technique specializing imperative programs fortran widespread scientific programming 
exhibited large class scientific applications approach particularly adapted 
written rules implement fortran specializer 
rules express reach syntax nodes representing statements 
rules perform normalization expressions 
rules simplification rules implement simplification expressions 
rules implement statements simplification 
written prolog predicates implement vdm operators specify simplification 
operators rules formal specification simplification 
partial evaluator may analyze fortran program simplifies subset fortran 
subset recommended standard scientific applications studied 
instance analyze goto statement recommended goto statements implement specific control structures loop 
average initial length programs subroutines analyzed lines fortran code recommended length lines 
reduction rate amounts lines code 
length reduction obtained removal code useless context 
implies direct improvement readability 
reduction specially important large number assignments conditionals 
case subroutines implementing mathematical algorithms 
subroutines main purpose editing results calling subroutines reduction generally important 
partial evaluation programs difficult maintain general 
formally specified specialization inference rules expressed natural semantics formalism augmented vdm operators 
shown prove rule induction correctness formal system standard semantics programming language 
derived specification 
focusing industrial implementation prototype 
tool maintainers edf national french provides distributes electricity country 
developed cedric iie provided basic tools including centaur fortran 
obtain tool current prototype take account new operators fortran 
consist adding new language concepts new syntax operators defining new operator specialization rules modified 
furthermore formal specification specializer document people involved development specializer 
allows express real semantics construct simplify define precisely interesting simplifications statements exhibit prove specialization rules 
extensions take account proof tedious 
expect theorem prover coq 

fortran 
ansi standard 

aho sethi ullman compilers 
addison wesley eds 

tool program comprehension specialization ieee workshop program comprehension washington november 

centaur documentation 
inria january 

despeyroux proof translation natural semantics 
symposium logic computer science cambridge usa june 

dowek coq proof assistant user guide inria report december 

hennessy semantics programming languages 
wiley eds 

jones systematic software development vdm 
prentice hall nd eds 

kahn natural semantics 
proceedings stacs lecture notes computer science vol march 

meyer techniques evaluation imperative languages 
acm sigsoft march pp 

plotkin structural approach operational semantics 
report daimi fn university aarhus 
