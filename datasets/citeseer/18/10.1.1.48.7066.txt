automated theorem proving test set induction adel inria lorraine campus scienti que rue du jardin nancy cedex france email loria fr www loria fr html sri international computer science laboratory ravenswood avenue menlo park california usa email csl sri com 
test set induction goal directed proof technique combines full power explicit induction proof consistency 
works computing appropriate explicit induction scheme called test set trigger induction proof applies refutation principle proof consistency techniques 
general scheme test set induction simple soundness proof 
method new notions test sets induction variables provable inconsistency allow refute false conjectures case functions completely de ned 
show test sets computed constructors free give algorithm computing induction variables 
procedure proof test set induction complete larger class speci cations shown previous 
method implemented prover spike 
computer experiments dealing mutual induction spike appears practical eoecient explicit induction systems 
keywords automated reasoning theorem proving test set induction mutual induction term rewriting systems 
table contents 
terminology notation 
general scheme test set induction 
inductive theory 
principle test set induction 
soundness criteria 
generic procedure test set induction 
test set induction conditional theories 
compute induction variables 
compute test sets 
inductive rewriting 
case analysis 
proof procedure conditional theories 
soundness 
completeness 
computer experiment 
summary 
nowadays computer technology heart increasing number safety critical systems supervision nuclear power stations control devices 
systems may general contain errors ensure safely battery tests needed 
perform nitely tests run risk errors may pop exceptional cases 
formal methods considered remedy 
formal methods 
typically mathematically notions prove system free design errors 
context equational reasoning plays critical role computer science arti cial intelligence applications particular program veri cation speci cation systems 
equations motivated existence initial model 
proof methods model usually induction scheme structure terms 
approaches developed prove theorems induction 
earlier approaches applied explicit induction ar structure terms 
nqthm system developed framework considered successful theorem provers 
heuristics nqthm rationally reconstructed prover clam 
rrl theorem proving system supports cover set method closely related boyer moore approach 
decade proof consistency approach rewriting completion techniques developed re ned ways 
approaches limitations 
guiding proof explicit induction requires skill nding right axioms hypotheses apply 
hand proof consistency techniques require guidance user generation lemmas performed automatically completion procedure 
completion misses lemmas fails cases explicit induction succeeds 
new approach proposed combines full power explicit induction proof consistency :10.1.1.48.9419
explicit induction explicit induction schemes called test sets control generation lemmas 
proof consistency require construction hierarchy lemmas proved 
developed system spike principle 
spike proved interesting theorems limited user interaction 
example proved card trick lemmas provided user classical induction provers coq nqthm rrl require fteen lemmas 
spike system restrictive computation test sets done constructors free strategy complete respect boolean speci cations 
furthermore set false conjectures refuted limited soundness proof procedure long delicate 
propose general scheme test set induction simple soundness proof 
procedure relies notion test set 
de nition test set general previous 
de nition new notion provable inconsistency induction positions de ne subset variables conjecture instantiated induction schemes permit refute false conjectures previous de nitions particularly case axioms suoeciently complete :10.1.1.48.9419
show test sets computed constructors free spike available anonymous ftp ftp loria fr directory pub loria softwares spike give algorithm computing induction variables 
procedure proof test set induction complete larger class speci cations previous works 
approach need hierarchy managing subgoals 
mutual induction automatically handled technique 
point crucial handling mutually recursive de nitions 
noticed approach advantages concerning problematic aspect explicit induction techniques 
organized follows 
section introduce basic notions term rewriting 
section general scheme test set induction 
section de ne procedure proof test set induction conditional speci cations section algorithm compute induction positions 
section introduces procedure compute test sets constructors free 
inductive rewriting fundamental tool proving inductive theorems 
section de ne generalization inductive rewriting 
section presents technique simulating case analysis rewriting 
strategy embedded sound set inference rules described section 
axioms ground convergent functions completely de ned free constructors strategy proved complete 
computer experiment spike discussed section 
terminology notation assume reader familiar basic concepts rewriting 
introduce notations refer detailed presentation 
sorted signature sigma pair simply short set sorts nite set function symbols 
assume partition subsets constructor symbols de ned symbols respectively 
family sorted variables set sorted terms 
var stands set variables appearing denotes number occurrences variable variable linear ioe 
denote set linear variables term linear ioe variables var 
var empty ground term 
denote set ground terms 
assume exists ground term sort 
term said constructor term 
symbol syntactic equality objects 
denote list vector 
set sequences positive integers 
term pos denotes set positions expression denotes subterm position write resp indicate subterm position resp position 
root position written 
denote symbol position position term said non variable position linear variable position linear non linear variable position non linear 
fpos denote set non variable positions position juj length corresponding string gives depth 
term depth maximum depths positions non variable depth maximum depths non variable positions substitution assigns terms appropriate sorts variables 
identity substitution written composition substitutions oe written oej 
term tj obtained applying substitution called instance tj ground term say tj ground instance ground substitution 
term uni es term exists substitution oe toe soe 
equation assuming pair sort 
conditional equation expression form equations 
clause expression form delta delta delta delta delta delta positive clause clause positive literals 
clauses oe substitution oe say subsumes set clauses clause 
say logical consequence valid model written relation terms denote transitive closure 
relation noetherian nite sequences delta delta delta suppose transitive relation set terms noetherian monotonic implies stable implies soe toe 
multiset extension denoted ae 
congruence relation terms stable implies soe toe compatible implies de ne 
clauses consider clause term extended alphabet 
say subsumption ordering exists substitution conditional equation written ae oe oe oe oeg substitution oe case say conditional rule 
term left hand side rule 
set conditional rules conditional rewrite system 
constructor free root left hand side rule 
rewrite rule left linear linear 
rewrite system left linear rule left linear 
assume conditional rule 
conditional rule rewrite terms replacing instance left hand side corresponding instance right hand side opposite direction provided conditions hold 
conditions checked recursively 
termination ensured conditions smaller left hand side 
introduce notion term rewriting conditional rules de nition 
conditional rewriting conditional rewrite system 
term position write loe roe substitution oe conditional rule exists term oe oe term irreducible term substitution oe irreducible xoe irreducible variable domain 
say terms joinable term rewrite relation said ground convergent terms joinable operator suoeciently complete ioe exists suoeciently complete say suoeciently complete 
general scheme test set induction axiomatizations built conditional rules goals proved clauses 
inductive theory conditional rewrite system inductive theory class sentences true minimal herbrand initial model detailed de nitions initial models see instance 
element domain herbrand model denoted ground term built signature ground terms easily ordered induction available natural technique prove sentences models 
call class sentences valid initial model inductive theory de nition 
set conditional equations 
clause inductive consequence ioe valid initial model denoted ind set clauses say ind ioe ind proposition gives useful characterization inductive consequences proposition 
clause delta delta delta delta delta delta inductive consequence ground substitution oe oe implies oe principle test set induction section generic procedure test set induction 
rst introduce ingredients allowing compute induction schemes 
give soundness criteria 
selection induction schemes necessary provide induction schemes perform proof induction 
framework schemes de ned function conjecture selects positions variables induction applied induction variables special set terms called cover set test set instantiate induction variables 
rst consider problem choosing induction variables 
induction variables consider simple example show problem choosing induction variables fundamental eoeciency 
fx prove instantiate induction schemes derive subgoals 
really necessary proving means certain variables instantiated induction schemes 
de ne set variables 
de nition 
say sort nitary set irreducible ground terms sort nite 
said nitary 
de nition 
induction variables conditional rewrite system clause 
set induction variables denoted smallest subset var variable nitary sort 
variable appears non variable subterm position exists rule uni able 
non variable position 
non linear variable 

de nition general allows refute false conjectures particularly axioms suoeciently complete see example 
cover sets test sets method notion cover sets test sets 
rst introduce de nitions de nition 
term said inductively reducible resp irreducible conditional rewrite system irreducible ground substitution fl tfl reducible resp irreducible 
plaisted proved decidability inductive reducibility nitely unconditional equations see 
note easy semi decide term inductively reducible conditional rewrite system 
de nition 
term strongly irreducible non variable subterms matches left hand side de nition 
term weakly irreducible subterms exists rule substitution oe loe oe unsatis able ground substitution oe 
clause delta delta delta weakly irreducible maximal element resp elements fu oe resp weakly irreducible note strongly irreducible term necessarily weakly irre 
de nition 
cover set cover set denoted cs conditional rewrite system nite set irreducible terms ground irreducible term exist term cs ground substitution oe toe cover sets crucial soundness method 
help refute false conjectures 
mutually recursive de nition introduces notions test sets test substitutions 
de nition 
test set test substitution test set cover set additional properties instance inductively reducible term test substitution matches left hand side 
ii instance positive clause test substitution oe weakly irreducible coe inductive consequence test resp cover substitution clause instantiates induction variables terms taken test resp cover set fresh variables renamed apart 
denote sigma resp cs sigma set possible test resp cover substitutions clause test sets considered re ned induction schemes 
allow avoid failure procedure proof induction cases 
illustrated example example 
rules de ne odd nonnegative integers true false assume abuse notation set fa oe oe oe bn oeg denoted oe 
true odd false true odd true conjecture true odd true valid initial model test set true falseg 
proof conjecture immediate 
note methods proof induction notion cover sets fail prove conjecture consider cover set true falseg 
upsilon test sets permit refute false conjectures constructing counterexample 
de nition 
provably inconsistent conditional rewrite system test set delta delta delta delta delta delta dm clause 
provably inconsistent exists test substitution oe ind oe oe 
ii oe oe delta delta delta oe dm oe weakly irreducible de nition provably inconsistent clause involves inductive validity weak irreducibility properties undecidable general case 
lemma gives suoecient conditions decide clause provably inconsistent 
show key property provable inconsistent clause provably inconsistent inductive consequence result proved construction ground instance es axioms 
theorem 
conditional rewrite system 
clause provably inconsistent inductive consequence proof 
delta delta delta delta delta delta dm provably inconsistent clause 
exists test substitution oe ind oe oe 
ii oe oe maximal element resp elements fc oe oeg resp weakly irreducible de nition exists ground substitution delta delta delta dm oe ind coe 
notion provably inconsistent clause allows refute false conjectures previous methods 
particular refute false conjectures axioms suoeciently complete 
example 
consider conditional speci cation de nes predicate natural numbers predicate ordered checks list numbers ordered 
true false ordered cons nil true false ordered cons cons false predicate ordered suoeciently complete equation ordered cons cons false provably inconsistent 
ordered cons cons contain induction variable weakly irreducible false unsatis able methods equation provably inconsistent ordered cons cons strongly irreducible :10.1.1.48.9419
upsilon example 
consider example remove rule predicate odd suoeciently complete 
consider conjecture odd true induction variable de nition 
instantiating yields odd true simpli ed false true provably inconsistent 
conclude odd true inductive consequence method induction variable 
hand odd true provably inconsistent odd strongly irreducible 
method fails refute conjecture odd true 
upsilon soundness criteria goal section describe inference system proving disproving inductive consequences conditional rewrite system inference system operates sets clauses conjectures checked ii induction hypotheses 
assume set copies clause variable renaming belong time 
prove soundness inference system start fair derivation show minimal non valid clause derivation persistent 
fairness roughly means clause set conjectures eventually modi ed inference 
formally derivation delta delta delta fair set persistent clauses ji empty 
assume wellfounded ordering clauses monotonic stable satis es subterm property 
de nition 
conditional rewrite system set conjectures ind delta delta delta arbitrary derivation minimal element oe set ce fd ground irreducible substitution minimal clause subsumption ordering coe 
say sound rule applies justify notion soundness sound derivation fair conjectures inductive consequences theorem 
soundness successful derivations conditional rewrite system delta delta delta fair derivation 
sound ind proof 
proof contradiction 
delta delta delta fair derivation assume ind exists minimal counterexample sound rule applies resulting contradiction fairness assumption 
rst step dealing successful derivations 
second step deal refutation derivation inconsistency pops 
ensure conjectures valid need inference system sound transforms valid premises valid consequences 
de nition 
conditional rewrite system derivation step 
inference system sound ind implies ind theorem 
soundness conditional rewrite system sound system 
delta delta delta derivation 
exists contains provably inconsistent clause ind proof delta delta delta derivation 
suppose exists contains provably inconsistent clause 
theorem conclude ind sound ind generic procedure test set induction conditional rewrite system cs cover set generic procedure formalized transition system 
rule generate derives lemmas simplify delete eliminate redundancies 
rules stable congruence clauses compatible set conditional equations 
oec resp cc denote set instances clauses strictly smaller resp smaller equal oe generate fcg fcg smallest set satisfying property oe cs sigma ground substitution fcg oe coe coe oec coe simplify fcg smallest set satisfying property oe ground substitution oe coe coe coe oe oe oec coe 
delete fcg oe ground substitution oe coe coe coe 
fig 
inference system lemma 
inference system sound 
procedure generic sense inference rule describes step procedure instantiated give operational inference rule 
example instantiation section 
proof 
coe minimal counterexample de nition 
show contradiction rule applies 
suppose rule generate applied substitution oe ground irreducible exists oe cover substitution ground substitution oe oe exists clause fcg oec coe coe fcg coe minimal counterexample ce oe 
coe 
assumption oe coe 
follows counterexample smaller coe contradiction 

suppose rule simplify applied exists clause oec coe coe oe oec coe suppose exists ground irreducible substitution coe 
clause minimal oe ce presence proves rule generate applied contradiction previous case 
oe oe oe coe contradiction 

suppose rule delete applied oec coe coe follow reasoning conclude oec coe contradiction coe 
inference system refute false conjectures 
result consequence lemma lemma 
inference system sound 
proof 
clause derivation step obtained application rule show ind ind analyse situation rule applied 
suppose rule generate applied cover substitution oe 
ground substitution 
assumption fcg oec coe hand coe generate rule generates valid conjectures 

suppose rule simplify applied oe ground substitution 
assumption oec coe hand coe simplify rule generates valid conjectures 

suppose rule delete applied ind case 
approach proved lemmas easily way axioms 
lemmas allow subsume simplify generated nite family subgoals divergence 
test set induction conditional theories section instance generic procedure complete larger class speci cations methods 
rst algorithms compute induction variables test sets 
de ne generalization inductive rewriting 
compute induction variables conditional rewrite system algorithm starts computation induction positions function symbols 
positions extensions inductively complete positions see conditional rewrite systems 
computation done permits determine variable term induction variable 
longer necessary consult axioms order select induction variables conjecture 
algorithm computes functions set induction positions denoted 
easily prove algorithm terminates nite set function symbols nite number rules input rewrite system output induction positions function symbols 
pf fs exists element fa fb flg fg 
pos fu pf fpos saturation false saturation nx subterm fa fb contains position hg exists nx pos pos pos fug pos pos pos pos pos saturation true 
fig 
computing induction positions proposition gives suoecient criterion computing induction variables uni cation 
proposition 
set induction variables clause smallest subset var 
variable nitary sort 

subterm 
example 
consider speci cation lists natural numbers insert operation ordered predicate lists true ioe list ordered isort operation sorts insertion list natural numbers see 
set axioms denoted application algorithm gives pos pos insert pos isort pos ordered induction positions function symbols computed algorithm pos pos insert insert pos isort isort pos ordered ordered ordered insert insert true induction variable occurs position subterm insert induction position insert 
clause ordered insert cons cons true contain induction variable 
upsilon compute test sets computation test sets equational speci cations decidable see 
unfortunately algorithm exists general case conditional speci cations 
methods described computing test sets suoeciently complete conditional speci cations free constructors section study computation test sets constructors free 
theorem 
ground convergent rewrite system suf ciently complete 
assume constructors speci ed set unconditional equations 
computation test sets decidable 
proof 
suoeciently complete elements test sets necessarily constructor terms 
compute test sets consider axioms constructor symbols unconditional 
computation test sets equational speci cations decidable computation test sets decidable 
theorem algorithm computing test sets equational speci cations adapted compute test set suoeciently complete speci cation constructors speci ed set unconditional equations 
assume arbitrary speci cation constructors 
proposition gives procedure compute test set 
need simple notions speci cation ordered sorts nat list bool constructors nat nat nat true bool false bool nil list cons nat list list de ned functions nat nat bool insert nat list list isort list list ordered list bool axioms true false insert nil cons nil true insert cons cons cons false insert cons cons insert isort nil nil isort cons insert isort ordered nil true ordered cons nil true false ordered cons cons false true ordered cons cons ordered cons fig 
speci cation ordered lists de nition 
term said nitary position ground exist nitely irreducible ground instances subterms position distinct 
depth resp non variable depth de ned maximum depth resp non variable depth left hand sides rules non empty denoted depth resp 
left linear depth 
proposition 
conditional rewrite system 
assume suoeciently complete ground convergent 
test set computed follows 
ft linear constructor term depth pos ioe jpj 
expand expand obtained instantiating variables nitary sort possible ways ground constructor terms sort 
subset composed terms inductively reducible 
terms nitary test set proof 
test set computed proposition 
suoeciently complete exists hand conditional rewrite system conditional rule 
exists irreducible irreducible term built constructors instance element proof second property trivial 
check third property 
positive clause delta delta delta dm oe test substitution coe weakly irreducible 
prove ind coe 
de nition oe oe maximal element resp elements fc oe oeg oe resp weakly irreducible var coe fx proceed show exists ground instance coe irreducible ii ensures ind coe 
assumption non ground term nitary 
exists ground substitution domain fx oe irreducible jx jjx gamma jx jj show coe irreducible 
oe maximal fc oe oe oe maximal fc oe oeg 
assume exists rule substitution ff position oe lff ff 
show steps rule matches oe substitution fi variable occurs position xfi xff xff appears oe xfi oe 
fi unsatis able ff contradiction 
oe irreducible rule apply non variable position second variables non variable positions induction variables instantiated oe 
oe replaces variables terms depth overlap fpos oe 
third step uses classical depth arguments 
proceed prove ii coe counterexample 
oe oe construction assumption oe oe 
conclude ind coe ground convergence example 
set conditional rules true false true true false false constructors free test set nat bool true false note term nitary set term nitary set upsilon example 
example continued test set nat bool true false list nil cons nil cons nil cons cons upsilon inductive rewriting simplify goals generalize inductive rewriting relation de ned induction hypotheses conjectures proved axioms simpli cation 
de nition 
conditional rewrite system set conditional equations 
consider clause soe 
write soe gamma 
toe exists conditional equation 
roe oe ae fa oe oe oe oeg 

oe gamma 
oe gamma 
de nition 
inductive rewriting conditional rewrite system set conditional equations 
consider clause write 
gamma 
oe set de nition intended contain induction hypotheses conjectures proved proof system described 
rule allows prove conjectures previous approaches 
example 
consider speci cation axiom proposition inductive property 
methods fail prove conjecture consider cover set instantiation gives equation simpli ed axiom 
new inductive rewriting simpli ed conjecture spite proved oe 
upsilon inductive rewriting stable substitution lemma 
substitution implies case analysis case analysis important rule context inductive theorem proving case splitting arises naturally induction hypothesis 
case analysis simpli es conjecture conditional rules disjunction conditions inductively valid 
de nition 
case analysis conditional rewrite system clause 
de ne case analysis follows case analysis fp oe oe oe oe ind oe delta delta delta oe example 
example continued consider clause true odd true ind true true apply case analysis get 
true true false true 
true true true true upsilon proof procedure conditional theories conditional rewrite system cs cover set procedure de ned set transition rules see 
procedure generalization extension previous procedures 
generate rule allows derive lemmas 
case simplify rule simpli es conjecture conditional rules disjunction conditions inductively valid 
simplify rule reduces clause axioms induction hypotheses conjectures proved 
note simplify permits mutual simpli cation conjectures 
rule implements simultaneous induction crucial eoeciency 
rules subsume delete tautology delete redundant clauses 
generate fcg oe oe fcg oe cs sigma coe tautology oe coe 
fcg 
oe fc oe case analysis coe 
case simplify fcg case analysis 
simplify fcg fc subsume fcg subsumed clause delete tautology fcg tautology 
fig 
inference system soundness prove inference system sound sound 
lemma 
inference system sound 
proof 
coe minimal counterexample de nition 
show rule applied contradiction obtained 
generate suppose rule generate applied substitution oe ground irreducible exists cover substitution oe ground substitution oe oe coe tautology means possibilities exists clause coe 
fcg 
lemma coe 
fcg 
instances clauses fcg rewriting step smaller coe oe valid hand oe coe contradiction proved existence instance clause valid sets clauses suppose resp set conditional rules resp equations resp 
abuse notation relation 
denoted smaller coe oe assume rule case analysis applied coe exists non empty sequence conditional rules sequence positions coe coe coe ind delta delta delta result applying case analysis fp coe coe un exists coe coe 
hand fl oe rewrite rule oe coe contradiction 
case simplify case similar previous 
simplify suppose rule simplify applied exists clause 
lemma coe 
oe 
instances clauses rewriting step smaller coe oe valid oe 
hand oe oe coe contradiction 
subsume coe subsumed axiom exists oe minimum subsumption ordering 
fcg 
hand rule generate applied contradiction previous case 
rule applied delete tautology coe tautology rule need considered 
inference system refute false conjectures 
result consequence lemma lemma 
inference system sound 
proof 
clause obtained application inference rule show ind implies ind discuss situation rule applied generate suppose rule generate applied cover substitution oe 
coe tautology possibilities exists coe 
fcg 
ground substitution lemma coe 
fcg 
assumption instances clauses fcg rewriting step valid 
ind case analysis applied coe 
exists non empty sequence conditional rules sequence positions coe coe coe ind case analysis fp coe coe un suppose exists ind coe exists ground substitution assume coe ground loss generality coe 
implies coe contradiction 
case simplify case similar previous 
simplify suppose rule simplify applied exists clause 
oe ground substitution 
lemma coe 
oe 
instances clauses rewriting step valid assumption 
oe ind subsume delete tautology deleted ind case 
completeness section study completeness proof induction procedure 
rst introduce de nitions de nition 
strongly complete function strongly complete system suoeciently complete de ned function 
rules left hand sides identical renaming ind strongly complete say strongly complete function symbol strongly complete note suoeciently complete rewrite system necessarily strongly complete 
shown example example 
conditional rewrite system de ne predicates constructors true false true false false true easily show suoeciently complete strongly complete consider axiom precondition true inductive consequence upsilon transformation suoeciently complete rewrite system equivalent strongly complete system obvious functions suoeciently complete free constructors 
example example 
consider example system equivalent strongly complete 
true false false true false false true upsilon positive decomposition ff rg fs rg free constructor 
negative decomposition rg rg free constructor 
positive clash ff rg frg distinct free constructors 
eliminate trivial equation rg frg delete rg var rae tautology ae fx occur check rg exists var constructor term inductively irreducible negative clash rg distinct free constructors 
fig 
inference system continued add inference system rules see 
rules positive resp negative decomposition positive clash eliminate trivial equation take advantage fact constructors free simplify clauses 
rules delete occur check negative clash delete redundant clauses 
lemma 
ground convergent rewrite system 
inference system sound 
proof 
coe minimal counterexample de nition 
show rule applied obtain contradiction 
positive decomposition suppose rule positive decomposition applied inference rules free constructors necessary guarantee completeness inference system coe oe oe 
exists oe oe 
qoe qoe oe coe contradiction 
negative decomposition suppose rule negative decomposition applied coe oe oe 
assumption ground convergent rewrite system free constructor 
oe oe 
qoe qoe oe coe contradiction 
positive clash suppose rule positive clash applied coe roe 
hand roe oe coe contradiction 
eliminate trivial equation suppose rule eliminate trivial equation applied coe roe 
hand roe oe coe contradiction 
delete suppose rule delete applied var rae tautology ae fx coe contradiction 
occur check suppose rule occur check applied exists var inductively irreducible coe contradiction 
negative clash suppose rule negative clash applied distinct free constructors ground convergent oe oe coe contradiction 
inference system refute false conjectures 
result consequence lemma lemma 
ground convergent rewrite system 
inference system sound 
proof 
clause obtained application inference rule show ind implies ind discuss situation rule applied positive decomposition suppose rule positive decomposition applied oe ground substitution 
coe roe oe oe 
rst possibility gives desired immediately 
assume second 
ground convergent rewrite system free constructor oe oe 
clause veri es qoe 
negative decomposition suppose rule negative decomposition applied oe ground substitution 
coe roe oe oe 
rst possibility gives immediately desired 
assume second 
exists necessarily oe oe 
oe 
positive clash suppose rule positive clash applied oe ground substitution 
ground convergent distinct free constructors oe oe roe 
eliminate trivial equation suppose rule eliminate trivial equation applied oe ground substitution 
oe roe 
delete occur check negative clash deleted ind case 
test sets cover sets add inference system rule fcg rules applied inference system complete conjecture valid initial model disproved 
result consequence result lemma 
conditional rewrite system strongly complete free constructors 
rule applied inductive consequence proof 
clause condition rules hold rst show contain de ned function 
assume contains term form de ned function 
suoeciently complete inductively reducible 
oe test substitution de nition soe instance left hand side inductive rewriting case analysis applied strongly complete 
generate rule applied contradiction 
conclude clause contains constructor terms 
constructors free simpli cation rules applied necessarily form hand var rule occur check applied inductively irreducible consider substitution ae fx clause cae tautology rule delete applied clause cae provably inconsistent theorem cae inductive consequence nally inductive consequence theorem 
ground convergent rewrite system strongly complete free constructors 
derivation issued terminates application rule ind conversely ind fair derivations issued terminate application rule 
proof 
lemmas 
lemmas 
computer experiment theorem prover spike designed prove inductive validity set clauses conditional theory 
rst step proof session orient axioms speci cation rewrite rules lexicographic path ordering introducing precedence status function symbols 
second step check de ned functions completely de ned 
third step compute test set induction positions 
preliminary tasks proof starts spike rst instantiates conjectures proved induction schemes cover sets test sets induction positions simpli es axioms conjectures induction hypotheses 
cycle generates new subgoals processed way initial conjectures 
example 
suppose forward counter see backward counter see 
speci cation counters functions suoeciently complete cover set introduced user see example 
reg reg fig 
forward counter reg reg fig 
backward counter speci cation counter sorts nat bool constructors true bool false bool bool bool bool bool bool bool nat nat nat input nat bool init nat bool de ned functions nat nat bool nat nat bool nat nat bool nat nat bool bool bool axioms input init input init fig 
speci cation counters ok ok subsumed axiom simplification induction hypotheses fig 
proof conjecture immediate see 
prove termination axioms lexicographic path ordering oe see precedence function symbols oe oe true oe false oe init oe input oe oe oe oe oe theorem proved problem proved nqthm modifying axioms signatures due presence mutually recursive operators 
note speci cation suoeciently complete function de ned constructors 
scheme proof generated spike 
direct proof generated spike cover set 
bool false true init input 
nat induction positions functions 




application generate test substitutions 
init init simplification init simplification init init init simplification init init delete init init simplification delete application generate test substitutions 
input input delete input subsumed input simplification delete subsumed initial conjectures inductive consequences summary proposed general scheme test set induction simple soundness proof 
main arguments favor method founded ordering founded ordering induction exactly termination ordering orient axioms rules 
numerous mechanical tools designed prove termination rewrite systems readily available suggesting induction orderings 
induction schemes schemes rst de ned function conjecture selects positions variables induction applied induction variables special set terms called cover set test set variables instantiated 
computation induction positions carried speci cation determines variable position conjecture induction variable 
guarantee eoeciency method longer necessary consult axioms order select induction variables conjecture 
case analysis test set induction case analysis easily simulated term rewriting 
divergence problems avoided applying conditional rules 
generation lemmas lemmas generated replacing induction variables conjecture cover sets test sets applying inductive rewriting case analysis 
mutual induction conjectures processed non hierarchical order 
new subgoals proved simply added list 
mutual induction automatically handled technique 
point crucial handling mutually recursive de nitions 
noticed approach advantages concerning problematic aspect explicit induction techniques 
refutation refute false conjectures producing counterexamples 
conjecture rejected inconsistency appears 
proposed new notion provable inconsistency allows refute false conjectures previous approaches 
strategy complete refutes conjecture valid initial model provided axioms ground convergent functions strongly complete free constructors restricted boolean speci cations 
property useful debugging speci cations 
test set induction procedure implemented prover spike 
contrast majority current proof systems construct proofs step step require frequent user intervention say great expertise part user spike proved interesting problems minimum interaction user 
plan enhance system decision procedures generalization techniques suggesting lemmas hope prove challenging problems minimal number lemmas provided user 
am grateful micha rusinowitch fruitful discussions jean pierre jouannaud ne kirchner jos meseguer natarajan shankar valuable comments 
partially supported information technology promotion agency japan part industrial science technology frontier program models software sponsored new energy industrial technology development organization 

andrew bundy 
productive failure inductive proof 
journal automated reasoning 

aubin 
mechanizing structural induction 
theoretical computer science volume pages 

bachmair 
proof consistency equational theories 
proceedings rd ieee symposium logic computer science edinburgh uk pages 


challenge mutual recursion mutual simpli cation implicit induction 
invited talk international workshop automation proof mathematical induction june 


par dans les th 
phd thesis universit henri poincar nancy march 


spike system suoecient completeness parameterized inductive proof 
bundy editor proceedings th international conference automated deduction nancy france volume lecture notes arti cial intelligence pages 
springer verlag june 


induction rewriting verify complete parameterized speci cations 
theoretical computer science 

kounalis rusinowitch 
automated mathematical induction 
journal logic computation 

rusinowitch 
implicit induction conditional theories 
journal automated reasoning 

boyer moore 
computational logic 
academic press new york 

reddy 
induction term orders 
journal automated reasoning 

eckhardt 
fast algorithm ground normal form analysis 
kirchner levi editors proceedings rd international conference algebraic logic programming volterra italy volume lecture notes computer science pages 
springer verlag september 


computing ground reducibility inductively complete positions 
dershowitz editor proceedings rd conference rewriting techniques applications chapel hill usa volume lecture notes computer science pages 
springer verlag april 

bundy van harmelen smaill ireland 
extensions tactic guiding inductive proofs 
stickel editor th international conference automated deduction volume lecture notes arti cial intelligence pages 
springer verlag july 

comon 
inductive proofs speci cation transformations 
dershowitz editor proceedings rd conference rewriting techniques applications chapel hill usa volume lecture notes computer science pages 
springer verlag april 

comon 
ground reducibility automata disequality constraints 
mayr wagner editors proceedings th annual symposium theoretical aspects computer science france volume lecture notes computer science pages 
springer verlag february 

dershowitz 
termination rewriting 
journal symbolic computation 

dershowitz 
jouannaud 
rewrite systems 
van leeuwen editor handbook theoretical computer science 
elsevier science publishers 
north holland 

dowek felty herbelin huet paulin mohring werner 
coq proof assistant 
user guide inria cnrs ens 

fribourg 
strong restriction inductive completion procedure 
journal symbolic computation september 

hofbauer huber 
linearizing term rewriting systems test set 
journal symbolic computation 

hofbauer 
proving inductive theorems term rewriting systems 
grabowski lescanne editors proceedings st international workshop algebraic logic programming pages 
akademie verlag 

huet 

proofs induction equational theories constructors 
journal computer system sciences october 
preliminary version proceedings st symposium foundations computer science ieee 


jouannaud kounalis 
automatic proofs induction theories constructors 
information computation 

kaplan 
decidability quasi reducibility 
bulletin european association theoretical computer science february 

kapur narendran zhang 
suoecient completeness related properties term rewriting systems 
acta informatica 

kounalis 
testing ground reducibility property term rewriting systems 
theoretical computer science 

kounalis rusinowitch 
mechanizing inductive reasoning 
proceedings aaai conference pages boston 
aaai press mit press 


inductive completion ground proof transformation 
kaci nivat editors colloquium resolution equations algebraic structures volume rewriting techniques pages 
academic press 

musser 
proving inductive properties data types 
proceedings th acm symp 
principles programming languages pages 
acm 


computing horn clause theories 
springer verlag 

plaisted 
semantic completion method 
information control 

reddy 
term rewriting induction 
stickel editor proceedings th international conference automated deduction kaiserslautern germany volume lecture notes computer science pages 
springer verlag 

rushby owre shankar 
pvs prototype veri cation system 
kapur editor proceedings th international conference automated deduction saratoga springs usa volume lecture notes arti cial intelligence pages 
springer verlag june 

schmid 
eoecient construction test sets deciding ground reducibility 
hsiang editor proceedings th conference rewriting techniques applications kaiserslautern germany volume lecture notes computer science pages 
springer verlag 

shankar 
steps mechanizing program transformations pvs 
science computer programming 

walther 
combining induction axioms machine 
bajcsy editor proceedings th international joint conference arti cial intelligence chamb ry france volume pages 
morgan kaufmann august 


wirth gramlich 
constructor approach positive equational speci cations 
journal symbolic computation 

zhang kapur krishnamoorthy 
induction principle equational speci cations 
lusk overbeek editors proceedings th international conference automated deduction argonne ill usa volume lecture notes computer science pages 
springer verlag 
