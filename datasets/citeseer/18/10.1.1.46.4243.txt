explaining algebraic theory functional programs jeroen fokker dept computer science utrecht university box tb utrecht netherlands jeroen cs ruu nl www cs ruu nl people jeroen hierarchy important structures algebra groups rings fields introduced gofer class definitions laws 
instance declarations provided explaining algebraic construction integers quotients adding function spaces polynomials matrices 
definitions include generalized implementations polynomial division matrix inversion 
monadic parsers provided constructs discussed 
application line program calculating eigenvalue equation matrix 
mathematicians said recognized importance software reuse long advent computers 
large libraries theorems available applied prove new theorems 
generally accepted quality criterion mathematical theorems applicability limited constraints possible 
quest simple universally applicable theorems resembles construction general purpose software libraries 
programming languages lot notations concepts borrowed mathematics arithmetical expressions fortran notions sums products datatypes algol exploitation category theory build graphical user interfaces haskell 
engineering discipline programming developed notations managing complexity large programs 
evolution led simple notion modules simula modula class hierarchies inheritance today object oriented languages 
typed functional programming languages contributed idea polymorphic data types 
time programming pays back mathematics notations structuring information 
concept classes haskell gofer overloading operators polymorphic parameterized data structures suitable making explicit assumptions various concepts algorithms algebra course 
article introduce notions group ring field classes section 
examples classes integers polynomials constructed algebraic 
data types instance applicable classes section 
added benefit manipulation sequences case polynomials matrices eased known standard functions lists available programming language bw jon fok 
examples taken textbook linear algebra lan 
believe notation appeals programmer intuition eases comprehension ideas especially case computer science students 
fact material covered explanation year course functional programming computer science students utrecht fok 
available time weeks knowledge programming scope course prohibit treat details course convince students mathematical algorithms quite elegantly functional programming language 
classes algebraic hierarchy simplest algebraic structures imagine monoid 
set forms monoid closed associative binary operator neutral element 
class definition declare types operator neutral element class eq 
monoid 
laws 
operator constant obey 



laws written comment class definition 
checked automatically instances class desired properties pointless formal notation stating laws language 
benefit laws type checked 
laws notion equality monoid class subclass eq instances monoid instance eq providing definition equality operator 
class algebraic hierarchy group 
instances class provide function neg value gives inverse addition class monoid 
group neg 
neg neg 


specified group addition commutative 
authors include law speak commutative abelian group commutativity holds 
type supports associative operator distributes addition said form rng 
usually operator called multiplication class group 
rng 






multiplication operator need neutral element 
structure called ring class rng 
ring 

word rng chosen previous class ring lacks unity symbolized dropping letter 
possible divide remainder structure called euclidean space 
remainder division denominator sense 
sense smaller understood specified degree function class ring 
euclid degree int divide modulo modulo 
neg divide 
degree modulo degree second law euclidian spaces states multiplying quotient denominator adding remainder yields numerator default definition modulo class definition 
richest structure hierarchy field 
field element zero required exact inverse multiplication class ring 
field inv 
inv definition field class independent euclid class 
classes introduced monoid group rng ring euclid thought linear hierarchy field euclidean space trivial way instance field 
euclid degree divide 
inv derived operators operators defined terms operators class hierarchy automatically overloaded instances classes involved 
give example classes hierarchy 
known sum function adds element list starting zero generalized arbitrary monoid summ monoid 

summ foldr 
group notion subtraction defined adding negation 
group 


neg multiplication available rng square value value multiplied square rng 
square 
ring unity raising value natural power defined 
ring 
int 



euclidean algorithm determining greatest common divisor applied integers arbitrary instances euclidean space euclid 
degree modulo field define shorthand notation division 
field 


inv useful priorities operators defined infixl 
infix 
infix divide modulo infixl 
additional classes section lot types instance classes hierarchy 
easy manipulation values string representation 
parse functions provided making type instance repr class repr parse parser 
shows parser type backtracking parsers type parser string 
string shows type string representation prepending type shows string 
string auxiliary functions defined parsing showing single item pars repr 
string 
repr 

string pars head just parse instances primitives numeric built types int float form group ring trivial way built addition multiplication functions 
instance monoid int instance group int neg negate instance rng int instance ring int instance monoid float instance group float neg instance rng float instance ring float integers form euclidean space 
degree function taken absolute value degree modulo degree required negative 
instance euclid int degree abs divide div modulo mod floating point values approximation real numbers form field instance field float inv generic definition section form euclidean space trivial way 
natural numbers built features natural numbers defined zero successor natural number 
data nat zer suc nat peano axioms natural numbers confusion ability induction implicit semantics data declaration 
induction natural numbers captured fold natural numbers 

nat 
zer suc equality ordering natural numbers expressed instance eq nat zer zer true suc suc false instance ord nat zer true suc zer false suc suc natural numbers enumerable 
form monoid associative addition operator zero identity defined 
instance enum nat suc instance monoid nat zer zer 
suc 
suc natural numbers form group set closed negation 
function partial minus function datatype indicate failure 
data nat 
nat 
nat zer zer suc suc total multiplication function defined 
natural numbers form ring requires form group 
similarly division function defined natural numbers euclidean space 
nat 
nat 
nat zer zer suc 
nat 
nat 
nat case 
zer 
suc integers define integers negative positive natural numbers 
gives representations zero 
symmetry add third representation zero explicitly assume neg pos applied natural number zer 
data neg nat zero pos nat integers compared ordered instance eq neg neg zero zero true pos pos false instance ord neg neg neg true zero neg false zero true pos pos pos false addition integers sign addition natural number sign 
signs differ fact sign constructors applied non zero natural numbers 
instance monoid zero zero 
neg 
neg neg pos 
pos pos neg suc zer 
pos suc zer zero neg suc zer 
pos suc pos neg suc 
pos suc zer neg neg suc 
pos suc neg 
pos 

integers group negation just changing sign 
definition multiplication multiplication natural numbers augmented sign rule 
defined define enumeration repeatedly adding 
instance group neg zero zero neg neg pos neg pos neg instance rng zero 
neg 
neg pos pos 
pos pos neg 
pos neg 

instance ring pos suc zer instance enum integers form euclidean space 
integer division natural division augmented sign rule degree function absolute value defined fold natural number sign 
modulo function defined default definition section 
instance euclid degree zero degree pos degree neg divide zero zero divide pos pos pos divide pos neg neg divide neg pos neg divide neg neg pos quotients integers rational numbers constructed pairs modulo equivalence relation 
rational numbers form field 
generalization construction quotient field arbitrary ring data quot quot assume second part tuples zero 
quotients equivalent denote fraction cross multiplication yields equal results instance rng 
eq quot quot quot able multiply need base type ring ring needs 
base ring ordered quotients instance ord rng 
ord quot quot quot associative addition defined quotients making common denominator instance ring 
monoid quot quot quot 
quot quot 
zero element need non zero denominator 
base ring element guaranteed non zero need base ring unit making quotients monoid 
type information sufficient deduce 

right hand side definitions operations base ring denoted 
quotients easily ring field instance ring 
rng quot quot 
quot quot instance ring 
ring quot quot instance ring 
field quot inv quot quot addition complex numbers constructed real numbers considering formal sums property gamma 
generalization formal sums arbitrary base type 
closure adding belong class monoid group rng ring field base type 
formalized instance declarations rules manipulating complex numbers recognized 
data iadd iadd instance eq 
eq iadd iadd iadd instance monoid 
monoid iadd iadd iadd 
iadd iadd instance group 
group iadd neg iadd iadd neg neg instance rng 
rng iadd iadd 
iadd iadd 

instance ring 
ring iadd iadd instance field 
field iadd inv iadd iadd neg square 
square function spaces function spaces form monoid function composition addition identity function zero 
instance monoid id 
function spaces general form group negation function inversion 
special cases inversion defined 
known example invertible real functions inverse computed newton method instance group float float neg sat imp sat imp functions finite domain invertible trying elements form group instance eq finite 
group neg head members provide finite types define instances finite class booleans characters pairs finite types function spaces finite types instance finite bool members false true instance finite char members map chr instance finite finite 
finite members members members instance eq finite finite 
finite members members members eq 


ys map const ys xs ys ys xs ys condition forming monoid group need type instance eq 
function spaces problem done constructively finite domains property functions equal equal arguments instance finite eq 
eq members definitions applied recursively capable verifying de morgan law evaluating test 
equality required monoid group classes able formulate laws computations 
interested computing mechanically checking laws may give dummy implementation function equality instance eq error compare functions matrices matrices blocks values 
values matrix taken real complex numbers allow matrices arbitrary type 
depending class base type matrices instance class 
matrices represented lists rows data matrix mat assume constraints size matrices 
firstly rows length 
class monoid addition matrices size 
class ring multiplication matrices number rows operand equal number columns second 
class field inverting matrices consider square invertible matrices 
operations matrices function applied elements 
auxiliary functions dimensional analogue map zipwith mapp 




mapp map map zipwith zipwith pointwise mat xss mat mapp xss pointwise op mat xss mat mat op xss example scaling matrix constant value multiplication applied elements equality matrices conjunction equality respective elements rng 

matrix 
matrix pointwise 
instance eq 
eq matrix mat xss mat xss matrices added adding elements pointwise 
zero element take infinite matrix zeroes added compared matrix arbitrary size instance monoid 
monoid matrix mat repeat repeat 
pointwise 
instance group 
group matrix neg pointwise neg textbooks multiplication matrices described notation indices 
indices seldomly necessary functional program matrix multiplication described standard list operations instance rng 
rng matrix mat xss 
mat mat map xss map transpose xs ys summ zipwith 
xs ys transpose defined prelude nice functional definition transpose foldr zipwith repeat unit matrix matrix ones diagonal inv det thetaa thetad thetag thetab thetac thetaa thetab thetac det thetaa thetab thetac thetaf thetai thetaa thetad thetag thetaf det thetad thetab thetaf thetad thetac thetaf thetai det thetaa thetad thetag thetai thetag thetab thetai det thetag thetac thetaf thetai det calculating inverse matrix zeroes 
delta delta delta 
case zero matrix infinite matrix size right size multiplied matrix instance ring 
ring matrix mat iterate repeat important notion matrices determinant computed base type ring 
determinant computed recursively multiplying elements row sub matrices obtained deleting row corresponding column adding products alternating signs 
example theta case det theta det gammab theta det theta det formalized definition det ring 
matrix 
det mat det mat xs xss zipwith 
xs map det mat gaps transpose xss auxiliary function gaps deletes element list possible ways function calculates sum alternating signs gaps 
gaps gaps xs xs map gaps xs ring 
neg ring 

summ zipwith 
square matrices non zero determinant inverse calculated cramer rule 
calculating element inverse matrix row column deleted form transpose original matrix determinant calculated divided determinant entire original matrix 
signs taken alternatingly 
see theta example 
easy express awkward description function composition instance field 
field matrix inv mat xss mat 
mapp det det mat map gaps transpose gaps transpose xss ring 
iterate tail function map gaps transpose gaps generates matrix matrices rows columns left possible ways 
polynomials polynomials formal finite sums terms term value multiplied variable raised natural power 
represent polynomials lists terms term pair coefficient exponent type term int data poly poly term auxiliary functions manipulate terms simple polynomials coef term 
expo term 
int 
int 
poly 
poly poly 
coef fst expo snd poly poly xs coef head xs assume polynomials normal form terms zero coefficient exponents unique terms sorted decreasing exponent 
function brings polynomial normal form 
uses addition coefficients requires coefficients form monoid monoid 
term 
term filter coef sort sort foldr ins ins ins ys expo expo ys ins ys xs ys ys xs terms compared negated multiplied provided coefficients 
terms added form monoid 
eq 
term 
term 
bool group 
term 
term neg rng 
term 
term 
term polynomials instance classes eq monoid group rng ring base type 
addition done concatenating terms normalizing result negation done multiplication done cross product terms instance eq 
eq poly poly xs poly ys length xs length ys zipwith xs ys instance monoid 
monoid poly poly poly xs 
poly ys poly xs ys instance group 
group poly neg poly xs poly map xs instance rng 
rng poly poly xs 
poly ys poly xs ys instance ring 
ring poly interesting instance polynomials euclidean space division remainder defined provided base type field 
degree function take highest exponent gamma zero polynomial 
example division gamma quotient division gamma remainder gamma 
calculated kind long division gamma gamma gamma gammax gamma gammax gammax gamma gamma start head term numerator head term denominator inspected 
divided base type needs field results term quotient 
term multiplied denominator 
product subtracted numerator term highest exponent vanishes 
process repeated remaining part numerator gamma yields second term quotient 
recursion stops remaining numerator lower degree denominator required remainder 
algorithm formalized instance field 
euclid poly degree poly degree poly xs expo head xs divide 
divide 
degree degree derived function section calculate gcd polynomials arbitrary field 
parsers gofer constructor classes prelude monadic parser library inspired wadler wad 
library type parser instance functor monad monadplus monad comprehensions see jon defining parsers 
library common parser combinators defined satisfy char bool 
parser char parser 
parser option parser 
parser library parser single digit defined monad comprehension digit parser int digit ord ord satisfy parser type nat peano natural numbers defined instance repr nat parse foldl ds ds sequence digit 
iterate suc 
shows zer suc involved parsers build combining parsers combinators monad comprehensions 
combined functional composition 
example integers represented instance repr parse zer zero null pos neg option symbol parse zero showchar pos neg showchar similarly parser floating point numbers defined described fok 
parameterized types quot iadd un parsers defined calling overloaded parse function base type 
instance ring repr 
repr quot parse quot null head parse option second symbol parse quot showchar term polynomial represented strings 
format coefficient defaults exponent missing case parsed generated instance ring repr 
repr term parse null head null head option parse option token null result option second token parse id 
id showchar 
id showchar parsers polynomials easily constructed parser combinator listof dual combinator listify instance repr term 
repr poly parse poly xs xs listof parse token poly xs listify xs listify 
shows 
shows 

shows listify id listify listify xs listify xs listof parser 
parser 
parser listof parser matrices constructed similar way 
applications construction quotient field arbitrary ring section generalization construction rational numbers 
rational numbers defined special case type rat quot int likewise complex numbers defined closure adding floating point numbers type compl iadd float iadd base types get gauss integer numbers hamilton quaternions type gauss iadd int type qi iadd rat type quaternion iadd compl type iadd quaternion parse functions easy apply library concrete problems 
example polynomial division section carried defining poly float pars pars session evaluate divide note type information pars divide choose right instance 
polynomials declared float int polynomial division base type required field 
declaring poly int result error message required instance euclid poly int field int advantage careful distinction different classes numeric values instance num standard prelude 
field base type polynomial division field rational numbers 
define poly rat pars pars calculate divide experiment matrices calculating simple inverse 
defining matrix float pars calculate inv just changing type matrix matrix rat result matrix rational numbers inv involved example uses matrices ring polynomials 
calculate equation solutions eigenvalues matrix 
eigenvalue matrix scalar ax kx vector put differently ax gamma kx gamma ki det gamma ki 
immediately programmed gofer ring matrix poly ring poly 
matrix 
poly det map 
example eigenvalues matrix int pars solutions shown structures algebra succesfully modelled gofer classes 
providing parsers constructions instances classes algorithms applied immediately practical problems 
extended directions ffl adding classes vector spaces modules algebraically closed fields 
ffl proving required laws hold implementations style induction proofs bw :10.1.1.100.9674
ffl adding instances lists monoid addition zero klein group group symbolic expressions field 
ffl adding derived operations classes defined 
example find solution polynomial 
abc formula polynomials degree formulas degree making polynomials complex numbers special strategies polynomials rat solution form divisor coefficient divisor head coefficient program algorithms handling matrices finding jordan normal form 
bw bird wadler functional programming :10.1.1.100.9674
prentice hall 
fok jeroen fokker 
course notes dept computer science utrecht university 
fok jeroen fokker functional parsers 
advanced functional programming johan jeuring erik meijer eds pp 

springer lncs 
jon mark jones gofer release notes 
www cs nott ac uk department staff mpj 
lan serge lang linear algebra 
addison wesley 
wad philip wadler monads functional programming 
advanced functional programming johan jeuring erik meijer eds pp 

springer lncs 
