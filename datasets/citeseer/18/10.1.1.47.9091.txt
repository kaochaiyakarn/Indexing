framework dynamic reconfiguration distributed programs christine james computer science department university maryland college park md current techniques software engineer change computer program limited static activities application begins executing reliable ways reconfigure 
developed general framework application software dynamically 
sound method managing changes running program allows developers perform maintenance activities loss system service 
methods support forms load balancing distributed system research software fault tolerance 
goal create environment organizing effecting software reconfiguration activities dynamically 
framework reconfiguration possible describe formal approach programmers capture state process abstractly 
describe implementation method environment experimenting program reconfiguration 
conclude summary key research problems continuing pursue area 
research supported national science foundation contract nsf ccr 
earlier shorter version appeared dynamic reconfiguration distributed programs proceedings th international conference distributed computing systems pp 

overview capabilities managing dynamic software reconfiguration changes implementation running program increasingly demand 
users highly available systems perform maintenance software components place managers may discover need instrument application placed operation users managers alike may desire relocate parts running program order improve performance task relocated local workstation remote supercomputer executing computationally demanding portions program 
techniques static control application programs available years software engineering label configuration management dynamic techniques widely addressed 
view software application system interoperating processes process implemented module collection individual data program units 
module interfaces bound represent communication channels processes 
communication channels bindings modules comprise application structure 
application geometry describes structure mapped heterogeneous distributed architecture 
distributed application framework programmers need reliable techniques manage general types changes 
module implementations 
system structure remains user may require alteration individual modules 
example experimenters may wish replace program unit implements different algorithm order study impact performance run time system administrators may wish replace repair device drivers loss service software engineers responsible enhancing long running program may need extend application functionality losing persistent state executing program 

structure 
system logical structure called modular structure topology may change 
bindings module interfaces may altered new modules may introduced modules may removed 
course structural changes may turn require alterations implementation modules described 
users may introduce entirely new capabilities existing application 

geometry 
logical application structure may remain fixed mapping structure distributed architecture geometry may change 
geometric reconfiguration useful load balancing software fault tolerance adaptation changes available communication resources relocation processes order access guarded resources 
research provides coherent framework considering forms reconfiguration presence heterogeneity required sample applications cited 
motivate various forms dynamic reconfiguration programmers need describe providing capabilities 
describe approach solving key subproblem capturing state executing task may re established forms 
prototype environment demonstrating experimenting dynamic reconfiguration described conclude summary additional research problems continue pursue 
motivation section presents concrete example motivate reconfiguration problem 
example distributed version known dining philosophers problem help describe requirements dynamic reconfiguration system describe scientific problems solved order obtain benefits reconfiguration 
dining philosophers problem resource allocation problem mutual exclusion preserved resources allocated fairly 
resources case forks shared pair philosophers 
group dining philosophers seated circular table single fork pair left 
diner thinks gets hungry tries eat 
order eat diner exclusive adjacent forks neighboring philosophers eat time 
eating diner returns thinking cycle 
implementation problem uses decentralized algorithm developed chandy misra 
details algorithm critical purpose show pseudo code diner 
original example separate process passing forks requests forks bindings right 
algorithm decentralized protocol sharing forks contained diner entirely local state 
illustrate problem terms existing distributed programming system polylith 
order run example heterogeneous network polylith user needs provide simple description application modular structure terms module interconnection language mil 
done polylith responsible packaging invoking processes coercing data representation synchronization marshalling data communication 
shows mil declaration necessary user implement distributed application 
providing text polylith packaging system user source files accessed compiled linked automatically generated network stubs procedures intercept call local process perform remote procedure call network activity described detail 
user eating thinking hungry hungry christine jack liz jim right left right left right left right left dining philosopher problem 
directly execute application polylith responsible invoking executables establishing communication channel tasks 
user sees application works expected 
describe possible forms reconfiguration terms example 
module implementations 
example individual module reconfiguration replace verbose diner displays detailed information activities 
original diner says eating thinking hungry verbose diner provides information forks requests forks 
order perform replacement losing fair allocation mutual exclusion properties application old diner state information initialize verbose diner 

structure 
way change structure application add new diner 
order preserve mutual exclusion properties new diner initialized appropriate state information 
case new diner initial state state neighbors 

geometry 
example geometric reconfiguration move diner original host host 
hosts architecture operating system migration straightforward engineering operation 
heterogeneity defeats existing migration techniques 
deal problem technique changing module implementation capture diner state removing state information initialize new version created target machine 
changes user see interruption service program continue meet spec possibly timing constraints address research time 
kramer magee describe formalism characterizes precisely distributed program may reconfigured way furthermore describe experimental implementation conic 
approach focuses changes primarily creation deletion nodes plus connection establishment removal nodes 
compelling research influenced focus questions persistent state contained process exposed transmission initialize diner state hungry initialize left fork state initialize right fork state main status special set initial values graph acyclic update left fork state update right fork state hungry conditions right start eating done eating start thinking done thinking hungry pseudo code diner service diner implementation binary world users crh diner algebra status client left string returns string function right string returns string orchestrate tool jim diner special tool christine diner regular tool liz diner regular tool jack diner regular bind jim left christine right bind christine left liz right bind liz left jack right bind jack left jim right mil declaration dining philosophers 
process 
points program execution state reliably captured restoration 
proceed transparent source programs written arbitrary languages 
section address questions 
reconfiguration framework objective provide robust framework dynamically reconfiguring distributed application execution environment diverse heterogeneous 
focus mechanisms external application program internal interested changing application requests outside currently executing program initiated user program 
focusing internal mechanisms restrictive possible configurations anticipated represented initial software source denying incorporating new software components exist initiation time 
example system provides internal reconfiguration nil implementation called hermes 
large number activities coordinated user capture manipulate state running process 
environment support general dynamic program reconfiguration presence heterogeneity meet requirements ffl users need easy way configure invoke possibly distributed application 
ffl users notation identifying program components attributes wish reconfigure 
able name individual modules aggregates modules composed structure 
ffl users able visualize current state geometry running program 
reliable way users reconfigure program understand processes currently employed running 
ffl especially presence heterogeneity architectures languages programmers need reliable way coerce representation data transmitted normal communication reconfiguration 
ffl execution environment ensure programmers communication processes controlled external agent responsible reconfiguration 
processes allowed communicate private channel subsequent reconfiguration involving processes may fail update dependencies result module may find trying access non existent resource 
ffl similarly reconfiguration mechanism execution environment ensure information characterizing process captured represented 
includes state information cached behalf process underlying operating system 
primary example type information table open file descriptors operating system maintains process 
ideal behavior kernel information adapted migration transparent application execution possible differences performance 
homogeneous distributed systems strong evidence projects charlotte ideal achieved 
objective met highly diverse distributed systems especially developer freedom adapt operating system objective provide reconfiguration requiring modification underlying operating systems 
ffl execution environment needs way mark processes non relocatable recognizing modules necessarily act guards private resources 
example access file system reasonably handled incorporating non relocatable process 
possible replace guard developer able design module updated designer decisions re establish say access file changed externally reconfiguration step 
approach meeting requirements build existing polylith software interconnection system 
polylith provides users environment easily constructing large possibly distributed applications heterogeneous execution environments 
reasons polylith natural starting point investigating applications reconfigured 
polylith bus organization satisfies requirements concerning coercion data representation heterogeneous system 
bus manages data transformation normal communication showing capture state executing process reasonable data structure techniques discussed coercion mechanism serves equally relocation process state hosts 
bus abstraction helps assure programmers processes communicate private channels 
modules built polylith system communicate bus 
bus protocol notifies process symbolic name passes absolute name modules 
design application component communicates directly modules components affected reconfiguration modules 
new incarnation module invoked bus simply direct subsequent communication new version abandoning old version 
possible programmers devise application defeats principle try hard 
requirements reconfiguration environment discussed far met extending polylith interconnection system 
remaining requirement means characterize state executing process may altered relocated 
provide capability minimum cost programmers 
provided completely transparent application source code 
provided loss run time performance 
questions addressed section describe method abstractly 
questions addressed experimentally constructed set extensions polylith software interconnection system 
extensions provide workbench build study reconfiguration distributed applications 
adt formulation process approach reconfiguration individual processes formulating terms data types adts reconfiguration software process performed characterization component captured run time 
idea contrasts previous approaches migration homogeneous systems methods relocate process moving actual representation operating system abstraction 
actual representation architecture dependent reason approaches directly apply heterogeneous computing system 
object study previous binary representation process framework available users name component wish reconfigured 
contrast approach having way extract state process independent host architecture 
abstraction guide subsequent invocation comparable implementation task 
problem find characterize process state abstractly run time 
accomplish generalization approach transmission adts 
herlihy new operations encode decode added adt developer provides suitable implementation operations host 
adt transmitted new accessors system extract internal state data type external representation shared valid implementations data type 
transmission scheme effective usual formulations adts applications 
sufficient reconfiguration 
instance adt wish transmit passive datum operated application leisure process thread control change state rapidly 
worse necessary state information contained just executable image cached behalf process cpu registers program counters os data structures 
adt transmission scheme generalized account dispersed process state 
approach modeling processes instances process adt source module defines type executing process corresponds implementation type 
process run time structures characterize value instance state extracted execution time suitable representation function 
reconfiguration begins agent application framework stops normal activity causes process invoke representation function characterization state external format 
inverse representation function parameterize invocation valid implementation adt 
purposes programmers provide representation functions modules manually examples enhanced polylith system 
details concerning environment constructed experimenting reconfiguration 
section describes primitives synchronizing reconfiguration mh hold cap get capability holding interfaces objects application mh edit hold null obj hold interface module obj mh edit hold null obj null hold module obj mh hold apply holds specified mh release holds specified primitives altering modules mh obj cap obj get capability module obj mh obj cap null get capability new module mh edit add attrib val insert replace value specified attribute module mh edit del attrib null remove specified attribute module mh edit add add specified interface module mh edit del remove specified interface module mh edit add attrib val add replace value specified attribute interface module mh edit del attrib null remove specified attribute interface module mh chg obj add add module mh chg obj del remove module mh move induce module divulge state forward primitives altering bindings mh bind cap get capability altering bindings application mh edit bind add obj obj add new binding interfaces obj obj mh edit bind del obj obj delete binding interfaces obj obj mh edit bind cpo obj obj copy messages queued interface obj interface obj mh rebind apply binding changes specified polylith reconfiguration primitives extensions polylith needed support experimental activities 
section describes extensions adt framework portrayed 
reconfiguration primitives extensions polylith intended support experimentation reconfiguration tasks 
allow suspend communication modules reconfiguration alter structure application transfer state information module 
reconfiguration initiated module application third party 
reconfiguration changes accomplished invoking series polylith primitives described 
groups reconfiguration primitives approach applying changes get capability applying change mh hold cap example series edits describe change mh edit hold apply change atomically mh hold 
group primitives provides synchronization reconfiguration holding interfaces modules application level 
hold applied interface module attempting communication interface blocked 
similarly held module blocked attempting polylith bus service 
additional parameter mh edit hold describe indicates unread messages moved interface 
purely structural changes adding deleting modules changing bindings done support jim jack liz christine jim jack christine liz liz christine jim jack liz verbose diner replacing diner verbose diner 
modules implementations 
reconfiguration changes involve changes module level replace implementation module move module host 
changes require module participation capturing process state 
mh move command induces old module encode state manages transfer state old new 
polylith controls application configuration manages application level changes creating moving removing modules adjusting bindings 
modules need local knowledge behavior global knowledge module application 
module implementations 
section described scenario dynamically replaced verbose diner 
give details reconfiguration activity 
replacement accomplished creating new verbose diner module copying state old diner new binding verbose diner application removing old diner 
reconfiguration events shown acquiring access old diner creating new diner 
binary attribute specifies implementation new diner verbose diner status attribute indicates new diner initialize state 
old diner told divulge state interface encode 
complies blocks indefinitely 
old diner state sent decode interface new diner active 
accomplishes state transfer old module new messages may queued old diner 
queued messages copied new diner rebinding phase old module bindings removed bindings new module added queued messages copied old new 
binding changes described series mh edit bind commands applied atomically mh rebind command 
applying binding changes atomically simplifies reconfiguration task reducing number steps required making easier reason reconfiguration 
notice need mh hold primitives scenario old module blocks encoding state effectively holding 
modules bound old module continue sending messages atomic rebinding hold ends binding destined replacement 
state old diner bindings copied new diner old module deleted new started 
sequence events example may look daunting task replacing module interfaces standardized written generic replacement routine takes care details requiring names module new implementation 
old diner get access old diner create new new diner new add binary new add status clone get state old diner send new old encode new decode remove bindings old diner null del old right left del left old right del old left right del right old left add bindings new diner add new right left add left new right add new left right add right new left copy messages transit cpo old left new left cpo old right new right start new diner remove old new add old del reconfiguration events replacing diner 
discussed old new participation replacement scenario details capturing restoring process state section 
structure 
example gave section structural change add diner application 
done creating new diner binding application giving appropriate initial state 
approach initializing new diner wait neighbors reach known state initialize new diner accordingly 
approach initialize new diner composite neighbors states shown 
shaded portion initial application configuration left corresponds state capturing 
shaded portion duplicated arrive final configuration right 
advantage approach new diner added immediately waiting application reach predetermined state 
sequence events reconfiguration scenario shown 
new module looks just name status attributes 
example state modules plus state binding initialize new diner composite state consistent meaning reflect correct application state 
mh move primitive invoked neighbor guarantee divulge state time 
freeze portion application holding affected interfaces specified mh edit hold commands applied atomically mh hold invoked 
addition removing existing bi directional binding adding new ones binding changes include copying queued messages appropriate interface new diner 
prior example applying binding changes atomically critical example interfaces held atomicity important 
know mutual exclusion fair allocation preserved new module initial state consistent neighbors states diner state hungry compatible fork states initialization follows protocol rules 
right fork state left fork state diner state right fork state left fork state diner state right fork state left fork state diner state right fork state left fork state diner state right fork state left fork state diner state right fork state left fork state diner state right fork state left fork state diner state right fork state left fork state diner state right fork state left fork state diner state hungry adding new dining philosopher 
new create new diner new add name newname new add status composite hold right side left neighbor left side right neighbor null null right null left remove binding left right neighbors null del right left del left right bind new diner neighbors add right newname left add newname left right add newname right left add left newname right copy messages transit hold applied cpo left newname left cpo right newname right get state neighbors send new diner newname newname start new diner release neighbors new add reconfiguration events adding diner 
geometry 
third final scenario described section move diner host 
reconfiguration identical replacing module implementation difference changing binary attribute change machine attribute specify different host name 
polylith platform designed accomodate heterogeneity handles underlying details 
reconfiguration scenarios demonstrate different ways synchronizing reconfiguration activities 
example third synchronization accomplished blocking old module state altering binding copying messages transit atomically 
second scenario synchronization achieved holding interfaces modules divulge state information 
keeps modules binding state module free execute tries communicate held interface messages transit hold occurred copied new bindings 
capture restore process state support reconfiguration able characterize state executing process capture state 
ultimate goal automatic capture process state requires fill representation process state explicit help process 
semantic information application selectively preserve data relevant process state data captured 
includes static variables data area dynamic variables stack programmer allocated data heap file descriptor signal handler information stored operating system things process priority cumulative cpu time 
major aspect process state capture restore deals execution thread 
issue determining execution capture sufficient state information allow process restart process reconfigurable state 
state capture explicitly include program counter reconfigurable states program states execution safely resume program 
case execution thread captured implicitly implicit value program purposes discussion 
second issue process state includes program counter capturing restoring thread execution may entail capturing restoring activation record stack procedure function returns non local data handled correctly resumed process 
kramer magee define reconfigurable state modules involved change quiescent initiate new communication provided services needed modules reach quiescent state 
prove quiescent state reachable modules involved reconfiguration 
communication modules limited certain types interactions primarily rpc type interactions 
restrict types interactions modules guarantee application modules able reach reconfigurable state 
possible write application module prevented reaching reconfigurable state depended interaction module blocked reconfigurable state 
reconfiguration scenarios distinctly different approaches capturing restoring state 
example module replaced capture restore full state module including program counter 
second example capture partial state different modules capture program counter 
new module partial states appropriate default values create composite state 
shows add diner verbose diner order support state capture restoration reconfiguration scenarios 
comparing amount new code may substantial abstracted away details original algorithm included details reconfiguration aspects 
support replacement approach module provide encode decode operations capture restore process state 
ultimately generated automatically module compiled rely encode decode operations provided programmer 
initialize diner state hungry initialize left fork state initialize right fork state requested catch left fork state requested send left fork state interface left fork state right fork state requested send right fork state interface right fork state encode requested requested main status special set initial values graph acyclic status composite receive left fork state interface left fork state receive right fork state interface right fork state status clone receive diner state left fork state right fork state interface decode signal catch update left fork state update right fork state hungry conditions right start eating done eating start thinking done thinking hungry requested send diner state left fork state right fork state interface encode block reconfigurable version diner reconfiguration mh move old encode new decode command binds module encode interface new module decode interface signals module divulge state 
diner module prepared receive signal procedure catch encode operation requested turns flag requested 
purpose flag delay encode operation diner reaches reconfigurable state 
returning signal handler diner continues normal execution reaches bottom main loop performs encode operation blocks 
delaying encode operation effect defined process state include program counter value set loop 
diner encode interface temporarily bound new diner decode interface process state sent new diner 
recall final reconfiguration steps remove old diner start new 
new diner status attribute clone started action perform decode operation 
program counter main loop state captured don bother explicit goto loop just allow execution resume loop 
second reconfiguration scenario mh move left neighbor right fork state newname right fork state command binds right fork state interfaces signals left neighbor divulge right fork state 
similar command directed right neighbor 
receiving signal diner sends fork state immediately resumes normal execution 
new diner status composite begins getting fork state appropriate interface 
initial diner state defined hungry state compatible combination fork states 
experiences date polylith bus organization necessarily result performance loss compared manually constructed version distributed application 
polylith reconfiguration techniques described cost replacing bindings insignificant cost creating deleting modules reduces cost creating deleting processes underlying operating system 
replacing module addition creation deletion cost incurred cost capturing transmitting restoring process state heavily dependent size complexity state 
reconfiguration scenarios process state fully described boolean variables cost capturing transmitting restoring process state negligible 
important note entire application need suspended reconfiguration hold just affected portion application allowing rest proceed normal processing 
related parts spectrum capabilities addressed past 
geometric reconfiguration processors architecture operating systems considered form process migration 
research provides reconfiguration system structure 
important previous area formalism exposed conic system 
approach software bus abstraction currently implemented polylith system 
project related large body previous technologies 
done primitive data representation presence heterogeneity 
example approach benefited review previous experiences courier 
sun microsystem xdr similar approach uts universal type system internal mlp mixed language programming system 
abstractly transmission data types adts herlihy adt transmission mechanism inspired capturing transmitting state executing process 
polylith previous focus simple data structures interfaces 
stems design principle established early project instance sufficiently rich data type deserves module packaged process space appropriate environments 
polylith language binds instance accessors modules modules transact capability instance flattening transmission 
approach similar shown call object method described detail 
structure oriented languages control distributed programming environment earlier projects notably clu mesa 
support distributed programming coupling notation supporting systems 
systems represent significant step forward area ability realize vast potential distributing computation 
subsequently matchmaker provided transformational approach problem integrating distributed components application written synthesis say pascal higher level specification language 
source transformed ordinary pascal code having accessors host communication system inserted explicitly static control distribution 
especially appropriate multiprocessor configurations transaction facility built top mach language resource constructed 
kernel implements parallel programming resource appropriate homogeneous set hosts 
hcs project shows way provide heterogeneous rpc capability distributed environment 
concert variations theme 
early projects emphasized network filesystem approach locus 
interesting approach cross architecture procedure call common backing store 
system allows forms dynamic reconfiguration ada environment mercury system supports heterogeneity applications managing networked object repository 
described broad framework organizes software reconfiguration activities specifically distributed programming environment 
order run experiments framework constructed execution environment containing fundamental reconfiguration capabilities 
exposed approach described workbench evaluating diverse reconfigurable applications demonstrated utility sample programs 
collection primitives programmers utilizing system represents type assembly language dynamic reconfiguration assembly language primitives quite flexible best employed automatic generation declarations 
result experiences system continuing research investigating abstractions better help programmers direct dynamic reconfigurations framework 
addition studying techniques automatically identifying introducing representation functions extract process state reconfiguration operations 
finkel designing process migration facility charlotte experience ieee computer vol 
pp 

bloch library language extension programming general purpose distributed transaction system proc th conf distributed computing systems pp 

barbacci doubleday weinstock wing status report tool pms level programming proceedings rd workshop large grained parallelism 
chandy misra drinking philosophers problem acm transactions programming languages systems vol 
pp 

cheriton distributed system communications acm vol 
pp 

cross architecture procedure call 
ph thesis uiuc dept computer science uiuc 
hayes schlichting simple system constructing distributed mixed language programs software practice experience vol 
pp 

herlihy liskov value transmission method data types acm transactions programming languages systems vol 
pp 

jul levy hutchinson black fine grained mobility emerald system transactions computer systems vol 
pp 

jones rashid thompson matchmaker interface specification language distributed processing proc th symp principles prog languages 
kramer magee evolving philosophers problem dynamic change management ieee transactions software engineering vol 
pp 


liskov atkinson clu manual springer verlag lncs 
liskov bloom gifford scheifler weihl communication mercury system proceedings st annual hawaii conference system sciences pp 

notkin black lazowska alia interconnecting heterogeneous computer systems communications acm vol 
pp 

polylith software appear acm transactions programming languages systems currently available university maryland csd technical report 
popek walker chow alia locus network transparent high reliability distributed system proc th symp operating systems principles pp 

strom bacon hermes high level process language reliable distributed computing proceedings rd workshop large grain parallelism 
sullivan anderson system parallel distributed programming master slave model proc th conf distributed computing systems pp 

sweet mesa programming environment proceedings acm sigplan symposium programming issues programming environments pp 

yemini goldszmidt alia concert high level language approach heterogeneous distributed systems proc th conf distributed computing systems pp 

appreciate guidance rich leblanc 
grateful jeff kramer jeff magee helpful comments concerning research sharing experiences conic 
