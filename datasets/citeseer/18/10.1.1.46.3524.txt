ieee transactions visualization computer graphics sept pp 
collision detection interactive graphics applications philip hubbard program computer graphics cornell university collision detection response important interactive graphics applications vehicle simulators virtual reality 
unfortunately previous collision detection algorithms slow interactive 
presents new algorithm rigid articulated objects meets performance goals form time critical computing 
algorithm supports progressive refinement detecting collisions successively tighter approximations object surfaces application allows processing time 
algorithm uses simple dimensional geometry approximate motion hierarchies spheres approximate threedimensional surfaces multiple resolutions 
sample application algorithm allows interactive performance possible previous algorithm 
particular new algorithm provides acceptable accuracy maintaining steady high frame rate cases improves previous algorithm rate orders magnitude 
index items collision detection time critical computing real time performance interaction dimensions approximation 
physical world filled solid objects 
solid objects collide penetrate flex break pieces 
computer simulation physical world natural believable objects exhibit property 
enforce objects simulation system relies collision handling algorithm 
researchers computer graphics robotics developed variety collision handling algorithms 
typically algorithm consists parts 
detection algorithm determines simulated objects penetrate collision handling algorithm leave 
response algorithm corrects behavior objects penetrate 
parts collision handling algorithm pose interesting problems focuses detection algorithms 
discussion response algorithms see baraff 
despite wealth literature detection algorithms published algorithms adequately address needs interactive applications vehicle simulators virtual reality 
interactive application detection algorithm satisfy criteria 
algorithm support real time performance high nearly constant frame rate low latency complex objects collide 
second algorithm tolerate objects motion guided user objects motion fully pre specified 
presents detection algorithm rigid articulated objects meets criteria approximation 
algorithm detects collisions simplified representations objects 
representations support progressive refinement having detected collisions representations fit objects level accuracy algorithm advance accurate representations processing 
accuracy improvement algorithm allows interrupted application program 
application flexibility degrade accuracy speed important example avoid latency may give users feeling motion sickness 
copyright ieee 
rights reserved 
personal material permitted 
permission reprint republish material advertising promotional purposes creating new collective works resale redistribution servers lists reuse copyrighted component works obtained ieee 
mailing address frank rhodes hall cornell university ithaca ny 
email address pmh graphics cornell edu 
approach analogous essence rendering multiple levels quality explored bergman funkhouser shirley 
success rendering techniques suggests value approach collision detection 
ideas elements time critical computing stresses time algorithm spends producing results important correctness results 
time critical detection algorithm uses forms approximate geometry 
dimensional structure called space time bound fourth dimension explicitly represents time 
space time bound provides conservative estimate interactively guided object may 
algorithm uses space time bounds focus attention objects collide 
second form approximate geometry sphere tree 
structure contains sets spheres set approximating dimensional surface object different level detail 
sphere trees allow algorithm quickly find approximate contacts objects 
forms approximation cooperate detection algorithm significantly faster previous algorithms 
sample application best previous algorithms requires seconds frame preventing application maintaining real time performance 
new algorithm comparison allows low latency nearly constant frame rate frames second note rate exceed previous algorithm rate orders magnitude 
remainder structured follows 
section reviews collision detection literature 
section gives overview new algorithm 
section introduces space time bounds detection algorithm developed sections 
section describes sphere trees section sketches algorithm builds sphere trees automatically 
aspects topic subtle omit details appear current emphasizes structure detection algorithm :10.1.1.46.3524
section discusses performance algorithm 
section summarizes issues raises 
previous basic algorithm way evaluate previous detection algorithms note improve basic algorithm 
consider simulation animates objects gamma system runs simulation maintains internal sense simulation time distinct wallclock time experienced human observer simulation time runs fig 
sketches pseudocode simulation system 
renders frame animation deltat units simulation time 
rendering frame calls basic detection algorithm 
paragraphs discuss problems basic algorithm 
problem concerns outermost loop detection algorithm 
loop increments time variable fixed timestep deltat assumed smaller rendering timestep deltat 
larger deltat algorithm faster samples simulation time frequently 
smaller deltat algorithm accurate collisions samples 
way get speed accuracy adaptive timestep size timestep smaller collisions 
basic algorithm inability adaptively change timestep fixed timestep weakness 
second problem basic algorithm presence inner loops 
loops cycle pairs objects making processing time increase quadratically number objects 
need check pair timestep pairs weakness 
basic algorithm third problem involves statement innermost loop 
algorithm checks objects surfaces penetration particular time pair processing algorithm 
implementing algorithm tricky 
example consider case objects polyhedral surfaces 
ways faces edges vertices contact complicate algorithm giving special cases inefficient execute difficult debug 
detection algorithm suffers pair processing weakness pair processing algorithm robust efficient 
simulation steps deltat get user input update behavior objects fo gamma detect fo gamma finds collision collision response render objects fo gamma variable prev persists calls 
detect curr fo gamma prev curr steps deltat object fo gamma move position time object fo gamma object fo gamma penetrates collision occurs simulation time prev curr basic detection algorithm simulation uses 
basic algorithm improvements authors address basic algorithm weaknesses 
justice previous require full section presents highlights 
solutions discussed ingenious address weaknesses 
furthermore algorithms nearly solve impose restrictions shapes motion objects making algorithms unsuitable interactive applications 
eliminate fixed timestep weakness algorithms geometry fourth dimension simulation time 
canny example derives functions time variable express convex polyhedra change time roots functions denote collisions 
duff uses interval analysis quickly identify refine regions space time contain collisions 
approach address weaknesses 
unfortunately assumes objects motions time fully known advance 
interactive application algorithm 
advances interval analysis snyder retain disadvantage 
variations algorithms apply geometry estimates objects assuming fully pre specified motion idea related approach develop section discuss interval analysis context 
researchers address fixed timestep weakness assuming fully pre specified motion 
bounds velocity distance increase deltat collisions occur 
technique handle nonlinear motion address pairs weakness idea inspired concept space time bounds introduced section 
structures somewhat similar space time bounds solve fixed timestep weakness 
approach addresses pairs weakness situations 
lin similar analysis concert efficient technique tracking distance convex polyhedra :10.1.1.45.3926
algorithm incorporates extensions nonconvex objects authors analyze performance algorithm practice 
space subdivision popular way mitigate pairs weakness omega gamma worst cases exist object shapes 
algorithms moore shaffer herb smith exemplify octrees researchers 
turk presents simpler technique divides space uniformly turk application molecular modeling spheres approach works bounding spheres boxes arbitrary objects efficiently reducing number objects surfaces tested intersection method 
cohen simple spatial sorting find intersections bounding boxes sorting exploits interframe coherence reduce workload 
algorithms address fixed timestep pair processing weaknesses flexible handle motion fully pre specified 
turk algorithm cohen algorithm particular efficient low overhead 
narrow phase refine interrupted broad phase bounding spheres collide broad phase necessary broad phase necessary application call detection frame application call detection frame application call detection frame application call detection frame application call detection frame broad phase possible collision broad phase possible collision broad phase possible collision broad phase bounding spheres collide broad phase narrow phase action 
thibault naylor show binary space partitioning bsp trees address pair processing weakness polyhedral objects 
advantage bsp trees rigid objects structure tree optimized improve performance naylor describes optimization techniques 
accelerate pair processing algorithm garcia alonso associate precomputed regular grid object objects rotate grids lose efficiency 
sclaroff pentland pair processing algorithm approximates surfaces deformed superquadrics 
authors demonstrate approach works wide variety surfaces authors show approximation collision detection efficient 
understand performance new detection algorithm best evaluation direct empirical comparison previous algorithms 
comparisons require considerable effort common literature 
contribution respect modest compare algorithm previous approaches turk algorithm bsp tree algorithm section 
efficient organization algorithms straightforward implement quick execute 
know published demonstrations algorithms improve algorithms variety situations comparisons algorithm algorithms worthwhile area 
algorithm overview section introduced detection algorithm progressively refines accuracy 
algorithm operates sequence steps allowing interrupted application step 
step algorithm broad phase 
broad phase uses upper bounds objects accelerations build set space time bounds structures section derive 
space time bound gives conservative estimate object 
lowest time coordinate pair space time bounds intersect earliest time collision objects possible 
arrives broad phase need immediately conclude collision intervening frame 
space time bounds address fixed timestep weakness 
section explain space time bounds address pair processing weakness 
time arrives broad phase focuses objects space time bounds intersect 
checks intersection objects bounding spheres located objects positions 
bounding spheres intersect collision broad phase builds new set space time bounds computes new repeats 
hand bounding spheres intersect broad phase collision coarsest level detail 
views parabolic horn object moving point labeled point labeled tj case algorithm switches narrow phase 
narrow phase progressively refines accuracy collision 
specifically narrow phase repeatedly determines approximations surfaces intersect progressively accurate approximations 
repetition narrow phase allows interrupted application application gets accuracy proportional time spare collision detection 
object approximations sets spheres arranged hierarchy called sphere tree section describe 
level sphere tree fits object tightly previous hierarchy allows narrow phase base accurate intersection tests results accurate ones 
sphere trees narrow phase step efficient straightforward implement address pair processing weakness 
narrow phase terminates refinement step finds collision application interrupts algorithm returns broad phase cycle repeats 
fig 
shows schematic diagram broad phase narrow phase action 
section describe algorithm precisely 
space time bounds section defines space time bounds structures broad phase 
moment assume object point 
denote position velocity acceleration respectively simulation time interactive application knows vectors current time say 
application knows scalar holds time say unknown subject inequality jx gamma assertion related taylor theorem proof difficult appears :10.1.1.46.3524
inequality important geometric interpretation 
states unknown position distance known position bound position sphere radius centered bound position times structure cross section sphere 
better understand structure consider analogy dimension structure bounds movement time dimensions 
structure cross sections circles radius spheres 
fig 
shows bounding structure case 
due factor definition bounding structure parabolic horn 
note conservative bound position time outside horn 
extension idea covers object merely point 
moves rotate point physically motion center mass possible rotations bounded sphere radius radius parabolic horn parabolic horn cross sections expanded simple approach handling rotation overly conservative shape 
case representation overlapping parabolic horns bounding part motion section discuss detection algorithm addresses fixed timestep weakness finding intersections bounding structures 
parabolic horns contain quadratic factor costly intersect 
alternative build simple polyhedron called encloses object parabolic horn 
cross sections isothetic cubes bound cross sections respectively parabolic horn 
cross sections defined linear interpolation endpoint cubes 
fig 
shows object case frustum 
object faces face cross sectional cubes 
needs bottom top face corresponding respectively intersection involving faces implies intersection involving faces 
constant cross section face isothetic square 
cross sections face normal axis say face normal axis 
feature faces important section 
guaranteed enclose parabolic horn radius horn cross sections convex function conservative bound 
far derivation assumed object acceleration vector point direction 
acceleration limited certain directions approach overly conservative causing bound space object possibly occupy 
knowledge certain directions possible allows part trimmed away tightening bound represents 
say application knows acceleration vector lie hemisphere application knows vector delta sort limit arises moves away particular direction example avoiding obstructing wall 
relationship leads inequality gamma delta proof identical proof inequality 
appreciate significance inequality think outward pointing normal vector plane passes inequality states time vector position back side plane 
inequality holds point displaced radius front plane part bound position lies front plane unnecessary section describe algorithm implements trimming 
set planes defined cross sections cutting plane 
cutting plane complete space time bound 
fig 
shows example 
algorithms space time bounds assume provided application program 
application provide time values expire corresponds earlier derivations 
application uses specialized knowledge objects compute values 
example consider spaceship flight simulator 
simulator compute current acceleration provided ship main engine adding extra slack value prevents immediately invalid user increases acceleration 
simulator current direction ship main axis value isothetic means axis aligned 
example square isothetic edges parallel coordinate axis cube isothetic faces isothetic square 
complete space time bound cutting plane motion expires user ship rotate degrees application estimate expiration time current rotation rate 
simulator notices guesses incorrect force broad phase treat current time expiration time second example consider application vehicles airplanes automobiles 
turn vehicles acceleration directed center turn 
vehicle current speed xj upper bound acceleration xj lower bound turning radius 
corresponding points center turn 
application estimate expiration time values notify broad phase expire early 
final example consider application user selects drags objects mouse 
case difficult dragging kinematic dynamic 
solution slightly modify dragging paradigm simulating attachment object mouse cursor spring 
approach adds little lag smooths object motion result desirable 
space time bound intersections objects collide simulation time space time bounds intersect follows space time bounds conservative 
detection algorithm compute earliest objects space time bounds time time intuitively clear approach addresses fixed timestep weakness 
section algorithm precisely 
current section concentrates compute avoiding pairs weakness 
strategy main source complexity intersection algorithm cutting planes 
observation simplifies algorithm intersection faces necessary intersection spacetime bounds 
understand observation space time bound consisting cutting plane define analogously 
assume disjoint 
consider different ways intersect ffl intersection involve face face observation holds trivially 
ffl intersection involve face cutting plane recall intersection space part inside matters 
get inside intersect face ffl intersection involve previous case parts respectively matter 
face intersect face ways intersect convenient structure search intersections space time bounds search face intersections 
face ff projects straight line segment ff plane 
ff face face intersections recall face normal standard axis cross section face normal axis 
set faces consists subsets ff ff face normal axis ffg ff fx zg sets important reason intersect time intersection face ff face ff ff fx zg 
proof assertion messy straightforward 
contra positive assertion guides face intersection algorithm 
specifically algorithm considers turn testing faces current intersection 
sets considered intersection algorithm conclude intersection 
problems finding intersections set ff literature contains methods guarantee worst case behavior 
sections heuristic methods 
section compares performance methods 
projection method way find intersections ff project face ff ff plane 
normal ff axis points coordinate ff coordinate 
projection ff plane line segment fig 
illustrates 
intersection faces segments necessary sufficient condition intersection faces faces intersect cross sections intersect 
cross sections isothetic squares ff coordinate checking intersection requires finding intersection squares fi fl plane letting fi fl standard axes ff 
find intersection algorithm needs fi fl coordinates squares corners 
recall square oe side isothetic cube cube cross section oe shares edge sides cube 
cubes isothetic clear algorithm compute required corner coordinates oe point adjoining sides points total 
algorithm needs formula point side cross section time point face recall section defined linear interpolation appropriate point gamma points face respectively 
derive correspond object defined section 
face question cross sections outward pointing normal fi unit vector pointing fi axis 
equation idea expanding parabolic horn radius yield ru fi fi similar analysis holds normal gammau fi intersection pair face cross sections exists isothetic rectangle 
algorithm finds intersection consider rectangle cut cutting planes 
relevant cutting planes space time bounds contain intersecting faces 
intersection rectangle cut vertices cross section cutting plane 
algorithm applies ideas finds intersections segments 
finds segment intersections technique bentley ottmann 
technique sweeps line ff plane reporting intersection finds 
broad phase needs earliest lowest segment intersection corresponds real face intersection sweeping stops soon finds intersection 
bentley ottmann algorithm runs log time segments intersect times 
processing ff ff contains faces objects 
worst case value 
imagine cases algorithm processes segment intersections finding real face intersections 
cases unusual require objects align coordinate motions quite precisely 
encountered cases tests 
fact hundreds test runs section describe average number segment intersections processed real face intersection percent worst case value 
empirical evidence suggests projection method effectively eliminates pairs weakness practice 
subdivision method alternative way find face intersections approach similar duff algorithm 
approach subdivides space time octree 
subdivisions isothetic cubes algorithm efficiently determine faces intersect cube 
algorithm subdivides recursively base case cubes intersect small number faces 
cube algorithm tests pairs faces intersection 
process continues finds earliest intersection 
projection method subdivision method spend time notice face intersections 
worst case uncommon subdivision method usually efficient practice 
comparison compare projection subdivision methods ran empirical tests 
tests involved various distributions detailed :10.1.1.46.3524
current section presents results randomly distributed sense approximate average case 
conducted tests involving different set 
test intersection set applying projection method subdivision method values value test measured speedup projection method defined speedup processing time subdivision processing time projection speedup greater means projection method faster 
fig 
graphs speedup simulation time intersection 
graphs logarithmic scale avoid hiding slowdowns speedups 
projection method faster tests recommend way find face intersections 
face plane intersections section mentioned second category space time bound intersections involves face cutting plane intersection occur intersects face part inside significant intersection involve greater coordinates intersection simulation time st intersection speedup projection speedup projection method subdivision method 
characterize intersection convenient start intersection plane contains normal vectors constant cross sections respectively 
line intersection direction theta point line defined linear interpolation points line points lie positions follow linear algebra 
point intersection km points correspond real intersections points part outside boundaries part outside boundaries space cut algorithm avoids points imposing constraints characterize real intersections 
constraints come interpretation space time bound intersection half spaces defined face cutting plane 
half space defines constraint expression follows 
outward pointing normal vector cross section half space bounding plane 
point bounding plane equation point inside half space gamma delta inequality solved terms linear functions complete details appear :10.1.1.46.3524
result set constraint half planes plane 
pairs intersection half planes satisfy constraints correspond real intersection points 
face plane intersection algorithm find earliest point 
finding point example variable linear programming problem 
preparata shamos describe solution problem 
alternative solution involves straightforward extensions bentley ottmann algorithm approach efficient small number constraints involved 
plane plane intersections final category space time bound intersections section involves cutting planes associated situation identical situation section replacing note obtained subject twelve constraint half spaces discussion ways space time bounds intersect complete 
pseudocode fig 
summarizes process 
ff fx zg intersection method says intersection ff containing cutting plane associated intersection cut intersects satisfying constraints intersects satisfying constraints minft intersects satisfying constraints minft algorithm finds time earliest intersection set space time bounds 
intersection method projection method subdivision method 
prev curr build rebuild space time bounds build space time bounds intersect gamma build deltat objects intersecting space time bounds intersecting bounding spheres prev add objects result return result start narrow phase build deltat expiration time space time bounds prev return collisions broad phase detects collisions simulation time curr space time bounds broad phase section describes detection algorithm broad phase uses results section 
essential idea appeared fig 
section shows broad phase doing collisions possible 
earliest intersection space time bounds simulation time curr curr time current frame broad phase concludes collisions currently possible 
fig 
gives pseudocode implements idea 
detail broad phase sets variable build prev previous time stopped detecting 
rebuilds space time bounds build uses intersection algorithm section find time space time bounds intersect 
note section works normalized time scale assumes build mapping unnormalized normalized time straightforward broad phase sets unnormalized value curr collisions currently possible 
detection algorithm free return immediately 
returning stores variable prev persists frames allowing immediately return frames curr prev broad phase return immediately space time bounds built build intersect 
case algorithm section sets prev simulation time space time bounds expire time application estimates acceleration bounds invalid 
curr collision possible current frame broad phase 
default behavior case set build time possible collision rebuild space time bounds check new intersections 
gamma build small threshold deltat default behavior diminishing returns 
broad phase gets bounding spheres objects space time bounds intersect checks spheres intersection 
spheres intersect broad phase reached limits accuracy 
returns objects narrow phase take detect collisions greater accuracy 
narrow phase complete broad phase resumes operation 
advance simulation time build rebuild retest space time bounds 
rebuilding uses new values provided application new values reflect discontinuous changes objects trajectories due collision response 
simulation time broad phase advances build deltat deltat previous paragraph 
deltat minimum temporal resolution broad phase 
value deltat chosen application 
choose deltat small user care collisions duration deltat missed note similarity deltat basic algorithm fig 

algorithms minimum temporal resolution algorithm space time bounds advantage timestep fixed deltat broad phase advances build deltat objects may draw close new space time bounds disjoint initial time coordinate build deltat algorithm section assumes space time bounds initially disjoint 
resolve problem algorithm performs extra test overlap space time bounds cross sections time build deltat cross section defined space time bound faces sets ff say ff faces sorted bentley ottmann processing section algorithm iterate find overlapping intervals 
iteration quite efficient practice 
narrow phase sphere trees turns narrow phase checks pairs objects intersection particular instant simulation time 
narrow phase observation spheres simplest shapes check intersection 
objects spheres narrow phase pair processing algorithm trivial 
interesting shapes closely approximated single sphere union partially overlapping spheres provide better approximation 
support progressive refinement narrow phase uses hierarchies unions spheres call sphere trees 
deeper levels hierarchy spheres approximate object exactly 
children level sphere spheres level cover parts object covers 
pair processing algorithm checks sphere trees intersection need check pairs spheres parents intersect 
simple recursive algorithm descends hierarchy find intersection level wasting time unnecessary sphere comparisons 
level recursion algorithm allows stopped application 
stopping particular hierarchy level algorithm detects approximate collisions 
specifically intersecting level spheres objects approximate true collision objects assuming recursion proceeds breadth manner finding level intersections descending level 
accuracy approximate collision ensuing collision response depends tightness level spheres fit objects 
section describes build sphere trees deeper levels spheres increase tightness 
deeper descent increases accuracy increases processing time 
narrow phase provides progressive refinement allowing application control balance accuracy speed choice number levels descended 
minimum temporal resolution common detection algorithms literature 
interval analysis techniques provide best alternative deepest level subdivision find small intervals time definitely contain collisions exact instants collisions intervals unknown 
desktop lamp triangles levels sphere tree built medial axis surface 
hierarchical algorithms common computer graphics important note approach differs hierarchies previous detection algorithms 
new approach avoids inherent algorithms octree hierarchies example algorithm shaffer herb 
frame algorithms incur cost rebuilding octree moving objects 
sphere trees contrast transform way rigid objects due rotational invariance spheres sphere trees built preprocess 
idea applies articulated objects articulated component sphere tree 
second difference previous algorithms descend deepest nodes hierarchies check exact intersections object real surfaces sets polygons 
processing time algorithms grows geometric complexity surfaces 
new approach hand processing object real surfaces 
processing time depends resolution sphere trees independent objects geometric complexity sphere trees built section describes 
accuracy decrease geometric complexity increases application ability balance speed accuracy deems appropriate 
new approach act previous ones checking real surface intersections deepest intersecting spheres application time level accuracy 
feature requires sphere tree conservative words level cover object surface completely 
building sphere trees building sphere tree requires generating multiple hierarchy levels different numbers spheres approximate object different resolutions 
multiresolution modeling difficult topic general heckbert garland discuss context rendering 
collision detection particular challenge making level fit object tightly tightness necessary application detection invoke collision response colliding spheres level 
section gives overview techniques building tight sphere trees details appear :10.1.1.46.3524
literature contains tight hierarchies 
algorithm builds octree representation object build sphere tree circumscribing occupied octant sphere 
resolution resulting sphere tree increases depth sphere trees produced way tend fit object loosely 
goldsmith salmon algorithm builds efficient bounding hierarchies ray tracing 
optimizing hierarchy ray object intersections directly promote tightness needed object object collisions 
rourke badler fit spheres inside polyhedron attaching subset vertices 
approach produces tightly fitting sets spheres offers little control resolution set link multiple sets hierarchy 
experimented elaborate techniques building sphere trees 
algorithm starts octree sphere tree spheres object 
tightening constrained minimization problem minimize looseness spheres maintaining conservative coverage object 
way solve problem apply simulated annealing 
context simulated annealing repeatedly proposes random changes spheres accepts changes produce tighter fit accepts changes loosen fit avoid local minima 
measuring looseness spheres nonconvex object nontrivial problem 
best approach measures hausdorff distance sphere object surface way measure distance making approximations 
simulated annealing improve accuracy octree sphere trees cases slow produces highly irregular distributions spheres 
successful algorithm building sphere trees uses medial axis surfaces 
medial axis surface corresponds skeleton object 
building exact medial axis surface polyhedron difficult describe algorithm produces satisfactory approximation 
algorithm distributes points outer surface object computes voronoi diagram points vertices voronoi diagram inside object lie medial axis surface 
vertex defines sphere touches object outer surface points 
typically vertices associated spheres generating multiple levels detail requires merging adjacent spheres 
merge pair spheres sphere tree building algorithm replaces pair sphere covers parts object pair cover 
algorithm chooses pair merge applying cost function encourages tight fit object 
applying merging operation repeatedly algorithm give level arbitrary number spheres tests level spheres making sphere tree fan match octree 
note resolution sphere tree independent object geometric complexity 
merged spheres necessarily cover object conservatively usually leave tiny patches object surface uncovered postprocess scales spheres adjacent uncovered patches corrects problem 
reliably context algorithm requires extensions 
algorithm aliasing problems postprocess check algorithm results correct problems 
corrections involve selectively adding points object outer surface updating voronoi diagram 
extensions algorithm build sphere tree medial axis surface works practice 
fig 
shows results model lamp 
model features long flat triangles require small spheres tight coverage 
sphere tree allows efficient collision detection section reports 
long flat triangles common models increase complexity detail 
building sphere tree triangle lamp takes minutes hewlett packard model 
increase time unreasonable larger models example model triangles takes minutes 
important remember time occurs preprocessing application begins running 
performance evaluate detection algorithm empirically tested best previous algorithms 
algorithm hybrid uses turk uniform space subdivision find pairs objects bounding cubes intersect uses bsp trees process pair 
complete description tests appears section presents highlights results :10.1.1.46.3524
set tests compare space time bounds turk algorithm 
test program generates random configurations isothetic cubes applies forces move 
cube forces grouped sets set associated acceleration bounds number sets variations set random 
simulate interactive conditions program gives algorithm information expiration time 
unix clock routine measures time algorithm needs find collision 
tests ran decstation turbo 
fig 
gives results tests objects test 
graphs show speedup space time bounds defined speedup processing time turk algorithm processing time space time bounds speedup greater means space time bounds faster 
graphs logarithmic scale avoid hiding slowdowns speedups 
detection speedup comparison time spent detection algorithms ignoring time spent ordinary differential equation ode solver speedup includes ode solver runtime 
fig 
shows space time bounds faster turk algorithm 
space time bounds slower terminating collision occurs immediately cases estimating collisions speedup simulation time collision occurred speedup space time bounds turk algorithm 
num 
frames space time bounds seconds frame detection time num 
frames turk algorithm frame timings space time bounds turk algorithm 
provides advantage overhead space time bounds penalty 
graph suggests ode solver fourth order runge kutta method bottleneck speedups closer detection speedups faster ode solver 
speedups fig 
reflect performance frames 
interactive applications important individual frame fast 
study frame performance repeated tests recording time spent algorithm frame 
individual tests slowest frame space time bounds slower slowest frame turk algorithm 
hand frames nearly slow slowest frame common space time bounds 
evidence comes histograms detection frame times algorithm include frames just slowest tests see fig 

note particular fullness bin indicating space time bounds spend time majority frames 
providing fast frames occasional slower frames space time bounds meet requirements soft real time systems interactive graphics applications 
set tests compare sphere trees bsp trees 
bsp trees give exact results tests indicate speed application gains accepting degraded accuracy 
tests run context sample application simple spaceship simulator real application simulator features objects geometric behavioral complexity representative real applications 
user controls ship applying forward thrust rotational velocity 
user ship shares space ships periodically pick control values random 
simulator call detection algorithms frame compare performance 
tests algorithm uses sphere trees uses bsp trees 
preprocessor builds data structures start tests 
bsp trees efficient preprocessor minimizes number extra nodes created faces straddle partitioning planes naylor discusses ways optimize bsp trees 
ships tests shaped lamps fig 

sphere trees fourth accurate level spheres shown fig 
spheres store lamp polygons allowing fifth level exact detection 
tests ran sun sparcstation zx timings unix routine 
tests measure speedup sphere trees bsp trees defined speedup processing time bsp trees processing time sphere trees cases level number mean speedup exact speedup sphere trees bsp trees cases reached sphere tree level intersecting cases level number mean speedup exact speedup sphere trees bsp trees cases intersect sphere tree level fig 
shows mean speedup cases narrow phase reached level sphere trees 
cases level level sphere trees intersect detection algorithm conclude objects collide 
cases sphere trees intersect level application stops narrow phase intersection levels shallower exact detection invokes collision response objects quite collide 
fig 
shows speedup cases 
fig 
shows upper bound distance quite colliding objects cases 
distances indicate certain amount inaccuracy decreases rapidly sphere tree depth 
modest inaccuracy acceptable figs 
show sphere trees offer dramatic speedups bsp trees 
final set tests compare algorithms space time bounds sphere trees versus turk algorithm bsp trees 
tests spaceship simulator ships shaped lamps 
ships start circle user controlled ship soon break formation move independently 
collision response simple causing ship jump back initial position collision 
fig 
tracks processing time spent turk algorithm bsp trees run simulator 
notice time oscillates considerably greater seconds frame 
fig 
shows similar run space time bounds sphere trees 
run simulator tries meet target seconds frame acceptable interactive performance interrupting narrow phase 
fig 
tracks time devoted collision detection activities rendering tracks slack time periods waiting keep frame time seconds 
detection algorithm allows application keep frame time target frames 
speedup turk algorithm bsp trees frames 
frames space time bounds sphere trees allow interactive performance impossible algorithm 
time broad narrow phases separately extra calls system clock take time time noticeable effects frame rate pilot studies 
level mean distance cases intersect level upper bound separation distance expressed fraction lamp bounding sphere radius 
simulation time detection processing time seconds processing time turk algorithm bsp trees run spaceship simulator 
processing time seconds frame detection slack simulation time processing time space time bounds sphere trees run spaceship simulator 
presents time critical approach collision detection 
algorithm addresses weaknesses common detection algorithms allows interactive applications trade accuracy speed needed 
implementation significantly outperforms previous algorithm empirical tests allowing interactive performance impossible 
offers opportunities extensions improvements 
narrow phase currently exploit interframe coherence starting traversals sphere trees levels suggested previous frame narrow phase faster 
space time bounds maximum acceleration structures similar space time bounds derived limits velocity position reformulation advantageous cases applications estimate velocity position easily acceleration 
current broad phase interruptible conservative ignores collisions 
take inordinate amount time situations objects packed densely object collides multiple objects frame 
way broad phase interruptible allow selectively ignore objects application temporarily designated important interesting question speed gained manner useful 
parallel processing accelerate phases algorithm broad phase predictive properties space time bounds assist load balancing schemes narrow phase independence paths sphere tree leaves allow simultaneous processing 
general idea trading accuracy speed deserves research 
important advances systems integrate time critical algorithms multiple tasks studies determine approximations users find appropriate particular tasks 
preliminary abbreviated version appeared ieee symposium research frontiers virtual reality 
research conducted part author doctoral studies brown university 
guidance john spike hughes essential completion andy van dam rest brown computer graphics group important contributions 
brown supported part nsf arpa science technology center computer graphics scientific visualization sun microsystems onr arpa order ncr hewlett packard ibm digital equipment apple microsoft 
cornell peter shirley gave valuable encouragement advice structure 
baraff 
coping friction non penetrating rigid body simulation 
proceedings siggraph published computer graphics july 
bergman fuchs 
image rendering adaptive refinement 
proceedings siggraph published computer graphics aug 
canny 
collision detection moving polyhedra 
ieee transactions pattern analysis machine intelligence mar 
cohen lin manocha ponamgi 
collide interactive exact collision detection system large scale environments 
proceedings symposium interactive graphics monterey california pages 

collision detection algorithm velocity distance bounds 
proceedings ieee international conference robotics automation pages 
duff 
interval arithmetic recursive subdivision implicit functions constructive solid geometry 
proceedings siggraph published computer graphics july 
hayward 
awareness collision prediction 
proceedings ieee international conference robotics automation pages 
funkhouser 
adaptive display algorithm interactive frame rates visualization complex virtual environments 
proceedings siggraph published computer graphics proceedings annual conference series pages aug 
garcia alonso serrano 
solving collision detection problem 
ieee computer graphics applications may 
yu knight dong 
constructing discrete medial axis objects 
international journal computational geometry applications 
goldsmith salmon 
automatic creation object hierarchies ray tracing 
ieee computer graphics applications may 
heckbert garland 
multiresolution modeling fast rendering 
proceedings graphics interface pages may 
hubbard 
interactive collision detection 
proceedings ieee symposium research frontiers virtual reality pages oct 
hubbard :10.1.1.46.3524
collision detection interactive graphics applications 
phd thesis department computer science brown university oct 
kennedy lane 
profile analysis simulator sickness symptoms application virtual environment systems 
presence summer 
lin manocha canny :10.1.1.45.3926
fast collision detection geometric models 
technical report tr department computer science university north carolina chapel hill jan 
shirley 
visual navigation large environments textured clusters 
proceedings symposium interactive graphics monterey california pages 
moore wilhelms 
collision detection response computer animation 
proceedings siggraph published computer graphics aug 
naylor 
constructing partitioning trees 
proceedings graphics interface pages may 
rourke badler 
decomposition dimensional objects spheres 
ieee transactions pattern analysis machine intelligence pami july 
preparata shamos 
computational geometry 
springer verlag new york new york 
press teukolsky vetterling flannery 
numerical recipes cambridge university press cambridge england nd edition 
samet webber 
hierarchical data structures algorithms computer graphics part fundamentals 
ieee computer graphics applications may 
sclaroff pentland 
generalized implicit functions computer graphics 
proceedings siggraph published computer graphics aug 
shaffer herb 
real time robot arm collision avoidance system 
ieee transactions robotics automation apr 
smith kitamura kishino 
simple efficient method accurate collision detection deformable objects arbitrary motion 
proceedings ieee virtual reality annual international symposium pages mar 
snyder woodbury fleischer barr 
interval methods multi point collisions time dependent curved surfaces 
proceedings siggraph published computer graphics proceedings annual conference series pages aug 
thibault naylor 
set operations polyhedra binary space partitioning trees 
proceedings siggraph published computer graphics july 
turk 
interactive collision detection molecular graphics 
technical report tr department computer science university north carolina chapel hill jan 
