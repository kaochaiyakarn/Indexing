type reconstruction linear pi calculus subtyping atsushi igarashi naoki kobayashi department information science university tokyo ku tokyo japan tokyo ac jp november powerful concurrency primitives concurrent languages thread libraries provide great exibility implementation high level features concurrent objects 
low level dicult check global correctness programs perform non trivial code optimization elimination redundant communication 
order overcome problems advanced type systems output channels linear channels studied type reconstruction problem type systems remained open applications concurrent programming languages limited 
develop type reconstruction algorithms variants kobayashi pierce turner linear channel type system pierce sangiorgi subtyping input output channel types prove correctness algorithms 
knowledge complete type reconstruction algorithm previously known type systems 
implemented algorithms incorporated compiler concurrent language 
shows experimental results algorithm application compile time optimizations 
keywords linear type linear channel static analysis concurrent language background advantages disadvantages low level concurrency primitives 
concurrent languages thread libraries provide programmers powerful lowlevel concurrency primitives dynamic creation processes rst class communication channels 
major advantages providing primitives complex communication mechanisms easily implemented modi ed semantics obtained uniformly terms semantics primitives implementation concurrent languages substantially simpli ed 
advantages free lowlevel primitives implementing high level features concurrent objects useful information behavior may lost result dicult check global appear information computation 
earlier version fourth international static analysis symposium sas title type analysis communication concurrent languages appearing volume lecture notes computer science pages 
correctness programs perform non trivial code optimization elimination redundant communication 
type systems process calculi 
order overcome problems number type systems gay vh ps kpt ps studied process calculi 
pierce sangiorgi input output channel type system subtyping ps kobayashi pierce turner linear type system kpt come re ned process equivalence theories making easier reason program behavior enabling non trivial code optimizations 
order illustrate ideas consider asynchronous process calculus parallel execution creates channel executes sends channel receives values executes 
replication inaction example process receives value channel forwards channel process 
represents nite number parallel copies repeatedly forwards values received earlier type systems gay vh concurrent languages including cml rep concerned types values transmitted channels typed type environment int denotes type channels transmitting values type idea input output channel type system annotate channel types information operations input output allowed channels 
write type channels receiving input values type type channels sending output values type type channels receiving sending values type int 
valid type judgment int 

furthermore distinction input output capabilities naturally leads subtyping relation input channel type covariant output channel type contravariant input output channel type invariant 
re ned type system admits coarser process equivalence example type int int process 
equivalent ecient process respect appropriate typed barbed congruence ps kpt case usual untyped process equivalence mil 
linear type system re nes channel types adding information channels input output 
phrase channel input output means process tries receive send value channel process succeeds receiving sending value nding communication partner 
example type environment int means times receiving channel received channel sending integer 
typed environment 
type information safely replace process ecient process 
argued kpt optimization corresponds tail call optimization functions 
previous papers input output channel type system ps linear type system kpt concerned type checking applications concurrent programming languages limited 
pict pt input output channel type system linear channel type system 
major diculty type reconstruction type systems principal typing property 
example possible typings process int int 
general typing represents candidates 
goal approach main goal develop type reconstruction algorithms variant linear type system kpt extension subtyping type systems applied concurrent programming languages putting additional burden programmers 
approach 
key idea reconstruction algorithm introduce variables constraints partial information channel usage expressed 
new type system process typed follows int fj may input times receiver total number allowed inputs 
expressed constraint 
instantiating variables elements constraint satis ed obtain possible typings 
similarly process typed allow structural subtyping constraint simpler fk constraint expresses condition receiver uses sending channel type sent channel expected receiver subtype 
general constraint variables fairly simple solved simple method 
especially structural subtyping type reconstruction algorithm runs time polynomial size process expression 
applications 
algorithm fully recover type information unannotated program 
programmer needs put type information places wants compiler check channel usage 
algorithm applicable ml style implicitly typed concurrent languages cml rep ky 
addition check correct channel usage type information recovered algorithm especially information channels call linear channels useful optimization concurrent programs 
elimination redundant communication channel creation mentioned usage information tail call optimization functions methods concurrent objects 
reduction cost communication optimize run time representation linear channel reduce run time check state allocate register 
improvement memory utilization memory space linear channel reclaimed immediately communication 
amount performance improvement course depends linear channels actual concurrent programs 
informal pro ling programs written cml rep pict pt ky indicates linear channels frequently channels typical function method call linear 
contributions 
main contributions formalization type system mentioned proof existence principal typing development algorithms infer usage information consists algorithm compute principal typing algorithms solve derived constraint evaluation performance improvement gained type system simple benchmarks 
clarity brevity pure process calculus target language believe technique applicable concurrent languages rep yt yon pt ky fact incorporated type reconstruction algorithm compiler functions records polymorphic type system formal proof correctness analysis please refer igarashi master thesis iga 
structure rest organized follows 
section introduces basic linear channel type system subtyping section shows correctness 
section section main part section rst modify basic type system introducing type variables subtyping constraints 
re ned type system shown principal typing property algorithm compute principal typing 
section show reduce subtyping constraint principal typing constraint variables solve 
section reports experimental results applying analysis compile time optimizations concurrent programs 
discussing related section conclude section 
linear pi calculus subtyping section introduce syntax type system process calculus linear channels type reconstruction algorithm section 
calculus considered asynchronous fragment polyadic calculus mil close core languages ky pict pt 
similar original linear calculus kpt allows subtyping ps recursive types treated unlimited channels channels times coerced linear channels 
types uses sketched section instance channel type constructor annotated usage information called uses 
de nition 
means channels means channels means channels arbitrary number times 
metavariables uses 
syntax types de ned follows 
de nition set bare types ranged set types ranged syntax bare type may abbreviated denotes type channels tuple values types transmitted 
superscripted resp called input output resp denotes channel input output resp 
example channel type denotes type channels sending value type receiving 
introduce countably nite set variables ranged metavariables de ne type environments 
de nition type environment mapping nite set variables set types 
write dom domain write abbreviated type environment dom fx ng 
dom write type environment dom dom fxg operations uses types type environments de ned 
de nition binary relation uses total order de ned 
de nition summation uses written commutative associative operation satis es 
summation types written de ned bare types identical example 
operation types pointwise extended type environments 
de nition summation type environments de ned follows dom dom dom dom dom dom dom dom dom example de nition product uses written 
commutative associative operation satis es 




product extended operation uses types 


extended operation uses type environments 


example 

example 
example 


process expressions syntax process expressions di ers slightly section introduce new syntax choice process de nitions def corresponds attach type annotations recovered type reconstruction algorithm variables pre process de nitions 
de nition set process expressions ranged de ned parallel composition channel creation output atom 
xm nm guarded choice input pre xes def local process de nition bound variables process expression de ned customary fashion variable bound def variables bound def 
variable bound called free variable 
de ne conversions bound variables customary manner assume implicit conversions bound variables process expression di erent bound variables free variables 
notation sequence variables may written write abbreviated process expression obtained replacing free variables write 
give higher precedence example means omit type annotations important 
intuitive meanings expressions introduced section follows 
guarded choice input pre xes 
xm nm waits value arrive channels xm receives channel behaves local process de nition def rst creates fresh channel spawns process repeatedly receives values channel spawns executes process regarded process de nition sense reduced output represents output process de nition expanded 
process de nition exactly times don count input output uses separately 
input set just technical convenience presenting type reconstruction algorithm 
give examples process expressions 
formal de nition reduction relation section 
example process reduced communication communication example process def reduced def 
example process def fact fact fact computes factorial outputs result 
simplicity assume integers booleans primitives 
reduced follows def fact 
fact 
def fact 
fact 
def fact 

def fact 

def fact 
typing type judgment form read typed type environment means typed ordinary sense channel uses type example type judgment means uses receiving value type uses sending value 
rules deriving type judgment 
type environments concerned uses variables need take special care merging type environments 
example totally output input total variable obtained adding uses type environments 
rule parallel composition par hand choice 
input pre executed 
expression typed type environment 
rule choice 

choice rule output atom follows 

expresses fact channel output 
takes account usage receiver 
similarly rule input pre follows 
typing rule local process de nition 

def 
def note case input pre def may executed rst premise means type environment necessary copy multiplied upper bound 
number spawned reason upper bound 
follows 
rst premise rule indicates may times output process time output invoked may times output spawns causes times output may cause spawned 
times 
second premise rule indicates may times output total number spawned bound 



example expression def produces copies produces copies total number messages sent 
rule channel creation moves corresponding binding type environment pre new rules sub weak standard rules subsumption weakening 
denotes subtyping relation introduced subsection 
sub weak subtyping relation channel type may type 
example channel type arbitrary number times input output may channel type order formalize type coercion give kinds subtyping relations non structural subtyping relation structural subtyping relation str relation allows outermost uses changed example holds 
resulting type system ik 
relation input output channel types ps allows general type coercion example str holds value type coerced type safe send value type channel value type expected 
relation enables faster analysis channels relation enables precise analysis see examples 
de nition binary relation types de ned example de nition binary relation str types de ned relation closed rule match ng str 
str str 
str str chan relation match types de ned match match ng 
example str 
de nition str partial orders 
respect str output channel type contravariant argument types input channel type covariant input output channel type invariant 
means sender put value subtype channel bare type receiver value extracted value supertype type form supertype type far shape di er uses value type 
write assume derived str sub 
want explicit write write str str 
rest section give examples typing processes 
rst premise match removed sound type system 
include just order simplify discussions type reconstruction 
example holds 
shown examples relation str gives accurate judgment usage channels type reconstruction complicated 
example process 
uses output typed subtyping relation 
suppose executed parallel 
receiver uses input output fact typed 
str str str 
judgment derived weaken type environment 
information output lost 
example process 
input output typed subtyping relation 

receiver uses output input output fact 

str str 
weaken type attach 
information lost 
correctness type system prove soundness type system previous section respect operational semantics 
soundness mean type system correctly estimates channel example guaranteed output evaluation rst de ne operational semantics linear calculus subsection show correctness type system respect reduction semantics subsection corresponding proof original linear calculus kpt 
reduction semantics linear pi calculus standard presentation process calculi mil reduction semantics process expressions de ned relations structural congruence reduction relation 
de nition fv fv fyg zg fv set free variables structural congruence congruence process expressions closed rules 
fv def def fv def def fv example def def 
shall de ne reduction relation 
usually reduction relation written means reduced step 
relation annotated label written label special symbol variable form means reduced communication bound channel means reduced communication free channel means reduced replacing single occurrence note typed processes reduction relation coincides usual untyped reduction relation mil 
de nition relation relation closed rules 

comm yn call cong par 
new fv 
new def def def fv def def def fv de ned 
unde ned 
main di erence ordinary reduction semantics lies rules new capabilities communication removed binding channel 
example reduced communication longer channel example process expression def reduced communication free channel def def reduced communication channel def def derived applying rule def correctness uses channels kpt correctness type system shown subject reduction theorem theorem implies typedness process preserved reduction theorem implies lack immediate misuse channels typed process expressions 
valid subtyping relations str subject reduction theorem stated 
note reduction comes communication free channel second case reduced process typed type environment obtained removing consumed capabilities 
theorem subject reduction 

proof see appendix lack immediate misuse channels mean example case type system judges channel messages currently sent 
stated follows 
theorem run time safety suppose 
def def 
fj 
fj pg stands parallel composition 


pair binding pre 
furthermore bound def 

output binding def greater 
bound def 


input binding greater 
furthermore bound def 

output binding 





input binding 
proof trivial typing rules fact implies type reconstruction focus main goal type reconstruction 
consists phases rst phase constraints types uses extracted process expression second phase constraints solved 
section discusses rst phase 
second phase deferred section 
typing rules section suitable type reconstruction 
example consider infer typing process expression 
rule par tells rst compute general typings add obtained type environments 
don know receivers reconstruction step stops 
order avoid introduce type variables variables represent undetermined types uses keep information variables subtyping constraint 
general typing process represented pair consisting type environment subtyping constraint 
example general typings represented forms type variable variables subtyping constraints 
typings typing obtained pair reconstruction step expressed rule st par means variable bound subtype assumption means stronger constraint 
formal de nition de nition intended meaning new type judgment sp holds substitution types uses type variables satis es subtyping relations modi cations obtain process expression general pair modi ed type system de nition principal typings subsection 
describe algorithm compute principal typings subsection 
discussions rest section independent str subtyping relation 
type system reconstruction principal typing mentioned introduce countably nite set variables ranged replace expression 
de nition set expressions syntax 

call expression just call constant 
distinguish expression variables corresponding constant 
example identify 
countably nite set type variables ranged added set bare types 
operations 
types extended obvious way 
substitution ranged nite mapping type variables bare types variables uses 
write substitution maps write composition say ground maps variables constants type variables bare types type variables 
de ne subtyping constraint related notions 
de nition subtyping constraint set expressions form call element constraint expression 
de nition ground substitution solution holds expression de nition solution solution de nition preorder subtyping constraints closed substitutions 
dom dom write subtyping constraint dom example new typing rules reconstruction shown 
rules sub weak combined rules new rules syntax directed 
example derivable new type system 
avoid confusion write type judgment derived previous typing rules st new typing rules 
new type system essentially equivalent previous sense 
theorem equivalence type systems 
suppose st solution domain includes type variables sp 
st empty subtyping constraint 
proof rst part proved straightforward induction derivation st syntax directed rule corresponds combination old rules 
second part follows fact derivation st constructed combining derivation steps rule weak sub derivation steps 
principal typing process expression general pair st formal de nition follows 
de nition principal typing conditions satis ed st st exists substitution sc sp st par 


st choice 
st st 


def st def st new syntax directed typing rules example 
principal typing jr kr js ks jr kr js ks channels output contain js ks similarly channel input contain sent value type type subtype summation expressed constraint jr kr type reconstruction algorithm ptu type reconstruction algorithm obtained reading new rules bottom manner 
describing algorithm introduce auxiliary functions algorithm 
computes general pair functions solving 
respectively 
de nition de ned procedure type environments dom dom dom dom kx kx fresh dom type environment dom dom dom jx kx fresh dom dom dom dom dom dom de nition de ned procedure type environment dom dom dom jx kx fresh dom dom de ned de ne similarly 
de nition de ned procedure type environment dom dom jx kx fresh 
dom example jx kx jy ky jx kx jx kx kx kx kx jy ky type reconstruction algorithm ptu shown takes process expression input returns principal typing mentioned programmer need put type annotations process expression passing process expression ptu system automatically put fresh place type annotations omitted 
note ptu may succeed example consider process def violates rule channel bound def input ptu succeeds outputs subtyping constraint including kind process rejected satis ability checked phase constraint solving described section 
prove ptu computes principal typing theorem correctness ptu sp ptu outputs principal typing proof see appendix recovering type annotation constraint solving previous section showed compute principal typing process expression solving subtyping constraint nd type annotation detect linear channels 
possible type annotations interested optimal sense uses channels created estimated small possible want nd linear channels possible 
rst de ne optimality type annotations discuss solution gives optimal annotation subsection 
show compute solution depends course particular subtyping relations describe case subsection case str subsection 
type variable assumed fresh 
fx denotes type environment domain restricted dom fx ptu ptu ptu ptu 
ptu 
ptu 
ptu ptu dom fxg ptu jn kn jn kn ptu ptu fy ng dom ptu def ptu ptu 
fx fxg xi gg 
xi dom ng dom jy ky type reconstruction algorithm ptu simplicity consider closed process expressions 
process containing free variables analyzed purpose separate compilation programmer declare type information free variables 
uses need necessarily declared assigned unknown uses 
case type declaration unnecessary 
type declarations delay instantiations certain type variables keep constraints 
algorithm incremental constraint solving easily obtained algorithms described subsection transform constraints step step 
optimality type annotation state optimality type annotation introduce ordering process expressions 
means process expressions identical type annotations pair outermost uses type appearing equal greater type corresponding position de nition relation process expressions relation closed rules 
pm 
xm nm 
xm nm pm def def optimality type annotation de ned follows 
de nition substitution types uses type variables process expression optimal respect sp sp example substitution optimal respect 
st implies sp solution obtain optimal type annotation computing solution assigns variables small uses possible 
de nition substitution minimal solution solution solution sj variable appearing theorem closed process expression ptu 
optimal respect minimal solution assigns variables appearing proof trivial de nition minimal solution 
theorem focus attention nding minimal solution subtyping constraint subject subsections 
constraint solving structural subtyping subsection discusses solve subtyping constraint case relation de nition constraint expression reduced equality bare types inequalities uses 
equalities bare types solved ordinary rst order uni cation assume de nition ptu auxiliary functions bare types constant variable 
inequalities uses solved simple iterative method 
describing details show simple example 
example reduced equality constraints inequalities uses 
solving equality constraints obtain obtain solving inequalities 
obtain substitution minimal solution describe details solve equalities bare types inequalities uses 
mentioned solving equalities bare types rst order uni cation problem 
de nition substitution uni er set pairs bare types ng 
uni er general uni er exists substitution theorem uni cation rob suppose expression appearing constant variable 
exists algorithm computes general uni er set uni er exists reports failure uni er exist 
nal task solve inequalities uses 
interested minimal solution need nd solution solution assigns variables small uses possible 
de nition ptu assume inequality variable constant 
inequalities uses divided sets fj fc constant 
loss generality assume comprise variables occur distinct add constraints appear replace inequalities single inequality 
represents upper bound 
solution rst set inequalities computed checked solution second part 
check fails original subtyping constraint solutions 
operation uses monotonic variables range nite space solution rst part calculated simple iterative method lemma solution inequalities uses fj fc distinct constant 
de ne solution set solution solution 
solution proof variable range nite space operations uses monotonic exists holds ng 
show solution suppose holds suces show mathematical induction base case trivial 
suppose ng 
ng show second part lemma 
suppose solution solution rst part ng 
fn mg implies solution case solution easy solution implies solution steps obtain minimal solution theorem minimal solution subtyping constraint constraint expression variable constant 
cg cg 
solution solution set inequalities successfully obtained minimal solution solution reports failure reported solution 
proof follows theorem lemma 
computational complexity informally discuss computational cost computing solution inequalities uses 
show cost computing solution set fj polynomial size set 
discussion refers de ned lemma size size de ned constant variable size size 
increases monotonically increases number steps iteration 
step total cost computing size 
max size 
number inequalities twice size subtyping constraint set size process expression auxiliary functions add times constraint expressions number variables process expression 
result computational complexity computing solution polynomial size expression 
note estimation order rough may better upper bound 
constraint solving structural subtyping subsection discusses case relation str de nition rule constraint expression implies condition match 
match means di er uses essentially solved rst order uni cation uses ignored 
match satis ed constraint expression str reduced constraints form 
solved iterative method 
assignment variables increase assigned step step constraints get satis ed true step 
simpli ed formal description algorithm consider simple example 
example condition match instantiated bare type fresh variables reduced constraints uses rst conditions come come assign variables 
satis ed assignment incremented 
true conditions simpli ed assignment incremented satis ed 
conditions satis ed obtain minimal solution describe algorithm formally 
extend de nition match match holds type variables 
introduce procedure condition match 
takes subtyping constraint input outputs general substitution match holds constraint expression sc outputs fail substitution 
call subtyping constraint matching constraint fm match holds procedure match described fm 
de nition de ned procedure stands union disjoint sets cg empty substitution 
ng fail occur ng jn kn fresh 
fail occur ng jn kn fresh 
fail lemma subtyping constraint 
exists matching constraint succeeds outputs sc matching constraint exists substitution outputs fail proof similar proof correctness match fm 
example 

interested minimal solution assign bare type type variables instantiated subtyping constraint transformed simpler constraints uses step step 
describe algorithm rewriting quadruple 
represents subtyping constraint reduced constraints uses 
sets inequalities uses keeps inequalities satis ability needs checked keeps checked inequalities 
matching constraint variables rewriting steps solution satis ability fj preserved 
solution rewriting terminates quadruple contains expressions form 
minimal solution need preliminary de nitions 
order transform subtyping constraint conditions uses step step extend syntax constraint expression de nition solution subtyping constraint 
de nition extended subtyping constraint set expressions form extended subtyping constraint said matching match de nition substitution solution extended subtyping constraint implies example solution fj 

de nition relation quadruples relation closed rules fj fj sj ng ng example quadruple fj fj rewrites fj steps fj fj fj fj fj fk fj 
fj quadruple called normal form 
obtain minimal solution matching constraint rewriting system 
lemma matching constraint constraint expression appearing variable constant 
type variables variables rewrites normal form 
solution empty minimal solution solutions empty 
proof see appendix combining rewriting system obtain algorithm compute minimal solution subtyping constraint 
theorem minimal solution ii subtyping constraint constraint expression appearing variable constant 
solution minimal solution successfully obtained rewriting system minimal solution solution outputs fail rewriting system reports solution proof follows lemmas 
example detection optimization show example detection linear channels consider closed process expression computes th fibonacci number sequentially language extended integer values boolean values operations def output variable output denotes special channel type int 
infer values variables attached channel ptu outputs pair int int int int 
show slightly simpli ed constraint 
type variables denote bare types respectively 
variables denote input output process 
similarly denote uses process 
rule parallel composition obtain expression expression int obtained input pre 
similarly int obtained expression int 
rst step know int int int obtain inequalities solving obtain implies linear channel 
similarly know linear 
information obtained replace process optimized def int int def int def int output optimized program channels receiving results recursive calls created def 
value sent channels received immediately variable sized bu ers storing sent values blocked receivers longer required implementing channels created def communication implemented eciently 
linear channels memory space reclaimed immediately 
note optimized process corresponds continuation passing style representation app functional fibonacci program channels viewed continuations 
experimental results section show results simple experiments compiler evaluate performance improvement obtained analysis show elapsed time analysis 
application programs include example fibonacci function described previous section concurrent objects expressed 
encoding optimization concurrent objects showing results explain concurrent objects realized language optimization enabled analysis 
state concurrent object implemented channel method implemented process rst extracts current state channel executes method replies result puts new state channel 
fragment process expression corresponds typical method de nition def arg state 
result state news receiving argument arg method channel replying result extracts current state channel state computation result replied new state news object put state 
caller method typically form rst creates channel receiving result invoke method argument waits result carry rest computation analysis translated def cases 
similarly example fibonacci function described previous section transformed process implemented eciently 
experiment results evaluation evaluate performance improvement programs sequential fibonacci program shown optimization example parallel fibonacci program performs recursive calls parallel counter increment program counter creates counter object increments value times tree summation program tree creates binary tree node concurrent object computes summation values leaf nodes simulation conway life game life knuth bendix completion algorithm kb 
experiment applied kinds optimization source level program transformation process expression form known linear channel transformed def 
special case entire expression replaced transformation may able hoist app process de nition top level reducing number dynamic process creation 
example def transformed def compiler translates program program manner similar sml tal 
compiler available single processor workstation network workstations 
just show performance single processor workstation 
table running time benchmark programs naive sec opt 
sec func 
sec counter tree life kb free variable result receiver process waiting created statically 
applied method invocations concurrent objects function calls 
re nement run time representation linear channels 
ordinary channels implemented variable sized bu ers storing sent values storing blocked processes waiting channel values received 
hand linear channels implemented place bu ers 
saves memory space required channels 
send receive operations linear channels optimized 
send function ordinary channel rst checked receiver bu er channel empty sent value put bu er receiver extracted bu er executed 
call send function involves channel status check update value receiver bu ers 
hand linear channel costs substantially reduced 
bu ers updated communication occurred 
second channel status check eliminated 
notice value sent status channel empty receiver ready 
prepared versions send functions just switched function pointers receiver put bu er 
applied immediate reclamation memory space linear channels 
row table shows result program 
rst column naive shows running times unoptimized programs written concurrency primitives second column opt shows running times programs optimized analysis 
addition show third column func running time program written function primitives sequential fibonacci 
note programs executed single processor machine sun sparc station hyper sparc mhz slower overheads 
result sequential fibonacci program indicates programmers implement functional computations concurrency primitives compiler generate optimized code comparable written directly function primitives 
speedup ratio parallel fibonacci program relatively smaller overheads multi threading large 
note speedup deemed important execution time fibonacci program dominated communications function calls local computations integer comparison summation 
life kb perform communications frequently speedups smaller 
table elapsed time analysis size 
solve standard nodes msec msec msec tree counter life kb programs counter tree estimating performance improvement typical concurrent object oriented programs 
represent extreme cases counter method invocations frequent creations concurrent objects tree creations concurrent objects happen frequently method invocations 
table shows elapsed time analysis set benchmark programs 
implemented analysis subtyping relation written standard ml new jersey running ss hyper sparc mhz 
rst column size shows sizes parse trees programs 
second column third column solve show elapsed times type reconstruction constraint solving respectively 
implementation integrates uni cation phase constraint solving type reconstruction third column shows elapsed times solving inequalities uses 
fourth column standard shows elapsed times standard information type reconstruction 
type system includes ml style complexity type reconstruction theoretically exponential 
kb type reconstruction algorithm times slower standard 
believe faster ecient implementation 
cost solving inequalities type reconstruction 
related origin channel type system subtyping proposed pierce sangiorgi ps linear channel type system kobayashi pierce turner kpt 
results theoretical mainly concerned checking channel usage reasoning program behavior 
type reconstruction problems open applications type systems concurrent programming languages limited kpt claimed linear channels potentially useful program optimization applied actual compilers 
turner wadler mossin proposed similar static analysis technique nding values functional programming languages 
type system simpler constraints variables result variable syntactic occurrence inferred 
possible apply technique directly detection linear channels trivial re ne technique accordingly notice communication channel normally syntactic occurrences occurrence input output 
nielson nielson nn proposed technique nding linear channels ect analysis nn 
analysis ective detection linear channels counts operations channels region possibly nite set communication channels 
example def number output operations performed channel counted analysis counted analysis 
colby col proposed technique analyzing communication interpretation potentially applicable detection linear channels 
analysis ective detection linear channels applied detection linear channels nite number channels uniquely identi ed control paths concrete semantics mapped abstraction function control path method give rise problem mentioned 
kobayashi yonezawa proposed technique nding linear channels linearized channels kpt 
complex far linear channels concerned type analysis gives accurate results costs 
mer proposed algorithm analyzing communication target language restricted channels rst class values dynamic process creation allowed 
developed type reconstruction algorithm linear channel type system subtyping input output channel types 
technique performing source level program transformations tail call optimization reducing runtime costs communications analysis structural subtyping applied compiler concurrent language performance improvement gained optimizations measured 
believe technique proposed applicable similar concurrent programming languages 
includes evaluation analysis realistic especially distributed applications 
focused channel usage usage information values tuples function closures obtained analysis iga left utilize information program optimization ecient memory management 
originally motivated discussions linear channels benjamin pierce david turner 
active discussions great help especially nding right direction initial stage 
ito carefully read earlier draft gave number useful suggestions 
grateful akinori yonezawa comments 
shimizu helped experiment compiler 
anonymous referees comments helped improve presentation 
igarashi research fellow japan society promotion science 
app andrew appel 
compiling continuations 
cambridge university press 
col christopher colby 
analyzing communication topology concurrent programs 
acm sigplan symposium partial evaluation semantics program manipulation pages 
fm chin mishra 
type inference subtypes 
theoretical computer science 
gay simon gay 
sort inference algorithm polyadic calculus 
acm sigact sigplan symposium principles programming languages pages 
iga atsushi igarashi 
type analysis usage values concurrent programming languages 
master thesis university tokyo february 
ik atsushi igarashi naoki kobayashi 
type analysis communication concurrent programming languages 
fourth international static analysis symposium sas volume lecture notes computer science pages 
springer verlag september 
naoki kobayashi akinori yonezawa 
static analysis communication asynchronous concurrent programming languages 
second international static analysis symposium sas volume lecture notes computer science pages 
springer verlag 
naoki kobayashi 
partially deadlock free typed process calculus 
acm transactions programming languages systems 
preliminary summary appeared proceedings lics pages 
kpt naoki kobayashi benjamin pierce david turner 
linearity 
acm sigact sigplan symposium principles programming languages pages january 
ky naoki kobayashi akinori yonezawa 
higher order concurrent linear logic programming 
theory practice parallel programming volume lecture notes computer science pages 
springer verlag 
mer nicolas algorithm analyzing communicating processes 
brookes main melton mislove schmidt editors mathematical foundations programming semantics volume lecture notes computer science pages 
springer verlag 
mil robin milner 
polyadic calculus tutorial 
bauer brauer schwichtenberg editors logic algebra speci cation 
springer verlag 
nn hanne riis nielson flemming nielson 
higher order concurrent programs nite communication topology 
acm sigact sigplan symposium principles programming languages pages 
nn hanne riis nielson flemming nielson 
static dynamic processor allocation higher order concurrent languages 
tapsoft theory practice software development lecture notes computer science pages 
springerverlag 
ps benjamin pierce davide sangiorgi 
typing subtyping mobile processes 
ieee symposium logic computer science pages 
full version mathematical structures computer science vol 

ps benjamin pierce davide sangiorgi 
behavioral equivalence polymorphic pi calculus 
acm sigact sigplan symposium principles programming languages pages paris france january 
pt benjamin pierce david turner 
pict programming language pi calculus 
technical report computer science department indiana university 
appear milner festschrift mit press 
rep john reppy 
cml higher order concurrent language 
proceedings acm sigplan conference programming language design implementation pages 
rob robinson 
machine oriented logic resolution principle 
journal acm 
tal david tarditi anurag acharya peter lee 
assembly required compiling standard ml technical report cmu cs school computer science carnegie mellon university november 
david turner philip wadler christian mossin 
type 
functional programming languages computer architecture pages san diego california 
vh vasco vasconcelos kohei honda 
principal typing schemes polyadic calculus 
concur volume lecture notes computer science pages 
springer verlag 
yon akinori yonezawa 
abcl object oriented concurrent system 
mit press 
yt akinori yonezawa mario tokoro 
object oriented concurrent programming 
mit press 
pages 
proof subject reduction theorem theorem need lemmas prove theorem 
follows write dom 
lemma suppose 
exist 


exist 

exist 
def exist 




proof easy 
derivation case ends application typing rule corresponding form followed consecutive applications rules sub weak 
notice consecutive applications sub weak replaced application rule parts sub weak may applied premise application choice new 
lemma str satisfy conditions 



suppose de ned proof easy de nitions str lemma exist 
de ned 
proof prove need prove stronger statement 
zn exist zn de ned de ned ng 
zn yn proved straightforward induction derivation 
zn sub cases 
lemma special case statement 
note loss generality assume dom zg weak 
lemma proof straightforward induction proof cases follow commutativity associativity operation type environments 
base cases easy induction steps 
lemma def def 
proof structural induction derivation case analysis rule 
cases induction steps easy show base case call 
assumption def lemma obtain 

cases value 
show case 
case 
de nitions 

lemma 
str 
lemma rule weak rule def 
def nishing subcase 
subcase similar 
proof theorem prove structural induction proof variable case analysis rule 
case comm 



lemma obtain zn 
zn zn lemma 
cases values show case 
lemma 
ng str zn 
rule weak sub fxg lemma rule weak fxg rules sub weak nishes subcase 
subcases similar 
case call case excluded label case cong follows lemma 
case par show case variable assumption lemma exist induction hypothesis lemma easy show nishes case 
case def follows lemma 
case new new def cases easy 
proof theorem prove theorem need lemmas 
lemmas ensure auxiliary functions output general type environment subtyping constraint 
intuitively expect outputs general case de ned may pair summation directly introduce extra type environments summation de ned satis es general pair satis es lemma suppose exists substitution denotes dom dom type variable domain 
proof respectively de nition dom dom respectively 
rst part trivial 
substitution dom type variables substitution exists type variable fresh 
dom dom dom dom 
note domain includes fresh variables 
easy show implies equivalent 
letting nishes proof 
lemma suppose 

exist sc lemma suppose 

exist sc proofs lemmas similar lemma 
lemma st st proof induction derivation st transitivity fact implies proof theorem structural induction derivation st sp case analysis rule 
show cases cases similar 
case st par st sp st sp rst show st ptu 
ptu 
induction hypothesis st 
lemma satis es lemma st 
st par st show exists substitution sp induction hypothesis exists substitution sp 
domains disjoint includes fresh type variables stands union mappings domains disjoint 
lemma satis es letting nishes case sp equivalent note dom disjoint type variables proof lemma constructed extending mapping fresh variables 
case st new st rst show st ptu 
ptu 
induction hypothesis st show subcase dom 
fxg st rule st new 
show exists fxg 
induction hypothesis extending possible type variables distinct variables 
sc fs 
subcase dom similar 
proof lemma prove termination rewriting system introducing founded order quadruples 
preliminary de nitions 
size jcj extended subtyping constraint de ned follows jc gj jcj jc gj jc gj 
extend uses pointwise substitutions uses dom dom variable dom 
proper order substitutions uses variables de ned jc jc jc jc lemma set quadruples founded 
proof lexicographic product founded orderings integers 
lemma rewriting system strong normalizing 
proof easy show inspecting rules 
note third rule jc gj jcj 

jcj 

jc ng strong normalization follows foundedness 
rewriting steps preserve properties lemma suppose 
matching constraint contains type variables constraint expression variable constant left hand side variable constant satisfy conditions 
solution fj sj dom solution fj dom 
solution solution proof induction length rewriting steps inspection rewriting rules 
proof lemma lemma rewrites normal form 
empty solution fj sj dom includes constraint expression form quadruple normal form solution lemma 
lemma solution hand empty solution includes constraints form lemma quadruple normal form lemma solutions 
benchmark programs section shows programs experiments section 
benchmark programs translated written target language extended mathematical operations conditional expressions records 
programs output special channel represents output device display fl constructs record eld names respectively selects eld record fibonacci functions naive optimized sequential bs described example analysis section 
naive parallel def output optimized expression def def output counter objects naive implementation counter object def init st st init def st st get state counter def ack st ack st increment counter fget ig def incr ack invoke method times ack incr ack incr get output program optimized def init st st init def st st def ack st ack st fget ig def incr ack ack def incr ack def def get output incr tree summation naive implementation tree object def newnode left right rep node object leaf object holding st st left right def st st sum sum rep sg def rep newnode rep left right newnode left right rep sum output optimized program def newnode left right rep st st left right def st st def sum sum rep sg def rep newnode rep def left right newnode left right rep def sum output 
