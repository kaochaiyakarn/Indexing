automated mathematical induction adel emmanuel kounalis micha rusinowitch inria lorraine bp nancy france laboratoire informatique avenue einstein france proofs induction important computer science arti cial intelligence applications particular program veri cation speci cation systems 
new method prove disprove automatically inductive properties 
set axioms suited induction scheme constructed automatically 
call induction scheme test set 
proving property just instantiate terms test set apply pure algebraic simpli cation result 
method needs completion explicit induction 
retains positive features completeness robustness 
implemented theorem prover spike motivation inductive reasoning simply method performing inferences domains exists founded relation objects 
fundamental proving properties numbers data structures programs axiomatised set equations conditional axioms 
conditional axioms de nitions known computer science programs logical functional style datastructures expressed framework 
opposed deductive theorems inductive theorems usually valid particular models axioms 
instance herbrand models initial models nicely semantics data type speci cations logic functional programming 
classical example consider data structure nonnegative integers built function symbols 
element structure represented variable free ground term involves 
suppose de ne addition operation axioms preliminary versions results international symposium arti cial intelligence mathematics fort lauderdale florida january bulletin european association theoretical computer science june 
clearly adding integers equations yields nonnegative integer 
instance equates deductive reasoning apply just twice second axiom rst 
consider property associativity typical example identity proof requires kind induction 
everybody knows experience dioecult nd appropriate founded relation support inductive inferences guess suitable induction hypothesis 
main approaches proposed overcome 
rst applies explicit induction arguments structure terms 
second involves proof consistency inductionless induction method 
prove associativity explicit induction scheme basic case induction step implies proof basic case trivial proof induction step follows immediately de ning axioms induction hypothesis 
hand prove property inductionless induction rst try compile axioms convergent terminating set rewrite rules 
example suoecient orient axioms left right 
associativity added rule oriented right left completion procedure started order transform set rules convergent computing critical pairs 
critical pairs trivial identities associativity proved 
methods limitations theorems proved underlying theory 
guiding proof explicit induction requires skill nding right axioms hypotheses apply 
hand inductionless induction technique require guidance user generation lemmas performed automatically completion procedure 
completion misses lemmas inductionless induction fails explicit induction succeeds 
associativity oriented left right example inductionless induction fails prove completion procedure loops case 
exist realistic inductionless induction procedure conditional theories 
disadvantage inductionless induction explicit induction needs ground convergence property axioms hard achieve 
explicit induction techniques need hierarchical structure managing subgoals order avoid ill founded induction steps 
point crucial handling mutually recursive de nitions 
advances concerning problematic aspect explicit induction 
explain important point 
proof inductive theorem reduces proof lemma proof may independent may require instances order succeed 
global proof valid instances smaller considered inductive hypotheses 
inductionless induction need check instance smaller rewrite step instance conjecture derived lemma valid structure proof procedure 
need build proof hierarchical way accounting explicit ordering relation instances 
explicit induction refute trivially unsatis able problems 
inductionless induction allows detect general false conjectures 
complete non conditional theories 
alternative proof system automating inductive reasoning theories de ned conditional axioms 
show prove disprove equations generally clauses herbrand models 
proof system attempt combine power explicit induction inductionless induction 
explicit induction explicit induction schemes called test sets control generation lemmas 
need axioms ground convergent rewrite system 
inductionless induction require construction hierarchy lemmas proved 
highlights related works method relies notion test sets essence nite description initial model uses pure algebraic simpli cation 
simpli cation strategy axioms previously proved conjectures instances conjecture soon smaller currently considered proposition respect founded relation 
point captures notion induction hypothesis proof induction paradigm 
main observation axioms oriented terminating set rules provide natural founded ordering support induction 
main arguments favour method ffl works functions incompletely de ned relations constructors case boyer moore system ffl correctness require theory turned convergent set axioms ffl provides automatically induction schemes algorithms computing test sets ffl allows refute false conjectures axioms ground convergent conditional rewrite system complete sense equation valid initial model disproved provided axioms turned ground convergent unconditional rewrite system ffl implicit induction require hierarchy handling induction hypothesis words checks hypothesis smaller goal simpli es 
guaranteed structure procedure properties rewriting relations applied 
ffl restricted equational theories applies conditional theories ffl restricted proof equations applies non orientable equations general clauses 
hofbauer rst notice inductionless induction techniques ground property input set equations relaxed 
procedure completion framework computing critical pairs testing conjectures ground reducibility 
procedure propose rst version appeared june combine steps test sets 
approach developed general conditional axiomatisations require ground convergence property correctness 
due property test sets easily proved complete theory ground convergent set equational rules 
reddy related method non conditional case july 
notion covering sets developed analogous test sets computing induction schemes 
procedure known deriving covering sets 
surprising equational theory set variables covering set set particularly useless induction 
understand covering sets assert perform induction automatically providing constructive de nition induction schemata 
notion covering set disprove false conjectures 
hand give procedure obtain test sets conditional case 
related induction proof complete extended strategies 
instance allow simpli cation conjectures conjectures fundamental feature eoeciency shown computer experiments 
layout structure follows 
section inference system simple example 
section introduce essential notions 
particular de ne useful rewriting relations 
section provide basic theorems proving disproving inductive conjectures 
give general inference system perform induction show correctness 
prove completeness convergent equational theories 
section introduce methods get completely operational proof system 
particular show convergence property required completeness correctness obtained knuth bendix procedure semantic techniques speci hierarchical axiomatisations 
computation test sets generally undecidable propose section method obtain test sets conditional theories free set constructors 
section describes general proof procedure shows proof session spike software discusses computer experiments related systems 
overview approach examples discussing technical details method propose proofs inductive theorems rst describe inference system simple example positive integers cut ooe gcd functions predicate 
arrow just indicates apply conditional equation simpli cation gamma gamma succ gamma succ gamma succ true false true succ succ true false succ succ false true gcd succ succ gcd succ gamma false gcd succ succ gcd gamma succ gcd gcd consider conjectures gamma false succ true true false false false true gcd succ false false true propositions valid standard arithmetic 
note state total ordering integers 
prove induction 
method rst step consists computing test set 
techniques section get test set succ true falseg 
step consists replacing variables conjecture elements test set checking instances pure simpli cation 
simpli cation strategy may axioms previously proved conjectures instances conjecture long smaller noetherian relation contains rewriting relation currently considered proposition 
point captures notion induction hypothesis proof induction paradigm 
equation instances need checked gamma succ gamma succ 
rst reduces immediately trivial identity 
second consider reduction notice induction hypothesis succ gamma succ 
gamma 
non trivial instance succ succ false succ succ 
false derivation induction hypothesis satisfy condition 
argument employed 
instances test set 
non trivial case succ succ true succ succ false case analysis split formula conjunction true true true succ succ false true succ succ true succ succ false trivial split true false false false succ succ true true false succ succ false succ succ true trivial contains instance true false conjecture smaller subgoal succ succ true succ succ false induction step 
subgoal solved 
proved exactly way 
consider 
disprove going convergence property initial system 
instances considered succ false succ succ succ false 
rst reduces true false members irreducible dioeerent 
conjecture false 
consider instance succ false succ true 
reduced true false false true valid 
preliminaries assume reader familiar basic notions horn theories rewrite systems 
introduce essential terminology refer detailed presentations 
material section divided parts rst basics conditional equations overview fundamental rewrite concepts 
conditional theories terms substitutions signature sigma pair set sorts nite set function symbols equipped mapping type theta value type type sort sigma denote fun sigma denote ff denote function type ff assume signature sigma sensible admits ground term sort 
signature sigma de nes set formulas built function symbols taken sigma free variables taken denumerable set variables 
family fx sets free variables indexed disjoint sigma 
sort sigma sigma set sigma terms sort constructed function symbols type ff root symbols variables sigma terms denoted ar stands set variables appearing sigma term ar denotes number occurrences variable term linear ioe variables ar 
ar empty set ground term 
sigma denote set ground terms sort sort nullary de nition sigma nite set 
furthermore set sequences positive integers ffl empty sequence delta concatenation operation sequences 
call elements positions denote de ne pre ordering ioe exists case de ne write ioe positions said disjoint denoted ioe term dom denotes set positions expression denotes subterm position denote symbol position position term said strict position variable position non linear variable position 
denote set strict positions write indicate subterm position denote term subterm sigma gamma substitution fx assigns sigma gamma terms appropriate sorts variables 
applied sigma gamma term simultaneous replacement occurrences sigma gamma terms values greek letters oe denote substitutions 
composition substitution oe denoted oej 
sigma gamma term tj obtained applying substitution called instance applies variable domain ground term say ground substitution 
tj ground ground instance syntactic equality terms denoted term uni es term exists substitution oe toe soe 
conditional equations clauses sigma signature 
sigma equation pair sigma terms sort sort conditional sigma equation sigma equation expression forms sigma equations 
conditional sigma equation said conditions 
sigma formula sigma clause built sigma equations symbols words sigma formula expression form en sigma clear context omit pre sigma sigma gamma 
axiomatisations built conditional equations goals proved clauses disjunction equational literals predicate 
shall identify conditional equation corresponding representation clause 
inductive theory set conditional equations ax signature sigma recall herbrand model ax model ax domain set ground terms axioms equality implicitly assumed valid 
formula deductive theorem ax valid model ax 
denoted ax deductive theorems proved refutation deriving contradiction ax 
usually transformed universal sentence introducing skolem functions 
signature sigma extended 
theorem proving techniques rely herbrand theorem implies ax unsatis able ioe herbrand model extended signature 
notion inductive theory related special kinds models herbrand models initial models constructor models 
study initial herbrand model approaches de nition ax set conditional equations signature sigma 
clause inductive theorem ax ioe ground substitution oe eoe valid ax 
denoted ax ind clauses validity herbrand models general validity initial model 
notions validity coincide unconditional equations proposition clause inductive theorem ioe valid herbrand model ax 
unconditional equation inductive theorem ioe valid initial model ax 
rewrite relations binary relation 
resp 
gamma denotes transitive closure resp 
inverse 
binary relations ffis denote composition 
relation ffi 
gamma written short 
relation noetherian nite sequence 
suppose reduction ordering set terms transitive relation noetherian monotonic implies stable implies soe toe 
write delta strict subterm reduction ordering extended literals comparing multisets members multiset extension see 
formulas compared multiset extension ordering multiset atomic subformulas 
ambiguity extensions denoted 
equation written provided soe toe ground substitutions oe 
case say equation orientable rule 
conditional equation written oe oe oe oeg ground substitutions oe case say conditional equation orientable conditional rule 
term left hand side rule 
set conditional rules rewrite system 
conditional rewriting idea rewriting impose direction equations proofs 
direction indicated arrow independent instantiation means replace context 
instance conditional equation orientable valid conditional part applied rule 
conditions checked recursive call theorem prover 
termination ensured requiring conditions smaller reduction ordering 
various conditional rewrite relations studied literature 
de nition set conditional equations term 
write soe toe exists substitution oe conditional equation 
soe toe 
ng oe gamma oe 
fl soe fa oe oe oe oeg term reducible term say irreducible denote system quali ed convergent gamma note set conditional rules relation similar notion decreasing rewriting dershowitz okada sivakumar 
relation extended sets clauses natural way de nition fcg fdg case rewriting case reasoning technique basis theorem proving strategies 
important rule context inductive theorem proving case splitting arises naturally induction hypothesis 
propose notion case rewriting suited inductive reasoning allows derive clauses admit smaller instance conjecture 
case derived clause easily proved induction argument see introductory example 
de nition case rewriting set conditional equations conditional equation positive literal 
soe clause oe substitution set clauses 
case rewriting rule stated follows fa soe ng coe soe coe toe de nition generalised case conjunction positive literals straightforward way 
denote proposition basis proving disproving clausal theorems 
proposition case rewriting rule sound derived set clauses logically equivalent initial set provided contains 
proof trivial 
note relation 
external control necessary applying rewriting technique simplify goals 
supported rewriting introduce new rewrite relation useful expressing inductive hypothesis prove premises conditional rule 
consider instance theory fp true true trueg 
order prove true assume induction true apply conditional equation true true order rewrite true 
recursive conditional rewriting la kaplan allow step condition equation proved means axioms 
formal de nition extended notion rewriting de nition supported rewriting set conditional equations set equations term 
de ne supported rewriting relation 
soe 
toe exists substitution oe conditional equation 
soe toe 
ng oe gamma oe 
fl soe fa oe oe oe oeg empty set unconditional equations write 
sake simplicity shorten 
fu vg 
relaxed rewriting rewrite relation introduce useful handle non orientable equations 
cases equational replacement step clause replaced term bigger replacing yields smaller clause chosen complexity ordering 
idea formalised notion relaxed rewriting 
oe say incomparable denote oe de nition relaxed rewriting set unconditional equations 
de ne relaxed rewriting relation substitution oe 
example fx consider conjecture suppose inductive hypothesis 
fx xg 
fx xg 
prove disprove inductive theorems section propose general methods prove disprove automatically sets clauses inductive consequences theories axiomatised sets conditional rules 
technique allows replace inductive reasoning pure algebraic simpli cation 
mechanisation inductive proofs notion test set essence provides nite description initial model conditional theory 
section divided parts 
rst discuss de ne key notion test set 
show proving theorems 
show test sets allow disprove theorems 
test sets rst give motivation test sets standard structural schemes covering sets 
consider theory axiom proposition valid initial model models really need induction proved initial model reduces elements 
suoecient check theorem values trivial task 
looking method produce induction schemes terms informative terms 
ensure situations captured exhibit ground irreducible terms depth explains technical depth conditions single test sets cover sets 
furthermore important point concerning eoeciency cardinality test set smaller general cardinality covering set require element test set admits irreducible ground instance 
partly motivates second requirement de nition 
rewrite rule left linear linear 
rewrite system rule left linear said non left linear 
term strongly irreducible non variable subterms instance left hand side position juj length corresponding string gives depth 
term depth maximum depths positions denoted depth 
strict depth written maximum depths strict positions depth rewrite system denoted depth de ned maximum depths left hand sides similarly strict depth written maximum depths strict positions left hand sides rewrite system partitioned left linear rules ll non left linear rules nl ll nl depth ll denotes maximum depths left linear rules ll depth nl denotes maximum depths non left linear rules nl number equal depth depth nl depth ll depth ll equal depth 
said bound de nition set conditional rules test set nite set irreducible terms properties completeness irreducible ground term exists term ground substitution oe toe non ground term position non ground term juj depth exist nitely strongly irreducible ground instances non ground term variables depth greater equal 
show notion test set really needed automating induction 
completeness property allows prove theorems induction domain irreducible terms set terms see theorems 
second properties crucial refutation inductive conjectures see theorem 
order derive useful lemmas able apply rewrite rules instances conjecture 
reason instances deep ensured property 
left linear rules property may weakened suoecient consider non ground terms admit strongly irreducible instance 
taken equal depth gamma left linear theories de ned free set constructors 
important eoeciency purpose 
possible compute test sets equational theories relatively eoecient way see 
unfortunately algorithm exists general case conditional theories 
section give method compute test sets conditional theories de ned free set constructors 
example fa gg ff ag set fa test set come back introductory example 
set axioms 
pointed succ true falseg test set 
note set ground instances members test set contains ground irreducible terms relation properties de nition veri ed 
particular variables conjecture need instantiated induction schemes 
called induction variables shall prove necessary completeness 
intuitively variables occurs positions certain amount instantiation needed applying function de nition rewrite step position 
condition de nition follows potential rewriting subterm clause rule induction variable variable satisfying condition ii need instantiated looking match instance instance reducible position rule depends value instantiation unimportant consider induction variable 
de nition set conditional rules clause 
variable induction variable occurs subterm uni able left hand side rule ii position strict non linear variable position position variable occurs terms test sets build test substitutions induction variables 
de nition test set set conditional rules clause test instance respect instance obtained substituting renamed terms induction variables corresponding sort 
test substitution substitution maps variable domain renaming element sort 
example fx succ succ consider associativity property 
induction variables test instances respect succ succ succ succ succ succ succ succ succ 
inductive proofs simpli cation notion induction uses noetherian ordering ground terms contains conditional rewriting relation 
inductive hypothesis instance theorem want prove soon instance smaller currently considered 
propose rewriting relation sound respect induction hypotheses 
hand inductive hypothesis verify conditions conditional rule 
inductive hypothesis safe conditions conditional rule smaller respect noetherian ordering 
hand inductive hypothesis applied simpli cation goal axiom rule 
inductive hypotheses safe show situation smaller currently examined goal 
theorem formalises previous discussion shows prove equations class isomorphic initial models conditional theories 
theorem set conditional rules test set equation 
de ne ffi closure relation 
ffi 
fu vg test substitutions term ffi ffi inductive theorem proof suppose inductive theorem ground substitution smallest equation oe suppose irreducible exhibit smaller counterexample 
test substitution oe ground substitution oe 
hypothesis term uoe ffi voe ffi instantiation ffi ffi remains show term replacement occurring proof valid initial model logical consequence induction hypothesis 
give contradiction choice 
suppose instance uae unconditional step 
rst step replacement applied term smaller initial term uoe voe rewritten 
voe 

uae conditional step 
conditions evaluated smaller term rewrite instance equation proof smaller original goal voe straightforward generalize previous method prove clauses 
call tautology clause contains complementary literals instance theorem set conditional rules test set clause 
test substitutions fcg fp delta delta delta png clause tautology subsumed axiom contains instance strictly smaller inductive theorem proof consider ground instance coe stability rewrite relations fp oe oe delta delta delta pn oeg 
soundness coe logically equivalent conjunction clauses fp oe oe delta delta delta pn oeg 
tautologies subsumed axiom 
valid 
remaining ones contain ground instance smaller coe 
induction hypothesis valid 
conclude inductive theorem ground instances valid 
example prove transitivity 
see axioms introductory example false false true non trivial test instance succ succ false succ succ false succ succ true steps case rewriting get non tautological clause false false true succ succ false succ succ false succ succ true clause contains strictly smaller instance property proved 
theorem proof transitivity achieved 
disproving inductive conjectures notion test set particularly useful refuting inductive properties 
de nition provides criteria reject conjectures inductive theorems 
idea test instance clause subterm matches left hand side axiom derive ground instance clause property 
ensured properties test sets 
ground instance provides counterexample conjectured theorem 
de nition suppose set conditional rules test set 
clause em gn dn quasi inconsistent respect test instance coe oe inductive theorem satis ed oe oe oe oe strongly irreducible ii oe oe oe strongly irreducible iii oe oe oe oe strongly irreducible result shows set axioms convergent quasi inconsistent clause inductively valid 
proved building chosen ground instance clause false herbrand model axioms 
particular clause equation valid initial model 
theorem convergent set conditional rules test set quasi inconsistent inductive theorem example consider conditional axioms integers odd 
true false true odd false false odd true test set true falseg 
note axioms satisfy convergence property 
consider conjecture true odd false 
quasi inconsistent shown instance false 
proof theorem set left hand sides rules say term instance mean instance element form em gn dn clause quasi inconsistent respect test instance coe oe inductive theorem facts hold oe oe subterm oe oe instance ii oe oe subterm oe instance iii oe oe oe subterm voe instance shall prove theorem iii holds 
cases similar 
order show inductive theorem suoecient show dn oe inductive theorem ground instances em oe false hypothesis 
show case oe oe subterm oe oe instance inductive theorem ar gn dn fx aoe instance dn oe fx shall show exists ground instance aoej aoe subterm instance ensure dn oe inductive theorem cases depending groundness case suppose ground aoe ground clause 
oe oe rewrite term gn dn oe false convergence case suppose exists non ground 
suppose variables occur positions maximal number non ground subterms rooted positions depth equal depth 
oej strongly irreducible ground substitution instance oe aoej ij gamma aoej depth aoe note substitution instance exists property test sets 
show aoej contains subterm instance subterm aoej instance exist strict position aoej oej strongly irreducible term aoej instance cases depending linearity case suppose linear 
rst non variable position necessarily uv non variable position aoe property test sets 
aoej instance aoe uv aoej uv 
suppose set variable positions oe substitution xoe aoej uw 
note oe de ned linear occurences 
follows aoe soe aoe contains subterm instance contradiction 
case suppose non linear 
non variable position necessarily uv non variable position toe property 
aoej instance aoe uv aoej uv 
aoej uu aoej uu aoe contains subterm instance exist pair uu uu position aoe aoe uu aoe uu remainder proof case subcases depending groundness subterms aoe uu aoe uu case suppose aoe uu aoe uu ground 
aoe uu aoej uu aoe uu aoej uu aoej uu aoej uu aoe uu aoe uu contradiction 
case suppose aoe uu ground aoe uu non ground 
aoe uu aoej uu hand aoe ju depth exist position ij aoe aoe ij non ground uu ij jw ij depth depth aoej uu depth aoej ij 
depth aoej ij depth aoe de nition substitution oej 
depth aoe depth aoe uu depth aoej uu 
depth aoej uu depth aoej uu contradiction 
case suppose aoe uu aoe uu non ground 
aoe uu aoe uu exist position aoe uu aoe uu subcases depending groundness subterms aoe uu aoe uu suppose aoe uu aoe uu ground proof identical case 
ii suppose aoe uu ground aoe uu non ground proof identical case nb 
ii suppose aoe uu aoe uu non ground aoe uu aoe uu exist cases hold uu ij uu uu ij uu uu ij uu uu ij uu uu ij uu uu ij uu uu ij uu uu ij uu uu ij uu suppose uu ij uu depth aoej uu depth aoej ij depth aoej bu de nition substitution oej 
depth aoej depth aoej uu case hypothesis depth aoej uu depth aoej uu contradiction 
proof subcases identical subcase 
suppose uu ij uu toe ju depth uu ij pq uu ij aoe uu aoe uu aoe uu aoe uu uu ij uu uu uu proof subcases identical 
suppose uu ij uu assume maximal path aoej uu depth aoej uu depth aoej ij depth aoe depth aoej de nition substitution depth aoe depth aoej depth aoej uu contradiction 
subterm aoej instance oej dn oej gn oej dn oej convergent 
inductive theorem complete proof theorem 
general procedure proof induction previous subsection technique proving inductive theorems step 
time rounds needed getting proof 
instance successive instantiations test sets may necessary 
easiest way process formalism inference rules bachmair reddy 
main advantage approach hierarchy intermediate lemmas proved management inductive hypotheses intermediate lemma proved put set initial conjectures priority priori attached 
sense procedure viewed close inductionless induction 
inference rules inductive proofs system conditional rules 
proof induction procedure detailed modi es incrementally sets equations 
set equations proved 

set equations reduced equations induction hypotheses 
give set inference rules generate fe oe oe fe test instance eoe oe oe eoe 
fe oe fb oeg oe oe 
fe oe bg eoe oe oe 
simplify fa bg fa bg 
fa bg simplify fa bg fg hg fa bg fg hg goe hoe goe delta 
simplify fc dg fa bg fc dg fa bg coe doe coe delta simplify fa bg fa bg oe delete fa ag ail fe test instance eoe oe eoe oe eoe fe oe eoe fe oe fe inference system rule generate allows initialize inductive steps replacing conjectures implicitly smaller conjectures 
rule simplify simpli es conjecture conditional axioms conjectures checking convergence preconditions 
rules simplify simplify simplify apply conjecture induction hypotheses conjectures 
note simplify allows handle non orientable equations 
rule delete helps getting rid tautologies 
rule ail applies generate applied 
derivation sequence states en hn derivation failed ends application ail rule 
example fp rue rue initial state fp 
fp trueg generate ftrue trueg fp trueg delete fp trueg generate step justi ed noting 
true rue gamma fp trueg true de nition derivation fair failed set persisting equations ji empty 
lemma fair derivation ind exists rule ail applied 
proof lemma proved considering smallest invalid ground equation instance element rst introduce notion complexity proof step de nition equational proof step triple written exists substitution oe soe toe 
soe toe equational proof step 
de ne complexity oe soe toe equational proof step say justi es say valid soe toe 
consider set proof steps justi ed equations show rule ail applies equation justi es minimal proof step valid suoecient prove simpli ed generate apply ail applied equation persists derivation due fairness hypotheses 
soe toe proof step assume oe assume oe irreducible hypothesis soe toe 
assume application simplify generate discuss situation rule applied derive contradiction case 
proof order simplify notations write simplify distinguish cases case soe 
oe assume proving preconditions substitution 
consider 
de nition fe oe 

hand ae valid nally oe toe 
oe toe 
verify ffl fs oe oe 
ffl fs oeg oe oe soe 
oe fs oeg oe 
fs oe fs oe oe 
valid strictly smaller soe toe 
contradicts choice 
case toe 
oe reason soe oe 
soe oe 
verify ffl 
case ft oeg oe oe toe 
ffl ft oeg oe 
oe ft oeg oe oe toe 
oeg oeg oe 
valid strictly smaller soe toe contradiction 
simplify distinguish cases case equation simplify exists ffl valid oe toe hand oe toe 
contradicts choice assumed justi es minimal proof step valid ffl oe oe 
delta oe oe oe oeg oe contradiction 
exists fg hoe ae foe test substitution goe 
hand oe oe oe ground substitution 
assume irreducible 
exists test substitution oe ground substitution oe oe 
hoe hoe hoe goe hoe goe 

note equations proof preconditions valid justify smaller proof steps 
hoe hand hoe hoe fg hoe oe oe goe soe hoe oe oe soe 
contradicts choice case reasoning case 
simplify distinguish cases case equation simplify exists delta ffl valid oe toe 
hand oe toe 
proof simplify contradiction 
ffl oe oe 
oe oe verify ffl oeg oeg oe oe soe 
ffl oe absurd ffl oe oeg oe oeg oe due fact oe oe soe oe oe oe oe soe 
contradiction 
case 
reasoning case 
simplify distinguish cases case 
oe oe oe hand equation simplify exists oe oe oe oe oe oeg oe oe oe oe toe oe toe 
oe fs oeg contradiction 
case oe oe 
oe oe oe ground substitution 
assume irreducible exists oe test substitution ground substitution oe oe 
distinguish cases goe 

hoe hoe hoe goe hoe 
hoe hoe verify hoe fg hoe oe goe soe 
oe hoe hoe fg hoe oe toe 
fg hoe fg hoe oe 
contradiction 
ii 
hoe 

goe goe goe goe hoe 
goe goe verify goe goe fh goe soe 
goe oe fh goe oe hoe oe toe 
goe goe oe 
contradiction 
case 
reasoning 
generate oe ground irreducible substitution exists oe ground substitution oe oe 
assume rule generate applies distinguish cases case 
soe 

toe toe toe soe toe 
toe toe verify ffl fs toe oe 
ffl toe fs toe oe soe 
oe toe toe fs toe toe 
fs toe fs toe oe 
toe equations proof preconditions valid justify smaller proof steps 
hand contradiction 
case 
oe situation toe 

soe soe soe soe toe 
soe soe soe 
oe verify ffl soe soe ft soe soe 
ffl soe oe ft soe oe toe 
ffl soe soe oe 
contradiction 
theorem soundness fair derivation 
derivation non failed ind note valid derivation nite ail applies 
corollary set equations set conditional equations derivation state state set equations element inductive theorem emphasize deal conditional theories allow simpli cation conjectures conjectures reddy see simplify 
failure prove theorem procedure may due absence inference rule case reasoning 
propose enhance procedure allowing case reasoning case rewriting 
generally note step current conjectures proved induction proof technique 
expressed generic rule fcg fcg ind easily prove system remains correct add inference rule previous ones 
example consider example prove rst commutativity 
just consider non trivial instance test substitution simpli cation consider goal rule simplify applies yields oe 
get applying generate simplify hypotheses nishes job 
having proved commutativity prove true 
prove proceeds follow reduces successively 
simpli ed true induction hypothesis 
prove odd true 
non trivial case odd simpli es true supported rewriting 
true odd true valid initial model 
refutation conjectures consider set inference rules obtained extending new inference rule fcg quasi gamma inconsistent theory ground convergent set conditional rules allows detect false conjectures 
easy consequence theorem formally expressed corollary corollary convergent set conditional equations derivation 
exists applied ind discovering inconsistency step conclude input set valid 
stated lemma lemma derivation ail applied 
ind ind proof gamma gamma simpli cation rule equations simpli cation occur valid hypothesis 
valid gamma gamma generate auxiliary equation rewriting instance test substitution valid theorem assume convergent derivation 
exists applied ind proof derivation 
assume exists applied 
clear applied step corollary ind lemma 
ind note soundness theorem remains valid inference system replace statement ail 
complete system unconditional equations consider particular case convergent equational system take inference rules replace notice situation rules ail identical 
prove inference system complete 
means method allows detect false conjecture ail rule 
theorem fair derivation 
ind derivation failed 
proof fair derivation 
assume ind theorem 
derivation failed 
conversely assume exists ail applied 
corollary 
ind lemma 
ind get convergence property convergent systems equations property terms equal simplify identical ones 
section methods obtain convergence property crucial framework disproving conjectures 
saturation techniques technique detailed give overview 
knuth bendix procedure designed derive convergent systems equational presentations 
saturation technique natural extension knuth bendix algorithm conditional theories rst introduced 
technique set inference rules complete conditional equations 
main inference rule superposition re nement paramodulation see ordering terms atoms inferences allowed obtained maximal members maximal members maximal refers ordering 
certain number standard rules simpli cation tautology deletion subsumption 
fair application rules set clauses generates clauses persist deleted step say saturated 
applying set inference rules conditional equations theorem knuth bendix generalized application rules allows derive saturated set convergent 
hierarchical axiomatisation techniques hierarchical axiomatisations natural tools building structured speci cations 
obtained incremental extensions base theories new function de nitions 
sigmab fb subsignature sigma 
words sigma sigmab new function symbols 
elements sigmab called constructors sigma gamma sigmab called de ned function symbols 
terms substitutions equations conditional equations formulas sigmab called constructor sigma gamma terms constructor sigma gamma substitutions constructor sigma gamma equations constructor sigma gamma conditional equations constructor sigma gamma formulas respectively 
hierarchical axiomatisations ground obtained semantic methods 
theorem underlying plaisted theorem set conditional rules signature sigmab sigma gamma sigmab ae convergent set rules sigmab 
assume initial model conservative extension initial model ground term sigma gamma sigmab exists constructor sigma gamma term 
convergent 
proof term 
suppose 

hypothesis exists terms sigmab share initial model theorem convergence property nd term achieves proof 
case hierarchical conditional theory procedure computing test sets see section may demonstrate convergence provided initial model conservative extension initial model instance introductory example convergent axioms introduced de ne successively gamma gcd modify initial model peano arithmetic rewrite rules eliminate symbols ground term 
asking suoecient completeness property rewriting relation 
veri cation inductive properties involves proof lemmas 
adding lemmas initial axiomatisation destroy convergence stated result theorem ground convergent conditional equation inductive theorem 
fcg ground convergent 
proof ground terms 
fcg 
fcg inductive theorem ground instances proofs valid valid convergence property allows conclude proof 
instance introductory example ground convergent appropriately chosen reduction ordering 
get test sets pointed construction test sets conditional theories undecidable 
lies fact computation requires kind induction 
propose method computing test sets conditional theories set function symbols signature partitioned set sigmab constructors set sigma gamma sigmab de ned functions 
assume left hand side conditional rule symbol sigma gamma sigmab 
corresponds known requirements principle de nition hold equational theory see 
key concept method computing test sets conditional theories notion pattern trees 
de nition consider linear term sigma gamma sigmab sigmab variable sort sons possible dioeerent terms modulo variable renaming obtained replacing terms sort form xn function symbol sort arity sigmab xn fresh distinct variables appropriate sorts 
example fa gg fb fa gg theta terms sons obtained replacing variable terms 
de nition basis concept pattern trees pattern tree succ de nition pattern tree linear term tree root labelled outgoing branches non leaf node labelled sons label node variable 
illustrate de nition simple example example fb succ true falseg fb int int theta int bool true bool false bool succ int int tree gure pattern tree term succ 
pattern trees enjoy fundamental properties described proposition proposition nite pattern tree set ground instances equal set ground instances leaf labels ii sets ground instances dioeerent leaf labels disjoint iii ground substitution exist unique leaf unique ground substitution oe tj roe 
construction test set conditional theory consists computing suitable pattern trees terms sigma gamma sigmab general want construct tree expansion root questions come naturally mind pattern tree nodes expanded 
variables replaced 
construction halt 
answer questions de ne special kinds terms want leaf labels pattern trees interested 
terms possess de ned structure certain degree mirrors structure left hand sides rules conditional theory consideration 
de nition term said extensible position variable position sort nullary strict non linear position left hand side rule term said extensible extensible position said covering 
de nition set conditional rules term said exists non empty sequence conditional rules cn sequence positions un oe oe un oe oe oe cn oe inductive theorem said pseudo irreducible emphasize notion pseudo reducibility dioeerent de ned jouannaud kounalis 
example shows concepts example consider theory dif ff dif tt dif tt dif dif remove nil nil dif tt remove cons cons remove dif ff remove cons remove term remove cons pseudo reducible dif ff inductive theorem term remove quasi reducible term pseudo reducible ground instances reducible proving node label pseudo reducible conditional theory amounts proving inductive theorems 
avoid vicious circle dioeerent method prove particular properties method weaker notion test set currently computing 
instance set terms depth greater variables depth weaker test sets 
necessary machinery hand resolve questions stated 
introduce dioeerent types node labels dealing class covering terms 
de nition conditional theory pattern tree xn 
node label said type pseudo reducible type pseudo irreducible covering succ pattern tree type irreducible ground term 
node label said type free type type type 
pattern tree xn said complete node label type leaf label 
discussion denote node labels type boldface letters 
example fb succ true falseg fb int int theta int bool true bool false bool succ int int conditional theory 
succ true false true succ succ true false succ succ false note succ reducible succ succ pseudo reducible true false inductive theorem 
pattern tree complete see gure 
general compute complete pattern tree term xn procedure may 
procedure computing complete pattern trees procedure takes input conditional theory signature sigma 
initially reduced node labelled term xn 
repeat long type free leaf labels remains terminate successfully pattern tree xn complete 
select type free leaf label 
select variable position extensible 
expand cover possibilities compute sons 
procedure terminates sigma gamma sigmab leaf labels type test set easily computed examining obtained pattern trees theorem assume set conditional rules 
sigma gamma sigmab exists complete pattern tree xn leaf labels type test set computed 
test set contains 
arguments leaf labels trees minimal respect subsumption ordering 
constructor terms variables depth instance argument leaf label 
proof clearly nite 
show satis es properties de nition ffl leafs labels type ground term form sigma gamma sigmab sigmab reducible 
ground irreducible term constructor sigma term 
properties pattern trees completeness follows 
ffl obtained construction 
ffl construction test sets terms constructor terms 
hypothesis left hand sides contains non constructor symbol 
means ground instances terms strongly irreducible 
term variables occurring depth depth 
variables may substituted nitely dioeerent constructor terms assume exists constructor symbol constant 
property 
example leaf labels previous example succ succ succ 
arguments leaf labels succ succ succ 
test set succ true falseg 
note true false constructor terms occur argument leaf labels 
method gives way check ground term hierarchical axiomatisation reduce constructor term consequence theorem prove convergence system 
theorem set conditional rules sigma sigmab sigma gamma sigmab left hand side contains symbol sigma gamma sigmab 
assume initial model conservative extension sigmab 
leaf complete pattern tree type term sigma reducible term sigmab 
remove cons remove nil remove pattern tree remove proof ground term sigma gamma sigmab sigmab 
necessarily exists leaf ground substitution oe toe type exists rule contains ground instance 
induction hypothesis may assume terms sigmab theory conservative extension initial model sigmab relation derived dioeerent constructor terms 
exists shows reducible smaller term apply induction hypothesis 
consequence normal form belongs sigmab 
consider example pattern tree remove complete leaf label type see gure 
dif tt dif ff inductive theorem 
test set ff cons 
system ground convergent theorem 
note previous construction may extended non free constructors case provided speci ed set unconditional equations 
de nition changed accordingly 
example constructors verify relations 
ff tt tt tt ff ff test set tt ffg 
see suoecient verify terms pseudo reducible vs 
implementation computer experiments describes general proof procedure shows proof session spike software discusses computer experiments related systems 
main procedure implementation test set induction main data structures rewrite system conditional theory built constructor discipline 
note restriction required purely equational theories 
set conjectures proved 
set inductive hypotheses 
ts test set describe procedure way 
compute test set ts 
gamma simplify conjecture axioms conjectures 
inductive hypotheses gamma eliminate trivial identities 

initial conjectures inductive consequences select conjecture apply generate case rewriting derive new inductive hypotheses instantiation test substitutions inductive positions 
step succeed convergent quasi inconsistent equation 
inductive consequence failure 
go 
hierarchical induction proof handles induction hypotheses level 
provides fully automated procedure simpli cations permitted explicit hierarchical induction 
permits prove properties round helpful prove 
proof session spike show partial transcripts sessions spike example give intuition abilities system 
detailed account 
procedure initialised axioms initial conjectures 
inductive hypothesis true false true 
odd false false 
odd true false true odd true odd false true false odd true odd false simplification odd true true true simplification odd false false false delete true true delete false false 
simplify odd rue trivial rue rue 
operation justi ed premise rule alse odd rue veri ed assume conjecture alse 
thing odd alse 
obtain trivial identities 
fragment example illustrates eoeciency system mutual simpli cation conjectures 
application generate 
induction variables 
false true simplification odd true odd false true false false true 
simplify induction hypothesis orientable 
con rms claim handle non orientable equations 
application case rewriting odd true odd false odd false true true false 
odd true odd false false 
true false odd false true true false odd true odd false false false true delete odd false true true false 
procedure just performed case analysis case rewriting axiom alse odd rue 
application generate true false true true true false false true false false true false 
false true true false delete true true true false delete false true false false simplification true false true false delete true false 
contains instance true false 
smaller true false 
generate rule supplied new induction hypothesis new conjectured lemmas 
trivial 
real induction step allows eliminate conjecture rue alse false true true false initial conjectures inductive consequences nice day 
unit users spike example ml loaded unit set conjectures empty proof achieved 
lemmas fx generated automatically session 
results comparison experimented system examples 
table 
rules oriented lexicographic path ordering see 
example simple example situation calculus proposed richard scherl 
axioms transformation axioms rewrite rules gives true true true true alse alse alse true true alse theorem lemmas len rot len len len rot 
len rot rev rev rev 
rev len qrev len len qrev len qrev qrev rev qrev 
qrev nth nth nth nth nth nth nth nth false true odd false odd true odd odd odd odd odd true true odd false odd false odd true odd true odd false false table examples spike 
problem solved nqthm clam modifying axioms due presence mutually recursive operators 
hand induction step derived axiom connect directly 
problem dioecult systems clam proof highly focused induction hypothesis 
note extensions deal mutually recursive functions proof needs lemma examples short hand cons 
app empty list nil cons nil 
axioms specify functions len app nth rev qrev lists natural numbers len il len cons len app il app cons cons app nth nth il il nth cons nth rev il il rev cons app rev cons il qrev il qrev cons qrev cons proving theorems lemma necessary 
lemma derived automatically powerful divergence critic developed toby walsh integrated spike 
critic successful identifying divergence proposing appropriate lemmas generalizations large number theorems 
procedure relies dioeerence matching algorithm 
lemmas validated run spike suoecient achieve proofs 
note nqthm failed 
examples refer axioms odd example 
example proved simultaneously subsection 
order derive independently necessary provide commutativity lemma 
theorems derived directly heuristics 
mentioned success proof commutativity mainly due special technique handling non orientable equations 
particular standard approach rewriting induction unable get proof 
example discussed 
axiom proof shows test sets adapted cover sets standard induction schemes 
explicit induction technique cope problem 
spike proved binomial theorem proof needs lemmas 
larch prover requires associativity commutativity properties lemmas see 
new methods inductive reasoning 
methods try exploit possible power rewriting 
rewriting systems natural framework inductive reasoning provide suited noetherian relations 
proofs initial model usually require checking nite sets ground equations 
concept test set allows reduce set nite 
axioms ground convergent test sets give complete strategy disprove theorems producing counterexamples 
method generalises case axioms theory negation equations conditions 
theorem prover spike technique solved number interesting problems 
currently extended incorporate generalization mechanisms tactics see necessary solve usual problems 
working better algorithms computation test sets 
aubin 
mechanizing structural induction 
theoretical computer science volume pages 
bachmair 
proof consistency equational theories 
proceedings rd ieee symposium logic computer science edinburgh uk pages 
bachmair 
canonical equational proofs 
computer science logic progress theoretical computer science 
birkh user verlag ag 
basin walsh 
dioeerence uni cation 
bajcsy editor proceedings th international joint conference arti cial intelligence chamb ry france volume pages 
morgan kaufmann august 
hummel hutter walther 
karlsruhe induction theorem proving system 
siekmann editor proceedings th international conference automated deduction oxford uk volume lecture notes computer science pages 
springer verlag 

automatique par dans les th 
phd thesis universit nancy march 
boyer moore 
computational logic 
academic press new york 

computing ground reducibility inductively complete positions 
dershowitz editor proceedings rd conference rewriting techniques applications chapel hill north carolina usa volume lecture notes computer science pages 
springer verlag april 
bundy stevens van harmelen ireland smaill 
rippling heuristic guiding inductive proofs 
arti cial intelligence 
bundy van harmelen horn smaill 
oyster clam system 
stickel ed th international conference automated deduction volume lecture notes arti cial intelligence pages 
springerverlag 
bundy 
computer modelling mathematical reasoning 
academic press new york 
bundy van harmelen smaill ireland 
extensions tactic guiding inductive proofs 
stickel editor th international conference automated deduction volume lecture notes arti cial intelligence pages 
springer verlag july 
burstall 
proving properties programs structural induction 
computer journal 
dershowitz 
termination rewriting 
journal symbolic computation 
dershowitz manna 
proving termination multiset orderings 
communications association computing machinery 
dershowitz okada sivakumar 
canonical conditional rewrite systems 
proceedings th international conference automated deduction argonne illinois usa volume lecture notes computer science 
springer verlag may 
fribourg 
strong restriction inductive completion procedure 
proceedings th international colloquium automata languages programming volume lecture notes computer science pages 
springer verlag 
garland john guttag 
overview lp larch prover 
dershowitz editor proceedings rd conference rewriting techniques applications chapel hill north carolina usa volume lecture notes computer science pages 
springer verlag april 
gramlich 
re ned completion inductive 
stickel editor proceedings th international conference automated deduction volume lecture notes arti cial intelligence pages 
springer verlag july 
guttag horning 
algebraic speci cation data types 
acta informatica 
hofbauer 
proving inductive theorems term rewriting systems 
grabowski lescanne editors proceedings st international workshop algebraic logic programming pages 
akademie verlag 
hofbauer huber 
linearizing term rewriting systems test sets 
journal symbolic computation volume pages january 
hsiang rusinowitch 
proving completeness theorem proving strategies trans nite semantic tree method 
journal association computing machinery july 
huet 

proofs induction equational theories constructors 
journal computer system sciences october 
preliminary version proceedings st symposium foundations computer science ieee 
huet oppen 
equations rewrite rules survey 
book editor formal language theory perspectives open problems pages 
academic press new york 
hutter 
guiding inductive proofs 
stickel editor th international conference automated deduction volume lecture notes arti cial intelligence pages 
springer verlag july 

jouannaud kounalis 
proof induction equational theories constructors 
proceedings st ieee symposium logic computer science cambridge massachusetts usa pages 
knuth bendix 
simple word problems universal algebras 
leech editor computational problems algebra pages 
pergamon press oxford 
martin 
group theory larch prover 
technical report september 
kapur musser 
proof consistency 
arti cial intelligence february 
kapur narendran zhang 
proof induction test sets 
proceedings th international conference automated deduction oxford uk volume lecture notes computer science pages 
springer verlag 
kaplan 

completion algorithms conditional rewriting systems 
kaci nivat editors resolution equations algebraic structures volume rewriting techniques pages 
academic press 
kounalis 
testing inductive reducibility 
arnold editor proceedings th caap copenhagen denmark volume lecture notes computer science pages 
springer verlag may 
kounalis rusinowitch 
word problem horn logic 

jouannaud kaplan editors proceedings st international workshop conditional term rewriting systems orsay france volume lecture notes computer science pages 
springer verlag july 
see extended version published journal symbolic computation 
kounalis rusinowitch 
mechanizing inductive reasoning 
bulletin european association theoretical computer science june 
see proceedings american association arti cial intelligence conference boston pages 
aaai press mit press july 

inductive completion ground proof transformation 
nivat editors colloquium resolution equations algebraic structures volume rewriting techniques pages 
academic press 
musser 
proving inductive properties data types 
proceedings th acm symp 
principles programming languages pages 
association computing machinery 

inductive proofs automated bulletin european association theoretical computer science 

computing horn clause theories 
springer verlag 

inductive proofs constructor horn clauses 
technical report mip universit passau germany 
plaisted 
semantic tests completion methods 
information control 

disproving conjectures 
kapur editor proceedings th conference automated deduction saratoga springs usa volume lecture notes arti cial intelligence pages 
springer verlag 
reddy 
term rewriting induction 
stickel editor proceedings th international conference automated deduction kaiserslautern germany volume lecture notes arti cial intelligence pages 
springerverlag 
robinson wos 
paramodulation rst order theorem proving 
meltzer editors machine intelligence pages 
edinburgh university press 
rusinowitch 
automatique par des techniques de 
th se de doctorat etat universit de nancy 
published collection science informatique directed huet 
rusinowitch 
theorem proving resolution superposition extension knuth bendix procedure complete set inference rules 
proceedings international conference fifth generation computer systems 
see extended version published journal symbolic computation number 
walsh 
divergence critic 
bundy editor proceedings th international conference automated deduction nancy france volume lecture notes arti cial intelligence pages 
springer verlag june july 
zhang 
reduction superposition induction automated reasoning equational logic 
phd thesis rensselaer polytechnic institute department computer science troy ny 
zhang kapur krishnamoorthy 
induction principle equational speci cations 
lusk overbeek editors proceedings th international conference automated deduction argonne illinois usa volume lecture notes computer science pages 
springer verlag 
