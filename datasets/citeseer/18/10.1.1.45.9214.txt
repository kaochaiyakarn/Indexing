semantic view classical proofs type theoretic categorical denotational characterizations preliminary extended 
ong university oxford national university singapore classical logic best examples mathematical theory truly useful computer science 
hardware software engineers apply theory routinely 
foundational standpoint aspects classical logic problematic 
intuitionistic logic classical logic held non constructive said admit proof semantics 
draw analogy programs paradigm understand theory manipulation equivalent specifications comparatively little foundational insight process transforming program implements specification 
extended outlines semantic theory classical proofs variant parigot calculus type theory 
reviewing conceptual problems area potential benefits theory sketch key steps approach terms questions sought answer ffl syntax circumscribe coherent system classical proofs 
satisfactory curry howard style representation theory 
ffl categorical characterization boolean algebra classical propositional proofs opposed validity 
manner categories characterizes classical proofs way cartesian closed categories capture intuitionistic propositional proofs 
appear proceedings th ieee annual symposium logic computer science computer society press 
prg oxford university computing laboratory wolfson building parks road oxford ox qd england 
luke ong comlab ox ac uk ffl complete denotational models intensional game models classical logic canonical circumscribed proofs 

expect semantic theory classical proofs 
key conceptual questions proof theory classical logic gleaned literature 

analysis cut elimination cut elimination major theme proof theory folklore computation purified form 
cut elimination theorem classical logic proved gentzen long ago 
intuitionistic proofs relatively conceptual advances note semantics classical proofs 
reason somewhat problematic nature normalization theory classical proofs 
take cut elimination lk sequent calculus nk natural deduction standard formal presentations classical proofs 
viewed rewrite systems seemingly intractable critical pairs see 
unfortunately impedes understanding analysis computational heart classical proofs 
state affair inevitable 
non confluent reduction intrinsic classical cut elimination 
way manage control just understand 
better model classical cut elimination 

extraction constructive contents kreisel shown sigma formula provable peano arithmetic provable heyting arithmetic 
suggests constructive interpretation classical logic plausible 
sev eral important questions remain 
example constructive interpretation treat evidently non effective proofs existentially quantified statements general seemingly ad hoc methods extracting witnesses functions algorithms proofs 
better possible design version peano arithmetic proofs pi formula systematically transformed algorithm directly process cut elimination 
excellent treatment topic coquand lecture notes 
see discussion 

theory functions processes old idea proof theory deep connection brouwer heyting kolmogorov interpretation intuitionistic logic rule theory functions calculus 
fruitful relationship established suitably constructive interpretation classical logic appropriate theory functions processes 

reasoning imperative programming features applications classical logic especially propositional fragment directly part physical theory logic gates meta level discipline reasoning widespread computer science 
advance understanding intensional properties proofs enrich computer science strengthen links logic 
connections classical proofs control features functional computations investigated various people see :10.1.1.26.6893
outline programme extended sketch approach understand classical proofs semantically computational perspective 
hope shed light conceptual questions identified 
take task identification satisfactory curry howard style representation theory classical proofs 
separate related parts formal representation proofs dynamics cut elimination accompanying term assignment system 
coherent system proofs defines formal objects provide term rewriting syntax suited analysis cut elimination properties system 
course syntactic representation complete classical provability 
section introduce variant parigot classical natural deduction calculus curry howard style representation theory propositional fragment classical proofs 
approach calculus type theory 
inherited notion equality proofs qua terms compatible cut consistent decidable congruent 
having syntax step taken categorical characterization classical proofs defines 
task sense opposite preceding aims find categorical equivalent curry howard representation 
correct analysis tradition categorical type theory spell precisely model classical proofs circumscribed 
categorical characterization generic model called describes standard check mathematical structure model 
regard right way set definition model 
section define generic model kind fibred ccc called category 
appropriate characterization achieve soundness category gives rise model completeness classifying category theory category 
third goal construction denotational models classical proofs merely provability described 
denotational mean traditional sense programming language semantics compositionality 
proof theory principle compositionality precisely compatibility cut 
section sketch concrete instance category kind dialogue game players called consisting pure control moves questions answers 
game may keep private record aspects history play 
assume non 
base type denumerably access 
game played context finite number open 
course play may ffl open new scratchpad close open ffl read open scratchpad return reading answer pending question write answer question 
book keeping operations follow strict protocol 
problem interpreting classical proofs mathematical objects model intuitionistic proofs innocent strategies sense hyland ong interpretation invariably fails attain adequate degree uniformity 
scratchpad protocol designed overcome problem quite effectively senses word 
propositions interpreted arenas proofs innocent strategies players required play innocent strategies depend view history play innocent 
notion state position play contents currently open 
control moves change states actual answers supplied operation 
game model satisfies definability property innocent strategy arena context denotation unique normal form curry howard correspondence unique cut free proof 
close connection terms innocent strategies describe evidently effective operations imperative nature gives attractive computational view classical cut elimination setting 
related griffin pioneering typing control constructs programming operator felleisen relating classical proofs great deal interest classical proofs 
tentative incomplete classification ffl algorithm extraction control operators griffin murthy krivine de groote nakano schwichtenberg berger coquand ffl formal systems calculi girard parigot berardi danos schellinx ffl proofs semantics cut elimination girard hofmann coquand pfenning herbelin parigot ideas provided inspiration early stage basis believing categorical characterization classical proofs grabs 
girard lc presents things denotational model version classical proofs argues forcefully attempt construct termed boolean categories categorical models classical logic negation ultimately come grief ideas gave impetus programme research reported extended 
course contradiction girard assertion discovery categorical model cartesian closed fibred ccc appropriate kind falsehood modelled weakly initial object isomorphic canonical map gamma 
retraction 

curry howard style representation classical natural deduction cnd calculus introduced parigot shall see key innovations go back prawitz mid 
cnd formal presentation classical proofs calculus accompanying term assignment system 
name implies cnd natural deduction system formation rules take form elimination logical connectives formulated sequent style 
shall focus variant parigot system restricted propositional fragment type theory 
type theory kinds judgement ffl term assignment gamma delta ffl term equality gamma delta gamma gamma range contexts delta delta contexts 
types system ranged built constructor set atomic types including distinguished base type called falsehood 
shall follow convention associating right write delta delta delta simply delta delta delta 
kinds variable 
just usual variable simply variable 
standardly denumerably variables type associated binding operator abstraction gamma 
shall refer kind variable ranged ff fi fl names simply names sense calculus milner denumerably names ff ff ff non 
type crucial feature version name type 
addition variables thing substituted name name 
associated binding operator ff gamma 
corresponding kinds variable kinds context context context 
find convenient construction classifying category define context finite sequence type variable pairs written opposed variable may occur similarly context 
context respectively context typical form delta delta delta resp 
ff fi fi delta delta delta fl note occur context 
raw terms ranged defined follows variable abstraction st application ff named term fi abstraction 
rules term assignment judgements displayed table 
observe symmetry structural rules contexts contexts 
term simply term typed raw term 
note typed named term ff necessarily type type typed abstraction form fi type type 
equational laws rules term equality judgements usual rules specify equations axioms 
fi sx fv fi ff fl ff fl ff ff ff fn ff fi fi ff ff 
gamma ff 
equations understood abbreviating equation context written full axiom fi say take form gamma delta kinds substitution distinguished 
usual substitution term free occurrences variable term calculus second fl ff just renaming names 
third shall call mixed substitution substitution operation assuming fi ff means replace subterms form ff term fi ux gamma ff 
means replace subterms form ff 
term ux 
example ff ff fi ff fi fi ux 
version augmented product types additional law call theta ff thetaa ff ff ff ff ff ff ff ff thetaa means replace subterms form ff thetaa term ff 
kinds substitution capture free standard sense 
presentation differs parigot ways 
parigot places context right sequent form gamma delta 
law version call mixed substitution fi ff opposed ff type involves variables names terms 
contrast accord named terms full status term witness 
pleasing effect achieving symmetry abstractions serve naturally witnesses elimination 
note abstraction necessarily form ff fi admit terms form ff syntactic restriction 
difference consequence insistence name type 
led depart parigot syntax rewrite system details follow shortly design considerations criteria important standpoint categorical type theory 
elaborations 
require formal presentation classical proofs completeness provability sense 
proposition parigot tautology inhabited closed term sequent derivable 
see example table term peirce law famous classical tautology intuitionistically valid 
proof tree horizontal lines denote proof steps annotated rules 
follows proposition closed term type contradiction 
closed normal form ff type initial object closed normal form normal form type think 
useful relate gentzen natural deduction nd classical logic rules axiom elimination classical absurdity rule 
exercise advantage giving intuitive informal semantics calculus 
shall establish precise relationship derive proposition corollary 
version admits names type 
names allowed bound essentially status constant variable 
perm gamma gamma delta gamma gamma delta perm gamma delta ff fi delta gamma delta fi ff delta wk gamma delta gamma delta gamma wk gamma delta gamma delta ff ff delta ctr gamma delta gamma delta gamma ctr gamma delta ff ff gamma delta ff ff ff ff ff ff delta axiom intro gamma delta gamma delta elim gamma delta gamma delta gamma delta st intro gamma delta gamma delta ff ff ff delta elim gamma delta fi gamma delta fi table 
rules defining term assignment judgements 
ff fi ff intro ff fi ff elim ff fi ff ff ff fi ff intro ff ff fi ff table 
proof peirce law convenient sequent calculus associated term calculus call represent conventional nd proofs curry howard style correspondence 
intuitively sequent gamma means term representation nd proof proposition undischarged hypotheses occurrences annotated propositions form taken set gamma 
recall nd packets hypotheses discharged classical absurdity rule 
standard hypotheses belonging packet annotated variable 
calculus just calculus augmented new variable binding mechanism term type cx term type note honour felleisen operator binds variables negated type 
exact curry howard style correspondence nd proofs terms defined augmenting standard rules example ch 
proof delta delta delta delta delta delta delta delta delta delta corresponds gamma proof delta delta delta delta delta delta delta delta delta delta corresponds gamma gamma cx gamma gamma means set difference 
define algorithm transforms welltyped term nd proof term type 
assume bijection variables annotating negated hypotheses form names gamma example ff take nd proof gamma theta subset gamma consisting negated hypotheses 
theta def theta ff elseif theta px sq theta def psq theta theta def psq theta theta sq theta def ff psq theta transformation formalizes way understanding relation gentzen nd 
think variant nd discharge discipline distinguishes hypotheses discharged classical absurdity rule annotation names discharged annotation variables ffl name type corresponds parcel hypotheses type may discharged classical absurdity rule ffl rule elim corresponds exactly classical absurdity rule ffl intro shall see opposite amounts elimination premise negated proposition discharge classical absurdity rule 
straightforward induction show transformation sound lemma nd proof gamma subset theta gamma consisting negated hypotheses gamma gamma theta theta psq theta provable sequent 
theta say delta delta delta theta sequence ff delta delta delta fl likewise gamma gamma theta regarded sequence 
transformation reverse direction 
take term define term recursion xx def xx sy def def ff sy def ff sy def cx 
straightforward induction show lemma derivable sequent gamma delta sequent gamma delta valid 
putting preceding lemmas deduce complete classical provability 

worth pointing fi reduction normal proofs nd equivalently satisfy subformula property 
mid pointed de groote prawitz considered version nd satisfies property 
introduced proof reduction rules essentially push double negation simpler formulae 
normal proofs system hypotheses discharged classical absurdity rule atomic propositions 
group laws may regarded reformulation prawitz reduction rules 
rewrite system parigot considers term rewriting system reduction rules fi fi ff fi fi ff fi ff means replace subterm form ff expression fi ua 
parigot writes fi ff ff 
system remarkably behaved reduction church rosser strongly normalizing 
unfortunately extending system reduction produces unresolvable critical pair turns modulo appropriate congruence rewrite system associated reasonably wellbehaved 
show strongly normalizing church rosser modulo writing reflexive transitive closure conclude type theory consistent 
proper treatment rewrite system 

categorical characterization give concise account generic model section 
observation fact set free category finite products generated map composition zero basic maps kinds delta theta range objects permutation delta gamma 
theta equivalently invertible maps weakening delta theta theta wa delta contraction delta theta theta delta theta theta theta theta shall assume basics fibred category theory see 
definition proper italics explanatory notes commentary roman 
ff reduces ff fi fi ff 
definition category split fibration satisfying conditions fibred ccc sense fibre cartesian closed reindexing functors preserve products function spaces nose 
condition follows observation fixed context delta structural rules axiom intro elim precisely rules define simply typed calculus 
ii canonical fibre 
fibre terminal object canonical sense object delta objects delta bijection objects direction reindexing terminal map delta delta gamma 

iii base category 
free category finite products generated set objects canonical fibre distinguished object objects isomorphic 
ii iii follow essentially analysis rules intro elim harm writing objects delta pair delta ranging objects fix notation 
delta delta 
notational economy gained 
shall write delta map delta gamma 
delta delta write homset delta delta delta simply delta 
shall write product base category theta theta distinguish product theta fibres 
iv status 
weakening map wa delta theta theta gamma 
delta isomorphism delta delta theta theta ff natural delta 
write bijection ff ff oe note iv assumption isomorphic delta delta theta theta preceding 
notational convention isomorphism delta theta theta ff 
condition characterizes status falsehood 
aside flat fibration category finite products object define flat fibre follows objects just objects gamma 
map just case thetac gamma 
map 
note just fibre called flat fibration flat objects pairs objects maps gamma 
fibration theta gamma 
projection 
objects object delta assuming bijection conditions iv delta delta theta theta thetaa delta theta theta delta theta theta say flat fibre category delta theta theta object delta theta theta bijective action delta table 
case object isomorphic similar omit 
mixed substitution functor action functorial defines equivalence categories natural delta preserves cartesian closed structure falsehood 
preservation falsehood mean commuting diagram delta theta theta delta thetau delta theta theta delta theta theta theta thetad ffi gamma delta theta thetad thetau delta theta theta thetad ffi gamma functor delta interprets action mixed substitution takes term context gamma delta ff gamma delta fi fi ff vi beck chevalley condition 
contraction map form delta theta theta delta theta theta theta theta require diagram commute delta theta theta theta theta thetaa thetaa delta theta theta theta thetab delta theta theta thetaa delta theta theta functor corresponding mixed substitution gamma ff ff thetaa law theta omit extended 
theta delta theta theta ff theta theta ffi fi cur gamma ff ffi delta theta theta fi theta ff ffi delta theta theta ffi theta theta cur gamma ff ffi delta theta theta ffi table 
definition 
right arrow diagram composite thetaa thetaa delta theta theta theta thetab thetaa delta theta theta theta thetab thetaa delta theta theta overload notation reindexing relevant contraction map flat fibration delta theta theta theta thetab soundness completeness axiom system specified pair sig ax sig set signatures ax set equations context regarded axioms 
precise sense soundness completeness context categorical type theory 
theorem soundness category interpretation axiom system sig ax category interpretation satisfies equation context theorem axiom system 
theorem completeness classifying free category theory category 
conclude category generic model syntax free categorical equivalent type theory 

complete game model section sketch model kind person dialogue game questions answers player may book keeping purposes 
model concrete instance category satisfies completeness property 
innocent approach review basic setting common innocent approach hyland ong see extended brief account follows 
basic arena question harm overloading symbol set ans possible answers 
useful bear mind reading interpretation ans logical atomic proposition proofs computational base type values set basic arenas ranged distinguished basic arena called falsehood 
definition arena finite upside forest labelled basic arenas 
precisely specified function gamma 
finite forest set basic arenas 
question just element graph function pair say question type call occurrence ans set answers question 
shall say question justifies just case occurs immediately forest 
clearly questions occur root called opening questions question unique justifying question 
convention questions levels questions levels questions 
moves game kinds question answer question answer shall parentheses superscripted respective types necessary metavariables follows proponent opponent question answer forest forest 

forest questions questions answered construction arenas define product function space arenas 
product simply take obvious disjoint sum arenas directed graphs 
function space simplest draw picture 
picture opening move 
opening moves tree opening move graft copy forest questions shall call arena pointed just case forest questions tree 
kind arena playing innocent strategies gives rise fully model pcf 
direct reader comprehensive treatment innocent approach 
imperative book keeping features model need extend innocent setting appropriate book keeping facilities 
non 
basic arena assume denumerably type written ff ff fi fl access 
play may open close scratchpad read write open scratchpad 
collection open varies play unfolds 
scratchpad opened initialized answer type new answer type written scratchpad overwrites old value 
legal ways may play governed protocol consisting sequence component actions follows assume ffl control question open scratchpad ff ii raise question iii promise write answer received open scratchpad fi ffl control answer copy preceding answer type open scratchpad fi ii read open scratchpad ff return reading answer iii close scratchpad ff note actions control question component wise dual control answer 
control question specified tuple ff fi open ff fi control answer specified tuple fi ff fi close ff rtn ff note open angle bracket marks opening scratchpad corresponding closed angle bracket closing 
control moves call ff subject scratchpad fi object scratchpad 
shall abbreviate open ff fi fi close ff rtn ff 
omit cases control move 
sum shall consider moves kinds moves pure question answer control control question control answer question move pure question control question similarly answer move 
note control moves 
regard control question control answer single moves 
ground rules fix arena finite set ffi open 
play game governed rules begins raising opening question may repeated 
play alternately making move time 
play ends opening question answered 
moves answer move play answer moves 
condition applicable innocent game interpretation pcf essentially presence definition cases conditionals 
dialogue unfolds required satisfy principles civil conversation 
justification question raised occurrence unique justifying question pending asked answered answer occurrence unique question expecting pending 
note unique justifying question justifies 
pertinence ask answer condition question asked answered 
equivalent bracketing condition gandy dangling question mark condition 
addition may making control question control answer moves subject conditions 
control move control question raised immediately question type subject scratchpad control answer offered immediately answer type object scratchpad 
addition promise write execute write action scratchpad open point play similarly close scratchpad opened preceding control question 
ffi written closed play 
formulate notion justification move explicitly attach justification pointer move play points occurrence question move past uniquely justifies 
convention opening move points 
justification pointer answer move points occurrence question move answer specific reply 
formed sequence defined sequence moves auxiliary sequence justification pointers move satisfying conditions 
player view view simply view ppq formed sequence moves defined recursively 
range formed sequences moves segments formed sequences 
def pp delta deltar delta def ppq delta delta pp delta delta delta def ppq delta delta pp delta deltar delta def ppq delta delta pp delta delta delta def ppq delta delta means example move deltah delta delta delta 
object scratchpad fi open ff fi considered open point play ffi ff opened preceding control question move 
explicitly justifies nd rd clauses explicitly justifies clauses 
example view formed sequence moves may shape delta delta deltah delta delta delta 
construction pattern delta respectively delta view question respectively answer explicitly justified 
segments form delta delta delta view 
dual notion opponent view view omit 
definition legal position arena finite set ffi open formed sequence satisfies condition called visibility question respectively question raised provided question respectively question explicitly justifying appears view respectively view history point control question raised provided preceding control question responsible opening object scratchpad appears view history point 
innocent strategies pointed arena finite set ffi open collection legal positions ordered prefixing forms tree thought defining game tree legal positions just paths game tree 
strategy sub tree appropriate kind 
shall consider strategies depend view point play 
state legal position contents open point 
definition innocent strategy sub tree game tree satisfies conditions innocence response legal positions views bounded enquiry question may raised infinitely play totality provided plays innocent strategy satisfying response copycat raises pure question type preceding question offers pure answer copy preceding answer 
observe implies innocent strategy deterministic appropriate sense 
significance innocent strategy finitary aspect determines strategy happily gives handle induction proofs 
condition force innocent strategy pure answer move control answer move condition 
fact actions answer completely determined behaviour rules game 
defining innocent strategy need state legal positions raises pure control question 
information finite 
innocent strategy specified partial function questions pointers collection pairs shapes ffl delta 
ffl delta 
open ff fi provided fi ffi fi ff fi opened control question appearing 
omit justification pointer question justifying question appearing omit case second case 
represent state legal position finite type respecting partial function ae answers scratchpad ff open ae ff defined 
control moves 
example psq delta deltah open ff fi delta innocent strategy respond fi close ff rtn ff new state ae fi 
ff state identical ae fi reads ff undefined 
construction category sketch fix finite set ffi open 
category ffi defined follows objects arenas maps gamma 
innocent strategies arena set ffi open 
composition maps defined way innocent approach parallel composition hiding complicated additional feature control moves 
show ffi cartesian closed 
set empty set 
observe objects just arenas 
generalize notion higher types 
suppose delta delta delta 
shall assume scratchpad ff non 
type uniquely associated scratchpad ff type map ff 
ff injective 
define base category data objects finite sets delta ff fi delta delta delta fl generalized 
map delta gamma 
theta type respecting function names theta names delta note reversal direction 
easy see representation free category finite products generated non 
objects obtain category need identify fibred ccc suppose delta delta delta 
object delta ff fi delta delta delta fl define fibre delta ff fi delta delta delta fl def theta theta delta delta delta theta ff fi delta delta delta fl notion flat fibration introduced earlier 
prove 
theorem soundness category 
example peirce law consider example proof term ff ff fi ff see table derivation 
play trace innocent strategy determined term 
begins raising opening question 
responds raising control question open ff ff opens scratchpad ff asks promises write ff move raises question responds raising open fi ff opens scratchpad fi asks promises write ff open move 
suppose gives answer immediately move 
responds control answer ff close fi rtn fi copies ff returns contents fi answer closes fi 
suppose responds answer type concluding move gives control answer ff close ff rtn ff copies ff returns value answer closes ff segmented arrows justification arrows 
note delta delta deltai mark period play scratchpad question open 
game model satisfies completeness property theorem definability arena finite set delta generalized innocent strategy denotation normal term 
believe definability theorem extended full completeness result sense abramsky jagadeesan 
open ff ff open fi ff rtn ff scope ff rtn fi ff ff 
peirce law gives overview approach understand classical propositional proofs curry howard style type theoretic presentation variant parigot calculus 
intrinsic notion equality proofs consistent decidable congruent compatible cut 
give categorical characterization construct game model satisfies completeness property 
owes martin hyland insights 
eike ritter contribution categorical semantics useful discussions wei koh charles stewart gratefully acknowledged 
comments referees useful 
supported part british epsrc research gr systematic programming semantics 
abramsky jagadeesan 
games full completeness multiplicative linear logic 
symb 
logic 
berardi 
extracting constructive content classical logic control reductions 
proc 
int 
conf 
tlca pages 
springer 
lncs vol 


fibred categories foundations na ive category theory 
symb 
logic pages 
berger schwichtenberg 
program extraction classical proofs 
leivant editor proceedings lcc 

coquand 
semantics evidence classical arithmetic 
journal symbolic logic 
coquand 
computational content classical logic 
proc 
newton institute ii summer sch 
semantics logics computation 
cambridge univ press 
appear 
crole 
categories types 
cambridge university press 
danos 
schellinx 
new logic linear logic 

editor advances linear logic 
cambridge univ press 
de groote 
cps translation calculus 
tison editor proc 
caap 
springer 
felleisen friedman kohlbecker duba 
syntactic theory sequential control 
theoretical computer science 

girard 
new constructive logic classical logic 
math 
struct 
comp 
science 

girard 
unity logic 
ann 
pure appl 
logic 

girard lafont taylor 
proofs types 
cambridge university press 
griffin 
formulae types notion control 
proc 
acm conf 
principle programming languages 
acm press 
herbelin 
calculus structure isomorphic sequent calculus structure 
preprint 
takeuti 
reduction rule peirce formula 
studia logica 
appear 
hofmann 
sound complete axiomatisations call value control operators 
preprint 
hyland 
ong 
full abstraction pcf ii iii 
pages ftp able ftp comlab ox ac uk directory pub documents luke ong 
hyland 
ong 
pi calculus dialogue games pcf 
proc 
th acm conf 
functional prog 
lang 
comp 
architecture pages 
acm press 
kreisel 
mathematical significance consistency proofs 
symb 
logic 

krivine 
classical logic storage operators second order calculus 
annals pure applied logic 
murthy 
evaluation semantics classical proofs 
proc 
th ieee annual symposium logic computer science 
ieee computer society press 
nakano 
logical structure catch throw mechanism 
phd thesis university tokyo 
parigot 
calculus algorithmic interpretation classical natural deduction 
proc 
int 
conf 
logic prog 
automated reasoning pages 
springer 
lncs vol 

pfenning 
structural cut elimination 
proc 
th annual ieee symposium logic computer science pages 
ieee computer society press 
prawitz 
natural deduction 
almqvist wiksell 
stockholm studies philosophy 
