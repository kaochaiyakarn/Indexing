methods models management distributed persistent data michael feeley january discuss important issues related managing persistent data distributed system network workstations 
review research areas including distributed file systems persistent storage systems distributed shared memory systems dsm 
persistent store system object oriented database stores persistent data structures 
main focus type persistent data persistent store system deals issues file system left programs fine grain synchronization coherency recoverability 
fundamental sense data management simply means moving data memory memory disk memory node node system 
persistent data cached local memory programs read modify modifications sent back disk persistent 
key data management issues pertain cache managed 
divided discussion parts 
section discuss issues related managing data accessed read 
central questions data organized disk memory distributed cache hierarchy organized 
compare page grain object grain caching show page grain caches benefits 
alternatives organizing cache hierarchy discussed 
persistent storage systems client server 
contrast dsm systems server node client 
discuss approaches conclude discussing seeks extent cache hierarchy client server systems include memory remote clients 
section discuss additional issues raised programs modify data 
issues concurrency control coherency recoverability having maintaining consistency data 
section discussion consistency model define consistency means particular system 
discuss issues turn focusing similarities 
section granularity key question 
persistent storage systems typically tied granularity concurrency control coherency recoverability caching grain typically page grain modern dsm systems separate issues providing fine grain coherency page grain cache 
defining distributed system model describing persistent data different types systems manage 
data management section describe system model highlights parts system store data ram disks data management problem moving data data repositories right times 
describing system model 
define persistence discuss application models accessing 
enumerate data management issues addressed remainder 
memory centric distributed system model distributed system modeled collection processors memories 
processor local memory data stored local memory local data accessed directly processor load store machine instructions 
processors data storage devices attached disk 
memory said durable content survives failures failure model durable memory needed store persistent data 
common assume processors fail meaning failure cause processor execute erroneous operation 
adopt failure model avoid questions durable memory implemented 
usually local memory durable volatile portion local memory durable adding battery flash memory types non volatile ram 
common type durable memory disk 
disk resident data copied local memory accessed 
processors connected network 
processor access data stored local memory processor exchanging network messages processor 
refer local memory processors remote memory 
data accessible processor said distributed 
data remote memory remote data accessed copying local memory network data shipping transferring control remote processor desired operation performed processor local data function shipping 
deal exclusively management data data shipping distributed system 
system data replicated reside memories moved remote memory local memory 
data accessed programs execute processors sequential execution program called thread 
term object refer fundamental data abstraction programs 
purposes object simply vector bytes size possibly name 
typically object refer point objects storing names part data 
programming languages add properties objects type function bindings object oriented programming languages properties objects unimportant discussion 
programs operate local data directly require assistance system accessing remote data disk 
role system transfer data local memory satisfy data needs program 
persistent data data natural lifetime begins created program continues program requires access 
data transient meaning lifetime ends program created terminates lost processor program executing fails 
transient data shared programs case live programs terminate 
data survives system failures said persistent 
typically persistent data outlives execution program creates 
possible execution state program persistent execution resumed failure restarting persistent data discarded program terminates normally 
persistent data stored durable memory may cached memories copy durable memory 
changes persistent data local memory persistent transferred durable memory 
program models persistent data distributed file systems notable example system support persistent data file system 
file system programs access persistent data block time read write synchronize operations 
read copies data local memory write copies data durable memory synchronize stalls caller preceding writes completed written data durable 
virtual memory mapped files operating systems provide programs virtual address space local memory cache portions address space active programs 
rest data address space stored disk backing file 
system transfers data local memory disk demand response memory accesses programs 
data accessed way said mapped programs virtual address space contrast standard file interface gives programs explicit control transfer data read write operations 
early operating systems multics pilot extended virtual address space include persistent data approach known single level store 
ibm operating systems system provide single level store hardware supported segment relative addressing 
research single address space operating systems combines advantages single level store architectural advancements wide addresses bit addresses allow data addressed single flat address space 
modern commercial operating systems osf begun provide similar interface persistent data mapped files 
allows applications change backing store range virtual addresses 
paging range system paging file paging transformed system read write operations mapped file 
advantage implicit access persistent data provided single level stores mapped files applications access persistent data way access program data 
data transferred automatically local durable memory demand response program accesses 
explicit interfaces file systems provide applications greater control data transferred additional cost complexity persistent data accessed differently transient data 
providing efficient data management mapped data active research topic 
data management issues basically explicit implicit interfaces persistent data 
explicit interface system interface allows programs directly control movement data local memory disk 
programs tools need manage data efficiently 
mapped data transfer data hidden programs 
means operating system involved data management provide interface programs allows greater control data transfer 
databases persistent storage systems databases type persistent data system 
database provides structured data model implemented top file system raw disk interface 
example relational database organizes data tuples tables object oriented database oodb stores data items objects arbitrarily complex inter object 
databases provide specialized languages performing operations queries 
persistent object store persistent store similar objectoriented database stores programming language data structures necessarily support query language database features 
persistent store program interface access individual data items objects 
interface implicit programs access persistent objects way access programming language objects variables 
systems require programs explicit calls database create retrieve store persistent object 
data management discuss key issues related management persistent data distributed system 
data managed collection software components operating system external servers runtime libraries attached application programs collectively referred data management system 
data management system primary functions move data memories maintain data consistency shared distributed persistent data modified 
sections discuss turn 
section consider issues related organization memories cache hierarchy storing persistent data data moves memories 
section discuss additional issues arise programs modify data 
managing read data persistent data system consists memories local memory disk durable memory 
similarly distributed system local remote memory 
local memory processor holds data active programs running 
acts cache persistent data stored durable memory distributed data 
system responsible managing cache provides basic functions 
ffl trap program uncached data ffl locate data cached locally ffl move data local cache ffl discard cached data room new items ffl support inter object naming pointers key data management issues discussed section relate system structured data organized named system supports inter object data moved memories 
issues relate central basic task data management system moving data memory 
client server system architecture distributed persistent storage systems typically organized client server system 
processor direct access durable memory called server data stores 
programs operate data processors run called clients 
notice particular processor server data client data data 
furthermore program client servers systems restrict 
data transferred disk copied server cache resides local memory server processor 
clients receive data server network store client cache local memory 
client server processors caches combined 
data modified programs transferred reverse direction client cache server cache server disk 
persistent data cached server client memories results cache hierarchy consisting client cache server cache server disk 
structure supported combination software components 
storage manager runs server manages server cache disk 
clerk runs client manages client cache 
programs interface clerk link runtime library provides support program 
persistent storage systems distributed file systems normally organized client server systems 
distributed file systems nfs sprite afs examples 
read operations issued program satisfied client cache server cache disk 
afs cache data client disks 
programs read write operations transfer data program accessible memory 
persistent storage systems distributed persistent storage systems typically client server 
systems include research systems exodus orion mneme thor shore commercial object oriented databases objectstore gemstone 
systems exodus orion single system client server versions 
mneme thor shore clients cache data multiple servers 
persistent stores differ file systems provide support persistent data structures 
contrast file systems defer issues related management file contents applications 
persistent store extent aware structure data stores supports naming individual objects provides stronger consistency guarantees store file systems 
application interface persistent store typically implicit object 
mneme programs access store making procedure calls local clerk fetch modify objects 
thor programs access objects rpc interface program code directly accesses object written special language called theta incorporated clerk 
shore objects accessed program private cache objects referenced copied client cache cache program private address space 
thor programs written special language run directly clerk avoiding cost copying program cache 
consistency guarantees provided persistent stores discussed section 
file systems persistent stores provide support fine grain concurrency control recoverability transactions provide atomic updates persistent storage 
organization data said main function data management system move data memory memory 
central question granularity data 
caches generally classified page grain 
cache hierarchy programs fine grain accesses data access objects 
objects grouped clustered physically blocks storage disk accessed efficiently 
page grain cache data transferred memory units physical pages 
grouping objects page physical memory cache corresponds directly grouping objects disk 
allows page transferred directly disk local memory file system virtual memory system system knowledge content pages 
basic unit transfer object grain cache individual objects groups objects 
transfer data cache correspond directly accesses programs 
objects transferred time accessed transferred groups 
importantly grouping objects need correspond objects clustered disk 
potential improving utilization physical memory network bandwidth objects needed program cached entire pages objects 
improve prefetching allowing multiple clusterings objects tailored access patterns different programs 
main issues 
discuss turn sections 
ffl performance system depends grouping objects physical clusters transferred managed 
pages provide form clustering certain advantages disadvantages 
ffl performance affected degree integration virtual memory system 
page grain caches easier 
ffl cache management easier page cache reasons pages uniform size objects page offset virtual address pointers need translated bookkeeping overhead lower necessary keep track object individually 
clustering clustering objects important performance main advantages page cache page clustering objects 
typically cost detecting cache locating accessed object transferring cache orders magnitude higher accessing object cache 
clustering objects accessed cost handling cache amortized accesses number objects 
clustering critical data stored disk rotational nature disk initiating transfer slower transferring data 
clustering important satisfied remote memory accessing disk 
case clustering amortizes cost detecting locating data setting network transfer 
main difference types clustering clustering disk requires objects cluster physically contiguous clustering memory network transfer 
page cache object exactly cluster clustering disk memory caches object 
dewitt performed detailed study caching client server systems 
compared page server transfers pages client server object server transfers objects time 
surprisingly page server performed substantially better long clustering objects pages moderately effective 
object server performed better clustering correspond access benchmark programs 
strength similar results number page systems built including research systems exodus cricket mneme shore commercial object oriented databases objectstore 
main advantage page grain caching provides clustering advantages disadvantages related locking coherency discuss section 
main disadvantage page clustering object belong cluster 
clustering wrong programs prefetching benefits clustering lost performance worse clustering 
poor clustering page cache results poor utilization network bandwidth physical memory 
object accessed entire page transferred network local cache entire page physical memory reserved 
page grain cache assumes way cluster objects page provides clustering programs 
true 
day claims clustering zero sum game clustering data program result clustered poorly programs 
naughton evidence workloads examined study clustering algorithms algorithm worked best program 
noteworthy programs accessing different datasets possible different algorithms different programs page clustering 
case day assertion formed basis decision object grain caching thor 
object caches thor provides clustering mechanism satisfy dewitt objections object servers 
thor object clustering provided crystals 
thor client server system server cache page grain data transferred disk multiple page segments mneme 
client caches object grain data transferred server cache client caches crystal time 
crystals flexible pages unit clustering object belong multiple crystals crystal membership changed moving objects disk 
note objects clustered pages storage disk server cache 
object grain clustering crystals provides benefit disk reads 
furthermore clustering really zero sum game server cache poorly utilized high overlap crystals active clients 
summary clustering important achieve cache performance 
page cache clusters objects object clustered way 
programs impossible cluster objects program benefits clustering 
object cache crystals provides flexible way cluster objects allows object clustered different ways 
clustering really zero sum game appear object grain cache preferred 
arguments page grain cache 
virtual memory system integration important benefit page grain caching easier integrate cache virtual memory system important benefits performance ease 
appel li describe memory management hardware alternative explicit software checks detect data accessed program :10.1.1.12.2903
type access information needed detect cache misses provide implicit page grain locking generational garbage collection 
example page cache cache detected page fault object cache explicit residency check needed possibly time new object referenced time pointer followed 
argument page faults drive garbage collection locking hosking moss show page grain access information coarse applications 
claim software residency checks relatively inexpensive object oriented language smalltalk combined method dispatch calling procedure 
true method dispatch fairly expensive language interpreted procedure addresses determined dynamically 
fine grain access objects language residency checks add significantly cost accessing object 
agree page granularity coarse locking logging garbage collection object faulting comparable performance page faulting questionable 
advantage page cache easier avoid data copying transferring data cache 
data copying expensive memory access times scaling processor speeds 
page cache data transferred directly cache disk network remapping system buffer page receives data client address space 
object cache difficult objects typically copied cache 
remapping possible cases amount data transferred close multiple page size 
difficult objects buffer transferred cache duplicate objects discarded 
thor instance overlapping crystals cached cache contains single copy object 
cache integrated vm avoid poor interaction vm page replacement operations 
discussion assumed local memory caches allocated physical memory 
reality operating systems reside virtual memory cached physical memory operating system 
local cache really cache built top cache 
get cache performance expect need virtual memory system get way 
crucial problem object cache vm system thinks pages cache dirty objects page modified 
object cache things page cache need unnecessarily dirty pages copying discussed pointer translation discussed 
pages support naming easier way page caches easier manage inter object pointers represented cached data 
object cache inter object pointers translated swizzled virtual address new location object cache 
page cache possible coordinate allocation virtual address space pointers need translated 
works page offset object possible assign pages globally unique virtual addresses virtual address pointer stored disk cache 
idea opal single address space operating system technique objectstore avoid pointer translation possible 
main disadvantages swizzling difficult discard entries cache longer needed 
example consider object wish discard problem may cached objects point store virtual address pointer fields 
discarded dangling 
problem exacerbated fact reason discarding bring new object say cache 
stored virtual address stale pointers point real object wrong 
problem unavoidable object cache 
deal thor objects discarded replaced small proxy object 
bring cache replaced proxy freeing space taken pointers previously pointed valid point proxy 
compacting garbage collector discards proxies longer pointed cached object 
possible solutions include standard solutions detecting dangling comparing object id pointer dereference updating stale pointers point 
note solutions add runtime overhead 
page cache discarding page easy long reside different virtual address need way take physical page stored assign new unique virtual address 
furthermore avoid pointer translation address address cache 
just vm system manages caching effect want simulate behavior exhibited mapped file systems provide 
unfortunately difficult impossible cache integrated vm system 
persistent object systems cache resides fixed range virtual addresses cache page reused store new data virtual address 
big problem objectstore page cache lacks integration 
deal objectstore discard pages cache transaction commits discards pages cache eliminating need pages remain local memory protected attempts access generate faults trapped clerk 
provides interesting solution mapped files mmap similar technique incorporated new version objectstore 
system assumes fixed number physical pages assigned client cache 
creates file physical pages uses mmap map different virtual address 
gives system way name physical pages file name way change virtual address physical page remapping file new virtual address 
replace file currently maps remapped new address content copied address 
technique basically elaborate way workaround deficiencies osf vm system interface shortcomings 
really mapped files 
clerk transfers data explicitly copying cache page network buffer 
second cache statically assigned fixed number physical pages 
necessary system initiate page cached pages copied disk file mapped page 
files exist provide means naming physical pages mmap reused different database pages real storage location page database file server 
third difficult multiple programs share client cache 
multiple programs share cache supported objectstore page replacement require global synchronization threads programs change mapping page replaced 
pages cache management easier reasons page caches easier manage 
pages uniform size objects 
cache variable size entries fragmented time 
management object cache include mechanism compacting objects cache 
thor example uses copying garbage collector periodically compact objects client cache 
additionally object caches complicated higher overhead extra bookkeeping needed keep track object 
thor table cached objects kept client server server keeps list object currently cached client 
object fetched server table updated object sent client 
client object looked client object table objects cached discarded new objects added table copied cache 
pointers object translated looking object table 
referent object cached client pointer changed virtual address object cache proxy object created cache represent referent proxy address placed pointer field 
page cache minimum necessary add page page tables maintained client possibly server 
page server swizzle pointers persistent storage system object table may needed 
discussion current literature clear distinction object page caches 
believe distinction somewhat artificial possible combine best features 
benefits vm integration low overhead bookkeeping compelling reasons page cache 
pages easier extent cache hierarchy include remote memory see section 
possible may workloads clustering really zero sum game 
require system support overlapping object clusterings 
alternative replicate objects multiple pages disk server cache adds addition cost keeping replicas date changed 
extending client server cache hierarchy section discuss alternatives client server cache hierarchy distributed file systems persistent stores 
distributed shared memory systems dsm differ client server systems clients cooperate maintain global cache client server system client cache independent 
remote client caches important resource overlap data cached different processors caches underutilized 
resource file systems persistent object systems exploit 
researches begun look extending cache hierarchy types systems include remote memory 
main examples experimental xfs file system berkeley franklin extensions exodus persistent storage manager wisconsin remote memory paging 
main reasons extend cache hierarchy include remote memory move server functions clients increase cache hits increasing total cache size 
distributing server functions clients advantage offloading server 
decrease latency certain operations clients communicate directly contacting server improves scalability 
effective cache size increased ways 
sharing concurrent sequential multiple processors data accessed processor may cached local memory processor 
second local memory processor underutilized local programs portion extend cache processors cache 
main issues relate policies mechanisms managing global cache find page parts system know cached 
global cache management policies complicated tension local memory maximize cache efficiency local processor memory improve caching system 
considerable sharing processors tension exhibits tradeoff increasing replication maximize local performance decreasing reduce duplication data global cache 
data shared tension seen tradeoff local memory local caching caching data remote processors 
distributed shared memory dsm provides parallel distributed program illusion global shared memory 
system replicates data local memories data accessed programs maintains consistency protocol invalidates updates replicas modifications occur 
systems typically don support persistence interesting define view memory hierarchy different client server view taken persistent storage systems 
dsm system processor client 
program accesses data cached local memory data retrieved client server 
similarly coherency updates invalidations transferred client client 
effective cache potentially larger client server systems includes local memories processor network just client server 
main issues locating data local cache invalidating updating copies item modified 
dsm systems actions tied program concurrency control primitives implicit synchronization page accesses 
primary data structure called 
item lists processors currently cache item depending dsm system item page lock object 
li surveys alternatives maintain information 
simplest approach centralize item single processor called manager 
manager contention reduced assigning processor management responsibilities fixed set items example hashing function address 
network communication reduced distributing things method li calls dynamic distributed manager algorithm 
items managed processor modify owner 
owner satisfies requests copies item sends coherency messages item updated 
ownership moves processor probable owner field left probable owner fields processors updated receive copies item copies invalidated updated 
probable owner fields form chain leads item current owner 
approach distributes data structure 
organized tree 
processor node edges leading node local subset probable owner 
page requests flow tree current owner root coherency messages flow tree owner 
adding additional synchronization processor page requests satisfied processor currently item cached 
benefit overhead sending coherency messages divided multiple processors 
li shows dynamic distributed manager outperforms centralized alternatives 
contrasts studies distributed locking algorithms shown centralized manager techniques best 
particular felten rabinovich describe algorithm centralized manager distributed waiter queue outperforms known alternatives light heavy contention workloads 
finding page similar finding lock different results explained fact dsm algorithms just concerned locating lock token locating current copy data 
general centralized manager requires round trip messages fetch data item manager find current owner current owner fetch data 
distributed lock algorithms absence contention manager need contacted 
distributed manager dsm better requires average round trips locate page distributed manager lock average better round trip 
summary dsm systems differ client server systems server 
data owned processor modify central server 
cache occurs page forwarding pointers left ownership move processor processor 
distributed file systems policy tradeoffs remote memory distributed file system explored dahlin context xfs design new file system 
afs client disks included cache hierarchy 
modified files kept clients transferred client client server differs afs updates propagated server file closed 
previous file system xfs includes remote memory cache hierarchy 
simulated policy alternatives remote memory direct client cooperation greedy forwarding centrally coordinated caching chance forwarding considered read accesses 
direct client approach simplest 
processor idle entire local memory active clients 
active clients memory extend caches cooperation clients server unmodified 
approach extends size clients cache provide benefits sharing client needs page cached client read server client 
greedy forwarding hand supports sharing extend size client cache 
client manages local cache independently 
server keeps track cache state clients 
cache occurs client request sent server 
server determines requested page cached client forwards request client sends page directly requesting client 
centrally coordinated caching statically allocates portion local memory global cache 
local caches managed greedy forwarding global cache managed server global lru page discard 
page evicted local cache set server added global cache 
adding global cache system avoids duplication duplication occurs local caches 
main disadvantage approach static partition local memory penalizes processors benefit larger smaller local cache increasing local cache misses decreasing potential size global cache 
chance forwarding algorithm claim works best 
separate global cache singleton page discarded local cache forwarded processor chosen random page singleton cached processor 
page recirculation counter set time accessed program 
page forwarded counter decremented counter reaches zero page discarded 
greedy forwarding server complete knowledge cached requests pages cached client forward server 
simulations show centrally coordinated chance best performance due control duplication 
improved average page read time rates factor 
central coordination doubles local cache rate compared alternatives due static division local memory local global caches result server load central coordination higher alternatives 
chance forwarding recirculation count effective 
study limitations 
built prototype system 
result important overheads fully considered simulation communication needed clients determine pages cache singletons server know client currently page cached 
requires clients inform server discard pages cache typically done distributed file systems 
concern protocols extent centralized 
cache results message central server page cached client contrast pages located dsm systems 
simulation file system traces files read sequentially start finish workstations active minute interval average 
leave unanswered question algorithms perform workloads paging databases mapped files heavily loaded conditions 
persistent object systems franklin extended client server exodus allow server satisfy requests client data cached client 
file system franklin views memory hierarchy consisting levels local cache server cache remote client cache server disk 
basic approach similar greedy forwarding client requests page server checks page cache list pages believes cached clients 
page client server requests client send page requester 
additional features added scheme sending dropped pages hate hints 
clients inform server drop page cache 
server checks see client holds copy page 
request client send page server dropping 
server caches page cache 
similar chance forwarding selecting recipient page random server selected 
second approach hate hits avoid duplication server cache 
server sends page client marks copy page cache 
pages discarded servers cache 
avoids duplication server cache attempt avoid duplication page multiple client caches 
remote memory paging felten zahorjan describe system uses local memory idle workstation backing store virtual memory 
similar xfs direct client algorithm 
approaches effect extending size client cache provide benefits pages shared processors page exists exactly place local memory remote memory disk 
simplifies implementation support coherency unnecessary coherency needed data replicated 
remote memory stores dirty page failure remote processor cause program fail 
moderately large distributed system necessary protect programs 
fault tolerance added sending dirty pages remote memories multiple processors forcing disk adverse performance implications 
problem distributed file systems cache holds dirty data modifications sent durable storage 
persistent store possible avoid replication leveraging recoverability protocol 
essence dirty page lost long updates written durable log normally done systems 
discuss section 
discussion remote memories important resource 
data shared processors concurrently sequentially pages needed program processor may cached local memory processor 
system get page read disk 
remote memory useful caching demands processors differ 
certain times processor may modest need local memory cache data interest programs currently running 
times processors able available memory increase size caches 
extreme example memory idle workstation paging 
important issues information cache state system stored cache management decisions 
supporting updates turn question updates applied data 
key issues summarized question values returned reads follow update 
multiprocessor distributed shared memory systems defined memory consistency model 
main challenge updates preserve model data shared distributed persistent 
issues normally treated separate problems concurrency control coherency recoverability 
believe really aspects problem implementing memory consistency model 
defining consistency normal programs assume current value variable determined write program variable 
fundamental assumption essential making sense data accesses program 
notion extended data shared programs see values written programs 
uniprocessor read returns result write location program 
guarantee provided cache coherency hardware shared memory multiprocessors 
assertion read returns value written example memory consistency model 
model programs deal sharing application specific way typically concurrency control primitives define critical sections code executing thread exclusive access specific set data 
distributed system consistency difficult define clear meant value written data item 
ordering events distributed system defined lamport happened relation defines partial ordering events system processors communicate sending messages 
happened transitive closure happened event said happened immediately event executed processor program order sending message receiving message 
program order order operations appear program text 
system dsm persistent storage system processors communicate shared data clear order operations 
strictest memory model called linearizability requires ordering hypothetical global clock provides guarantee uniprocessors 
model impractical requires global synchronization memory operation 
sequential consistency provides weaker strong guarantee weaker exist executions sequentially consistent linearizable 
sequential consistency requires processor agree ordering memory operations ordering agree program order processor 
linearizability sequential consistency strict memory models weaker sequential consistency expensive implement requires coherency operation 
class relaxed models delay coherency leveraging concurrency control primitives program coordinate access shared data 
hill extended happened relationship define ordering concurrency control operations programs acquire release critical section synchronization object lock 
relation happened defines partial order operations ordering acquire lock release lock preceded acquire execution program 
program data race free happened defines total order conflicting operations operations conflicting write location 
adve hill defined memory consistency model called data race free provides data race free programs guarantees sequential consistency 
cheaper implement coherency delayed programs synchronize 
data race free similar relaxed model called release consistency release consistency guarantees sequential consistency conflicting operations synchronized data races 
entry consistency type relaxed consistency model concurrency control 
places additional requirement programs addition data race free explicit association locks data 
entry consistency guarantees consistency data item lock associated item held lock acquired released 
offers efficient implementation data race free class models memory consistent lock acquired 
entry consistent evolved long line consistency models distributed parallel programming domain identical consistent model persistent storage systems 
consistency persistent data meaning consistency persistent data typically defined somewhat differently 
database literature term integrity constraint describe conditions determine database states considered consistent 
operations grouped sequences called atomic actions transactions transform database consistent state 
transactions serve important functions define consistency model support recoverability 
consistency model defined transactions called serializability 
states effect executing group concurrent transactions transactions executed sequentially order transactions sequentially consistent respect 
property known independence states partial effects transactions visible outside transaction 
provided property transactions known atomicity 
atomicity requires updates transaction applied database 
failure database reflect effects completed transactions committed 
transactional property called durability states transaction committed effects permanently recorded durable memory 
important part transaction model programs need know updates durable typically needed programs interact outside world difficult undo redo operations 
example atm ensure withdrawal transaction durable dispensing cash 
important properties transactions summarized acid acronym atomic transform database consistent state independent serializable durable 
variations transaction model weaken independence 
rvm example separates synchronization coherency recoverability 
kaiser provide survey number transaction models support weaker consistency guarantees serializability 
weaker models allow concurrency particularly important long running read transactions 
section discuss class weaker models multiple versions timestamps 
concurrency control discuss aspects implementing consistency model concurrency control coherency recoverability concurrency control 
form concurrency control needed extend read latest value rule individual program group programs access data concurrently 
done locks optimistically 
previous section granularity key questions 
locking granularity persistent storage systems granularity locking granularity caching page servers typically page locks object servers object locks 
advantages page grain locks page faults implicit locking objectstore coarse grain locks cheaper implement group objects locked client server interaction 
unfortunately coarse grain locking leads problem known false sharing page grain locking locking conflicts arise different programs attempt access different objects happen page 
fact primary objections page grain caching systems exodus objectstore caching locking grain systems 
carey argued finer grain locks possible page cache 
ideas shore uses de locks page grain locks server detects conflict 
server receives conflicting lock request requests client convert page lock object locks objects accessed 
allows server access objects page clients 
optimistic concurrency control concurrency control mechanisms pessimistic execute instructions critical section ensure executing thread appropriate access permission 
example systems typically provide types access permission exclusive shared 
update object program needs exclusive access 
multiple programs concurrent shared read access object shared permission revoked order updater exclusive access 
transaction isolation serializability typically provided phase locking 
locks acquired transaction executes held transaction locks released transaction committed aborted 
distributed system lock permission normally acquired exchanging messages lock manager running processor client server systems clients get locks server 
optimistic concurrency control alternative optimizes common case programs rarely conflicting accesses shared data 
acquiring locks validation phase added checks conflicts committing sequence updates 
thor uses optimistic scheme transactions object version numbers stored object client cache server 
transaction commits transaction log sent server log contains version number object transaction accessed read wrote 
server validates transaction checking version numbers list ensure transaction accessed current version object multiple servers involved objects control part standard phase commit protocol 
transaction date object aborted 
abort message returned client includes list objects date 
client aborts program transaction invalidates stale objects cache 
transaction commits server sends invalidation message clients cache objects modified transaction 
clients invalidate objects caches preemptively abort transactions access 
optimization reduces aborts result accessing stale object 
timestamps multiple versions interesting class optimistic concurrency control techniques update timestamps objects 
modifying objects place modifying object creates new version version copy object state particular point time 
object versions organized history version unique timestamp indicates version created 
timestamps determine versions objects system consistent group versions called consistency configuration database 
timestamps compared ensure programs see updates inconsistent order defined consistency model 
versions provides benefits optimistic concurrency control need validation phase 
important benefit older versions objects retained program read objects currently updated violating consistency model guaranteed consistent slightly date view database 
distributed timestamp consistency protocol global view time base timestamps 
models mentioned uses slightly different approach 
example weihl assigns timestamps transaction initiation phase collect current timestamp object transaction access create new timestamp greater timestamp assigned object modified transaction 
approaches variants lamport logical clock defines global time happened relation 
types timestamp synchronization timestamp ordering multiversion phase locking mv pl transactional updates objects modified creating copy object 
timestamp ordering timestamp ordering introduced reed 
transaction identified globally unique ascending start time transactions serialized start time 
object timestamps record sequence number transaction modified 
objects record list start times transactions read 
read operation selects version object older transaction start time 
checks see transaction produced version committed read blocks waits fate version resolved 
write operations check read list object determine newer read transaction read object 
update transaction aborts 
transaction aborts versions created discarded read list entries removed objects read reads await discarded versions aborted 
approach disadvantages 
objects modified program reading 
cache entries means read transactions write access data read 
second conflict read transaction update transaction updating transaction aborted 
costly abort transaction changes changes undone 
nice favor aborting read transactions better avoid conflict altogether 
third reed provision minimizing space consumed approach discarding old version longer needed 
fourth update transactions cause read transactions block unnecessary older versions exists consistent configuration transaction access blocking 
multiversion phase locking multiversion phase locking mv pl alternative timestamp ordering addresses shortcomings 
mv pl transactions divided categories update read 
update actions normal phase locking read actions run concurrently timestamp ordering 
advantage mv pl transactions serialized commit point starting point timestamp ordering timestamp object version reflects time creating transaction committed 
means timestamp ordering object read time subsequent versions object timestamp greater obviates need read list means read transaction need update object read 
read transaction selects consistent configuration reading version object created transactions committed began 
non trivial race condition initiation read transaction commit procedure update transactions 
read transaction timestamp issued lock point commit point update transaction lock point point transaction timestamp determined 
means objects timestamps older read starting time transactions committed 
read transaction read version update transaction subsequently aborted inconsistency result 
chan gray solve problem keeping list committed transactions consulted read access object determining version read 
agrawal sengupta improve computing highest timestamp transactions lower timestamps committed 
weihl defines multiversion protocols similar mv pl focuses old versions collected discarded 
basic technique add initiation phase read transaction 
prior accessing object transaction completes initiation phase contacting object access objects record timestamp read action 
objects notified read transactions complete 
version older minimum current time oldest executing read action discarded 
version modeling database applications need support concurrent updates data 
example cad database objects typically accessed checkout checkin synchronization 
engineer checks relatively large group objects works locally 
mean time engineer want read possibly modify objects 
multiversion system possible allow long information dependencies different version retained consistency guaranteed 
done defining version model 
concurrent updates allowed longer possible select consistent configuration picking versions committed particular point time 
configuration defined version graph lists version object belongs configuration 
users typically control defining configurations interesting tools provided manipulating version history resolve conflicting updates object 
katz provides survey version models cad databases 
object oriented databases provide support maintaining multiple versions creating workspace allows programs define database configurations transaction see 
provide support defining version models typically left applications relatively ad hoc 
coherency data distributed addition providing currency control system maintain coherency data cached multiple memories 
program modifies data writing copy cached local memory 
point copies modified data items brought date 
done sending messages invalidate update copies 
coherency mechanism guard inconsistencies occur coherency messages delayed applied order different original write operations 
distributed shared memory systems early distributed shared memory systems page grain caching locking coherency 
dsm systems decoupled granularity caching locking coherency 
typically caching granularity locking determined application granularity coherency determined data program modifies 
issues data modified knowing coherency operations needed 
detecting changed dsm systems detect data changed help vm system suggested appel li :10.1.1.12.2903
pages initially protected write operation page generates fault 
ivy system traps fault lists page modified 
munin treadmarks page copied unprotected list updates diffs generated comparing modified page copy 
protecting copying comparing pages midway uses software approach 
compiler modified insert code write operation sets dirty bit associated object 
code simplified requiring coherency grain fixed size objects 
system allows different regions memory different sizes 
similarly persistent storage systems typically software detection 
vm approaches advantage implemented transparently programs programming languages special compiler needed 
potentially significant cost disadvantage 
copying comparing memory intensive operations scaling processor speed 
pages large objects small amounts significant overhead 
software approaches advantage fixed small overhead associated update 
similar argument hosking moss 
performing coherency operations consistency model determines coherency operations needed 
strict consistency dsm ivy page protections trap writes coherency maintained invalidation ensure modified pages cached memory 
relaxed models concurrency control primitives programs drive coherency 
munin implements restricted form release consistency data race free coherency occurs time program releases lock 
lock released diffs generated modified page comparing copy modified pages protected detect writes 
diff contains address size value modified byte range 
messages containing diffs sent processor 
processor applies diffs memories sends message 
received release completes 
memory operations releasing processor stalled release completes 
stronger required consistency model sufficient stall processor subsequently issued acquire 
munin allows programs optimize coherency protocol annotating data select update invalidate coherency 
treadmarks implements consistency model known lazy release consistency lrc 
programs lrc looks exactly release consistency rc 
difference coherency delayed program issues acquire 
offers efficient implementation acquiring processor coherent processor 
complicated implement 
diffs generated way rc creation delayed processor requests updates particular page 
time divided intervals acquire release 
pages tagged vector timestamp entry processor indicating interval processor page received updates 
processor keeps vector indicates interval processor dependent happened relation 
lock acquired acquiring processor dependency vector compared page vector page releasing processor determine acquiring processors pages date 
list pages processors modified write notices sent reply message acquire 
stale page accessed message sent processors modified page retrieve diffs 
diff retained processor need received 
diff sent processor discarded 
discarding diffs problematic processor may access page diff pertains may wait arbitrarily long time 
treadmarks deals performing synchronous checkpoints system bring memories date 
midway lock released modified cache lines tagged processor current timestamp 
timestamp global clock implemented lamport happened relationship 
sending message sending processor increments timestamp includes message 
receiving processor sets timestamp maximum timestamp sending processors timestamp 
lock acquired processor timestamps determine cache lines date 
lock records processor store value processor timestamp lock transferred processor 
acquiring lock timestamp value sent processor currently holds lock 
processor compares lock timestamp timestamps object protected lock determine changed acquiring processor held lock 
copies objects sent back processor reply message acquire 
midway differs treadmarks keeping list diffs objects modified processor records timestamp object similar multiversion timestamps discussed section 
uses space avoids problem determining old diffs discarded 
cost choice determine changed necessary perform timestamp compare object associated lock 
granularity locking greater granularity coherency overhead substantial 
addition necessary current lock holder retain local memory objects associated lock way knowing portions objects needed bring subsequent acquiring node date 
persistent storage systems stated previously persistent storage systems provide consistency model identical entry consistency 
locks ensure coherency cached data 
works client server systems allows client request item acquire lock message exchange server 
locks guarantee application access stale data client cache 
exodus locks released transaction pages remain cached client 
client subsequently requests access cached pages server checks see client cache date 
sends updated page client lock 
orion objects flushed client cache transaction objectstore pages flushed lock released 
objectstore shore locks cached client transactions server uses call back messages request clients release locks conflicts occur 
shore cross transaction call back locks maintain coherence client page cache objects flushed program private cache transaction completes 
exodus shore date pages updated shipping new copy entire page server objects page date 
discussion coherency concurrency control needed support sharing distributed data policies mechanisms implementing related 
dsm research shown parallel programs coherency mechanism known programs acquired locks necessary access data item ensure coherency item time 
dsm systems midway entry consistency best sending fewest number messages 
striking difference dsm persistent stores persistent stores typically tie granularity coherency consistency 
client stale copy item entire item object page send client just differences needed bring client date 
results greater network overhead client caching nearly date object objects large large object actively shared multiple processors 
recoverability recoverability property data allows survive failures 
recoverability defines constraints durable memory updates order ensure consistency persistent data 
failures cause loss volatile state interrupt updates durable memory 
system recoverable failure restored consistent state 
provide recoverability data management system ensure durable memory updates atomic obey transaction semantics described section 
main ways provide atomicity general purpose systems logging shadowing 
logging techniques write updates durable log updating durable memory 
shadowing log updates shadow database swapped current database single atomic operation 
version persistent data stored durable memory consistent called checkpoint 
shadowing gemstone ps algol persistent storage systems shadowing provide recoverability 
system maintains multiple mappings database old mapping checkpoint new mapping modified pages 
pages memory mapped copy write checkpoint 
system checkpointed freezing updates writing modified data new mapping structure disk 
atomicity achieved leaving old mapping place disk write swaps checkpoint new mapping 
shadowing implemented aid virtual memory system order minimize impact checkpointing performance normal transactions 
appel li describe concurrent checkpointing scheme checkpoints stopping normal operation briefly long write thread state critical state synchronously disk write protect pages cache 
normal operation allowed continue thread works background copy cached pages disk pages copied protection changed allow write access 
application tries modify page checkpointed fault occurs allows copy page disk write access allowed complete 
procedure incremental vm system maintain list dirty pages writing pages disk 
twin paging type shadowing keeping multiple mappings copies modifiable page maintained 
page timestamp updated written disk 
page read disk copies retrieved 
page timestamps compared timestamp current checkpoint page written disk prior checkpoint considered current checkpoint 
page written disk overwrites page current checkpoint 
create checkpoint dirty pages written disk new checkpoint timestamp written disk atomic operation 
introduced twin page checkpointing scheme integrated virtual memory translation 
scheme current checkpoint identified global checkpoint register system uses register select current page time translates virtual address physical address 
logging persistent storage systems recoverability techniques logging 
updates recorded write ahead log wal written durable memory updates applied durable memory 
failure occurs durable memory updated log finished updates failure 
updates uncommitted transactions allowed propagate durable memory wal undo 
logging physical new possibly old values modified objects logged logical log contains redo possibly undo operations 
caching concurrency control coherency granularity key issues 
granularities recoverability concurrency control typically linked recovery grain larger coherency grain imply logging unlocked data 
objectstore exodus example page grain logging transaction commits modified page sent client server 
thor shore object grain logging modified objects written log sent server 
choice natural thor client caches object grain 
shore client caches page grain de locks concurrency control object grain 
important issue log recovery policies interact cache management 
interaction logging cache management log system data stored places page local memory page durable memory log durable memory 
page local memory may contain updates committed uncommitted transactions 
durable log contain records committed updates possibly uncommitted updates 
copy database durable memory fuzzy checkpoint system 
called fuzzy database necessarily consistent durable log consistent 
places important constraint durable memory updates local memory page overwrite checkpoint page durable memory updates page including uncommitted updates recorded durable log 
important interactions caching logging protecting checkpoint pages durable memory second new checkpoints taken 
summarized issues defining key cache management characteristics steal force 
cache management policy steal modified pages written back durable memory time steal pages remain memory transactions modifying completed 
policy force page forced back durable memory transaction completes force policy effectively maintains checkpoint transaction commit 
force policy durable memory updated forcing local memory pages time reading pages durable memory local memory applying log records necessary bring date forcing pages back durable memory 
durable memory disk read called installation read needed install updates satisfy client request 
argued section integrating cache virtual memory system benefits 
note requires steal management policy page outs written automatically back durable memory 
example pages modified transaction pinned physical memory prevented paged transaction completes 
transaction checkpointing scheme exodus shore aries algorithm steal force policy 
policy steal coordinating writing pages durable memory durable log writes 
log record assigned monotonically increasing sequence number log sequence number lsn 
page stores lsn transaction modify 
log contains undo redo information 
log records accumulated local memory changes forced durable log necessary commit transaction 
modified page written durable memory lsn lower high lsn durable log modifications page logged 
policy force periodic checkpoints needed checkpoint taken writing single checkpoint record lists pages currently date memory version different disk version transactions commit 
aries originally single server system exodus aries extended approach client server systems 
ibm storage architecture uses hardware lock bits pages implement steal policy modified page written disk modifying transaction completed page written temporary disk block 
segmented system supports recoverability functions directly hardware 
transaction locking selected segments implemented hardware special hardware register stores executing thread transaction identifier 
address translation system provides page grain locking 
maintains bit bit line page indicating current transaction modified 
commit scans pages locked current transaction logs bit sections modified releases locks 
levy silberschatz fuzzy checkpointing scheme memory resident database optimizes checkpointing ordering log records page modify 
transactions generate log records written durable log sent accumulator process 
accumulator groups log records modify page 
threshold reached page checkpointed reading durable memory applying accumulated log records page writing back durable memory log records committed transactions applied 
deciding checkpoint page presents performance tradeoff waiting longer results fewer checkpoint operations increase size log recovery time 
thor uses similar mechanism update durable memory 
transaction logs accumulated clients local memory 
commit transaction client sends transaction log server 
server writes log durable log organizes log records local memory page 
modified pages servers cache updated corresponding log records discarded 
log records installation reads delayed number log records possibly different transactions collected 
server reads page disk satisfy client request checks list pending log records see copy disk date 
log records update sent client 
checkpointing distributed shared memory checkpointing important distributed parallel programs long running run processors 
factors increase likelihood failure occur execution 
solution execution state programs recoverable checkpointing state durable memory 
main difficulty ensure checkpoint consistent 
considerable past decade checkpointing message distributed systems 
types distributed checkpointing schemes consistent pessimistic optimistic 
consistent checkpointing establishes coordinated checkpoint entire system performing global synchronization processor 
pessimistic checkpointing duplicates messages message sent target processor designated backup processor 
processor fails backup capable standing 
optimistic checkpointing allows processors checkpoint independently individual checkpoints coordinated form consistent global checkpoint event failure processors 
global checkpoint formed tracking dependencies individual processor checkpoints consistent message recorded received recorded sent 
possible combination checkpoints consistent problem known domino effect 
way prevent processors log durable memory messages received checkpoints allows individual checkpoint rolled forward 
easy see distributed checkpointing extended dsm systems simply lowest level shared memory illusion implemented message passing 
checkpointing added level regard higher level shared memory model 
efficiencies achieved implementing recoverability higher level integrating support coherency 
recoverability strict consistency models wu fuchs introduced recoverable dsm adding checkpointing strict consistency page grain dsm system similar ivy 
processors checkpoint independently twin paging write checkpoint durable storage 
checkpoints incremental pages modified checkpoint written disk 
checkpoint triggered time processor receives request page modified checkpoint 
checkpoint written disk page sent requesting processor 
similar message pessimistic checkpointing processors checkpoint sending message 
stumm zhou describe pessimistic page grain checkpointing scheme dsm recoverable restore execution context programs failed processor 
approach avoids writing data durable memory tolerates failure single processor time 
provide recoverability page replicated local memories processors 
requires coordination client cache managers 
write permission page cache managers ensure cached processor 
invalidating remote copies page normally done ensure coherency cache retains page prevents programs accessing 
processor sends modified page processor replicates modified sending requested page marks pages unmodified 
richard singhal provide pessimistic page grain recoverable dsm combination independent processor checkpoints page logging 
accessing page reading writing programs acquire lock 
lock acquisition software copies acquired page volatile log local memory 
modified page transferred processor log written stable storage 
failed processor recovered restoring checkpoint replaying execution satisfying page requests log log exhausted 
page vector timestamps detect discard writes issued replay page subsequently modified processor 
recoverability relaxed consistency models janssens fuchs integrate recoverability dsm relaxed consistency model release consistency 
approach similar strict consistency approaches discussed checkpoints taken coherency operations required 
relaxed consistency improves performance recoverability decreasing checkpointing frequency reasons improves coherency performance 
janssens fuchs propose checkpointing protocols coherency invalidate 
invalidation processor checkpoints lock holds acquired remote processor 
update protocol processors checkpoint time local lock released 
recoverability entry consistency castro added recoverability entry consistent dsm system called approach tolerates single node multiple node failures 
keeping volatile log local memory processor records changes processor 
distributed log recover failed processor replaying execution 
replay acquires satisfied log supplying version object supplied normal execution prior failure 
possible node fails object version acquired logged surviving processor locally produced 
message optimistic checkpointing execution assumed deterministic 
information needed determine versions replaying execution acquire stored logs surviving processor 
generate information thread maintains local counter incremented acquire 
thread acquires lock current counter value version object acquired stored local memory remote processor 
lock acquired remote processor information recorded remote processor object log 
acquired locally information logged randomly chosen remote processor sending extra message 
replaying execution failed processor necessary recreate log including information stored processors versions objects acquired 
thread maintains list acquires issued records identity thread supplied object counter values threads 
recovery lists surviving processors examined determine threads acquired objects failed processor 
information update recovering processors log 
discussion recurring theme preceding discussion log updating modifying object recording copy version history log 
discussed examples multiversion concurrency control allows reading concurrent updates version models permit concurrent updating manage consistency data modified different people time treadmarks generates diff histories lazily maintain coherency write ahead logging guarantees recoverability transactional updates object logging entry consistent dsm recoverable 
interesting examples exist transactional memory implement non blocking synchronization transaction logs maintain coherency persistent data logging simplify concurrent compacting garbage collection 
compacting garbage collection offers benefits persistent store 
support implicit object deletion reduce fragmentation objects implement implicit persistence 
concurrency important obvious reason applications tolerate long pause times occur objects copied 
compacting collectors copying objects active copy database called space space 
concurrent collector allows programs access data copy threads making normal accesses called mutators 
traditionally done switching space collection allowing mutators access objects space 
complicated system prevent mutator pointer space modifying object 
examples 
appel prevent mutators accessing space objects virtual memory page protections trap trap handler copies objects referent page space granting access 
demers technique checks page dirty bits detect writes objects copied write occurs entire page 
persistent heap transaction logs recoverability simpler efficient approach possible 
transactions allow mutators access modify objects space flip space happens collection complete 
space updates recorded transaction log easily reapplied space bring date changes collection 
important complexity performance benefits 
example collector need recoverable doing complex 
furthermore mutators interrupted follows wrong pointer appel collector required extra demers 
management persistent data distributed system essentially cache management problem 
local memory workstation node cache stores persistent data active programs running 
system moves data local memory data accessed transfers changes back durable memory disk persistent 
main issues data organized cache hierarchy look consistency maintained face updates shared distributed persistent data 
granularity granularity key issue discussed places 
choice page object granularity caching concurrency control coherency recoverability 
granularity caching page grain caching advantages 
foremost allows cache integrated virtual memory system 
important benefits performance ease 
page faults detect cache misses 
vm integration eliminates need expensive memory memory coping transfer data object grain cache 
solves level paging problems caused false dirty bits dirty bits set objects copied cache 
page grain cache cache virtual address object persistent name eliminates minimizes need pointer translation swizzling 
important benefit eliminates need item removed cache critical problem objectstore successful commercial object oriented database 
benefits page grain caching presents internal fragmentation problems implemented lower bookkeeping overhead 
real advantage object grain caching comes impossible cluster objects page 
thor persistent store uses object grain client caches believe clustering zero sum game clustering bad programs 
bad clustering page grain cache results poor utilization network bandwidth client memory 
conclusive empirical evidence settle clustering question way 
advantages page grain caching strong possibility reasonably clustering usually high caching best choice 
making choice dictate granularity concurrency control coherency recoverability traditionally case persistent storage systems 
granularity updates granularity concurrency control match access patterns programs 
programs concurrency control object grain programs design systems cad software design environments coarse grain locking checkout portion database local access object grain locking control local concurrency 
page grain locking false sharing conflicts arise programs try access different objects reside page 
cache page grain cache misses detected page faults locking 
traditionally persistent storage systems page grain caches page grain locks client typically holds locks items cache 
shore system depart providing page grain locks turned object grain locks conflict occurs 
similarly granularity coherency recoverability separated granularity caching concurrency control coherency modern distributed shared memory systems 
allows efficient coarse grain locks lock collection objects instance change modified portions objects updated 
page grain persistent stores object modified entire page typically invalidated 
invalidation appropriate objects actively shared requires entire page retransmitted client time client accesses 
argument similar recoverability object grain log stores data consumes network bandwidth transmitting changes back server 
page grain stores typically page grain logging 
important benefit thor uses object grain logging benefit easily extended page grain cache techniques dsm systems detect part page modified 
summary argue system caches page grain cache client receives entire page data operations related updates object grain fine grain 
argument stronger amount ram workstations increases 
amount data cache increase 
furthermore system organized utilizes remote memory caching resource programs may rarely go disk read data 
updates persistent data stored durable memory object grain recoverability efficient 
similar way object grain coherency reduces cost maintaining consistency replicated data 
directions research begun look ways workstation memory network global cache file systems xfs persistent storage systems franklin paging felten 

example approaches confined particular application domain specific workload assumptions 
xfs looks unix file accesses typically different page grain accesses franklin exodus storage server 
franklin turn different paging 
better approach build single remote memory caching mechanism environments 
areas research include investigating global caching policies greater detail vm integration page grain accesses change assumptions xfs study 
little investigates handle updates remote memory caching system xfs focuses read accesses provides coarse grain coherency file grain typical file systems franklin assumes page grain coherency recoverability felten remote paging require coherency pages shared postulates replication provide recoverability 
believe ideas object grain consistency applied domain great benefit 
example object grain recoverability updates page stored durable log 
allows dirty pages discarded remote processor processor fails current version page reconstructed durable version log 
needed explore techniques log updates coherency recoverability interact page grained caching vm integration 
interesting question long object log remain local memory 
log useful concurrency control coherency 
multiversion timestamp concurrency control allow reads proceed concurrent updates reading objects log 
log records bring stale incoherent page date avoiding need reread page disk remote memory 
log records back changes processor processor read consistent version page processor reading disk 
hand log consumes valuable memory 
concurrent reading versions objects needed 
coherency efficient read page remote memory exists possibly disk size log records page eventually exceed size page 
sarita adve mark hill 
unified formalization shared memory models 
ieee transactions parallel distributed systems june 
agrawal sengupta 
modular synchronization distributed multiversion databases version control concurrency control 
ieee transactions knowledge data engineering february 
guy 
garbage collection object oriented system 
technical report cmu cs school computer science carnegie mellon university june 
thomas anderson henry levy brian bershad edward lazowska 
interaction architecture operating system design 
proceedings fourth symposium architectural support programming languages operating systems asplos iv pages april 
andrew appel john ellis 
real time concurrent collection stock multiprocessors 
proceedings acm sigplan symposium programming language design implementation pages june 
andrew appel kai li :10.1.1.12.2903
virtual memory primitives user programs 
proceedings fourth symposium architectural support programming languages operating systems asplos iv pages april 
malcolm atkinson ken chisholm paul cockshott 
ps algol algol persistent heap 
sigplan notices july 
mary baker john hartman michael kupfer ken john ousterhout 
measurements distributed file system 
proceedings th acm symposium operating systems principles pages october 
kaiser 
concurrency control advanced database applications 
acm computing surveys september 
brian bershad wayne 
midway distributed shared memory system 
proceedings compcon conference pages february 
hans boehm alan demers scott shenker 
parallel garbage collection 
proceedings acm sigplan symposium programming language design implementation pages june 
anita borg jim sam 
message system supporting fault tolerance 
proceedings th acm symposium operating systems principles pages october 
anita borg wolfgang blau wolfgang ferdinand herrmann wolfgang oberle 
fault tolerance unix 
acm transactions computer systems february 
nicholas pradhan 
virtual checkpoints architecture performance 
ieee transactions computers may 
paul butterworth allen jacob stein 
gemstone object database management system 
communications acm october 
michael carey david dewitt daniel frank goetz graefe joel richardson eugene shekita 
architecture exodus extensible dbms 
proceedings th vldb conference pages 
michael carey david dewitt michael franklin nancy hall mark mcauliffe jeffrey naughton daniel schuh marvin solomon tan seth white michael 
persistent applications 
proceedings acm sigmod international conference management data may 
michael carey michael franklin 
fine grained sharing page server oodbms 
proceedings acm sigmod international conference management data may 
john carter john bennett willy zwaenepoel 
implementation performance munin 
proceedings th acm symposium operating systems principles pages october 
chan robert gray 
implementing distributed read transactions 
ieee transactions software engineering se february 
mani chandy leslie lamport 
determining global states distributed systems 
acm transactions computing systems february 
albert chang mark mergen 
storage architecture programming 
acm transactions computer systems february 
chao mackey sears 
mach virtually addressed cache architecture 
proceedings usenix mach symposium pages october 
jeffrey chase henry levy michael feeley edward lazowska 
sharing protection single address space operating system 
acm transactions computer systems november 
appear 
atkinson chisholm 
persistent object management system 
software practice experience january 
alan cox dwarkadas pete keleher lu ramakrishnan willy zwaenepoel 
software versus hardware shared memory implementation case study 
proceedings st annual international symposium computer architecture pages april 
michael dahlin clifford randolph wang thomas anderson david patterson 
quantitative analysis cache policies scalable network file systems 
proceedings sigmetrics pages may 
michael dahlin randolph wang thomas anderson 
cooperative caching remote client memory improve file system performance 
proceedings symposium operating system design implementation pages november 
daley dennis 
virtual memory sharing multics 
communications acm may 
date 
database systems 
addison wesley reading ma 
mark day 
lockup client object cache avoid 
proceedings international workshop object oriented operating systems 
mark day 
object groups may better pages 
proceedings th workshop workstation operating systems pages 
david detlefs 
concurrent atomic garbage collection 
technical report cmu cs school computer science carnegie mellon university october 
deux 
system 
communications acm october 
david dewitt david maier philippe fernando velez 
study alternative workstation server architectures object oriented database systems 
proceedings th vldb conference pages 
edsger dijkstra leslie lamport martin scholten 
thefly garbage collection exercise cooperation 
communications acm november 
elnozahy willy zwaenepoel 
manetho transparent rollback recovery low overhead limited rollback fast output commit 
ieee transactions computers may 
nabil elnozahy david johnson willy zwaenepoel 
performance consistent checkpointing 
proceedings th symposium reliable distributed systems pages october 
eswaran gray lorie traiger 
notion consistency predicated locks database system 
communications acm november 
michael feeley jeffrey chase vivek henry levy 
integrating coherency recoverability distributed systems 
proceedings symposium operating system design implementation pages november 
edward felten michael rabinovich 
centralized token algorithm distributed mutual exclusion 
technical report department computer science engineering university washington february 
edward felten john zahorjan 
issues implementation remote memory paging system 
technical report department computer science engineering university washington march 
fowler 
decentralized object finding forwarding addresses 
phd department computer science engineering university washington december 
technical report 
michael franklin michael carey 
client server caching revisited 
proceedings international workshop distributed object management august 
michael franklin michael tan michael carey david dewitt 
crash recovery client server exodus 
proceedings acm sigmod international conference management data pages june 
kourosh gharachorloo daniel lenoski james laudon phillip gibbons anoop gupta john hennessy 
memory consistency event ordering scalable shared memory multiprocessors 
proceedings th annual international symposium computer architecture pages may 
arthur goldberg gopal kong li rob strom david bacon 
transparent recovery mach applications 
proceedings usenix mach conference pages july 
gray 
notes data base operating systems 
bayer graham editors lecture notes computer science vol operating systems advanced course pages 
springer verlag new york 
jim gray andreas reuter 
transaction processing concepts techniques 
morgan kaufmann publishers san mateo california 
paulo miguel castro 
distributed shared object memory 
proceedings th workshop workstation operating systems pages october 
theo andreas reuter 
principles transaction oriented database recovery 
acm computing surveys december 
robert hagmann 
crash recovery scheme memory resident database system 
ieee transactions computers september 
maurice herlihy eliot moss 
transactional memory architectural support lock free data structures 
proceedings th annual international symposium computer architecture pages may 
maurice herlihy jeannette wing 
linearizability correctness condition concurrent objects 
acm transactions programming languages systems july 
antony hosking eliot moss 
protection traps alternatives memory management object oriented language 
proceedings th acm symposium operating systems principles pages december 
hoffman 
ibm system support capability addressing 
proceedings th symposium computer architecture may 
john howard michael kazar menees david nichols satyanarayanan robert sidebotham michael west 
scale performance distributed file system 
acm transactions computer systems february 
golden richard iii singhal 
logging asynchronous checkpointing implement recoverable distributed shared memory 
proceedings th symposium reliable distributed systems pages october 
barrera iii 
fast mach network ipc implementation 
proceedings usenix mach symposium pages november 
bob janssens kent fuchs 
relaxing consistency recoverable distributed shared memory 
proceedings third annual international symposium fault tolerant computing digest papers pages june 
johnson zwaenepoel 
high performance rpc system 
software practice experience february 
david johnson 
efficient transparent optimistic rollback recovery distributed application programs 
proceedings th symposium reliable distributed systems pages october 
david johnson willy zwaenepoel 
sender message logging 
proceedings seventeenth annual international symposium fault tolerant computing digest papers pages july 
david johnson willy zwaenepoel 
recovery distributed systems message logging checkpointing 
journal algorithms september 
henry baker jr list processing real time serial computer 
communications acm april 
randy katz 
unified framework version modeling engineering databases 
acm computing surveys december 
pete keleher alan cox dwarkadas willy zwaenepoel 
treadmarks distributed shared memory standard workstations operating systems 
proceedings winter usenix conference pages january 
pete keleher alan cox willy zwaenepoel 
lazy release consistency software distributed shared memory 
proceedings th annual international symposium computer architecture pages may 
won kim jorge nathaniel darrell woelk 
architecture orion database system 
ieee transactions knowledge data engineering march 
elliot william weihl 
atomic incremental garbage collection recovery large stable heap 
proceedings acm sigmod international conference management data pages 
charles lamb gordon landis jack orenstein dan weinreb 
database system 
communications acm october 
leslie lamport 
time clocks ordering events distributed system 
communications acm july 
leslie lamport 
multiprocessor computer correctly executes multiprocess programs 
ieee transactions computers september 
levy avi silberschatz 
incremental recovery main memory database systems 
ieee transactions knowledge data engineering december 
li naughton plank 
real time concurrent checkpoint parallel programs 
proceedings second acm sigplan symposium principles practice parallel programming pages march 
kai li paul hudak 
memory coherence shared virtual memory systems 
acm transactions computer systems november 
barbara liskov mark day sanjay ghemawat robert gruber umesh maheshwari andrew myers shrira 
language independent interface thor persistent object store 
programming methodology group memo massachusetts institute technology laboratory computer science march 
mohan don bruce lindsay hamid pirahesh peter schwarz 
aries transaction recovery method supporting fine granularity locking partial rollbacks write ahead logging 
acm transactions database systems march 
mohan 
aries csa method database recovery client server architectures 
proceedings acm sigmod international conference management data pages may 
eliot moss 
design mneme persistent object store 
acm transactions office information systems april 
michael nelson brent welch john ousterhout 
caching sprite network operating system 
acm transactions computer systems february 
nuno miguel castro paulo 
checkpoint protocol entry consistent shared memory system 
proceedings th acm symposium principles distributed computing august 
james toole scott nettles 
concurrent replication garbage collection implementation report 
technical report cmu cs school computer science carnegie mellon university pittsburgh pa april 
appears mit lcs tr 
james toole scott nettles david gifford 
concurrent compacting garbage collection persistent heap 
proceedings th acm symposium operating systems principles pages december 
james toole shrira 
opportunistic log efficient installation reads reliable storage server 
proceedings symposium operating system design implementation pages november 
papadimitriou 
serializability concurrent database updates 
journal acm pages october 
james plank 
efficient checkpointing mimd architectures 
phd thesis department computer science princeton university june 
michael powell david presotto 
publishing reliable broadcast communication mechanism 
proceedings th acm symposium operating systems principles pages october 
brian randell 
system structure software fault tolerance 
ieee transactions software engineering se june 
redell dalal lauer lynch mcjones murray purcell 
pilot operating system personal computer 
communications acm february 
david reed 
implementing atomic actions decentralized data 
acm transactions computer systems february 
reuter 
fast transaction oriented logging scheme undo recovery 
ieee transactions software engineering se july 
david russell 
state restoration systems communicating processes 
ieee transactions software engineering se march 
russel sandberg david goldberg steve kleiman dan walsh bob lyon 
design implementation sun network filesystem 
proceedings summer usenix conference pages june 
satyanarayanan kumar steere kistler 
lightweight recoverable virtual memory 
acm transactions computer systems february 
richard schlichting fred schneider 
fail processors approach designing faulttolerant computing systems 
acm transactions computer systems august 
shekita 
cricket mapped persistent object store 
proceedings fourth international workshop persistent object systems design implementation september 

design business data processing system 
ieee computer september 
robert strom yemini 
optimistic recovery distributed systems 
acm transactions computer systems august 
michael stumm zhou 
fault tolerant distributed shared memory algorithms 
proceedings second ieee symposium parallel distributed processing pages december 
manolis jeffrey naughton 
performance object clustering techniques 
proceedings acm sigmod international conference management data pages 
william weihl 
distributed version management read actions 
ieee transactions software engineering se january 
seth white david dewitt 
high performance mapped object store 
proceedings acm sigmod international conference management data pages may 
paul wilson 
uniprocessor garbage collection techniques 
proceedings sigplan international workshop memory management pages september 
paul wilson kakkad 
pointer swizzling page fault time efficiently compatibly supporting huge address spaces standard hardware 
proceedings international workshop object orientation operating systems pages september 
kun lung wu kent fuchs 
recoverable shared virtual memory 
ieee transactions computers april 
matthew wayne brian bershad 
software write detection distributed shared memory 
proceedings symposium operating system design implementation pages november 
