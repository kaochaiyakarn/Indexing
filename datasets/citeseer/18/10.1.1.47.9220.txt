experimental assessment workstation failures impact checkpointing systems james plank department computer science university tennessee knoxville tn plank cs utk edu december technical report ut cs university tennessee available ftp cs utk edu pub plank papers cs ps web www cs utk edu plank plank papers cs html submitted publication 
see web page information 
experimental assessment workstation failures impact checkpointing systems james plank december university tennessee technical report ut cs 
submitted publication 
publication status please see www cs utk edu plank plank papers cs html past years wealth theoretical research minimizing expected running time program presence failures employing checkpointing rollback recovery 
time period little experimental research corroborate results 
study results separate projects monitor failure workstation networks 
goals twofold 
see results correlate theoretical results second assess impact strategies checkpointing long running computations workstations networks workstations 
surprising result base assumptions theoretical research hold results applicable 
price performance desktop workstations viable platform scientific computing 
combined software platforms allow workstations cooperate paradigms messagepassing mes shared memory acd workstation networks powerful computational resources rivaling supercomputers utility scientific programming 
traditionally checkpointing rollback recovery employed provide fault tolerance longrunning computations computing platforms ls ste cpl 
storing checkpoint program limits amount re execution necessary process processor failure 
turn improves program running time presence failures 
plank cs utk edu 
material supported national science foundation ccr cda ccr 
checkpoint question paramount practical importance 
checkpoints overhead checkpointing may slow application program 
checkpoints infrequently program may spend time re executing code failures 
problem determining checkpoint called optimal checkpoint interval problem 
goal allow users checkpointing systems determine frequency checkpointing interval minimizes expected running time application presence failures 
determining optimal checkpoint interval field research rich history 
papers topic appeared context transaction processing systems cr gd gel 
concentrated real time systems sll distributed systems vai wf ks general frameworks analysis bac tb ksl lm vai 
papers derive analytical results concerning performance checkpointing systems presence failures 
relation scientific computing workstations workstation networks research implications 
assumptions underlying analytical results hold may ffl predict program expected running time presence failures checkpointing 
ffl determine optimal interval checkpoint 
interval enables program minimize expected running time presence failures 
ffl compare performance checkpointing algorithms 
short results may help important decisions concerning algorithms runtime parameters checkpointing system 
papers require probability distribution workstation failures known 
typically poisson failure rates assumed 
papers assumed tb sll employed exemplify usage resulting equations 
workstation failures follow poisson model applicability results scientific computing workstations brought question 
little research addresses underlying assumptions results 
cs manifestation software errors shown follow poisson processes 
significantly long performed study monitoring availability machines internet 
study determine probability machine failures poisson model extremely small 
attempt characterize failure model standard probability distribution function 
contradiction theoretical results experimental observations 
purpose address contradiction assess practical implications users checkpointing systems 
analyzing machine availability data different networks workstations including long 
simulate performance programs checkpointing networks compare simulated results theoretical projections 
surprising result failure model networks decidedly governed poisson processes approximation theoretical results hold 
absence data mttf machine may determine checkpoint interval optimal reasonably close 
outline outline follows 
section state significant results research optimal checkpoint interval 
failures follow poisson distribution results cited section extremely useful determining runtime parameters checkpointing comparing checkpointing algorithms 
section describe sets data study 
set contains longitudinal failure information collection workstations period months greater 
data set state high confidence failures follow poisson distribution 
remainder data section run simulations checkpointing systems 
simulations may determine performance checkpointing parameters checkpoint interval overhead 
simulations assess equations section predict actual checkpointing performance 
conclude recommendations selecting parameters algorithms checkpointing minimize expected running time long running computations 
results research optimal checkpoint interval literature cited section useful equations concerning performance checkpointing systems 
divide categories 
predicting performance program checkpointing 
checkpointing runs program hopes completes machine running fails 
machine fail program started anew machine functional 

predicting performance program checkpointing 
checkpointing program periodically stores checkpoints execution state 
machine fails program recovers state stored checkpoint 

predicting optimal checkpoint interval 
frequency checkpointing minimizes program expected running time presence failures 

predicting failure rate parallel systems 
equations categories derived uniprocessor systems 
certain cases treat parallel checkpointing system uniprocessor system slightly different failure model 
order equations categories failure rate parallel system predicted uniprocessor failure rate 
prediction subject category 
equations follow employ nomenclature borrowed vaidya vai average checkpoint overhead 
checkpoint overhead amount time added application failure free run result checkpointing 
represents average overhead checkpoint 
checkpoint latency 
latency defined time checkpoint initiated may recover failure 
application halted checkpointing latency typically equals overhead 
certain optimizations forked checkpointing decrease overhead drastically slightly increasing latency discussion please see vai 
recovery time 
time takes system restore checkpointed state functional 
note take account time system re execution time application 
simply measure long takes system restore checkpoint 
typically similar values 
time 
average time failure system functional 
failure free running time 
running time application checkpointing machine fail 
checkpoint interval 
application checkpointing periodically frequency checkpointing governed checkpoint interval 
unfortunately ways specify checkpoint interval 
duration start checkpoint start checkpoint 
second defined gamma latency equal overhead time checkpoint checkpoint 
checkpointing systems pl require user specify require user specify optimizations forked checkpointing ae natural specification 
theoretical research optimal checkpoint interval assumes specified 
difference specifying subtle implications performance 
specified interval program start checkpoint specified similarly specified interval recovery checkpoint checkpoint specified checkpointing system requires user specify requires user specify parameters performance systems may differ 
ae difference slight close failure rate high difference may significant 
checkpointing systems greater checkpoint complete begins 
expected running time 
expected running time application checkpointing presence failures 
checkpoint interval depending interval specification method checkpointing system requires 
ef expected running time checkpointing 
checkpoint interval specification method program checkpoint 
failure occurs application restart 
ef expected running time presence failures checkpointing 
opt opt optimal checkpoint interval 
opt value minimizes opt value minimizes ae opt opt failure rate 
average number failures unit time 
mean time failure system mttf mttf 
random variable poisson distribution governed poisson process results hold 
predicting performance program checkpointing equation predicting ef specified duda ef gamma gamma delta equation assumed time zero 
include non zero times equation multiplied ef gamma gamma delta assumes governed poisson process 
predicting performance program checkpointing calculate vaidya provides equation vai gammac gamma gamma delta note ef may derived 
predicting optimal checkpoint interval approximation opt derived young opt refer young approximation 
approximation assumed papers provide refinements young approximation 
vaidya provided equation opt vai topt gamma opt opt refer vaidya approximation 
important note vaidya includes overhead latency recovery time model equation opt depends overhead failure rate 
predicting failure rate parallel systems theoretical research checkpointing performance parallel systems 
straightforward approach assume processors cooperating run parallel application periodically coordinate take checkpoints global system state 
called coordinated checkpoints 
thorough discussion coordinated checkpointing please see survey elnozahy 
processor fails processors halt 
processors functional roll back stored checkpoint 
scenario equations may employed predict performance checkpointing long rate processor collection failing 
processor failures independent follow poisson distributions fact employed performance predictions parallel checkpointing systems vai wf ks 
data collection assess applicability equations obtained collections failure data separate workstation networks 
collection set workstations monitored period months 
workstation data records periods machine functional 
assume functional periods machine failure state 
granularity data seconds accuracy described order minutes hours 
describe data set 
long random machines internet set data collected long july may 
wrote program called periodically queries set workstations internet determine time intervals 
remain unaffected network partitions replicated sites data merged provide unified view workstations question 
description assessment failure data appears 
report data hosts distributed world 
obtained data culled number hosts removing machines reported times vastly july may interval machines percent availability machines scientific programming 
reason ttf ttr data looks slightly different 
obvious data collection method may tell story concerning machine failures 
example machine fails twice queries corresponding interval failures lost 
data reports machine necessarily usable 
collection wide variety geographically distributed machines long collection extremely useful 
princeton network dec alpha workstations princeton data set contains failure information collection sixteen dec alpha workstations department computer science princeton university 
machines owned individuals department sitting desks 
general purpose workstations member department needs 
size network smaller long represents typical local cluster homogeneous processors parallel computation 
princeton machines rebooted brought backups regular schedule 
fail typically planned 
failure data princeton collected january july 
method collection differed long method 
program called job live target machine recognize failures 
runs background machine probing machine minutes ensure alive 
cron daemon machine spawn additional copies hour hours hours twelve hours hours main program dies due machine process failure gets restarted cron daemon 
measures slightly different class failures 
example system administrator owner machine decides kill processes system detect failure goes unnoticed 
detects machine functional running 
time machine restoration failure gets initiated cron daemon considered time time 
cetus network sun sparc workstations cetus data set contains failure information collected cetus lab department computer science university tennessee 
cetus lab collection sun sparc ipx workstations connected local area network 
machines general purpose workstations member department needs 
popular computing platform running parallel scientific applications 
big difference cetus machines princeton machines cetus machines may reserved night exclusive researchers conducting timing tests 
reservation begins machines rebooted cron daemons disabled logins refused user reservation 
report reserved times classifies machines unavailable time 
cetus data collected december july 
cetus princeton data sets included opposite ends spectrum 
homogeneous local area networks workstations princeton machines fail infrequently set schedule cetus machines fail frequently quasi regular intervals 
knowledge usage machines long data set 
looking failure data clear follow daily rebooting schedule fail unpredictable times 
basic characteristics data sets basic characteristics data sets table 
expected princeton machines longest mean time failure cetus machines shortest 
ttf ttr interval distribution graphs show networks greatly varying distributions 
long data shows variety ttf ttr intervals distinct spike just day 
long guesses due number machine owners reboot machines day 
nearly half princeton ttf intervals longer month longer days 
ttr intervals day 
contrast cetus ttf intervals day value roughly hours accounting third intervals 
similarly ttr intervals hours 
lab reservations hour periods ttf ttr distributions quite reasonable 
order workstation failures governed poisson process ttf intervals distributed exponentially 
exponential distribution mttf days shown 
rule set observed data governed en exponential distribution standard tests may state high low confidence set data exponentially distributed 
long network long princeton cetus number machines number ttf intervals number ttr intervals mean ttf interval days mean ttr interval days availability ttf interval distribution time failure days fraction intervals time failure days fraction intervals time failure days fraction intervals ttr interval distribution time recovery days fraction intervals time recovery days fraction intervals time recovery days fraction intervals table basic characteristics data sets performs test data determine probability intervals distributed exponentially vanishingly small 
likewise performed tests sets data spss software package sps reached 
simulation checkpointing rollback recovery assess applicability theoretical results section wrote program simulate expected performance long running programs periodic checkpointing rollback recovery 
input simulator takes data sets plus machine data set 
picks starting time machine simulates running program machine starting time 
seconds program takes checkpoint requires seconds processing time failure days fraction intervals exponential ttf distribution mttf days run start run start lost normal execution overhead committing checkpoint recovering time line seconds example program simulation committed seconds started 
program gets seconds running time addition checkpoint overhead finishes 
machine fails program finishes program wait machine functional takes seconds recover committed checkpoint zero seconds committed checkpoint 
continues processing program completes failure occurs 
simulation calculated hour machine lifetime 
specifically simulation started time simulation starts 
machine simulation starts uptime 
simulations run manner get data set 
running times averaged yield expected running time program machines collection 
example suppose data set consists machine uptime intervals wish simulate program 
graph shows simulation proceeds including checkpoints failures recoveries 
run checkpoints completed machine fails 
machine comes back program failure free running time days expected running time days simulated projected eq 
long failure free running time days simulated projected princeton failure free running time days simulated projected cetus running times presence failure restored second checkpoint takes checkpoint completing 
running time program execution checkpoint overhead recovery overhead lost computation downtime 
second run program executes machine fails 
comes back program restarted 
takes checkpoints completing total running time execution checkpoint overhead recovery overhead lost computation downtime 
third run program complete starts 
expected time completion program machine seconds 
simulation results ran simulations data sets compared results analytic equations section 
results prediction categories section 
predicting performance program checkpointing predict ef program eq 
section 
displays results simulating programs checkpointing varying running times networks 
unsurprisingly princeton network gives fastest running times cetus network gives slowest 
plots projected values ef eq 
section line ef 
networks projected simulated values start running time increases projected values rise rapidly simulated values 
effect marked networks higher failure rates 
suggests ef deviates eq 
loses utility 
predicting performance program checkpointing predict performance program periodic checkpointing eq 
section 
measure eq 
predicts running time programs employ checkpointing ran simulations days expected running time days long days princeton days cetus effect modifying programs programs ran days overheads minutes varied just greater overhead days 
overheads consistent reported real life checkpointing applications 
tests assume display results minute overheads varying minutes days 
displays features typical tests 
anticipated small overhead checkpointing dominates running time program 
effect decreases rapidly increases expected running time reaches minimal value 
opt running time increases slowly lost due failures significant 
second network shape curve quite similar 
say approximation effect varying running time program independent third cases minimum running time value days 
shape curve cetus network jagged 
direct result ttf distribution 
displayed table third ttf intervals occur roughly days 
sense sharp increase grows past 
similarly expects see smaller increase grows past 
effect pronounced subsequent graphs 
brevity figures follow plot values days restrict values near opt plot simulated projected values programs 
project eq 
assume gamma anticipated overhead checkpointing lower lowered values value opt lower 
similarly overhead higher higher values value opt higher 
striking feature graphs projected values quite close simulated values 
especially true near opt holds failing cetus machines 
draw surprising small values eq 
reasonable predictor checkpointing performance 
days expected running time days long days princeton days cetus expected running time days expected running time days simulated projected effect modifying simulated projected 
optimal checkpoint interval important equation section determination optimal checkpoint interval 
section evaluate utility young approximation vaidya approximation data sets 
programs running times days simulator determine optimal checkpoint interval opt values seconds hour 
compared values opt calculated young vaidya approximations 
shows results tests 
top row graphs plots values opt function checkpoint overhead 
bottom rows graphs value opt simulated young vaidya simulated expected running time program checkpoint interval 
middle row graphs plot expected running times function checkpoint overhead 
definition simulated value opt yield lowest expected running time 
bottom row graphs prints performance penalty young vaidya approximation opt simulated value 
interesting results 
consider simulator determination opt minutes opt days simulated young approx 
vaidya approx 
long minutes princeton minutes cetus minutes days minutes minutes minutes penalty optimal running time hours long minutes princeton minutes penalty optimal running time cetus comparing simulated projected values opt 
true value note true value opt greater vaidya approximation 
resembles step function changes steps approaches vaidya approximation 
steps larger long cetus networks appear related fact data sets single ttf value disproportionately represented roughly long cetus network 
young vaidya approximation says example opt cetus network opt near number checkpoints committed frequent ttf interval computation lost ttf interval checkpoint interval just 

obviously going explained effect disproportionately represented ttf values cetus long impact opt second third rows graphs quantify performance penalty choosing young vaidya approximation opt correct value 
long princeton networks penalty quite small just hours case total running time application 
minutes days minutes minutes minutes running time days long minutes princeton minutes cetus optimal checkpoint interval function latency cetus network places approximations differ correct values show worst performance penalties 
draw long princeton networks young vaidya approximations achieve close optimal performance long running programs 
cetus network approximations points penalize performance significantly day optimal selection checkpoint interval 
final middle row graphs displays decreasing checkpoint overhead improves performance application 
example long network lowering overhead hour minutes improves average running time day 
lowering overhead hour minute improves running time days 
note points curves meet axis correspond availability respective systems 
example availability princeton network 
expect optimal expected running time approximately curve intersects axis 
latency result section optimal checkpoint interval independent checkpoint latency 
test performed tests fix checkpoint overhead vary latency 
results displayed 
top row graphs shows value opt function latency 
consistent pattern emerges approximation appear opt independent second row graphs shows number processors lambda failures day simulated projected eq 
long number processors princeton number processors cetus determination network 
optimal running time value increases running time increases degree increased 
agrees vaidya assertion checkpoint latency far impact running time program overhead vai 
predicting failure rate parallel systems performed final test explore validity eq 
section 
wrote program takes input data set long princeton cetus number processors calculates data set 
monte carlo simulation 
program runs number iterations iteration chooses random set processors data set 
calculates ttf intervals data set stipulating state processors functional state processors functional 
ttf intervals averaged iterations mttf calculated 
inverse mttf 
displays calculated program iterations value 
plotted function compared results quite different network 
long network appears grow linearly rate princeton cetus networks grows slowly expected proximity machines network failures independent 
cetus network reservation schedule guarantees processor failures independent closer data hard draw general concerning failure rate parallel systems 
certainly assuming reasonable networks possible exception long network 
remains seen implication predictions parallel checkpointing performance vai wf ks 
results workstation monitoring projects assess applicability theoretical equations concerning performance checkpointing 
equations require failure recovery rates follow poisson processes actual failure recovery rates follow poisson processes expected equations little applicability 
surprise cases equations provide excellent checkpointing performance 
summarize findings ffl eq 
poor predictor running time program checkpointing 
particular failures play significant role execution program eq 
overestimates expected running time drastically 
ffl eq 
provides approximation expected running time program checkpoint intervals near optimal interval 
ffl young vaidya approximations opt opt may huge performance penalty 
particular approximations long princeton networks penalized performance hours program ran days 
ffl optimal checkpoint interval appears independent checkpoint latency 
optimize performance checkpointing decreasing overhead impact decreasing latency 
ffl little said rate failure processor parallel system assumed equal systems failures independent cetus network attempt quantify actual failure distribution networks terms known distributions 
attempt characterize mathematical properties distributions impact equations section 
subject analyze mathematical underpinnings results 
avenues area 
encourage collection dissemination wider variety failure data 
second consider factors cpu load network performance data collection simulation 
third consider parallel systems advanced checkpointing algorithms simple coordinated checkpointing 
acknowledgments authors darrell long richard golding sharing failure data lee writing monitoring princeton cetus networks 
geoff adam beguelin letting monitor workstation networks nitin vaidya yi min wang answering questions 
acd cox dwarkadas keleher lu yu zwaenepoel 
treadmarks shared memory computing networks workstations 
ieee computer february 
bac baccelli 
analysis service facility periodic checkpointing 
acta informatica 
crowder smith 
statistical analysis reliability data 
chapman hall london 
cpl chen plank li 
clip checkpointing tool message passing parallel programs 
sc high performance networking computing san jose november 
cr chandy ramamoorthy 
rollback recovery strategies computer programs 
ieee transactions computers june 
cs crow 
empirically developed fourier series model describing software failures 
ieee transactions reliability june 
duda 
effects checkpointing program execution time 
information processing letters 
elnozahy johnson wang 
survey rollback recovery protocols messagepassing systems 
technical report cmu cs carnegie mellon university october 
elnozahy johnson zwaenepoel 
performance consistent checkpointing 
th symposium reliable distributed systems pages october 
gd 
performance rollback recovery systems failures 
communications acm june 
gel 
optimum checkpoint interval 
journal acm april 
geist reynolds 
selection checkpoint interval critical task environment 
ieee transactions reliability october 
huang 
wang 
software tools libraries fault tolerance 
ieee technical committee operating systems application environments winter 
ks sanders 
performance analysis time coordinated checkpointing protocols 
pacific rim international symposium fault tolerant systems taipei taiwan december 
ksl krishna shin lee 
optimization criteria checkpoint placement 
communications acm october 
lm malenfant 
computing optimal checkpointing strategies rollback recovery systems 
ieee transactions computers april 
long muir golding 
longitudinal survey internet host reliability 
th symposium reliable distributed systems pages bad september 
ieee 
ls litzkow solomon 
supporting checkpointing process migration outside unix kernel 
usenix winter technical conference pages san francisco ca january 
mes message passing interface forum 
mpi message passing interface standard 
international journal supercomputer applications 
plank beck li 
transparent checkpointing unix 
usenix winter technical conference pages january 
pl plank li 
consistent multicomputers 
ieee parallel distributed technology summer 
sunderam geist dongarra manchek 
pvm concurrent computing system evolution experiences trends 
journal parallel distributed computing 
sll shin 
lin 
lee 
optimal checkpointing real time tasks 
ieee transactions computers november 
sps spss spss windows 
release see www spss com 
ste 
checkpointing process migration mpi 
th international parallel processing symposium april 
tb toueg babaoglu 
optimum checkpoint selection problem 
siam journal computing august 
vai vaidya 
case level distributed recovery schemes 
acm sigmetrics conference measurement modeling computer systems ottawa may 
vai vaidya 
impact checkpoint latency overhead ratio checkpointing scheme 
ieee transactions computers august 
wf wong franklin 
checkpointing distributed systems 
journal parallel distributed systems may 

wang huang 
vo 
chung 
checkpointing applications 
th international symposium fault tolerant computing pages pasadena ca june 
young 
order approximation optimum checkpoint interval 
communications acm september 
