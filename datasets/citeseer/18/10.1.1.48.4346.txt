lambda lifting transforming programs recursive equations thomas johnsson september revised june lambda lifting technique transforming functional program local function definitions possibly free variables function definitions program consisting global function combinator definitions rewrite rules 
different ways doing lambda lifting reasons rejecting selecting method lazy ml compiler 
attribute grammar functional program implementing chosen algorithm 
originally proceedings conference functional programming languages computer architecture lecture notes computer science nancy france 
springer verlag 
part author thesis 
main addition attribute grammar formulation 
compiling lazy functional language technique described joh presumed input program form set function definitions possibly mutually recursive expression evaluated printed value program 
programs form nm value program function bodies contain lambda expressions may contain local definitions letrec 
summarise technique function definition fx compiled code graph reduction machine called machine performs graph rewriting fe graph application function rewritten graph value right hand side substituting actual parameters formal parameters recursive equations powerful programming language right convenience program clarity advantage able write lambda expressions locally defined functions 
introduce expressions local function definitions xx compiler principle able move function definition global level 
similarly compiler transform lambda expression xx expression move function definition xx global level new unique identifier 
simple scheme course breaks function body contains free variables free variable function definition undefined definition moved global level 
dealing free variables function definitions main subject 
process flattening program involving local function definitions possibly free variables program consisting global function definitions call lambda lifting 
proceed discussion choices depend particular idiosyncrasies machine 
algorithm described compiler lazy ml lml short developed augustsson 
details compiler papers aug joh aug 
different strategies transformation attempt translate lambda expressions dealing programs containing lambda expressions lambda expression lifted global function rewrite rule 
follows treated lambda expression introducing variables nested lambda expressions 
definition equivalent safely done necessary free variables lambda expression transformation rule beta substitution backwards free variable example illustrates idea 
innermost lambda expression indicated name global function thing done outermost yielding def def expr lml functional languages allow expressions local definitions 
traditional way dealing local nonrecursive recursive definitions letrec defining meaning implementations treat syntactic sugaring lambda expressions fix point combinator lan tur hug 
transformation rules 
letrec resulting expression contains lambda expressions place lets treated described 
example illustrates 
letrec remove recursion remove free variables giving names lambda expressions lifting global level yields program 
def def def expr treating expressions involving letrec manner just described unsatisfactory reasons ffl efficiency reasons want recursive function source program remain recursive transformed program lml compiler machine deal global recursive functions 
eliminating recursion fix point combinator introduces unnecessary inefficiencies 
ffl letrec expressions involve lambda expressions need 
directly compiled machine code constructs evaluates shared cyclic expression graph 
ffl effect transformation scheme free variable occurs inside lambda expression abstracted lambda expression passed function argument way place usage 
right hand side definition lambda expression prefer treat definition global function constant occurrence need abstracted 
turn attention lambda lifting schemes allow keep recursion letrec far possible 
attempt keep letrec attempt keep letrec expressions program proceed lambda expressions 
example letrec ii free lambda expression abstracted letrec ii def expr letrec ii unfortunately modified strategy suffers drawbacks attempt local function definitions definitions right hand side lambda expression treated definitions variables passed arguments occurences inside lambda expressions abstracted lambda expressions 
example happened variable abstracted definition consequence resulting global function recursive 
drawback scheme concerns efficiency function application machine setting 
comes evaluation application ii example value unreduced curried application argument missing able reduce revert worst case treatment application 
hand function applied global graph value function node number arguments formal parameters possible evaluate application efficiently 
particular example ii tail call 
variable know essentially better simpler way implement tail call build graph ii hard way 
global function arity call implemented efficiently assignment ii followed jump code see joh details 
efficient build graph application function global number argument number formal parameters 
case build vector application node chain apply nodes 
aim strategy local function definitions lifted global level global function constants occurrences need abstracted presence free variables function definitions 
attempt trouble attempt having abstracted free variables local function definition right hand side function longer lambda expression lambda expression applied abstracted variables 
third attempt perform abstraction follows ffl free variable local function definition add argument function lambda abstraction 
function names treated constants need abstracted 
ffl apply free variables function substituting fx set free variables definition 
identifiers unique lambda lifting process starts name clash occur 
difference version version lambda lifting strategy place abstracted variables passed arguments 
version lambda expression function definition applied abstracted variables version function applied abstracted variables 
shall see little difference far reaching effects 
example letrec ii variable free definition get letrec ii safely lifted global function constant def expr ii try new strategy example involving mutually recursive function definitions different free variables 
incidentally definition global keep expression merely introduce free variable 
letrec 
variable free free apply new lambda lifting strategy get letrec 
step unfortunately introduced variable function definitions lifted new free variables 
lambda insertion step repeated letrec 
contain free variables get global functions expression def def expr 
example obvious adopt abstraction method lambda lifting algorithm lambda insertion application repeated free variables remain inside lambda expressions 
take complicated contrived example repetition necessary 
consider recursive 



performing lambda lifting compiler repeatedly transforming program manner costly 
possible find set variables abstracted function costly manner 
denote set variables abstracted definition function definition set equation involving resulting system set equations solved respect look nasty example 
letrec 
obviously contains variables applied free variables set equations obtain example 
fag fbg proceed solve equations 
substituting equation second fbg fag fa bg solution fa bg equation get fa bg solutions instruct ffl add definition ffl substitute similarly solving set equations equivalent computing transitive closure relation fcg true function occurrence function name obtained fh fc hg set free variables function best time complexity known transitive closure problem ahu worst case complexity lambda lifting algorithm number functions program equations functions program solved go 
general situation quite bad 
previous example see contain scope rules language fxg obtained directly having solve set equations 
proceed top program lambda lifted invoke set equation solving machinery set mutually recursive function definitions letrec expression 
lambda lifting algorithm lambda lifting algorithm adopt solving set equations described previous section 

give identifiers unique name 
done early lml compiler called scope analysis 
avoid name clashes doing substitutions step 
handling set equations simplified functions distinct names 

anonymous lambda expressions right hand side definition names substituting letf inf case new unique identifier 
purpose lambda expressions take part equation solving machinery function definitions give names global functions 

traverse program top 
letrec expression letrec defined functions defined variables vm compute set variables abstracted defined functions follows 
point know items obtained previously top traversal program vars set variables current scope occur free variables letrec expression 
start lambda lifting process set empty 
funs similarly set functions current scope functions know variables abstracted functions 
initially set empty 
sol solutions set equations function names set funs 
functions yields set equation fg ff fi fv mg vars fi gn fg funs fi fi free identifiers functions ones defined currently processed definition list 
functions functions defined outer level comes solutions sol 
note definitions recursive set fg empty solution directly 
solve set equations example repeated substitution 
continue program tree vars vars fv mg funs funs ff sol sol fn 
fx mg solution set equations perform substitutions program ffl definition ffl occurence 
lift functions global level 
definition list empty substitute similarly letrec 
said complexity algorithm 
solving set equations letrec expression complexity set operations basic operations number functions definition list 
rest algorithm linear number set operations basic operations size program 
attribute grammar functional program lambda lifting section elaborate lambda lifting details form attribute grammar steps previous section 
attribute grammar translated functional program evaluating attributes 
discussion attribute grammar functional programming joh 
attribute grammar thought decoration parse tree pairs 
normally parse tree constructed implicitly explicitly parsing input string lexical symbols 
presenting attribute grammar lambda lifting writing attribute definitions conjunction production rules context free grammar write conjunction patterns match nodes syntax tree 
instance production rule letrec attribute definitions write letrec attribute definitions variables correspond nonterminals attributes assigned 
pattern letrec appear function evaluates attributes 
deal syntax trees generated lml type declarations expr letrec list def expr appl id list expr def var id expr fun id list id expr sake simplifying discussion consider recursive local definitions non recursive ones degenerate case solving set equations necessary 
appl curried application identifier list expressions 
definition variable definition var function definition fun list identifiers formal parameters function 
table summarizes cases considered attribute grammar 
letrec local recursive definition expression appl curried application expression non empty argument list empty argument list var variable definition definition list fun function definition definition list empty definition list 
variables denote expressions denote argument lists lists expressions denote definition lists 
set operations lambda lifting algorithm list id 
list id set ids list ids list id 
list id 
list id union list id 
list id 
list id intersection mem id list id 
bool membership lists sets reasons 
order identifiers set important step algorithm variables course order abstracting function definition occur function applied 
achieved example letting set operations maintain list sorted duplicates 
frequently convenient treat set list concatenated traversed map concession readability conventional symbols union intersection set membership respectively 
denote empty set list fxg denote singleton sets lists 
entities vars funs sol previous section inherited propagating downwards tree attributes attribute grammar 
synthesized propagating upwards attributes ids set identifiers occuring expression expression list definition list applicable 
lifted list lifted function definitions expr new expression expression list definition list applicable lifted functions removed 
furthermore mere programming convenience constructing set equations additional synthesized attributes defined definition lists variables defined definition list functions defined definition list ss list pairs function names identifiers occuring definition 
give attribute grammar entirety attribute time 
notation attribute ids say ids 
letrec ids ids ids appl ids ffg ids ids ids ids ids var ids ids ids fun ids ids ids ids letrec lifted lifted lifted appl lifted lifted lifted lifted lifted lifted var lifted lifted lifted fun lifted fun lookup sol expr lifted lifted lifted letrec expr expr expr letrec expr expr appl expr appl lookup sol expr map appl expr expr expr expr var expr var expr expr fun expr expr expr letrec vars vars vars vars appl vars vars vars vars vars vars var vars vars vars vars fun vars vars vars vars letrec funs funs funs funs appl funs funs funs funs funs funs var funs funs funs funs fun funs funs funs funs letrec sol sol solve map sol funs vars ss sol appl sol sol sol sol sol sol var sol sol sol sol fun sol sol sol sol var fig fun var fun ffg var ss ss fun ss ids ss ss meat algorithm contained places marked 
function definition put list lifted functions note functions absent resulting expression attribute expr 
substitutions step performed solutions set equations obtained looking attribute sol 
note perform lookup identifier function sense definition right hand side lambda expression 
function lookup return empty set 
function lookup defined follows 
lookup sol lookup sol lookup steps performed 
set equations definition obtained solved solution appended previously obtained solution 
set equation represented triple fg 
list triples function definition list constructed ss attribute definition list 
expression sol funs vars computes fv mg vars fi gn step 
function defined follows 
sol lookup sol sol sol function solve solves set equations 
possible formulation solve solves repeated substitution see page definitions map 
solve solve solve sol solve map lookup sol sol give functional program doing lambda lifting evaluating attributes defined attribute grammar 
function contains auxiliary functions le la ld doing actual traversing syntax tree evaluating attributes 
apart tree argument take arguments inherited attributes return tuple synthesized attributes 
le takes expression la takes expression list ld takes definition list argument 
take arguments attributes vars funs sol 
le la returns triple attributes expr lifted ids 
ld returns tuple attributes expr lifted ids ss 
note attribute grammar describes multipass algorithm resulting program traverses syntax tree 
note unconventional recursion resulting method evaluating attributes particularly conspicuous case le letrec 
components ld returns compute set equations functions defined definition list 
equations solved extended set solutions passed tree le la ld uses compute second component tuple 
circular programs requires lazy evaluation 
discussion programming techniques bir joh 
expr sol sol letrec solve solve solve solve map mem letrec le letrec vars funs sol letrec ed dd id ss ld ee de le vars funs solve map 
sol funs ss sol ed ee letrec ed ee de dd id le appl vars funs sol ee de la vars funs sol appl map appl sol ee de la vars funs sol la vars funs sol ee de le vars funs sol el dl il la vars funs sol ee el de dl il ld vars funs sol ld var vars funs sol ee de le vars funs sol el dl il ss ld vars funs sol var ee el de dl il ss ld fun vars funs sol ee de le vars funs sol el dl il ss ld vars funs sol el fun sol ee de dl il ss le expr letrec library functions map map map def def def def ahu aho hopcroft ullman 
design analysis algorithms 
addison wesley reading mass 
aug augustsson 
compiler lazy ml 
proceedings acm symposium lisp functional programming pages austin 
aug augustsson 
compiling pattern matching 
proceedings conference functional programming languages computer architecture pages nancy france 
bir bird 
circular programs eliminate multiple data 
acta informatica 
hug hughes 
super combinators new implementation method applicative languages 
proceedings acm symposium lisp functional programming pages pittsburgh 
joh johnsson 
efficient compilation lazy evaluation 
proceedings sigplan symposium compiler construction pages montreal 
joh johnsson 
attribute grammars functional programming paradigm 
proceedings conference functional programming languages computer architecture lecture notes computer science portland oregon 
springer verlag 
lan landin 
programming languages 
communications acm 
tur turner 
new implementation technique applicative languages 
software practice experience 

