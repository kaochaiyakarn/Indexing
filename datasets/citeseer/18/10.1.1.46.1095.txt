perfect trees bit reversal permutations march ralf hinze institut fur informatik iii universitat bonn bonn germany mail ralf informatik uni bonn de famous algorithm fast fourier transform fft 
efficient iterative version fft algorithm performs step bit reversal permutation input list 
bit reversal permutation swaps elements indices binary representations reverse 
amortized approach operation run linear time random access machine 
intriguing question linear time implementation feasible pointer machine purely functional setting 
show answer question affirmative 
deriving solution employ advanced programming language concepts nested datatypes associated fold unfold operators rank types polymorphic recursion 
bit reversal permutation operates lists length natural number swaps elements indices binary representations reverse 
bit reversal permutation list length instance brp case elements positions elements positions swapped 
formally may define brp unique function satisfies delta brp rev gamma 
function denotes list indexing rev computes bit reversal natural number 
assuming list indexing takes constant time function rev runs theta time straightforward implement brp takes theta nk time permute list length extra cleverness necessary brp run linear time see cormen problem 
question brp implemented run linear time assuming constant time indexing function 
straightforward design implementation takes theta nk time 
main idea hinze fig 

bit reversal permutation list 
represent input list perfectly balanced binary leaf tree tree list indexing 
rest pearl show develop idea linear time implementation 
start assume length input list fixed known advance 
algorithmic part solution developed assumption 
algorithmic details settled discuss extensions necessary program inputs unknown length 
perfect trees section introduces perfectly balanced binary leaf trees perfect trees short recursion operators folding unfolding 
represent perfect trees employ simplest scheme conceivable pairs pairs 
elements 
formally perfect tree rank element delta delta type delta theta defined 
members deltaa called nodes 
tree depicted fig 
instance represented term type delta int manipulate trees frequent mapping function nodes defined delta 
delta delta delta common practice name type constructor corresponding map functions 
accordingly mapping function perfect trees rank delta 
combination type constructor mapping function referred functor 
mapping function satisfies called functor laws prove useful calculations follow 
delta id id delta delta delta delta delta build flatten perfect trees employ variants recursion schemes widely known cata anamorphisms meijer 
catamorphism delta denoted takes function type deltaa replaces node perfect trees bit reversal permutations fig 

constructing bit reversal permutation 
input function 
delta 
delta id delta delta recursion operator indexed rank input speak ranked catamorphism 
converse ranked catamorphism ranked anamorphism denoted takes function type deltaa builds perfect tree seed type delta 
delta id delta delta ranked cata anamorphisms satisfy variety properties 
laws 
delta delta delta delta gamma delta gamma delta delta delta delta id delta id delta id delta id laws show ranked cata anamorphisms expressed compositions mapping functions 
third fourth law state ranked cata anamorphisms inverse base functions 
recursive solutions recall main idea implementing brp sketched input list transformed perfect tree repeatedly indexed build bit reversal permutation 
alternative approach avoids indexing operation works building perfect tree flattening list 
second phase elements shuffled order obtain desired bit reversal permutation 
fig 
illustrates build perfect tree bit reversal permutation input list frontier 
building perfect tree probably matter routine input list split equal halves trees built recursively halve results hinze combined 
follows assume input list length essentially methods splitting list length equal halves 
called halve partitions list significant bit indices second called divide significant bit 
halve gamma gamma gamma divide functions natural inverses termed cat interleave cat delta halve id interleave delta divide id consider lists length dual properties halve delta cat id divide delta interleave id hold 
building halve divide obtain functions constructing perfect tree rank build builds tree input list frontier second shuffle builds tree bit reversal permutation frontier 
build shuffle delta build delta unwrap delta halve shuffle delta unwrap delta divide function unwrap unwrap require converse wrap accordingly defined wrap 
aside note trees generated build shuffle may considered radix trees build represents finite map 
shuffle represents 
rev build shuffle easily derive functions flattening tree 
derivation build inverse proceeds follows 
flatten delta build id definition build flatten delta delta unwrap delta halve id cat delta halve id flatten delta delta unwrap cat delta functor wrap delta unwrap id flatten cat delta delta wrap derivation shuffle inverse proceeds completely analogous 
summarize flatten delta flatten cat delta delta wrap interleave delta delta wrap composing shuffle flatten build obtain theta nk time implementations brp brp cat delta divide interleave delta halve proof brp satisfies specification left exercise reader 
note cata anamorphisms take theta nk time 
known perfect trees bit reversal permutations running time build improved theta technique called accumulation bird 
dual technique termed tupling may improve complexity flatten gain constant factor shuffle amenable techniques 
key linear time implementation brp build flatten perfect trees iteratively 
iterative solutions introducing iterative versions single big eureka step try possible derive recursive functions defined previous section 
flattening tree simpler building start improving flatten colleague shuffle try express flatten terms flatten flatten step delta flatten entirely obvious approach works 
works iterative variant flatten step delta wrap note flatten wrap 
function step type deltaa transforms list pairs elements list elements 
moment reflection reveals step takes list 
defined interleave delta unzip unzip unzip delta delta unzip sequel require unzip inverse denoted zip reason defining step terms unzip simply symmetry flatten explicit see 
crucial property step interleave delta unzip distributes cat step delta cat cat delta delta step step delta cat cat delta delta step prove reason flatten definition flatten cat delta delta wrap cat delta delta cat delta delta wrap delta functor cat delta delta cat delta delta wrap cat delta delta wrap step delta wrap cat delta delta step delta wrap hinze delta functor cat delta delta step delta delta wrap step delta cat delta delta wrap definition flatten step delta flatten derivation proceeds completely analogous 
suffices fact interchange roles cat interleave summarize flatten interleave delta unzip delta wrap cat delta unzip delta wrap equations trivial derive iterative definitions build shuffle get build unwrap delta zip delta divide shuffle unwrap delta zip delta halve zip delta divide zip delta halve take time proportional size input list 
length list halved step total running time gamma delta delta delta theta 
putting things obtain linear time implementations brp brp interleave delta unzip delta zip delta halve cat delta unzip delta zip delta divide haskell program assumed length input list fixed known advance 
get rid assumption 
concreteness final program functional programming language haskell peyton jones editor 
main reason choosing haskell require fairly advanced type system 
seek suitable datatype representing perfect trees 
type encompass perfect trees arbitrary rank fact looking representation delta delta delta delta delta delta 
denotes disjoint sum raised level functors recall 
alternatively may define id delta id identity functor id delta denotes functor composition delta 
fact functor composition distributes leftward sums delta delta delta obtain delta delta delta delta delta delta id delta delta delta delta delta delta delta delta replacing delta delta delta delta delta delta unknown arrive fixpoint equation perfect trees 
perfect id perfect delta delta perfect trees bit reversal permutations rewriting functor equation applicative style introducing constructor names yields desired haskell datatype definition 
data perfect zero succ perfect delta definition somewhat unusual recursive component perfect delta identical left hand side equation 
type recursion nested datatype definitions property called nested datatypes bird meertens 
abbreviating constructor names letter tree fig 
represented term 
note prefix encodes tree rank unary representation 
interesting contrast perfect usual definition binary leaf trees matter fact corresponds fixpoint equation 
bush id delta delta bush clearly bush identical perfect formal reason functor composition distribute rightward sums 
general delta delta delta haskell datatype corresponding functor equation 
data bush leaf fork delta bush encoded element bush int tree fig 
reads comparing expressions fairly obvious representation concise second 
estimate space usage ary constructor cells perfect tree rank consumes gamma cells gamma second representation 
difference 
haskell non strict language bush comprises finite partial infinite trees 
contrast perfect accommodates finite trees 
fact nested datatype space economical lead conclude perfect datatype choice perfectly balanced trees required 
tackle question define recursion schemes folding unfolding perfect trees 
presentation largely follows approach taken meijer hutton shall see higher level abstraction 
recast recursive type definitions fixed points called base functors 
assume occupies cells 
course perfect contains partial elements succ infinite element succ elements hardly qualify trees 
hinze base functor corresponding perfect data base perfect zero succ perfect delta base functor obtained replacing recursive occurrence perfect type variable 
type perfect defined fixpoint functor 
newtype perfect base perfect constructor inverse establish isomorphism functors perfect base perfect note base really functor higher order functor takes type constructors type constructors functors functors 
associated mapping function unusual takes polymorphic functions type polymorphic functions type base base base 
base base base zero succ delta zero succ note parameter applied function type delta delta explains polymorphic 
type base called rank type mccracken legal haskell 
suitable extension implemented ghc peyton jones hugs jones accept definition change type signature base base definition cata anamorphisms entirely straightforward types 
base 
perfect delta base delta base 
perfect delta base delta map polymorphic functions polymorphic functions 
catamorphisms perfect trees usually take form delta abbreviate 
anamorphisms typically written zero delta succ delta bool delta 
expression mccarthy conditional form better readability abbreviate unwieldy zero delta succ delta 
utterly part 
flatten perfect tree type perfect 
catamorphism takes tree form 
immediate expression realizes simple loop leads suspect merely adapt iterative variant flatten inspecting perfect trees bit reversal permutations types deltaa confirms suspicion 
flatten perfect flatten wrap interleave delta unzip wrap cat delta unzip loosely speaking perfect captures recursion scheme iterative tree algorithms 
building perfect tree course done iteratively 
build shuffle perfect build single unwrap zip delta halve shuffle single unwrap zip delta divide function single tests list singleton defined single null null tail 
bit reversal permutation defined composition ana catamorphism 
question naturally arises possible remove intermediate data structure build anamorphism consumed catamorphism 
see obtain little calculation 
setting delta argue specification delta definition def 
delta base delta delta delta base delta delta delta delta id base functor specification delta base delta delta delta delta delta delta 
delta base delta delta delta base delta delta definition base delta delta delta delta delta express delta fixed point recursion equation delta delta delta 
interesting take closer look typing assuming types ingredient functions bool delta delta infer type recursive call type deltaa deltaa 
th level recursion type delta delta 
means called polymorphically recursive function mycroft 
noted hindley milner type system underlies today functional programming languages allow polymorphic recursion 
furthermore hinze suitable extension type system shown undecidable henglein 
haskell allows polymorphic recursion explicit type signature provided respective function 
applying fusion law flatten delta shuffle obtain surprisingly concise implementation bit reversal permutation 
brp brp single id cat delta unzip delta brp delta zip delta divide note brp accepts arbitrary non empty lists 
blog nc elements input list 
remaining elements discarded invocations zip final remarks nested datatype perfect nicely incorporates structural properties perfectly balanced binary leaf trees 
definition essentially proceeds bottom perfect tree rank defined perfect tree rank containing pairs elements 
consequently recursion operators folding unfolding perfect trees capture iterative algorithms 
contrast regular datatype bush proceeds top manner associated recursion operators capture recursive algorithms 
unsurprisingly function perfect trees expressed iteration 
reason generalization fold operator proposed bird paterson allows implement iterative recursive algorithms mixtures styles 
bit reversal permutation defined lists length construction binary leaf trees sense lists arbitrary length 
general case recursive iterative versions build shuffle yield differently shaped trees 
recursive version constructs braun tree braun rem characterized balance condition node fork satisfies size size size 
iterative version yields leftist left complete tree offsprings nodes right spine form sequence perfect trees decreasing height 
algorithms mentioned bird 
techniques constructing leaf trees closely related top bottom versions merge sort paulson 
fact different merge sort implementations may obtained fusing build wrap merge standard catamorphism bush interestingly input provokes worst case respective merge sort constructed applying flatten delta shuffle ordered list 
permutation effect application merge interleave argument lists 
bird richard 

functional programming haskell 
nd edn 
london prentice hall europe 
bird richard meertens lambert 

nested datatypes 
pages jeuring perfect trees bit reversal permutations ed fourth international conference mathematics program construction mpc sweden 
lecture notes computer science vol 

springer verlag 
bird richard paterson ross 

generalised folds nested datatypes 
submitted publication 
bird richard 

functional pearls building trees minimum height 
journal functional programming 
braun rem 

logarithmic implementation flexible arrays 
memorandum eindhoven university technology 
victor anne 

simple efficient flexible implementation flexible arrays 
pages third international conference mathematics program construction mpc 
lecture notes computer science vol 

springer verlag 
henglein fritz 

type inference polymorphic recursion 
acm transactions programming languages systems 
jones mark 

technical summary new features hugs 
unpublished 
mccracken nancy jean 

typechecking programs implicit type structure 
pages kahn gilles macqueen david plotkin gordon 
eds semantics data types international symposium sophia antipolis france 
lecture notes computer science vol 

berlin springer verlag 
meijer fokkinga paterson 

functional programming bananas lenses envelopes barbed wire 
pages th acm conference functional programming languages computer architecture cambridge ma 
lecture notes computer science vol 

springer verlag 
meijer erik hutton graham 

bananas space extending fold unfold exponential types 
pages conf 
record th acm sigplan sigarch ifip wg intl 
conf 
functional programming languages computer architecture fpca la jolla san diego ca usa 
acm press 
mycroft alan 

polymorphic type schemes recursive definitions 
paul robinet 
eds international symposium programming th colloquium toulouse 
lncs 
paulson 

ml working programmer 
nd edn 
cambridge university press 
peyton jones simon 

explicit quantification haskell 
research microsoft com users simonpj haskell quantification 
peyton jones editor simon hughes editor john augustsson lennart barton dave boutel brian burton warren fraser simon fasel joseph hammond kevin hinze ralf hudak paul johnsson thomas jones mark launchbury john meijer erik peterson john reid alastair runciman colin wadler philip 
december 
haskell non strict purely functional language 
