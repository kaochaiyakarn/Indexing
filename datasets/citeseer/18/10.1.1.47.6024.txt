ecl ps platform constraint logic programming mark wallace stefano joachim contact address ic parc william laboratory imperial college london sw az 
email doc ic ac uk august introduces constraint logic programming clp platform ecl ps ecl ps designed implementation clp supports mathematical programming stochastic programming techniques 
crucial advantage ecl ps enables programmer combination algorithms appropriate application hand 
benefit results ecl ps facility support fine grained 
ecl ps designed solving difficult combinatorial industrial problems areas planning scheduling resource allocation 
platform offers conceptual modelling language specifying problem clearly simply way neutral algorithm solve 
conceptual model easy construct alternative design models expressed ecl ps design model runnable program execution ecl ps employs specific combination algorithms 
platform supports experimentation different hybrid algorithms 
technically different classes algorithms mentioned aspects constraint handling search 
various different constraint handling facilities available ecl ps libraries 
include finite domain propagation interval propagation linear constraint solving 
ecl ps constraint treated concurrently different handlers 
regard search behaviour clp mathematical programming typically impose new constraints lower levels search tree 
contrast stochastic techniques search solutions locally repairing original solution repeating process 
ecl ps supports kinds search allows combined hybrid search techniques 
ecl ps philosophy generation constraint programming languages focussed single technique constraint propagation described section wal 
whilst constraint propagation proved variety applications suffice efficiently produce solutions typical practical industrial problems 
years operations researchers designed highly efficient algorithms classes problems set partitioning matching knapsack network flow problems techniques mixed integer programming mip 
stochastic techniques simulated annealing achieved striking results optimisation problems travelling salesman problem 
ecl ps designed take advantage results supporting industrial scale mip functionality stochastic techniques constraint propagation solving 
travelling salesman problem find shortest route starts certain point visits set destinations customers returns starting point 
importantly real industrial problems seldom fit specific class pure travelling salesman problem rarely comes real life typically salesmen available cover different customers certain customers visited certain times day roads certain times day journey time may vary time day anyway poor salesmen need time rest usually complete circuits 
side constraints may belong problem class class set covering problems scheduling problems 
industrial problems typically constraints belong different problem classes sense hybrid 
accordingly necessary offer wide choice algorithms solving problems facility mix match algorithms build hybrid algorithms 
ecl ps designed support fast development specific hybrid algorithms tuned problem hand 
assumed algorithm implemented application developer guaranteed best ecl ps provides platform supporting experimentation different hybrid algorithms appropriate suits particular features application 
section shall explore ecl ps problem modelling language 
distinguish kinds model conceptual model captures problem specification design model tuned efficient solving computer 
ecl ps designed support kinds models mapping 
sections shall examine ecl ps facilities handling constraints 
wal encountered different kinds constraints primitive constraints propagation constraints constraint agents 
ecl ps supports various classes built constraints primitive constraints propagation constraints 
ecl ps allows complex constraints constraint behaviours constructed built classes supporting constraint agents 
constraint handling return second major aspect problem solving search solutions 
separate discussion subsections 
concerned constructive search second repair search 
constructive search explores consequences making choices decision variables time 
choice reduces set viable choices remaining decisions 
contrast repair search explores consequences making decisions changing 
case new choice typically compared previous context suggested choices decision variables 
initially expected suggested choices necessarily consistent constraints 
idea changing choices reduce number constraint violations constraints satisfied 
brief section ecl ps system external communication facilities embeddability documentation obtain system 
ecl ps modelling language overview ecl ps modelling language ecl ps tailored solving combinatorial problems 
problems characterised set decisions decision set alternative choices set constraints decisions certain choice decision may preclude entail certain choices decisions 
ecl ps decision modelled variable choice possible value variable 
constraints modelled relations variables 
example consider map colouring program countries colour 
program illustrate constraint logic programming wal 
ecl ps constraint logic programming language uses syntax prolog 
hopefully syntax familiar readers 
time hope readers suffered limitations prolog conclude ecl ps suffers limitations 
problem involves decisions country 
modelled variables countries just name list variables 
lib 
coloured countries countries value countries ne ne ne ne ne ne 
value red 
value green 
value blue 
generic logic program map colouring decision variable problem set choices modelled possible values variables red green blue 
constraints modelled relation ne meaning equal 
command lib 
loads ecl ps library 
functionality ecl ps held different libraries introduced section 
library apply macros holds definition predicate applies predicate element list 
value countries equivalent value value value value 
logic programming requirements ecl ps kinds enable problems modelled simply naturally enable resulting problem model solved efficiently 
separation modelling solving supported ecl ps distinguishing conceptual model expressed pure logical ecl ps program design model constructed conceptual model adding control ecl ps program 
combination requirements difficult satisfy impossible completely general modelling language required suitable kind application 
applications ecl ps designed decision support applications involving combinatorial problems 
logic programming apt modelling problems kind reasons 
ffl relations ffl supports logical variables combinatorial problem naturally modelled set variables set constraints relations variables facilities logic programming precisely match requirements modelling combinatorial problems 
predicate logic program defines relation explicitly set facts implicitly terms rules 
recall example wal 
predicate meat defined facts meat beef 
meat 
whilst predicate main meaning main course defined rules main meat 
main fish 
variables logic programming logical variables 
entirely natural initialise problem variables example writing countries constrain example writing ne 
briefly compare ecl ps modelling language formal specification languages mathematical modelling languages mainstream programming languages object oriented languages 
formal specification languages formal specification language designed formality execution 
consequently include constructs universal quantification precisely defined constructive 
words constructs mapped practical algorithm 
luckily class problems ecl ps designed finite set decision variables admits finitely alternatives 
consequently necessary support restricted form logic easier understand easier implement 
nearest thing ecl ps offers universal quantification iteration finite sets example goal value countries 
restricted logic ecl ps benefit mapping conceptual model problem design model extension conceptual model rewriting 
means problem requirements change natural capture change conceptual model carry design model 
result application development conceptual model design model remain step 
avoids pitfalls await developers working applications specifications changing application development 
mathematical modelling languages exists class modelling languages designed combinatorial problems 
mathematical modelling languages typically input mixed integer programming mip packages 
discuss mip ecl ps section 
syntax different mathematical modelling languages share features logic programming 
support logical variables constraints 
support numerical constraints supported traditional logic programs supported constraint logic programs shall see section 
support named constraints achieved constraint logic programming introducing predicate name precede 
facilities constraint logic programming available mathematical modelling languages 
main quite simple constraint logic programs possible define constraint involves disjunction 
mathematical programming handle disjunction directly 
second difference logic programming allows new constraints defined terms existing ones recursively 
mathematical programming model essentially flat complicates model reduces application applications 
illustrate advantage handling disjunction modelling language take toy example models mathematical programming model constraint logic programming model 
consider constraint tasks sharing single resource done time 
constraint involves variables start times times resources tasks 
specification constraint follows tasks distinct resource ne task ends task starts task ends task starts 
shall show expressed mathematical model disjunctions 
purpose encoded numerical equations inequalities integer constraints 
disjunctions captured introducing variables br br large constant say larger possible values variables 
express constraint terms numerical inequalities follows br br br gamma br gamma br gamma br gamma technically called horn clauses br tasks different resources 
case br br 
exercise reader prove br tasks overlap 
br entails entails ecl ps constraint modelled directly logic illustrated 
ne 


specifying resource contention constraint ecl ps note ecl ps model conceptual model whilst mathematical model design model 
point ecl ps models expressed whilst mathematical modelling express design model 
shall show section design model written ecl ps close conceptual model 
ecl ps design model close conceptual model handled ecl ps automatic translator builds mip model passes mip solver ecl ps translator described available ic parc home page url section 
whilst example shows complex constraints expressed terms numerical inequalities required mip encoding awkward difficult debug 
increasingly difficult constraints complex current example immediately harder resources finite capacity greater 
notice mathematical model requires resources identified numbers whilst constraint logic programming model imposes restriction shall show section 
mainstream programming languages naturally implemented solution industrial problem delivered industrial computing environment 
argued possible solution implemented mainstream programming language java 
arguments supporting view firstly embeddability easier efficient pass data control modules written programming language secondly system support mainstream language programmers easier find replace specialist programmers 
whilst argument supports mainstream programming language implementation conceptual modelling consequence modelling language assumption discussed conceptual model close design model 
design model encoded mainstream programming language conceptual model compromised design model gap conceptual model design model grows wide 
sadly attempt tackle combinatorial problems mainstream programming languages implemented solution proved solve actual industrial requirement requirements change application development solution modified meet actual new requirements reasonable cost timescale 
core combinatorial optimisation problem best solved specialised programming platform mathematical constraint problem embedding solved 
approach embed constraint solving mainstream programming language 
shall see section search constraint handling closely interdependent 
search encoded mainstream programming language programmer required understand detail data structures constraint handlers operational behaviour 
practice packages providing embedding constraints mainstream programming languages encapsulate search package 
application developer required control search 
avoid mismatch host programming language search control package popular approach implement package library host programming language 
result separation conceptual modelling design modelling favour staying confines expressive capabilities host programming language 
approach requires specialist programmers develop support application sacrifices modelling advantages mathematical constraint logic programming 
fact problem embedding overcome generation constraint logic programming languages deficient area 
ecl ps fully embeddable uses external solver written handle linear constraints runtime cost interface perfectly acceptable tightly integrated component constraint handler 
object oriented languages ecl ps supports object orientation distinct features modules structures 
modules support behavioural object orientation structures support structural object orientation 
nature combinatorial problems requirement behavioural object orientation constraint handlers 
implementation constraints library hidden inside module access internal data structures predicates exported module 
remaining objects occur ecl ps model attributes behaviour require structural object orientation 
example modelled map colouring problem variables constraints 
argued complex applications conceptual model benefit notion object variables built 
example modelling resource scheduling problem notion task certain attributes useful 
task identifier start time time duration 
declaring structures tasks times programmer access attributes independently 
eclipse lib structures 
structures loaded eclipse task id start duration time hour minute 

eclipse task id duration 
task 
eclipse task id start time hour task id start time hour 
task time task time 
defining task structure ecl ps prompt eclipse followed user query lib structures 
rest article query refers query preceded prompt eclipse 
programmer enters lib structures 
system responds structures loaded 
added star line showing system response 
query defines attributes objects classes task time 
query shows user equate variable structured object variable instantiated structure 
ecl ps automatically constructs unknown values written unspecified attributes 
query illustrates expressive power needed constraint programming language supports objects 
objects share attribute value shared subobject non shared subobjects attributes connected constraint 
constraint distinct objects typically expressible traditional object oriented framework 
conceptual model design model main benefit constraint logic programming platforms solving combinatorial problems closeness conceptual model design model 
ecl ps takes full advantage offering facilities choose different annotations conceptual model achieve design models whilst syntactically similar radically different behaviour 
map colouring start mapping conceptual model map colouring example illustrated design model uses finite domain constraint handler ecl ps design model encoded shown 
lib fd 
coloured countries countries countries red green blue ne ne ne ne ne ne labeling countries 
ne finite domain clp program map colouring design model extends conceptual model ways 

ecl ps finite domain library loaded lib fd 

explicit finite domain associated decision variable countries red green blue 

finite domain built disequality constraint implement ne constraint ne 
special syntax disequality finite domain constraint solver 

program includes search algorithm invoked goal labeling countries 
shall see predicate tries choosing variables turn value domain 
succeeds combination values satisfies constraints 
naturally toy example easy turn conceptual model ecl ps program design model program 
constraint logic programming particular ecl ps lot progress achieving close relationship conceptual model design model 
different components ecl ps system support separate development clear correct conceptual model efficient design model support mapping 
having change pocket take interesting problem set challenge mip community 
problem apparently simple minimum number coins purchaser needs pocket order able buy item costing pound guarantee able pay exact amount 
problem involves decision variables number coins denomination held pocket denominations 
conceptual model problem shown 
lib 
solve min tw fv te ff range min min tw fv te ff minimize min 
total coins tw fv te ff range coins total tw fv te ff maplist coins 
conceptual model coins problem lines numbered syntax comment symbol ecl ps describe program line line 

variable just shorthand list variables tw fv te ff denote number coins denomination held pocket 

list ecl ps allows lists written alternative syntax head tail 
min simply way writing list variables min tw fv te ff 
command range min associates range variables 

min total number coins pocket enforced equation min tw fv te ff 

ensure coins total impose constraints total 
total called value otal 

minimize min simply specifies best feasible solution problem minimises value variable min 

total initialises set coins tw fv te ff needed total otal 

set coins initialised range 
total value constrained equal otal 
constraint enforced equation total tw fv te ff 

constraint required coins denomination equal number coins denomination pocket enforced constraints tw tw fv fv te te ff ff 
constraints generated single command maplist coins start trying mixed integer programming problem 
add integer declarations integer variables change constraints syntax recognised external mip solver accessed ecl ps library eplex 
equations syntax inequalities 
design model shown 
lib 
lib eplex 
solve cost tw fv te ff range min min tw fv te ff optimize min min cost 
total coins tw fv te ff range coins total tw fv te ff maplist coins 
range min max var integers var var min var 
max 
conceptual model coins problem program passes constraints cplex mixed integer programming package cpl invokes cplex branch bound solver minimise value variable min 
minimum placed variable cost 
model solve problem producing exact change replacing program 
full problem system runs memory 
standard mip solutions problem run overnight tough challenge reduce time hours minutes 
illustrate ecl ps program solving coins problem facilities ecl ps finite domain constraint solver implemented ecl ps library fd 
case constraints optimisation predicate minimize implemented ecl ps finite domain library 
program proves seconds minimum number coins purchaser needs pocket total coins 
solution tw fv te ff 
shown underlying model coins problem passed different solvers best 
ecl ps choice constraints easily passed solvers time 
instance define replace model treat similarly 
whilst problem finite domain solver solves problem efficiently encountered practical examples combination solvers outperforms 
lib 
lib fd 
solve min tw fv te ff range min min tw fv te ff minimize labeling min 
total coins tw fv te ff range coins total tw fv te ff maplist coins 
range min max var var min max fd constraints coins problem solvers syntax ecl ps offers different libraries handling symbolic numeric constraints 
fd finite domain library range library ria real number interval library eplex mip library 
fd finite domain library finite domain library refined year period 
result great constraint handling facilities 
best seen libraries 
library handling symbolic finite domains values red machine built constraints symbolic finite domain variables equations disequalities constraints hold expressions constants variables 
constraints domains numeric 
second library handling integer variables numerical constraints variables 
library propagates equations inequalities linear expressions 
linear numeric expression written form term term term turn written number number 
number positive negative 
example expression gamma normally write gamma 
third library supporting built complex constraints 
examples constraints constraint constraints set variables take values pairwise distinct atmost constraint constrains variables set take certain value 
fd symbolic finite domain facilities figures showed map colouring problem solution 
domains associated countries red green blue 
declared finite domains usual syntax red green blue 
problem modelled numbers represent colours extra power allowing symbolic finite domains numeric ones 
developing ecl ps programs real problems great help meaningful names distinguish different types finite domain variables 
particular crucial debugging 
illustrates basic constraints finite domain variables predicates accessing searching domains 
second query associates symbolic finite domain variable response ecl ps prints variable name newly assigned domain 
fact variable associated domain require changes parts program may treated ordinary variable 
query shows symbolic domains include values different types 
query shows dom predicate retrieve domain associated variable 
queries illustrate equality disequality constraints effects domains variables involved 
finite domain constraints special syntax explicit constraint library handle constraint example uses 
queries illustrate search 
strictly expect search predicates belong constraint library fact search constraint propagation closely connected 
query shows indomain predicate instantiating domain variable value domain 
ecl ps asks answers required user ask value domain chosen instantiated value 
user asks instantiated third value domain time ecl ps doesn offer user choices simply outputs 
query illustrates built finite domain labeling predicate 
predicate simply invokes indomain variable turn argument 
case calls indomain variables constrained take different values disequality constraints labelings satisfy constraints admitted 
consequently query different answers user stops asking second answer 
query illustrates heuristic fail principle 
choosing decision solving problem best choice fewest alternatives 
predicate selects variable set variables fewest alternatives smallest finite domain 
example variables representing decisions picks smallest domain indomain selects value third argument output argument rest returns remaining variables selected removed 
decisions 
fd integer arithmetic facilities numeric finite domains fd library admits equations inequalities disequalities numeric expressions 
additionally fd library includes built optimisation predicates 
illustrated 
query illustrates numeric finite domain initialised just giving lower upper bounds list members 
fact internally finite domains stored lists intervals example 
query shows user find lower bound variable numeric finite domain 
similar predicate retrieving upper bound 
queries illustrate features finite domain constraint propagation 
query shows pruning achieved simple numerical finite domain constraint 
notice domains pruned constraints directions 
query illustrates finite domain constraint remains active achieved pruning 
query query extra constraint imposed subsequently 
constraint active prunes domain 
query shows interest computational efficiency mathematical constraints narrow bounds finite domains 
example domain theoretically reduced require computation especially finite domains quite large 
eclipse lib fd 
fd loaded eclipse 

eclipse 

eclipse dom list 
list 
eclipse 
eclipse 
eclipse indomain 



eclipse labeling 



eclipse var rest indomain var 
rest var 

symbolic finite domains eclipse lib fd 
fd loaded eclipse 

eclipse min 
min 
eclipse 

eclipse 

eclipse 

eclipse min 
min 
eclipse minimize labeling 
solution cost 
numeric finite domains query example built minimize predicate 
predicate returns admissible labeling variables yields smallest value general search procedure substituted labeling argument minimize 
example minimize indomain indomain indomain 
fd complex constraints motivations supporting complex constraints 
simplify problem modelling 
shorter natural single constraint variables gamma pairwise disequalities 
second motivation achieve specialised constraint propagation behaviour 
constraint variables semantics gamma pairwise disequalities achieve better propagation possible disequalities 
example variables domain size constraint immediately fail 
variables domain elements constraint achieve propagation 
pairwise disequalities unable achieve propagation constraint 
constraint atmost number list constrains atmost number variables list list take value difficult constraint express logic 
way constrain sublist length number contain variable value different resulting number constraints large 
natural way constrain variables take value different allow constraint violated times 
fd library supports facility constraint 
constraint 
possible express atmost imposing constraint ar variable ar list adding constraint bm built atmost constraint essentially implemented 
fd constraints extended extra variable way 
fd library includes great variety facilities best explored obtaining ecl ps extensions manual looking programming examples section fd library 
range library range library little provides common basis interval mip libraries 
contrast finite domain library range library admits ranges lower upper bound real numbers integers 
library enables programmer associate range variables illustrated 
eclipse lib range 
range loaded eclipse 


eclipse 

eclipse 
solution 
eclipse integers 


example queries range library query programmer enters system responds printing resulting range 
variable instantiated range checked compatibility shown queries 
treated type information programming paradigms treated constraint constraint programming paradigm 
add constraint integer middle program shown query 
ria real interval arithmetic library ria library supports numeric constraints may involve variables 
program execution ria continually narrows ranges associated variables far possible constraints 
words ria supports propagation intervals range library record current ranges detect inconsistencies 
constraints handled ria equations inequalities numerical expressions 
expressions quite complex include polynomials functions 
functionality quite similar offered fd fd propagate linear constraints 
hand finite domain library uses integer arithmetic real number arithmetic general efficient ria 
shall confine single example showing ria 
suppose wish build garden house corners lie circle 
house regular polygon may number sides 
large possible limitations 
note sides larger area covered covers practically circle 
extra side incurs fixed cost 
problem decide sides garden house 
sides house look illustrated 
rad garden house area house area triangle illustration 
area sided house modelled ecl ps shown 
number sides area area house 
variable rad denotes radius circle lengths sides triangle illustrated 
ria requires constraints written specific syntax just 
distinguishes ria constraints linear finite domain constraints special syntax 
payoff area number sides define cost house area gamma weighting factors chose reflect relative costs benefits area number sides 
model shown returns cost benefit sided house case radius circle weights 
place program file called house pl ecl ps find costs consulting file illustrated query 
queries indicate sided house best cost weightings 
interesting see interval reasoning system achieve useful propagation knowing number sides house 
show query 
intervals returned ria narrower reduced output significant figures 
lib ria 
area rad area integers rad area area 
pi sqr rad cos pi rad sqr sqr sqr rad area cost rad cost cost area rad area cost area cost cost cost 
area cost benefit garden house eclipse house 
range loaded house pl compiled 
eclipse 


eclipse 

eclipse 


eclipse 


eclipse 


eclipse 



eclipse squash lin 


finding optimal shape garden house upper bound number sides extracted due constraint positive propagation cost benefit weak 
cases propagation augmented technique known squashing illustrated query 
give short examples showing limitations interval reasoning general 
motivate linear constraint solver ecl ps described section 
limitations interval reasoning quite simple examples detect inconsistency constraints cases constraints solution interval reasoning fails reflect results propagation 
illustrated couple simple examples 
case system eclipse lib ria 
ria loaded eclipse 



eclipse 



poor interval propagation behaviour failed detect inconsistency query deduce value possible query 
answer incorrect ria guarantees possible answers lie intervals returned guarantee existence answer interval 
useful available powerful solver recognise cases 
eplex external cplex solver interface library equations inequalities linear numeric expressions defined section subset constraints handled ria 
class handled inconsistency constraints guaranteed detected 
techniques solving linear constraints heart operations research half century highly efficient linear solvers developed 
widely distributed scaleable efficient packages incorporating linear constraint solver cplex mip package cpl 
cplex offers algorithms solving linear constraints including simplex dual simplex algorithms 
algorithms supported sophisticated data structures package handle problems involving thousands linear constraints thousands variables 
discussion far mentioned important aspect industrial combinatorial problems 
required decisions satisfy constraints chosen optimise measure 
travelling salesman problem example decisions order visit cities optimising total distance travelled salesman 
feature available packages solving linear mixed integer problems support optimisation 
design model transportation problem uses eplex library pass constraints cplex package 
note fd uses ria uses eplex uses 
answer returned ecl ps lib eplex 
main cost vars transportation problem clients plants 
variables represent amount delivered plant client 
vars vars variables client demand constraints 
plant capacity constraints 

optimize min solve minimizing transportation costs cost 
design model transportation problem fact mip packages typically offer optimisation facility insist optimisation function design model 
illustrating examples ria performed badly eplex library shall insert dummy optimisation function 
eplex examples shown 
query set constraints inconsistency detected ria 
eplex recognises inconsistency 
order establish possible value queries finding minimum value maximum 
value returned solutions eplex library proved possible value problems involving real number continuous variables linear constraint solving suffices solve problem 
industrial problems typically include mixture real number integer variables 
example problems involving discrete resources decision resource task modelled continuous variable 
traditionally operational researchers binary variable integer variable 
resources discrete example machines jobs vehicles deliveries rooms meetings ships people projects 
fundamental discrete variables modelling decision order things example visiting cities travelling salesman problem performing tasks machine 
point view programmer adding constraint variable straightforward 
effect constraint performance solver disastrous mixed integer problems harder solve linear problems 
eplex library uses standard range variables provided range library facilitates interfacing solvers 
interface cplex enables state information retrieved constraint slacks basis information reduced costs 
para eclipse lib eplex 
eplex loaded eclipse 


opt optimize min opt cost 
solution 
eclipse optimize min cost 
cost 
eclipse optimize max cost 
cost 
linear constraint solving eclipse lib eplex 
eplex loaded eclipse optimize min 

eclipse integers optimize min 

mixed integer programming meters queried modified 
quite generic solver demon provided easy cplex data driven clp setting 
notion solver handles encourages experiments multiple solvers 
pair predicates possible read write problem files mps lp format 
mip packages cplex xpress currently integrated eplex package surprisingly effective problems involving discrete variables 
underlying linear solvers reflect carefully chosen balance flexibility 
offer flexibility linear solvers usually built constraint programming systems clp better 
proved possible ecl ps achieve flexibility clp restrictions imposed mip solvers 
complex constraints whilst constraint programming languages offer broad selection built constraints new industrial application typically requires number application specific constraints aren built constraints 
take ongoing example constraint tasks sharing single resource done time 
constraint introduced section 
constraint involves variables start times times resources tasks 
specification constraint follows tasks distinct resource ne task ends task starts task ends task starts 
shall compare different ways handling constraint 
recall encoded numerical equations inequalities integer constraints 
encoding necessary allow solved mip algorithms available eplex library 
mip package necessarily best algorithm handling constraint 
experience practical applications suggests variables necessary introduce handle constraint efficient mip 
inefficiency comes partly mip constraints handled globally cost handling extra constraints boolean variables increases fast number 
comes boolean variables take value close little effect search 
contrast shall show handled libraries ecl ps library chr library 
libraries allow constraint modelled simply handled efficiently 
generalised propagation library major issue defining complex constraints handle disjunction 
resource constraint running example quite easily expressed disjunction finite domain constraints 
ecl ps allows express disjunction alternative clauses defining predicate constraint expressed single ecl ps predicate 


purpose library take exactly disjunctive definitions turn constraints 
illustrated 
syntax goal infers turns ecl ps goal simplex dual simplex algorithms cost goes worst case exponentially number constraints variables 
technically rarely facet inducing cuts 
lib 
infers 



specifying resource contention constraint ecl ps constraint 
supported library 
behaviour constraint find values variable consistent constraint 
constraint propagation behaviour described wal repeatedly attempts reduce domains variables time constraints reduce domains 
shows examples behaviour 
query constraint deduces tasks overlap task start task start 
query tasks bound overlap constraint deduces task resource eclipse 
loaded pl compiled 

eclipse 

eclipse 

behaviour goal infers behaviour achieved writing goal infers consistent goal infers ground 
behaviours facilities library described ecl ps extensions manual 
chr constraint handling rules library ecl ps programmer little control behaviour complex predicates library 
example query illustrated constraint detects holes inside domains variables 
experience solving scheduling problems suggests computational effort expended detecting holes rarely compensated reduction amount search necessary find solutions 
whilst propagation powerful alternatives available library weak 
useful behaviour constraint conditions hold ffl tasks guaranteed overlap constrain distinct resources ffl tasks resource tasks precede constrain task start task ended 
notice unfortunately behaviour achieved mip encoding 
behaviour expressed ecl ps constraint handling rules chr library 
required ecl ps encoding remains quite logical needs new concept guard 
rule guard executed guard entailed 
data driven implementation guarded rules uses mechanisms data driven implementation constraints discussed section 
syntax guarded rules different syntax ecl ps clauses encountered far 
syntax illustrated encoding constraint 
example constraint handling rules finite domain constraints definitions 

constraints 










constraint handling rules task resources constraint logically rules states constraint 
rule uses different statement 
example rule says 
order constraint handling rules necessary translate underlying ecl ps language automatic translator 
constraints written file called file chr example shall chr 
illustrate loading constraint handling rules give example queries 
query yields propagation implementation punch holes variables domains 
query produce new information tasks resource constraint means task precede task constraint deduces latest start time earliest start time coincidence 
query uses fact tasks overlap remove domain 
chr library offers facilities including multi headed rules augmentation rules 
facilities explored detail studying relevant chapter trying example constraint handling rule programs distributed ecl ps eclipse lib chr lib fd 
chr loaded fd loaded eclipse chr 
chr compiled 

eclipse 

eclipse 

eclipse 

behaviour explicit data driven control chr libraries implemented set underlying facilities ecl ps support data driven computation 
main feature supporting data driven computation suspension 
illustrated 
eclipse lib fd 
fd loaded eclipse suspend writeln wake inst writeln 
wake 

eclipse suspend writeln wake inst goal call goal 
wake 

eclipse suspend writeln wake min wake 

handling suspensions suspension goal waits executed certain event occurs 
suspension associated set variables soon relevant event occurs variables set suspension wakes goal activated 
event instantiation suspensions variable wake variable instantiated 
query loads fd library example 
preferable load libraries may needed start session 
query suspends goal writeln wake variable goal executed soon instantiated inst 
woken goal scheduled certain priority 
priority second argument suspend 
case priority highest priority 
remainder query performs write statement instantiates output ecl ps shows suspended goal executed instantiated system output 
query shows various facilities explicitly handling suspension 
current suspensions accessed 
possible access just suspensions particular variable 
suspension converted goal 
suspension killed longer accessible 
suspension connection goal executed 
save space output variable values omitted 
query illustrates kind event wake suspended goal 
case goal suspended lower bound finite domain associated variable denotes module writeln defined 
tightened min 
events wake suspended goals associated constraint handlers general event variable constrained way expressed constrained 
goals suspended way wake new constraint added fd constraint ria constraint eplex constraint 
possible retrieve goals suspended variable associated event variable 
simple idea possible define constraint behaviour explicitly 
simple example constraint variable differ input number call constraint difference variables 
behaviour tighten finite domains variables 
lib fd 
suspend 
xmin ymax ymax xmin ymin xmax xmax ymin suspend 

suspensions implement constraints implement behaviour constraint 
underlying fd constraints load fd library 
clause checks lower bound close upper bound satisfy constraint need 
case imposes constraint second clause symmetrical test lower bound upper bound conditions satisfied doesn 
just suspends finite domains tightened gamma 
mechanism suspended goals implement built constraints ecl ps example constraint implemented goal suspended events change maximum domain change minimum domain typically finite domain built constraints suspended events occur finite domains variables 
concluding subsection observe different constraint libraries ecl ps supported flexible facility 
information kind constraint variable held data structure attached variable called attribute 
fd library loaded variable ecl ps finite domain attribute 
variable finite domain attribute contains behaviour variable just attribute 
hand variable finite domain attribute stores finite domain pointers suspended goals waiting event occur finite domain 
fd library automatically loads suspend library necessary load suspend explicitly 
naturally ria constraints eplex constraints stored attributes suspended goals attached 
ecl ps user define implement completely new constraint handling library steps 

new attribute storing information new class constraints defined 

events specific class constraints specified 

new constraint behaviours implemented terms goals suspend events 
ecl ps extensions manual gives example defining new constraint library 
search constructive search branch bound preceding sections encountered optimisation procedures finite domain procedure minimize mip procedure optimize 
optimisation procedures implement algorithm called branch bound posts new constraint time finds solution cost solutions better cost current best solution 
eventually new constraint unsatisfiable algorithm proved optimum 
depth search backtracking encountered finite domain search procedure labeling successively instantiates list finite domain variables values domains 
ecl ps default search method depth search backtracking failure 
complete search methods available practice best search algorithms breadth component quickly grow occupy memory 
discuss incomplete search methods 
guesses constraints imposed search search course general just labelling 
certainly combinatorial problems involves making guesses may turn bad 
guess need involve guessing value variable done labelling 
example variable range guessing precise value may useful perform binary chop guessing guess turns bad guessing 
guess general sense posting new non redundant constraint narrows search space 
guarantee guess rule solutions problem system explore remainder search space backtracking 
typically done imposing negation constraint 
negation inequality strict inequality handled linear programming 
case integer variable integer negation gamma handled 
mip search finite domain propagation narrows domains guarantee detect inconsistencies 
guarantee partial labelling assigns consistent values variables extended complete consistent labelling 
linear constraint solver available eplex guarantee detect inconsistencies linear constraints 
hand linear solver take account constraint certain variables take integer values return proposed solutions non integer values proposed integer variables 
linear solver efficiently find optimal solution problem integrality constraints variables ignored 
optimum termed optimum continuous relaxation problem just relaxed optimum short 
suggests different search mechanism new constraint added exclude non integer value relaxed optimum returned linear constraint solver 
value integer variable relaxed optimum example new constraint added 
excludes feasible solutions new constraint guess turns bad guess alternative constraint posted 
search method mip optimize called eplex library 
search heuristics hybrid solvers mip search duplicated ecl ps passing linear constraints cplex proposed solutions decide new constraint impose guess 
whilst little point precisely duplicating mip search control ecl ps allows ecl ps programmer define new search techniques information fd library eplex 
example size finite domain recorded finite domain library choosing variable guess constraint 
value variable relaxed optimum returned eplex choosing value label 
search technique supported ecl ps library illustrated 
version indomain selects value closest value relaxed lib 

vars var vars rest indomain var rest 
solve cost minimize cost 
search library optimum returned eplex 
instructive watch search place ecl ps tracing facilities shall load program file called pl shall run shown 
query loaded automatically loads libraries needed 
query sets predicates 
time predicates called exit debugger stops allows programmer study state program execution 
query calls program defined 
labelling starts domains variables reduced finite domain propagation 
reduced domains automatically communicated range library passed linear solver 
linear solver cplex invoked eplex returned values variables relaxed optimum 
selects variable smallest domain indomain predicate labels integer value nearest value relaxed optimum 
wakes fd constraint handler domain wakes linear solver returns new relaxed optimum new suggested values variables 
eclipse 
fd loaded range loaded eplex loaded loaded 
eclipse spy spy indomain 
spypoint added 
spypoint added indomain 

eclipse solve 
call eplex range fd eplex range fd eplex range fd eplex range fd dbg leap call indomain eplex range fd dbg leap exit indomain dbg leap call eplex range fd eplex range fd eplex range fd dbg leap call indomain eplex range fd dbg leap exit indomain dbg leap call dbg debug solution cost 
tracing search time variable smallest domain selected instantiation 
instantiated integer value closest suggested value fd propagation immediately instantiates remaining values 
spy point user enters debug tracing switched 
optimal solution usefulness combined heuristic search 
incomplete constructive search real industrial applications search space usually large complete search possible 
branch bound search yields better solutions longer longer delays cases fails yield new solutions continues searching 
cases complete search impractical heuristics guiding search important 
bad heuristics chosen search may methodically explore unpromising corner search space yielding poor solutions fail drive branch bound search fruitful areas 
heuristics depend constraint handling information returned constraint handlers crucial enabling heuristics focus search promising regions 
choices propagation achieve better results supporting better heuristics choices 
positive feedback produces spiral 
received wisdom suggests local search techniques solution repair achieve faster convergence solutions constructive search 
industrial applications experience shown contrary 
heuristics tailored application hand proved effective yielding high quality solutions techniques solution repair 
intelligent backtracking nogood learning ecl ps offers facilities programmers define specific constructive search algorithms 
intelligent backtracking implemented ecl ps offered library practice reduction amount search due intelligent backtracking dominated cost accessing updating necessary data structures 
information constraints involved failure occurs search useful recording combinations variable values mutually inconsistent 
conflict sets impose extra constraints called nogoods learned search 
nogood learning ecl ps proving useful benchmark examples library supporting nogoods available 
describing rr available ic parc home page url section 
solution repair previous section suggested incomplete search constructive search heuristics outperform solution repair 
important examples job shop scheduling travelling salesman problems repair performs better constructive search 
repair important handling dynamic problems change initial solution 
problem may changed user unsatisfied solution reasons captured implementation adds new constraints exclude solution 
change may due external circumstances unplanned delays rush orders cancellations 
ecl ps uses concept tentative value support solution repair 
concept return proposed values variables linear solver discussed preceding section 
case repair tentative value comes constraint handler original solution original problem 
problem changes tentative values may longer satisfy new constraints 
simplest change constrain variable take new value 
case tentative value violates new constraint 
case violation course tentative values comprise feasible solution new problem need repair solution 
purpose ecl ps repair library support process detecting variable tentative value conflict constraint detecting violations result choosing value variable differs tentative value 
constructive repair different repair algorithms arise different choices change value variable tentative value 
algorithm similar constructive search simply instantiates variable chosen new value 
case tentative values support specific heuristic constructive search algorithm 
notice heuristic simply choosing tentative value guess variable labelling 
take account value variable number tentative values conflicts constraints 
variable labelled new value value chosen minimise disruption original solution 
ecl ps repair library defines primitives setting tentative value variable tent set looking tent get 
supports special annotation changes behaviour constraint propagation simply checking tentative values uninstantiated variables 
annotation written constraint constraint built user defined constraint 
check fails constraint recorded conflict constraint full propagation constraint switched 
set conflict constraints accessed predicate conflict constraints 
search procedure decide variable label 
built search predicate called repair provided selects variable tentative value violates repair constraint labels succeeds remaining variables consistent tentative values 
illustrate repair algorithm example ic parc ecl ps library manual sne 
solutions means solve problem variables state constraints set existing solution repair invoke repair labeling newy 
get repaired solution constructive repair algorithm repaired 
initially constraint inconsistent solution variable repaired take value 
affects constraint repaired 
constraint affected update 
particular keeps value existing solution labeled repair 
constructive repair known informed backtracking successfully variety benchmarks 
weak commitment instantiating variable order repair alternative method simply change tentative value 
approach requires backtracking conflict fixed just changing tentative values 
disadvantage cycles easily occur variables repeatedly switch tentative values 
successful algorithm repairing tentative values called weak commitment 
starting variables tentative values 
variables conflict repaired instantiating conflicts algorithm terminates remaining conflicts repaired 
situation occurs variable conflict instantiated value consistent variables instantiated far 
dead encountered weak commitment algorithm simply variables setting tentative values values instantiated 
algorithm restarts fixing conflicts 
local improvement constructive repair weak commitment algorithms designed find feasible solutions problem 
case problem additionally requires cost minimised repair adapted return better better solutions 
unconstrained problems local improvement achieved just changing value variable having chosen variable value cost new solution better cost previous solution 
idea underlies various hill climbing algorithms stochastic techniques simulated annealing tabu search 
problems constraints changing value variable necessarily yield feasible solution 
ecl ps repair library find feasible solution incorporates change 
simulated annealing program written ecl ps ensures moves respect problem constraints 
program compared pure simulated annealing approach simply associates cost violated constraints treats problem unconstrained 
experiments showed constrained simulated annealing program outperformed pure 
industrial application repair library eplex linear constraint library 
algorithm application relaxed optimum checked repair constraints step violated constraint strengthened way solution returned eplex satisfy 
algorithm outperforms standard mip search problem dynamic constraint problem original solution requirement modify solution satisfy new constraints 
details algorithms scope article hopefully brief survey offered glimpse power repair search combination different solvers ecl ps ecl ps system ecl ps jointly owned icl ic parc icl supported research centre imperial college 
system obtained ftp ic parc eclipse request doc ic ac uk ecl ps runs unix operating system specifically sunos sun hardware solaris sparc machines linux pc available windows nt version 
ecl ps embeddable programs 
available form linkable library number facilities available pass data different environments integration close possible 
naturally facilities provided allow ecl ps invoke 
tightly integrated graphical system useful program development ecl ps offers integration tcl tk toolkit public domain software available unix windows 
typically ecl ps invoked tcl driven directly user interactions 
example graphical environment ecl ps developers graphical constraint environment grace available ecl ps library 
grace implemented ecl ps tcl 
manuals documentation include manual covering non constraint facilities ecl ps ae manuals covering facilities supporting constraints sne information covering graphical user interface library embeddability 
background list publications reachable ic parc home page www doc ic ac uk ecl ps platform development years 
time constraint programming established important research area live industrial applications 
market constraint technology growing dramatically point major vendor mip technology cplex taken constraint technology vendor ilog 
years ecl ps moved early roots logic programming constraint propagation focus hybrid algorithms 
tight integration mip clp developed hybrid algorithms combination proved efficiency industrial applications 
hybrid search algorithms particular utilising solution repair focus research development 
growing experience hybrid algorithms able separate features different algorithms underlying problem model 
consequently reached point ecl ps express clear precise neutral conceptual model application model extended annotated implementation stage 
result implementation design model implements fine grained hybrid algorithms tailored application hand 
experience variety industrial applications 
ic parc developed applications industrial partners application contributed final architecture ecl ps platform 
ongoing applications partners british transport continually give rise new hybrid techniques results feed back ecl ps algorithms encapsulated added new libraries 
real benefit ecl ps comes algorithms encapsulated libraries ease new hybrid algorithms developed validated delivered industrial computing environment 
ae eclipse user manual 
ic parc 
pascal eclipse extensions manual 
ic parc 
cpl cplex 
cplex callable library cplex mixed integer library 
technical report version cplex optimisation 
minton johnston philips laird 
minimizing conflicts heuristic repair method constraint satisfaction scheduling problems 
artificial intelligence 
rr tom richards barry richards 
nogood learning constraint satisfaction 
technical report ic parc 
proceedings cp workshop constraint programming application 
robert mark wallace 
new approach integrating mixed integer programming constraint logic programming 
technical report ic parc 
appear annals operations research 
sne joachim stefano el 
ic parc eclipse library manual 
ic parc 
wal mark wallace 
constraint programming 
chapter handbook applied expert systems crc press 
yokoo 
weak commitment search solving constraint satisfaction problems 
proc 
th national conference artificial intelligence pages 
contents ecl ps philosophy ecl ps modelling language overview ecl ps modelling language logic programming formal specification languages mathematical modelling languages mainstream programming languages object oriented languages conceptual model design model map colouring having change pocket solvers syntax fd finite domain library fd symbolic finite domain facilities fd integer arithmetic facilities fd complex constraints range library ria real interval arithmetic library eplex external cplex solver interface library complex constraints generalised propagation library chr constraint handling rules library explicit data driven control search constructive search branch bound depth search backtracking guesses constraints imposed search mip search search heuristics hybrid solvers incomplete constructive search intelligent backtracking nogood learning solution repair constructive repair weak commitment local improvement ecl ps system 
