experience processes monitors mesa butler lampson xerox palo alto research center david redell xerox business systems monitors describing concurrency discussed literature 
monitors real systems size number problems arise adequately dealt semantics nested monitor calls various ways defining meaning wait priority scheduling handling timeouts aborts exceptional conditions interactions process creation destruction monitoring large numbers small objects 
problems addressed facilities described concurrent programming mesa 
experience substantial applications gives confidence validity solutions 
key words phrases concurrency condition variable deadlock module monitor operating system process synchronization task cr categories 
early began design concurrent programming facilities pilot new operating system personal computer 
pilot fairly large program lines mesa code 
addition support variety quite large application programs ranging database management inter network message transmission heavy users concurrency experience applications discussed 
intended new facilities purposes local concurrent programming 
individual application implemented tightly coupled group synchronized processes express concurrency inherent application 
appeared communications acm feb pp 
earlier version th acm symposium operating systems principles pacific grove ca dec 
version created published version scanning ocr may errors 
permission copy fee part material granted provided copies distributed direct commercial advantage acm copyright notice title publication date appear notice copying permission association computing machinery 
copy republish requires fee specific permission 
experience processes monitors mesa global resource sharing 
independent applications run machine cooperatively sharing resources particular processes share processor 
replacing interrupts 
request software attention device handled directly waking appropriate process going separate interrupt mechanism example forced branch 
pilot closely coupled mesa language write pilot applications programs supports 
natural design facilities part mesa easier allows compiler detect kinds errors 
idea integrating facilities language certainly new goes back far pl 
furthermore invention monitors dijkstra hoare brinch hansen provided attractive framework reliable concurrent programming 
followed number papers integration concurrency programming languages implementation 
thought task easy read literature compare alternatives offered pick suitable needs 
expectation proved naive 
large size wide variety applications address number issues clearly resolved published monitors 
notable listed sections discussed 
program structure 
mesa facilities organizing programs modules communicate defined interfaces 
processes fit scheme see section 
creating processes 
set processes fixed compile time unacceptable general purpose system see section 
existing proposals varying amount concurrency limited concurrent elaboration statements block style algol complex mechanism pl 
creating monitors 
fixed number monitors unacceptable number synchronizers function amount data details existing proposals depended fixed association monitor block program text see section 
wait nested monitor call 
issue continued source considerable amount confusion resolve acceptable manner proceed see section 
exceptions 
realistic system timeouts way abort process see section 
mesa unwind mechanism abandoning part sequential computation orderly way interact properly monitors see section 
scheduling 
precise semantics waiting condition variable discussed agreed reasons making particular choice articulated see section 
attention paid interaction monitors priority scheduling processes see section 
experience processes monitors mesa input output 
details fitting devices framework monitors condition variables fully worked see section 
points discusses usefulness monitors modern general purpose mainframe operating system 
modula language addresses limited context 
settling monitor scheme described considered possibilities 
felt task choose shared memory monitors message passing basic interprocess communication paradigm 
message passing language support number operating systems proposal embed messages language see 
analysis differences schemes monitors lauer needham 
conclude certain mild restrictions programming style schemes duals transformation message process send reply language main tool program structuring procedure considerably easier monitor scheme devise message passing scheme properly integrated type system control structures language 
shared memory paradigm considered possibility adopting simpler primitive synchronization facility monitors 
assuming absence multiple processors simplest form mutual exclusion appears non preemptive scheduler processes yield processor voluntarily mutual exclusion insured yield points 
simplest form approach tends produce delicate programs insertion yield random place introduce subtle bug previously correct program 
danger alleviated addition modest amount syntactic sugar delineate critical sections processor yielded example pseudo monitors 
sugared form non preemptive scheduling provide extremely efficient solutions simple problems rejected reasons willing accept implementation multiple processors want embed restriction basic semantics 
separate preemptive mechanism needed anyway processor respond time critical events example interrupts voluntary process switching clearly sluggish 
preemptive process scheduling interrupts treated ordinary process reduces total amount machinery needed eliminates awkward situations tend occur boundary scheduling regimes 
non preemption mutual exclusion restricts programming generality critical sections particular procedure happens yield processor called 
large systems modularity essential restrictions intolerable 
experience processes monitors mesa mesa concurrency facilities function virtual memory environment 
mutual exclusion forbids multiprogramming page faults effectively insert arbitrary points program 
mutual exclusion preemptive scheduler necessary introduce explicit locks machinery requesting processes wait lock unavailable 
considered casting locks semaphores decided compared monitors exert little structuring discipline concurrent programs 
semaphores solve different problems single mechanism example mutual exclusion producer consumer similar economies implementation monitors condition variables see section 
associated protection mechanism processes mesa implicit type system language 
system supports user feel considerable protection offered strong typing language sufficient 
fact contributes substantially low cost process operations 

processes mesa casts creation new process special procedure activation executes concurrently caller 
mesa allows procedure internal procedure monitor see section invoked way caller discretion 
possible retrieve results returned procedure 
example keyboard input routine invoked normal procedure writing buffer terminal wait input caller wish compute concurrently fork terminal 
concurrent computation buffer join types procedure device returns line process returns line rendezvous return terminates new process join old process provided automatically 
root procedure new process 
scheme number important properties 
treats process class value language assigned variable array element passed parameter general treated exactly value 
process value pointer value procedure value refers nested procedure dangling process refers goes away 
method passing parameters new process retrieving results exactly corresponding method procedures subject strict type experience processes monitors mesa checking 
just procedure generator family types depending argument result types process similar generator slightly simpler depends result types 
special declaration needed procedure invoked process 
implementation procedure calls global control transfers mesa extra execution cost generality 
cost creating destroying process moderate cost storage twice minimum cost procedure instance 
feasible program large number processes vary number quite rapidly 
lauer needham point synchronization problems straightforward solutions monitors obtaining new process cheap 
patterns process creation possible 
common create detached process returns result creator functions quite independently 
root procedure detached process returns process destroyed fuss 
fact intends wait result expressed executing detach point view caller similar freeing dynamic variable generally error current value process running asynchronously may complete destroyed time 
course design program may happen case value useful parameter abort operation see section 
illustrates general point processes offer new opportunities create dangling 
process variable kind pointer process destroyed 
furthermore parameters passed process pointers happen local variables procedure procedure return process destroyed 
implementation languages mesa provide protection dangling connected processes 
ordinary mesa facility exception handling uses ordering established procedure calls control processing exceptions 
block may attached exception handler 
block containing statement causes exception chance handle enclosing block forth procedure body reached 
caller procedure chance way 
root procedure process caller prepared handle exceptions generated process including exceptions generated procedure 
fails resulting error sends control debugger identity procedure exception easily determined programmer 
comfort system operational 
practical consequence procedure suitable forking called sequentially converse generally true 
experience processes monitors mesa 
monitors processes interact sharing data care taken properly synchronize access data 
idea monitors proper vehicle interaction unifies synchronization shared data body code performs accesses 
data protected monitor accessed body monitor procedure 
kinds monitor procedures entry procedures called outside monitor internal procedures called monitor procedures 
processes perform operations data calling entry procedures 
monitor ensures process executing monitor procedure time process said monitor 
process monitor process calls entry procedure delayed 
monitor procedures written textually declaration protected data reader conveniently survey data 
long order calling entry procedures produces meaningful results additional synchronization needed processes sharing monitor 
random order acceptable provisions program outside monitor 
example unbounded buffer put get procedures imposes constraints course get may wait taken care monitor described section 
hand tape unit reserve read write release operations requires process execute reserve release 
second process executing reserve delayed monitor process doing read prior reserve produce chaos 
monitors solve problems concurrent programming intended part primitive building blocks complex scheduling policies 
discussion policies implement monitors scope 
monitor modules mesa simplest monitor instance module basic unit global program structuring 
mesa module consists collection procedures global data sequential programming implement data abstraction 
module public procedures constitute external interface abstraction private procedures internal implementation called outside module data normally entirely private 
monitor module differs slightly 
kinds procedures entry internal private external non monitor procedures 
monitor procedures execute monitor lock held 
example consider simple storage allocator entry procedures allocate free external procedure expand increases size block 
experience processes monitors mesa monitor integer condition allocate entry procedure size integer returns pointer size wait endloop remove chunk size words update free entry procedure pointer size integer put back chunk size words update notify expand public procedure pointer size integer returns pnew pointer pnew allocate size copy contents old block new block free 
mesa module normally package collection related procedures protect private data external access 
order avoid introducing new lexical structuring mechanism chose lo scope monitor identical module 
procedures belong abstraction need access shared data need entry procedures monitor distinguished 
example asynchronous processes clearly execute allocate free procedures time entry procedures 
hand unnecessary hold monitor lock copy expand procedure logically belongs storage allocator module written external procedure 
complex monitor internal procedures structure computations inaccessible outside monitor 
acquire release lock call return called lock held 
suitable block available allocate caller wait condition variable 
free notify variable new block available causes process waiting variable resume execution see section details 
wait releases monitor lock waiting process monitor 
wait done internal procedure releases lock 
monitor calls procedure outside monitor module lock released procedure calls monitor ends doing wait 
rule adopted concurrent pascal 
understand reasons consider form correctness argument program monitor 
basic idea monitor maintains invariant true data process executing monitor 
control leaves monitor invariant established 
return control enters monitor invariant assumed 
entry procedure establish invariant returning monitor procedure establish doing wait 
invariant assumed experience processes monitors mesa start entry procedure wait 
conditions monitor lock ensures enter monitor invariant false 
lock released wait done monitor happens called invariant established making call leads wait 
general way know call outside monitor lead wait invariant established call 
result calling procedures hopelessly cumbersome 
alternative solution allow outside block written inside monitor meaning entry block lock released invariant established block protected data inaccessible leaving block lock 
scheme allows state represented execution environment monitor maintained outside call imposes minimal burden programmer establish invariant making call 
mechanism easy add mesa left seen convincing examples significantly simplifies program 
entry procedure generates exception usual way result call exception handler monitor lock released 
particular means exception handler carefully avoid invoking monitor deadlock result 
avoid restriction entry procedure restore invariant execute return error arguments returns entry procedure releasing lock generates exception 
monitors deadlock patterns pairwise deadlock occur monitors 
practice course deadlocks involve processes case actual patterns observed tend complicated conversely possible single process deadlock example entry procedure recursive 
simplest form deadlock takes place inside single monitor processes wait expecting awakened 
represents localized bug monitor code usually easy locate correct 
subtle form deadlock occur cyclic calling pattern monitors 
monitor calls entry procedure calls wait release monitor lock 
kind deadlock serious monitor mechanism 
arises cyclic dependencies allowed occur program avoided number ways 
simplest impose partial ordering resources resources simultaneously possessed process totally ordered insist resource precedes ordering acquired 
resources monitors reduces simple rule mutually recursive monitors avoided 
concurrent pascal check compile time mesa procedure variables 
experience processes monitors mesa serious problem arises calls waits condition occur process enters condition true 
situation unlocked wait occurred remain locked wait kind level data abstraction handled care 
straightforward solution standard monitors break parts monitor ordinary module implements abstraction defined calls access shared data 
call done 
monitors interprocess communication mechanism tool implementing synchronization constraints chosen programmer 
unreasonable blame tool poorly chosen constraints lead deadlock 
crucial tool program structure understandable possible restricting programmer choice constraints example forcing monitor lock held longer necessary 
extent goals tend conflict mesa concurrency facilities attempt strike reasonable balance provide environment programmer avoid deadlock reasonably easily 
experience area reported section 
monitored objects wish collection shared data objects representing instance object file storage volume virtual circuit database view wish add objects collection delete dynamically 
sequential program done standard techniques allocating freeing storage 
concurrent program provision serializing access object 
straightforward way single monitor accessing instances object recommend approach possible 
objects function independently part single monitor drastically reduces maximum concurrency obtained 
case want give object monitor monitors share code instances object share code object lock 
way achieve result multiple instances monitor module 
mesa quite easy recommended approach 
data associated module instance includes information mesa system uses support program linking code swapping cost duplicating information 
furthermore module instances allocated system program exercise fme control allocation strategies possible ordinary mesa data objects 
introduced new type constructor called monitored record exactly ordinary record includes monitor lock intended protected data monitor 
writing code monitor programmer specify access monitored record embedded larger data structure passed parameter entry procedures 
done locks clause written module monitor locks file file pointer experience processes monitors mesa protected data 
arbitrary expression appear locks clause instance locks file buffers appropriate protected data buffers array part file 
entry procedure monitor internal procedure wait access file acquire release lock entry wait 
accomplished ways file may global variable module may parameter procedure 
case effectively created separate monitor object limiting program freedom arrange access paths storage allocation likes 
unfortunately type system mesa strong construction completely safe 
value file changed entry procedure example chaos result return procedure release lock acquired call lock 
example insist file read level indirection aliasing occur restriction enforced 
practice lack safety problem 
abandoning computation suppose procedure called procedure turn called forth current procedure generates exception eventually handled 
provide handlers mesa allows exception handler abandon portion computation done 
continue execution happens distinguished exception called unwind generated 
chance handle necessary cleanup activation destroyed 
feature mesa part concurrency facilities interact facilities way 
procedures abandoned say entry procedure invariant restored monitor lock released destroyed 
logic program allows unwind programmer supply suitable handler restore invariant mesa automatically supply code release lock 
programmer fails supply unwind handler entry procedure lock automatically released remains set cause resulting deadlock hard find 

condition variables section discuss precise semantics wait details associated condition variables 
hoare definition monitors requires process waiting condition variable run immediately process signals variable signaling process turn runs soon waiter leaves monitor 
definition allows waiter assume truth predicate stronger monitor invariant signaler course establish requires additional process switches process continues wait 
requires signaling mechanism perfectly reliable 
mesa takes different view process establishes condition process may waiting notifies corresponding condition variable 
notify regarded hint waiting process causes execution process waiting condition resume convenient time 
waiting process resumes reacquire experience processes monitors mesa monitor lock 
guarantee process enter monitor waiting process 
monitor invariant may assumed wait waiter reevaluate situation time resumes 
proper pattern code waiting ok proceed wait endloop 
arrangement results extra evaluation ok proceed predicate wait compared hoare monitors code ok proceed wait return extra process switches constraints waiting process run notify 
fact perfectly right run waiting process notify presumably pointless notify done interesting change protected data 
possible faire attitude scheduling monitor accesses lead unfairness starvation 
think legitimate cause concern properly designed system typically processes waiting monitor lock 
hoare brinch hansen pointed low level scheduling mechanism provided monitor locks implement high level scheduling decisions system example process get printer 
high level scheduling done account specific characteristics resource scheduled example right kind printer 
scheduler delay client processes condition variables recording information requirements decisions information notify proper conditions 
design data protected monitor bottleneck 
verification rules mesa monitors extremely simple monitor invariant established just return entry procedure wait may assumed start entry procedure just wait 
awakened run immediately predicate established notify assumed corresponding wait waiter tests explicitly ok proceed verification simpler localized 
consequence mesa treatment notify hint applications trouble determine exact condition needed waiter established 
choose cheap predicate implies exact condition example change occurred notify covering condition variable 
waiting process responsible determining exact condition holds simply waits 
example process may need wait particular object set changes state 
single condition covers entire set process changing objects broadcasts condition see section 
information exactly objects currently interest implicit states waiting processes having represented explicitly shared data structure 
attractive way decouple detailed design processes feasible cost waking process small 
experience processes monitors mesa alternatives notify rule easy add additional ways resume waiting process timeout 
associated condition variable timeout interval process waiting time resume regardless condition notified 
presumably cases check time take recovery action waiting 
original design timeouts raised exception timeout occurred changed users simply wanted retry timeout objected cost coding complexity handling exception 
decision certainly go way 
abort 
process may aborted time executing abort 
effect time process waits waiting resume immediately aborted exception occur 
mechanism allows process gently prod generally suggest clean terminate 
aborted process free arbitrary computations ignore abort entirely 
broadcast 
doing notify condition process may broadcast causes processes waiting condition resume simply 
notify just hint correct broadcast 
better notify typically processes waiting condition known waiting process respond properly 
hand times broadcast correct notify alert reader may noticed problem example program section solved replacing notify broadcast 
mechanisms affects proof rule monitors 
provides way attract attention waiting process appropriate time 
note way runaway process 
reflects fact mesa processes cooperative 
aspects design appropriate competitive environment general purpose timesharing system 
naked notify communication input output devices handled monitors condition variables communication processes 
typically shared data structure details determined hardware passing commands device returning status information 
possible device wait monitor lock update operations structure designed single word atomic read write operations provided memory sufficient atomic 
device needs attention notify condition variable wake waiting process interrupt handler device acquire monitor lock notify called naked notify 
device finds address condition variable memory location 
complication associated naked notify notification protected monitor lock race 
possible process monitor find ok proceed predicate false device need attention wait device updates shared data notify 
wait done notify device lost 
ordinary processes happen experience processes monitors mesa monitor lock ensures process testing predicate preparing wait changing value ok proceed doing notify 
problem avoided providing familiar wakeup waiting switch condition variable turning binary semaphore 
switch needed condition variables notified devices 
briefly considered design devices wait acquire monitor lock exactly ordinary mesa processes design attractive avoids anomalies just discussed 
serious problem kind mutual exclusion processes run processors substantially different speeds faster process may wait slower 
worst case response time faster process time slower needs finish critical section 
get higher throughput faster processor slower get better worst case real time performance 
consider fundamental deficiency 
best avoid mutual exclusion provided atomic memory read write operations mesa code device hardware microcode 
relationship easily cast producer consumer form implemented linked lists arrays memory mutual exclusion 
small amount mesa code handle device data structures protection monitor 
clearly change models occur point disk head application program see reason happen mesa code certainly tightly encapsulated 

priorities applications desirable priority scheduling discipline allocating processor processes waiting 
care taken ordering implied assignment priorities subverted monitors 
suppose priority levels highest lowest processes running level 
communicate monitor consider sequence events 
enters 
preempted 
preempted 
tries enter monitor waits lock 

runs effectively prevent running contrary purpose priorities 
simple way avoid situation associate monitor priority highest priority process enters monitor 
process enters monitor priority temporarily increased monitor priority 
modula solves problem simpler way interrupts disabled entry effectively giving process highest possible priority supplying monitor lock approach fails page fault occur executing mechanism free needed depends application 
instance processes adjacent priorities share monitor problem described experience processes monitors mesa occur 
case problem may occur rarely absolute enforcement priority scheduling may important 

implementation implementation processes monitors split equally mesa compiler runtime package underlying machine 
compiler recognizes various syntactic constructs generates appropriate code including implicit calls built known compiler support procedures 
runtime implements heavily operations process creation destruction 
machine directly implements heavily features process scheduling monitor entry exit 
note primarily frequency abstraction motivated division labor processor software 
split turn fairly clean layering birth death processes implemented top monitors process scheduling 
processor existence process normally represented stack procedure activation records frames plus small byte description called 
frames allocated frame heap allocator 
come range sizes differ percent percent separate free list size bytes sizes 
allocating freeing frames fast frames size needed 
frames come heap need stack space needed process 
frame size needed available frame fault fault handler allocates frames virtual memory 
resident procedures private frame heap real memory virtual memory manager 
kept fixed table known processor size table determines maximum number processes 
time exactly queue 
kinds queues ready queue 
ready queue containing processes ready run 
monitor lock queue 
process attempts enter locked monitor moved ready queue queue associated monitor lock 
condition variable queue 
process executes wait moved ready queue queue associated condition variable 
fault queue 
fault process temporarily unable run process moved ready queue fault queue fault handling process notified 
experience processes monitors mesa queue cell head tail process queue queues kept sorted process priority 
implementation queues simple way circular list queue cell pointing tail queue see 
compact structure allows rapid access head tail queue 
insertion tail removal head quick easy general insertion deletion involve scanning fraction queue 
queues usually short problem 
ready queue grows substantial size normal operation patterns insertions deletions queue scanning overhead small 
queue cell ready queue kept fixed location known processor fundamental task execute instruction highest priority ready process 
check instruction process switch done necessary 
particular mechanism interrupts serviced 
machine implements simple priority scheduler preemptive priorities fifo priority 
queues ready list passed processor software operands instructions trap vector case fault queues 
queue cells passed general updated identity tail may change 
monitor locks condition variables implemented small records containing associated queue cells plus small amount extra information monitor lock actual lock condition variable timeout interval wakeup waiting switch 
fixed interval times second processor scans table notifies waiting processes timeout intervals expired 
special notify tricky processor know location condition variables processes waiting update queue cells 
problem solved leaving queue cells date marking processes way normal usage queue cells notice situation update appropriately 
provision time slicing current implementation easily added effect semantics processes 
experience processes monitors mesa runtime support package process module mesa runtime package creation deletion processes 
module written mesa monitor underlying synchronization machinery processor coordinate implementation fork join built entry procedures process fork process join respectively 
unused treated essentially normal processes waiting condition variable called 
call process fork performs appropriate brain surgery process queue notifies bring process life process join synchronizes dying process retrieves results 
implicitly invoked procedure process synchronizes dying process joining process commits suicide waiting 
explicit call process detach marks process calls process simply destroy immediately 
operations process abort process yield provided allow special handling processes wait long compute long respectively 
adjust states appropriate queues machine standard queueing mechanisms 
utility routines provided runtime operations setting condition variable timeout setting process priority 
compiler compiler recognizes syntactic constructs processes monitors emits appropriate code example instruction start entry procedure implicit call process fork fork 
compiler performs special static checks help avoid certain frequently encountered errors 
example wait external procedure flagged error direct call external procedure internal 
power underlying mesa control structure primitives care concurrency integrated language processes monitors mesa resulted remarkably little inside compiler 
performance mesa concurrent programming facilities allow intrinsic parallelism application programs represented naturally hope structured programs high global efficiency result 
time facilities nontrivial local costs storage execution time compared similar sequential constructs important minimize costs facilities applied finer grain concurrency 
section summarizes costs processes monitors relative basic mesa constructs simple statements procedures modules 
course relative efficiency arbitrary concurrent program equivalent sequential determined numbers intent simply provide indication relative costs various local constructs 
storage costs fall naturally data program storage reside swappable virtual memory indicated 
minimum cost existence mesa module bytes data bytes code 
changing module monitor adds bytes data bytes code 
prime component module set procedures experience processes monitors mesa requires minimum byte activation record bytes code 
changing normal procedure monitor entry procedure leaves size activation record unchanged adds bytes code 
costs small compared program data storage needed typical modules procedures 
cost specific monitors space condition variables condition variable occupies bytes data storage wait notify require bytes bytes code respectively 
data storage overhead process bytes resident storage plus swappable storage stack procedure activation records 
process contains extra code code fork join create delete occupy bytes compared bytes normal procedure call return 
fork join sequence uses data bytes store process value 
summary space bytes construct data code module procedure call return monitor entry procedure fork join process condition variable wait notify measuring execution times define unit called tick time required execute simple instruction example mip machine tick microsecond 
tick arbitrarily set fourth time needed execute simple statement loads add store 
interesting number compare concurrency facilities cost normal procedure call associated return takes ticks arguments results 
cost calling returning monitor entry procedure ticks percent ordinary call return 
practice percentage increase somewhat lower typical procedures pass arguments return results cost ticks item 
process switch takes ticks includes queue manipulations state saving restoring 
speed wait notify depends somewhat number priorities processes involved representative figures ticks wait ticks notify 
minimum cost fork join pair ticks times procedure call 
summarize experience processes monitors mesa construct time ticks simple instruction call return monitor call return process switch wait notify waiting notify process waiting fork join basis performance figures feel implementation met efficiency goals possible exception fork join 
decision implement language constructs software underlying machine main reason somewhat performance 
regard decision sound facilities considerably complex basic synchronization mechanism frequently especially join detached processes discussed section turned quite popular 

applications section describe way processes monitors substantial mesa programs operating system calendar system replicated databases internetwork gateway 
pilot general purpose operating system pilot mesa operating system runs large personal computer 
designed jointly new language features heavy 
pilot autonomous processes called number client processes priority fully asynchronous manner 
exploiting potential concurrency requires extensive monitors pilot roughly program modules contain nearly separate monitors 
pilot implementation includes dedicated processes exact number depends hardware configuration event handlers classes events interrupts 
naked notifies discussed section 
process faults 
page faults events signaled fault queues discussed section 
client code higher levels pilot including dedicated processes cause faults 
internal exceptions 
missing entries resident databases example cause appropriate high level helper process wake retrieve needed data secondary storage 
daemon processes awaken periodically perform housekeeping chores example swap unreferenced pages 
essentially pilot internal processes experience processes monitors mesa monitors created system initialization time particular suitable complement interrupt handler processes created match actual hardware configuration determined interrogating hardware 
running system dynamic process monitor creation largely pilot involved implementing facilities virtual memory dynamic creation software 
internal structure pilot fairly complicated careful placement monitors dedicated processes succeeded limiting number bugs caused deadlock life system dozen distinct deadlocks discovered fixed relatively easily global disruption system structure 
areas caused annoying problems development pilot 
lack mutual exclusion handling interrupts 
conventional interrupt systems subtle bugs occurred due timing races devices handlers 
extent illusion mutual exclusion provided casting interrupt code monitor may contributed feel resultant economy mechanism justifies choice 

interaction concurrency exception facilities 
aside general problems exception handling concurrent environment experienced difficulties due specific interactions mesa signals processes monitors see sections 
particular reasonable consistent handling signals including unwinds entry procedures represents considerable increase mental overhead involved designing new monitor understanding existing 
violet distributed calendar system violet system distributed database manager supports replicated data files provides display interface distributed calendar system 
constructed hierarchy abstractions shown 
level builds lower calling procedures supplied 
addition levels explicitly deal process 
course level multiple processes calls lower levels possible multiple processes executing procedures levels 
user interface level processes display keyboard 
display process responsible keeping display database consistent views specified user changes occurring database 
processes notify changes occur calls lower levels read information updating display 
display calls update operations lower level 
processes respond changes initiated user keyboard database 
process forked transactions module data looked violet changes disappears reported changes display 
experience processes monitors mesa level transactions process table user interface views buffers file suites networks stable files internal structure violet calendar names containers volatile files complex constellation processes exists constructs single replicated file set representative files containing data version replicated file 
representatives stored transactional file system updated atomically carries version number 
accessed monitor keeps track known representatives version numbers 
replicated file considered updated representatives write quorum updated latest version examining read quorum 
provided sum read quorum write quorum large total set representatives replicated file behaves conventional file 
file suite created forks inquiry process representative 
process tries read representative version number successful reports number monitor associated file suite notifies condition 
process trying read suite collect read quorum 
representatives waits 
inquiry processes expire done 
experience processes monitors mesa client wants update collect write quorum representatives containing current version waiting 
forks update process representative quorum tries write file 
forking update processes client joins turn proceed completed 
processes run transaction underlying transactional file system guarantees representatives quorum written 
possible write quorum currently accessible read quorum case writing client forks copy process representative accessible date 
process copies current file suite contents obtained read quorum representative eligible join write quorum 
processes may created representative replicated file 
normal situation state representatives known processes done vanished monitor call required collect quorum 
potentially complex structure held single monitor containing array representative states single condition variable 
gateway internetwork forwarder substantial application program implemented mesa process monitor facilities internetwork gateway packet networks 
gateway attached networks serves connection point passing packets network boundaries required 
perform task efficiently requires heavy concurrency 
lowest level gateway contains set device drivers device typically consisting high priority interrupt process monitor synchronizing device non interrupt level software 
aside drivers standard devices disk keyboard gateway contains drivers ethernet local broadcast networks common carrier lines 
ethernet driver processes interrupt process background process autonomous handling timeouts infrequent events 
driver common carrier lines similar third process collection lines resemble single ethernet iteratively simulating broadcast 
network drivers structure drivers provide standard network interface higher level software 
level software provides packet routing dispatching functions 
dispatcher consists monitor dedicated process 
monitor synchronizes interactions drivers dispatcher process 
dispatcher process normally waiting completion packet transfer input output occurs interrupt process handles interrupt notifies dispatcher immediately returns await interrupt 
example input interrupt process notifies dispatcher dispatches newly arrived packet appropriate socket processing invoking procedure associated socket 
router contains monitor keeps routing table mapping network names addresses gateway machines 
defines hop path accessible remote experience processes monitors mesa network 
router contains dedicated housekeeping process maintains table exchanging special packets gateways 
packet transmitted differently received 
process wishing transmit remote socket calls router monitor consult routing table process calls directly appropriate network driver monitor initiate output operation 
asymmetry input output particularly characteristic packet communication typical software 
primary operation gateway easy describe arrival packet processed level dispatcher discovered packet addressed remote socket dispatcher forwards doing normal transmission consulting routing table calling back driver initiate output 
gateway contains substantial number asynchronous processes critical path forwarding message involves single switch pair processes 
integration processes monitors mesa language somewhat substantial task anticipated flexibility mesa control structures amount published monitors 
largely mesa designed construction large serious programs processes monitors refined sufficiently fit context 
task accomplished yielding set language features sufficient power serve software concurrency mechanism personal computer handling situations ranging input output interrupts cooperative resource sharing unrelated application programs 
received june accepted september revised november 
american national standard programming language pl 
american nat 
standards inst new york 

boggs pup internetwork architecture 
ieee trans 
communications april 

brinch hansen operating system principles 
prentice hall july 

brinch hansen 
programming language concurrent pascal 
ieee trans 
software engineering june 

dijkstra hierarchical ordering sequential processes 
operating systems techniques academic press 

gifford weighted voting replicated data 
operating systems review dec 
experience processes monitors mesa 
gifford 
violet experimental decentralized system 
integrated office systems workshop rocquencourt france nov available csl report xerox research center palo alto calif 

hoare monitors operating system structuring concept 
comm 
acm oct 

hoare communicating sequential processes 
comm 
acm aug 

howard signaling monitors 
second int 
conf 
software engineering san francisco oct 

israel mitchell sturgis separating data function distributed file system 
second int 
symposium operating systems rocquencourt france oct 

structuring operating systems monitors 
australian computer feb reprinted operating systems review jan 

lampson mitchell satterthwaite transfer control contexts 
lecture notes computer science springer 

lauer 
needham 
duality operating system structures 
second int 
symposium operating systems rocquencourt france oct reprinted operating systems review april 

am maynard 
implementation monitors 
software practice experience july 

metcalfe 
boggs ethernet packet switching local computer networks 
comm 
acm july 

mitchell 
maybury 
sweet mesa language manual 
xerox research center palo alto calif 

redell pilot operating system personal computer 
comm 
acm feb 

saltzer traffic control multiplexed computer system 
mac tr mit july 

saxena structured specification hierarchical operating system 
sigplan notices june 

wirth modula language modular multi programming 
software practice experience jan 
experience processes monitors mesa 
