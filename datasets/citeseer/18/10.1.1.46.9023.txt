algorithm automatic generation reservation tables architectural descriptions submitted isss peter ashok dutt alex nicolau ics uci edu ics uci edu dutt ics uci edu nicolau ics uci edu center embedded computer systems university california irvine ca usa reservation tables rts long detect conflicts instructions simultaneously access architectural resource 
traditionally rts specified explicitly designer 
increasing complexity modern processors manual specification rts cumbersome error prone 
furthermore manual specification conflict information infeasible supporting rapid architectural exploration 
algorithm automatically generate rts high level processor description goal avoiding manual specification rts resulting concise architectural specifications supporting faster turn time design space exploration 
demonstrate utility approach set experiments ti vliw dsp dlx processor architectures suite multimedia scientific applications 
modern processors exhibit multiple levels parallelism deep pipelines resource data hazards lead significant performance degradation incorrect execution behavior 
detection avoidance hazards crucial task processor system design 
hazard information may captured conflicts instructions access resources time 
reservation tables rts specify represent pipeline behavior resource usage operations commonly part machine model capturing conflict information retargetable compilers 
rts example instruction scheduler avoid resource conflicts pipeline hazards 
complex processors increasingly deployed high embedded applications typically fixed parametrized cores system chip 
rts specified different levels detail architectural design space exploration dse environment involving trade offs accuracy speed software tools embedded systems onchip 
current retargetable tools follow rt approach require user specify rts manually instruction basis architecture description language adl 
processors contain complex pipelines large amounts parallelism complex storage sub systems typically contain large number partially supported nsf mip onr 
operations instructions resources rts 
manual specification rts operation basis cumbersome error prone 
furthermore exploration customization different architectures drives need rapid evaluation different architectural pipeline configurations making impractical manually specify rts operation basis configuration 
algorithm automatically generates rts high level processor description 
frees user burden having manually enumerate rts allowing conciseness specification reduction errors specification reduction time spent specification 
operation proceeds pipeline path accesses storage units data transfer paths key idea rt generation approach possible trace execution operation architecture pipeline data transfer segments generate accurate rts 
section describe related adl driven pipeline constraint specification tools compare approach 
section motivate need automatic rt generation ti vliw dsp 
section describes features necessary high level processor description support automatic generation rts 
expression adl designed support architecture exploration software tool kit generation 
rts generated expression drive scheduler express highly optimizing memory aware instruction level parallelizing ilp compiler 
section presents algorithm automatic rt generation 
section presents experiments implementation algorithm conducted demonstrate utility approach 
section presents brief discussion different usage scenarios approach purpose dse section concludes 
related pipelining developed late modern pipelining techniques direct descendents done late early 
surveys pipelining techniques provides terminology concepts today 
contains description various aspects pipelining including tackling hazards compilation techniques 
advent system chip soc technology ability explore variety processor cores led renewed interest retargetable software tool kits compilers terms operation instruction interchangeably simulators 
due increased parallelism pipelining today processors complex data resource hazards may raise conflicts architecture leading insertion stalls pipeline incorrect execution instructions vliw processors 
crucial detect avoid conflicts software toolkit compiler processor hardware controller 
related approaches specifying conflict information 
reservation tables rts long detect conflicts scheduling 
concept rts represent resources individual instructions stage pipeline developed 
conflicts instructions detected comparing rts 
examples compilers adopt approach include multiflow trace scheduling compiler compiler 
uses adl captures constraints instructions explicit rts instruction basis hierarchical description compactness 
explicit specification rts introduces redundancy processor description 
design space exploration dse structural changes architecture may propagate description requiring user manually reflect changes rt section 
state diagrams finite state fsas represent set legal instruction schedules processor 
fsas derived rts 
compiler techniques fsas 
determining instruction conflicts representation size rt approach suffers drawback increased time compared fsas 
rt optimization techniques mitigate drawbacks 
rts needed order generate fsas 
disadvantage fsa approach amenable certain advanced scheduling techniques iterative modulo scheduling mutation scheduling 
lisa approaches targeted mainly generate high performance simulators 
conflicts modeled signals capturing occurrence certain opcodes pipeline stages trigger different strategies stall shift freeze pipeline 
conflicts explicitly specified signal triggering mechanism 
nml adl processor instruction set described attributed grammar derivations reflecting set legal combinations instructions 
combinations instructions recognized grammar represent conflicts 
isdl adl illegal combinations instructions explicitly enumerated 
approaches advantage able capture constraints including due bitwidth restrictions size specification tends get large complex processors 
previous approaches require manual specification conflicts tedious error prone task 
propose algorithm automatically generate set rts mixed structural behavioral description processor 
free user burden having manually specify rts 
dse changes structure processor reflected automatically rts allowing fast dse iterations 
automatically generating conflict information avoid redundancy input processor specification 
approach architectural specification generate structural simulator rts required optimizing compiler express 
motivating example texas instruments vliw dsp intuitively explain rt generation algorithm illustrate complexity problem 
state art fixed point digital signal processor dsp high performance vliw architecture block level diagram shown 
bold blocks represent pipeline functional units dotted blocks represent storage components 
interesting features architecture include instruction level parallelism ilp operations issued cycle complex fragmented pipeline complex storage subsystem register files rfa rfb multiple read write ports main memory banks 
main memory data transfer pipeline path ps pw pr dp dc rfa rfb mem controller pg 
block diagram ti vliw dsp 
pg ps pw pr perform instruction fetch dp dc perform decode dispatch functional units 
ease illustration omitted showing main controller pipeline latches ports connections storages 
actual rt generation algorithm assumes complete specification including example source destination ports functional unit 
detailed description ti architecture 
version processor fully qualified operations requiring specification rts 
operation formats supported operand opcode dest operand opcode dest src operand opcode dest src src formats 
large number operations specification rts operation basis tedious error prone 
specifying generating rts straightforward simple task architectures due presence complex architectural features fragmented pipeline paths multiple register files cross paths varied operation formats 
automatic rt generation approach essential free user burden specifying complex rts reduce possibility errors rts 
approach results automatic generation rts architectures complex features including multiple pipeline paths bus data transfers different operation formats 
fully qualified operation fields bound architectural components functional storage units adl information required rt generation describe essential features required architecture description language adl support automatic generation rts 
adl vehicle demonstrating automatic generation rts machine description important note rt generation approach specific expression adl 
adl incorporates generic features mentioned candidate automatic generation rts approach 
primary characteristic adl automatic rt generation integrated specification structure behavior instruction set system 
summarize key features structural behavioral specification adl 
adl structural specification structure processor system defined components connectivity components 
component defined attributes connectivity components defined high level constructs pipeline data transfer described 
component specification component architecture may modeled unit alu storage register file port connection bus 
component described terms opcodes instructions supported component timing multi cycle pipelined components label tag associated port connection components opcodes construct ties behavioral description structural description components 
connectivity specification pipeline constructs provide natural concise way specify net list high level 
pipeline specify ordering units comprise architecture pipeline stages 
pipeline paths represent sequence time execution pipeline units 
data transfers specify valid unit storage storage unit data transfers 
data transfer paths typically occur functional units alus memory elements register files 
adl behavioral specification behavior processor defined instruction set 
operation instruction set defined terms opcode opcode mnemonic associated operation operands list arguments src dst associated operation format operation format indicate relative ordering various operation fields 
adl features drive automatic generation rts described section 
algorithm automatic generation reservation tables presents flow reservation tables rt generation algorithm 
starts description processor specified adl expression generates rt instruction 
proceeds phases 
phase pipeline paths data transfer segments combined generate cross product called traces 
traces incorporate instruction set information capture behavior pipeline set possible footprints netlist 
trace example ti shown bold lines traversing pg ps pw pr dp dc units accessing rfa rfb 
trace activated instruction mapping traces specific instruction performed second phase trace linked instruction 
second phase instruction traces instruction format opcode unit mapping generate corresponding rt 
rt represents architectural resources pipeline stage particular instruction 
phase different strategies varying computation time memory requirements generate rts explained detail section 
traces intermediate output algorithm number traces typical processor small compared number fully qualified instructions consequently number rts 
details phases rt generation algorithm 
pipeline gen pipeline paths pipeline paths decorate pipeline paths instr format decorated pipeline paths append data transfers traces fully qualified instruction opcodes supp resources 
table compose dt segments dt segments data transfers expression express compiler simulator verification synthesis phase phase ii bind instr rt compiler 
overview algorithm phase expression contains hierarchical description pipeline flatten hierarchy set distinct pipeline paths 
instance flattened pipeline path ti pg ps pw pr dp dc 
data transfers described compose complete rf fu fu rf transfers steps necessary transform pipeline data transfers description hierarchical expression format format required algorithm 
rest algorithm independent expression processor architecture description language containing features described section 
procedure decorate pipeline paths annotates units pipeline path ports corresponding data transfer involving unit 
example unit decorated ports src operand src operand allowing transfer data rfa rfb conciseness represent ports 
ports annotating pipeline path chosen instruction formats 
order pipeline path support instruction format operands referenced instruction format implemented port decorating pipeline path 
rf stands register files rfa fu functional units 
main memory ps pw pr dp dc rfa rfb mem controller pg 
trace ti architecture format opcode fu src src dst pipeline path pg ps pw pr dp dc src covered port src dst pipeline path try satisfy instruction format generating possible decorations operand format covered exactly port 
pipeline path multiple formats supported multiple ways decorate duplicate pipeline path different combination ports decorate copy 
append data transfers pipeline paths generates traces attaching data transfer port decorating pipeline paths 
port may multiple data transfers attached 
transfer data rfa rfb different set connections 
port consider possible data transfers duplicating decorated pipeline paths choosing combination data transfers attach 
result step called traces 
trace example architecture shown 
contains units pg ps pw pr dp dc data transfers rfb rfa rfa 
unit reads operand rfb cross connection rfb port rfa connection rfa connect port 
unit writes result rfa connection rfa connect port phase ii 
second phase traverse traces order find trace corresponding input instruction 
narrow choice traces ones corresponding instruction format unit 
instruction rfb rfa rfa choose traces contain unit support format opcode fu src src dst 
verify units trace support instruction opcode 
way account cases different opcodes supported fu require different sets resources 
unit supports ld add instructions ld additionally requires mem controller unit add 
mem controller support add opcode traces containing memory controller excluded determining rts add instruction 
eliminate traces containing false paths verifying algorithm phase generate traces input structural specification processor currently expression output possible traces architecture phase pipeline paths get pipeline paths adl expression spec data transfers get data transfers adl expression spec decorated pps decorate pipeline paths pipeline paths traces append data transfers pipeline paths decorated pps data transfers return traces phase procedure decorate pipeline paths pipeline paths input pipeline paths output decorated pipeline paths pipeline path instruction format permutations resources implementing operands decorate resources add decorated pipeline path list decorated pps return list decorated pps procedure append data transfers pipeline paths decorated pps data transfers input decorated pps data transfers output traces decorated pipeline path permutations data transfers dt connected ports decorating append data transfers dt add list traces return list traces algorithm phase ii bind instructions traces input instruction opcode unit operands format traces architecture output rt instruction phase ii temp trace list find traces unit format traces unit format trace list temp trace list units support opcode opcode instruction format supported format return reservation table phase ii 
reservation tables generation algorithm phase generate traces phase ii traces stage pg stage ps stage pw stage pr stage dp stage dc stage rfb rfb rfa rfa connect stage rfa connect rfa 
resources stage trace highlighted order instruction format satisfied 
instruction opcode fu src src dst src src read dst written 
point choice traces corresponding instruction narrowed traces 
fully qualified instruction corresponds exactly trace represents rt instruction returned result algorithm 
example fully qualified instruction rfb rfa rfa trace returned rt shown 
input instruction phase ii fully qualified fu instruction executed specified result list possible rts 
rts guide compiler transformations fu allocation 
worst case complexity phase xz number pipeline paths number data transfers number distinct instruction formats processor maximum number operands instruction 
typically architectures maximum number instruction operands number formats 
choices considered 
considering choices data transfer particular operand corresponding operand type src fu assigned instruction chosen 
worst case complexity phase ii algorithm number traces architecture number fully qualified instructions 
time consuming part algorithm section discussion exploring different strategies trade computation time memory 
experiments set experiments conducted various processor descriptions illustrate utility algorithm 
section describes descriptions generated rts drive pipelined scheduling set multimedia scientific benchmarks 
arch 
expr 
pipeline dt traces rts time lines paths paths traces rts dlx dlx rf rf rf table 
rt generation table presents results rt generation algorithm ti processor multi issue version dlx processor 
context architectural design space exploration variants architecture show modifying features architecture register file architecture impacts number traces rts 
processor vliw dsp allowing operations issued cycle 
multi issue dlx architecture allows operations cycle pipeline stages units 
column table describes architectures rts generated automatically 
experimented single register file rf dlx rf version register file rf dlx rf architectures 
rf actual architecture shown register files partitioned limited connectivity fus rfs 
dlx rf contains register files connected functional units 
second column shows number expression lines specifying complete architecture including structure isa 
third column shows number pipeline paths fourth column shows number data transfer paths processors 
fifth sixth columns show number traces rts generated columns computation time needed automatically generate traces rts 
number traces architecture fairly limited 
hand rt corresponds fully qualified instruction number rts large dlx rf 
manually specifying rts operation basis tedious may lead increased errors specification 
furthermore simple changes architectural design space exploration may affect rts requiring rts approach need re specify architecture modified rts generated automatically 
rf dlx rf number rts 
hand register file versions increases 
due fact rf versions instructions may read operands possible locations leading larger number fully qualified instructions 
significant difference rts dlx rf rf due different rf architecture 
dlx operands instruction belong rfs rf restricted connectivity fus rfs precludes operand combinations 
section explore different strategies trading computation time memory requirement deal large number rts 
discussion recall generate rts phases extract set traces modeling execution patterns instructions second bind execution traces individual instructions order generate rts instruction basis 
separation concerns allows interesting trade offs time memory requirements rt generation 
expression description architecture phase extraction traces performed quickly seventh column table 
seen order seconds relatively complex architecture 
phase ii binding rts instructions time consuming step 
strategies varying time memory requirements 
called fly ot binds rts required tools 
second called precompute database binds rts instructions hand stores database 
third called cached modified approach rts generated demand stored database access 
strategies useful different scenarios tool usage compilers pipeline verification tools 
approach low memory requirement useful tool requires rts instructions compiling small application 
precompute database approach costly terms memory may faster rt computation time amortized iterations tool usage compiling applications architecture 
cached approach low memory time requirements particularly rts instructions application needed 
tool repeatedly requests rts small set instructions compiling domain specific applications 
explain utility strategies design space exploration dse environment 
presents language design methodology exploration embedded socs 
briefly dse occurs phases 
phase called exploration phase systems designer explores evaluates different processor candidates memory components discover promising configurations exploration refinement 
promising processor memory configurations identified designer proceeds refinement phase 
phase fine tunes candidate architectures various design objectives evaluating architecture extensive set benchmarks 
actual decision rt generation strategy depends size number applications chosen phase dse 
cached approach beneficial exploration phase objective perform rapid dse small set representative applications 
database approach useful refinement phase objective fine tune architecture larger set applications 
arch domain precompute db cached apps 
time time db size time db size array matrix dlx mm numeric mixed array matrix mm numeric mixed table 
rt generation strategies dlx ti table tradeoffs terms computation time memory requirement generation rts strategies 
ran algorithm sets benchmarks containing applications suite multimedia scientific applications containing filters wavelet image processing laplace edge enhancement numeric code linear recurrence equation solvers successive relaxation gauss seidel relaxation 
details please refer 
table column shows application domain number applications benchmark set 
column shows total time required generate rts fly parallelizing compiler 
columns show total time database size number rts needed precompute db approach columns show total time maximum database size cached approach 
expected time required generate rts naive approach large 
requires minimal memory store rts 
database approach works best compiling applications time db computation better amortized 
memory penalty large compared approaches 
cached version results significant time improvement compared memory reduction compared database 
dlx cached approach performs small sets benchmarks database approach performs better large sets 
possible improvements rt generation pursuing includes time required precompute rts time retrieve database 
include efficient database storage retrieval techniques incremental updating rt database architectural changes dse instruction conflict representations fsas conflict tables generated rts 
tiered approach automatic rt generation allows system designer experiment various approaches depending objectives dse 
combined benefits automatic rt generation flexible approach generation usage rts allows system designer significantly reduce time spent rt re specification architectural design space exploration 
summary reservation tables rt needed detect conflicts instructions instructions trying unit time 
rts long time drive scheduling compiler generate state diagrams driving dynamic scheduling hardware controller 
algorithm automatically generate rts architecture description processor 
approach bridges gap structural representation processors typically processor designers higher level information needed compilers 
traditionally detailed rts specified hand 
due increasing complexity today processors containing hundreds instructions extensive parallelism tic deep pipelines specifying rts hand laborious error prone task 
architectural exploration order keep compiler upto date processor designer needs reflect changes architecture rt specification 
tedious task 
automatically generating rts avoid need explicit specification support fast architectural exploration automatically reflecting changes architecture compiler 
set experiments ti vliw dsp dlx architecture 
prototype tool starts expression description generates rts express compiler 
rt generation strategies varying time memory requirements 
experiments show results set multimedia scientific kernels 
investigate rt generation strategies apply techniques wider class architectures 
acknowledge khare nick vijay ganesh contributions 
bala rubin 
efficient instruction scheduling finite state automata 

davidson 
design control pipelined function generators 
ieee conf 
snc pages mexico 
davidson 
reduced description preserves scheduling constraints 
pldi pages may 
davidson effective control pipelined processors 
ieee compcon pages san fransisco 
isdl instruction set description language retargetability 
proc 
dac 
gyllenhaal optimization machine descriptions efficient 

lowney multiflow trace scheduling compiler 
supercomputing 
unified code generation approach mutation scheduling 
code gen embedded processors 
kluwer 
lisa machine description language generic machine model hw sw design 
ieee workshop vlsi signal processing 

nml machine description formalism 
technical report tr sm imp dist tu berlin cs dept 
dutt nicolau 
automatic generation reservation tables architecture description 
technical report university california irvine 
ganesh khare dutt nicolau 
expression language architecture exploration compiler simulator retargetability 
proc 
date march 
hennessy patterson 
computer architecture quantitative approach 
morgan kaufmann san francisco 
khare dutt nicolau 
sat visual specification analysis tool system chip exploration 
proc 
euromicro october 

architecture pipelined computers 
mcgrawhill new york 
muchnick 
advanced compiler design implementation 
morgan kaufmann san francisco 
proebsting fraser 
detecting pipeline hazards quickly 
ppl january 
rau 
iterative modulo scheduling algorithm software pipelining loops 
proc 
th november 

processor description language supporting retargetable multi pipeline dsp program development tools 
proc 
isss december 
texas instruments 
tms cpu instruction set guide 
release www org 
user manual 

