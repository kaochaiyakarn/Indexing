pure type systems rewriting logic mark oliver stehr jos meseguer computer science laboratory sri international menlo park ca usa 
logical operational aspects rewriting logic logical framework illustrated detail representing pure type systems object logics 
precisely apply membership equational logic equational rewriting logic specify pure type systems literature new variant pure type systems explicit names solves problems closure conversion satisfactory way 
furthermore rewriting logic give formal operational description type checking directly serves ecient type checking algorithm 
reported part ambitious project concerned development maude proof assistant occ open calculus constructions equational extension calculus constructions 
detailed case study ease naturalness family higher order formal systems pure type systems pts represented rst order logical framework rewriting logic 
pts systems generalize cube contains important calculi 

system close logical framework lf combination calculus constructions cc 
pts systems considered key importance generality simplicity ideal basis representing higher order logics propositions types interpretation higher order logical framework spirit lf isabelle 
exploiting fact rewriting logic membership equational initial free models de ne representation pts systems parameterized theory framework logic de ne single parametric way representations nite family pts logics 
furthermore representational versatility rewriting logic membership equational logic exercised considering di erent representations pts systems di erent levels abstraction textbook version terms identi ed conversion concrete version calculus names explicit substitutions type checking inference system fact reasonably ecient implementation pts systems executing representation maude language 
concrete version basis proof assistant occ open calculus constructions equational extension calculus constructions development 
case study complements earlier showing rewriting logic properties logical framework represent wide range logics including linear logic horn logic equality rst order logic modal logics sequent presentations logics 
particular representations calculus binders quanti ers studied rst systematic study representation typed higher order systems 
property shared representations including discussed called representational distance logic formalized rewriting logic representation virtually zero 
syntax inference system object logic directly faithfully mirrored representation 
important advantage terms understandability representations making encoding decoding functions unnecessary called adequacy proof 
directness naturalness logics represented framework logic important quality logical framework scope applicability class logics faithful representations preserving relevant structure de ned 
typically want representations preserve re ect theoremhood theorem original logic translation proved framework representation logic 
mappings go di erent names di er generality higher order logical frameworks representations typically required adequate mappings theory general logics liberal conservative mappings entailment systems studied 
generalize conservative mappings notion 
stehr meseguer pure type systems rewriting logic sound complete total correspondence sentences entailment systems 
particular representations pts systems consider correspondences kind 
fact sound complete total correspondences systematically state correctness representations pts systems di erent levels abstraction relate di erent levels abstraction showing concrete representations correctly implement counterparts 
systematic way comparing scopes logical frameworks exhibit sound complete total correspondence representing correspondences form category compose shows scope general pure type systems include system close logical framework lf calculus constructions cc results indicate scope rewriting logic general logics 
furthermore adequate mappings linear logic lf sense conservative mapping logics linear logic rewriting logic indicate lf methodology restrictive notion adequate mapping specialized rewriting logic approach 
preliminaries entailment systems sections concerned variety di erent interrelated formal systems viewed entailment systems notion de ned main component general logics 
notion entailment system general needed purposes unary entailment systems 
unary entailment system sen set sentences sen unary entailment predicate sen maps sentences relate di erent logics 
introduce general notion morphism correspondence sentences di erent entailment systems 
sen sen unary entailment systems 
correspondence sen sen relation sen sen correspondence say sound implies similarly say complete implies 
called total sen correspondences compose obvious relational way giving rise category cent 
correspondence sentences sen sen takes form function sen sen case speak map sentences 
map entailment systems sense sound map sentences conservative map precisely sound complete map 
rewriting logic membership equational logic rewrite theory triple signature function symbols set equations set possibly conditional rewrite rules form terms applied modulo equations rewriting logic rules deduction infer possible rewrites provable rewrite theory 
equational theory regarded rewrite theory rules equational logic rewriting logic 
fact rewriting logic parameterized choice underlying equational logic unsorted sorted 
design maude language chosen membership equational logic mel underlying equational logic 
membership equational logic quite expressive 
sorts subsorts overloading function symbols express partiality directly de ning membership sort means equational conditions 
atomic sentences equalities memberships sort general sentences horn clauses atoms 
membership equational logic rewriting logic initial free models 
denote mel inclusion membership equational logic rewriting logic 
logics naturally represented rewrite theories de ning formulas proof theoretic structures sequents elements appropriate sorts data type speci ed equational theory 
inference rule logic axiomatized possibly conditional rewrite rule giving rise representation rewrite theory 
alternatively exploit rich sort structure membership equational logic represent inference rules logic rewrite rules pure type systems rewriting logic 
stehr meseguer horn clauses expressing membership adequate sort derivable sentences leading membership equational logic representation form 
forms representations di erent versions pts systems 
membership equational logic categorical initial model semantics provides general scheme inductive de nitions equational theories powerful free algebraic data types known functional programming languages 
rewriting logic generalizes equational logic gives initial semantics general scheme inductive de nitions rewrite systems 
overview main results section show de nition pts systems easily formalized membership equational logic 
approach specialized higher order logical framework lf isabelle explanatory power explain higher order calculi terms rst order system straightforward semantics 
order speci cation pts systems concrete introduce notion uniform pure type systems upts treatment names cinni new simple rst order calculus names substitutions 
upts systems solve problem closure conversion simple elegant way 
membership equational logic speci cation upts systems directly formalizes informal de nition 
intermediate step employ optimized version upts systems upts valid contexts upts vc 
system contains explicit judgement valid contexts seen re nement ecient implementation type checking 
describe meta operational aspects important class upts vc systems type checking type inference seen rewrite systems likewise formalized rewriting logic 
result formalization executable speci cation upts vc systems correct logical speci cation obvious way 
abbreviate rewriting presentation upts vc vc 
similar presentation basis proof assistant open calculus constructions mentioned 
formally di erent presentations pts systems families unary entailment systems parameterized pts speci cations 
notation pts upts upts vc vc denote entailment systems associated pts speci cation appropriate pts speci cations obtain chain sound complete correspondences pts upts upts vc vc di erent kinds connections rst entailment systems leading di erent correspondences form pts upts composing correspondences form nally arrive total sound complete correspondence pts vc shows equivalence high level speci cation pts implementation type checker 
internalizing derivability rewrite theory rewriting logic seen unary entailment system sen sentences form equation membership rewrite 
means derivable theory membership equational logic likewise seen unary entailment system obtained restricting membership equational logic theories equations memberships 
entailment systems pts upts upts vc vc easily speci ed membership equational logic rewriting logic 
speci cally total sound complete correspondences pts mel upts mel upts vc mel vc 
stehr meseguer pure type systems rewriting logic cases representational distance type system representation practically zero syntax inference system type theory directly faithfully represented framework logic 
rst correspondence representation pts systems membership equational logic section 
pts membership equational logic speci cation pts pts judgements pts possible representations membership equational logic sentence pts derivable membership equational logic judgement derivable pts de nes total sound complete correspondence form pts mel 
concerned correspondence map sentences due fact pts systems names membership equational logic representation names part description terms adding appropriate equations equivalent abstraction achieved membership equational logic 
remaining systems upts upts vc vc names 
associated representational correspondences take form conservative maps entailment systems judgement type system associate unique sentence membership equational logic rewriting logic respectively 
metalogical view pts pts speci cation triple set sorts set axioms set rules 
range pts speci cations 
pts systems priori distinction terms types 
pts pseudo terms de ned syntax binders fx agm ranges range terms ranges names 
add fx agm name bound assume convertible terms terms equal renaming bound variables identi ed 
pts pseudo context nite list declarations form 
empty context denoted concatenation written juxtaposition 
ranges pts contexts 
pts speci cation set derivable typing judgements form de ned inductively rules ax start weak fx agb pi fx agb lda fx agb mn app conv pure type systems rewriting logic 
stehr meseguer means standard metatheoretic operator substitution 
rule usual notion convertibility contains convertibility trivially satis ed presentation 
example instantiate pts systems fprop typeg prop type prop prop prop prop type type type prop prop type type type obtain calculus constructions cc 
presentation pts systems reasons rstly working modulo conversion identify equivalent terms secondly concerned inductive de nition set derivable judgements algorithm type check particular term 
mathematically presentation important bene allows reason pure type systems assuming concrete realization names 
leads general results frees proofs unnecessary technical details 
pts membership equational logic speci cations maude syntax logical semantics membership equational logic representing pts systems exactly operational version suited implementation discussed section 
notice plan describe single type system nite family type systems parameterized sorts axioms rules 
pts speci cations formalized models single parameter theory speci ed maude follows fth pts spec sorts sorts axioms axioms 
rules rules 
subsort axioms subsort rules op sorts sorts axioms 
op sorts sorts sorts rules 
example pts speci cation cc functional module fmod cc spec sorts sorts axioms axioms 
rules rules 
subsort axioms subsort rules op sorts sorts axioms 
op sorts sorts sorts rules 
op prop sorts op type sorts mb prop type axioms mb prop prop prop rules mb prop type type rules mb type prop prop rules mb type type type rules endfm pure type systems speci ed functional module parameterized theory pts spec 
functional modules initial case free model semantics formalization pts systems fact inductive de nition captures precise model theoretic way inductive character pts rules 

stehr meseguer pure type systems rewriting logic fmod pts par pts spec de ne sort trm terms algebraic data type 
notice distinguish sort identi ers qid places identi er declared sort variables var refer declared identi er 
sorts var trm subsort qid subsort var subsort sorts op trm trm trm op qid trm trm trm op qid trm trm trm vars sorts vars qid vars trm usual deterministic version capture free substitution naturally de ned membership equational logic demonstrated 
important point want restrict particular choice fresh names speci cation overly concrete 
accomplished leaving unspeci ed deterministic function choosing fresh variables actual function varies choice model details refer 
give signature set membership free variables substitution function op qid qidset bool op fv trm qidset op qid trm trm trm substitution operator semantically identify terms convertible refer induced equality equality means equations 
ceq fv ceq fv de ne binary relation convertibility conv rule pts systems 
conditional memberships initiality condition de ne conversion smallest congruence term constructors containing step reduction 
sorts convertible convertible 
subsort convertible op trm trm convertible 
mb convertible cmb convertible convertible cmb convertible convertible convertible cmb convertible convertible convertible cmb convertible convertible convertible cmb convertible convertible convertible mb convertible judgements pts systems form de ne syntax contexts judgements 
de ne function side conditions pts rules 
pure type systems rewriting logic 
stehr meseguer sorts context judgement op context op qid trm context op context context context assoc id var context op context trm trm judgement op qid context bool eq false eq ready de ne inference rules 
formally inference rules de ne inductive subset derivable judgements 
derivability predicate usually implicit informal reasoning refers judgement fact derivable 
sort derivable subsort derivable cmb derivable axioms cmb derivable derivable cmb derivable derivable derivable cmb derivable derivable derivable rules cmb derivable derivable derivable derivable rules cmb derivable derivable derivable cmb derivable derivable derivable convertible endfm formalization avoided arbitrary encoding syntax binders require nontrivial justi cations 
seen rst order framework suciently powerful represent pts systems making commitments 
particular need change syntax rules pts systems obtain faithful representation 
names seriously treatment names pts systems leads general metatheory high level theoretical basis quite di erent implementations pts systems price paid view necessarily limits expressivity theory 
need concrete representation specialized results deal example implementation 
stehr meseguer pure type systems rewriting logic formal system tools formal system essential way 
reasoning formal system concrete speci cation computationally meaningful necessary useful formalizations constructive type theories logics computational sublanguages 
soon give identi cation convertible terms take inference rules literally encounter problems rst pointed 
rst problem set derivable judgements closed conversion 
instance adapting example 
derive judgment form prop fz px fx say cc equivalent version bound variables distinct derived 
second diculty reported want derive prop fz px fx px able derive prop fz px fx px derive rst judgement name lda rule sides colon 
tackle rst problem pollack proposed type system lt variation 
uses liberal notion context allows multiple declarations identi er visible inside judgement 
unfortunately pursue direction second diculty appears context pts systems dependent types 
concerning lt remarks don think pts 
solution nally discussed solution employed constructive engine proof assistants lego coq formalized rigorously 
idea hybrid naming scheme employs distinct names global variables declared context judgement de bruijn representation terms bound local variables 
clearly pts systems hybrid naming scheme correct implementation pts systems described 
precisely pts systems hybrid naming scheme seen particular models membership logic speci cation pts systems sense corresponding model isomorphic appropriately instantiated functional module pts 
approach maintains distinction global local variables appears uniform complicating formal metatheoretic proofs type checking 
course scaling pollack lt pts systems satisfying direction pursue 
indexed names named indices believe root second diculty discussed traditional notion binding logic programming reveals undesirable property may called accidental hiding language re ned direct way giving identi cation conversion 
consider instance formula distinct names formula contains free 
occurrence captured inner quanti er outer quanti er hidden viewpoint 
way refer outer quanti er 
faced problem calculus equality unavoidable consequence giving identi cation conversion depending accidental problem conversion remains unsolved system dependent types enjoy property 
pure type systems rewriting logic 
stehr meseguer choice names visibility bound variables may restricted 
important visibility restricted original calculus equality renaming performed tacitly time 
clearly phenomenon hiding occurs example undesirable original calculus equality 
merely accident caused giving identi cation conversion adding compensating exibility language 
suggests tackling general problem migrating exible syntax express binding constraint annotating identi er index written indicates binders skipped reach refers 
instance write express bound inner meaning bound outer 
language conservative extension traditional notation identify generalized syntax called cinni syntax cinni refers calculus indexed names named indices new simple calculus explicit substitutions introduced section 
appear similarity notation de bruijn indices 
notice essential di erence index occurrence xm number binders skipped states skip binders particular name counting binders names 
formal relation de bruijn notation established restrict terms contain single name replace index loss information arrive de bruijn purely indexed notation 
words restrict available identi ers single obtain de bruijn notation special case 
sense cinni syntax formally seen proper generalization de bruijn notation 
pragmatically relation de bruijn syntax plays minor role typical user exploit dimension names dimension indices 
practice notation standard named notation additional advantage accidental hiding weird renamings avoided 
pragmatic advantage cinni notation reduce distance formal system implementation directly employed user wants think terms names need translation internal representation de bruijn indices user friendly syntax ordinary names disappears completely 
far know cinni substitution calculus rst calculus explicit substitutions combines named index representations provides link worlds explicit substitution calculi 
explicit substitutions far simple rst order syntax expressions contains conventional named notation de bruijn indexed notation special cases 
important operation performed terms capture free substitution 
cinni substitution calculus 
strictly speaking cinni family explicit substitution parameterized syntax including information binding language want represent 
instantiation substitution calculus untyped calculus terms cinni syntax xm motivation substitution calculus consider example reduction step traditional calculus distinct names names literally identi cation conversion course general hiding important issue binding treated independently 
slight di erence de bruijn indices start 
see discussion weird renaming section 

stehr meseguer pure type systems rewriting logic clearly identi er di erent avoid capturing 
unfortunately canonical choice identi ers treated equal 
call phenomenon weird renaming bound variables 
combination undesirable ects names carefully chosen user changed enforced choice new name collides right names treated equal citizens 
ects avoided cinni calculus instantiated calculus 
speci ed rstorder equational theory 
operation assumed names equality 
cinni operational semantics viewing equations rewrite rules 
apart basic kinds substitutions simple substitutions shift substitutions substitutions lifted variable ranges substitutions 
xm xm yn yn xm xm yn yn xm xm yn yn mn sm sn instantiate cinni calculus give concrete treatment di erent formal systems 
equations speci syntax language structural equations 
equations right column structural equations calculus 
de ne reduction rule notice weird renaming bound variables previous example avoided new notion reduction 
application substitution consider renaming bound variable rule reduction 
arbitrary xed name 
rule cinni term reduced nameless normal form essentially de bruijn index representation 
terms denote equal renaming bound variables 
just cinni syntax contains de bruijn indexed notation special case instantiation cinni calculus reduces calculus explicit substitutions proposed pierre lescanne degenerate case admit single identi er 
noteworthy smallest known indexed substitution calculus enjoying theoretical properties con uence preservation strong normalization 
simplicity inherited cinni practice dimension names important dimension indices 
tend think cinni substitution calculus names indices 
uniform pure type systems application cinni pts turns surprisingly simple leads system seen pollack lt scaled pts systems 
contrast hybrid approach pts systems adopted constructive engine formalization distinguishing global local variables indexed identi ers uniformly 
suggests de ning uniform pure type systems upts modifying pts steps pure type systems rewriting logic 
stehr meseguer pts terms generalized upts terms way explained upts pseudo terms rst order cinni syntax xm fx agm second step adapt syntax dependent part cinni calculus upts terms mn sm sn fx agm fx third nal step de ne derivable typing judgements 
want identify equivalent terms fundamental change formal system 
careful inspection typing rules new reading shows minor changes rules start weak needed 
new rules xa start xm xa weak appear upts systems de ned specialization pts systems committed particular representation names 
full truth hand described generalization pts systems names may occur multiple times context 
notice rules dropped side condition means completely eliminated need side conditions upts systems 
point particular touched lda rule place conversion comes play conv rule subsumes conversion just original pts systems 
describe changes re ected membership equational logic speci cation 
identi ers variables indexed identi ers 
replace subsort qid op qid nat var second conventional substitution cinni upts terms sort subst op qid trm subst op shift qid subst op lift qid subst subst op subst trm trm var subst vars nat eq eq suc ceq eq shift suc ceq shift eq lift eq lift suc shift 
stehr meseguer pure type systems rewriting logic ceq lift shift eq eq eq lift eq lift third conversion explicitly contains conversion implicit equality previous speci cation mb shift convertible mb shift convertible new versions start weak cmb shift derivable derivable cmb shift shift derivable derivable derivable see representational distance mathematical presentation upts systems membership equational logic speci cation practically zero 
particular equational nature cinni substitution calculus directly captured membership equational logic speci cation 
upts liberal pts derivable judgement may contain multiple declarations identi er set derivable judgments pts recovered set derivable upts judgements generated adding rule variable declared 
representation judgements rule membership equational logic straightforward omit formalizations sake brevity 
terminology introduced section entailment systems propositions establishes total sound complete correspondence form pts upts arbitrary pts speci cation 
proposition soundness completeness upts pts terms pts contexts pts judgement derivable upts derivable pts vice versa 
proposition implies upts systems conservative pts systems 
slightly weaker comprehensive correspondence pts upts modulo renaming variables 
purpose extend renaming equivalence judgements equal renaming declared bound variables 
proposition soundness completeness upts ii upts terms pts terms upts contexts pts contexts upts judgement derivable upts derivable pts vice versa 
proposition implies concerning judgements form pts upts equivalent modulo equivalence 
metatheoretic results pts apply upts renaming 
convention introduced section ordinary terms pts terms seen cinni terms upts terms 
pure type systems rewriting logic 
stehr meseguer proposition implies new form judgement necessary ensure soundness dropped 
judgements form convenient formulate thinning lemma contexts multiple declarations name treated sets 
kinds judgements useful metatheoretic reasoning 
conservative optimization presentations pure type systems pts upts maintain economy number rules suited metatheoretic inductive reasoning judgement implicitly subsumes judgement stating typed context 
practice checking contexts important checking types switch conservative extension upts systems biased forms judgement 
practical point view addition separate judgement valid contexts seen optimization avoids unnecessary contexts subderivation 
refer optimized type system upts valid contexts upts vc 
modi cations need described 
judgements form valid context weak typing strong typing add rules xm lookup xm lookup xm 
lookup ctxt denotes failure lookup xm de ned lookup xm lookup xa lookup xm lookup xm lookup ym lookup ym replace ax ax variable declared 
respectively remove rules start weak admissible rules new system 
system just obtained similar system vcxt concerned upts systems pts systems minor di erence explicit lookup function 
freshness side conditions eliminated cinni 
representation membership equational logic quite direct 
nicely illustrates mixed speci cation style equations memberships sort trm 
subsort trm op trm 
op lookup context var trm 
eq lookup eq lookup shift 
stehr meseguer pure type systems rewriting logic eq lookup suc shift lookup ceq lookup lookup op context judgement op context trm trm judgement op context trm trm judgement mb derivable cmb derivable derivable derivable cmb lookup derivable lookup cmb derivable derivable derivable cmb derivable axioms upts vc equivalent upts total sound complete correspondence kind upts upts vc arbitrary pts speci cations sense proposition soundness completeness upts vc upts terms upts context 
judgement derivable upts vc derivable upts vice versa 
proposition similar lemma considering upts pts systems 
meta operational view pts pts systems equipped logical semantics proposition types interpretation fundamentally pts systems usually equipped operational semantics de ned internal notion functional computation reduction 
operational view pts systems concerned internal notion computation interested meta operational view deals question embed pts systems formal system operational semantics typical computational tasks type checking type inference possible exploiting operational semantics metalanguage 
employ purpose eciently executable sublanguage rewriting logic supported maude 
introduce classes pts speci cations giving rise corresponding pts systems practically interesting enjoy properties 
de nition pts speci cation decidable denumerable decidable predicates decidable 
decidability pts speci cation reasonable requirement ensure type inference type checking undecidable complex speci cation de nition pts speci cation functional implies implies functional pts speci cations relations viewed functions 
functionality ensures term unique type conversion 
class functional pts systems includes example systems cube 
course careful pts systems inconsistent propositions types interpretation 
attributes pts speci cations naturally lifted corresponding entailment systems 
pure type systems rewriting logic 
stehr meseguer de nition pts speci cation full pts speci cation semi full implies full pts systems allow form fx agb types liberally avoiding restrictions sorts imposed side condition pi rule 
example cc full pts system 
de nition pts speci cation top sort sort sort set top sorts denoted top top empty 
pts disallow top sorts introduce kind non uniformity set sorts 
just full pts speci cations seen function functional pts speci cations viewed function semi full pts systems nice property get rid third premise lda rule replacing rule fx agb top lda premises side conditions lda imply fx agb formed type cf 
rule pi 
explained context pts systems replacing lda lda change set derivable judgements semi full upts systems 
full upts systems eliminate side conditions rule lda obtain lda changing set derivable judgements fx agb lda calculus constructions type top sort 
straightforward extend cc nite universe hierarchy yielding pts 
upts previous section families inference systems di er choice rule lda 
full pts speci cation de ne unary entailment system denoted upts remainder type checking algorithm class upts rewriting logic formal speci cation language 
type checking pts trivial spite unsolved theoretical questions expansion postponement problem ecient algorithms important classes functional pts semi full pts satisfying appropriate decidability normalization properties 
order avoid excessive technical details clear general way rewriting logic represent type checking algorithms restrict upts decidable normalizing functional full 
class upts systems decidable normalizing functional semi full treated lines rule lda lda 
upts pts motivated desire obtain formal representation takes names seriously type checking uniform 
di erent uses names informally presentation purposes assumes identi cation conversion justi ed formalization abstracts local names representing de bruijn indices 
upts membership equational logic standard way implement type checking cast inference rules equivalent syntax directed inductive de nition de ne type inference function basis new system 
formally technically done executable sublanguage membership equational logic functional programming language membership equational logic attractive allows formulate logical operational versions pts systems single uniform language extremely reduction 
stehr meseguer pure type systems rewriting logic simple semantics particular presuppose higher order constructs explain elementary terms 
data structures functions speci cation directly implementation 
setting reason membership equational logic natural higherorder functional programming language equational speci cation calculus substitutions naturally equipped operational semantics just viewing equations rewrite rules 
contrast functional programming language equational rewriting substitution calculus encoded essentially means specialized rewrite engine calculus implemented functional language cumbersome engine explicitly invoked needed 
sense speci cation programming style rewriting closer mathematical practice applications kind higher order functional programming approach 
speci cation substitution calculus purely equational executable speci cation type checker upts systems decidable type checking written membership equational logic standard equational functional programming techniques 
core speci cation consists type inference function op type context trm trm 
computes type typable term yields 
function de ned way similar cinni abstracting treatment names 
cinni freshness conditions avoided 
implementation speci cation appears elegant constructive engine hybrid treatment names 
additional advantage multiple declarations identi er naturally admitted contexts judgement 
easy disallow general contexts desired implementing conventional judgement 
discussing purely equational approach detail alternative approach section exploits features rewriting logic equational functional languages 
experience shows alternative approach scales complex type theories extensions upts systems satisfactory way purely functional equational approaches type checking 
upts rewriting logic shown extensive collection examples rewriting logic logical framework naturally represent inference systems di erent kinds logically operationally satisfying way 
section view type checker particular inference system 
contrast higher order functional programming approach require encode inference system terms type checking function rewriting logic approach ers clear advantage inference rules expressed directly rewrite rules 
fact type inference system expressed collection rewrite rules transform conjunction judgements simpli ed form style constraint solving systems 
yields rewrite system eciently executable maintaining close correspondence logical speci cation upts systems 
rewriting logic speci cation represents vc systems able perform type checking decide derivability judgements form class decidable normalizing functional full upts vc systems discussed 
pts systems type checking reduces type inference solving incomplete queries form giving informal account directly discuss formal speci cation rewriting logic 
exploit assumption pts speci cation decidable functional full means relations speci ed equationally de ned functions axioms rules pure type systems rewriting logic 
stehr meseguer fth pts spec sort sorts op axioms sorts sorts op rules sorts sorts sorts syntax directed approach invert inference rules order obtain goal directed algorithm generating inductive de nition 
contrast purely equational functional approach rewriting logic speci cation aim rewrite transition systems models seen operational generalization equational functional paradigms 
contrast typechecking algorithm receives direct formal status prerequisite reasoning formally correctness 
inductive de nition upts systems membership equational logic seen static description set judgements equip dynamic interpretation 
precisely static logical implication 
seen inference rule dynamic state transition re ning goal subgoals directly represented rewrite rule 
rewriting logic 
state consists nite set subgoals remain solved 
static description seen inducing invariant dynamic system satisfy state empty set goals reachable logical interpretation static description state true 
inference rules formal system typically take form horn clauses operationally re ned rewrite rules may functional equational parts auxiliary functions substitution calculi naturally expressed membership equational logic fragment 
mix di erent paradigms uniform framework allows express type checking algorithm way close logical speci cation 
re ned speci cation number auxiliary judgements judgement meaning sort rule literally normalizing mn discuss rewriting logic speci cation upts type checker detail 
purely functional module introduced fmod speci cation takes form system module introduced mod rewrite system initial semantics mod pts par pts spec reuse components functional module de ned add auxiliary judgements op sort trm judgement op rule trm trm trm judgement op trm trm judgement op trm trm judgement op context trm trm judgement op context trm trm trm trm trm judgement 
stehr meseguer pure type systems rewriting logic order express intermediate goals queries operational re nement presentation extend terms explicit metavariables sort subsort op qid var weak head normal form calculated function whnf ecient way check term convertible form fx agm sorts whnf containing terms weak head normal form weak head reducible terms respectively 
sake brevity omit straightforward de nitions membership equational logic 
sort whnf subsort whnf subsort op whnf trm trm 
con guration conjunctive set judgements solved veri ed type checker sort op subsort judgement op assoc comm id var js sort configuration op configuration replacement metavariables terms textual replacement obvious de nition spelled syntax op trm trm trm op trm subst subst op trm context context op trm judgement judgement op trm rule instantiates metavariable entire con guration uniquely determined equality rl js js rule typical constraint programming approach con guration seen set constraints simpli ed subsequent rules 
detecting inconsistency goal eliminate constraints 
addition simpli cation constraints general rewrite rules simpli cation equational rewriting plays major role approach 
example judgement convertibility normalizing terms checked follows 
order avoid redundant reductions reduce general problem checking convertibility weak head normal forms treated rules 
case binders perform renaming equalize names 
pure type systems rewriting logic 
stehr meseguer rl crl whnf crl whnf crl whnf whnf rl shift rl shift auxiliary judgements implement side conditions rl sort rl rule rules inference rule upts vc systems gives rise rewrite rule obtained reversing direction inference rl axioms crl lookup lookup rl new new new new rule rl new new sort new new rl new new new new rl terms new new denote fresh metavariables 
rewriting controlled simple strategy constraints possible rewrites instantiating variables new new fresh identi ers time rule applied 
notice contrast ordinary variables names taken seriously care metavariable names formal status inside upts systems belong metalevel 
explanations new judgements certain conversion closure properties 
partial normalization rules allow normalized judgements rules crl sort whnf sort crl rule whnf rule crl rule whnf rule crl whnf completes de nition type inference system judgements form goal de ne operational counterpart give type checking algorithm reduce type checking type inference standard way conditional rules straightforward re nement speci cation obtain system takes metavariables seriously necessary purpose 

stehr meseguer pure type systems rewriting logic crl new new sort crl new new new rules constitute operational formulation lemma characterization pts proved pts 
add rules reversed form check valid contexts strong typing judgement rl crl new new sort crl endm omitted straightforward rule corresponding allows check derivability strong judgements disallow multiple occurrences variable verify judgement start initial con guration 
con guration reduced meaning judgement proved nal con guration contains unsolved constraints seen informative indication type checking error 
notice inductive de nitions specify pts systems upts systems logically addition operational version upts systems rewrite rules essentially inductive de nition rewrite system gives re ned view type checking process 
important property type checker soundness 
soundness rewrite rules obvious veri ed inspection user algorithm obtain con dence correctness resorting dicult proofs 
range decidable normalizing functional full pts speci cations 
vc denotes rewrite version upts vc terms rewriting logic 
proposition gives sound complete correspondence upts vc vc proposition soundness completeness vc upts terms upts context judgements sentence derivable vc derivable upts vc vice versa 
completeness stated immediately imply completeness implementation rewrite theory usually executed strategy restricts rewrites chosen 
ideally case speci cation additional restriction strategy freshness requirement metavariables mentioned 
give presentations pts systems di erent levels abstraction 
discussed natural representations systems membership equational logic rewriting logic 
abstractions representations uniformly captured notion correspondence entailment systems 
apart general contribution demonstrates pure type systems formally speci ed rewriting logic logical framework technical contributions cinni pure type systems rewriting logic 
stehr meseguer simple general calculus explicit substitutions upts new variant pure type systems seen new approach problems closure conversion systems dependent types 
furthermore point techniques currently applied design implementation proof assistant occ open calculus constructions extension calculus constructions incorporates equational logic computational sublanguage 
similar membership equational logic occ supports conditional equations conditional assertions operational semantics conditional rewriting modulo equations 
maude rewriting engine re ective capabilities developed modest amount ort experimental version proof assistant occ acceptable performance ideas cinni upts 
conclude emphasized representational aspects choice right formal representation important right attempts give formal proofs 
interesting properties require complex proofs 
example soundness property easy verify speci cation techniques employed 
hand membership equational logic rewriting logic initial model semantics provide general notions equational inductive de nitions fact exploited representing inductively de ned formal systems 
remaining problem carrying proofs closed formal systems completeness proofs example requires development useful induction principles basis possibly di erent related presentations formal system 
appropriate induction principles formulated higherorder logic simply formal system occ metalogic re ective techniques cf 
approach re ective metalogical frameworks 
support darpa nasa contract nas oce naval research contract national science foundation ccr daad scope hsp iii gratefully acknowledged 
francisco dur steven eker help concerning theory practice maude furthermore manuel clavel narciso mart oliet anonymous referees constructive criticism 
barendregt 
lambda calculi types 
abramsky gabbay maibaum editors background computational structures volume handbook logic computer science 
oxford clarendon press 
basin clavel meseguer 
re ective metalogical frameworks 
appear proc 
workshop logical frameworks meta languages september paris france 
benaissa lescanne degli 
calculus explicit substitutions preserves strong normalisation 
journal functional programming september 
berardi 
mathematical analysis coquand huet calculus constructions systems barendregt cube 
technical report carnegie mellon university universita di torino 

jouannaud meseguer 
speci cation proof membership equational logic 
bidoit dauchet editors tapsoft theory practice software development th int 
joint conf 
caap fase lille france april proceedings volume lncs 
springer verlag 
church 
formulation simple theory types 
journal symbolic logic 
clavel dur eker lincoln mart oliet meseguer quesada 
maude speci cation programming rewriting logic 
sri international january maude csl sri com 
coquand huet 
calculus constructions 
information computation 
de bruijn 
lambda calculus nameless dummies tool automatic formula manipulation application church rosser theorem 
proc 


akademie van volume pages 
gardner 
representing logics type theory 
phd thesis university edinburgh 

stehr meseguer pure type systems rewriting logic geuvers 
logics type systems 
phd thesis university nijmegen 
girard 
interpretation fonctionelle elimination des coupures dans ordre 
phd thesis universit paris vii 
harper honsell plotkin 
framework de ning logics 
second annual symposium logic computer science pages ithaca new york june 
ieee computer society 
huet 
constructive engine 
narasimhan editor perspective theoretical computer science 
world scienti publishing 
huet paulin mohring coq proof manual version coq project 
technical report inria 
pauillac inria fr coq 
lescanne 
journey calculi explicit substitutions 
hans boehm editor proc 
st annual acm principles programming languages portland usa pages 
acm 
lescanne degli 
calculus explicit substitutions 
technical report rr january 
luo pollack 
lego proof development system user manual 
lfcs technical report ecs lfcs university edinburgh 

implementation alf proof editor martin monomorphic type theory explicit substitutions 
phd thesis university dept computer science 
mart oliet meseguer 
rewriting logic logical semantic framework 
technical report sri csl sri international computer science laboratory august 
appear gabbay ed handbook philosophical logic kluwer academic publishers 
mart oliet meseguer 
general logics logical frameworks 
gabbay editor logical system pages 
oxford university press 
mart oliet meseguer 
rewriting logic logical semantic framework 
meseguer editor proc 
intl 
workshop rewriting logic applications volume electronic notes theoretical computer science 
elsevier 
www elsevier nl cas tree store tcs free pc volume htm 
mckinna pollack 
pure type systems formalized 
bezem groote editors international conference typed lambda calculi applications tlca utrecht netherlands march volume lncs 
meseguer 
general logics 

ebbinghaus editors proceedings logic colloquium pages 
north holland 
meseguer 
conditional rewriting logic uni ed model concurrency 
theoretical computer science 
paulson 
isabelle volume lncs 
springer verlag 
pollack 
closure alpha conversion 
henk barendregt tobias nipkow editors types proofs programs international workshop types nijmegen may selected papers volume lncs pages 
springer verlag 
pollack 
veri ed typechecker 
dezani ciancaglini plotkin editors second international conference typed lambda calculi applications edinburgh uk april volume lncs 
springer verlag 
reynolds 
theory type structure 
programming symposium paris volume lncs 
springerverlag 

normalization lambda calculus relation type inference 
phd thesis eindhoven university technology 

stehr 
cinni new calculus explicit substitutions application pure type systems 
manuscript csl sri international menlo park ca usa 

een analyse van 
manuscript university nijmegen netherlands 
van benthem jutting 
typing pure type systems 
information computation 
van benthem jutting mckinna pollack 
checking algorithms pure type systems 
henk barendregt tobias nipkow editors types proofs programs international workshop types nijmegen may selected papers volume lncs pages 
springer verlag 
