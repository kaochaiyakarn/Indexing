automatic structures achim erich mathematische grundlagen der informatik rwth aachen blume informatik rwth aachen de study definability complexity issues automatic automatic structures 
general infinite structures finitely collection automata 
admit effective fact automatic evaluation order queries 
automatic structures provide interesting framework extending algorithmic logical methods finite structures infinite ones 
explain notion automatic structures give examples discuss relationship automatic groups 
determine complexity model checking query evaluation automatic structures fragments firstorder logic 
study closure properties definability issues automatic structures technique proving structure automatic 
give model theoretic characterisations automatic structures interpretations 
discuss composition theory automatic structures prove closed finitary feferman products 

relationship logical definability computational complexity important issue number different fields including finite model theory databases knowledge representation computer aided verification 
far research devoted finite structures relationship definability complexity fairly understood see applications particular database theory 
cases limitation finite structures restrictive 
fields mentioned considerable efforts extend methodology finite structures suitable classes infinite ones 
particular case databases computer aided verification infinite structures constraint databases systems infinite state spaces increasing importance 
general theoretical point view may ask classes infinite structures suitable extension 
specifically conditions satisfied class necessarily finite structures approach methods finite model theory sense 
obvious fundamental conditions finite representations 
structure representable finite way 
effective semantics relevant logic order logic 
formula presentation structure effectively produce presentation set note effective semantics means particular theory decidable 
class infinite structures studied quite intensively model theory recursive structures 
papers proposing study recursive structures recursive databases issues just mentioned 
class recursive structures large general quantifier free formulae admit effective evaluation algorithms 
classes infinite structures relationship definability complexity studied include metafinite structures constraint databases 
consider automatic structures 
automatic groups studied intensively computational group theory see general notion automatic structure defined investigated khoussainov nerode theory structures developed 
informally relational structure rm automatic universe relations finite automata 
means find regular language provides names elements function mapping word element represents 
function surjective element named need injective elements name 
addition recognisable finite automata words name elements relation tuple words names tuple belonging detailed definition section 
believe automatic structures promising approach sketched 
automatic structures admit finite presentations numerous interesting examples large body methods developed decades automata theory 
contrary class recursive structures automatic structures admit effective fact automatic evaluation order queries possess pleasant algorithmic properties 
notion automatic structure modified generalised directions instance automata infinite words finite infinite trees 
study automatic automatic structures 
results extended tree automatic structures change see lack space mention 
outline 
section define notions automatic automatic structures mention examples 
purposes important examples automatic structures expansions presburger arithmetic restricted divisibility predicate tree structures tree 
fundamental examples automatic structures expansion additive real group order restricted divisibility tree natural extension tree 
explain section notion automatic group 
section show order logic fact extension quantifier exist infinitely effective semantics automatic structures 
study complexity results model checking order logic fragments 
section study definability properties automatic structures technique proving structure automatic 
application prove instance skolem arithmetic 
divisibility poset automatic 
section model theoretic characterisations automatic automatic structures 
prove structure automatic interpretable equivalently tree 
similarly structure automatic interpretable tree 
section characterisation study composition theory automatic structures 
prove automatic structures closed finitary products unions similar constructions 
goal significant new contributions automata theory 
main technical contributions algorithm evaluate quantifier exists infinitely complexity results low level fragments order logic automatic structures proofs certain interesting structures automatic particular composition theorem automatic structures 
main purpose conceptual want explore extent automatic structures suitable framework extending methods finite model theory infinite structures 
believe model theoretic characterizations automatic automatic structures terms interpretability particularly useful suggest general way obtaining interesting classes infinite structures suitable approach fix structure nice algorithmic model theoretic properties consider class structures order interpretable obviously structure class finitely presentable interpretation 
nice properties preserved order interpretations structure class inherits particular class queries effective closed order operations effective interpretation closure 
automatic structures automatic groups assume reader familiar basic notions automata theory regular languages 
slightly nonstandard aspect need notion regularity just languages ary relations words 
idea regular relations defined automata take tuples words inputs synchronously components precise represent tuple word alphabet called convolution padding symbol belonging appended words sure components length 
formally 
jw jg 

jw 
relation called automatic regular fw rg regular language 
sequel distinguish relation words encoding language 
usual mathematical logic consider structures non empty set called universe relation function names relations functions arities form vocabulary consider constants functions arity 
relational structure structure functions 
associate structure relational variant obtained replacing function graph bg 
definition 
relational structure automatic exist regular language surjective function relation nw nw predicates relations nw nw rg regular 
arbitrary necessarily relational structure automatic relational variant automatic presentation structure mean pair consisting function collection finite automata recognise relations mean just collection 
note determines structure presents isomorphism 
automatic presentation called deterministic automata called injective implies injective 
write class automatic structures vocabulary examples 
finite structures automatic 
important examples automatic structures presburger arithmetic expansions relation iff power dividing ary encodings starting significant digit difficult construct automata recognizing equality addition 
natural candidates automatic structures consisting words 
note free monoids generators automatic presentations 
fix alphabet consider structure tree el xa iff xz el iff jxj jyj obviously structure automatic 
observations simple useful 
automatic structure admits automatic presentation alphabet 
automatic structure admits injective automatic presentation 
automatic groups 
class automatic structures studied intensively automatic groups 

group fs set semigroup generators means written product 
elements canonical homomorphism surjective 
cayley graph respect graph sm vertices group elements set pairs 
definition 
automatic finite set semigroup generators regular language restriction surjective provides automatic presentation 
inverse image equality nw nw regular 
note group structure 
automatic sense definition cayley graph 
natural examples automatic groups see 
importance notion computational group theory comes fact automatic presentation group yields efficient algorithmic solutions computational problems undecidable general case 

definition automatic group set semigroup generators cayley graph automatic structure 
contrary claim clear converse holds 
definition automatic group requires function restriction canonical homomorphism mere condition automatic structure imply 
automatic structures 
notion automatic structure modified generalised number different directions see 
particular obtain interesting class automatic structures 
definition analogous automatic structures elements automatic structure named infinite words regular language relations structure recognisable automata 
examples 
automatic structures automatic 
real numbers addition expanded structure automatic iff kx tree automatic structures tree extend natural way uncountable automatic structures tree el 

model checking query evaluation section study decidability complexity issues automatic structures 
structure formula relation query defined fundamental algorithmic problems model checking presentation structure formula tuple parameters decide 
query evaluation presentation structure formula compute presentation 
pair representing construct automaton recognises 
observe order queries automatic structures effectively computable 
fact case order logic formulae containing quantifier meaning infinitely 
proposition 
injective presentation automatic automatic structure formula fo effectively construct automaton recognising 
proof 
fo formulae follows readily classical results closure properties regular languages 
case automatic structures quantifier handled pumping argument 
consider simplicity formula xy 
infinitely satisfying iff infinitely elements encoding symbols longer take number states automaton pumping lemma condition equivalent existence xy long obviously construct automaton 
note injectivity ensures infinitely words encodes different element automatic structures proof involved 
introduce notation 
denote factor similarly equal 
deterministic automaton states recognising language fv define iff fv vg class 
claim 
infinite infinite 
proof 
trivial proved showing contains finite classes 
assume belonging different finite classes 
denote run sequence states define fk states indices infinite 
position maximum fix infinite 
position 
choose 
iff implies contradiction choice finish proof yy automatic 
express finite finite equal equal clearly equal recognised automata 
claim finite construct automaton recognising corollary 
fo theory automatic structure automatic injective presentation decidable 
immediate consequence conclude full arithmetic 
automatic automatic 
common extensions order logic finite model theory transitive closure logics fixed point logics monadic second order logic firstorder logic counting model checking problem automatic structures undecidable 
complexity 
consider structure expression combined complexity model checking respectively dependence input structure formula parts measured remaining parts input considered fixed 
course complexity problems may depend automatic structures 
focus presentations deterministic automata admit boolean operations performed polynomial time nondeterministic automata complementation may cause exponential blowup 
assume vocabulary automatic structures alphabet automata deal fixed 
furthermore vocabulary assumed relational stated 
deterministic presentation automatic structure denote jdj maximal size automata automatic presentation structure define function minf jxj ag mapping element length shortest encoding 
abbreviation seen query evaluation model checking order formulae effective complexity problems non elementary exceeds fixed number iterations exponential function 
follows immediately fact complexity th non elementary see 
proposition 
exist automatic structures expression complexity model checking problem non elementary 
turns model checking query evaluation quantifier free existential formulae extent tractable 
usual denote respectively class quantifier free class existential order formulae 
theorem 
presentation relational structure tuple formula fo model checking problem dtime jdj log jdj dspace log jjj log jdj ii structure complexity model checking quantifier free formulae logspace complete respect fo reductions 
iii expression complexity complete regard deterministic log time reductions 
proof 
decide holds need know truth value atom appearing remains evaluate boolean formula done dtime jjj atime log jjj dspace log jjj see 
value atom calculated simulating corresponding automaton components belong variables appearing nave algorithm uses time jdj log jdj space log jdj time complexity bound perform simulation atom store outcome evaluate formula 
jjj atoms claim follows 
obtain space bound store value atom 
logspace algorithm evaluate time value atom needed simulate run corresponding automaton separate set tapes 
ii reduction logspace complete problem reachability deterministic paths see model checking problem 
graph construct automaton ftg remove edges originating vertices degree greater add loop deterministic path iff accepts word iff jv 
iff jv structure presentation 
closer inspection reveals transformation defined order logic 
iii evaluation boolean formulae see 
questions restrict attention relational vocabularies replace functions graphs expense introducing additional quantifiers 
studying quantifier free formulae want need consider case quantifier free formulae function symbols 
class denoted fun 
lemma epstein 
tuple words automaton recognising graph function calculation dtime jqj log jqj jqj jwj dspace jqj log jwj proof 
ideas implement algorithms complexity bounds 
see details 
theorem 
vocabulary may contain functions 
presentation structure tuple quantifier free formula fo model checking problem dtime jjj jdj log jdj jjj jdj dspace jjj jjj jdj jdj log jdj ii structure complexity model checking problem quantifier free formulae functions nlogspace 
iii expression complexity ptime complete regard log reductions 
proof 
algorithm proceeds steps 
values functions appearing calculated starting innermost 
functions replaced values formula containing relations remains evaluated 
need evaluate jjj functions 
nested result length jjj jdj 
yields bounds 
ii sufficient nondeterministic logspace algorithm evaluating single fixed atom containing functions 
algorithm simultaneously simulates automata relation functions input 
components input corresponding values functions guessed nondeterministically 
simulation needs counters current state input position logarithmic space 
iii time bounded deterministic turing machine polynomial configuration coded word qw jw encoding function mapping configuration successor predicate configurations containing accepting states recognised automata 
assume accepting configurations starting state accepts word configuration jwj accepting jwj automatic 
mapping pair jwj desired reduction clearly computed logarithmic space 

theorem says fixed automatic structure quantifier free formulae evaluated quadratic time 
extends result word problem automatic group solvable quadratic time 
automatic group generated structure 
gs 
gs just functional way presenting cayley graph automatic 
instance word problem described quantifier free sentence term equation structure 
theorem 
presentation structure tuple formula modelchecking problem jjj jdj jdj jjj jjj jdj log jjj ii structure complexity model checking formulae complete respect tt reductions 
iii expression complexity pspace complete regard log reductions 
proof 
run corresponding automaton atom appearing encoding elements input missing guess 
ensure guessed inputs automata simulation performed simultaneously 
algorithm determines atoms appear simulates product automaton constructed automata relations 
step symbol quantified variables guessed nondeterministically 
note values variables may longer input continue simulation reaching cardinality state space number steps 
cardinality jdj jjj closer inspection algorithm yields bounds 
ii reduce complete non universality problem nondeterministic automata unary alphabet see automaton check recognise language problem 
reduction performed steps 
automaton simplified transformed deterministic construct automatic structure formula holds values original automaton recognises modelchecking performed parameter yields truth table reduction 
nondeterministic finite automaton alphabet 
construct automaton transitions outgoing state 
done replacing transition form state binary tree transitions new states internal nodes 
course changes language automaton 
state jqj successors take trees fixed height dlog 
homomorphism note size polynomial nondeterministic 
deterministic add second component labels transitions 
yields automaton accepts word iff word kn accepts kn structure complexity expression complexity model checking logspace complete complete fun nlogspace ptime complete complete pspace complete query evaluation logspace pspace pspace expspace presentation frg structure yr kn iff kn iff follows iff yr kn jqj part trivial 
show number 
assumption jqj 
apply pumping lemma find 
contradiction 
iii shown coding computations turing machines 
proof 
turn query evaluation problem formula classes 
theorem 
presentation structure formula automaton representing computed time jdj jjj space jdj case quantifier free ii time jdj jjj 
space jdj jjj case existential formulae 
particular structure complexity query evaluation logspace quantifier free formulae pspace existential formulae 
expression complexity pspace quantifier free formulae expspace existential formulae 
proof 
enumerate state space product automaton output transition function 

structures automatic prove structure automatic just find suitable presentation 
prove structure automatic 
main difficulty priori known elements automatic structure named words regular language 
obvious criteria automatic structures countable order theory decidable known 
non trivial criterion available growth rates length encodings elements definable sets 
proposition elgot 
automatic structure injective presentation function constant true replace relation finitely values ab holds 
result deals single application function relation 
remaining part section study effect applying functions iteratively consider definable subset universe calculate upper bounds length encodings elements substructure generated 
need bounds encodings elements definable subsets 
lemma follows easily classical results automata theory see proposition 
lemma 
structure presentation fo definable subset finite union arithmetical progressions 
process generating substructure count number applications functions 
definition 
presentation finitely operations arities respectively fe subset 
th generation defined inductively fe fe putting obtain result 
case finitely generated substructures appeared 
proposition 
injective presentation automatic structure finitely definable operations definable subset constant mn 
particular jg jsj mn alphabet case automatic groups naming function fixed techniques available fellow traveller property see 
proof consists simple induction theorem 
structures automatic presentation 
trace monoid 
generators 
ii structure pairing function defined 
iii divisibility poset 
iv skolem arithmetic 
proof 
show fa bg induction fa bg fa aa bg uv uv fa bg fa bg jg claim follows 
ii analogous iv immediately follows iii divisibility relation definable 
iii suppose 
define set primes px iff set powers prime qx iff py relation containing pairs pn prime divisor sxy iff qz pz common multiple numbers lcm iff finitely snm 
satisfies conditions proposition 
consider set generated lcm jg cardinality 
proposition 
fp fp generally consists numbers form numbers form 
numbers mixed form 
steps create numbers numbers mixed form lcm 
obtain ng 
assume odd 

nlogn contradiction 

easy construct tree automatic presentation skolem arithmetic result implies class structures tree automatic presentation strictly includes class automatic structures see 
structure 
stands having common divisor automatic 

characterising automatic structures interpretations interpretations important mathematical logic model theory particular 
define copy structure inside permit transfer definability decidability complexity results theories 
definition 
dimensional interpretation relational structure rm structure sequence hd order formulae vocabulary tuple consists variables provided exists surjective map called coordinate map interpretation hold iff ii relation iff formula defines congruence structure rm isomorphism quotient structure rm case quotient structure just isomorphic say definable obviously definable interpretation coordinate map canonical projection mapping tuple equivalence class structure including relations functions definition interpretation interpretation relational variant functions replaced graphs write fo denote exists interpretation fo fo say mutually interpretable 
examples 
recall write denote power dividing function maps number largest power dividing 
easy see structures mutually interpretable 
define statement formula 
direction definition 
write tree tree structure tree 
structures tree mutually interpretable see 
observe proposition implies interesting closure property 
proposition 
classes automatic automat ic structures closed interpretations automatic fo corollary 
classes automatic resp 
automat ic structures closed extensions definable relations ii definable congruences iii substructures definable universe iv finite powers 
model theoretic characterisation automatic structures theorem 
states structure tree complete structure belongs fo theorem 
structure equivalent automatic 
ii fo 
iii fo tree 
proof 
facts ii iii equivalent imply follow immediately mutual interpretability tree fact structures automatic closure automatic structures interpretations 
remains show automatic structure interpretable tree 
suppose automatic presentation alphabet loss generality take 
word val natural number ary encoding val classical result called theorem relation order definable val val rg regular 
see proof fact information relationship automata definability expansions presburger arithmetic 
formulae define sense regular language regular relations automatic presentation provide interpretation 
fo automatic groups free change coordinate map arguments give characterisation terms definability interpretability 
theorem 

automatic group exists finite set semigroup generators fo definable tree 
turn automatic structures 
provide similar characterisation equivalent theorem encodings regular relations 
result obtained wolper 
natural translations words real numbers prove relation recognised automaton translation order definable structure relation explicitly represents translation holds iff exists representation word digit position specified somewhat unsatisfactory aspect result assumption encoding relation basic relation structure 
preferable natural expansions additive real group 
show possible case restricted variant divisibility relation 
recall structures tree introduced section automatic 
step show behaviour automata recognising regular relations simulated firstorder formulae tree 
second show tree mutually interpretable 
result obtain model theoretic characterisation automatic structures 
theorem 
structure equivalent automatic 
ii fo 
iii fo tree 
proof 
order construct interpretations tree vice versa define formulae allow access digits respectively number word tree 
case set dig el states digit position jyj situation complicated real numbers admit encodings 
formula describes encoding digit position 
corresponds predicate 
dig jxj 

fo tree represent number pair words 
finite encodes integer part infinite contains fractional part 
direction map finite words 
interval infinite words 
mapped intervals necessary words mapped number 
desired interpretations constructed easily formulae dig defined 
remains prove regular definable tree 
automaton assume 
prove claim constructing formula ym fo stating successful run run encoded tuple qm words symbols qm position equal iff automaton state scanning input symbol position 
ym form 
qm adm start run acc admissibility condition adm states components infinite start says state acc final state appears infinitely run ensures transitions correct 
define auxiliary formulae 
access digits tuple words position define sym dig characterise words set inf adm start defined adm inf inf start sym run states position valid transition run sym sym sym acc says final state appears infinitely acc jz jzj sym 
composition structures composition method developed feferman shelah considers compositions products sums structures index structure allows compute depending type composition order monadic second order theory structure respective theories components monadic theory index structure 
characterisation previous section prove closure automatic structures compositions finitely structures see 
generalised product defined generalisation direct product disjoint union ordered sum 
prove finite sequence structures belong class containing complete structure generalised products members 
definition product bit technical 
relations defined terms types components elements 
atomic type atp tuple structure conjunction atomic negated atomic formulae holds look direct product ordered sum defined types 
example 
binary relation 
universe pair belongs iff equivalent condition atomic types include formula rx 
partial orders 
universe 
iff condition expressed types 
definition 
fr finite relational vocabulary arity sequence structures arbitrary relational structure universe fix enumeration ft atomic types set 
fd 
ft expansion belonging sequence 
atp fo defines generalised product example 
continued direct product set set atomic types containing formula rx 
case set set atomic types containing formula theorem 
finite relational vocabulary class structures containing finite structures structure complete regard dimensional fo interpretations 
finite relational structure sequence structures generalised product 
interpretation fo constructed effectively interpretations fo fo proof 
fr assume jij contains constants 
construct interpretation arity consider dimensional interpretations represent element tuple jij 
jij elements jij determines components empty encodes th component desired interpretation constructed follows 
jij jij jij jij jij jij jij order define consider interpretation finite interpretation exists 
formula defining note contains additional relations sentence signature extended symbols appropriate replace order obtain definition parameters jij defined note definitions valid ranges finite set 
defined replaced definitions 
obviously steps construction effective 
corollary 
effectively closed finitary generalised products 
promised immediately obtain closure types compositions 
corollary 

exists automatic presentations direct product ii disjoint union 
iii fold disjoint union 
corollary 
ordered structures 
exists automatic presentations ordered sum ii fold ordered sum abiteboul hull vianu 
foundations databases 
addison wesley 

automatic structures 
diploma thesis rwth aachen 
wolper 
expressiveness real integer arithmetic automata 
proc 
th int 
colloq 
automata languages programming volume lncs pages 
hansel 
logic recognizable sets integers 
bull 
belg 
math 
soc 
buss 
boolean formula value problem time 
proc 
th acm symp 
theory computing pages 

ebbinghaus flum 
finite model theory 
springer 
eilenberg 
automata languages machines volume academic press new york 
elgot 
relations defined generalized finite automata 
ibm res 
develop 
epstein cannon holt levy paterson thurston 
word processing groups 
jones bartlett publishers boston 

automatic groups guided tour 


simple interpretations complicated theories 
inf 
process 
lett 
gurevich 
metafinite model theory 
information computation 
gurevich 
monadic second order theories 
barwise feferman editors model theoretic logics pages 
springer 
harel 
theory recursive structures 
proc 
rd int 
symp 
mathematical foundations computer science volume lncs pages 
springer 
hirst harel 
recursive structures descriptive complexity zero laws 
proc 
th ieee symp 
logic computer science pages 
hodges 
model theory 
cambridge university press 
hunt iii rosenkrantz szymanski 
equivalence containment covering problems regular context free languages 
comput 
syst 
sci 
immerman 
descriptive complexity 
springer 
khoussainov nerode 
automatic presentations structures 
lncs 
kuper libkin paredaens editors 
constraint databases 
springer 
meyer stockmeyer 
word problems requiring exponential time 
proc 
th acm symp 
theory computing pages 
stolboushkin 
recursive model theory 
lecture notes logic 
thomas 
ehrenfeucht games composition method monadic theory ordinal words 
lncs 
