copyright crc press approximation algorithms np hard optimization problems philip klein department computer science brown university neal young department computer science dartmouth college chapter discuss approximation algorithms optimization problems 
optimization problem consists finding best cheapest heaviest element large set called feasible region usually specified implicitly quality elements set evaluated function objective function usually fairly simple 
element minimizes maximizes function said optimal solution objective function element optimal value 
optimal value minff pg example optimization problem familiar computer scientists finding minimum cost spanning tree graph edge costs 
problem feasible region set optimize consists spanning trees recall spanning tree set edges connect vertices forms cycles 
value objective function applied spanning tree sum costs edges spanning tree 
minimum cost spanning tree problem familiar computer scientists algorithms solving procedures graph quickly determine minimum cost spanning tree 
matter graph provided input time required algorithms guaranteed slowly growing function number vertices edges log 
optimization problems contrast minimum cost spanning tree problem known algorithm solves instances quickly sense 
furthermore algorithm discovered problems np hard algorithm imply problem np solved quickly np considered 
option case seek approximation algorithm algorithm guaranteed run quickly time polynomial input size produce solution value objective function close optimal value 
considerable progress understanding combinatorial optimization problems approximately solved accuracy 
theory np completeness provide evidence problem hard solve precisely hard approximate particular accuracy 
furthermore natural np hard optimization problems approximation algorithms developed accuracy nearly matches best achievable theory np completeness 
optimization problems categorized best accuracy achievable polynomial time approximation algorithm problem 
chapter organized categories category describe representative problem algorithm problem analysis algorithm 
way demonstrate ideas methods common approximation algorithms 
illustrate diversity problems studied briefly mention additional problems go 
provide sampling compendium field important results areas 
section mention areas cover direct interested reader comprehensive technically detailed sources excellent book hochbaum 
unfamiliar theory np completeness see chapters garey johnson 
underlying principles focus combinatorial optimization problems problems feasible region finite typically huge 
furthermore focus primarily optimization problems np hard 
main organizing principle restrict attention algorithms provably sense input algorithm runs time polynomial length input returns solution member feasible region value objective function value guaranteed near optimal defined sense 
guarantee called performance guarantee 
performance guarantees may absolute meaning additive difference optimal value value algorithm bounded 
commonly performance guarantees relative meaning value algorithm multiplicative factor optimal value 
algorithm performance guarantee returns solution implicitly discovered bound exact optimal value problem 
obtaining bounds basic challenge designing approximation algorithms 
compute optimal value expect prove output algorithm near 
common techniques shall call witnesses relaxation coarsening 
witness structure derived input provides short easily verified bound optimal value 
similar notion witness theory np completeness satisfying assignment short proof formula satisfiable 
witnesses optimal value generally obtainable witnesses approximately bound optimal 
performance guarantee shown respect witness 
suffices show performance guarantee respect optimal 
relaxation way obtain lower bound minimum value upper bound case maximization problem 
formulates new optimization problem called alternative worst case analysis average case analysis 
see chapter 
relaxation original problem objective function larger feasible region includes subset 
contains including optimal element belongs 
optimal value relaxation minff equal optimal value original optimization problem 
intent optimal value relaxation easy calculate reasonably close optimal value original problem 
linear programming provide witnesses relaxations important technique design analysis approximation algorithms 
randomized rounding general approach probabilistic method converting solution relaxed problem approximate solution original problem 
coarsen problem instance alter typically restricting complex feasible region objective function result problem efficiently solved typically dynamic programming 
coarsening useful coarsened problem approximate original problem rough correspondence feasible solutions problems correspondence approximately preserves cost 
term coarsening roughly describe wide variety algorithms spirit 
approximation algorithms small additive error minimum degree spanning tree example consider slight variant minimum cost spanning tree problem minimum degree spanning tree problem 
feasible region consists spanning trees input graph time objective find spanning tree degree minimum 
degree vertex spanning tree graph number edges incident vertex degree spanning tree maximum degrees vertices 
minimizing degree spanning tree amounts finding smallest integer left example input graph right spanning tree approximation algorithm 
shaded circle indicates nodes witness set exists spanning tree vertex incident edges 
procedure finding minimum degree spanning tree graph find hamiltonian path graph hamiltonian path degree spanning tree 
hamiltonian path graph path graph visits vertex graph exactly 
np hard determine graph hamiltonian path determining minimum degree spanning tree degree presumed computationally difficult 
approximation algorithm minimum degree spanning tree minimum degree spanning tree problem remarkably approximation algorithm furer 
input graph edges vertices algorithm requires time slightly product output spanning tree degree guaranteed minimum degree 
example graph hamiltonian path output path spanning tree degree 
graph algorithm naturally finds desired spanning tree algorithm finds witness case set vertices proving degree nearly optimal 
denote degree subtrees result left shows trees obtained deleting nodes tree indicated shaded region 
right shows edges input graph connect different trees vertices deleted 
properties show degree nearly optimal 

edges graph distinct trees 
number trees jsj gamma gamma jsj gamma 
show degree nearly optimal denote set vertices comprising subtree 
spanning tree connect sets vertices jsj jsj gamma edges 
furthermore edges go distinct sets edges incident vertices obtain sg jsj gamma jsj gamma gamma jsj gamma jsj gamma jsj gamma gamma jsj gamma deg denotes degree tree average degrees vertices jsj gamma gamma js gamma jsj strictly greater gamma 
average degrees left shows arbitrary spanning tree input graph right shaded regions subset nodes corresponding tree 
proof algorithm performance guarantee observation jsj gamma edges needed connect nodes vertices greater gamma follows vertex degree gamma 
shown spanning tree vertex degree gamma 
minimum degree gamma 
explained algorithm obtains spanning tree set vertices set shows spanning tree nearly optimal 
basic idea follows 
start spanning tree denote degree 
set vertices having degree gamma current spanning tree 
subtrees comprising gamma edges subtrees set satisfies property show satisfies property case algorithm terminates 
hand edge distinct subtrees inserting edge removing edge results spanning tree fewer vertices having degree gamma 
repeat process new spanning tree subsequent iterations improvement steps somewhat complicated follow lines 
prove number iterations log 
summarize brief sketch algorithm follows current set witness near optimality current spanning tree slight modification set spanning tree improve 
algorithm terminates relatively small number improvements 
algorithm remarkable simplicity elegance quality approximation achieved 
shall see np hard optimization problems settle approximation algorithms weaker guarantees 
problems having small additive error algorithms natural combinatorial optimization problems approximation algorithms similar performance guarantees known 
examples edge coloring graph color edges graph minimum number colors vertex edges incident vertex different colors 
problem easy find witness 
graph vertex highest degree clearly needs assign deg colors edges edges color incident graph edge coloring number colors equal plus degree 
proof fact translates polynomial time algorithm approximates minimum edge coloring additive error misra gries 
bin packing input consists set positive numbers 
solution partition numbers sets summing 
goal minimize number blocks partition 
approximation algorithms bin packing performance guarantees 
example performance guarantee algorithm follows input set item weights finds packing uses opt log opt bins opt number bins best packing optimal value 
randomized rounding linear programming linear programming problem optimization problem feasible region corresponds assignments values variables meeting set linear inequalities objective function linear function 
instance determined specifying set variables objective function set inequalities 
linear programs capable representing large variety problems studied decades combinatorial optimization tremendous literature see chapters book karloff papadimitriou steiglitz 
linear program solved point feasible region maximizing minimizing objective function time bounded polynomial size input 
integer linear programming problem linear programming problem augmented additional constraints specifying variables take integer values 
constraints integer linear programming general linear programming general solving integer linear programs np hard 
example consider np complete balanced packing problem input bipartite graph 
goal choose edge incident vertex jv edges total minimizing maximum load number chosen edges adjacent vertex vertices represent tasks vertices represent people presence edge fv wg indicates person competent perform task problem assign task person competent perform minimizing maximum number tasks assigned person 
balanced packing problem formulated integer linear program balanced packing problem captures essential spirit studied integer multicommodity flow problem 
simple version problem network set commodities pair vertices choose path commodity minimizing maximum congestion edge 
minimize delta subject delta edge variable determines chosen 
variable delta measures maximum load 
relaxing integrality constraints replacing linear inequalities yields linear program minimize delta subject delta rounding fractional solution true solution 
relaxed problem solved polynomial time 
hand optimal solution correspond set edges 
typical solution fraction 
convert optimal fractional solution approximately optimal integer solution 
randomized rounding general approach doing just raghavan thompson motwani raghavan ch 

technique probabilistic method alon 
consider polynomial time randomized algorithm find integer solution optimal solution linear program 
solve linear program obtain fractional solution load delta 
vertex choose single incident edge random probability edge chosen 
note 

edges incident 
algorithm choose edge adjacent vertex feasible solution original integer program 
say load 
particular vertex load particular edge probability 
expected value load delta start 
course maximum load larger 
larger 
answer need know distribution load just expected value 
key fact need observe load sum independent random variables 
means deviate expected value 
precise estimates come standard bounds called chernoff hoeffding bounds theorem random variable sum independent random variables 
expected value ffl pr ffl exp gamma ffl see 
motwani raghavan ch 

analyze performance guarantee algorithm 
slightly complicated bad claim probability maximum load induced exceeds optimal additive error max ae ln ln delta oe jw proof sketch observed previously particular load sum independent random variables expectation bounded delta ffl just large exp gamma delta ffl 
chernoff type bound probability load exceeds ffl delta 
naive union bound probability maximum load delta ffl delta ffl delta 
leave reader verify choice ffl ffl delta equal expression statement claim 
pi summary 
general randomized rounding recipe 
formulate original np hard problem integer linear programming problem ip 

relax program ip obtain linear program lp 

solve linear program obtaining fractional solution 

randomly round fractional solution obtain approximately optimal integer solution 
typically method conditional probabilities spencer raghavan convert randomized algorithm deterministic algorithm 
faster algorithms obtain comparable performance guarantees solving linear program 
instance case packing covering problems abstracting multicommodity flow problems klein goldberg khachiyan plotkin karger plotkin 
algorithms faster general linear programming approximately solving fractional relaxed packing covering problems 
algorithms understood framework probabilistic methods variant randomized rounding called oblivious rounding yields algorithms don need solve linear program young 
probability events happens sum probabilities individual events 
performance ratios ae approximation np hard optimization problems seek approximation algorithm absolute performance guarantee simply problems instance problem construct new equivalent instance scaling objective function 
instance traveling salesman problem instance multiplying edge weights yields equivalent problem objective function scaled problems best hope relative performance guarantee shmoys 
ae approximation algorithm algorithm returns feasible solution objective function value ae times minimum case maximization problem objective function value ae times maximum 
say performance ratio algorithm ae 
polynomial approximation schemes knapsack problem example np hard problem 
instance consists set pairs numbers weight profit goal select subset pairs sum weights maximize sum profits 
items put knapsack capacity maximize profit 
knapsack problem np hard assume approximation algorithm achieving say fixed absolute error 
led ask best performance ratio achievable polynomial time approximation algorithm 
fact best performance ratio ffl polynomial approximation algorithm performance ratio ffl 
smaller value ffl greater running time corresponding approximation algorithm 
collection approximation algorithms terminology frequently finds alternative terminology literature 
confusingly authors term ae approximation algorithm gamma ae approximation algorithm refer call ae approximation algorithm 
ffl called polynomial approximation scheme 
think approximation scheme algorithm takes additional parameter value ffl addition input specifying instance optimization problem 
running time algorithm bounded terms size input terms ffl 
example approximation scheme knapsack problem requires time log ffl ffl instances items 
sketch simplified version algorithm requires time ffl 
algorithm works coarsening 
algorithm pairs weight profit weight profit parameter ffl 
assume loss generality weight equal 
profit max max profit opt denote unknown optimal value 
item greatest profit constitutes solution albeit usually profit max opt 
order achieve relative error ffl suffices achieve absolute error ffl profit max transform instance coarsened instance rounding profit multiple ffl profit max doing reduce profit ffl profit max consequently optimal solution consists items profit optimal solution reduced ffl profit max total 
optimal value coarsened instance opt gammaffl profit max turn gamma ffl opt 
corresponding solution measured original profits value 
need solve coarsened instance optimally order get performance guarantee gamma ffl 
addressing solution coarsened instance note optimal value sum profits profit max opt ffl 
optimal value coarsened instance ffl 
solve coarsened instance optimally dynamic programming 
note coarsened instance achievable total profit written delta integer ffl 
dynamic programming algorithm constructs dn ffle theta table entry minimum weight required achieve profit delta subset items entry infinity way achieve profit 
fill table algorithm initializes entries infinity executes step set minft gamma weight gamma profit gamma profit profit item rounded instance 
simple induction shows calculated values correct 
optimal value coarsened instance opt calculates optimal value coarsened instance usual dynamic programming corresponding feasible solution easily computed desired 
problems having polynomial approximation schemes running time knapsack approximation scheme depends polynomially ffl 
scheme called fully polynomial approximation scheme 
natural np complete optimization problems strongly np hard meaning essentially problems np hard numbers appearing input restricted larger magnitude size input 
problem expect fully polynomial approximation scheme exist garey johnson 
variety np hard problems fixed dimensional euclidean space approximation schemes 
instance set points plane covering disks find minimum set area disks squares covering points hochbaum 
euclidean traveling salesman find closed loop passing points having minimum total arc length arora 
euclidean steiner tree find minimum length set segments connecting points arora 
similarly problems planar graphs graphs fixed genus polynomial approximation schemes baker hochbaum instance planar graph weights assigned vertices maximum weight independent set find maximum weight set vertices adjacent 
minimum weight vertex cover find minimum weight set vertices edge incident vertices set 
algorithms relatively sophisticated varied coarsening techniques 
constant factor performance guarantees seen assuming np np hard problems polynomial time approximation algorithms small absolute errors may fully polynomial approximation schemes strongly np hard problems fully polynomial approximation schemes may polynomial approximation schemes 
class problems approximation schemes problem constant polynomial time approximation algorithm problem relative error assuming np 
problem best hope approximation algorithm constant performance ratio 
example problem vertex cover problem graph find minimum size set vertices vertex cover edge graph incident vertex feasible region consists vertex covers objective function size cover 
simple approximation algorithm hochbaum 
find maximal independent set edges 
vertices incident edges 
set edges independent edges share endpoint 
set maximal larger independent set contains 
reader may wish verify set linear time maximal necessarily cover 
performance guarantee show 
edges independent cover vertex edge witness proving cover jsj vertices 
hand cover jsj vertices 
cover returned algorithm twice size optimal vertex cover 
weighted vertex cover problem 
weighted vertex cover problem generalization vertex cover problem 
instance specified giving graph vertex graph number wt called weight 
goal find vertex cover minimizing total weight vertices cover 
way represent problem integer linear program minimize wt subject fu vg variable vertex representing cover constraints edges model covering requirement 
feasible region program corresponds set vertex covers 
objective function corresponds total weight vertices cover 
relaxing integrality constraints yields minimize wt subject fu vg relaxed problem called fractional weighted vertex cover problem feasible solutions called fractional vertex covers 
rounding fractional solution true solution 
solving linear program optimal fractional cover polynomial time 
problem possible convert fractional cover approximately optimal true cover rounding fractional cover simple way 
solve linear program obtain optimal fractional cover 
set cover edge endpoints fractional weight 
reader verify total weight vertices twice total weight fractional cover approximation algorithm 
described hochbaum hochbaum 
problems simple kind rounding sufficient 
previously discussed technique called randomized rounding generally useful 
primal dual algorithms witnesses duality 
purposes approximation solving linear program exactly unnecessary 
design faster algorithm witness technique fact linear program defined notion witness 
reader may wonder additional constraints form necessary 
fact assuming vertex weights non negative incentive larger constraints redundant 
witnesses linear program feasible solutions related linear program called dual suppose original problem minimization problem 
point feasible region dual problem value objective function lower bound value optimal value original linear program 
feasible solution dual problem possible witness original integer linear program relaxation 
weighted vertex cover problem dual maximize subject wt feasible solution linear program called edge packing 
constraints vertices called packing constraints 
recall original approximation algorithm unweighted vertex cover problem find maximal independent set edges vertices incident edges analysis set witness 
edge packings generalize independent sets edges 
observation allows generalize algorithm unweighted problem 
say edge packing maximal edge edge vertices packing constraint met 
algorithm 
find maximal edge packing 
vertices packing constraints tight reader may wish verify maximal edge packing easily linear time set cover maximal 
performance guarantee 
vertices packing constraints tight edge vertices wt solution dual lower bound weight vertex cover fractional 
algorithm approximation algorithm 
summary 
general primal dual recipe 
formulate original np hard problem integer linear programming problem ip 

relax program ip obtain linear program lp 

dual dlp lp source witnesses 
general guidelines algorithm designer left task figuring find solution witness 
see hochbaum ch 
approach works wide class problems 
optimization problems constant factor approximations constant factor approximation algorithms known problems areas 
section describe sampling problems 
problems described polynomial approximation scheme np constant factor approximation algorithms best hope 
typical problem simple algorithm achieving small constant factor may involved algorithms achieving better factors 
factors known achievable typically come close meet best lower bounds known assuming np 
problems omit discussion techniques problems solved relaxation form possibly implicitly primal dual recipe 
problems polynomial approximation schemes restricted graphs induced points plane constant dimensional euclidean space see section 
max sat propositional formula conjunctive normal form possibly negated boolean variables find truth assignment variables maximizes number clauses groups ed variables formula true assignment 
variant called max sat restricts formula variables clause 
max sat canonical example problem complexity class max snp papadimitriou yannakakis 
max cut graph partition vertices input graph sets maximize number edges endpoints distinct sets 
max cut max sat problems best approximation algorithms currently known rely randomized rounding generalization linear programming called semidefinite programming goemans williamson karger hochbaum 
shortest super string set strings oe oe find minimum length string containing oe 
problem applications computational biology li blum 
cluster graph weighted edges parameter partition vertices clusters minimize maximum distance vertices cluster 
related problems see hochbaum shmoys 
traveling salesman complete graph edge weights satisfying triangle inequality find minimum length path visits vertex graph christofides hochbaum ch 

edge vertex connectivity weighted graph integer find minimum weight edge set pair vertices edge disjoint paths graph frederickson aj khuller vishkin khuller hochbaum ch 

similar algorithms handle goal vertex disjoint paths ravi williamson frederickson aj khuller vishkin garg goal augmenting graph achieve connectivity frederickson aj khuller 
steiner tree undirected graph positive edge weights subset vertices called terminals find minimum weight set edges terminals possibly vertices connected zelikovsky berman zelikovsky hochbaum ch 

steiner forest weighted graph collection groups terminals find set edges pair terminals group connected agrawal hochbaum ch 

algorithm problem primal dual framework adapted wide variety network design problems 
see section 
logarithmic performance guarantees constant ratio performance guarantee possible slowly growing ratio best thing 
canonical example set cover problem family sets universe find minimum cardinality set cover collection sets collectively contain elements weighted version problem set weight goal find set cover minimum total weight 
problem important due generality 
instance generalizes vertex cover problem 
simple greedy algorithm lov asz johnson 


repeat elements covered add set maximizing number elements set wt 
return algorithm performance guarantee theorem greedy algorithm weighted set cover problem approximation algorithm maximum size set definition delta ln give direct argument performance guarantee relate general primal dual recipe 
imagine algorithm proceeds assigns charges elements covered 
specifically set added cover elements previously covered assign elements charge wt note total charge assigned course algorithm equals weight final cover argue total charge assigned course algorithm lower bound times weight optimal vertex cover 
facts prove theorem 
suppose prove set optimal cover elements assigned total charge wt done element set optimal cover charge charge wt consider example set fa fg wt 
convenience assume greedy algorithm covers elements alphabetical order 
say charge assigned 
consider iteration covered assigned charge 
iteration chosen elements covered 
greedy algorithm option choosing set choose resulted charge wt jt 
element 
covered chosen elements remained uncovered 
consequently charge assigned 
reasoning similarly elements assigned charges respectively 
total charge elements theta wt jt wt line reasoning easily generalizes show set elements assigned total charge wt pi underlying duality 
role duality primal dual recipe play analysis natural integer linear program weighted set cover problem minimize wt subject relaxing integer linear program yields linear program minimize wt subject solution linear program called fractional set cover 
dual maximize subject wt inequalities sets called packing constraints 
solution dual linear program called element packing 
fact charging scheme analysis just element packing charge assigned divided light previous analysis simply constructing dual solution witness show performance guarantee 
problems poly logarithmic performance guarantees minimizing linear function subject submodular constraint natural generalization weighted set cover problem 
state general problem give special case example family sets vectors set having cost find subfamily sets minimum total cost union rank natural generalization greedy set cover algorithm gives logarithmic performance guarantee nemhauser wolsey 
vertex weighted network steiner tree network steiner tree problem described section instance consists graph set terminals case graph vertex weights addition edge weights 
adaptation greedy algorithm achieves logarithmic performance ratio 
network design problems large class problems generalizing steiner forest problem see section 
example problem class survivable network design weighted graph non negative integer uv pair vertices find minimum cost set edges pair vertices uv edge disjoint paths connecting graph 
primal dual approach generalized algorithm steiner forest problem yields performance guarantees problems class 
performance guarantee depends particular problem cases known bounded logarithmically goemans williamson ravi klein williamson gabow aggarwal garg goemans 
commercial application see mihail 
graph bisection graph partition nodes sets equal size minimize number edges endpoints different sets 
algorithm find approximately minimum weight bisector remarkably useful provide basis conquer approach graph optimization problems 
fact solution related easier problem suffices 
define balanced cut partition vertices graph sets containing third vertices weight total weight edges connecting sets 
algorithm find balanced cut weight log times minimum weight bisector leighton rao 
note algorithm strictly speaking approximation algorithm optimization problem output algorithm solution problem quality output measured optimal value 
algorithm nearly useful true approximation algorithm divide conquer algorithms precise balance critical 
balanced cut algorithm obtain approximation algorithms problems including 
optimal linear arrangement assign vertices graph distinct integral points real number line minimize total length edges hansen 
minimizing time space sparse gaussian elimination sparse linear system order variables eliminated affects time storage space required solving system choose ordering simultaneously minimize time storage space required agrawal 
crossing number embed graph plane minimize number edge crossings leighton rao 
approximation algorithms problems performance guarantees depend performance guarantee balanced separator algorithm 
known performance guarantee improved algorithm balanced separators constant performance ratio 
graph separation problems approximation algorithms known aumann rabani garg klein linial seymour approximation algorithms cut problems linear programming relaxation 
multi criteria problems applications objective functions considered 
approximation algorithms developed multi criteria optimization problems remains done 
problems previous sections cluster problem described section viewed bi criteria problem budget imposed resource number clusters algorithm required approximately optimize resource cluster diameter subject budget constraint 
example scheduling unrelated parallel machines costs budget cost jobs assigned machines way cost assignment budget makespan schedule nearly minimum 
approximation algorithms bi criteria problems switch idea men tioned section 
example polynomial approximation scheme variant minimum spanning tree problem unrelated costs edge say weight length budget length algorithm finds spanning tree length ffl weight minimum weight spanning tree having length ravi goemans 
similar switch algorithms pairs cost measures spanning trees degree total cost degree bottleneck cost degree diameter ravi ravi 
hard approximate problems optimization problems worst case performance guarantees possible np hard approximate problems willing accept poor performance guarantees 
examples 
maximum clique graph find largest set vertices pairwise adjacent hastad 
minimum vertex coloring graph color vertices minimum number colors adjacent vertices receive distinct colors lund yannakakis 
longest path graph find longest simple path karger 
max linear satisfy set linear equations find largest possible subset simultaneously satisfiable arora 
nearest codeword linear error correcting code specified matrix vector find codeword closest hamming distance vector arora 
nearest lattice vector set vectors vector find integer linear combination nearest euclidean distance arora 
defining terms ae approximation algorithm approximation algorithm guaranteed find solution value appropriate ae times optimum 
ratio ae performance ratio algorithm 
absolute performance guarantee approximation algorithm absolute performance guarantee guaranteed return feasible solution value differs additively optimal value bounded amount 
approximation algorithm solving optimization problem 
algorithm runs time polynomial length input outputs feasible solution guaranteed nearly optimal defined sense called performance guarantee 
coarsening coarsen problem instance alter typically restricting complex feasible region objective function resulting problem efficiently solved typically dynamic programming 
standard terminology 
dual linear program linear program corresponding linear program called dual 
linear program linear program dual max delta solution original linear program solution dual delta ax delta optimal equality holds 
problem formulated integer linear program feasible solutions dual relaxation program serve witnesses 
feasible region see optimization problem 
feasible solution element feasible region optimization problem 
fractional solution typically solution relaxation problem 
fully polynomial approximation scheme approximation scheme running time ffl bounded polynomial length input ffl 
integer linear program linear program augmented additional constraints specifying variables take integer values 
solving problems np hard 
linear program problem expressible form 
theta real matrix vector vector determine min phi delta ax psi ranges vectors inequalities interpreted component wise means entries non negative 
max snp complexity class consisting problems constant factor approximation algorithms approximation schemes np 
objective function see optimization problem 
optimal solution optimization problem 
feasible solution minimizing possibly maximizing value objective function 
optimal value minimum possibly maximum value taken objective function feasible region optimization problem 
optimization problem optimization problem consists set called feasible region usually specified implicitly function objective function 
performance guarantee see approximation algorithm 
performance ratio see ae approximation algorithm 
polynomial approximation scheme collection algorithms fa ffl ffl ffl ffl approximation algorithm running time polynomial length input 
restriction dependence running time ffl 
randomized rounding technique uses probabilistic method convert solution relaxed problem approximate solution original problem 
relative performance guarantee approximation algorithm relative performance guarantee guaranteed return feasible solution value bounded multiplicative factor times optimal value 
relaxation relaxation optimization problem feasible region optimization problem feasible region oe objective function extension original problem objective function 
relaxed problem typically easier solve 
value provides bound value original problem 
optimization problem instance problem integer easily computed second instance objective function second instance element wise times objective function instance 
problems best hope multiplicative performance guarantee absolute 
semidefinite programming generalization linear programming subset variables may constrained form semi definite matrix 
results obtaining better approximation algorithms cut satisfiability coloring problems 
strongly np hard problem strongly np hard np hard numbers appearing input bounded polynomial length input 
triangle inequality complete weighted graph satisfies triangle inequality wt wt wt vertices hold graph representing points metric space 
problems involving edge weighted graphs better approximation algorithms problem restricted weights satisfying triangle inequality 
witness structure providing easily verified bound optimal value optimization problem 
typically analysis approximation algorithm prove performance guarantee 
acm siam 
proceedings fifth annual acm siam symposium discrete algorithms philadelphia pennsylvania 
acm siam 
proceedings sixth annual acm siam symposium discrete algorithms san francisco california 
acm siam 
proceedings seventh annual acm siam symposium discrete algorithms atlanta georgia 
aggarwal garg 

scaling technique better network design 
acm siam pages 
agrawal klein ravi 

trees collide approximation algorithm generalized steiner problem networks 
siam journal computing 
agrawal klein ravi 

cutting fill nested dissection provably elimination orderings 
george gilbert li editors graph theory sparse matrix computation ima volumes mathematics applications pages 
springer verlag 
alon spencer erdos 

probabilistic method 
john wiley sons new york 
arora 

polynomial time approximation scheme euclidean tsp geometric problems 
ieee pages 
arora babai stern 

hardness approximate optima lattices codes systems linear equations 
th annual symposium foundations computer science pages palo alto california 
ieee 
appear jcss 
aumann rabani log approximate min cut max flow theorem approximation algorithm 
siam journal computing 
appear 
baker 

approximation algorithms np complete problems planar graphs 
journal acm 
berman 

improved approximations steiner tree problem 
journal algorithms 
blum jiang li tromp yannakakis 

linear approximation shortest superstrings 
journal acm 
christofides 

worst case analysis new heuristic travelling salesman problem 
technical report cs carnegie mellon university graduate school industrial administration pittsburgh pa 

greedy heuristic set covering problem 
mathematics operations research 


linear programming 
freeman 
crescenzi kann 

compendium np optimization problems 
www nada kth se nada theory html 
naor rao schieber 

divide conquer approximation algorithms spreading metrics extended 
th annual symposium foundations computer science pages milwaukee wisconsin 
ieee 
naor rao schieber 

fast approximate graph partitioning algorithms 
proceedings eighth annual acm siam symposium discrete algorithms pages new orleans louisiana 
frederickson aj 

approximation algorithm algorithms graph augmentation problems 
siam journal computing 
furer 

approximating minimum degree steiner tree optimal 
journal algorithms 
gabow goemans williamson 

efficient approximation algorithm survivable network design problem 
rd mps conference integer programming combinatorial optimization pages 
garey johnson 

computers guide theory np completeness 
freeman new york 
garg santosh 

improved approximation algorithms biconnected subgraphs better lower bounding techniques 
proceedings fourth annual symposium discrete algorithms pages austin texas 
garg vazirani yannakakis 

approximate max flow min multi cut theorems applications 
siam journal computing 
goemans goldberg plotkin shmoys tardos williamson 

improved approximation algorithms network design problems 
acm siam pages 
goemans williamson 

approximation algorithms max cut max sat 
proceedings sixth annual acm symposium theory computing pages montr eal qu ebec canada 
goemans williamson 

general approximation technique constrained forest problems 
siam journal computing 
goldberg 

processor efficient implementation maximum flow algorithm 
information processing letters 
khachiyan 

approximate minimum cost multicommodity flows ffl gamma time 
technical report dimacs 
mon mar gmt 
hansen 

approximation algorithms geometric embeddings plane applications parallel processing problems extended 
th annual symposium foundations computer science pages research triangle park north carolina 
ieee 
hastad 

clique hard approximate gammaffl ieee pages 
hochbaum 

approximation algorithms set covering vertex cover problems 
siam computing 
hochbaum editor 
approximation algorithms np hard problems 
pws publishing hochbaum shmoys 

unified approach approximate algorithms bottleneck problems 
journal acm 
ieee 
th annual symposium foundations computer science santa fe new mexico 
ieee 
th annual symposium foundations computer science burlington vermont 
johnson 

approximation algorithms combinatorial problems 
journal computer system sciences 
johnson 

approximation algorithms combinatorial problems 
journal computer system sciences 
karger motwani 

approximating longest path graph 
workshop algorithms data structures volume lecture notes computer science pages 
springer verlag 
karger motwani sudan 

approximate graph coloring semidefinite programming 
ieee pages 
karger plotkin 

adding multiple cost constraints combinatorial optimization problems applications multicommodity flows 
proceedings seventh annual acm symposium theory computing pages las vegas nevada 
karloff 

linear programming 
birkhauser 
khuller 

improved approximation algorithms uniform connectivity problems 
journal algorithms 
khuller 

approximation algorithms graph augmentation 
journal algorithms 
khuller vishkin 

approximations graph 
journal acm 
klein plotkin stein tardos 

faster approximation algorithms unit capacity concurrent flow problem applications routing finding sparse cuts 
siam journal computing 
klein plotkin rao tardos 

approximation algorithms steiner directed 
journal algorithms 
klein rao agrawal ravi 

approximate max flow min cut relation undirected multicommodity flow applications 
combinatorica 
leighton rao 

approximate max flow min cut theorem uniform multicommodity flow problems applications approximation algorithms 
th annual symposium foundations computer science pages white plains new york 
ieee 
li 

dna sequencing theory learning string preliminary version 
st annual symposium foundations computer science volume pages st louis missouri 
ieee 
linial london rabinovich 

geometry graphs algorithmic applications 
combinatorica 
lov asz 

ratio optimal integral fractional covers 
discrete mathematics 
lund yannakakis 

hardness approximating minimization problems 
journal acm 
young 

data collection sloan digital sky survey network flow heuristic 
acm siam pages 
mihail dean 

commercial application survivable network design ccs network topology analyzer 
acm siam pages 
misra gries 

constructive proof theorem 
information processing letters 
motwani raghavan 

randomized algorithms 
cambridge university press 
nemhauser wolsey 

integer combinatorial optimization 
john wiley sons new york 
papadimitriou steiglitz 

combinatorial optimization algorithms complexity 
prentice hall 
papadimitriou yannakakis 

optimization approximation complexity classes 
journal computer system sciences 
plotkin shmoys tardos 

fast approximation algorithms fractional packing covering problems 
nd annual symposium foundations computer science pages san juan puerto rico 
ieee 


fast deterministic approximation multicommodity flow problem 
acm siam pages 
raghavan 

probabilistic construction deterministic algorithms approximating packing integer programs 
journal computer system sciences 
raghavan thompson 

randomized rounding technique provably algorithms algorithmic proofs 
combinatorica 
ravi 

rapid rumor ramification approximating minimum broadcast time extended 
ieee pages 
ravi goemans 

constrained minimum spanning tree problem 
proc 
th scand 

algorithm theory number lecture notes computer science pages 
springer verlag 
ravi klein 

cycles collapse general approximation technique connectivity problems 
rinaldi wolsey editors proceedings rd symposium integer programming combinatorial optimization 
ravi marathe ravi rosenkrantz hunt iii 

birds stone multi objective approximation algorithms extended 
proceedings fifth annual acm symposium theory computing pages san diego california 
ravi williamson 

approximation algorithm minimum cost problems 
acm siam pages 
seymour 

packing directed circuits fractionally 
combinatorica 
shmoys computing near optimal solutions combinatorial optimization problems 
series discrete mathematics computer science 
ams 
spencer 
lectures probabilistic method 
cbms conference board mathematical sciences regional conference series 


estimate chromatic class graph russian 


williamson goemans mihail vazirani 

primal dual approximation algorithm generalized steiner network problems 
combinatorica 
young 

randomized rounding solving linear program 
acm siam pages 
zelikovsky 

approximation algorithm network steiner problem 
algorithmica 
zelikovsky 

better approximation bounds network euclidean steiner tree problems 
technical report cs department computer science university virginia 
mon mar gmt 
information excellent survey field approximation algorithms focusing results research issues see survey david shmoys shmoys 
details topics chapter including algorithms hardness results definitive book edited hochbaum hochbaum 
np completeness subject classic book michael garey david johnson garey johnson 
article johnson anticipated issues methods subsequently developed johnson 
randomized rounding probabilistic techniques algorithms subject excellent text motwani raghavan motwani raghavan 
writing searchable compendium approximation algorithms hardness results crescenzi kann available line crescenzi kann 

