prefer specific defaults terminological default logic franz baader bernhard hollunder german research center ai dfki saarbrucken germany mail namei dfki uni sb de proposed terminological default logic formalism combines means structured representation classes objects default inheritance properties 
major drawback terminological default logic inherits general default logic take precedence specific defaults general ones account 
behaviour criticized general context default logic problematic terminological case emphasis lies hierarchical organization concepts 
addresses problem modifying terminological default logic specific defaults preferred 
turns existing approaches expressing priorities defaults appropriate purpose 
shall consider alternative approach dealing prioritization framework reiter default logic 
formalism general setting default logic priorities arbitrary partial ordering defaults 
shall exhibit interesting properties new formalism compare existing approaches describe algorithm computing extensions 
contents default logic reiter default logic terminological default logic previous approaches prioritization prioritization semi normal defaults prioritized default theories ordered default theories default theories specificity computing extensions related appendix 
proofs theorems proof theorem proof theorem proof theorem soundness completeness algorithm early knowledge representation formalisms semantic networks frames comprise means structured representation classes objects default inheritance properties 
formalisms defined formal semantics subsequent formalisms trying overcome problem usually concentrated means representation 
nonmonotonic inheritance networks concerned defeasible inheritance combination strict inheritance nodes networks unstructured objects classes 
terminological representation formalisms hand define relevant concepts problem domain structured formed way 
done building complex concept descriptions atomic concepts unary predicates roles binary predicates help operations provided concept language particular formalism 
addition objects described respect relation concepts interrelation 
concept descriptions interpreted universal statements means allow exceptions 
consequence terminological system descriptions automatically insert concepts proper place concept hierarchy classification facts stated objects deduce concepts belong objects inherit properties default 
problem addressed bring means representation originally semantic networks frames losing advantages terminological formalisms equipped formal understood semantics providing automatic concept classification 
integration defaults greatly enhance applicability terminological systems convenient applications see shows embedding defaults terminological systems important item wish list users systems 
reason existing terminological systems back classic rep loom sb extended provide user kind default reasoning facilities 
designers systems point approaches usually ad hoc character satisfy requirement having formal semantics 
attempt give formally founded solution problem attempts generalize approach structured classes restricted setting clear obtain general results direction see :10.1.1.52.6219
integration reiter default logic terminological formalism proposed 
reason selecting default logic wide range nonmonotonic formalisms reiter default rule approach fits philosophy terminological systems 
systems provide users form monotonic forward rules turned rules viewed specific default rules justifications absent 
second pleasant feature terminological default logic introduced decidable provided applicability default rules restricted objects explicitly knowledge base 
noted constraint imposed monotonic rules terminological systems 
major drawback terminological default logic inherits general default logic take precedence specific defaults general ones account 
example assume default says penguins fly says birds fly classification shows penguins subconcept birds 
intuitively penguin specific default preferred means default extension penguin fly 
default logic default priority second means gets second extension penguin fly 
behaviour criticized general context default logic problematic terminological case emphasis lies hierarchical organization concepts 
shall consider problem modifying terminological default logic specific defaults preferred 
short recapitulation default logic specialization terminological default logic section shall consider existing approaches expressing priorities defaults shall point appropriate purpose see section 
reason section alternative approach dealing prioritization framework reiter default logic 
formalism general setting default logic priorities arbitrary partial ordering defaults 
terminological default theories priorities defaults induced position prerequisites concept hierarchy 
shall exhibit interesting properties new formalism shall compare existing approaches 
turns extension definition extension ex reader surprised taken default property penguins look cover 
tension reiter definition extension extensions compatible partial ordering defaults excluded formalism 
default theories extension normal default theory extension 
defaults restricted prerequisite free normal defaults approach coincides ordered default theories brewka junker 
section problem compute extensions addressed 
preparation report learned brewka proposed generalization ordered default theories case normal defaults prerequisites 
section shall briefly introduce brewka approach point differences approach 
proofs deferred appendix 
default logic section briefly reviews reiter default logic specialization terminological default logic see details 
reiter default logic reiter deals problem formalize nonmonotonic reasoning introducing nonstandard nonmonotonic inference rules calls default rules 
default rule expression form ff fi fl ff fi fl order formulae 
ff called prerequisite rule fi justification fl consequent 
set default rules denote sets formulae occurring prerequisites justifications consequents pre jus con respectively 
default rule closed iff ff fi fl contain free variables 
semi normal iff justification implies consequent normal justification consequent identical 
default theory pair set closed order formulae world description set default rules 
default theory closed iff default rules closed 
intuitively closed default rule applied consequent added current set beliefs prerequisite believed sake simplicity consider defaults justification 
results easily extended general case defaults finitely justifications 
justification consistent set beliefs 
formally consequences closed default theory defined notion extension called extension set deductively closed firstorder formulae defined fixed point construction see 
general closed default theory may extension extension 
depending wants employ skeptical credulous reasoning closed formula ffi consequence closed default theory iff extensions extension theory 
reiter gives alternative characterization extension shall slightly modified way definition extension 
th gamma stands deductive closure set formulae gamma 
definition set closed formulae closed default theory 
define ffl ff fi fl ff th fi 
extension iff th 
note extension constructed iteration process occurs definition iteration step 
adding consequents defaults iteration extension form th con subset easy consequence definition inconsistent extension iff inconsistent 
generalize notion extension arbitrary default theories just assumes default free variables stands ground instances 
reiter original semantics world description consequents defaults skolemized building ground instances enlarged signature 
shown skolemization leads semantic algorithmic problems reason shall dispense case terminological default theories 
terminological default logic formally introducing particular terminological language see details shall just mention features terminological languages important 
terminological part languages allows build complex concept descriptions atomic concepts unary predicates roles binary predicates 
purposes suffices know concept description regarded firstorder formula free variable subsumption hierarchy concepts corresponds implication formulae subsumed iff valid 
assertional part language state object instance concept individuals connected role logically means constant symbols names objects build formulae respectively substituting free variable applying binary predicate constants finite set formulae called abox 
important inference problems aboxes abox consistent object instance concept logical consequence abox 
noted formulae obtained concept descriptions terminological language belong restricted subclass order formulae free variable 
reason subsumption consistency instantiation problems usually decidable languages 
terminological default theory pair abox finite set default rules prerequisites justifications consequents concept descriptions 
obviously aboxes seen sets closed formulae concept descriptions seen formulae free variable terminological default theories subsumed reiter notion open default theory 
motivated section building ground instances 
means open default terminological default theory interpreted representing closed defaults obtained instantiating free variable object names occurring abox 
interpretation possible compute extensions terminological default theories see section 
previous approaches prioritization conflicts occur reasoning defaults quite obvious specific information prevail general 
context terminological default theories means instance concepts default prerequisite preferred subsumed mentioned requirement taken account reiter approach 
assume penguin bird flies appropriately defined concept descriptions penguin formulae occurring rule assumed identical free variables 
subsumed bird terminological default theory consisting world description danny defaults penguin flies flies bird flies flies extensions 
contains flies danny flies danny semantics gives reason preferring second specific default applied 
overcome kind problem approaches realizing priorities defaults proposed literature 
priorities may induced specificity prerequisites described may come sources reliability defaults 
prioritization semi normal defaults reiter show kind prioritization defaults achieved changing formalism encoding priority information justifications semi normal defaults 
specific default example preferred second negated prerequisite default conjoined justification second second default rewritten bird flies penguin flies simple example handled approach clear treat complex situations 
example direct conflict consequents defaults default lower priority generally blocked prerequisite higher priority 
blocking default lower priority activated context consequents lead contradiction 
reiter describe general method solving problems just focus certain fairly simple patterns default rules 
problem starts normal defaults example ends semi normal defaults realizing priorities way 
means face undesirable properties non normal defaults non existence extensions 
additional problem brewka points additional knowledge requires blocking default default rewritten 
prioritized default theories order avoid semi normal defaults brewka takes ideas underlying prioritized circumscription defines iterated version default logic calls prioritized default logic pdl 
set defaults takes finite number sets 
closed defaults intended meaning defaults higher priority pdl extensions defined iterated application reiter definition extension set closed formulae prioritized default theory 
iff extension gamma pointed brewka approach sense restricted prerequisite free normal defaults 
problem caused prerequisites demonstrated example 
assume levels priority consisting default fi fl fl second fi fi 
start empty world description default applied constructing extension level 
second level fires get fi extension default fire longer considered second level 
restricted prerequisite free normal defaults prioritized default logic yields prioritized version poole approach default reasoning exhibit quite reasonable behaviour 
reason appropriate formalism treating specificity terminological default theories defaults put levels priorities totally ordered 
subsumption gives partial ordering defaults 
ordered default theories approach just described generalized situation priorities arbitrary partial ordering defaults 
precise ordered default theory triple set closed order formulae set closed prerequisite free normal defaults strict partial ordering fd dg finite principal idea consider total extensions partial ordering computing extensions ordered default theory shall call extensions 
enumeration 
compatible partial ordering defines note finiteness condition fd dg finite extension follows 
starts th step iteration consequent fi default fi fi added fi consistent set formulae obtained step gamma 
current set formulae remains unchanged 
limit process extension 
ordered default theories allow priorities partial ordering approach directly realize specificity terminological default theories 
reason restriction defaults severe 
fact terminological default theories priorities wanted consider induced subsumption relationships concept descriptions prerequisites 
means prerequisite free terminological defaults longer need prioritization 
situation bad 
shown closed normal default ff fi fi approximated closed normal default ff fi ff fi 
start normal terminological default theory determine priorities defaults prerequisites transform defaults corresponding ones prerequisites 
way ends ordered default theory approximates terminological default theory handles priorities induced specificity prerequisites terminological default theory 
claim approach satisfactory gives lot 
pointed approximation gets rid prerequisites defaults properties classical implication reasoning cases reasoning original defaults 
example assume addition concept descriptions penguin bird flies description winged objects having wings subsumption relation penguin bird 
consider terminological default theory consisting world description danny defaults penguin flies flies bird winged winged winged flies flies preferred extension danny wings fly 
approach described yields extension yields danny wings soon approximation default fired contrapositive third fired gives winged danny 
necessary sufficient existence enumeration compatible 
shows approach defaults longer behave simple forward rules 
similarity default rules monotonic forward rules terminological systems reasons choosing default logic place 
default theories specificity overcome problems pointed previous section shall propose new approach handling priorities defaults prerequisites 
semantics close reiter semantics properties theory resemble reiter theory 
default theory specificity triple 
consisting closed default theory strict partial ordering fd dg finite terminological case abox obtained instantiating terminological default rules constants occurring abox 
instantiated terminological default rules prerequisites iff concerned object specific subsumed vice versa 
restriction ordering satisfied finite definition terminological default theories 
definition extension default theory specificity modelled reiter iterative characterization extensions see definition 
main idea treating priorities consequent default added iteration step default delayed preferred default exist smaller default currently active 
set closed formulae closed default ff fi fl say active iff prerequisite consequence ff th justification consistent fi th consequent consequence fl th 
definition 
default theory specificity set closed formulae 
define ffl ff fi fl ff th fi active extension 
iff th 
difference reiter characterization additional requirement smaller defaults active current state iteration 
definition extension get intuitively correct result example defaults concerning penguins birds objects wings 
fact penguin second default asserting birds normally wings fire specific default asserting penguins normally fly applied 
means third default asserting winged objects normally fly applicable penguin prerequisite derivable negation justification added 
means definition extension chooses existing extensions respects priorities 
theorem states case set extensions subset set extensions 
theorem extension default theory specificity 
extension 
proof appendix 
main idea take obtained sequence construct sequence characterization extensions 
easy see converse true 
fact consequent fl default may added delayed smaller default active 
straightforward way prove th show set active defaults delaying decreases iteration 
unfortunately set defaults delaying may increase prerequisites smaller defaults derivable step may derivable step iteration 
proof shall circumvent problem considering set defaults may potentially delay defaults smaller currently active may active soon prerequisite derivable see appendix details 
default theories extensions follows default theory specificity need extension 
extensions need exist extensions default theory specificity 
demonstrated example 
example assume empty consider defaults fi fi fi fi fi ff ff assume default smaller second respect 
default theory extension th fig extension 
fact extension prefer default yields fi third default modified version known rule example default theory having extension relevant 
case specificity normal default theories specificity nicer properties arbitrary default theories specificity 
theorem closed normal default theory specificity 
proof appendix relatively straightforward adaption reiter proof extensions 
construct extension th normal default theory reiter starts world description successive steps adds consequents active defaults possible destroying consistency con maximal subset set defaults active con consistent 
take priority information strict partial order account construction simply modified considering active defaults minimal respect 
see appendix details 
appendix shall show construction yields extension normal default theory specificity 
general extensions obtained way 
example shows true normal default theories specificity 
example assume empty contains defaults ff ff fi fi ff fi fi assume ordering defaults empty means notions extension extension coincide 
default theory extensions th fff fig th fff fig 
obtained successively adding maximally consistent sets consequents active defaults 
fact defaults active 
fff fig consistent exactly maximal set fd con consistent fd 
set get way fff fig 
shows extension contain fi obtained 
normal default theories specificity orthogonality see theorem semi monotonicity see theorem 
defaults priorities semi monotonicity expected hold adding default high priority course able change extensions considerably 
restrict attention normal defaults prerequisites notion extension coincides extension shows approach generalization ordered default theories 
theorem set closed prerequisite free normal defaults 
extension default theory specificity 
iff extension ordered default theory 
assumed finite proof relatively easy general case possibly infinite sets defaults involved see appendix 
computing extensions extensions extensions generate extensions default theory extension directly definition extensions check extension 
terminological default theories provides effective procedure computing extensions 
fact shown compute terminological default theory 
finitely closed defaults instantiation problem terminological languages decidable iteration definition extension effective 
may exist lot extensions extensions computing extensions expensive 
reason preferable algorithm directly computing extensions 
idea algorithm iteration similar definition extension having final set controlling consequents defaults added 
iteration stable case finite sets closed defaults check additional condition sure result really extension 
main problem determine sets consequents candidates added step iteration 
course correct choice may exist 
look definition definition see defaults consequents added defaults active minimal priority order 
subset consequents taken depends set iteration 
algorithm know final consider arbitrary subsets shall see constraints reduce number possible choices 
noted greedy procedure takes maximal subsets consistent computed overly modest procedure adds consequent step complete 
example demonstrates greedy procedure absence specificity information 
examples illustrate overly modest procedure appropriate computing extensions section 
nondeterministic algorithm subset con subset jus set formulae fi fi fg 
algorithm 
closed default theory specificity 
inconsistent th extension 
define 
assume defined 
consider fd active active choose nonempty subset satisfies fi th con jus fi jus 
set choice yields new sets con jus 
set th extension iff 
ff fi fl fi 
fi fi proof soundness completeness algorithm appendix 
idea sets follows 
consequent minimal active default included reason justification consistent final extension 
exclude default know negation justification belong extension 
condition corresponds fact defaults consequents added extension justifications consistent extension 
condition ensure local correctness choices 
reason check conditions ensure global correctness 
terminological default theories steps algorithm effective provided consistency instantiation problem underlying terminological language decidable assumption usually satisfied 
addition finitely closed defaults iteration stable finitely steps 
related preparation report learned brewka proposed generalization ordered default theories described section case normal defaults prerequisites 
section shall briefly introduce brewka approach point differences approach 
brewka considers default theories specificity 
finite set closed normal defaults 
total extension defines extension th called extension follows 
exists default active ffig fi consequent minimal default active results follows extension extension 
means approach brewka takes subset set extensions admissible extensions default theory specificity 
examples show general takes subset 
example demonstrates may get extensions extension 
example assume empty consists normal defaults ff ff fi ff ff fi fi ff fi fi relationships defaults show th fff fig extension 
fact definition extensions yields fff fig active prerequisites deducible minimal defaults active addition ff fi shows fff fig 
active negated justifications deducible shows brewka definition extension ff fi added step iteration depending active 
restrict attention case fffg 
case ffig symmetric 
active extension know minimal default active 
reason get fff fig shows get th fff fig way 
easy see example extensions th fff fig th ff fig extensions 
general extensions need extensions 
demonstrated example 
example assume empty consists normal defaults ff ff fi fi fi fl fl ff fl fl relationship exists th fff fi flg extension extension 
show extension consider total extension 
ordering obviously get fffg 
active smaller default active 
get fff flg 
step active default means fff fl fig 
defaults active shows th extension 
show extension 
iterative definition extensions obviously get fff fig 
observe active means consequent added negation justification consequent delayed 
shows th th fff fig addressed question prefer specific defaults general ones 
problem general interest default reasoning important terminological case emphasis lies hierarchical organization concepts 
previously existing approaches handling priorities defaults brewka ordered default theories turned come nearest needed solving specificity problem terminological default theories 
restriction prerequisite free normal defaults severe adequate solution terminological case 
proposed new approach called default theories specificity handling priorities defaults prerequisites 
properties prove formalism demonstrate quite reasonable generalization reiter default logic brewka ordered default theories 
addition correctly handles examples approaches give unintuitive results 
brewka independently developed generalization ordered default theories case normal defaults prerequisites turned orthogonal approach sense extensions obtained approach obtained vice versa 
described method generating extensions default theory specificity 
method effective provided base logic decidable finitely closed defaults 
restrictions satisfied terminological case means terminological default logic specificity decidable 
priority ordering proposed terminological default theories takes account strict subsumption links prerequisites terminological defaults 
wants consider specificity induced defaults example adapt method proposed brewka definition approach 
interesting point research consider priorities terminological defaults take subsumption prerequisites defaults account role relationships aboxes 
peter patel schneider interesting discussions specificity defaults bernhard nebel helpful comments draft 
supported german ministry research technology research contract 
baader hollunder 
embedding defaults terminological knowledge representation formalisms 
proceedings rd international conference knowledge representation reasoning cambridge mass 
besnard 
default logic 
symbolic computation series 
springer 
brachman mcguinness patel schneider resnick borgida 
living classic language 
sowa editor principles semantic networks pages 
morgan kaufmann san mateo calif 
brewka 
specificity default logic application formalizing obligation 
preprint 
brewka 
preferred subtheories extended logical framework default reasoning 
proceedings th international joint conference artificial intelligence pages detroit mich 
brewka 
nonmonotonic reasoning logical foundations commonsense 
cambridge university press cambridge 
delgrande jackson 
default logic revisited 
proceedings nd international conference knowledge representation reasoning cambridge mass 
junker brewka 
handling partially ordered defaults tms 
proceedings st european conference symbolic quantitative approaches uncertainty france 
kobsa 
sb knowledge representation workbench 
preprints workshop formal aspects semantic networks calif 
lifschitz 
computing circumscription 
proceedings th international joint conference artificial intelligence pages los angeles calif 

making kr systems useful 
terminological logic users workshop proceedings pages kit report tu berlin 
mcgregor 
statement interest 
von luck nebel editors statement interest nd international workshop terminological logics 
document dfki kaiserslautern 
ginsberg editor 
readings nonmonotonic reasoning 
morgan kaufmann los altos cal 
back 
system presentation 
terminological logic users workshop proceedings page kit report tu berlin 
padgham nebel :10.1.1.52.6219
combining classification nonmonotonic inheritance reasoning step 
working notes aaai fall symposium issues description logics pages 

luck kindermann org 
terminological logic users workshop proceedings 
kit report tu berlin 
reiter 
logic default reasoning 
artificial intelligence 
reiter 
interacting defaults 
proceedings th international joint conference artificial intelligence 
appendix 
proofs theorems proof theorem theorem extension default theory specificity 
extension 
assume th extension obtained iteratively generating sets 
described definition 
prove extension need technical definition lemmas 
define ff fi fl ff th active set contains defaults delay step iteration may delay step prerequisite deducible 
assumption strict partial ordering exist finitely means sets finite 
lemma shows stays gets smaller index increased 
lemma proof 
ff fi fl default contained assume ff th 
yields ff th contained hand assume active ff th fi th fl th 
ff th done 
ff th default active fi th fl th imply fi th fl th 
lemma states default prerequisite believed state iteration justification consistent eventually fire iteration 
lemma ff fi fl ff th fi exists index fl th 
proof 
lemma proved induction cardinality set defaults smaller active active obviously contained 
assume empty defaults smaller active assumption ff th fi implies fl take 
assume empty 
ff fi fl minimal default respect distinguish cases 
case fi active know ff th minimality implies delayed smaller default active shows fl lemma yields oe case fi th means exists fi th 
addition fact active implies fi th yields fi th ff th th deduce yields oe seen cases exists index oe obviously implies ff th th shows satisfies assumption lemma 
induction get index fl th 
prove theorem take extension obtained sequence construct sequence described characterization extensions ffl ff fi fl ff th fi 
show extension prove th 
lemma proof 
easily proved induction general direction hold necessarily subset get th immediate consequence lemma 
lemma fl exists index fl th 
proof 
lemma proved induction show assume 
fl element fl gamma know induction fl th assume fl gamma consequently fl consequent default ff fi fl prerequisite ff th gamma justification consistent fl 
fl formulae gamma ff th ffl 
fl 
induction know formulae fl th gamma exists index fl th 

ffl 
fl th implies ff th 
know fi assumptions lemma satisfied conclude exists index fl th 
proof theorem theorem closed normal default theory specificity extension 

closed normal default theory specificity 
inconsistent th extension 
assume consistent 
extension 
inductively constructed follows 
define fd active active con maximal subset con consistent 
compactness know th consistent 
show extension prove th ffi ff fi fi ff th fi active immediate consequence lemma 
note need fact nf gamma may contain elements fl th gamma nf gamma elements th gamma gamma definition active 
lemma th th 
proof 
lemma proved induction show assume know th th 
show th 
fi element fi th know induction fi th th 
assume fi th 
fi con means exists default ff fi fi active default active order prove fi fi th show default active ff th fi properties follow immediately know th th induction 
third property follows fi fact consistent 
concludes proof th 
show th 
fi element case fi th trivial 
assume fi th 
means exists default ff fi fi default active ff th fi th th yields note really need know fi th th conclude active remains shown fact element assume contrary maximality means ffig inconsistent turn means fi th 
fi th contradicts fact consistent 
proof theorem theorem set closed prerequisite free normal defaults 
extension default theory specificity 
iff extension ordered default theory 
inconsistent th extension extension 
assume consistent 
note means extensions extensions consistent 
prove theorem consistent show extension normal prerequisite free theory 
extension 
fi fi fi fi fi fi 
enumeration compatible defined enumeration 
means th fi th ffi 
define sets described definition extension see definition 
remains shown iteration really yields th 
immediate consequence lemmas 
lemma proof 
proof induction assume consider fi fi know fi induction 
fi know things fi fi fi default fi fi occurs enumeration exists fi fi addition fi implies fi th gamma yields fi fi lemma proof 
proof induction assume consider fi fi induction yields fi hand fi nf means fi fi fi know fi fi get fi remains shown active recall default fi fi active iff fi th fi th 
deduce 
fi induction yield fi implies fi fi active assume fi means fi th gamma gamma gamma induction gamma yields fi th 
implies fi fi active concludes proof extension extension 
direction assume th extension normal prerequisite free theory obtained iteratively generating sets described definition 
lemma says satisfies property obviously true extensions trivial extensions 
lemma fi fi fi fi proof 
proof induction 
assume fi reason fire ith step iteration exists default fi fi active gamma induction know fi fi exists index fi th fi th 
seen exists index longer active step iteration 
exist finitely defaults smaller means eventually fire shows fi show extension shall define strict partial ordering extends show enumeration compatible yields extension 
main idea definition prevent consequents fi defaults fi fi fi added extension 
reason sure defaults fi fi 
fi fi fi 
fi fi th ffi 
fi 
main technical problem show finiteness property set fd dg finite 
property necessary exist enumeration compatible define set defaults fire step iteration fd fi fi fi th gamma fi active gamma note fi fi implies fi fi fired fd fi fi fi 
obviously fired disjoint note union strict subset lemma fi fi exist nonnegative integer finite set defaults fired properties holds 
fi th 

ii fi th gamma fi th con 
proof 
know lemma fi th 
define smallest fi th 
define 
fi th satisfied assume 
minimality yields fi th gamma 
fi th deduce exist defaults 
ii fi th con fd 

define fd 
ready define extension looking 
transitive closure relation oe oe defined oe iff fired obviously extension implies remains shown appropriate purposes 
lemma relation satisfies properties 
noetherian exist infinitely descending chain ae ae 

partial ordering 

satisfies finiteness property set fd dg finite 
proof 
note oe strict partial orderings satisfying finiteness property 
just condition partial ordering satisfy admissible theory 
oe transitivity follow disjointness fired fact fired implies situation oe situation oe oe occur 
finiteness property oe immediate consequence fact finite oe irreflexive satisfy finiteness property noetherian 
reason infinitely descending chain loss generality form 

fired prove chain infinite show larger 

know ii know active gamma means justification say fi inconsistent gamma fi th gamma 
shows smaller smaller 
relation transitive definition 
follows fact noetherian 
finiteness property shown noetherian induction consider sets fd dg fd oe dg 
sets finite oe satisfy finiteness property 
successors elements sets successors 
induction know elements sets finitely successors completes proof lemma 
fi fi fi fi 
enumeration compatible finiteness property guarantees enumeration exists 
th extension defined enumeration 
extends extension 

remains shown lemma proof 
proof induction 
gamma gamma induction 
assume gamma ffi fi exists finite set defaults fi th con 
fi fi fi enumeration 
compatible means fi gamma fi gamma second case occur mean fi induction 
sum seen consequents defaults gamma shows fi th gamma contradicts assumption gamma ffi lemma completes proof theorem 
lemma proof 
previous lemma know exists default fi fi fi fi implies fi contradicts fact consistent 
soundness completeness algorithm algorithm 
closed default theory specificity 
inconsistent th extension 
define 
assume defined 
consider fd active active choose nonempty subset satisfies fi th con jus fi jus 
set choice yields new sets con jus 
set th extension iff 
ff fi fl fi 
fi fi inconsistent th extension algorithm yields case 
may assume loss generality consistent 
prove soundness assume th obtained described algorithm accepted admissible output satisfies conditions checked algorithm 
show extension generate sets described definition extensions 
means define ffl ff fi fl ff th fi active extension th 
shown proving th th 
proceed induction assume th th known 
lemma th 
proof 
fl element fl th fl th th induction 
assume fl th 
means exists default ff fi fl reason fl definition know ff th th default active th th means active 
get fl fl th remains shown fi case satisfies condition checked algorithm 
lemma th 
proof 
assume fl induction case fl th trivial 
fl th know exists default ff fi fl ff th th fi active obviously fi implies fi th th th yields get fl remains shown assume fi second condition checked algorithm yields fi know fi completes proof soundness 
show completeness assume th extension obtained sequence 
described definition extensions 
choose right sets algorithm 
assume corresponding sets defined sets satisfy th th note trivially satisfied 
define fd ff fi fl fi fd active active obviously subset empty easy see induction hypothesis th th th th th 
get th th th th show nonempty subset satisfying fi th con jus fi jus 
justification fi default satisfies condition th th shows fi contradicts assumption empty 
assume empty 
show fi jus satisfy condition fi th con jus immediate consequence lemma fi jus satisfies fi definition 
lemma th con jus proof 
extension deductively closed sufficient prove con jus induction know th th fl con fl definition assume ff fi fl fi jus 
fi seen admissible subset lemma shows jus defined algorithm subset addition definition con satisfies th th 
fact difference possible nf ne nf may contain additional elements elements th th 
sum shown induction step algorithm choose admissible set set th obtained choice coincides th 
th 
remains shown conditions algorithm satisfied 
ff fi fl fi definition sets lemma implies 
