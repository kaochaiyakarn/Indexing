pass evaluation region algebra expressions matthew young lai frank wm 
tompa department computer science university waterloo waterloo ontario canada region algebra collection operations apply lists regions useful model querying text databases 
address problem evaluating region algebra expression 
naive method evaluate operations time storing intermediate results reading back needed 
describe alternative method merges argument region lists performs evaluation single pass merged list 
ecient evaluating operations time visits input region exactly avoids writing intermediate results re reading inputs subsequent operations 
key words text database region algebra expression evaluation query optimization consider string character alphabet 
region pair natural numbers representing substring equal 
region algebra set functions takes lists regions arguments returns list regions result 
typically region lists algebra operates restricted way size 
example regions list may allowed nest overlap 
initially assume restrictions 
examples region algebras described literature tompa burkowski mannila clarke navarro :10.1.1.56.5928
algebras indexing query model structured documents increasingly prevalent preprint submitted elsevier preprint december world wide web 
traditional database models suited structured text region algebras emerged favored alternative 
usual way evaluating region algebra expression evaluate function calls time sequential order 
query optimization strategies try minimize size intermediate results choosing order intelligently transforming expressions prior evaluation navarro consens 
introduce method avoids need store retrieve intermediate results 
uses single pass visits input region exactly 
structure selection queries expressions de ne structure selection query function list arguments selects subset regions dependency regions structure selection queries expressed form fs cg boolean expression consists clauses joined logical operators brackets specify precedence 
clause form fs rg fd rg generally arithmetic expression involving boolean expression quali ed example structure query contained returns fs selects regions inside region similarly containing returns fs selects regions contain region example function uses clause arithmetic expression involving starts soon returns fs selects regions left characters right point convention speci ed arguments query named furthermore assume region region allows specify query de nitions unambiguously writing just constraint assume presence existential quali er speci ed 
example contained written 
talk query time speci calls queries introduce subscript refer separate queries case arguments regions arguments 
assume function included region algebra depends arguments 
structure selection queries means tautology selects contradiction fails select 
eciently recognize badly de ned structure selection query lemma structure selection query de ned boolean expression clauses determine contradiction tautology time 
proof 
clauses refer points domain character positions string compare expression involving valid query assignment making expression true making false 
di erent clauses relevant assignment classes test 
points compared regions region start string rst point region point string 
exactly assignments interest 
true false expression tautology contradiction 
composition query query passing result call argument 
example statement means perform query perform result 
recall set returned query speci ed form fs boolean expression involving existential quali er compose functions passing result argument returned set fs instances replaced result passed rst argument instances replaced passed second argument 
example set returned composition containing contained fs result contained call subset replace instances give fs fig 

expression graph dag 
query rst argument result query second result query set speci cation form fs instances replaced instances replaced applying rules recursively write set speci cation result query expression 
de ne dependency expression set speci cation boolean expression component existential quali ers removed 
query denote 
example contained 
denote dependency expression query expression graph 
example containing graph de ned contained dependency expression seen general description possible positions region may ect region satis es query 
example letting denote logical implication see contained region 
words match relevant decision keep match start ends 
algebra expression composition queries 
de ne expression graph representation algebra expression follows query represented node query takes result query argument edge node node height node expression graph number nodes longest path node leaf 
expression graph acyclic 
function call result argument result function contributed evaluation 
expression graph need connected tree 
multi rooted graph represents set expressions just 
directed acyclic graph dag example represents expressions common subexpression rooted bottom evaluation input expression graph set arguments queries leaf nodes 
result evaluating expression graph set results queries root nodes 
results queries roots intermediate results subexpressions 
bottom evaluation queries leaf nodes evaluated reading region lists corresponding arguments writing region list corresponding result 
queries non leaf nodes evaluated time arguments evaluated 
evaluation method region input travels expression graph read input query possibly written result step 
region nal output expression graph travels way leaf root way 
regions may travel rst part path discarded 
region read written step mentioned techniques reduce number repeat visits transforming graph prior evaluation 
propose di erent approach eliminates repeat visits completely 
pass evaluation describe evaluation strategy di ers signi cantly bottom approach 
recall expression graph corresponds function set region lists 
alternative way viewing set region lists single integrated list regions tagged type indicates list region located 
refer avoid outputting intermediate results inputting cases keeping memory 
interested cases memory requirements independent database size algebra large text collections 
typed list region inventory 
inputs outputs function corresponding expression graph region inventories 
note expressions formed composing structure selection queries output region inventory subset input 
forward passes suppose input region inventory regions stored sorted primarily left right left sorted right sorted 
specify secondary sort order reasons explained 
consider loop iterates region inventory sort order process region processing region involves reading input immediately outputting part expression graph output 
depending sort order refer loop forward deterministic pass left sorted input forward deterministic pass right sorted input 
term deterministic analogy deterministic nite transducers way deterministic nite transducer needs look ahead character choose transition take deterministic pass needs look ahead region decide output current region 
bu er alternative outputs choose backtrack 
note necessary store input region inventory directly list typed regions loop 
store separate lists logically merge time execute loop 
similarly split output region inventory separate lists executing loop 
strategies appropriate depending form input available form output needed 
particular separate lists appropriate representation region algebra interactively situations unknown left sorted right sorted input may required 
deterministic iterates regions xed order loop evaluate arbitrary expressions 
general example evaluate expressions containing contained calls prove 
consider regions shown 
suppose contained contain contained contain suppose fig 

list regions related contained containing 
iterate list left sorted order visit know kept dependencies 
know keep looking ahead point visit extension know keep indirectly depend consider right sorted order case read know keep regions 
read know keep depend general problem arbitrary compositions contained containing require lookahead regardless sort order pass 
need characterize conditions expression require lookahead 
start considering individual queries part expressions 
individual query requires lookahead decision keep discard region region read loop 
lemma single query requires lookahead left sorted input 
proof 
decision keep depends earlier left 
input left sorted read lookahead needed 
lookahead required needed decide keep read means relate guaranteed earlier left 
words 
example query implies 
query implication 
evaluate rst query forward deterministic pass left sorted input second 
regions equal left ends left sorted input assumptions relative ordering consider secondary sort order decide comes pass 
avoid issue assuming regions equal left ends read bu ered processing meaning treat read simultaneously 
strategy lemma lemma single query requires lookahead left sorted input 
corresponding lemma right sorted input follows 
assume equal regions sort order read bu ered processing 
proof similar lemma 
lemma single query requires lookahead right sorted input 
consider multiple queries 
evaluate queries expression graph forward deterministic pass query dependency expression imply lookahead 
left sorted input example imply region referenced 
words regions needed decide satis es query visited note assumes list referenced ect result query follows directly assumption functions depend arguments 
show implies lookahead query exactly implies lookahead query theorem evaluate expression graph structure selection queries forward deterministic pass left sorted input query 
proof 
prove necessity condition 
lemma query requires lookahead calculate 
prove suciency condition induction height query base case single query dependency expression implies requirement theorem requires lookahead 
induction hypothesis query height dependency expression implies 
induction step consider query height induction hypothesis applies descendants heights equal 
build dependency expression usual way starting left child right child replacing instances instances perform induction step 
know induction hypothesis 
know induction hypothesis 
condition theorem know substitution 
follows result calculated lookahead 
theorem evaluate expression graph structure selection queries forward deterministic pass right sorted input 
proof 
proof form previous theorem 
consider application theorems 
queries imply condition theorem 
theorem states deterministic pass evaluate expression formed composing calls queries regardless large 
conditions theorems basis categorization query functions 
henceforth refer functions satisfy condition queries forward pass satisfy condition queries forward pass 
note function categories 
example function condition condition 
consider slight variation forward deterministic pass 
suppose input left sorted outputting region immediately left sorted order bu er regions temporarily give right sorted output 
individual query require lookahead case necessary regions depends read output 
normal forward deterministic pass regions depends may visited visited 
case visited time bu ered 
read left sorted position bu ered right sorted position evaluating query expression graph requires implies 
call query satis es implication condition query forward pass 
evaluate condition query part expression graph imply regions 
fig 

overlapped regions 
true evaluate queries expression condition queries deterministic pass left sorted input output 
consider regions 
suppose depends depends true true 
decide keep lookahead forward pass left sorted input right sorted output 
problem condition implication transitive 
expressions composed condition queries evaluated deterministic pass 
state conditions know sure expressions constructible queries region algebra evaluable forward deterministic pass properly sorted inputs outputs theorem set query functions evaluate expression formed queries set forward deterministic pass properly sorted input output functions condition functions condition 
proof 
suciency condition established preceding theorems 
know evaluate expressions entirely condition condition functions forward deterministic pass 
show necessity condition prove set functions condition condition possible construct expression requires lookahead compute 
true pass left sorted input left sorted output theorem true pass right sorted input right sorted output theorem 
possible iteration right sorted input left sorted output may require regions output read 
remaining option left sorted input right sorted output 
queries expression graph require lookahead option imply suppose query query 
condition may condition condition may condition fig 

situation requires lookahead 

consider composition 
region decision satis es may require knowledge region 
similarly decision region satis es may require knowledge region 
result subset means determining satis es depend region situation shown 
decision satis es decision satis es 
conditions consistent calculate lookahead 
reverse passes consider reverse deterministic pass visits regions descending left sorted right sorted order process region preceding results adapted case corollary set query functions evaluate expression formed queries set reverse deterministic pass properly sorted input output functions satisfy functions satisfy 
proof 
proof symmetrically theorem occurrences left right swapped 
refer functions satisfying condition queries reverse pass satisfying condition queries reverse pass 
classi cation function necessarily passes directions 
example condition condition forward pass condition condition reverse pass 
examples general structure selection query written set speci cation classi ed implied order example contained condition direction results evaluate expression formed queries forward deterministic pass reverse deterministic pass 
similarly containing condition direction evaluate arbitrary expressions forward reverse deterministic pass 
evaluate arbitrary expressions formed composing contained containing deterministic pass mixes condition condition queries example 
example query intersect performs set intersection returning regions set speci cation condition condition direction 
set query subtract returns regions set speci cation condition condition direction 
nal example consider set speci cation 
nds regions follow abut region condition condition forward pass reverse pass 
opposite function set speci cation condition condition reverse pass forward pass 
algebra containing functions classi cation evaluate expression formed algebra deterministic pass 
example containing intersect subtract condition forward direction 
de ne algebra consisting just functions evaluate expression forward deterministic pass left sorted input 
example algebra consisting contained intersect subtract condition reverse direction 
evaluate expression algebra reverse deterministic pass left sorted input 
eciency memory required evaluate expression deterministic pass equal sum memory required evaluate query expression 
queries introduced examples constant memory memory requirement evaluating expressions queries linear size expression 
additional memory needed satisfy assumption equal regions sort order bu ered processing 
general bu ering required arbitrary 
additional condition eliminate problem 
consider left sorted region inventory formed merging lists 
suppose lists contains regions equal left ends condition enforced pat tompa multitext clarke example :10.1.1.56.5928
regions time share left region inventory 
number lists linearly bounded number queries expression graph 
amount bu ering remains linearly bounded size expression graph 
note argument holds merging lists region inventory done consider bottom evaluation strategy expression graph 
query read arguments output results 
nal results read inputs query 
contrasts evaluating expression deterministic pass way intermediate results need written read 
input region visited exactly 
time saving pass evaluation vary depending expression data 
larger size intermediate outputs bottom evaluation saving realized pass evaluation 
general functions preceding results depend functions expression structure selection queries 
fact arbitrary function region lists region lists classi ed condition condition way structure selection query write set speci cation describes output region terms region depends check implied order region inventory 
general functions possibility output depends region 
case implication hold output region depends 
example consider function merge overlaps nds pairs outputs region running pair 
description implies right equal right output 
function condition forward pass 
left ends greater equal left output 
function condition reverse pass 
evaluate expression constructed condition functions deterministic pass 
pass evaluation method simplest way pass evaluation method design algebra consisting entirely condition functions entirely condition functions pass direction 
ensures expression constructed algebra evaluated pass method 
unfortunately limits mix functions included 
example contained containing 
somewhat restrictive option break algebra groups functions group entirely condition condition pass direction 
allow user construct expressions functions group time 
way functions di erent groups constructing separate expressions output expression input 
nal restrictive option break algebra groups functions allow user construct expressions arbitrarily mix functions di erent groups 
system automatically break expressions subexpressions containing functions group 
subexpression evaluated pass output intermediate subexpressions inputs sub expressions 
strategy basis optimization method existing methods transform graph evaluation 
attempting minimize size intermediate results attempt minimize number required passes 
needed develop idea robust optimization method 
summary described evaluation method region algebra expressions uses single deterministic pass input region inventory 
method ecient bottom evaluation expression visits input region eliminating need output intermediate results read back 
de ned terms general way classifying functions considering xed set functions typical algebras 
needed examine alternative forms pass evaluation 
example may di erent rules restricting design algebra evaluation method allows constant lookahead region inventory lookahead 
wish explore evaluation methods input output region inventories strictly left sorted right sorted 
example suppose regions type displaced constant number positions left right sorted positions suppose regions type sorted region inventory restriction ordering regions di erent types 
exploration cases yield alternative methods eciency described fewer restrictions permissible functions 
burkowski 
algebra hierarchical organized text dominated databases 
information processing management 
clarke cormack burkowski 
algebra structured text search framework implementation 
computer journal 
consens 
algebras querying text regions expressive power optimization 
journal computer system sciences 
mannila 
retrieval hierarchical texts partial patterns 
korfhage rasmussen willett 
eds sigir proceedings th annual international acm sigir conference research development information retrieval 
new york 
navarro 
language queries structure contents textual databases 
proceedings th sigir 
tompa 
pat expressions algebra text search 
acta linguistica 

