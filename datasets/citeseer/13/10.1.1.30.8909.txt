classification algorithmic skeletons duncan campbell department computer science university york december algorithmic skeletons seen high level parallel programming language constructs encapsulating expression parallelism communication synchronisation embedding costing 
report examines classification algorithmic skeletons proposing classification examining devised 
various algorithmic skeletons examined categorised form core algorithmic skeletons suitable general classification practical experience skeletons 
categorisation compared proposed 
similarly skeleton approaches briefly examined 
algorithmic skeletons algorithmic skeletons envisaged high level parallel programming language constructs encapsulating expression parallelism communication synchronisation embedding having associated cost complexity 
skeletons parallel threads sequential looping constructs goto label providing structured expression certain algorithmic forms 
algorithmic skeletons help reduce parallel programming errors part concurrency toolbox programmers construct abstraction required solve problems 
requirement algorithmic skeletons long known 
backus bac called programming languages designed fixed set high level constructions capturing common computation patterns 
constructs necessary parallel programming complex serial programming due greater degrees freedom involved 
serial programming involves single thread computation time parallel programming involves multiple threads computation need communicate synchronise 
complexity increased massively parallel processing increases number threads executing concurrently needing communicate synchronise 
furthermore algorithmic skeletons correspond programming level terms mccoll classification models parallel computation mcc provide notation precise high level description correct efficient methods solutions computational problems 
overview survey example skeletons section 
summarised section basis general classification algorithmic skeletons survey 
candidate classifications section overview skeleton approaches section 
various classifications described compared author classification section 
summary section 
sample skeletons various authors lists algorithmic skeletons examined author cam summaries 
cole darlington nelson snyder quinn tropes scheme language 
reader note skeleton names written original authors written referring standard notation 
example darlington dfh refer pipeline skeleton pipe written pipe 
cole skeletons cole col coined term algorithmic skeletons gives example skeletons fixed degree divide conquer restriction ubiquitous divide conquer method requiring degree non leaf nodes process tree constant known execution 
see illustration 
restriction provides greater control distribution expense degree flexibility programmer level 
suitable problems include discrete fourier transforms approximate integration matrix multiplication iterative combination problem solved iterative combination described set homogeneous objects details relevant internal structure relationship 
rule combining objects measure value combination skeleton iterates loop object combined possibly parallel suitable remaining object exists objects combined acceptable combinations exist 
method appropriate solve problems progressively imposing structure initially uncoordinated collection objects 
suitable problems include minimum spanning tree connected components 
cluster skeleton designed perspective implementation rectangular grids processors 
suitable problems data sets instances described collection homogeneous objects individual descriptions may include information relates 
problems solved recursively clustering possibly parallel objects independent sub clusters corresponding maximal sub set objects connected directly transitively specific notion closeness 
continues possible suitable members clusters considered members parent cluster operated way respect 
clustering process imposes hierarchy clusters set objects original complete set root measure closeness parameterised level hierarchy 
recombining clusters pairs objects similarly considered manipulated appropriately 
task queue skeleton generalisation farm skeleton illustrated 
problems instance solutions represented terms large data structure proceed repeated concurrent execution instances task ma part data structure respect certain 
task instances may generate details task instances added back task queue 
suitable applications shortest paths lu matrix decomposition divide solve solve combine divide divide solve solve combine combine divide solve solve divide divide solve solve combine combine combine divide combine level binary divide conquer skeleton slave slave slave master master 
farm skeleton darlington skeletons darlington dfh put forward list skeletons pipe captures simple linear process parallelism 
see illustration pipeline processes 
models simple pipelining processes list possibly different functions composed elements streamed 
farm captures simplest form data parallelism function applied list independent jobs potentially parallel results combined controlling process see example 
dc models ubiquitous divide conquer method described see 
ramp reduce map pairs skeleton object system potentially interact object 
individual interaction calculated results combined produce result object 
skeleton typically initial specification implementation transformation alternative form farming calculation object 
dynamic message passing architecture skeleton process interact directly process message passing actual connections determined run time 
process initial state records local values messages processes may modify process state generate new messages processes 
skeleton describes dynamic algorithms interactions processes determined run time data 

pipeline skeleton list skeletons language pipe pipeline method described see 
loop models iterative recursive computations sequential parallel process 
farm various forms process farms modelled 
include cases identical slave functions process input data input data processed different slave functions portion input data processed slave functions conditioned guards 
see example 
geometric vector processing data parallel computations modelled process topology specified particular mapping data partitions function executes partition data 
see example 
tree structure combining distributing tree programmer specifying leaf non leaf processes number levels 
see example 




example geometric skeleton 
example combining tree skeleton nelson snyder skeletons nelson snyder ns examined skeletons compute aggregate broadcast appropriate algorithms composed basic phases compute phase performing basic computation aggregate phase usually tree computation combining local data global values broadcast phase returning global information directive back process 
skeleton may iterate phases necessarily starting compute phase phases generally order 
suitable problem solution skeleton parallel implementation jacobi iterative method solving laplace equation 
pipeline systolic suitable algorithms sub computations assigned dedicated processes data flowing processes expected locality communication regular communication structure different types simple processes 
problems suitable solution skeleton include band matrix multiplication dynamic programming hough transform 
see example pipeline form example systolic form 
divide conquer described see 
example systolic skeleton skeletons gss provide list skeletons described task graphs asynchronous processes independently precedence constraints operation communicating shared data message passing provided induces explicit dependencies processes 
suitable problems include matrix multiplication solving partial differential equations 
synchronous processes execute parallel explicitly synchronised executing lock step fashion communication place synchronisation points 
skeleton underlies skeletons special case multiphase skeleton empty serial phase linear synchronous pipeline data progressing processes lock step global clock 
suitable problems synchronous skeleton include synchronous jacobi algorithm solving partial differential equations 
see example 
multiphase composed serial phase single active process parallel phase concurrently active processes alternating computation 
serial phase master controls actions processes parallel phase slaves allocating parallel processes criteria 
suitable problems include power systems simulations travelling salesman 
see example 
partitioning processes divide divide phase compute partition phase combine results merge phase 
skeleton tends characteristic sorting searching algorithms 
may implement divide conquer algorithms described quicksort decomposing computation parallel execution 
see example 
pipeline models synchronous asynchronous pipelining described 
suitable problem systolic metropolis algorithm 
see example 
transaction processing covers algorithms described rest list 
requests arrive task force external source fielded parallel processes 
usually important maintain consistency global data synchronisation access performed efficiently 
suitable problem railway simulation 
variety problems broad construct graph skeleton really described skeleton 
sync 
sync 
sync example synchronous skeleton quinn skeletons quinn qui provides classes simd data parallel algorithms processes lock step zero synchronisation costs 
mimd pipelined pipelined algorithm described see 
systolic algorithm generalised kind pipelined algorithm direction data flow 
see example 
mimd partitioning problem divided sub problems solved individual processors solutions combined form problem solution 
implicit synchronisation processors means partitioning algorithms called synchronised algorithms 
categories partitioning algorithms pre scheduled algorithms process allocated share computation compile time self scheduling processes allocated global list run time 
mimd relaxation processes asynchronously goal partitioning may specialisation purpose pipelined essentially processor wait data processor working available data 
algorithms called asynchronous algorithms 
master 
master slave slave slave slave slave slave master example multiphase skeleton skeletons goo lists skeletons data parallel involves single thread control executing parallel computing elements 
example problems include vector matrix operations scan operations 
function evaluation function notations tend expose data dependencies potential concurrency 
independent sub trees formed expression evaluation application recursive relations executed parallel 
divide conquer described see 
client server algorithm consists collection entities provide services 
service requested client entity providing service server passing request result returned client 
usually referred aspect object oriented programming 
farming described see 
pipelining described see 
appropriate pipeline latency traded frequency results produced 
problems suitable skeleton include associated signal processing 
gabber skeletons gabber gab provides classification tree computations problems solved broken simpler sub problems solved recursively 
solution process resembles tree computations data flow root leaves solutions flow back root see 
examples include divide conquer described game tree search combinatorial search 
crowd computations algorithms defined terms set operating processes independent process communicating synchronising peers mainly message passing 
communication structure crowd computations normally follows regular graph ring mesh torus hypercube tree may change computation 
processes may shared memory pass information asynchronously 
skeletons rab provides categorisation referring skeletons paradigms recursively partitioned problem solved dynamically recursively dividing sub problems solved independently parallel final result obtained recursively combining solutions sub problems 
general divide conquer described exploits conservative parallelism sub problems need solved compute solution 
speculative parallelism exploited skeleton building partial solutions testing parallel possible improvements discarding partial solution improvements solving sub problems knowing usefulness results 
suitable problems include sorting computing convex hulls queens combinatorial search see example 
process networks computation divided stages data flowing stages operate concurrently 
process networks may uniform operation repeated stage multi function stages implement different functions static dynamic may communication pattern 
pipeline instance skeleton illustrated systolic skeleton illustrated 
distributed independent farm skeleton described see 
suitable problem random number generation 
iterative transformation operates set objects local data possibly sharing global values objects transformed iteration steps 
iteration step operations performed local object computes local data data objects including global data combine combining groups objects form set objects global computing global data possibly local data 
iterative transformation static combine operation parallelism arising concurrent application local operations object implemented sr dynamic number objects changes run time additional parallelism arising group objects combined independently groups 
special cases iterative transformation cole iterative combination see nelson snyder compute aggregate broadcast see 
suitable problems include numerical analysis image processing parallel branch bound graph problems 
tropes approach utilisation algorithmic skeletons generative communication undertaken production tropes hms 
tropes described primitive program schemes form parameterised conditional rewrite rules applied gamma language 
gamma general model multi set manipulation bcl minimal language single data structure multi set corresponding control structure metaphor chemical reaction 
state system multi set molecules chemical solution molecules interact reaction rules chemical reactions 
programs consist sets reaction pairs multi set rewritings components condition predicate characterising molecules transform action function yielding new molecules 
execution gamma program succession reactions consuming molecules specific reaction condition producing new ones 
execution terminates stable state reached molecules satisfy reaction rules 
tropes series rewrite rules skeletons gamma transmuter applies transformation operations elements multi set satisfy conditions keeping size multi set constant 
equivalent task queue skeleton repeatedly applying function available jobs see 
reducer reduces size multi set applying function pairs elements satisfying condition 
equivalent combining tree skeleton see 
optimiser optimises multi set particular criterion preserving structure multi set 
expander decomposes elements multi set collection basic values 
equivalent distributing version tree skeleton 
selector acts filter removing elements multi set satisfying certain condition 
bmf section combination map reduce operations combination transmuter reducer tropes 
seen list tropes similar skeletons proposed 
general classification seen readily commonalities various lists 
lists algorithmic skeletons surveyed previous section involve divide conquer skeleton dc dfh fixed degree divide conquer col divide conquer ns divide conquer goo tree partitioning gss tree computation gab reducer expander hms recursively partitioned rab 
skeletons contain level abstraction functionality divide conquer form 
relationships skeletons illustrated general skeletons higher hierarchy level hierarchy box 
similarly surveyed lists involve pipeline systolic skeleton pipe dfh pipe pipelining goo pipeline systolic ns pipeline gss mimd pipelined qui process networks rab 
skeletons offer different levels abstraction functionality general pipeline systolic form 
relations skeletons illustrated general skeletons higher hierarchy level hierarchy box 
lists involve farm skeleton farm dfh farm task queue col farming goo transmuter hms distributed independent recursively partitioned rab tree computation gab partitioning gss divide conquer goo divide conquer ns dc dfh fixed degree divide conquer col tree reducer hms expander hms hierarchy divide conquer skeletons process networks rab mimd pipelined qui pipeline gss pipeline systolic ns pipe dfh pipe pipelining goo hierarchy pipeline systolic skeletons rab 
skeletons generally level hierarchy functionality task queue general slave processes may produce new performed slaves 
potential classification involves iterative transformation skeleton iterative combination col computer aggregate broadcast ns iterative transformation rab 
potential classification involves skeletons particular process graphs crowd computation gab includes data parallel skeletons restrictive cases requiring homogeneous processes geometric data parallel goo simd qui 
leaves seemingly disparate skeletons allocated form general classification ramp dfh dfh loop cluster col function evaluation goo client server goo asynchronous gss synchronous gss multiphase gss partitioned qui relaxed qui optimiser hms 
beginnings general classification algorithmic skeletons seen author involving various cited collections skeletons 
tentative proposal basis classification cam follows recursively partitioned taken classification covering divide conquer skeletons identified 
consists generalised tree structured skeleton exploiting conservative speculative parallelism 
suitable problems solved dynamic recursive division problem subproblems solved independently parallel recursively combining sub solutions 
problems include divide conquer game trees quicksort combinatorial search approximate integration matrix multiplication connected ones task queue cole generalisation farm skeleton allowing slave processes produce new performed slaves 
covers farm skeletons identified 
includes problems amenable solution broadcasting jobs solved independently 
example problems include shortest paths random number generation systolic skeleton covers pipeline systolic skeletons identified 
consists stages data flowing may operate concurrently 
example problems include signal processing applications systolic metropolis algorithm band matrix multiplication dynamic programming hough transform crowd gabber classification covering problems represented graphs including data parallel problems 
distinct systolic skeleton flow data concurrently operating stages 
examples include combine skeleton fjl butterfly graph structure problems bitonic merge sort bat fft categories appear sufficiently distinct merit separate classification sufficiently general encapsulate minor algorithmic variations 
recursively partitioned task queue capture problems suitable solution distributed solved independently solutions combined 
hand systolic crowd capture problems solved application distributed graphs processes 
recursively partitioned differs task queue recursively divides problem indivisible sub problems solution broadcasting ready sub problems 
systolic differs crowd notion flow stages processes operating concurrently data supplied continuous stream single collection data applied process graph 
skeleton classification schemes bmf bird meertens formalism bmf bir originally conceived derivational style functional programs ski ski 
bmf consists set theories built base algebra unary binary functions theory captures behaviour particular class data structures 
bmf theory begins base types extends new types type functors adding base algebra set second order functions laws relate 
laws provide set meaning preserving transformations applied optimisation regarded rewrite rules completeness result intended guarantee language sufficiently expressive 
bmf extends concept data types adts categorical data types ski 
adts categorical data types operations equations relating guarantee required operations equations 
theory built constructors type categorical construction 
discovered bmf application basis data parallel functional programming language 
bmf program consists composition functions particular data type cs cs 
communication model restricted set second order functions encapsulates particular communication pattern requiring constant size neighbourhood locality ski 
bmf directly express parallelism compiler task implement operations parallel manner 
parallelism communication hidden direct concern programmer 
considering theory join concatenation lists bmf homomorphism lists expressed composition map followed reduce 
map reduce basic algorithmic skeletons operations lists 
shared topology standard topology theory lists including logarithmic depth spanning tree hamiltonian cycle 
similarly type theories matrices graphs sets constructors homomorphisms types expressed composition constructors skeletons 
major drawbacks bmf solely data parallel functions nested 
skillicorn appear acknowledge possibility nesting functions bmf having compiler flatten nested functions correct bmf ski 
despite having recognised data parallelism applicable previously thought hs lacking expressibility multi threaded predominantly breadth evaluation case code mss 
code expresses data parallelism operations non scalar objects 
supports range parallel operations providing rank coercion mechanism permits application parallel operators combination objects irrespective ranks match 
code exploits functional parallelism representing concurrency evaluating operands operation 
basel algorithm classification scheme bg driven goals reusability portability 
scheme describing algorithms placing algorithms set categories 
algorithms described tuple process structure static dynamic process topology worker pipeline mesh tree hypercube process macro execution structure series events see distinguish similar execution structures categorical data types come equipped set second order operations map reduce primitives data parallel computation model 
form operations guarantees existence parallelism 
bmf section generally specific particular bmf theory lists 
interaction global coupled barrier broadcast line broadcast fan pipe step rotate red black shuffle global decoupled local semaphore mailbox monitor linda direct signal wait send receive exchange data placement data placed data distribution global static dynamic 
events types calculation step interaction step daemon call total partial 
total events processes participate indicated superscripted partial events non empty subset processes participating indicated superscripted may include description set participating processes 
different types event may specified 
calculation steps may subscripted indicate different sequences statements 
interaction steps may subscripted refer type interaction 
daemon calls may subscripted distinguish creation deletion calls creation calls parameterised number kind created processes 
furthermore macroscopic execution structures indicate type loops distinguishing loops fixed numbers repetitions conditional numbers repetitions 
subscripted topology contains sequence events parentheses 
classification principally process structure data distribution resulting categorisation form static dynamic process static global dynamic data pure classes data distributed way viz dpsd 
simple mixed classes data distributed ways viz 
total mixed classes data distributed ways viz 
time related classification macroscopic execution structure contains information lapse time dividing algorithms sub classes 
additionally topology means sub classification 
combination topology data distribution leads huge set possible classes 
restrict fixed hardware topology reduce possible combination process topologies data distributions 
classification scheme forms basis language writing algorithmic skeletons offering reuse small constructs classification gee presents classification algorithmic skeletons broad classes style general functionality 
classifications control oriented skeleton described means control structure 
style various skeletons operate common data structure data oriented skeleton described valid operations data structure processor array modelled list communication abstracted skeletons permuting 
style control structure arrange operations specified skeleton 
distinction related control data parallelism completely comparable relation 
second classification captures sense skeletons different levels abstraction architectural skeleton particular architecture having straightforward interpretation typical elementary computation architecture algorithmic function expressible terms available architectural skeleton 
views process skeletons composing individual skeletons forming programs mapping algorithmic skeletons architectural skeletons 
similar view proposed author cam skeletons composable structures algorithmic skeleton mapped architectural model clumps model computation mapped target architecture 
skeleton approaches exist approaches parallel computation describing algorithmic skeletons definitely skeleton 
brief overview 
shared data types designed alternative message passing shared memory support high performance sharing applications 
intended effective abstraction mechanism compromise performance insulates programmer details data management 
essentially represent high level data types adts shared parallel processes implemented parallel hiding implementation user 
offer guarantees behaviour conditions high scalable performance scalable architectures 
implementation strategy distributed activity focussed point free locks critical sections provide maximal concurrency 
example include fifo queues accumulator captures general form existing combining style operations 
similar algorithmic skeletons terms motivation encoding particular mode computation 
skeleton data type tree mesh tree data type high level adt programming parallel applications involving adaptive computation capturing data computational structures adaptive problems 
rich set access functions including higher order operators abstracting commonly computational patterns parallel adaptive computation 
tree generalisation quadtree degree non leaf node dimension degree dimension quadtree 
node tree represents region domain subtrees sub regions overlaying node region 
provides abstraction hierarchical partition arbitrary order 
order operations perform basic query update operations node whilst higher order operations commonly patterns parallel adaptive computation 
bmf cro paradigm uses bmf constructs add parallel operations traditional sequential programming language 
parallelism provided map reduce zip operations bmf theory lists 
stages transformations sat gor designed support derivation parallel distributed memory programs transformation rules bmf higher order functions lists 
program viewed single thread stages parallelism occuring stages 
target view considered perception developing program aim parallel composition sequential processes 
design view considered orthogonal target view regarding parallel program sequence stages encapsulating parallelism possibly different kinds 
design view sat consists layers inter stage layer stages sequentially composed invoked intra stage layer stage parallel program invoking mixtures computations communications 
sat approach consists specifying algorithm design view obvious way transforming provably correct target view 
bmf functionals source parallelism represent stages program development 
communication skeletons ski intended extend unify existing models systolic arrays fixed connection network algorithms reconfigurable network algorithms bus networks homomorphic skeletons 
incorporate aspects fixed connection topology approaches bsp val fixed connection skeletons algorithms assume particular interconnection structure unit time nearest neighbour communication bsp form supersteps involve local computation global communication guaranteed complete barrier synchronisation superstep 
communication skeleton interleaving set uniform communication steps computation steps encapsulating useful operations internal parallelism allowing limitation weakened unit time step message received processors path 
communication skeletons topology assumption underlying topology design topology mapped target topology 
best choices design terms simulation capabilities meshes complete binary trees 
design patterns described object oriented algorithmic scheme intended capture solutions building recurring design problems systematic general ways 
problem solution descriptions design patterns include explanations applicability trade offs consequences solution 
design pattern illustrates implement solution object oriented programming language 
design patterns code implemented time applied 
designers supply application specific names key classes object pattern implement class declarations definitions pattern prescribes 
comparison author classification primarily empirical justified basis fellow researchers actual experience algorithmic skeletons 
classification represents separation proposed skeletons distinctly identifiable functionality categories form classification proposed 
bmf mathematically formal computationally restrictive scheme limited data parallel skeletons 
map reduce operations correspond task queue recursively partitioned skeletons respectively 
order represent crowd skeleton bmf theory lists needs extended include compound list operators clos ks order able represent necessary communication patterns 
bmf theory lists general classification skeletons proposed author 
formal approach bmf led similar limited range skeletons empirical approach detailed 
scheme appears means surveying algorithms classifying algorithmic skeletons 
classification particularly broad incorporating large range parameters accounted 
algorithmic skeleton classification proposed author 
formed basis language specifying algorithms similar style characteristics 
divided algorithmic skeletons groups software side hardware side 
skeletons software side correspond closely algorithmic skeletons hardware side skeletons far general aim concerned 
software skeletons broad classes style functionality 
abstracting far skeletal structures algorithmic skeletons intended capture 
promising scheme examples referred different level traditional algorithmic skeletons considering specialised operational structures 
tree particularly limited kind data type equivalent single skeleton recursively partitioned skeleton 
due bmf extended bmf constructs suffers draw backs bmf 
stages transformations limited source parallelism bmf operations theory lists suffer similar expressibility problems bmf 
communication skeletons borrowing bmf assumptions target topology providing truly architecture independent mapping skeletons 
application bsp model parallel computation particularly interesting bsp particularly promising model 
design patterns object oriented nature explicitly incorporate additional documentation pattern 
despite popularity object oriented community appear limited object oriented domain provide seemingly ad hoc mechanism code reuse 
summary algorithmic skeletons seen high level parallel programming constructs necessary parallel programming programmer able program parallel programs easily 
currently algorithmic skeletons proposed reexamined 
profusion algorithmic skeletons necessitates form classification 
classification proposed survey skeletons re examined 
skeleton classifications examined 
classification scheme perspective 
bmf set operations provided category theory data types 
general categorisation algorithms 
classifies skeletons broad classes style 
author classification attempts take existing skeletons proven useful experience groups general distinct classifications 
underway examination linda gel cg case reasoning cbr part involves identification macro operations algorithmic skeletons performing cbr linda 
resulted proposal operations skeletons intersection comparison tuple spaces 
intersection operation generalised skeleton performing operations tuple tuple space 
clearly demonstrates practical development algorithmic skeletons particular application cbr particular programming style linda 
offered murray cole edinburgh university various comments andrew vickers york university suggestions 
bac backus 
programming liberated von neumann style 
functional style algebra programs 
communications acm august 
bat 
sorting networks application 
afips spring joint computing conference volume pages 
bcl 
banatre coutant lem 
parallel machine multiset transformations programming style 
generation computer systems 
de roure 
guaranteeing unpredictability 
computer journal 
burkhart frank 
structured parallel programming informatics help overcome software 
proceedings priority programme informatics research information conference 
vlissides yu 
automatic code generation design patterns 
ibm systems journal 
bg burkhart 
software reuse portability parallel programs 
el shriver editors proceedings eighth annual hawaii international conference system sciences volume pages 
ieee computer society press 
bir bird 
lectures constructive functional programming 
broy editor constructive methods computer science pages 
nato asi series springer verlag 
burkhart korn 
basel algorithm classification scheme 
technical report university basel 
cam campbell 
clumps candidate model efficient general purpose parallel computation 
phd thesis department computer science university exeter october 
cg gelernter 
write parallel programs guide 
acm computing surveys 
col murray cole 
algorithmic skeletons structured management parallel computation 
pitman 
cro 
robustness performance structured parallelism 
kara davy nash editors machine models parallel distributed computing pages 
ios press 
cs cai skillicorn 
evaluating set message passing routines transputer networks extended 
department computing information science queen university kingston october 
cs cai skillicorn 
evaluation set message passing routines transputer networks 
allen editor transputer systems ongoing research 
ios press 
davy dew nash 
concurrent sharing data types case study 
kara davy nash editors machine models parallel distributed computing pages 
ios press 
dfh darlington field harrison kelly sharp wu 
parallel programming skeleton functions 
parallel architecture languages europe parle 
di orlando 
methodology development support massively parallel programs 
technical report tr dipartimento di informatica universita di pisa december 
fjl fox johnson otto salmon walker 
solving problems concurrent processors volume 
prentice hall international 
gab gabber 
practical tool development portable efficient programs multiprocessors 
ieee transactions parallel distributed systems 
gee 
transformational development data parallel algorithms 
phd thesis university nijmegen 
gel gelernter 
generative communication linda 
acm transactions programming languages systems 
goo 
performance multiprocessor communications networks 
phd thesis department electronics university york 
gor 
stages transformations parallel programming 
kara davy nash editors machine models parallel distributed computing pages 
ios press 
gss siewiorek segall 
parallel processing cm experience 
digital press 
hms hankin le sands 
parallel programming style algebra programs 
bode reeve wolf editors parle parallel architectures languages europe pages 
springer verlag 
lncs 
hs hillis steele 
data parallel algorithms 
communications acm 
ks kumar skillicorn 
data parallel geometric operations lists 
department computing information science queen university kingston canada january 
mcc mccoll 
architecture independent programming model scalable parallel computing 
general purpose parallel computing pages 
british computer society parallel processing specialist group december 
university 
mss muchnick sutton 
code implementation portable software platform data parallelism 
computer journal 
ns nelson snyder 
programming paradigms nonshared memory parallel computers 
jamieson gannon douglass editors characteristics parallel algorithms chapter 
mit press 
qui quinn 
designing efficient algorithms parallel computers 
mcgrawhill 
rab 
exploiting parallelism functional languages approach 
dew lake editors machine models highly parallel computers 
oxford university press 
ski skillicorn 
architecture independent parallel computation 
technical report issn department computing information science queen university kingston ontario march 
ski skillicorn 
practical parallel computation 
technical report issn department computing information science queen university kingston ontario august 
ski skillicorn 
parallelism bird meertens formalism 
department computing information science queen university kingston april 
ski skillicorn 
department computing information science queen university kingston 
personal communication 
ski skillicorn 
communication skeletons 
kara davy nash editors machine models parallel distributed computing pages 
ios press 
sr schwarz 
skeleton implementation iterative transformation algorithms functional languages 
kara davy nash editors machine models parallel distributed computing pages 
ios press 
val valiant 
bridging model parallel computation 
communications acm august 
wu field kelly 
data abstraction parallel adaptive computation 
kara davy nash editors machine models parallel distributed computing pages 
ios press 

