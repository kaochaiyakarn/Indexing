query processing issues object oriented knowledge base systems tamer ozsu dave randal peters laboratory database systems research department computing science university alberta edmonton alberta canada integration database management db artificial intelligence ai technologies leading development knowledge base management systems kbms frequently discussed 
potential benefits integration significant 
examples successful ai db integration common 
difficulty finding suitable integration architecture problems 
problem current database models techniques integration 
current commercial state art database technology settling relational model fundamental data structuring organization formalism sql primary data access language 
current technology commercial products developed primary purpose supporting data processing applications 
applications typically manipulate collections relatively simple data interrelationships modeled relatively straightforward manner 
additionally access data supported defined primitive operators 
data information manipulated knowledge base systems complex complex relationships 
furthermore development languages datalog cgt demonstrate manipulation requires operators complex powerful relational calculus algebra 
object orientation expected play role development system structuring paradigm data management system 
number early efforts fis ss sz commonly accepted object data model formalization 
model differs formalism support features object identity kc encapsulation state behavior sb type inheritance cw typed collections 
features object oriented database management system oodbms provide matter controversy see example abd srl 
successful provide functionality relational systems 
current address systems flanders road ma 
functions include declarative query language transactions view management 
chapter concentrate issues design query languages formalization processing 
recognize may early exhaustive discussion issues 
query models query processing quite undoubtedly relevant issues uncovered 
restrict discussion issues addressed research 
rely heavily yo provides framework evaluating query models specifically object algebras 
query declarative expression calculus normalized object expression algebra typecheck expression consistent type expression algebra optimized plan access generation access plan algebra optimization transformation calculus algebra optimization calculus query processing methodology extend relational query processing methodology jk gv depicted 
steps methodology follows 
queries expressed declarative language requires user knowledge object implementations access paths processing strategies 
calculus expression reduced normalized form eliminating duplicates applying identities rewriting 
normalized expression converted equivalent object algebra expression 
form query nested expression viewed tree nodes algebra operators leaves represent extents types database user defined collections objects 
algebra expression checked type consistency insure predicates methods applied objects support requested function 
simple type checking general programming languages intermediate results sets objects may composed heterogeneous types 
step query processing application equivalence preserving rewrite rules type consistent algebra expression 
lastly execution plan takes account object implementations generated optimized algebra expression 
methodology forms framework chapter 
presentation chapter follows parallel tracks 
discuss fundamental design modeling issues demonstrate issues addressed referring previous str example 
take detour section discuss nature knowledge base systems role object orientation design 
section address objectoriented data model issues relate query models 
section discuss specifics query model issues including definition calculus algebra 
chapter distinguish data model query model 
separation useful rich data structuring type systems 
data model context defines logical structuring objects query model concerns procedural declarative access primitives safety equivalence completeness 
type checking type inference rules covered section 
define typechecking rules object algebra section 
optimization algebraic expressions covering query rewrite rules topic section 
section addresses final step methodology including object manager design issues generation execution plans mapping algebraic expressions object manager operations 
subject address full optimization object oriented queries generation alternative execution plans 
cost function compute cost plan optimal plan alternatives chosen 
area fully studied 
related important problems addressed briefly reviewed section 
section provide concluding remarks suitability methodology remaining open problems 
assume reader familiarity object oriented concepts terminology 
knowledge base systems section discuss nature knowledge base systems cover arguments favor object oriented paradigm organize 
nature knowledge base systems knowledge base differ database expert system 
question subject considerable debate research community consensus 
fact instances ai database literature knowledge base system synonymously expert system 
intention engage detailed discussion nature knowledge base systems section 
number attempts address specifically issue fro ull wie wie 
give working definition adopt 
knowledge base structured collection ffl data representing facts aspects domain discourse modeled called extensional database fact base ffl knowledge represents higher level interpretation understanding domain discourse called intensional database rule base 
knowledge base considered composition intensional extensional databases 
knowledge base management system defined tool provides ffl facilities managing intensional database extensional database ffl language facility enables access knowledge base ffl mechanisms application knowledge data order respond queries require reasoning facts 
language facility assists accessing database traditional sense enabling issuing queries require reasoning factual data 
results returned basically new knowledge application domain 
consider example office information systems domain specifically hypertext system 
example chapter 
hypertext system stores things information documents authors system assertion document authored joe smith cruise missiles fact stored traditional database 
dbms answer queries form author document list documents cruise missiles 
statement documents cruise missiles considered top secret considered knowledge difficult store manage traditional database 
example dbms able easily handle query document top secret 
responding query goes mere retrieval stored facts requires reasoning capabilities knowledge base store fact document authored joe smith cruise missiles extensional database knowledge documents cruise missiles considered top secret intensional database 
query document top secret processed kbms reasoning capabilities produce answer 
clear separation intensional extensional databases course difficult problem 
avoid discussion chapter refer reader wie fro 
object oriented kbms organization architecture kbms provides features mentioned discussed time 
attempts coupling expert systems traditional dbms 
designs extensional database maintained traditional dbms aw 
expert system issues calls dbms access data 
approach called loose coupling sh depicted 
important problem approach 
fact base extensional database managed means dbms knowledge implicit embedded expert system code 
management knowledge follows pattern identical management data traditional file processing knowledge storage processing embedded application code abstracted 
explicit storing knowledge data management generalized tool brings advantages data management ai application developed top kbms 
tighter integration intensional extensional databases reasoning capability leads knowledge representation independence bro provides order differentiation expert systems 
kbms reason stored facts produce answer posed queries functionality ends 
expert system take response solve problem 
consider hypertext example 
kbms responds query document top secret answer successfully completed task 
expert system hand takes response uses reach decision take action deciding security access control action 
demonstrate point consider complicated knowledge base query officer read document 
expert system uses reasoning capability kbms determine security level document security clearance domain specific knowledge link security clearance security level determine outcome 

follow point expert system application specific 
knows set facts knowledge inference rules order reach solution problem 
kbms hand quite general application inference rules 
simply stores manages provides access set facts applies inference rules produce knowledge knowledge problem domain 
fact kbms may manage facts knowledge number expert systems 
cases inference rules stored intensional database may come application domain medical diagnosis kbms know assume knowledge associated class documents 
traditional database systems model situation inefficiently associating secrecy knowledge individual documents 

knowledge reasoning stores data factual stores 
expert system database extensional knowledge database intensional request retrieval fact data data stored facts request knowledge dbms expert system intensional database loose coupling expert systems dbms semantics rules domain know solving domain specific problem 
viewed fashion kbms constitutes technological base expert systems just dbms forms technological base data processing applications 
role object orientation general framework 
way answer question point frame min ai applications examples embody number features object oriented systems 
lines cite object oriented ai programming languages flavors moo bkk clos moo 
repeating obvious clarifying role object oriented technology ai applications 
curiously easy find compelling constructive arguments favor object oriented technology structuring paradigm ai literature 
systems built object oriented tools languages exist conceptual generalizations regarding conditions technology harder find 
argument favor object oriented technology terms nature intensional database managed kbms 
previous section indicated ai applications deal complex data complex relationships 
keeping terminology introduced section representation knowledge intensional 
expert system knowledge result request reasoning knowledge reasoning stores data factual stores database extensional database intensional expert system kbms knowledge base approach database 
features intensional database structure complex data types man complex interrelationships data types appear particularly suitable application object oriented technology 
quoted man discussion justifies claims criterion important information 
numbers values relationships things database care 
structure data 
important information data relational database knowledge care things structured related probably want oodb just want accounting planes ships cost relational database 
want know parts subassemblies relate airplane ship oodb place start needed structure modeling design driving force 
lines sheu sky indicate framework object oriented knowledge base significantly different non object oriented knowledge base frameworks aspects 
object oriented knowledge base deals objects explicitly semantics associated different entities 

treats procedures class entities knowledge procedures included 
note inferencing function kbms may satisfied enhanced inclusion active objects model dbm 
active objects observe events system react triggering certain actions 
events monitored conditions fulfilled executed response typically defined form event condition action eca rules 
addition potential representation formalism intensional database object oriented technology architectural paradigm organizing kbms 
intensional extensional databases may different representation access performance requirements 
object oriented technology appealing candidate deal heterogeneity allows encapsulation databases management routines time providing uniform interface outside world means abstraction capabilities 
manola suggests generation knowledge information systems involve integration heterogeneous information sources including heterogeneous distributed databases knowledge systems expert systems involving heterogeneous knowledge representations conventional programs associated processors 
man 
object oriented technology suitable vehicle integration uniform management heterogeneity 
assuming case object oriented technology knowledge base systems successfully concentrate design issues providing declarative query facility object oriented database systems 
object data model issues power flexibility object oriented systems introduce considerable complexity models 
feasibility defining object data model sense relational model questioned mai 
comprehensive discussion treatment issues scope restricted data model issues relate directly definition query languages processing 
model design considerations aspects data model direct bearing query model capabilities need included query processor 
issues entirely independent 
illustrate design decision affect 
nature object 
different definitions object 
object data models consider objects simply complex data structures bk somewhat similar nested relation models permit relation valued attributes 
approach common models developed deal complex object structures exist example engineering applications 
object data models consider objects instances data types adts aco sz encapsulate representation objects set public methods access 
case type template instances 
variation level encapsulation enforced data models affects query models sense 
query model fully describe visible components objects accessed query primitives 
example objects tuple valued bkk query expressions directly access tuple fields name 
furthermore allowable query primitives dependent decision 
principle maintaining data abstraction paradigm require querying database object behaviors structure 
complete encapsulation require comparison operators query language identity objects structure 
query models provide relaxed form encapsulation enabling sort structure dependent equality check 
relationship objects types 
types relationships defined types objects mb conforms ct type ht 
maier define structurally structure objects manola buchmann mb define concepts behaviorally behavior objects defined methods 
object conforms type indicates object follows structural behavioral specification type 
conforms relation binds object structure behavior object minimally structure behavior type conforms may additional structure behavior 
stronger relation type specifies object explicitly declared instance specific type 
set instances type called extent denote ext 
object type ht ct loss generality assume existence object types assume type relationship defined objects 
relationships exist 
ht ct 
ct ht 
ht ct 
ct ht 
ht ht cases straightforward simply indicate declared extent type relation 
third fourth cases indicate objects conform type explicitly declared extent type 
object data models cases occur relationship types similar object type kinds relationships types 
type said specialize type structure behavior included structure behavior stronger relationship subtype 
type said subtype type explicitly declared specialize explicitly declared structure behavior included structure behavior 
case called supertype subtyping establishes relationship ht ht ht ct case ht ct cases follow subtype supertype relationships subtype supertype relationships types form hierarchy semilattice types allowed multiple supertypes parent type lattice supertype children types 
object data models fifth kind relationship occur subtype supertype relationship direction 
words object type type subtype models object explicitly declared type type relationships derived type semilattice 
models said enforce strong typing relevance relationships especially subtyping query processing 
subtype ht ht type relationship defines object extent type relationship extents ext ext respectively 
specifically ext ext 
net effect query asks instances usually retrieve instances 
extended multiple levels subtype supertype semilattice 
query result consists union objects instances types subtree type lattice rooted type query posed 
call deep extent type denote ext 
subtype extent ext ext extent subtyping relationship discuss section semantics associated fifth kind relationship discussed restricted straightforward semantics 
restriction design alternatives may introduced 
object data models permit variant objects may deviate template defined type manner 
called prototypical object models clone objects existing objects type definition template object creation 
models facilitate definition kind objects act type specifications 
systems allow variant prototypical objects lie mb longer possible specify full behavior object type influences kinds optimizations performed 
furthermore definition schema prototypical variant objects supported needs clearly worked 
variant objects allowed data model type longer template instances claimed minimal template 
defines minimal behavior objects extent type 
important reason 
schema defines minimal behavior query takes input schema database generates output schema database bk additional behavior specified variant prototypical objects queried 
single versus multiple types 
indicated interpretation fifth type relationship respect subtyping restricted semantics attached 
alternative semantics may objects allowed enter type relationships types subtype supertype relationship 
case object structure behavior depending model structural behavioral types 
consider example types employee student 
schema teaching associate represented having type relationship employee student types 
example modeled systems enforce restricted semantics multiple type relationships making type semilattice 
model teaching associate employee student type created supertypes employee student 
relaxed semantics multiple type relationships may considered flexible sense natural representation real world difficult handle query model 
difference data model allows objects belong multiple types simulates effect creating subtypes subtle 
new type type lattice part schema type definition exists schema 
assume existence system defined function maps object type example considering result applying function object represents teaching associate different cases 
return objects belong multiple types result explicit subtypes created 
semantics multiple type relationships creates problems query processing 
direct consequence definition type teaching associate defined type employee type student extent types 
restricted interpretation involving subtype employee student hand extent deep extent employee student 
queries ask instances student employee retrieve set instances cases 
query asks example teaching associates computer science department easier efficient process type existed 
case query involves simple selection extent 
case necessary selection extents employee student take intersection 
student objects employee objects subtype student employee teaching associates teaching associates ht student objects employee objects student employee alternative representations multiple type relationship sets 
assuming possible serve teaching associate department student 
case evaluation query requires sort join intersection extents types followed selection 
case evaluation expensive 
data models allow objects type relationships multiple types mb 
definitions models clear semantics associate relationship 
example states subtype object ht ht model specification force implication ht ht hold 
possible object related types subtype supertype relationship 
issues raise respect query processing hold mb accepts behavioral versions definitions 
classes versus collections 
previous section referred extents types 
object data models concept type extent separated 
models typically refer class type definition collection objects instances type 
data models separate concepts type class extent type 
discussion previous sections assume 
class concept aggregation instances associated type 
distinction models explicit notion class 
models objects grouped arbitrary collections 
far object creation concerned difference 
models class note defines subtyping terms type relationship 
definitions previous section opposite direction subtyping implies type relationship extents 
ways writing correct 
combining allow stronger definition subtyping replacing 
concept object automatically member class represents extent associated type created 
utilize user defined collections aggregations objects user expected explicitly specify membership object collections 
perspective query models difference respect targets queries 
class models queries posed classes 
models user defined collections queries specified collections 
consider hypertext example assume existence document type 
case document class queries defined 
query asks authors documents satisfy selection predicate retrieve documents satisfy predicate 
second case document class exists 
explicit collections query defined resulting retrieval documents collection user explicitly specify query collections union results 
note distinction important context defining schema target query pointed object data models employ class extent type approach easier conceptualize query kim 
furthermore possible models exploit subtype supertype relationship yo deep extents 
words clear semantics retrieving objects deep extent type models said collection models 
value combining approaches viewing alternatives recognized 
beeri bee proposed model defines classes extents types automatic membership semantics collections user defined subsets classes 
model collection subset class resulting homogeneous collections 
adopt approach separate classes extents types user defined collections supporting concepts 
contrast beeri permit heterogeneous collections facilitate uniform treatment results queries may target multiple classes collections 
mechanism sharing 
strengths object oriented models provide mechanisms sharing objects 
types sharing possible sharing implementation sharing behavior 
behavioral sharing called subtype supertype relationship 
important differentiate implementation sharing 
noted nierstrasz nie problems inheritance arise discrepancy notions 
goes associates subtyping types inheritance classes 
follows model describes type defined specification behavior objects type class specification template implementation objects addition serving collection objects type 
association may valid especially models support classes extent type approach critical point 
important aspect note relationship type definitions relationship implementations claim separated 
traditional object oriented languages smalltalk gr bundle concepts 
proposals implementing sharing inheritance smalltalk delegation lie 
inheritance sharing semilattice types classes assuming nierstrasz model classes specify implementation templates 
type child type hierarchy inherits behav ior delegation sharing achieved object explicitly delegating behavior implementation object 
large choice sharing mechanism tied choice type system 
models allow variant prototypical objects typically implement delegation sharing mechanism enforce strong typing implement inheritance 
recognition mechanisms similar ste semantics object data model permits prototypical variant objects implements inheritance sharing mechanism quite complicated 
specification inheritance types inheritance instances types different due existence variant objects link bound quite complex 
complications affect query processing directly optimization queries object oriented system take advantage semantics sharing 
uniformity model 
system object 
data models day fugue hz mb treat objects types methods defined system 
models bring uniformity treatment objects 
contrast models concepts methods types treated meta information separate objects 
uniformity object data model affects query formalism various ways 
notion schema source supplemental meta information separate database queried replaced concept schema including part database 
addition collapsing potential hierarchy meta meta meta information single level self describing system provides greater flexibility allowing efficient techniques specified query formalism previously considered meta information 
advantage approach may apply query formalism schema data order extract semantic information objects queried manipulation schema query formalism may possible 
second affect uniformity query formalism refers way method objects handled 
methods objects query model ability cope 
invoke access bodies 
observed mb capabilities require query language facilities invoking methods passing parameters methods dealing returned results 
final consideration uniformity deals query formalism 
order uniform system shouldn query model part object space 
case envision greater querying power flexibility allowing queries query model 
may useful example asking database questions certain query processed 
sense serve explanation facility system 
uniformity data model increases power query formalism cost additional complexity specification formalisation 
sense discussions previous sections revisited complete uniformity model assumed 
sample object data model section describe object data model forms basis investigation query processing object oriented databases 
summarize model refer counterpart holds classes respect implementation sharing 

gamma mm gamma composition method applications 
full formal definition 
identifying characteristics data model 
objects viewed instances data types manipulated functions defined type 
types organized inheritance hierarchy allows multiple inheritance 
object unique time invariant identity independent state 
relations object identities equality set inclusion provide basis query primitives qualify query operators 
relations objects implemented adt interfaces 
briefly highlight properties 
classes methods model distinction class type 
class defines type interface methods stands objects instances type 
methods named functions arguments result objects 
method signature form theta theta result specify class argument objects result specifies class result object 
classes database form class lattice root node represents general class objects individual class may multiple parents 
subclasses inherit behavior parents may define additional methods 
class lattice provides inclusion polymorphism cw allows object class context specifying superclass sz 
similar conformance relationship emerald subtype relationship functional language ponder fai 
object behavior objects encapsulate state behavior 
methods defined class object instance define object behavior 
behavior revealed applying method object 
result method application object 
dot notation delta delta delta mm denote method application method composition 
assuming methods mm take arguments method takes arguments illustrates processing denoted operation 
method applied objects resulting object method applied objects returning object final result object obtained applying method mm objects rm gamma gamma 
note dot notation denotes function application composition traditional record field selection attribute selection bkk car ms 
mlist list method names unimportant 
object state object state captured value distinct identity kc sb 
object values atomic value provided database system int string uninterpreted byte sequence set value collection object identifiers structural value 
structural values visible class implementors encompass attributes tuples discriminated unions aco 
aspects structural values required users class revealed implementor method ultimately delivering atomic set value 
example database hypertext application selected example belongs application domain office information systems claimed potentially benefit object oriented database technology 
specifically hypertext system requires persistent data large number data types types ad hoc queries posed 
basic underlying concept simple 
windows screen associated units information stored database con 
information units related links 
links typed sense may specify structural composition document structural links may point related information supports primary theme referential links may point comments reviewers note links 
users hypertext system browse documents traversing links examining nodes interest 
approach powerful communications tool documents need structured linearly users follow related trails information order desire 
information units referred nodes encompass text graphics computer generated sound executable programs 
example restricted textual nodes 
document set nodes connected links node designated root node 
depicts hypertext system structural links shown solid lines referential links shown dotted lines 
nodes labeled root nodes 
documents structure desired 
documents rooted linear hierarchical respectively 
general restrictions links allowing nodes part multiple documents case exist outside document case nodes forest links associated document group documents called web 
hypertext database browsed ways 
method follow links open windows nodes examine contents method graphically display web associated document selectively examine nodes interest 
third database queried identify nodes meeting criteria 
nodes qualified selection criteria appropriate node type 
example textual nodes may selected keyword search graphics nodes selected pattern recognition 
query mechanism filter nodes links user viewing web document 
schatz sc note hypertext system grows web connected 
due existence documents 
situation link web display methods finding related units information limited usefulness 
result ad hoc query capabilities important hypertext system grows size 
design user interface contributes greatly usefulness hypertext system 
ease speed links followed windows opened information units systems implement link window invocation single mouse command 

web hypertext nodes 
line boolean string set number person root link window node document classification graph hypertext system 
difference system augments concurrent thought processes merely stores large amounts related data 
implementations kms amy notecards hal intermedia con unique user interface common low level architecture identified 
campbell goodman cg call common set features hypertext machine ham show known systems implemented standardized hypertext subsystem 
example implements subset ham object oriented database model chapter 
class lattice hypertext database 
classes boolean string set number considered predefined database management system classes defined hypertext database implementor 
signatures methods defined class table 
classes node link document closely reflect logical hypertext structure described earlier 
implementation details significant 
node may belong documents concurrently links emanating belong documents 
method links node theta doc set returns set table method signatures classes hypertext database 
name method signatures root boolean bool negate bool bool contains theta str bool creator person keywords set edit string str contains str theta str bool concat str theta str str str theta str theta num bool set size set num add set theta root set display bool number num add num theta num num greater num theta num bool person age person num expertise person set mother person person father person person children person theta person set window link creator link person link node link node part link doc node links node theta doc set document doc author doc person authors doc set title doc str keywords doc set doc node links emanating node document 
links identify source destination node means methods 
ham tags links attribute chosen separate link types defining subclasses 
provides opportunity priori restrict scope query defining range appropriate subclass link 
link specialization graphical object class line 
documents nodes require display ability subclass window 
node additionally inherits text handling behavior defines methods contains testing substring containment edit 
document collection nodes incorrect implement document specialization node 
instances document structural value captures document structure hidden users 
access structure provided methods document class preserving adt abstraction 
query model issues large number issues consider designing query models investigation 
part section concentrate key trade offs oodb query facilities formal vs ad hoc query languages predicates structure vs behavior object preserving vs object generating operations 
discuss number query model design issues 
detailed discussion object algebra design considerations yo 
second part section calculus algebra definitions data model section 
design alternatives formal versus ad hoc query languages 
formal query languages sz properties ad hoc query languages fis making suitable formal analysis 
importantly semantics defined simplifies formal proofs properties 
common types formal query languages calculus algebra 
calculus allows queries specified declaratively concern processing details 
queries expressed algebra procedural nature optimized 
algebras provide sound foundation rule transformation systems fre gd allow experimentation various optimization strategies 
large body exists algebras data models see example ab js 
defining oodb query requirements formally terms algebra facilitates comparisons models 
important aspect formal query languages support calculus definition sense relational calculus 
declarative languages provided user interface need define formal object calculus defined calculus calculus definitions typically lacking object oriented query research 
definition calculus raises number interesting issues 
notion completeness sense relational completeness worked influences set algebraic operators 
completeness requires calculus algebra equivalent 
safety calculus expressions issue needs worked 
safe expressions guarantee queries retrieve finite set objects finite amount time ow 
efficient algorithms need developed translate safe calculus expressions algebraic ones 
reported defines restricted calculus partially complete gives translation algorithm object algebra 
predicates structure versus behavior 
discussed previous section object models implement complex objects internal structure visible view objects instances data types 
access objects instances adt public interface 
interface defines behavior object 
views objects appear incompatible adt approach effectively model complex objects including get put methods components internal structure 
query language supports predicates object behavior general allowing knowledge object representations introduced stage query processing 
object preserving versus object creating operations 
distinction object preserving object creating query operations ss 
object preserving query languages asl aco return objects exist original database 
object creating languages kim sz dav dd answer queries creating new objects components objects 
new objects unique identity criteria appropriately establish supertype subtype properties 
sense violates integrity afforded objects identity objects apparent relation combined new object presumes encapsulate defined behavior 
requirement combining objects new relationships exist output purposes processing knowledge bases knowledge acquired forming new relationships existing facts 
notice object oriented query language complete object preserving query facility independent additionally creates new objects 
ability retrieve object database utilizing relationships defined inheritance lattice defined adt operations objects fundamental requirement 
addition object creating operations increases power language raises number issues type created objects operations support 
closed versus open algebras 
strengths relational algebra closed output operation input 
extension concept object algebras considered highly desirable bk 
closure somewhat complicated 
simplifying factor relational systems operand result algebraic operation relations 
operators type input generate type output relation 
object oriented systems schema consists types 
closure property redefined handle multiplicity types 
closed object algebra consists operators operates set objects belonging types type system outputs set objects belonging existing types type system 
observed bk object oriented languages able map structured objects structured objects 
objects returned necessarily belong existing types 
note existence object creating algebra operators definition complicates closure 
provision heterogeneous collections outputs queries difficult reconcile closure 
issues relate determination type objects collection address section 
object algebra operator set 
object algebras defined formally far md sz 
agreement set operators semantics 
indicated disagreements exist object creating operators included proper level encapsulation 
suggested object algebras extend relational algebra yo requiring definition project cartesian product operators 
operators definition deal components objects violating strict encapsulation 
indicated probably need include operators language exact relationship encapsulation needs worked 
example query model fundamental objective research query processing methodology techniques defined formal calculus algebra sections 
finiteness safety arguments object calculus algorithms calculus algebra translation 
discussed section query primitives restricted comparisons object behavior 
fundamentally due strict encapsulation enforced data model treatment objects instances data types 
considerations caused restrict algebra object preserving operations 
justification choice twofold 
oodb query language complete object preserving query facility independent creates new objects 
ability retrieve object database utilizing relationships defined type inheritance graph defined adt operations objects fundamental requirement 
second discussed issues raised definition object creating operations focus research clear consistently deal problems point 
query primitives principle maintaining data abstraction paradigm require querying database object behaviors values 
real world behavior value query language database modeling real world allow specification comparison values 
define comparison operators queries fg semantics shown tables 
operator tests object identity equality evaluates true denote object 
fg operators apply set valued objects denote set value inclusion set value equality respectively 
shown tables operands denote value required 
operator test value atomic object 
order maintain data abstraction primitives provided querying structural values 
aspect structural values required users object available methods class implementor 
table semantics function object value type 
fg atomic undefined undefined atomic structural undefined undefined undefined set undefined undefined atomic undefined undefined undefined structural structural undefined undefined undefined set undefined undefined atomic undefined undefined undefined set structural undefined undefined undefined set undefined table semantics function object value type 
fg atomic undefined undefined undefined val structural undefined undefined undefined undefined set undefined undefined undefined atomic undefined undefined undefined undefined fval val structural undefined undefined undefined undefined set undefined undefined undefined atoms building blocks calculus expressions predicates qualifying algebra operators 
represent primitive query operations data model return boolean result 
legal atoms follows ffl object variables denote operation form mlist object variables 
operators fg ffl object variable denotes operation form mlist object variables 
textual representation atomic value set atomic values 
operators fg example object variables 
examples legal atoms semantics 
objects denoted object 

mlist identifier contained set value object obtained applying methods mlist objects 

mlist fg set value object obtained applying methods mlist objects 
pairwise equal set value object denoted 

atomic value object denoted 

set value object denoted include identifier object atomic value 

fg mlist set value object obtained applying methods mlist objects 
contain identifiers objects atomic values 
object calculus format object calculus definition similar tuple relational calculus definition provided ull 
query object calculus form fo object variable denoting objects database formula built atoms 
result query set objects satisfy predicate formed 
introduce third atom specific calculus expressions addition defined previous section 
range atom name class object variable ranging instances class refers objects extent ext refers objects deep extent ext 
formulas depend notion free bound variables 
variable said bound formula previously introduced quantifier 
variable introduced quantifier free formula 
formulas defined follows 
atom formula 
object variables atom free formula 

formulas formulas 
object variables free bound free bound depending occur 

formula formula 
free occurrences bound 

formula formula 
free occurrences bound 

formulas may enclosed parenthesis 
absence parenthesis decreasing order precedence fg order 
query object calculus expression form fo free variable 
example database sample queries formulated object calculus expressions 

author document titled principles distributed databases doc author distributed databases title 
nodes belonging document titled principles distributed databases doc distributed databases title link part 
documents coauthored person father doc author coauthors father 
authors write things include topics doc author keywords point appropriate comment choice atoms object calculus quite restrictive compared tuple relational calculus 
example tuple relational calculus allows operator object calculus restricts fg 
object calculus allows value equality comparison atomic objects complex objects 
researchers proposed shallow deep equality operators applied objects class gr kc 
objects said shallow equal values identical 
objects said deep equal atomic objects values equal set objects elements pairwise deep equal tuple objects values take attributes deep equal 
object calculus defined avoids operators reasons 
value comparison complex objects complex objects violates principle data types instances solely defined behavior 
order completely support encapsulation allow query expressions results dependent equivalence structure opposed equivalence behavior 
second model allow various objects class implemented differently take advantage environment 
example different representations may objects main memory versus stored secondary storage 
furthermore distribution heterogeneity considered objects may represented differently different machines 
notion equivalence test depends representation inappropriate 
similar argument prohibiting comparison operators atomic objects 
user knowledge values domain necessarily imply knowledge ordering 
example consider case cipher letters shifted characters 
encoded form hello world 
database contain class value domain letters alphabet total ordering 
obviously relation members relation standard alphabet value domains identical 
reason value comparison operations implemented method class accordance total ordering class defines 
object algebra operands results object algebra sets objects 
algebra maintains closure property result query input 
operators accept operands 
theta operator algebra 
notation theta hq algebra expressions denote sets objects arguments operator theta 
case theta theta loss generality 
algebra operators qualified predicate 
operators written theta hq formula consisting atoms connected parenthesis required 
atoms lower case single letter variables range objects input set named corresponding upper case letter 
example object variables predicate theta hq range sets objects denoted respectively 
algebra defines operators 
union denoted union set objects 
equivalent expression union difference denoted gamma difference set objects equivalent expression difference intersection operator derived gamma gamma 
select denoted oe hq select returns objects denoted vector theta theta theta satisfies predicate equivalent expression select multiple operands permit explicit joins described kim 
explicit join join arbitrary classes support sequence method applications resulting comparable objects 
example find documents cars persons years age 
range doc range person doc oe car keywords author rue age greater result expression set document objects sets document person objects 
due object preserving nature algebra support creation new objects 
sense select traditional semi join operator 
result selection oe hq returns subset generate denoted fl hq predicate condition contain generating atoms target variable range argument sets 
operation returns objects denoted vector theta theta satisfies predicate equivalent expression generate common uses generate operator collect results method applications iterate content set valued objects 
example return authors document cat object oriented kin 
target variable range doc doc fl title authors map denoted 
mlist hq mlist list method names form delta delta delta mm map applies sequence methods mlist object objects hq parameters methods mlist 
returns set objects resulting sequence application 
method mlist requires parameters hq empty sequence map special case generate operator equivalent mlist form generate operation warrants definition occurs frequently supports useful optimizations 
map similar image operator sz restricted unary methods 
calculus algebra translation algorithm translating restricted set object calculus expressions object algebra counterparts fully described 
algorithm applicable queries occurrences universal quantifier 
family queries similar power select project join class queries relational model 
translation algorithm rewrites calculus expression prenex disjunctive normal form 
atoms conjunct placed candidate list ranked restrict query target variable generate target variable represent range atom 
conjunct reconstructed nested expression choosing atoms candidate list combining atoms referencing common variables empty expressions representing variables unbound partially completed conjunct 
process recursively repeated empty expression candidate list exhausted 
nested subexpression mapped corresponding algebra expression simple pattern matching template 
legal orderings candidate list may possible result family equivalent algebra expressions obtained 
translation algorithm insure optimality resulting algebra expressions require type checking logical rewriting 
topics covered sections 
typechecking algebra expressions database query languages traditionally minimal type checking requirements 
relational model example type checking insures relation schemes compatible appropriate comparison operations performed tuple fields 
limited number primitive domains supported model integer string boolean straightforward task 
oodb query languages introduce complexity process query results may non homogeneous sets objects objects query result type 
closed algebras result query input need insure methods referenced predicate second query defined objects result 
algebras impose type restrictions union compatibility sz algebra operators insure type consistency result 
union compatibility states members sets operated instances types subtype relationship 
type result considered general supertype types involved operation 
problem termed impedance mismatch occurs application programming language interface database query language 
languages partially incompatible data types union types relations sql 
common requirement independent particular language program variable iteratively bound element set objects returned query portals sr cursors ast 
possible insure binding type consistent order detect improper data 
problem complex query results homogeneous 
fundamental question result query set objects may homogeneous said types member query result supports 
important question intermediate results query input subsequent operators 
essential determine minimally common behavior set objects intermediate result identify methods safely applied 

type lattice fragment 
example consider fragment type lattice types labeled assume wish take union instances types issue determine behavior objects ext ext 
said behavior object 
objects behavior immediate supertype 
objects behavior immediate supertype 
objects behavior immediate supertype 
safe apply methods defined objects ext ext 
example demonstrates need build type system determine behavior intermediate query results 
example simple complicated cases come 
type checking issues type checking algebra versus calculus expressions 
type checking system operate calculus expressions algebra expressions 
advantage typechecking calculus expressions inconsistencies detected early query processor doing significant amount translating query calculus algebra format 
furthermore type checking integrated integrity enforcement usually performed front 
requires type checking rules defined general calculus expressions trivial 
typechecking algebra expressions simpler reduced defining type rules algebra operator 
probably advantageous apply combination calculus versus algebra type checking practical query system 
possible define simple type checking rules calculus expression eliminate incorrect 
sophisticated type checking intermediate query results may performed algebraic expressions 
static versus dynamic type checking 
static type checking applies type consistency rules compile time 
advantage identifying errors early potentially harmful results occur run time 
hampers dynamic binding objects commonly stated advantage object oriented languages 
discussion static versus dynamic typing object oriented languages going query processors probably required accommodate doing static type checking possible providing means dynamic binding variables objects 

subtype ht ct role conformance basis type checking 
example demonstrates case determination behavior objects collection basis type semilattice subtype relationship 
probably common approach 
possible perform type checking making conforms relationship 
case may possible tightly determine behavior objects 
consider example case depicted hold 
ht 
ht 
ct 
subtype 
subtype subtype case depend subtype relationship common behavior objects fo defined type conformance relationship determined common behavior fo defined type preferable specializes behavior specific note systems implement sort type checking emerald define conformance relationships objects types 
definition conformance general discussed restricted subtype supertype relationship 
type checking example data model type system designed defines set type checking rules type conformance type checking methodology static type checking algebra operators 
type conformance case restricted subtype supertype relationship discuss 
typing rules defined algebra operator various types query predicates allowed model 
define conformance set types 
set objects conformance ft denoted ft object conforms type ft example consider example 
define behavior objects ext ext terms conformance relationship 
objects conform immediate supertype 
objects conform immediate supertype 
objects conform immediate supertype 
intuitively may say type ext ext type objects union conform 
case somewhat trivial objects query result conform just class 
referring assume wish take union instances types case said objects ext ext 

objects conform ft immediate supertypes 
objects conform ft immediate supertypes 
objects conform ft necessarily immediate supertypes 
statement holds object conforms type instance inheritance supertypes 
define conformance inclusion relationship sets types iff words type conforming type note may contain types conform type definition 
notion finding set types members second set types conforms central determining type consistency operations sets objects 
want know types conformed set contain redundant information 
example conformance ext ext determined ft including parents conformance add new type information define behavior parents specializations parent types 
similarly placing general types conformance example parents introduces loss type information 
loss type information undesirable type checking query 
consider type lattice fragment 
assume objects query result conform conformance specified ft correspond case types general necessary placed conformance 
possible query question just subquery operations performed result 
object algebra operators qualified predicates 
form predicate involves applying method member query set 
method referenced query defined query fail type checking fact member query set support method 
requirement conformance set objects type checking include specific types satisfy conformance definition 
conformance set objects ft defined specific conformance exist subtype elements conform function msc defined return specific conformance types example referring msc ft msc ft msc ft need arise type checking determine inverse msc relationship 
letting refer subtypes types respectively function msc gamma defined msc gamma msc ft words inverse function msc gamma returns general set subtypes conform example referring msc gamma ft msc gamma ft msc gamma ft full set type conformance rules form foundation type checking methodology 
rules determine conformance expression conformance subexpressions 
type checking algorithm correct computes types derivable rules 
expression considered type inconsistent rules derive type conformance variables expression 
algebraic optimization step query processing methodology depicted optimization type consistent algebra expressions 
accomplished means equivalence preserving transformation rules 
fundamental design issue sure complete set transformation rules captured object algebra efficiently query processor 
goal algebraic optimization reduce cost evaluating query replacing algebraic expression may better performance characteristics 
haas distinction rule query transformation techniques query rewrite plan optimization 
query rewrite high level process general purpose heuristics drive application transformation rules 
plan optimization lower level process transforms query cost effective access plan specific cost model knowledge access paths database statistics 
section discuss rules intended query rewrite 
section address issues related plan optimization 
demonstrate idea algebraic optimization rewriting rules discussing full set rules specified object algebra 
proofs rules str 
rules grouped algebraic semantic ones 
algebraic rules create equivalent expressions pattern matching textual substitution 
semantic rules similar additionally dependent semantics database schema defined class definitions inheritance lattice 
rules written specifies expression equivalent expression fre restricted rules form restricted rules applicable condition true 
conditions conjunction functions determine properties argument sets predicates variables rule 
define function ref true variables referenced predicate function gen tests predicate contains generating atom variable similarly res true predicate restricts values example gen true mlist false fg mlist 
notation select generate sets delta delta delta oe hq iff res fl hq iff gen words set definition select generate operations distinguished properties predicate defined restricting values operation select 
defined generating values operation generate 
arbitrary expression list expressions referenced notation denotes zero occurrences example rule oe oe indicates result select operation independent ordering arguments 
set restricted appear select operator oe rule change position case generate operations target variable correspond input sets 
rules state outcome generate independent operand ordering 
fl fl fl fl introduced map operator special case generate 
captured conditional rule fl hq 
mlist hq condition insures mlist 
introduce abbreviations replace sm respectively 
example oe oe hq sm condition ref 
lower case letter represents object variable ranges set denoted corresponding upper case letter 
object algebra identities operands results algebra operators sets objects set membership determined object identity typical set theoretic identities typical set theoretic algebra operators union intersection difference apply 
identities include associativity union intersection distribution union intersection difference operators 
additionally rules specify identities object algebra conditions associated 
oe oe oe oe gamma oe oe gamma oe oe oe oe oe oe 
mlist 
mlist 
mlist fl fl fl rule captures commutativity select 
rules show difference union intersection commute select 
rule specifies union commutes map rule indicates union distributes generate 
rules general appear leading argument select map operation swapped trailing arguments 
rules capture commutativity union trailing argument 
oe hq oe hq oe hq fl hq fl hq fl hq 
mlist hq 
mlist hq 
mlist hq example consider query return root nodes documents cats dogs 
range class document atom cats keywords atom dogs keywords range node objects object algebra expression implement query doc oe doc oe 
apply rule get doc oe 
doc oe 
transformation shown graphically right hand side 


oe doc doc doc oe oe 
doc doc 

oe oe transformations examples 
select transformation rules select supports transformations conditional oe oe oe oe oe oe oe oe oe oe ref res ref res rule identity utilizes fact selection merely restricts input returns subset argument 
selection oe returns subset call 
second selection reduced oe merely smaller subset final subset obtained applying predicates separately intersection results 
rules recognize subformulas subset arguments 
operand sizes minimized breaking separate select operations intersecting union results 
example union subquery doc oe doc oe example matches right hand side rule 
substituting doc apply rule right left resulting doc oe doc oe doc oe transformation shown graphically left hand side 
noting similarities rules allows derive new rule conjunctive predicates oe oe oe ref res ref res slightly different version conjunctive predicate rule select oe oe oe oe fl ref ref res ref ref gen variable common variable restricted select 
rule common variable restricted restriction pushed separate select operation 
second rule similar denote common variable shared reflect target variable generated case pushed separate generate operation 
example consider query find documents written child computer scientist doctor 
range class document range class person range class person range person objects children atom author atom computers expertise atom medicine expertise atom children object algebra expression represent query doc oe expression satisfies conditions rule substitute doc person person 
applying rule substitutions gives doc oe doc oe person fl transformation shown graphically left hand side 
special case rule occurs select predicate contains generating atom set restricted 
oe oe fl ref res ref gen left hand side rule indicates elements restricted predicate 
restricts generates really sources values argument set generating atom result operation satisfy restriction generation break separate operations take intersection result 

person person oe doc doc oe fl person person oe doc fl person person oe oe transformations examples 
fl oe oe graphical representation rule 
generate transformation rules conjunctive predicates give rise transformation rules generate operations fl oe fl fl fl fl oe ref gen ref gen ref gen ref gen ref gen ref res conditions rule insure restricts common variable conjuncts predicate 
subsequently broken separate select operation 
rule common variable generated broken separate generate operation 
rule common variable conjuncts predicate 
generates values merely restricts allows conjuncts broken separate generate select operations 
example consider subquery person fl example computers expertise medicine expertise children returns children doctor computer scientist parents 
subquery satisfies conditions rule substitute person person resulting transformation person fl person oe fl ideally apply rule break atom restricts variable ranging class person 
noting ordering argument sets affect result generate operation apply rule give person oe fl person fl person oe apply rule break atom follows 
person fl person oe person oe fl person oe result steps shown right hand side 
special case generate operation occur predicate generates values target variable range argument set variable range argument set 
fl fl fl ref gen ref gen condition states generates values generates values target variable similar rule sources values argument set generating atom final values exist generated break generate operation intersect result prior generating values semantic transformations semantic transformation rules take advantage semantics object oriented data model 
database schema defined class definitions inheritance lattice captures relationships simplify object algebra expressions 
example represent classes represent set objects extent class ext represent deep extent ext 
show expression oe noting data model restricts object membership single class 
define relationships classes class extents assist categorizing special cases simplifications possible 
case subclass denoted denote subclasses common ext ext oe 
conversely implies exists class superclasses 
relationships derive special cases binary object algebra operators shown table 
semantic rules rely type consistency determine applicability 
consider rules 
oe oe oe oe table special cases binary operators 
rule condition oe gamma oe gamma gamma oe gamma 
oe oe oe oe semantic transformation rule identical occurrence replaced definition intersection returns objects input sets 
pure set theory perspective restriction removes objects input set automatically excludes objects result intersection 
addition restriction applied equally input set generate result 
intersection dependent operand ordering doesn care input set missing excluded objects 
similar argument restriction applied input sets affecting result 
referring restriction select operation oe input set restricted predicate examine transformation 
expression depicted considered type consistent expression methods predicate defined types represented objects note may heterogeneous set objects represents result subquery opposed extent class 
transformation valid expression legal 
means subquery oe type consistent methods predicate defined types represented objects condition transformation rule methods identical validity transformation similar argument dependent database nature subqueries produce transformations shown valid conclude equivalence expressions valid characteristics intersection discussed previously 
restriction legally applied input sets intersection requires applied 
execution plan generation section address issues arise step methodology depicted 
step involves generation alternative execution plans algebra expression obtained application rewrite rules 
step commonly called access path selection relational dbmss concerns choice implementation efficient algorithms executing individual algebra operators combinations 
issue complicated due difference abstraction levels behaviorally defined objects storage 
separate issues execution plan generation mapping object algebra expressions object manager interface expressions access plan selection involves selection optimum execution plan efficient implementation object manager interface operations 
sense similar query processing distributed databases systems ov involves global plan generation local optimization 
section mainly concerned execution plan generation 
primary concerns generating execution plans 
decompose object algebra operators union difference gamma select oe map 
mlist generate fl especially complex predicates sequence simpler operations accurately reflect interface provided real object system 
words defining lower level abstraction provided data model object algebra far treat access plan generation mapping object algebra expressions new abstraction interface 
lower level object management interface 
second concern wish maintain data abstraction provided behaviorally defined objects want assumptions objects stored implemented 
object manager design issues case relational data model cod close correspondence algebra operations low level primitives physical system sac 
mapping relations files tuples records may contributed strong correspondence 
analogous intuitive correspondence object algebra operators physical system primitives 
discussion execution plan generation define low level object manipulation primitives building blocks execution plans 
call low level object manipulation interface object manager om interface 
object managers received attention lately context distributed systems dla mg programming environments dec kae vbd databases cm ee hz kbc 
object managers typically oriented atime object execution differ terms support data abstraction concurrency object distribution 
encapsulation objects hides implementation details optimization queries objects pose challenging design problem simply stated follows point query processing query optimizer access information regarding storage objects 
differentiate types object storage information representation information specifies data structures represent objects physical storage information regarding clustering objects indexes defined object storage control object manager design question posed terms level om interface 
physical optimization query executions requires storage information arguing high level om interface accessed early optimization process 
systems typically called complex object systems choose approach 
encapsulation hand hides storage details argues low level om interface accessed late process 
om design principles data model treats objects instances data types encapsulation fairly important consideration 
furthermore interested investigating far go query processing accessing physical storage information 
elected define fairly low level om interface accessed late optimization process 
furthermore om interface reveal physical organization information 
words defining lower level abstraction provided data model object algebra 
object algebra expressions input execution plan generation process important characteristics 
represented graph nodes object algebra operators edges represent streams sets objects 
intermediate results structure 
fact intermediate results thought streams individual object identifiers 

algebra operators oe fl qualified predicate 
predicates formed conjunction atoms may variables 
variable corresponding result algebra operation called target variable 

variable name appearing multiple atoms predicate implies join kind objects denoted variable satisfy conditions concurrently 
point implied joins object variables predicate driving factor query execution execution plan generation strategy 
consider predicate select operation oe ho target variable inputs operation 
values generated atoms predicate 
result select operation defined true theta theta theta theta table identifies variables referenced atom numbered left right reflects dependencies variables 
clear table object denoted table dependencies variables predicate 
satisfy atoms concurrently 
respect data abstraction afforded objects possible query processor directly evaluate atoms concurrently required 
call agent perform individual operations objects correspond individual atoms 
require ability keep track combinations variables theta theta theta theta satisfy intuition leads design decisions 

low level operators generate execution plan algebra level operator consume generate streams sets tuples object identifiers 
introduce notation delta delta delta denote stream tuples object identifiers form delta delta delta convenience call oid stream remainder document 
way relationships variables atoms satisfy maintained sequence operations 

object manager interface performs low level operations comparable individual atoms predicate 
om interface specification object manager interface specifies calling sequence semantics performing operations oid streams 
operation types defined om stream union om diff stream difference om eval meth pred atom evaluation om stream reduction denote input output oid streams respectively 
semantics om calls described 
stream union operator generates union input oid streams 
streams variable names necessarily order 
operation analogous relational union operator 
output oid stream contains tuples projected variables identified output specifier 
stream difference operator generates difference input oid streams 
streams variable names necessarily order 
operation analogous relational difference operator 
output oid stream contains tuples projected variables identified output specifier 
atom evaluation operator applies optional method meth member theta theta creating intermediate oid stream theta theta theta res res result method application combination 
predicate pred applied intermediate oid stream result projected variables output stream identifier 
specifically ffl denote set oid streams represent input object manager call 
variable name may appear input stream 
ffl denotes oid stream returned output object manager call 
variable name may appear output stream 
variables referenced oid stream subset input streams special identifier res 
ffl meth optional method application specifier form delta delta delta delta delta delta correspond variables input streams textual representation atomic value 
special identifier res denotes result method application referenced output stream predicate 
ffl pred optional predicate objects input streams result meth field 
full set permissible predicates table 
variables predicate correspond variables input streams special identifier res textual representation atomic value denoted const table 
table predicates allowed om eval calls 
fg const const const const fg om eval call method predicate specified required 
specified method applied predicate evaluated 
special identifier res denotes result method application referenced output stream predicate method specified 
input streams may contain variables referenced output stream method predicate 
case respective oids input streams ignored 
variables referenced input streams output stream method predicate carried modification 
case unreferenced oid input tuple satisfies predicate optional method applied copied unchanged corresponding output tuple 
relationship restrictions ordering variables input streams output stream 
example consider atom evaluation operation om eval res res semantics operation algorithm 
tuple 
theta iterate cross product res object returned method application res set value inclusion add tuple res output stream notation denote component tuple 
om om om om om om om fl oe oe mapping object algebra expression trees object manager operation trees 
stream reduction operator combines reduces number input streams performing equijoin variables common input streams 
requires input streams variable name common 
semantics operation best described example 
example consider stream reduction om variables common input streams rewrite operation om order differentiate different sources variables input streams combined cross product results oid stream 
final result stream form contains tuples previous intermediate result 
plan generation execution plan generation thought creating mapping object algebra expression trees trees object manager operations 
query initially represented tree object algebra operators shown 
edges annotated labels indicate set objects considered stream individual objects 
example set objects denoted thought stream objects unique feature object algebra expression trees edges represent streams single objects streams multiple objects 
due closed nature algebra insures output operation input 
graph represents execution plan corresponding algebra tree left 
execution plan graph graph nodes om operators edges 
evaluated leaves root 
subtrees dotted boxes sequences 
res om eval res oe om eval res om eval res om eval res execution plan generation object algebra map operator 
object manager operations corresponding individual algebra operators original query 
edges cross subtree boundaries may represent streams tuples objects 
addition streams may input multiple object manager operations subtree 
sections shows mapping object manager operators performed object algebra operators gamma oe 
mlist fl 
union difference operations union difference operators map directly object manager counterparts 
inputs output algebra operations unary streams objects om om diff accept streams tuples object identifiers 
map operation reviewing briefly map operator 
mn hq denotes sequence method applications drawn theta theta object manager interface apply method call method sequence decomposed individual method applications 
determining parameter treated previously repeated 
depicts map operation 
hq represented sequence om operations 
full algorithm perform transformation omitted due space limitations 
select generate select generate operators introduce complexity execution plan generation due predicates 
may appear treated separately select operator returns subset input set generate operator generates objects input sets 
perspective low level execution plan creation quite similar 
consider selection predicate equation 
operation selection predicate generates values inherent difference complexity predicates selections generate operations 
real distinction target variable generate operation correspond input sets 
requirement creating select generate execution plans rewrite predicate atom corresponds just single object manager call 
substitutions insure mapping atoms predicate object manager calls 
outline simple algorithm mapping select generate algebra operators execution plan graphs 
algorithm takes inputs set atoms corresponding simplified predicate set variable names identifying inputs object algebra operation name target variable 
output execution plan graph 
algorithm uses hypergraph ber representation predicate 
hypergraph contains node unique variable name referenced atoms predicate initialized edge atom predicate covers nodes corresponding variables referenced atom 
note edges hypergraph define subsets nodes 
nodes marked red green 
green node indicates values variable exist variable ranges input sets object manager call generated values 
red marking indicates values exist variable may 
node markings initialized reflect variables represent inputs object algebra operation 
algorithm proceeds successively placing execution plan graph om eval operations atoms hypergraph edges atoms placed 
atom eligible placement execution plan graph nodes corresponding edge green node red represents variable values generated atom 
complete algorithm 
example apply algorithm described produce execution plan graph select operation predicate 
shows initialized hypergraph edge atom predicate 
note node red green indicating range input set 
initially atoms eligible placement node respective hypergraph edges green atom generates values single red node 
atom ineligible point generate values red node 
assume atom chosen random leading placement corresponding object manager call labeled execution plan graph 
placing colored green values exist edge atom removed hypergraph 
point remaining atoms eligible placement assume atom randomly chosen 
output oid stream corresponding om call atom overlaps target variable needs retained final result 
algorithm terminates placing remaining atom 

algorithm outlined section quite limited generate execution plans linear sequences om eval operations 
specifically ffl execution plan generated ffl ordering multiple eligible om operations determined random choice allow cost analysis different orderings ffl object manager operations performed parallel ffl om reduce intermediate oid streams 

red green green green green green hypergraph representation predicate corresponding execution plan graph 
ideally generate family execution plans best plan chosen cost criteria 
algorithm accomplishing described 
algorithm uses processing templates extensions join templates rr 
processing template represents family logically equivalent execution plans 
intermediate formalism mapping object algebra query trees execution plan graphs 
query optimization issues number issues related approach taken related scope investigation briefly touch 
issues involve selection optimum execution plan optimization method executions 
choosing optimum plan mentioned execution plan generation algorithm enumerates processing template identifies family logically equivalent query execution plans 
connected subtree edges processing template includes initial nodes final node valid plan 
best plan 
section defined object manager interface research address implementation 
implementation design highly dependent object representation technique bind method code objects system parameters 
propose specific cost function assume object manager capable oid stream statistics derive cost calls interface 
appropriate oid stream statistics stream cardinality information classes represented stream 
call object manager derive processing cost statistics resulting output oid stream 
processing template annotated cost information follows 
initially leaf nodes stream nodes processing template stream statistics associated 
leaf nodes correspond leaf nodes original object algebra query represent extent deep extent classes database statistics readily available 
leaf nodes represent output previous subtree object manager calls output oid stream statistics appropriate subtree attached 
working leaf root processing template object manager cost function assign processing cost operator node set stream statistics stream node operator feeds 
operator nodes stream nodes processing template annotated cost statistical information fashion 
total cost specific execution plan processing template sum operator costs included execution plan subgraph 
time information included cost function operator nodes execute parallel longest running operator included sum 
note cost information prune search space processing template generation algorithm 
search space algorithm defined number stream nodes processing template start pass 
value affected criteria define interesting permutations cause new operator stream nodes created 
optimization method executions research concentrates primarily optimization query primitives 
ideally query optimization possible queries utilize user defined methods 
highly dependent language define methods 
worst case optimizations possible provided compiler method implementation language 
examples optimizations inline subroutine expansion removal loop invariants efficient pipeline register usage 
approach assumes behavioral abstraction maintained logical level structural object oriented system exists lowest implementation level gm 
objects classes involved query requested reveal structural information query processor 
revealed expressions contain encapsulated behavior recursively requested reveal equivalent sequence structural expressions 
revealing process bottoms structural manipulation primitives optimized extended relational query optimizer 
approach purely functional language user defined methods 
expressions languages recursively decomposed sequences primitive data manipulation operations 
decomposed sequences optimized techniques described earlier 
clearly optimization user defined methods closely tied ability reason expressions method implementation language significant area research 
dynamic schema modification issue typically complicates query processing dynamic schema modification 
schema object oriented database system varies data model design decision discussed 
model treats objects instances single data type extension captured class schema consists class type lattice 
different interpretations possible discussed earlier sections 
previous chapter assumed schema change execution query 
words query processor receives query schema change response retrieved 
may realistic especially data model uniformly treats object 
query processing exist changes schema 
dynamic schema modification studied context object oriented database systems 
comparative summary nr types changes follows ffl changing class instance variables methods ffl modifying class lattice changing relationships classes ffl adding deleting classes lattice 
interaction changes query processing topic 
physical optimization section largely taken chapter ov 
object storage access responsibility object manager 
addition providing suitable interface generation execution plans discussed object manager performs functions physical clustering objects localization objects 
general object manager responsible transaction management scope current discussion 
object clustering grouping objects memory extent common properties example value attribute subobjects object 
minimizing number memory extents examine fast access clustered objects provided 
object localization gives location object identifier content attribute value 
exploits object clustering information possibly augmented form indexing 
object manager clustering localization objects provide efficient algorithms implementing interface operations 
indicated relational databases object managers efficient managing simple objects 
problem significantly difficult objectoriented databases due large atomic objects complex objects 
large atomic objects quite frequent new database applications 
instance digitized image image database require megabytes storage 
object manager able deliver useful portions large atomic object application program adt operation needs 
complex objects may large objects nested set tuple constructors arbitrary degree 
typical example cad applications vlsi chip object consists sections consisting cells containing transistors 
number atomic objects vlsi chip cells small bytes complex object may require megabytes storage 
object manager able access object subobjects rapidly entire complex object needed 
provide efficient access collections subobjects having read large complex object 
management complex objects difficult object sharing permits subobject parent 
storage techniques relational databases may extended support complex objects 
philosophy approach retain relational model underlying technology possible 
applied initially system cad application support lp postgres sr extension ingres 
relational model complex objects decomposed tuples subobjects 
treating tuple identifiers tid attribute values object manager maintain links subobjects composing object 
atomic object stored tuple atomic 
nesting tuple tuple represented storing identifier attribute nesting set tuples ft tuple represented binary relation containing pairs tid storage approach brings benefits relational model 
access subobjects stored relation efficient clustering appropriate 
furthermore traditional indexing attribute values possible 
object query processing may simplified approach 
conceptual query mapped relational query expressed stored relations replacing path expressions corresponding joins 
relational query optimized relational query optimization technique 
disadvantage approach access entire complex object requires joins tuple identifiers 
furthermore approach sufficiently general object identity restricted tuples atomic objects 
sharing set objects conceptual level difficult map physical level 
furthermore object oriented query primitives may mapped relational ones efficiently question 
alternative approach develop special complex object storage techniques 
provide capability storing complex object subobjects memory extent 
early hierarchical network database systems partially provided capability 
restrictions complex object fit page records shared physical identifiers called database pointers 
techniques generalized support nested relations object models 
special attention paid storage atomic objects arbitrary size 
exodus atomic object long byte sequence accessed parts byte index 
storage arbitrarily complex objects involved object sharing 
main difficulty complex object storage sharing parent containing shared object deleted 
case shared subobject relocated parent expensive operation 
simpler solution relational storage approach objects shared 
difficulty approach indexing order access entire objects subobjects objects may nested objects 
solution path indexes ms associate attribute values paths objects 
complex object storage complex objects may mapped directly physical level object subobjects may clustered memory extent 
case conceptual query mapped query expressed stored objects algebra complex objects 
query processing algorithm similar exhaustive search approach commuting joins stored objects selecting best access method stored object 
difference choice best access method complex object 
access complex object may involve path expressions predicates nested objects availability path indexes critical efficiency 
chapter discussed issues need considered development query models implementation query processors object oriented database systems 
framework presentation query processing methodology depicted 
point evident foregoing discussion necessity significantly research development query models languages object oriented database systems 
ideas chapter preliminary points arise area 
query models processing techniques needed definitive statement 
relied heavily methodology important comment feasibility 
fundamental criticism linearity processing 
methodology gives impression steps followed arrive execution plan optimal 
certainly true 
transformation step generate number different algebra trees plan generation step produce execution plan trees 
important note strategy followed cycles back forth logical algebra optimization phase access plan generation phase 
allow interleaving transformations change shape query access plan subtrees possibly resulting efficient plans 
important area investigate extensions data model integrated entire query processing methodology 
instance omitted recursive queries particularly important knowledge base systems 
primitive operations support recursion shallow deep equality kc additional predefined value types atomic set structural tuple values parametric types set sz significantly enhance usefulness model 
addition basic data model propagated methodology 
means incorporated calculus algebra type inference rules need developed logical equivalences proven object manager interface extended 
performing exercise extensions provide insight tradeoffs maintaining proposed query processing methodology completeness data model 
improving query languages important topic 
object calculus expressive user friendly 
design user query language object sql lyn ont enhance usability uncover programming language integration issues 
object algebra extended respects 
provide support object creating operations 
raises philosophical technical issues 
example class object created operation methods defined 
objects new class persist execution query 
second extension object algebra involves support universal quantification 
achieved allowing quantification predicates defining algebra operate tuples objects providing division operator similar relational algebra 
approaches may affect scope transformations possible logical optimization generation access plans 
designing object manager implementation important area research 
design address related issues object representation physical partitioning logical entities classes extents object buffering indexes method code bound objects 
design affected underlying hardware architecture uni processor multi processor available operating system services 
acknowledgment chapter partly author delivered invited talk partly ph dissertation second author str 
vijay kumar university missouri kansas city invitation give talk 
jim hoover li yan yuan warner joerg university alberta sylvia osborn university western ontario careful reading dissertation critical remarks 
lois delcambre university southwestern louisiana read earlier version chapter raised questions led significant improvements 
research supported part national sciences engineering research council nserc canada operating ogp 
ab abiteboul bidoit 
algebra non normalized relations 
proc 
acm sigact sigmod symp 
principles database systems pages march 
abd atkinson bancilhon dewitt dittrich maier zdonik 
object oriented database system manifesto 
proc 
st int 
conf 
deductive object oriented databases pages 
aco albano cardelli orsini 
galileo strongly typed interactive conceptual language 
acm transactions database systems june 
albano orsini pedreschi 
type system galileo 
atkinson buneman morrison editors data types persistence pages 
springer verlag 
amy mccracken yoder 
kms distributed hypermedia system managing knowledge organizations 
comm 
acm july 
asl su lam 
oql query language manipulating objectoriented databases 
proc 
th international conference large databases pages 
ast astrahan 
system relational approach data 
acm transactions database systems june 
aw williams 
relational representation knowledge bases 
proc 
st int 
conf 
expert database systems pages 
bee beeri 
formal approach object oriented databases 
data knowledge engineering pages 
ber berge 
graphs hypergraphs 
north holland 
black hutchinson jul levy carter 
distribution types emerald 
ieee transactions software eng se january 
black hutchinson jul levy 
object structure emerald system 
oopsla conference proceedings pages september 
bk bancilhon khoshafian 
calculus complex objects 
proc 
acm sigact sigmod symp 
principles database systems pages 
bk bancilhon kim 
object oriented database systems transition 
bull 
ieee tc data engineering december 
bkk bobrow kahn kiczales masinter stefik 
merging lisp object oriented programming 
oopsla conference proceedings pages 
bkk banerjee kim kim 
queries object oriented databases 
proc 
th int 
conf 
data engineering pages february 
bro brodie 
intelligent information systems ai database technologies working 
mylopoulos brodie editors readings artificial intelligence databases pages 
morgan kaufmann 
car cardelli 
semantics multiple inheritance 
kahn macqueen plotkin editors semantics data types volume lecture notes computer science pages 
springer verlag 
carey dewitt richardson 
object file management exodus extensible database system 
proc 
th international conference large databases pages august 
cg campbell goodman 
ham general purpose hypertext machine 
comm 
acm july 
cgt ceri gottlob tanca 
wanted know datalog ask 
ieee transactions knowledge data eng march 
cm copeland maier 
making smalltalk database system 
proc 
acm sigmod int 
conf 
management data pages august 
cod codd 
relational model data large shared data banks 
comm 
acm june 
con conklin 
hypertext survey 
computer september 
cw cardelli peter wegner 
understanding types data abstraction polymorphism 
acm computer surveys december 
dav davis 
formal foundation object oriented algebraic query processing 
phd thesis center advanced computer studies university southwestern louisiana 
day dayal 
queries views object oriented data model 
proc 
nd int 
workshop database programming languages pages 
morgan kaufmann 
dbm dayal buchmann mccarthy 
rules objects knowledge model active object oriented database system 
proc 
nd int workshop object oriented database systems pages 
dd davis delcambre 
denotational approach object oriented query language definition 
proc 
int 
workshop specifications database systems 
springer verlag july 
dec 
design distributed object manager smalltalk system 
oopsla conference proceedings pages september 
dla dasgupta leblanc 
clouds distributed operating system 
proc 
th int 
conf 
distributed computing systems pages june 
ee ege ellis 
design implementation object base management system 
proc 
th int 
conf 
data engineering pages may 
fai fairbairn 
new type checker functional language 
atkinson buneman morrison editors data types persistence pages 
springer verlag 

object oriented databases finding applications 
mis week april 
fis iris object oriented database management systems 
acm transactions office information systems january 
fre freytag 
rule view query optimization 
proc 
acm sigmod int 
conf 
management data pages 
fro frost 
knowledge base systems 
macmillan 
gd graefe dewitt 
exodus optimizer generator 
proc 
acm sigmod int 
conf 
management data pages may 
gm graefe maier 
query optimization object oriented database systems revelation project 
technical report cs oregon graduate center 
gr goldberg robson 
smalltalk language implementation 
addison wesley reading mass 
gv valduriez 
relational databases knowledge bases 
addison wesley 
hal halasz 
reflections notecards issues generation hypermedia systems 
comm 
acm july 
haas freytag lohman pirahesh 
extensible query processing starburst 
proc 
acm sigmod int 
conf 
management data pages june 
hz hornick zdonik 
shared segmented memory system objectoriented database 
acm transactions office information systems january 
hz zdonik 
fugue model engineering information systems baroque applications 
proc 
rd int 
conf 
data knowledge bases pages 
jk jarke koch 
query optimization database systems 
acm computer surveys june 
js schek 
remarks algebra non normal form relations 
proc 
acm sigact sigmod symp 
principles database systems pages 
kae 
virtual memory narrow machine object oriented language 
oopsla conference proceedings pages september 
kbc kim chou woelk 
integrating objectoriented programming system database system 
oopsla conference proceedings pages september 
kc khoshafian copeland 
object identity 
oopsla conference proceedings pages september 
khoshafian franklin carey 
storage management persistent complex objects 
technical report technical report aca st microelectronics computer 
kim kim 
model queries object oriented databases 
proc 
th international conference large databases pages 
kin king 
cat object oriented 
kim lochovsky editors objectoriented concepts databases applications pages 
addison wesley 
lie lieberman 
prototypical objects implement shared behavior objectoriented systems 
oopsla conference proceedings pages 
lp lorie 
complex objects design transactions 
proc 
ieee conf 
databases engineering design applications pages may 
richard velez 
object oriented data model 
proc 
acm sigmod int 
conf 
management data pages june 
lyn 
iris manual 
technical report hpl dtd hewlett packard october 
mai maier 
isn object oriented data model 
technical report cs oregon graduate center 
man manola 
evaluation object oriented dbms developments 
technical report tm gte laboratories october 
man manola 
object oriented knowledge bases parts ii 
ai expert pages march april 
mb manola buchmann 
functional relational object oriented model distributed object management preliminary description 
technical report tm gte laboratories december 
md manola dayal 
pdm object oriented data model 
proc 
st int workshop object oriented database systems pages 
mg marques 
extending operating system support objectoriented environment 
oopsla conference proceedings pages october 
min minsky 
framework representing knowledge 
winston editor computer vision 
mcgraw hill new york 
moo moon 
object oriented programming flavors 
oopsla conference proceedings pages 
moo moon 
common lisp object oriented programming language standard 
kim lochovsky editors object oriented concepts databases applications pages 
addison wesley 
ms maier stein 
indexing object oriented dbms 
proc 
st int workshop object oriented database systems pages september 
maier stein 
development object oriented dbms 
oopsla conference proceedings pages july 
maier zhu 
features object model 
proc 
st int 
conf 
deductive object oriented databases pages 
nie nierstrasz 
survey object oriented concepts 
kim editors object oriented concepts databases applications pages 
addison wesley 
nr nguyen 
schema evolution object oriented database systems 
data knowledge engineering pages 
ont ontos sql command november 
osborn 
identity equality query optimization 
dittrich editor advances object oriented database systems volume lecture notes computer science pages 
springer verlag 
ov ozsu valduriez 
principles distributed database systems 
prentice hall 
ow ozsoyoglu wang 
relational calculus set operators safety equivalent graphical languages 
ieee transactions software eng se september 
ozsu 
data management knowledge management prospects decade invited 
proc 
national congress pages 
ozsu 
query processing issues object oriented database systems preliminary ideas 
proc 
symp 
applied computing pages 
peters ozsu 
formalization behavioral object data model 
technical report preparation department computing science university alberta 
rr rosenthal reiner 
architecture query optimization 
proc 
acm sigmod int 
conf 
management data pages 
sac selinger astrahan chamberlin lorie price 
access path selection relational database management system 
proc 
acm sigmod int 
conf 
management data pages may 
sb stefik bobrow 
object oriented programming themes variations 
ai magazine pages 
sc schatz 
searching 
proc 
th int 
conf 
data engineering pages february 
sh stonebraker hearst 
trends expert data base systems 
proc 
nd int 
conf 
expert database systems pages 
sky sheu kashyap yoo 
query optimization object oriented knowledge bases 
data knowledge engineering pages 
stein lieberman ungar 
shared view sharing treaty orlando 
kim lochovsky editors object oriented concepts databases applications pages 
addison wesley 
ozsu 
access plan generation object algebra 
technical report tr department computing science university alberta june 
ozsu 
model oodb queries 
proc 
object oriented database task group workshop nist technical report nistir pages 
ozsu 
queries query processing object oriented database systems 
acm transactions information systems october 
ozsu 
type consistency queries object oriented database system 
proc 
ecoop oopsla conference pages 
ozsu 
execution plan generation object oriented data model 
proc 
nd int 
conf 
deductive object oriented databases 
sr stonebraker rowe 
design postgres 
proc 
acm sigmod int 
conf 
management data pages may 
srl stonebraker rowe lindsay gray carey brodie bernstein beech 
third generation data base system manifesto 
acm sigmod record september 
ss scholl schek 
relational object model 
abiteboul kanellakis editors proc 
rd int 
conf 
database theory volume lecture notes computer science pages 
springer verlag 
ste stein 
delegation inheritance 
oopsla conference proceedings pages 
str 
queries query processing object oriented database systems 
phd thesis university alberta 
sz shaw zdonik 
query algebra object oriented databases 
proc 
th int 
conf 
data engineering pages february 
ull ullman 
principles database systems 
computer science press 
ull ullman 
principles database knowledge base systems volume 
computer science press 
ungar smith 
self power simplicity 
oopsla conference proceedings pages 
vbd velez bernard 
object manager overview 
proc 
th international conference large databases pages 
valduriez khoshafian copeland 
implementation techniques complex objects 
proc 
th international conference large databases pages august 
wie wiederhold 
knowledge database management 
ieee software 
wie wiederhold 
knowledge versus data 
brodie mylopoulos editors knowledge base management systems pages 
springer verlag 
yo yu osborn 
evaluation framework algebraic object oriented query models 
proc 
th int 
conf 
data engineering pages 
zdonik 
properties objects refinements 
acm ieee fall joint computer conference pages november 
zdonik 
data abstraction query optimization 
dittrich editor advances object oriented database systems volume lecture notes computer science pages 
springer verlag 

