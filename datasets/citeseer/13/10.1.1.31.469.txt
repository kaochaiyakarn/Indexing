quasi linear types naoki kobayashi department information science university tokyo ku tokyo japan email tokyo ac jp november linear types types values just drawing great deal attention useful memory management place update data structures obvious advantage value linear type immediately deallocated 
linear types applied widely practice probably linear values values linear types traditional sense appear actual programs 
order increase applicability linear types relax condition linearity extending types information evaluation order simple dataflow information 
extended type system called quasi linear type system formalized correctness proved 
implemented prototype type inference system core ml automatically find value linear relaxed sense 
promising results obtained preliminary experiments prototype system 
linear types number type systems girard linear logic proposed functional languages concurrent languages 
guarantee certain data structures called linear values accessed just 
distinction linear values revised version technical report tr department information science university tokyo 
summary acm popl 
values provides benefits improvement memory management safe inlining interested improvement memory management 
data structure statically known linear deallocated immediately accessed 
heap value needs created linear value accessed just replace linear value new value deallocating linear value allocating space new data provided physical size new value greater linear value 
instance assume call value language function hx yi hx called argument linear pair second element pair destructively updated 
similarly append linear lists performed destructively copying cons cells 
kind improvement especially effective functional programs intermediate data structures cons cells closures created naive functional programs 
limitation linear types spite mentioned benefit linear type systems widely type inference algorithms proposed automatically find values linear 
think major reasons linear type systems naive application important automatic deallocation place update identify access heap value condition linearity strong purpose 
example consider expression easy see access linear type systems insert code deallocate just twice 
limitation forces programmer follow particular programming style 
instance hfst snd pair judged accessed twice wants pair deallocated write hx yi hx 
proposal linear types quasi linear types order remove mentioned limitation linear types relax condition linearity 
key idea express information evaluation order dataflow types 
recall expression type system take account evaluated ignore treat expression way order obtain information evaluation order type system able deal dataflow information 
consider example expression 
evaluated imply access may returned accessed 
order deal distinguish type value expression type value may returned part evaluation result expression 
possible obtain kinds information sophisticated analyses obtain simple method introducing new 
advantages approach include analysis formalized uniformly terms type system especially advantageous introduce polymorphism program containing free variables analyzed long type information provided useful modular incremental analysis separate compilation programs 
review ideas previous linear type systems overview ideas system 
review linear type systems introduced control values accessed accessed 
accessed arbitrary number times 
types annotated uses 
example real represents type real numbers accessed int 
int type functions integers called arbitrary number times 
type judgment accordingly refined gives useful information ordinary example real real means real number 
invalid type derivation highlights key point linear type system real real real real real real real real real premises derivation imply order know totally expression combine type environments subexpressions adding corresponding uses 
contrast rule ordinary type systems type environments shared subexpressions linear type system infer heap value accessed annotate allocation 
instance annotate expression deallocated accessed deallocated 
overview type system order express simple dataflow information introduce ffi 
intuitively value ffi call ffi value may accessed times locally returned part computed result 
type real ffi hx value call quasi linear value simply linear value call value traditional sense strictly linear value accessed relaxed manner accessed times ffi value accessed strictly linear value value accessed deallocated 
order guarantee usage value crucial type system take evaluation order account 
type derivation shown changed follows real ffi real real real real real ffi real real real new combination real ffi real type environments captures fact accessed ffi value accessed linear value deallocated evaluated 
similarly writes hfst snd hx yi hx deallocated snd evaluated 
quasi linear value may addition allocation heap value access heap value annotated distinguishing access value accesses 
example expression annotated ffi annotate constructors destructors heap values variables 
annotate order indicate access annotated ffi order indicate 
main results main contributions formalization new type system sketched proof correctness 
evaluation order taken account proof non trivial involved previous type systems 
contribution implementation type inference system core ml standard ml modules new type system inputs unannotated core ml expression outputs annotated expression 
far tested fairly small programs obtained promising results programs lists frequently sorting programs intuition name ffi ignored compared 
sieve eratosthenes conway game life type inference system judge heap values case sorting programs sieve eratosthenes values top level functions linear indicates executed garbage collection 
annotated programs output system indicate linear cons cells programs updated place application linear types place quick sort suggested baker remarkable point performed naive programs programmer annotation 
structure rest structured follows 
section introduces syntax target language 
section gives type system judging expression correctly annotated uses 
section shows correctness type system section briefly explains obtain type inference algorithm automatically infer annotation 
section discusses extensions target language 
section explains prototype type inference system results preliminary experiments 
section discusses related section concludes 
syntax operational semantics target language section introduce syntax operational semantics annotated expressions 
uses explained section introduced control way heap value accessed 
definition uses ffi 
metavariables uses 
mentioned section new point ffi basically say heap value accessed expression value ffi accessed locally inside expression returned part evaluation result 
means data accessed means data accessed restricted manner value ffi accessed deallocated inside current expression evaluated put evaluation result value 
means data accessed times way 
value regarded value value regarded value ffi 
order express kind relationship uses define total order uses ffi 
write heap value accessed mean contents heap value read just passing heap value count access 
example say accessed expression reduced reading actual contents pair considered accessed second element extracted closure accessed invoked real number accessed passed argument primitive function real numbers 
expressions consider simply typed calculus recursion pairs target language 
extension polymorphism data structures briefly discussed section 
type system sensitive evaluation order normal form order evaluation order explicit name intermediate value :10.1.1.24.9456
readability expressions normal form giving examples 
syntax expressions 
allocation read operation heap value annotated 
annotation automatically inferred type inference algorithm explained section 
definition expressions hv fst snd rec apply write set expressions 
metavariable represents value represented word need allocated heap 
integer constant denoted variable denoted 
variable considered heap address 
hv allocate pair closure respectively heap records shall restricted type system 
recorded expresses value accessed rest computation means value accessed hv need allocate pair heap means value accessed linear value may deallocated means value accessed arbitrary manner deallocated mechanisms garbage collection 
rec creates recursive function operations access heap fst snd resp 
extracts second resp 
element pair stored apply reads closure stored applies attached access operation represents value heap value accessed operation 
ffi heap just read unchanged heap value deallocated read heap value 
operation assumes accessed heap value value deallocate value ffi effect unnecessary included just technical convenience 
greater actual recorded accessed address access invalid causes error 
conditional expression reduced reduced example fst ffi snd allocates linear pair heap reads element moment deallocated fst annotated ffi 
second element read pair deallocated 
operational semantics order clarify annotation allocating deallocating heap values run time define operational semantics rewriting relation pairs heap expression 
definition evaluation contexts set evaluation contexts syntax write expression obtained replacing hole definition heap heap value denoted term form hv heap mapping finite set variables pairs consisting heap value 
write fx 

heap 
associated heap value judging value deallocated accessed linear value value deallocated 
means value deallocated 
write hv write set heaps 
reduction relation defined rules 
error indicates invalid access heap occurred kinds errors check heap value necessary allow value accessed linear value 
forbid coercion value linear value check unnecessary 
prefer restriction check implemented efficiently see 
application non function value lack errors guaranteed type system usual way focuses errors caused invalid heap access 
rules heap rec allocating heap values 
recorded new address allocated value 
heap changed sval word value 
rules app app error function application deserve attention 
apply reads closure stored value currently available greater equal application causes error 
closure deallocated application longer called changed 
expressed subtraction definition 
similarly access pair fst snd succeeds decreased access fst snd error 
may think operation uses incurs heavy overhead run time 
type system guarantees invalid access occurs check guaranteed succeed eliminated 
associated heap value change change means heap value deallocated actual implementation need updated 
implies heap value recorded heap space pointer bit tag extra run time cost check tag know accessed heap value access operation annotated 
think actual run time overhead quite small 
example expression example reduced follows fg fst ffi snd fu 
ig fst ffi snd fu 
ig snd fu 
ig snd fu 
ig fu 
ig heap value considered deallocated changes 
example expression example wrongly annotated fst snd ffi 
hg fresh heap rec 
fresh rec sval hfx 
mg apply hfx 
mg app hfx 
mg apply error app error hfx 
hv ig fst hfx 
hv ig fst hfx 
hv ig fst error fst error hfx 
hv ig snd hfx 
hv ig snd hfx 
hv ig snd error snd error ift iff operational semantics ffi undef undef undef ffi ffi ffi undef undef undef definition reduced error follows fg fst snd ffi fu 
ig fst snd ffi fu 
ig snd ffi fu 
ig snd ffi error type system shown example expression wrongly annotated uses run time error may occur 
order reject expressions introduce type system 
type system conservative extension usual type system simply typed calculus sense expressions typed usual type system typed type system 
major differences quasi linear type system usual linear type systems 
explained section linear value accessed times long access identified quasi linear type system 
difference interpretation pair type see 
types types expressing way values 
instance type constructor product arrow types annotated uses 
definition types set types ranged syntax 
int expresses way pair closure accessed 
require ffi 
represents closure invoked sense previous linear type systems 
closure allocated deallocated reason keep clear typing rule closure creations 
note meaning pair type different previous linear type systems 
previous linear type systems int int int corresponds linear logic formula int omega int omega int pair ii type read arbitrary number times time second element extracted read 
hand quasi linear type system second element accessed linearly access pair ii time extracted 
example int ffi int 

int type linear closure takes pair integers argument uses locally returns integer 
function may invoked times strict sense invoked linearly relaxed sense invoked closure ffi invocation 
example fst ffi snd ffi type 
example consider expression fst ffi fst snd ffi suppose appear second element pair accessed just fst snd ffi assigned type int int int pair integers deallocated fst consider expression fst snd apply ffi apply 
second element accessed fst time extracted snd 
totally accessed type int int int assigned quasi linear type system 
type judgment type judgment form called type environment mapping finite set variables types 
expresses heap value accessed evaluation example int ffi int int int implies may access heap address result linear pair integers escape result 
notation write type environment dom fv dom denotes set variables 
example int int denotes type environment maps int dom write type environment dom fv fv dom 
operations uses types type environments presenting typing rules operations uses types type environments 
explained section operation computing total value accessed place place 
order uses statically known 
de non ffi greater equal bc greatest non ffi equal computing total value value accessed times value 
motivations operations clearer typing rules 
operations extended operations types type environments 
example heap value accessed value type int ffi int place value type int int place totally accessed value type int ffi int int int int int means value may accessed 
definitions operations pair types function types deserve special attention notice operations act sub components pair type arguments return types functions 
order understand reason suppose accessed places value type int int int inner pair integers outer pair accessed linearly 
inner pair integers outer pair totally accessed expressed type int int int obtained adding attached pair types type int int int means inner pair totally accessed linearly 
hand suppose accessed places function type int int 
int int 
function invoked twice time invoked uses argument pair linearly returns linear pair 
total access function expressed int int 
int int int int 
int int 
similarly operation acts sub components pair type arguments return types function types 
de intended express type expression evaluation result contain ffi values 
type int ffi int 
int int contains ffi just means function type uses argument pair locally function locally 
int ffi int 
int int int ffi int 
int int 
omit write 
give higher precedence order 
example int ffi int ffi int int int int 
int int ffi int int int ffi int int int int int int int int int ffi int int ffi int ffi int typing rules variables constants weakening rule variables constants val expression typed type environment typed type environment represents access capabilities 
example int int int int int int judgment requires linear pair impose requirement 
rule allows weakening assumption weak relation means represents access capabilities words allows liberal access heap defined 
allocation heap values consider expression hy zi accessed ways directly addresses pair extracting 
access way represented types access way represented types information total access obtained adding types 
example int int int int total access represented int int rule allocation pair ffi hv pair require ffi creating ffi value deallocated creating ffi value creating value 
annotating allocation pair ffi meaningful may useful type contain ffi modify operational semantics hv ffi allocates pair hv stack deallocates evaluated recall value ffi part evaluation result 
rule allocation closure ffi abs premise guarantees closure called return ffi value result 
means call closure heap values accessed described premise means closure called times total access heap values represented copies written access happens evaluated closure created applied contain ffi values 
rule recursive functions similar abs estimation created function rec rec total number calls function calculated number calls number calls invocation may result invocations total calls counted 
function relaxed sense similarly calculated uses ceiling function applied just sure ffi 
expressions rule expressions best illustrates evaluation order taken account type system premise means heap values accessed described described ordinary linear type systems total heap values computed adding evaluated fully evaluated estimate total access heap values sequential composition int ffi int int int total calculated int ffi int int int may accessed times 
require type contain ffi top level applying order sure ffi value represented really evaluation escape rest computation 
access heap values rule closure invocation apply app access heap values apply estimated note type zero second function 
access heap values estimated 
apply evaluated evaluated total access estimated sequential composition 
rule reading element pair fst fst premise implies pair value value fst 
total estimated element may accessed total element estimated similarly rule extraction second element pair snd snd rules conditionals rule conditional expressions require part part typing 
int example type judgment fst ffi snd int obtained derivation int int int int int int int weak int int int snd int snd int int fst ffi snd int fst fst ffi snd int pair definition ffi ffi ffi ffi 

definition ffi ffi ffi ffi ffi 
definition ffi ffi ffi ffi ffi 

definition de ffi de definition bc ffi bc operations uses type soundness section show type soundness property invalid heap access occurs evaluation typed expressions 
type soundness formally stated follows theorem fg error 
want show property usual defining typing system run time state proving reduction relation preserves typing typed state causes error immediately 
unfortunately reduction relation defined section suitable purpose key feature type system capture information order heap access recall example flat representation heap loses information 
define alternative operational semantics represents heap nested letrec expressions show soundness type system respect semantics 
includes strange reduction rules easy see alternative semantics essentially equivalent original semantics 
section define alternative semantics show theorem intuitively says correspondence reduction ordinary semantics alternative relation int int dom dom dom binary operations op int op op op op op op defined 
undefined op op op op op dom dom dom dom unary operations op op int int op op op op op op op op op definitions relation operations types type environments semantics expression reduced error ordinary semantics reduced error alternative semantics 
properties imply expression reduced error alternative semantics ordinary semantics result evaluation 
section devoted showing typed expression reduced error alternative semantics 
alternative operational semantics presenting alternative semantics explain reduction relation fails preserve typing 
consider configuration fw 

hw ig fst ffi fst ffi int ffi int ffi int int int int int int int int int int int ffi int ffi int int int int int int int fine linear pair 
reduce configuration fst resulting configuration fw 

hw ig fst ffi requires pair accessed linear pair ffi pair fst ffi type system capture order uses access different variables 
way avoid problem extend type system order access different variables expressed 
resulting typing rules complex redefine operational semantics 
idea losing information order heap access split heap space advance order account 
example configuration converted fw 
ffi 
ffi hw ig fw 

hw ig heap space split definition part body part expression safely throw away information definition part evaluated body part 
reduced fw 
ffi 
ffi hw ig fst ffi fw 

hw ig order express kinds nested heap expression introduce new class expressions called dynamic expressions section 
define reduction relation dynamic expressions section discuss correspondence original semantics new semantics section 
note new operational semantics introduced just proving theorem 
actual implementation semantics defined section cost splitting heap needs paid 
dynamic expressions syntax expressions section extended dynamic expressions follows definition dynamic expressions set dynamic expressions ranged syntax letrec introduced letrec expression letrec express heap binding extended syntax expressions heap bindings bindings nested 
expression regard letrec expression letrec free variable 
new syntax nested heap expression fx 
ffi hw ig fx 
hw ig expressed dynamic expression letrec hw ffi letrec hw example letrec letrec fst apply represents configuration fx 

fst apply example heaps expressions nested expression letrec ffi fst ffi letrec snd ffi means expression evaluated fst ffi snd ffi fst ffi evaluated viewed ffi value viewed linear value snd ffi evaluated 
operational semantics dynamic expressions define operational semantics reduction relation 
dynamic expression dynamic expression special constant error representing invalid heap access 
label shows heap value accessed reduction step 
ffl indicates internal heap value accessed indicates heap address accessed value indicates heap address split explained 
rules heap allocation correspond rules heap rec 
ffl 
letrec fresh dr heap rec ffl 
letrec fresh dr rec rules heap access 
label record heap address accessed value 
fst hv 
dr fst snd hv 
dr snd apply 
dr app rules check heap access valid 
heap value consumed access invalid expression reduced error 
evaluation succeeds consumed removed 
letrec ffl 
letrec dr read 
letrec ffl 
error dr error followings rules conditional expressions 
ffl 
dr ift ffl 
dr iff rules specify part expression evaluated 
dr says expression reduced reduced way irrelevant heap added 
dr says expression definition part reduced 

appear letrec 
letrec dr 
ffl 
dr rules error propagation 
ffl 
error ffl 
error dr ffl 
error letrec ffl 
error dr rule dr split key rule 
explained expression evaluated heap value split evaluation definition part evaluation body part 
letrec 
letrec letrec dr split definition part expression fully evaluated split heap values merged ffi values thrown away 
letrec letrec letrec ffl 
letrec letrec dr var letrec shorthand letrec letrec example expression example reduced follows fst ffi snd ffl 
letrec fst ffi snd 
letrec ffi fst ffi letrec snd ffl 
letrec ffi letrec snd ffl 
letrec ffi snd 
letrec snd letrec ffl 
letrec letrec ffl 
letrec correspondence heap operational semantics alternative operational semantics alternative operational semantics may look strange essentially equivalent heap operational semantics 
basically rule dr xx corresponds xx rules dr read dr dr introduced context 
special rules dr split dr var 
role dr split just force access capability heap value split may causes errors due inappropriate splitting change result successful evaluation 
formally state theorem introducing definitions 
definition translation dynamic expressions translation function 
defined fg fg rec fg rec fst fg fst snd fg snd apply fg apply fg letrec fx 
hg defined dom dom dom dom dom dom dom definition binary relation heaps defined dom dom write correspondence new semantics heap semantics section formally stated theorem 
intuitively means new semantics heap semantics equivalent long error occurs error occurs heap semantics new semantics converse may hold 
write ffl 

xn 
ffl 
write reduced error matter heap bindings split ffl 
error ffl 
restrict syntax dynamic expressions contains expression form letrec form letrec letrec appear require forward letrec contains free occurrences contain sub expression form letrec theorem 
ffl 

error 

exists ffl 
proof see appendix 
type soundness checked correspondence new operational semantics original obtain theorem showing soundness type system respect new semantics 
show proving reductions alternative semantics preserve typing typed expression accesses invalid heap address immediately 
extend type system dynamic expressions introducing rules fv hv dt pair dt abs letrec dt heap type soundness guaranteed theorems 
proofs appendix theorem ffl 
error 
theorem subject reduction ffl ffl 
ffl 
exists 
subject reduction property little complicated usual typed dynamic expression may reduced ill typed expression heap value split inappropriate way 
example letrec snd reduced dr split letrec ffi snd letrec typed reduced error 
second statement lemma says heap splitting rule dr split applied typed expression splitting preserves expression 
type soundness theorem follows immediately theorems 
proof theorem suppose fg error 
theorem theorem 

contradict theorem theorem 
type reconstruction annotations automatically inferred unannotated expressions 
done basically way previous linear type systems explain informally 
basic idea introduce variables ranging uses types constraints express general typing principal typing expression 
new type judgment form set constraints specifies set uses types type variable range 
instance hy yi typed ff fff fi fl ffi jg hy yi fi fl 
typing principal sense typings derivable rules section obtained instantiating variables ff fi fl constraint satisfied 
give formal definition principal typings basically 
unannotated expression inference annotation proceeds follows second third steps may overlap 
attach fresh variable place annotation required annotated expression 

compute principal typing 
solve constraint apply obtained substitution subsections explain second third steps little detail discuss cost analysis 
computing principal typing algorithm computing principal typing obtained constructing syntax directed typing rules new type judgment form reading bottom 
example merge rules pair weak obtain rule new type judgment form ffi hv tr pair means substitution type variables satisfied satisfied 
rule says order compute typing hv compute typing add new constraints entailing ffi 
major difference previous linear type inference constraints type variables appear recall typing hy yi 
form meaning compatible sense defined words identical outer uses 
righthand type expression may contain constructors type expressions functions types 
solving constraints types uses algorithm solving constraints divided steps 
set constraints type variables simplified pair set constraints variables form set trivial constraints type variables form ff fi ff type expression fi fl constructed type variables 
simplification performed partial unification types uses kept different 
example constraint ff fi real fl instantiate ff fl fi real fi real fresh variables fi fi reduce constraint ffi fi fi set trivial constraints type variables solution remaining type variables instantiated say int obtain assignment variables solving set constraints variables 
simple iterative method previous linear type systems 
course assignment variables completely determined program 
example expression type real find assignment variable know places evaluation result expression 
unknown variables simply assign delay constraint solving 
important difference previous linear type inference solution necessarily best solution viewpoint memory management 
example consider expression fst 
annotation fst ffi 
expression deallocated access pair fst annotated ffi 
better annotate expression fst 
think ways dealing 
way classify uses annotating heap allocation annotating heap access 
solution obtained maximize heap access annotations long heap allocation annotations increase 
way extend target language explicit deallocation operation free deallocates heap values heap accessed described 
note constraint ffi expressed die 
example free real real ffi deallocates rule weak changed follows type environment free weak change avoids forgetting deallocate linear values 
optimize result moving operation free leftward merging heap access annotation far possible 
guarantee methods give best annotation expect give annotation practice 
cost analysis unfortunately computational cost type reconstruction exponential size input worst case 
reason number variables linear size type variable appearing input expression size type exponential size input expression 
example variable required type int int int int context typing int int int int fi int int int int number variables linear size type int int int int 
consider expression hx hx hx size type expression exponential spite fact expect reconstruction performed efficiently realistic programs reasons 
problem occurs tuple record types extraordinarily nested huge flat tuple type expression int int int arrow type expression cause problems 
second computational cost really problematic programs save cost sacrificing accuracy analysis 
example restrict operator defined forces type expressions shared saves time space analysis fact previous analysis imposes similar restriction performed polynomial time monomorphic type system 
extensions far considered simply typed calculus recursion pairs 
section discuss kinds extensions introduce polymorphism order improve analysis introduce kinds data recursive data structures cells 
polymorphism type system section monomorphic uses types analysis quasi linear values rough 
consider expression hx xi apply apply value forced value code pair creation body function shared 
order avoid problem introduce polymorphism uses 
type fi int 

int int expression annotated example hx xi apply ffi apply uses explicitly passed parameters polymorphic functions 
attached indicates polymorphic function accessed linearly 
general need introduce constrained type scheme definition atomic constraints ff ae ff fi ae ff ae ae ae ae ae ffi due fc oe type schemes ff oe new rule polymorphic expressions roughly looks ff ff cv ffg cv denotes set type variables may influence value type variable set satisfying conditions fv fv cv ff cv ff ae fv ae cv ff cv ff fi fi ff fi cv cv fv cv fv fv fv ae fv denote set free type variables appearing ae respectively 
denotes set type variables constrained defined fff fi ff fi cg fff ff cg fi cg actual implementation may need allocate instance example polymorphic function heap 
annotation assumed instances deallocated polymorphic function deallocated 
order deallocate instance polymorphic function separately need annotate type scheme example type scheme changed fi die int 

int int expression annotated hi ji hx xi apply ffi apply annotation means polymorphic function deallocated instance created deallocated 
attached apply represents instance deallocated 
large constants far considered integers constants 
order deal large constants constants represented word allocated heap need annotate allocation large constant 
example allocation linear real number annotated 
type large constant annotated 
instance type linear real numbers represented real typing rule real numbers follows real primitive functions primitive functions treated constants polymorphic types occurrence primitive function annotated uses 
example primitive real numbers assigned type fi ffi ffi ffi di real real real expression annotated hy zi 
recursive data structures recursive data structures lists trees treated way pairs annotating type constructors uses 
type list values type expressed list expresses cons cell list 
example real list type list cons cells may accessed times arbitrary manner elements real numbers accessed linearly 
primitives lists types ff ff ff list ff list nil ff ff list null ff ff list bool hd ff fi ffig ff list ff tl ff fi ffig ff list ff list types function append type ff fi fl fff fl fi fl ffi ffi dke ffi ff list fi list fl list general generate types constructors destructors datatype declarations standard ml 
cells order deal cells need introduce new type constructor 
type cell form ref type stored value cell denotes times stored value may read 
primitives cells annotated follows ref 
ref creates cell store accessed value 
reads value stored cell time linear deallocates cell 
stores value cell time linear deallocates cell 
typing rules example follows de ref ffi de ref ref ref ref 
deref ref ref update rule ref de ref means created cell may read times cell updated time value read value type stored value may totally value type tricky point rule update read count 
currently stored value replaced read 
preliminary experiments implemented prototype type reconstruction system core ml sml modules quasi linear type system simple profiler executes output program counts number allocated heap values 
describe current status system section report results simple experiments section 
prototype system available www yl tokyo ac jp research 
prototype type reconstruction system extensions discussed section implemented prototype analyzer 
takes expression core ml input performs type reconstruction produces annotated expression 
implemented ml kit version front supports full features core ml records datatype declarations exceptions 
polymorphism types uses polymorphism discussed section 
polymorphic recursion uses sound just polymorphic recursion regions sound region inference supported currently 
algorithm complex polymorphic recursion crucial analysis 
current system limitations 
produces annotation best see section analysis cell rough unnecessary uses passed parameters polymorphic functions removed manner unnecessary region parameters removed post path region inference current system slow known reasons just preferred rapid prototyping system optimized compiler utilizes analyzed information place update implemented :10.1.1.24.9456
results preliminary experiments table shows result experiments 
columns zero linear omega respectively show heap values allocated dynamically program 
rightmost column shows percentage heap values zero linear 
polymorphic function real real allocation counted words creations instances 
counted heap allocation current analyzer infers instance polymorphic function total instances see 
program list integers computes sum 
qsort sort list real numbers quick sort merge sort algorithms 
written naive way main part quick sort program fun quick quick val divide append quick quick sieve finds prime numbers sieve eratosthenes 
life computes generations lives generated initial lives 
reynolds programs taken parameters changed :10.1.1.24.9456
reynolds slightly modified version reynolds function uncurried analysis works better 
cases merge quick sorts sieve eratosthenes heap values linear non linear values top level functions 
looking produced annotated expression find cons cells generated merge quick sorts sieve eratosthenes updated place 
case life curried functions original program uncurried see discussions section reynolds heap values linear number linear zero linear omega zero linear total qsort sieve life knuth bendix boyer mandelbrot reynolds reynolds table number allocated heap values values huge greatly reduce need garbage collection 
knuth bendix boyer programs percentage linear values relatively smaller 
probably unification order terms performed program causes sharing heap values 
note percentages shown rightmost column necessarily indicate memory space saved analysis compared memory management conventional garbage collection extra memory space required representing polymorphic functions instances clear soon linear values deallocated 
current analysis performed unoptimized programs optimizations inlining hoisting may reduce ratio linear values 
know sure real impact analysis serious experiments carried purpose described section completed 
related previous linear type systems knowledge previous linear type systems automatically infer usage values barendsen smetsers uniqueness typing takes evaluation order account 
effect evaluation order account depends programming style evident functions fun map map map fun diff diff member diff diff fun move dx update dx function map list diff function computing set difference times judged linear quasi linear type system 
function move takes record representing point object argument adds dx field 
update primitive takes triple consisting record label value returns record obtained replacing field 
point accessed twice judged linear 
uniqueness typing different ways evaluation order call type system ffi type values locally relies separate analysis analyzing order memory access analysis integrated type system complex 
guzm hudak odersky proposed kind extension linear type system take evaluation order account check destructive operations arrays lists safely 
approach programmers explicitly declare destructive operations performed special primitives destructive update data structures check safe performing type inference 
technical novelty analysis definition operation 
previous type system defined identical outermost uses 
restriction analysis inaccurate example pair real numbers real real place real real place uses coerced real real total counted real real region inference alternative approach static memory management region inference 
region inference abstracts bunch memory addresses region estimates life time performing kind type inference 
region inference infers addition usual type information region expression may access automatically inserts allocation deallocation regions 
type system region inference advantages disadvantages 
life time data estimated region wise difficult region inference place update dealt strict expressions analysis naive analysis 
possible cases multiplicity inference storage mode analysis :10.1.1.24.9456
shortcoming region inference data merged region especially recursive data structures higher order functions cells result analysis life time data rough 
intend say analysis better lists region inference 
cons cell list accessed value analysis assigns type list list cons cells list deallocated automatically 
case region inference better 
hand advantages region inference completely independent values accessed deallocation data region performed constant time 
may interesting type system region inference complementary methods static memory management 
goal analysis similar storage mode analysis proposed complementary region inference :10.1.1.24.9456
analyzes access value access region value inserts code deallocate values region 
analysis storage mode analysis value deallocated data region garbage 
give examples analysis region inference analysis works region inference region inference works analysis 
program analysis region inference consider program taken fun fun cycle cycle val fn :10.1.1.24.9456
hd val cycle fn region inference analysis list generated collected cycle called live moment pointer list 
case analysis list allocated place list creation annotated 
programs analysis works region inference consider program reynolds taken datatype tree lf br tree tree fun mktree lf mktree val mktree br fun member false member rest orelse member rest fun search lf false search br member true search orelse search val search mktree region inference cons cell created deallocated search orelse search fully evaluated analysis deallocated search evaluated :10.1.1.24.9456
consider function merge fun merge int list merge merge merge merge region inference cons cells lists deallocated merge computed cons cells merged region 
hand unnecessary cons cells cons cells matched patterns program immediately deallocated analysis 
consider example val ref fn region inference deallocated expression evaluated stored region accessed function fn alive 
hand analysis deallocated immediately evaluated type inferred real real reasons region inference order know region inference examples needs know ideas region inference 
region inference type extended information value type stored 
example real ae type real number stored region ae 
real ae 
fae ae real ae ae type function takes argument stored region ae accesses regions ae ae returns real number stored region ae function stored region ae performing type inference type system operations allocating deallocating regions inserted 
example closed expression inferred type real ae value allocated region ae inside know value alive deallocated evaluated 
main reason region inference second example cons cells list stored region 
represent type finite expression impossible distinguish region cell constitutes recursive data structure 
example type list real numbers real ae list ae ae region elements list stored ae region cons cells stored 
cons cells elements put list deallocated garbage 
reason third example region polymorphism region annotated types express poor dataflow information 
region polymorphic type ae ae real ae 
fae ae real ae ae means function type takes argument stored region ae returns result stored region ae subsumes information represented annotated type real ffi real type system 
third example assigned monomorphic type real ae 
fae ae real ae ae 
place may case escapes argument stored region ae means region ae deallocated certain call function program region inference works analysis consider program fun real fn 
val val analysis judged deallocated invocation uses value called twice 
hand region inference deallocate expression evaluated 
consider program fun choose val val choose true inferred value deallocated analysis deallocated region inference 
reason analysis example dataflow information represented ffi naive 
second example reveals limitation analysis counting value access knowing value analysis find may result infers may twice 
proposed extended linear type system elegantly take evaluation order account proved correctness 
static memory management proposed region inference currently popular conventional garbage collection 
think important near 
static memory management especially attractive parallel distributed environments requires communications synchronizations conventional garbage collection 
second increasing importance cache memory saving memory space program save execution time 
type system proposed call value languages clear similar type system developed lazy functional languages 
left done apply type system compiler ml know real impact 
need issues fairly straightforward issue refinement type inference system discussed section annotation may optimal viewpoint memory management need modify analyzer produce better annotation 
reduction cost passing passing uses polymorphic functions takes extra cost need reduce dropping unnecessary uses just unnecessary region parameters region inference similar technique type lifting :10.1.1.24.9456
transformation place updates need implement compilation path finds places deallocation heap value immediately followed allocation value type replaces place update 
combination conventional garbage collection linear type memory management automatically deallocate quasi linear values need conventional garbage collector 
subtle problem linear type memory management pointer traversal information may create dangling pointer just region memory 
example closure fst fy ig traced garbage collection time second element may deallocated 
ways dealing problem 
way exclude type system dangling pointers created 
way currently exploring atsushi igarashi idea tag free garbage collection utilize annotated types tracing heap values garbage collection time conventional types 
example type real real closure known second element accessed closure need traced garbage collector 
improvement accuracy analysis 
order access different variables account type system deal order access different variables analysis rough variables aliased 
example consider expression fst ffi fst 
refer heap value regard linear value current type system judges value 
overcome problem representing type environment poset type bindings order express order access different variables earlier version kobayashi type system deadlock freedom 
combining analysis analyses analysis ffi values weak dealing curried functions 
consider expression fst curried version 
expression ffi assigned assigned 
problem may serious ordinary compiler optimization functions far possible may interesting improve analysis accurate dataflow information obtained region inference 
acknowledgment atsushi igarashi martin odersky mads tofte anonymous referees useful discussions comments 
henry baker 
lively linear lisp look ma garbage 
acm sigplan notices 
henry baker 
linear logic quicksort 
acm sigplan notices 
erik barendsen smetsers 
conventional uniqueness typing graph rewrite systems 
technical report csi computer science institute university nijmegen 
extended appeared proc 
fst tcs springer lncs pp 
lars birkedal nick rothwell mads tofte david turner 
ml kit version 
technical report department computer science university copenhagen 
lars birkedal mads tofte magnus :10.1.1.24.9456
region inference von neumann machines region representation inference 
proceedings acm sigplan sigact symposium principles programming languages pages 
jean yves girard 
linear logic 
theoretical computer science 
juan guzm paul hudak 
single threaded polymorphic lambda calculus 
proceedings ieee symposium logic computer science pages 
atsushi igarashi 
type analysis usage values concurrent programming languages 
master thesis department information science university tokyo 
atsushi igarashi naoki kobayashi 
type analysis usage communication channels concurrent programming languages 
proceedings international static analysis symposium sas volume lecture notes computer science pages 
springerverlag 
naoki kobayashi 
partially deadlock free typed process calculus simple system 
technical report department information science university tokyo september 
naoki kobayashi 
partially deadlock free typed process calculus 
acm transactions programming languages systems 
preliminary summary appeared proceedings lics pages 
naoki kobayashi benjamin pierce david turner 
linearity pi calculus 
proceedings acm sigplan sigact symposium principles programming languages pages january 
ian mackie 
functional programming language linear logic 
journal functional programming october 
robin milner mads tofte robert harper david macqueen 
definition standard ml revised 
mit press 
greg morrisett 
compiling types 
phd thesis school computer science carnegie mellon university 
greg morrisett matthias felleisen robert harper 
models memory management 
proceedings functional programming languages computer architecture pages 
martin odersky 
observers linear types 
proceedings th european symposium programming esop volume lecture notes computer science pages 
springer verlag 
rinus plasmeijer marko van eekelen 
concurrent clean ver language report 
available www cs kun nl clean 
mads tofte jean pierre talpin 
implementing call value lambda calculus stack regions 
proceedings acm sigplan sigact symposium principles programming languages pages 
andrew tolmach 
tag free garbage collection explicit type parameters 
proceedings acm conference lisp functional programming pages 
david turner philip wadler christian mossin 
type 
functional programming languages computer architecture san diego california 
proofs laws operations uses types type environments list laws operations defined section 
frequently proofs 
lemma 
operation uses types type environments associative commutative 

operation uses types type environments associative 

operation uses associative commutative 

unary operations monotonic 







proof trivial definitions operations 
proof theorem definition outermost outermost type written defined int undefined 
lemma 
proof trivial induction derivation 
proof theorem suppose ffl 
error 
subterm form letrec letrec 

typing rules dynamic expressions 
lemma contradicts 
proof theorem show theorem induction derivation 
proving theorem need lemmas 
lemma says obtain syntax directed typing rules eliminating weak 
lemma elimination weakening derivable derivable weak rule var 
proof follows fact weak applied rules var permuted upwards 
lemma renaming defined proof trivial induction derivation lemmas show typing changed reductions labeled lemma hv 
proof show lemma induction derivation hv 
case analysis rule 
ffl case dr fst case fst suppose rule fst null applying lemma obtain fact follows rule weak null ffl case dr snd similar case dr fst ffl case dr case letrec letrec hv 
suppose dt heap induction hypothesis dt heap weak obtain required 
lemma 

holds defined 
proof induction derivation 
case analysis rule 
ffl case dr app case apply suppose applying lemma applying obtain inequalities fact similarly 
applying weak obtain required 
ffl case dr case letrec letrec 
suppose need show dt heap induction hypothesis dt heap obtain weak obtain required 
shall show reduction dr var preserves typing lemma 
need technical lemmas lemma 
lemma defined proof trivial rules dt pair dt abs 
lemma bc bc proof show case analysis ffl case form hv dt pair bc bc bc bc required 
ffl case form dt abs cb cd bc bc bc required 
lemma letrec de letrec bc de 
proof induction length ffl base case suppose de 
derived var weak de 
de de 
ffl induction step suppose letrec de 
dt heap letrec de lemma induction hypothesis letrec kc de dt heap fact letrec kc de required 
lemma letrec letrec letrec proof sufficient show case empty sequence letrec letrec implies letrec letrec rules dt pair dt abs 
show induction length sequence ffl base case suppose applying lemma obtain weak 
ffl induction step suppose letrec letrec typing rules letrec letrec typing rules letrec letrec lemma letrec applying obtain letrec letrec induction hypothesis weak follows letrec lemma lemma letrec bc letrec bc required 
proof theorem show induction derivation 
case analysis rule 
ffl dr heap case letrec ffl 
case hy trivial typing rules 
suppose rule abs loss generality assume dom 
applying weak dt abs dt heap ffl dr rec trivial typing rules 
ffl dr read case letrec letrec 
hv suppose hv lemma dt pair dt heap letrec hv letrec hv ffi lemma dt abs dt heap letrec required condition letrec follows show shown follows inequality trivial 


inequality trivial 

ffl dr ift case suppose int weak ffl dr iff similar case ift 
ffl dr case letrec letrec 
suppose case analysis case ffl ffl 
induction hypothesis dt heap obtain case 
induction hypothesis exists 
letrec 
ffl dr case 
suppose case analysis case ffl 
induction hypothesis obtain case 
induction hypothesis 

ffl dr split case letrec letrec letrec suppose show 
case analysis case form hv dt pair dt heap letrec letrec 
weak 
law 
case form dt abs dt heap 
letrec letrec 
dt abs dt heap weak 
ffl dr var case follows lemma 
proof theorem lemma 
fx 
hg fx 
hg proof straightforward induction derivation 
lemma proof trivial fact fx 
hg fx 
hg 
lemma letrec letrec 
proof suppose letrec 
letrec 
letrec letrec ffl 
error 

shorthand 
xn 
suppose letrec 
ffl 
letrec letrec letrec letrec letrec letrec letrec ffl 
letrec conditions contradicts letrec 
easily construct derivation letrec ffl 
letrec 
proof theorem 

implies suffices show ffl 
implies hold show induction derivation ffl 
case analysis rule 
cases dr heap dr rec dr ift dr iff dr dr var trivial 
case dr read follows lemma 
rule dr ffl 

induction hypothesis 
lemma required 

suppose error reduction rules context expression form apply fst snd 
easily show induction structure 
ffl case case analysis ffl case letrec letrec hw letrec 


hw letrec hw 
induction hypothesis 
lemma 

suppose reduction rules context expression form rec apply fst snd show holds exists ffl 
induction structure 
ffl case case analysis ffl case letrec letrec hw letrec 


hw 


hw letrec hw 
error 
case second property theorem 
lemma 
case induction hypothesis ffl 
letrec ffl 

