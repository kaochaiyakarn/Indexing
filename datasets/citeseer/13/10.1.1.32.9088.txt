rule languages victor vianu cse san diego la jolla ca vianu cs ucsd edu august presents survey main formal rule languages semantics 
procedural fixpoint declarative model theoretic semantics defined discussed including inflationary fixpoint semantics stratified founded semantics 
relative expressive power complexity various languages provided 
nondeterministic rule languages discussed shown nondeterminism circumvent difficulties concerning expressive power deterministic languages 
languages value invention spirit object creation oodbs issues expressive power specific languages discussed 
rule languages lie core areas central importance databases artificial intelligence deductive databases active databases production systems 
presents survey main rule languages 
emphasis various semantics expressive power complexity languages 
terms semantics main competing approaches rule languages 
shall call logic programming approach attempts provide declarative model theoretic semantics programs 
paradigm dominant deductive databases 
second approach call production systems approach provides procedural semantics forward chaining rules 
approach dominant active databases production systems 
underlying theme survey comparison competing approaches context various languages 
rule languages considered survey variations datalog 
introducing language provides nice simplified abstraction recursion 
terms competing approaches alluded earlier datalog garden eden rule languages perfect marriage logic programming supported part national science foundation iri 
production systems approach semantics 
difficulties negation 
procedural production systems semantics datalog extension denoted datalog allows explicit retraction facts 
describe main declarative semantics proposed datalog various restrictions semi positive stratified founded semantics compare expressive power languages various procedural declarative semantics 
results regard expressive power convergence procedural declarative semantics known fixpoint queries 
deterministic languages including rule languages known limitations expressive power 
example known languages expresses precisely ptime queries 
consider ways circumvent limitations 
trades data independence principle expressiveness formalized results expressiveness presence order 
example datalog inflationary founded semantics shown express ordered databases exactly queries computable polynomial time 
second intimately related trades determinism expressiveness 
exhibit nondeterministic rule languages express deterministic nondeterministic queries computable polynomial time 
argue nondeterminism useful feature independently issues expressiveness 
practical production systems fact nondeterministic 
terms semantics nondeterministic languages nondeterminism arises firing rule instantiations arbitrary order 
describe approach choice operator yields outputs related stable models program 
look rule languages allow invention new values 
rules arise object oriented context object creation useful common operation 
results impact feature expressiveness rulebased languages 
particular exhibit language expresses traditional queries complete 
point limitations ability rule languages express nontraditional transformations contain newly created objects results 
organized follows 
background provided section 
production systems approach surveyed 
introduces datalog inflationary datalog datalog logic programming approach developed section including semi positive stratified founded semantics datalog relative expressive power languages provided section including connections complexity classes queries 
nondeterministic languages discussed section value inventing language section 
lastly including discussion procedural vs declarative semantics rule languages 
survey inspired presentations bid av ahv 
proofs ahv course original papers pointers provided 
background section review terminology relating relational databases 
particular recall traditional query languages including iterative extensions order logic relational algebra fixpoint mos ch cha queries 
assume reader familiar basic concepts terminology relational database theory see ull ull ahv 
refer kan survey field 
review briefly basic terminology notation 
assume existence infinite pairwise disjoint sets symbols set att attributes set dom constants set var variables 
relational schema finite set attributes 
free tuple relational schema mapping dom var 
constant tuple relational schema mapping dom 
instance relation schema finite set constant tuples database schema finite set relational schemas 
instance database schema mapping instance set instances schema denoted inst 
note logic terms database schema supplies finite set predicates database instance provides interpretation predicates finite structures 
finite structures considered 
interested primarily database queries updates involve transformations database instances database instances 
distinguish deterministic nondeterministic database transformations 
nondeterministic database transformation subset inst theta inst deterministic database transformation mapping inst inst 
database transformations usually required obey conditions typedness effective computability genericity au ch hy 
typedness captured requiring instances fixed schema related instances fixed schema 
effective computability self explanatory 
genericity originates data independence principle query update information provided conceptual level database 
particular distinct data values treated differently distinguished information available conceptual level named explicitly query update 
formally genericity requires graph database transformation closed isomorphisms domain 
refer complexity classes database transformations 
complexity measures time space turing machine produce standard encoding output instance starting encoding input instance 
turing machine complexity class corresponding complexity class nondeterministic transformations denoted db 
particular class nondeterministic database transformations computed nondeterministic turing machine polynomial time denoted db ptime 
important distinguish classes ndb nondeterministic queries classes deterministic queries defined nondeterministic devices 
example savitch theorem pspace db pspace db 
classes deterministic queries 
ndb pspace contains nondeterministic transformations db pspace ndb pspace ndb pspace similarly db np confused ndb ptime program transformation language mapping relation database instances program describes called effect program constitutes semantics program 
query languages practical query languages relational databases fo order logic relations called relational calculus 
fo called relational algebra cod 
relational algebra provides operations relations projection attributes oe selection tuples satisfying condition consisting equalities attributes constants ffi rename attribute join relations gamma difference union 
useful queries fo express transitive closure graph 
numerous extensions fo recursion proposed 
converge central classes queries fixpoint mos ch cha 
defined various ways adding fixpoint operators fo mos av looping constructs relational algebra cha ch extensions datalog av 
briefly review definition fixpoint looping constructs 
fixpoint 
extends fo recursion 
provides relation variables statements form fo query looping construct fo condition 
equivalent variation uses loops form change iterate body long change relation 
fixpoint semantics assignment cumulative assignment denoted adds current content 
guarantees termination fixpoint programs polynomial time programs require polynomial space 
production systems approach describe languages datalog datalog datalog procedural semantics 
procedural semantics intuitively simple rules program fired parallel fixpoint reached 
straightforward semantics datalog languages 
datalog activity deductive databases focused toy language called datalog 
early history datalog discussed mw 
limited datalog highlights aspects recursion practical languages 
optimization techniques deductive databases developed datalog 
formally presenting datalog informally syntax procedural semantics 
fixpoint semantics consider due ch 
considered earlier context logic programming ave 
datalog program tc computes transitive closure graph 
graph represented relation transitive closure relation datalog program defines relations occurring heads rules relations 
definition recursive defined relations occur bodies rules 
datalog program interpreted mapping instances relations occurring bodies instances relations occurring heads 
example program maps relation graph relation transitive closure 
formally define syntax datalog 
definition datalog rule expression form relation names free tuples tuples variables constants 
variable occurring occur datalog program finite set datalog rules 
head rule expression forms body 
set constants occurring datalog program denoted adom instance adom abbreviation adom adom 
datalog program 
extensional relation relation occurring body rules 
intensional relation relation occurring head rule extensional database schema denoted edb consists set extensional relation names intensional schema idb consists intensional ones 
schema denoted sch union edb idb 
semantics datalog program mapping database instances edb database instances idb 
contexts call input data extensional database call program intensional database 
note context logic languages term predicate place term relation name 
procedural semantics datalog defined 
operator called immediate consequence operator 
operator produces new facts starting known facts rules 
active domain instantiation rule rule valuation maps variable adom 
datalog program instance sch 
fact immediate consequence edb relation instantiation rule immediate consequence operator denoted mapping inst sch inst sch defined follows 
consists facts immediate consequences note simple mathematical properties operator sets instances 
define useful properties 
operator ffl monotone implies 
ffl fixpoint easily shown theorem minimum fixpoint extending denoted 
minimum fixpoint computed follows 
instance edb compute clearly follows immediately fact monotonicity number facts predicates sch elements sequence ft reaches fixpoint steps 
particular fixpoint denote fixpoint 
fixpoint approach suggests straightforward algorithm evaluation datalog 
explain algorithm example 
extend relational algebra operator allows iterate algebraic expression condition holds 
consider transitive closure query 
wish compute transitive closure relation relation suppose relations ab 
computation performed program ab ffi ffi recall ffi attribute renaming operation relational algebra see section 
lot redundant computation performed running program 
array optimization techniques datalog evaluation developed see br bid cgt ull ahv 
scope 
datalog datalog allows negations bodies rules 
datalog rules infer set facts 
fact inferred removed set true facts 
example datalog program input graph binary relation program computes relation closer defined follows closer fhx dg dg dg denotes distance nodes 
infinite path 
program closer program evaluated follows 
rules fired simultaneously applicable valuations 
firing facts inferred 
repeated new facts inferred 
negative fact true inferred far 
preclude inferred firing rules 
firing rules called stage evaluation program 
program transitive closure computed consider consecutive stages evaluation program 
note fact inferred stage inferred means distance hold stage closer inferred 
formal syntax semantics datalog straightforward extensions datalog 
datalog rule expression form atom atom case called positive negated atom case called negative 
active domain semantics evaluating datalog require rules range restricted 
datalog program non empty finite set datalog rules 
datalog programs sch denotes database schema consisting relations involved program relations occurring heads rules idb relations edb relations procedural semantics datalog extension fixpoint semantics datalog 
instance sch 
recall active domain instantiation rule rule valuation maps variable adom 
fact immediate consequence edb relation instantiation rule positive fact negative immediate consequence operator denoted gamma defined follows 
sch gamma fa immediate consequence instance edb compute gamma gamma gamma suggested example application gamma called stage evaluation 
definition gamma gamma gamma gamma datalog sequence reaches fixpoint denoted gamma finite number steps 
restriction idb relations subset thereof called image answer procedural semantics described increasing sets facts inferred firings rules 
reason semantics referred inflationary semantics datalog inflation tuples 
language datalog inflationary semantics referred inflationary datalog semantics proposed av kp 
datalog recall datalog inflationary semantics fact inferred retracted 
datalog allows explicit retraction previously inferred fact semantics datalog av 
syntactically done negations heads rules interpreted deletions facts 
close practical production systems languages 
resulting language denoted datalog indicate negations allowed heads bodies rules 
immediate consequence operator gamma semantics datalog program analogous datalog important proviso 
negative literal inferred fact removed inferred firing rules 
gives priority inference positive negative facts somewhat arbitrary 
possibilities give priority negative facts ii interpret simultaneous inference op including new instance old iii interpret simultaneous inference contradiction result undefined 
chosen semantics advantage iii result defined 
case choice semantics crucial results equivalent languages 
semantics chosen termination longer guaranteed 
instance program terminates input 
value flip flops fh ig fh ig fixpoint reached 
rule algebra examples datalog programs shown earlier clear semantics programs easy understand 
simple mechanism facilitates specification user various customized semantics 
done means rule algebra allows specification order firing rules firing fixpoint inflationary manner 
rule algebra logic programs introduced 
inflationary version rule algebra variations possible 
inflationary version ra base expressions individual datalog rules semantics associated rule apply immediate consequence operator cumulative fashion 
union specify simultaneous application pair rules complex programs 
expression specifies composition semantics execute 
inflationary iteration program called version rule algebra denoted ra starts datalog rules destructive semantics 
union composition generalized natural fashion iterator denoted 
example set rules consist rule ct ra program computes ct complement transitive closure shown ra equivalent datalog ra equivalent datalog av 
ra program compiled possibly complicated datalog program 
instance ra program example equivalent datalog program example 
advantage rule algebra lies ease expressing various semantics simple building blocks 
particular ra easily specify stratified founded semantics datalog introduced section 
logic programming approach declarative semantics datalog datalog knowledge semantics proposed datalog minimum model semantics datalog key idea model theoretic approach view program set order sentences describes desired answer 
instance rules pct yield logical formulas result satisfy sentences 
sufficient uniquely determine result easy see satisfy sentences 
turns result unique adds natural minimality requirement consists smallest set facts sentences true 
turns datalog program input unique minimal instance satisfying sentences corresponding program extending input 
defines semantics datalog program 
example suppose instance contains turns holds instance obeying facts hold 
particular belongs minimum instance satisfying includes input database instance constituting result satisfies sentences 
instance called model sentences 
problem arises infinitely instances satisfying sentences program 
sentences uniquely identify answer remains necessary specify models intended answer 
usually done assumptions external sentences 
section formalize relationship rules logical sentences ii notion model iii concept intended model 
associating logical sentences rules introductory discussion 
datalog rule ae associate logical sentence xm xm variables occurring rule standard logical implication 
observe instance satisfies ae denoted ae instantiation belong 
distinguish rule ae associated sentence 
program conjunction sentences associated rules denoted sigma turns datalog program input minimum model sigma extending model semantics input denoted 
surprising elegant property datalog declarative procedural semantics datalog programs coincide 
real competition logic programming production systems approaches case datalog reinforce sides coin 
defined modeltheoretic semantics fixpoint particular minimum fixpoint extending shall see harmonious coexistence declarative procedural semantics ceases soon negation introduced 
model theoretic semantics datalog review main declarative semantics datalog fragments thereof datalog stratified datalog founded semantics datalog basic problem hope extend model theoretic semantics datalog datalog just smoothly syntax 
unfortunately things straightforward negation 
illustrate informally problems arise 
datalog associate datalog program set sigma fo sentences corresponding rules note datalog sigma model extending input instance idb relations contain tuples values clearly model sigma datalog model theoretic semantics program unique minimal model sigma extending input 
unfortunately simple solution longer works datalog uniqueness minimal model extending input guaranteed 
example pq program fp pg 
program pq distinct minimal models fpg fqg 
example suppose want compute pairs disconnected nodes graph interested complement transitive closure graph edges binary relation naturally tempted write program ct input predicate sch transitively closed ct fhx yi occur hx yi clearly may verify minimal model sigma satisfying program sigma minimal models specify model intended solution 
various criteria models proposed hopefully distinguish intended model candidates 
shall discuss criteria go 
unfortunately criteria suffices job 
reflection clear criteria exist permit identification unique intended model minimal models 
case program pq example minimal models completely symmetric cases property separate just information input program 
summary approach datalog minimum model semantics breaks negation 
shall describe solutions problem giving semantics datalog programs 
simplest case build 
semi positive datalog consider semi positive datalog programs apply negation edb relations 
example difference defined rule program diff give semantics simply closed world assumption holds iff active domain edb relation content database semantics program clear 
elaborate 
definition datalog program semi positive negative literal occurs body rule edb 
name suggests semi positive programs positive 
eliminate negation semi positive programs adding edb relation new edb relation holding complement active domain replacing 
surprising semi positive programs behave datalog programs 
result easily shown 
theorem semi positive datalog program 
instance edb sigma unique minimal model satisfying 
ii gamma unique minimal fixpoint satisfying 
iii minimum model fixpoint ii identical equal limit sequence gamma semi positive datalog program input denote semi minimum model sigma equivalently fixpoint gamma restriction edb equals example semi positive program datalog fo program computes transitive closure complement hand program complement transitive closure semi positive program 
naturally viewed composition semi positive programs program computing transitive closure followed program computing complement 
stratification studied may viewed closure semi positive programs composition 
allow specify instance composition just described computing complement transitive closure 
stratified semantics datalog consider natural extension semi positive programs 
semi positive programs negation restricted edb relations 
suppose defined relations views 
relation defined program programs subsequently treat edb relation apply negation 
simple natural idea underlies important extension semi positive programs called stratified programs 
surprisingly appealing semantics independently proposed quite investigators ch abw lif gel 
suppose datalog program idb relation defined rules able read program idb relation portion defining comes negation simply compute negation done 
example consider program example 
clearly intended defined rules negation rule defining ct rules applied third 
way reading called stratification defined 
definition stratification datalog program sequence datalog programs mapping oe idb fp partition ii predicate rules defining oe program partition 
iii rule idb relation oe oe 
iv rule idb relation oe oe 
stratification called stratum stratification oe stratification mapping 
intuitively stratification program provides way parsing sequence subprograms defining idb relations 
iii relation positively definition defined earlier simultaneously allows recursion 
negation definition iv definition come strictly unfortunately datalog program stratification 
example way read program pq example defined programs stratification called 
pq 
hand clearly stratum consists rules defining second stratum consists third rule defining ct simple test checking program 
surprisingly involves testing acyclicity condition definitions relations negation 
datalog program 
precedence graph labeled graph nodes idb relations edges ffl rule hr ri edge label called positive edge 
ffl rule hr ri edge label gamma called negative edge 
program tested precedence graph follows 
proposition datalog program iff precedence graph cycle containing negative edge 
clearly test provided proposition takes time polynomial size program consider program stratification oe stratification oe easily give semantics understood programs 
notice program stratification uses negation edb note edb generally contains idb relations 
furthermore edb defined preceding idb 
program semi positive relative previously defined relations 
semantics obtained applying order programs precisely instance edb 
define sequence instances gamma gamma note extends gamma providing values relations defined gamma equivalently gamma semantics semi positive program applied values edb relations provided gamma denote final instance obtained oe 
provides semantics datalog program stratification oe 
easily seen datalog program stratification 
different yield semantics 
fortunately answer 
datalog program equivalent yield semantics inputs 
theorem abw datalog program 
equivalent 
seen stratification provides elegant simple approach defining semantics datalog programs 
major limitations 
provide semantics datalog programs 
second stratified datalog programs quite satisfactory regard expressive power 
computational point view provide recursion negation inflationary 
expect express fixpoint queries 
unfortunately stratified datalog programs fall short expressing queries 
shown section 
intuitively due fact stratification condition prohibits recursive application negation languages expressing fixpoint computational restriction exist 
reasons consider semantics datalog programs called founded 
shall see provides semantics datalog programs allows expressing fixpoint queries 
furthermore founded stratified semantics agree stratified datalog programs 
founded semantics datalog founded semantics relies fundamental revision expectations answer datalog program 
far required answer provide information truth falsehood fact 
founded semantics idea program may necessarily provide information facts 
facts may simply indifferent answer allowed say truth value facts unknown 
turn relaxing expectations answer fashion allows provide natural semantics datalog programs 
price pay answer longer guaranteed provide total information 
aspect approach puts negative positive facts equal footing 
longer assume true simply answer 
negative positive facts inferred 
formalize shall introduce valued instances truth value facts true false unknown 
section begins introducing largely declarative semantics datalog programs 
equivalent fixpoint semantics developed 
shown stratified founded semantics agree family stratified datalog programs 
aim giving semantics datalog program find appropriate valued model sigma considering appropriate mean useful recall basic motivation underlying logic programming approach negation opposed purely computational approach 
important goal model form natural reasoning process 
particular consistency reasoning process required 
specifically fact infer negation 
captured notion appropriateness valued model intuitive aspects ffl positive facts inferred assuming negative facts ffl negative facts inferred valued model satisfying notion appropriateness called stable model turns generally programs stable models 
natural take answer certain positive negative facts belong models turns yield sense smallest stable model 
founded semantics defined 
example example concerns game states 
game players 
possible moves games held binary relation moves 
tuple ha bi moves indicates state choose move state player loses state moves 
goal compute set winning states set states exists winning strategy player state 
obtained unary predicate win 
consider input value moves moves ci hc ai ha bi ha di hd ei hd fi hf gig easily seen winning strategies states move move 
slightly subtle fact winning strategy states player prevent winning essentially forcing non terminating sequence moves 
consider program win moves win intuitively states state win state move opposing player looses 
exhibit valued model agrees moves 
seen fact founded semantics input instance moves moves values win atoms follows true win win false win win unknown win win win embark defining formally founded semantics 
steps 
define notion valued instance extend notion truth value satisfaction 
consider datalog show existence minimum valued model datalog program 
consider datalog notion stable model basis founded semantics 
valued instances dealing truth values usual requires extending basic notions instance model 
shall see quite straightforward 
denote true false unknown 
consider datalog program classical valued instance denote program obtained adding unit clauses rules fact 
moment shall deal datalog programs input included program 
denote facts form relation constants occurring particular 
datalog program 
valued instance sch total mapping 
denote set atoms truth value respectively 
valued instance total valued 
natural ordering oe valued instances sch defined oe iff 
note equivalent generalizes containment valued instances 
occasionally represent valued instance listing positive negative facts omitting undefined ones 
example valued instance written fp sg 
valued instance define truth value boolean combinations facts connectives 
truth value boolean combination ff facts denoted ff defined fi fl minf fi fl fi fl maxf fi fl fi gamma fi fi fl fl fi 
reader careful known facts boolean operators valued context may hold complex 
instance note truth value may different see definition matches intuition want verify specific semantics instance example satisfy ground instantiation case define semantics standard way valued instance sch satisfies boolean combination ff atoms iff ff 
datalog program valued model sigma valued instance sch satisfying set implications corresponding rules ground 
example recall program example input instance output instance 
consider ground sentences win moves win win moves win true win moves win 
second true win moves win 
observe hand win moves win valued minimal model datalog extend definition semantics datalog programs context valued instances 
datalog programs contain negation allowed infer positive unknown false facts 
syntax extended datalog program datalog truth values occur literals bodies rules 
extended datalog program valued immediate consequence operator mapping valued instances sch defined follows 
valued instance rule body ground body rule body ground body particular rule head 
example consider extended datalog program fp 
sg sg sg fr sg fr sg frg frg frg valued instances compared respect oe 
minimal monotonic respect oe set inclusion classical valued instances 
particular note minimum valued instance oe atoms false 
denote particular instance 
definitions extended datalog programs valued instances behave similarly classical programs 
lemma easily verified 
lemma extended datalog program 

monotonic sequence increasing converges fixpoint 
unique minimal valued model equals fixpoint semantics extended datalog program minimum valued model analogous conventional datalog denote 
ready look datalog programs wish formally define stable models datalog program bootstrap semantics programs negation semantics extended datalog programs described 
valued instance sch 
reduce problem applying positive datalog program follows 
ground version denoted pg extended datalog program obtained ground replacing negative premise 
negative literals ground replaced truth value pg extended datalog program program negation 
fixpoint pg 
contains facts consequences assuming values negative premises denote pg 
conseq 
intuitive conditions required stable models amount conseq definition datalog program 
valued instance sch stable model iff conseq observe important distinction conseq immediate consequence operator inflationary datalog inflationary datalog assumed true long inferred 
just assume case unknown try prove new facts 
course doing requires valued approach 
example consider datalog program program stable models represented listing positive negative facts leaving unknown facts fp ug fp ug fp rg check stable model program pg minimum valued model pg obtained iterating 
fixpoint 
start ug 
application yields 
fp ug 

fp tg 

fp rg 
conseq pg 

stable model reader invited verify example instance stable model program input instance 
seen example datalog programs generally stable models 
show datalog program stable model 
sense final answer consist positive negative facts belonging stable models program 
shall see valued instance obtained stable model program 
definition datalog program 
founded semantics valued instance consisting positive negative facts belonging stable models denoted wf 
datalog program input instance wf denoted wf 
founded semantics program example wf fp rg 
shall see example wf win note description founded semantics effective quite inefficient 
straightforward algorithm yielded description involves checking possible valued instances program determining stable models intersection 
provide simpler efficient way computing founded semantics 
alternating fixpoint computation converges founded semantics 
side effect proof fact shows datalog program stable model founded semantics defined 
shows founded model stable model sense smallest 
idea computation 
define alternating sequence fi valued instances underestimates overestimates facts known stable model sequence conseq recall valued instance facts value 
note defined total instance 
follows easily facts ffl total conseq total ffl constructed starting total instance repeated applications conseq intuition construction sequence fi 
sequence starts overestimate negative facts answer contains negative facts 
overestimate compute conseq includes positive facts inferred 
clearly overestimate positive facts answer set negative facts underestimate negative facts answer 
underestimate negative facts compute conseq positive facts underestimate positive facts answer 
continuing process see indexed instances provide underestimates positive facts answer odd indexed ones provide underestimates negative facts answer 
limit indexed instances provides positive facts answer limit odd indexed instances provides negative facts answer 
intuition formal 
easy see conseq antimonotonic oe conseq oe conseq 
facts oe oe immediately follows oe oe oe oe oe oe gamma oe oe subsequence increasing odd decreasing 
finitely valued instances relative program sequences constant point 
denote limit increasing sequence fi limit decreasing sequence fi inequalities follows oe note conseq conseq denote valued instance consisting facts known 
equivalently shown theorem datalog program 
stable model 
wf illustrate alternating fixpoint computation examples 
example consider program example 
perform alternating fixpoint computation described 
start ug 
applying conseq obtain sequence instances fp ug fp ug fp ug fp ug fp ug fp ug 
fp rg coincides founded semantics computed example 
recall input example 
compute program note value move atoms false agrees input predicate moves show move atoms 
win predicate win win win win win win win win win win win win win win win win win win win win win win win win win win win win win instance example 
consider database schema consisting binary relation unary relation program defining bad answer bad answer bad consider instance ci hc bi hc di ha di ha eig assume facts database added unit clauses yielding pk perform alternating fixpoint computation pk start 
containing negated atoms 
applying conseq pk yields sequence fi bad answer fa fa fa fa omitting facts relating edb predicates change step 
note stratified founded semantics coincides stratified semantics 
shall see accidental 
founded semantics provides semantics datalog programs particular stratified programs 
seen example stratified program stratified founded semantics coincide 
fortunately shown stratified founded semantics compatible 
program stratified stratified founded semantics agree 
datalog program said total wf total input edb 
theorem grs stratified datalog program total founded semantics valued instance edb wf strat 
just seen program total founded semantics 
indicated example datalog program may yield valued model wf inputs 
furthermore exist programs stratified founded models total 
unfortunately effective characterization datalog programs founded semantics total input databases 
find sufficient syntactic conditions guarantee totality founded semantics quickly tedious endeavor 
interesting question remains unresolved open problem case datalog program find program founded semantics total inputs produces positive facts 
research founded semantics related notion stable model roots investigations stable default model semantics 
formulated somewhat differently notion stable default model equivalent total stable model prz 
stable model semantics introduced gl default model semantics bf bf 
stable semantics moore autoepistemic logic moo default semantics reiter default logic rei 
equivalence autoepistemic default logic general case shown kon 
equivalence stable model semantics default model semantics shown bf 
equivalent definitions founded semantics proposed 
definition comes prz 
alternating fixpoint computation described essentially gel 
alternative procedures computing founded semantics exhibited bf prz 
historically definition founded semantics proposed grs grs 
expressive power complexity described variety rule languages datalog datalog procedural semantics inflationary datalog declarative semantics semi positive stratified founded datalog procedural semantics 
section look relative expressive power complexity languages 
relative expressiveness fo express transitive closure datalog monotonic languages incomparable 
exact power datalog precisely characterized 
investigated ac ch shm lm kv 
clearly datalog expresses monotonic queries commutes homomorphisms database constants program evaluated polynomial time 
natural wonder datalog expresses precisely queries 
answer negative 
show existence path length perfect square nodes expressible datalog datalog augmented inequalities datalog 
monotonic polynomial time query commuting homomorphisms 
datalog strictly included semi positive datalog express nonmonotonic queries negation edb predicates 
semi positive datalog fo included stratified datalog stratified vs founded semantics connection stratified founded semantics obvious fact remained open problem time 
known stratified semantics strictly weaker founded semantics 
intuitive reason stratified datalog recursion negation number applications negation bounded 
contrast datalog founded semantics allows recursion negation bound number applications negation 
distinction turns crucial 
result follows facts datalog founded semantics expresses fixpoint queries theorems ii stratified datalog strictly weaker fixpoint 
result due kol making earlier results dal ch 
putting ii obtain theorem exists query expressible total datalog program wellfounded semantics expressible stratified datalog coming query separates stratified founded semantics fixpoint nontrivial 
describe query 
query concerns called game trees 
involves game played tree 
nodes tree possible positions game edges possible moves position 
additionally leaves tree labeled black 
game players 
round game starting node begins player making move children player ii move game ends leaf reached 
player wins player ii picks black leaf 
tree labels player winning strategy game starting node win starting matter player ii plays 
interested determining exists winning strategy 
game tree represented follows 
set possible moves binary relation move set black nodes unary relation black 
consider query winning confused predicate win example asks player winning strategy starting root tree 
query expressible stratified datalog expressible datalog program founded semantics fixpoint 
interest simpler natural examples queries expressible founded datalog stratified datalog unfortunately fortunately shortage examples relatively simple queries conjectured property 
example consider query graph closer fhx dg dg dg denotes distance nodes know example closer expressible inflationary datalog theorem follow datalog founded semantics 
open problem closer expressible stratified datalog conjectured answer negative 
natural query object database shown expressible stratified datalog asks objects deeply equal define deep equality intuitively objects deeply equal distinguished pointers starting objects 
founded vs inflationary semantics expressiveness results involving rule languages states wellfounded inflationary semantics datalog expressive power gel 
surprising elegant result shows convergence procedural declarative semantics datalog furthermore semantics express known fixpoint queries 
bears witness class queries 
theorems precise inflationary founded semantics 
comparison done care sense comparing apples oranges inflationary semantics lives classical valued world wellfounded semantics uses valued logic 
theorem shows sense founded semantics simulated inflationary semantics 
inf denotes query defined datalog program inflationary semantics 
theorem datalog program 
exists datalog program edb edb 
contains relation sch relations ffl answer ffl 
instance edb inf ffl answer iff wf ffl ffl 
result concerns simulation inflationary founded semantics 
precisely positive portion founded semantics yields facts inflationary semantics 
theorem datalog program 
exists datalog program edb edb idb relation answer instance positive portion answer wf coincides 
theorem positive portion answer wf coincides 
wf guaranteed total may contain unknown facts 
remains open program constructed provides total answer positive portion coincides answer essentially open problem stated section 
connection fixpoint queries provided av av theorem inflationary datalog expresses precisely fixpoint queries 
proof inflationary datalog simulated fixpoint straightforward 
converse nontrivial 
simulation fixpoint inflationary datalog presents main difficulties related simulation control capabilities available fixpoint 
involves delaying firing rule completion fixpoint set rules 
intuitively hard checking fixpoint reached involves checking non existence existence valuation datalog naturally geared checking existence valuations 
solution difficulty illustrated example 
example datalog program computes complement transitive closure graph example illustrates technique delay firing rule computing complement fixpoint set rules computing transitive closure reached application transitivity rule yields new tuples 
monitor relations old old final 
old follows computation step 
relation old final identical old includes clause prevents firing reached iteration 
old old final differ iteration transitive closure reaches final value 
subsequent iteration program recognizes fixpoint reached fires rule computing complement relation ct program old old final ct old old final assumed empty 
second difficulty concerns keeping track iterations body computation loop 
loop change body simulation body may involve numerous relations behavior may overly application iteration 
overcome separate internal computation body external iteration illustrated example 
example binary relation schema 
consider fixpoint program change note query computes set nodes reachable cycle 
words nodes lengths paths leading bounded 
iteration achieved datalog program bad delay delay bad simply iterating yield desired result 
intuitively relations delay bad scratch computation single iteration loop re initialized effectively re perform computation subsequent iterations 
problem essentially create version iteration versions distinguished timestamps 
nodes serve timestamps 
timestamps marking iteration values newly introduced relation iteration gamma 
relations delay delay stamped delay derivation new tuples bad bad stamped respectively computed current iteration 
process continues new values introduced iteration 
full program union rules perform iteration rules perform iteration timestamp bad stamped delay stamped delay stamped bad stamped datalog method similar shown datalog expresses precisely queries av 
relationship datalog datalog clearly datalog subsumed datalog intuitively tempting believe datalog powerful datalog considering terminating queries 
far obvious 
consequence results av relationship fixpoint theorem inflationary founded datalog strictly expressive datalog iff ptime pspace 
open ptime pspace relationship inflationary wellfounded datalog datalog remains open 
strict inclusion conjectured true 
relative expressive power various rule languages summarized 
arrow indicates strict inclusion arrow indicates strict inclusion iff ptime pspace 
datalog founded semantics datalog inflationary datalog fixpoint stratified datalog semi positive datalog datalog relative expressive power datalog languages 
limitations expressive power languages discussed quite powerful certain shortcomings regard expressive power 
simple queries languages express 
prototypical example evenness query unary relation true false odd 
difficulty specific rule languages 
extends deterministic languages 
understand difficulty involved consider natural way compute query remove elements time keep binary counter 
elements conceptually deterministic language adheres data independence principle perform algorithm just described 
ways sacrifice data independence ii sacrifice determinism allowing nondeterministic construct pick arbitrary element set 
explore trade offs turn 
suspending data independence principle modeled access order elements database reasonable mathematical metaphor access additional symmetry breaking information provided internal storage 
intuitively strong connection order information internal storage nondeterminism 
query implemented information internal storage answer may depend information appear nondeterministic conceptual level 
impact order assumption databases ordered dramatic impact expressive power languages 
ordered databases schema contains special binary relation succ providing successor relation constants database 
assumption turns stratified datalog inflationary datalog datalog founded semantics equivalent express precisely db ptime 
furthermore apparently weaker semi positive datalog powerful languages 
due technicality concerning order need assume minimum maximum constants explicitly 
surprisingly constants computed order query succ computed semi positive programs 
theorem stratified datalog datalog founded semantics inflationary datalog equivalent ordered databases express exactly db ptime queries 
equivalent semi positive datalog ordered databases min max express exactly db ptime queries 
result semi positive datalog expresses db ptime ordered databases due pap 
result inflationary datalog expresses db ptime follows results av equivalence inflationary datalog fixpoint imm var showed fixpoint expresses db ptime ordered databases 
note order assumption known deterministic language expresses precisely db ptime queries 
existence language remains main open problems theory query languages 
conjectured language expressing db ptime exists 
characterizes power datalog ordered databases 
follows result av showing equivalence datalog result var showing expresses db pspace ordered databases 
theorem datalog expresses exactly db pspace queries ordered databases 
nondeterministic rule languages arguments favor nondeterministic languages practical theoretical 
nondeterminism various forms 
natural nondeterministic queries updates implementation deterministic languages contrived inefficient 
known applications artificial intelligence naturally lead nondeterminism expert systems shells kee ops rule components nondeterministically 
theoretical arguments nondeterminism involve primarily expressive power nondeterministic languages 
nondeterminism circumvents problems discussed associated deterministic languages 
discussed conjectured deterministic language expressing exactly queries computable polynomial time 
hand nondeterministic languages expressing exactly deterministic nondeterministic queries computable polynomial time 
see av survey nondeterminism logic languages inspired presentation 
nondeterministic datalog consider nondeterministic versions datalog languages 
recall procedural deterministic semantics languages result evaluating programs repeatedly firing rules parallel fixpoint 
nondeterministic semantics obtained firing instantiation rule time nondeterministic choice 
instance consider program deterministic semantics program removes cycles length 
nondeterministic semantics program computes possible orientations graph pair edges edges removed 
define syntax nondeterministic version datalog denoted av 
difference deterministic version heads rules may contain literals equality bodies 
seen features redundant deterministic semantics 
definition datalog program finite set rules form literal form literal form variables constants 
required variable occurring head rule occur positively bound body 
formally define nondeterministic semantics introduce notion nondeterministic immediate successor set facts rule 
datalog rule 
set facts ground instance literal body true ii head consistent iii variable constant occurring instance obtained deleting facts head inserting facts head called immediate successor condition ii ground instance rule considered head contains ground literal negation 
definition datalog program 
effect relation sets facts defined follows eff iff exists sequence immediate successor ii immediate successor rule language datalog specialization datalog obtained disallowing negative literals heads rules negation occur bodies rules 
expressive power results expressive power datalog datalog discussed earlier significant result involves expressibility ndb ptime 
consider expressive power datalog theorem av datalog expresses exactly ndb pspace 
consider expressive power datalog easy see transformation ndb ptime 
turns simple ndb ptime queries expressed datalog show show datalog augmented increase expressive power ndb ptime 
strict inclusion ndb ptime shown example av 
example fp ab shown datalog program computes gamma 
precise characterization power datalog open 
note datalog expresses exactly ndb ptime presence order 
seen example simple transformations datalog compute 
look origin weakness show corrected 
note datalog provide sufficient control capability simulate composition programs 
gamma obtained composition mappings defined rules answer weak control capability datalog impossible programs language simulate explicit control necessary compute ndb ptime transformations 
note case datalog control needed provided deletions 
example query example computed datalog program answer answer constructs add datalog essentially provide sufficient control simulate composition inflationary manner 
consider alternative constructs 
construct allows inconsistency symbol appear heads rules 
resulting language denoted datalog 
idea symbol derived computation particular computation abandoned 
second construct universal quantification bodies rules yields language datalog 
datalog datalog 
languages av 
datalog language datalog extended symbol occur literal head rules 
pair effect datalog program iff obtained computation derived 
datalog language datalog extended allow rules form xb sequence variables occurring body rule 
vector variables occurring valuation rule fired valuation extension variables variables active domain vb vb holds 
illustrate languages show compute query example datalog datalog programs 
example mapping gamma computed datalog program answer yp datalog program computing query proj done proj done proj done proj proj answer done proj proj intuitively datalog check stage completed proceeding allows simulating composition 
datalog detected error leads derivation 
shows fact constructs provide sufficient power bridge gap datalog ndb ptime 
theorem av query equivalent ffl ndb ptime ffl defined datalog program ffl defined datalog program 
choice operator way provide nondeterminism rule languages provided choice operator kn 
construct included language ldl implementation datalog nt 
variations choice operator connection stable models datalog programs studied sz 
expressive power choice operator context datalog investigated cgp extension datalog variation choice operator introduced cgp 
particular variation called dynamic choice 
datalog programs extended allowing atoms form choice rules bodies disjoint sets variables occurring regular atoms rule 
choice atoms appear rule 
language obtained called datalog choice 
semantics 
choice atoms render immediate consequence operator datalog choice program nondeterministic 
application subset applicable valuations chosen rule containing occurrence choice functional dependency holds 
instantiation variables chosen instantiation variables 
nondeterministic choices operated application occurrence choose atom extend choices previous applications atom 
choose global nature 
negation datalog choice simulated seen example 
example datalog choice program computes complement nonempty relation respect universal relation arity cgp tag tag comp comp tag choose comp role choose program simple 
applied associates tag 
second application chooses tag tuples tuples tagged previous application choose tuples tagged precisely complement 
main result expressive power dynamic choice theorem cgp datalog choice expresses exactly ndb ptime 
connections determinism recall motivations considering nondeterministic languages ability express deterministic transformations 
section consider ability various nondeterministic languages express deterministic transformations 
consider deterministic transformations definable considering possible certain answers nondeterministic transformation spirit queries databases incomplete information 
results asv 
notion functional fragment expressed language defined 
definition functional fragment nondeterministic language set deterministic transformations effects programs language 
functional fragment language denoted funct 
previous section characterized nondeterministic transformations expressible various languages 
results characterize functional fragments expressible languages 
theorem funct datalog funct datalog db ptime 
funct datalog db pspace 
alternative way obtaining deterministic transformations nondeterministic programs suggested il incomplete information 
natural connection incomplete information nondeterminism 
noted ag incomplete information seen resulting incompletely specified nondeterministic updates 
notions possible certain answers il suggest definition definition nondeterministic program image input possibility semantics denoted poss certainty semantics denoted cert defined poss fj eff cert fj eff deterministic transformation expressed program possibility semantics denoted poss certainty semantics cert 
language poss lg cert lg poss cert semantics yield significant power theorem poss datalog poss datalog db np 
cert datalog cert datalog db np 
cert datalog poss datalog db pspace 
note datalog poss cert semantics yield additional power 
particular semantics simulated functional fragment datalog complete rule languages languages considered far express queries db pspace 
intuitively program uses fixed number relations fixed arity filled course computation tuples elements input 
programs build amount space polynomial number elements input 
suppose wish complete language language expressing queries 
way break polynomial space barrier allow programs invent new values course computation 
computational justification useful object oriented databases creation new object identifiers useful common feature 
exhibit extension datalog complete traditional sense expresses deterministic queries outputs relations elements input 
extension uses new values course computation answer 
informally describe language denoted datalog new syntax datalog variables appear body rule may appear head 
inflationary semantics language similar datalog difference consists variables occur heads rules outside current active domain resulting invention new values 
choice particular new value nondeterministic 
source nondeterminism 
final result contains values input query defined program deterministic 
furthermore datalog new complete theorem av query datalog new program expresses 
note datalog new programs express queries traditional sense results may contain newly invented values 
transformations useful contexts object oriented databases 
notion completeness naturally extended queries contain new values result ak 
expect datalog new complete respect extended notion completeness 
turns case 
query expressible datalog new exhibited example 
example ak query input schema fsg unary output binary 
defined follows input fa bg fh bi ai bi aig new elements 
query expressible datalog new fa bg gamma gamma gamma psi hj gamma gamma gamma phi phi phi phi phi phi oe query expressible new elegant necessary condition query computable datalog new ap 
condition show prove query example expressible datalog new condition involves inputoutput pairs datalog new programs 
input output pair hi ji condition requires simple connection automorphism group instance aut denote set automorphisms pair instances aut hk denotes bijections adom automorphisms theorem query expressible datalog new inputoutput pair hi ji exists mapping aut aut hi ji aut coincide ii ffi ffi iii id id hi ji id denotes identity mapping note necessary sufficient condition extension datalog new called iql provides complex values including sets 
iql powerful datalog new mapping called extension homomorphism aut aut hi ji 
see example usefulness condition consider query example 
show expressible datalog new follows 
hi ji input output pair 
proof contradiction 
suppose datalog new query produces input theorem extension homomorphism aut aut hi ji 
automorphism exchanging note gamma ffi id consider 
clearly suppose case similar 
clearly consider ffi 
hand ffi ffi hand ffi id id hi ji contradiction expressible datalog new possible obtain language expressing queries new values results adding datalog new choose operator allows selection nondeterministically determinate manner object set objects isomorphic ak highly complex construct requires ability check isomorphism graphs 
tractable construct yields completeness exhibited dv 
construct shown global nature applies entire database 
search simpler local constructs yield language complete value invention active area research 
described variety rule languages semantics main paradigms procedural production systems approach declarative logic programming approach 
paradigms philosophically different 
procedural approach provides semantics extremely simple describe 
semantics purely computational 
contrast declarative semantics attempt model natural reasoning process 
particular consistency reasoning process required fact infer negation happen procedural semantics 
declarative approach attempts describe solution model program satisfying certain desirable properties minimality 
draw results 
seen declarative procedural semantics datalog converge terms expressive power fixpoint queries 
comparison procedural declarative paradigms necessarily subjective preference style 
attempt risky 
comparison paragraphs 
question ask declarative semantics extent various semantics proposed truly declarative 
minimum model semantics datalog purely get 
languages datalog 
negation lack unique minimal model leads need specify intended model possible candidates 
stratified semantics natural procedural 
venture stratified semantics fact best understood procedural terms compute relation negation model theoretic terms preferred models discussed 
stratified semantics criteria selecting intended model increasingly contrived 
furthermore common justification chosen criterion captures fictitious programmer natural reasoning process rests shallow ground 
procedural semantics simple understand mentioned yield solution easily justifiable model theoretic terms fact solution model program 
despite simplicity computational semantics larger programs hard understand effect sensitive timing see example 
way quite appealing provided rule algebras ra ra 
algebras complicated programs build simple programs building blocks 
breaks complexity program allows flexible specification mechanism 
furthermore declarative semantics easily specified rule algebras stratified semantics expressed composition strata stratification founded semantics expressed program mimicking alternating fixpoint computation semantics 
final test various semantics rest programmers 
respect procedural approach leading time production systems expert systems shells procedural rule component deductive database systems limited prototypes see ru survey deductive database implementations 
active databases incipient stage adopted procedural approach rule semantics 
terms expressiveness pointed limitations expressive power deterministic languages considered 
nondeterministic languages circumvent limitations 
particular exhibited languages express ndb ptime 
nondeterminism provided languages allows expressing nondeterministic queries may useful additionally allows expressing deterministic queries 
point interesting trade expressiveness determinism intimately related trade expressiveness data independence principle 
lastly languages expressing classical queries exhibited 
expressive power due ability invent new values course computation 
apart computational reasons feature useful object oriented languages object creation 
discussed extended notion completeness takes account queries new values answer pointed difficulties obtaining languages complete respect extended class queries 
limited languages operate primarily relational framework 
extensions left survey 
mention particularly active areas ffl deductive object oriented languages 
languages object oriented features added rule languages 
typical example language iql ak 
different approach rules datalog negation provide semantics number variations schemas methods 
connection methods rule languages considered dv 
dood deductive object oriented databases conference provides forum research area 
ffl active databases centered rule languages 
active databases generally support automatic triggering updates response user requested system generated updates 
active database systems coh md han wf paradigm rules specify actions taken manner reminiscent expert systems 
active databases techniques shown useful constraint maintenance mor cw ctf incremental update materialized views cw database security hold promise providing new solutions view derived data update problem chm issues database interoperability cw cha wie 
see wc survey main active database systems 
ffl constraint logic programming programming constraints studied time topic areas ranging linear programming ai logic programming 
declarative spirit constraint programming database query languages leads natural marriage combination paradigms seriously studied kkr 
probably consequence success constraints field logic programming see jl lel coh surveys 
constraint database languages includes gs 
rule paradigm demonstrated flexibility vitality 
continue provide useful tool computer scientist foreseeable 
abw apt blair walker 
theory declarative knowledge 
minker editor foundations deductive databases logic programming pages 
morgan kaufmann los altos ca 
ac afrati cosmadakis 
expressiveness restricted recursive queries 
proc 
acm sigact symp 
theory computing pages 
afrati cosmadakis yannakakis 
datalog vs polynomial time 
proc 
acm symp 
principles database systems pages 
ag abiteboul grahne 
update semantics incomplete databases 
proc 
intl 
conf 
large data bases pages 
ahv abiteboul hull vianu 
foundations databases 
addisonwesley reading mass 
ak abiteboul kanellakis 
object identity query language primitive 
proc 
acm sigmod symp 
management data pages 
appear acm 
abiteboul lausen waller 
methods rules 
proc 
acm sigmod symp 
management data pages 
ap andries paredaens 
language generic graph transformations 
proc 
int 
workshop wg pages 
springer verlag 
asv abiteboul simon vianu 
non deterministic languages express deterministic transformations 
proc 
acm symp 
principles database systems pages 
au aho ullman 
universality data retrieval languages 
proc 
acm symp 
principles programming languages pages 
av abiteboul vianu 
procedural declarative database update languages 
proc 
acm symp 
principles database systems pages 
av abiteboul vianu 
datalog extensions database queries updates 
journal computer system sciences 
av abiteboul vianu 
generic computation complexity 
proc 
acm sigact symp 
theory computing pages 
av abiteboul vianu 
non determinism logic languages 
annals math 
artif 
int 
abiteboul van den bussche 
deep equality revisited 
proceedings th international conference deductive object oriented databases lecture notes computer science 
springer verlag 
appear 
ave apt van emden 
contributions theory logic programming 
acm 
bf bidoit froidevaux 
minimalism subsumes default logic circumscription 
proc 
ieee conf 
logic computer science pages 
bf froidevaux 
general logic databases programs default logic semantics stratification 
technical report lri universit de orsay 
appear information computation 
bid bidoit 
bases de donn ees pr esentation de datalog 
armand colin paris 
bid bidoit 
negation rule database languages survey 
theoretical computer science 
br bancilhon ramakrishnan 
amateur recursive query processing strategies 
stonebraker editor readings database systems pages 
morgan kaufmann 
earlier version appears proc 
acm sigmod conf 
management data pp 

ceri tanca zicari 
integrating object oriented data modeling rule programming paradigm 
proc 
acm sigmod symp 
management data pages 
cgp pedreschi 
datalog non deterministic choice computes ndb ptime 
proc 
intl 
conf 
deductive objectoriented databases dood 
cgt ceri gottlob tanca 
logic programming databases 
springerverlag berlin heidelberg 
ch chandra harel 
computable queries relational data bases 
journal computer system sciences 
ch chandra harel 
structure complexity relational queries 
journal computer system sciences 
ch chandra harel 
horn clause queries generalizations 
logic programming 
cha chandra 
programming primitives database languages 
proc 
acm symp 
principles programming languages pages 
cha 
chang 
incremental update propagation object databases 
phd thesis university southern los angeles california 
chm 
chen hull mcleod 
local ambiguity derived data update 
fourth intl 
workshop research issues data engineering active database systems pages 
cod codd 
relational model data large shared data banks 
comm 
acm 
coh cohen 
programming specification annotation 
proc 
aaai 
coh cohen 
constraint logic programming languages 
comm 
acm volume pages 
ctf casanova 
enforcing inclusion dependencies referential integrity 
proc 
intl 
conf 
large data bases pages 
cw ceri widom 
deriving production rules constraint maintenance 
proc 
intl 
conf 
large data bases 
cw ceri widom 
deriving production rules incremental view maintenance 
proc 
intl 
conf 
large data bases pages 
cw ceri widom 
managing semantic heterogeneity production rules persistent queues 
proc 
intl 
conf 
large data bases 
dal 
skolem normal forms concerning fixpoint 
borger editor computation theory logic volume pages 
springer verlag lecture notes computer science berlin new york 
van den bussche van gucht andries gyssens 
completeness object creating query languages 
ieee conf 
foundations computer science pages 
dv vianu 
power methods parallel semantics 
vldb pages 
dv vianu 
database method schemas object creation 
proc 
acm symp 
principles database systems pages 
forgy 
ops user manual 
technical report cmu cs carnegie mellon university 
gel van gelder 
negation failure tight derivations general logic programs 
ieee symp 
logic programming pages 
gel van gelder 
alternating fixpoint logic programs negation 
proc 
acm symp 
principles database systems pages 
gl gelfond lifschitz 
stable model semantics logic programs 
intl 
conf 
logic programming pages 
pedreschi sacc zaniolo 
nondeterminism deductive databases 
proc 
intl 
conf 
deductive object oriented databases dood pages los altos ca 
springer verlag lecture notes computer science 
grs van gelder ross schlipf 
founded semantics general logic programs 
proc 
acm symp 
principles database systems pages 
grs van gelder ross schlipf 
founded semantics general logic programs 
acm 
gs grumbach su 
finitely representable databases 
proc 
acm symp 
principles database systems 
han hanson 
initial report design ariel dbms integrated production rule system 
sigmod record pages 
hy hull yap 
format model theory database organization 
journal acm 
il imielinski 
relational model data cylindric algebras 
journal computer system sciences 
imm immerman 
relational queries computable polynomial time 
inf 
control 
imielinski naqvi 
explicit control logic programs rule algebra 
proc 
acm symp 
principles database systems pages 
jl jaffar lassez 
constraint logic programming 
proc 
acm symp 
principles programming languages pages 
kan kanellakis 
elements relational database theory 
van leeuwen editor handbook theoretical computer science pages 
elsevier 
kkr kanellakis kuper revesz 
constraint query languages 
proc 
th acm symp 
principles database systems pages nashville 
kn krishnamurthy naqvi 
nondeterministic choice datalog 
th int 
conf 
data knowledge bases pages los altos ca 
morgan kaufmann 
kol kolaitis 
expressive power stratified logic programs 
information computation 
kon konolige 
relation default autoepistemic logic 
artificial intelligence 
kp kolaitis papadimitriou 
negation fixpoint 
proc 
acm symp 
principles database systems pages 
kuper 
aggregation constraint databases 
proc 
workshop principles practice constraint programming 
kv kolaitis vardi 
expressive power datalog tools case study 
proc 
acm symp 
principles database systems pages 
lel 
constraint programming languages 
addison wesley 
lif lifschitz 
declarative semantics logic programs negation 
minker editor foundations deductive databases logic programming pages 
morgan kaufmann los altos ca 
lm lakshmanan mendelzon 
inductive pebble games inductive power datalog 
proc 
acm symp 
principles database systems pages 
md mccarthy dayal 
architecture active database management system 
proc 
acm sigmod symp 
management data pages 
moo moore 
semantics considerations non monotonic logic 
artificial intelligence 
mor morgenstern 
active paradigm enhanced computing environments 
proc 
intl 
conf 
large data bases pages 
mos moschovakis 
elementary induction structures 
north holland 
mw maier warren 
computing logic logic programming prolog 
benjamin cummings menlo park ca 
nt naqvi tsur 
language data knowledge bases 
computer science press rockville maryland 
pap papadimitriou 
note expressive power prolog 
bulletin eatcs 
prz przymusinski 
logic program natural stratification iterated fixpoint model 
proc 
acm symp 
principles database systems pages 
prz przymusinski 
founded semantics coincides valued stable semantics 
fundamenta informaticae xiii 
rei reiter 
logic default reasoning 
artificial intelligence 
ru ramakrishnan ullman 
survey deductive database systems 
logic programming pages 
shm shmueli 
decidability expressiveness aspects logic queries 
proc 
acm symp 
principles database systems pages 
stonebraker goh potamianos 
rules procedures caching views data base systems 
proc 
acm sigmod symp 
management data pages 
simon de 
implementing high level active rules top relational dbms 
proc 
intl 
conf 
large data bases pages 
sz sacc zaniolo 
stable models non determinism logic programs negation 
proc 
acm symp 
principles database systems pages 
ull ullman 
principles database knowledge base systems volume computer science press 
ull ullman 
bottom beats top datalog 
proc 
acm symp 
principles database systems pages 
ull ullman 
principles database knowledge base systems volume ii new technologies 
computer science press 
var vardi 
complexity relational query languages 
proc 
acm sigact symp 
theory computing pages 
van emden kowalski 
semantics predicate logic programming language 
acm 
wc widom ceri 
active database systems triggers rules advanced database processing 
morgan kaufmann san francisco california appear 
wf widom finkelstein 
set oriented production rules relational database systems 
proc 
acm sigmod symp 
management data pages 
wie wiederhold 
mediators architecture information systems 
ieee computer march 

