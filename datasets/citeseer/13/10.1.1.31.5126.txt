program structure tree computing control regions linear time richard johnson david pearson keshav pingali cs cornell edu pearson cs cornell edu pingali cs cornell edu department computer science cornell university ithaca ny describe program structure tree pst hierarchical representation program structure single entry single exit sese regions control flow graph 
give linear time algorithm finding sese regions building pst arbitrary control flow graphs including irreducible ones 
establish connection sese regions control dependence equivalence classes show algorithm find control regions linear time 
discuss pst 
controlflow algorithms construction static single assignment form speeded applying algorithms divide andconquer style sese region 
pst speed data flow analysis exploiting sparsity 
experimental results perfect club spec benchmarks confirm pst approach finds exploits program structure 
contributions 
section introduce program structure tree pst hierarchical representation control structure program 
nodes tree represent single entry single exit sese regions program edges represent nesting regions 
pst defined control flow graphs including irreducible graphs 
section give algorithm finding sese regions 
algorithm works reducing problem research supported presidential award ccr nsf ccr onr hewlett packard 
david pearson supported fannie john hertz fellowship 
determining simple graph property call cycle equivalence edges cycle equivalent strongly connected component iff cycles contains edges edge 
give fast linear time algorithm depth search solving cycle equivalence problem finding sese regions linear time 
algorithm runs fast practice example empirical results show runs faster lengauer tarjan algorithm finding dominators lt 
algorithm build pst arbitrary flow graphs time 
section give experimental results characterize structure pst standard benchmarks perfect club spec linpack programs 
expect pst usually broad shallow roughly sese regions nesting depth 
section apply cycle equivalence algorithm finding control regions time 
nodes said control region set control dependences fow 
previous algorithms problem restricted reducible flow graphs bal en complexity cfs 
information useful problems instruction scheduling pipelined machines gs linear time algorithm region determination wide interest 
pst tool enhance performance program analysis algorithms 
sese region control flow graph right program analysis algorithm applied directly 
partial results sese region combined pst give result entire procedure 
provided combining overly expensive conquer style applying analysis algorithms advantageous pst natural data structure exploiting global structure nesting local structure sese region sparsity 
points section showing pst problems conversion ssa form data flow analysis dominator computation 
discuss possible applications pst parallel incremental program analysis 
single entry single exit regions program structure tree literature term single entry single exit region consistently appear related constructs aliased term kas val tv gps 
section formal definition single entry single exit regions definition motivated part considerations control dependence precise section 
show single entry single exit regions organized tree called program structure tree pst 
shows control flow graph single entry single exit regions marked 
note sese region enclosed pair control flow graph edges called entry exit edges respectively 
sese regions nested sequentially composed disjoint 
regions sequentially composed exit edge region entry edge region 
shows pst control flow graph 
pst captures nesting relationship sese regions chains sequentially composed sese regions regions grouped pst 
defining single entry single exit regions recall standard definitions 
definition control flow graph graph distinguished nodes start node occurs path start 
start predecessors successors 
definition node said dominate node directed graph path start includes node said postdominate node path includes convention node dominates postdominates 
notions dominance postdominance extended edges obvious way 
single entry single exit regions defined follows 
definition sese region graph ordered edge pair distinct control flow edges 
dominates 
postdominates 
cycle contains vice versa 
refer entry edge exit edge sese region 
condition ensures path start region passes region entry edge second condition ensures path inside region passes region exit edge conditions necessary sufficient characterize sese regions backedges alter dominance postdominance relationships conditions prohibit backedges entering exiting region 
third condition encodes constraints path inside region point passes path point point inside region passes define notion cycle equivalence 
definition edges said edge cycle equivalent iff cycle containing contains vice versa 
similarly nodes said node cycle equivalent iff cycle containing nodes contains 
sese region sese region sese region 
graph edges sese regions example edge pair linear sequence nodes encloses sese region 
complete enumeration sese regions graph 
edge graph want find smallest sese regions exist entry edge exit edge 
call canonical sese regions associated express formally follows 
definition sese region canonical provided ffl dominates sese region ffl postdominates sese region 
code region points single entry single exit ignore trivial regions focus sese regions block level cfg code sequences coalesced basic blocks 
edge block level cfg control operator switch merge basic block control operators 
program structure tree consider nesting structure canonical sese regions organization program structure tree 
definition node graph contained sese region dominates postdominates intuitively node graph 
definition extended obvious way containment sese regions 
theorem describes canonical sese regions graph related 
theorem canonical sese regions graph statements applies 

node disjoint 

contained vice versa 
start control flow graph sese regions program structure tree control flow graph program structure tree words canonical sese regions partial overlap regions nodes common nested tandem 
obvious case structured programs 
general control flow graphs required result may proved follows 
proof suppose distinct canonical sese regions contain node dominate ordered dominance 
loss generality assume dominates similarly postdominate ordered postdominance 
postdominates contained 
postdominates cases consider case derive contradiction 

edge 
note edge dominate postdominate node 
postdominates dominates case happen 

distinct dominates dominates dominates free path start path contain free path contradicts fact postdominates postdominates similarly postdominates free path start contradicts fact dominates cycle passes contains path path contain dominates dominates cycle passes similar argument shows cycle contain sese region postdominates follows canonical contradiction 
notice property may true sese regions canonical 

distinct dominate free path start means postdominate path start passes postdominates violating assumption dominates postdominates postdominates dominates edge dominate postdominate node contradiction 
regions disjoint regions nested regions sequentially composed 
follows theorem sese regions organized tree 
node tree represents sese region 
parent region closest containing region children region regions immediately contained 
call program structure tree pst 
show pst determined time 
building pst linear time algorithm steps find sese regions second organize canonical sese regions pst 
cycle equivalence adequate find sese regions convenient reduce conditions sese regions single property cycle equivalence related graph 
theorem control flow graph edges enclose single entry single exit region cycle equivalent graph formed adding edge start 
proof suppose enclose sese region control flow graph definition cycle equivalent show cycle equivalent strongly connected graph formed adding edge start consider cycle cycle formed path start backedge start 
cycle contains contains postdominates similarly cycle contains contains dominates cycle equivalent suppose cycle equivalent cycle equivalent cycle cycle consider path start containing path exists edge occurs path start cycle equivalent loss generality assume occurs path 
free path yield cycle containing portion start free path start 
postdominates portion occurrence free 
free path start yield cycle containing dominates directed undirected graphs simplification possible surprising result cycle equivalence strongly connected graph remains edge directions removed 
result allows find cycle equivalence classes undirected multigraph corresponding strongly connected graph 
advantage working undirected graphs algorithms depth search simplified undirected graphs cross edges forward edges eliminated 
theorem strongly connected component undirected removing edge directions 
edges cycle equivalent corresponding undirected edges cycle equivalent proof show edges cycle equivalent corresponding edges cycle equivalent loss generality assume cycle containing edge cycle associated direction adjacent edges cycle direction opposing directions adjacent edges opposing directions say direction change node edges 
choose cycle containing cycle minimum number direction changes 
direction changes corresponding edges form directed cycle containing minimum non zero number direction changes 
traversing direction nodes edge direction changes changes back 
strongly connected exists directed path corresponding free undirected cycle path edge directions shown undirected path 
suppose occur consider cycle obtained replacing portion path resulting cycle contains fewer direction changes contradicting assumption minimum number direction changes 
may occur times occurrence path path occurrence corresponds directed free cycle similarly occurrence path occurrence path forms free cycle having fewer direction changes occurrence path corresponds directed free cycle suppose cycle equivalent loss generality directed cycle containing corresponding undirected cycle contains cycle equivalent slow algorithm cycle equivalence strongly connected graph undirected multigraph formed removing edge directions 
connected depth traversal yield depth spanning tree edges divided set tree edges set backedges 
notice cycle contain backedge 
observation recast problem cycle equivalence terms sets backedges sets cycles 
definition depth traversal bracket tree edge backedge connecting descendant ancestor consider edges cycle equivalent 
backedges cycle equivalent cycle formed backedge tree path connecting endpoints contains backedges 
hand tree edge backedge tree edges may cycle equivalent 
theorems establish conditions detecting equivalences 
theorem backedge tree edge cycle equivalent bracket proof suppose cycle equivalent tree path connecting endpoints forms cycle bracket backedge bracket backedge tree path connecting endpoints form cycle containing suppose bracket backedge connecting descendant ancestor cycle contain backedge cycle contain cycle comprised free path connecting endpoints 
path contain free path descendant pass lemma needed prove tree edges cycle equivalent condition equivalence proof follow 
lemma depth spanning tree tree edges bracket common ordered ancestor relation tree 
proof contradiction suppose ordered ancestor relation 
descendant descendant vice versa 
bracket connects descendant say node ancestor descendant bracket theorem tree edges cycle equivalent set brackets depth spanning tree proof show tree edges set brackets depth spanning tree cycle equivalent 
suppose edge bracket bracket definition brackets occur tree path connecting endpoints tree path forms cycle containing set brackets lemma asserts ordered ancestor relation depth spanning tree 
loss generality assume ancestor cycle contain backedge connecting descendant ancestor backedge cycle note nodes cycle descendants bracket bracket tree path lower endpoint cycle path contain edge path bypasses ancestor descendant section variations high low refer relative positions depth search tree 
higher locations closer root smaller dfs numbers 
descendants bracket bracket contradiction 
proof cycle containing contains similar omitted 
undirected depth traversal compute set brackets tree edge 
retreating node form union bracket sets node children set backedges node ancestor minus set backedges descendant node result bracket set tree edge current node 
intuitively set brackets tree edge name edge cycle equivalence class comparing sets find cycle equivalent edges 
building comparing sets expensive algorithm inefficient 
section describe compact naming scheme bracket sets allows avoid building comparing entire sets 
compact names sets brackets consider graph shown depthfirst spanning tree simple chain backedges correspond structured loops disjoint nested 
graphs easy see set brackets edge uniquely named innermost bracket edge entire bracket set tree edge needed 
simply visit nodes reverse depth order maintain stack brackets 
node delete brackets connect descendant current node add brackets connecting node ancestor 
backedges disjoint properly nested deletions insertions occur top bracket stack 
retreating node tree edge parent labeled name topmost bracket bracket stack traversal tree edges bracket label belong equivalence class 
tree edge labeled topmost element bracket stack cycle equivalent edges label 
consider slightly general case linear spanning trees backedges properly nested example shown 
difficulty reverse depth traversal brackets deleted stack order 
note edges set brackets topmost element bracket stack edges allow arbitrary deletion implement bracket stack doubly linked list 
brackets added top stack may deleted position stack 
way added bracket bracket lower endpoint highest tree top stack 
addition keep track size bracket stack 
easy see pair topmost bracket set size uniquely labels equivalence class example edges structured loops unstructured loops general tree node compact names bracket sets placed different equivalence classes edges placed equivalence class 
wemust handle general depth spanning trees example shown 
encounter node child bracket sets children merged 
unfortunately notion innermost bracket longer defined 
example node clear added backedge edge edge 
resolution difficulty rests observation subtrees node contain edges cycle equivalent ancestor edge subtree brackets originating subtree ancestor having brackets multiple subtrees cycle equivalent descendant example edges cycle equivalent edge edges cycle equivalent edges solution add additional capping backedge need merge bracket sets 
backedge topmost bracket set children bracket sets concatenated arbitrary order 
new bracket originates node children merged extends highest node brackets come branches 
add new backedge requires keeping track node tree highest node reached backedge point 
destination new backedge node second highest node children highest backedges 
examination bracket sets highest backedge necessarily related bracket set highest originating full search bracket set necessary 
fortunately simply compute information independently constant time node 
new backedge shown dotted edge 
show backedge added pair topmost bracket set size identifies equivalence class 
lemma capping backedges added algorithm alter cycle equivalence relation tree edges 
proof theorem tree edges cycle equivalent set brackets 
consider tree edges set brackets adding capping backedges set brackets adding capping backedges 
show share set new brackets added 
example illustration 
suppose edge bracketed capping backedge 
origin backedge node children highest reaching branch backedge point high tree second highest reaching branch backedge consider edge original set brackets occur 
edge bracket second highest reaching subtree tree path bracket highest reaching subtree occur tree path intersection paths tree path new bracket bracket theorem compact bracket set names uniquely identify bracket sets 
proof need prove edges compact name cycle equivalent 
direction reasonably easy edges cycle equivalent receive compact name 
theorem cycle equivalent edges bracket sets 
lemma backedges added depth traversal affect cycle equivalence relation 
bracket sets computed algorithm size top bracket 
cycle equivalent edges receive compact name 
complete proof need establish edges cycle equivalent receive compact name 
edges cycle equivalent 
theorem different bracket sets including lemma new backedges added algorithm 
sets different size algorithm clearly gives different compact names suppose bracket sets size 
lemma ordered ancestor relation brackets common receive different compact names 
assume loss generality ancestor sets size identical bracket shared bracket shared node descendant ancestor edge linked bracket list ahead top bracket 
top bracket higher 
bracket include different top bracket receive different compact name assume ancestor case paths diverge point 
call node multiple children backedge added point backedges branches 
point added backedge bracket higher backedge top bracket top bracket point backedges branch ended top bracket ended bracket case different top brackets different compact names 
fast algorithm cycle equivalence put observations fast algorithm data type called maintain lists brackets 
operations defined data type 
create empty structure 
size bl integer number elements structure 
push bl bracket push top bl 
top bl bracket topmost bracket bl 
delete bl bracket delete bl 
concat bl bl concatenate bl bl data type implemented record consisting doubly linked list brackets pointer cell list integer representing size list 
doubly linked list permits deletions list 
pointer cell list permits fast concatenation lists place update cell 
leave reader verify operations data type implemented constant time concrete representation 
subtlety delete 
edge pushed bracket list edge data structure updated pointer bracket list cell containing edge permits constant time deletion edge bracket list 
integers identify cycle equivalence classes 
procedure new class returns new integer time called 
implemented static variable initialized zero incremented returned time procedure called 
assume node structure fields ffl depth search number node 
ffl pointer node 
ffl hi destination node closest root edge originating descendant node edge data structure saves equivalence class number size bracket list edge topmost bracket bracket list 
example edge topmost bracket edges equivalence class number size bracket list previously topmost bracket edge 
contrast different equivalence class numbers 
access values saved brackets edge structure fields ffl class index edge cycle equivalence class 
ffl size bracket set topmost edge bracket set 
ffl equivalence class number tree edge topmost bracket 
edge node data types implemented records obvious way 
gives pseudocode computing edge cycle equivalence classes efficiently 
easy see depth traversal undirected graph amount performed node constant amount proportional number edges incident node 
algorithm requires time number edges control flow graph 
building program structure tree cycle equivalent edges totally ordered control flow graph dominance postdominance adjacent pair edges order encloses canonical sese region 
find canonical regions compute cycle equivalence classes edges time algorithm 
depth traversal original control flow graph visit edges cycle equivalence class order traversal entry exit edges canonical sese regions identified 
canonical regions organized program structure tree region parent closest containing procedure perform undirected depth search node reverse depth order compute hi hi min ft backedge hi min fc hi child hi min fhi hi child having hi hi hi min fc hi child compute create child concat endfor capping backedge descendant delete endfor backedge descendant delete class undefined class new class endif endfor backedge ancestor push endfor hi hi create capping backedge node hi push endif determine class edge parent root dfs tree tree edge parent top size size new class endif class check equivalence class class endif endif endfor cycle equivalence algorithm min returns infinity set empty 
code roughly lines long may obtained authors 
region children regions immediately contained region 
discover nesting relationship depth traversal determines canonical regions 
depth search keeps track entered region current region 
region entered set parent current region update current region region just entered 
region exited current region set exited region parent 
theorem follows pushing popping follows stack discipline 
topmost sese region stack dfs reaches entry node sese region name smallest sese region containing depth traversal complete program structure tree built 
empirical properties pst empirical evidence characterize properties pst 
gathered data procedures taken perfect club benchmark suite spec benchmark suite dennis gannon sigma fortran front modified extensively cornell back design 
programs listed 
suite program lines procedures perfect aps lgs tfs tis spec dnasa doduc fpppp matrix tomcatv linpack total presents distribution region depth 
psts regions 
maximum depth average depth 
agrees conventional wisdom typical programs contain deeply nested control structures 
shows cumulative number regions level see percent regions nesting level 
show procedures grow larger pst grows size broader deeper 
plots pst size number regions versus procedure size see number regions grow procedure size 
indicates larger procedures larger opportunities exploiting structure desired 
shows nesting largest procedures omitted figures avoid compressing horizontal axis 
psts follow general trend 
depth program structure tree number regions depth average depth depth program structure tree percentage regions depth number regions depth psts cumulative regions depth psts analysis pst depth procedure size program structure tree size regions procedure size maximum depth pst size versus procedure size average pst depth versus procedure size pst size depth procedure size case loop dag block weighted proportion regions kind depth structures independent procedure size expected 
sese regions detected identify kind structure region 
simple pattern matching pass identify region basic block case construct loop dag cyclic unstructured region 
shows proportion kind region region weighted number nested maximal sese regions 
example weight contains nested maximal regions 
weighting gives measure region size blocks unit weight 
interesting simple heuristic finds considerable structure 
fact procedures completely structured find considerable structure remaining procedures 
empirical results standard benchmarks show real programs contain abundance sese structure exposed quickly algorithm 
typical psts flat broad narrow deep 
show algorithms pst particular solve variety compilation problems 
control regions linear time application results computation control regions 
application pst reworking cycle equivalence algorithm motivates particular definition single entry single exit regions 
notion control dependence plays important role optimization parallelization 
intuitively node control dependent node determines executed 
control dependence defined formally follows 
definition node control dependent fow node direction path edge 
postdominates nodes 
distinct postdominate control dependence edge defined analogously 
nodes edges having control dependences control dependence equivalence class control region 
ferrante ottenstein warren posed problem partitioning control flow graph nodes control regions fow 
algorithm hashing compute control regions expected time worst case time ne space 
results improved cytron ferrante sarkar cfs gave en time space algorithm finding control regions 
briefly algorithm works placing nodes single equivalence class repeatedly refining equivalence relation considering effect control dependence existing partition 
worst case algorithm performs control dependences 
problem approach control dependence equivalence defined terms control dependence relation en size worst case 
ball bal recognized need characterize control dependence equivalences control dependence developed linear time algorithm computing control dependence equivalences 
algorithm works reducible graphs requires computation dominators 
podgurski lineartime algorithm forward control dependence equivalence special case general control dependence equivalence pod 
results section design algorithm determine control regions arbitrary flow graphs runs faster just dominator computation step previous algorithms problem 
key technical result section control dependence equivalence reduced cycle equivalence 
theorem strongly connected component constructed adding edge start control flow graph nodes set control dependences iff cycle equivalent leave reader verify theorem example shown 
proof theorem straightforward tedious 
edge cycle equivalence relation node cycle equivalence preserved edge directions removed graph 
fortunately simple construction lets reduce problem finding node cycle equivalence directed graphs problem edge cycle equivalence related directed graph 
definition directed graph define transformation node pair nodes connected edge call edge representative edge denoted edge corresponding edge 
node expansion shows node expansion step pictorially 
theorem establishes reduction control dependence equivalence edge cycle equivalence 
proof obvious omitted 
theorem nodes strongly connected component node cycle equivalent representative edges edge cycle equivalent node expanded graph 
algorithm edge cycle equivalence determine control regions time 
algorithm asymptotically optimal addition constant factor small algorithm runs fast practice 
detail implementation worth noting avoid explicitly expanding nodes edges 
doubly linked control flow edges depthfirst search traverse edges direction maintain tuple information control flow node corresponding information stored expanded nodes 
resulting code slightly complex savings space time working explicitly transformed graph significant 
related technical report shown algorithm runs faster dominator computation just step previous algorithms problem 
applications pst program structure tree tool enhancing performance program analysis algorithms providing simple framework exploiting global structure local structure sparsity 
intuitive idea 
global structure pst tree sese regions nesting structure explicit 
sese region control flow graph right 
global analysis algorithm applied unchanged sese region partial results combined pst give global result 
lets apply analysis algorithms divide conquer fashion program win combining partial results overly expensive 
example suppose algorithm suppose sese regions roughly equal size pst control flow graph 
provided combining done quickly cost divide conquer approach approximately region algorithm speeded factor concrete example static single assignment ssa form usually computed dominance frontiers size cfr 
show pst ssa computation performed separately sese region 
size sese region roughly independent program size combining partial results done problem pst exploitation nesting structure win 
local structure pst lets tailor analysis algorithms structure sese region 
shows practice sese regions basic blocks conditionals dags loops fast algorithms regions regions pst unstructured irreducible 
way view pst lets localize effect lack structure sese regions affect analysis regions 
sparsity analysis problems solution determined small subset sese regions pst regions contribute solution need analyzed 
example converting program ssa form show oe function placement variable solved completely analyzing regions contain assignment lets ignore vast majority sese regions show experimentally 
illustrate points discussing pst speed algorithms problems computing static single assignment form performing data flow analysis 
particular experimental results highlight importance exploiting sparsity 
pst conversion ssa form translation ssa form requires oe functions merge points control flow graph 
cytron cfr showed oe function needed merge point common paths distinct definitions variable characterized set merges terms property called dominance frontier 
briefly merge dominance frontier node df dominates predecessor dominate extending dominance frontiers sets df df 
variable defined nodes set cytron showed set merges needing oe functions exactly iterated dominance frontier df limit sequence df df df df df 
computation df performed worklist algorithm 
size dominance frontier node worst case 
algorithm uses nesting structure pst avoid computing entire dominance frontier node 
key theorem 
theorem merge node needs oe function variable iterated dominance frontier assignment sese region merge node 
omit proof describe intuition 
consider dominance frontiers 
merge node common paths distinct definitions definitions outside region containing merge paths join prior entering merge region 
likewise definitions region nested merge region paths join prior exiting nested region 
merge dominance frontier assignments sese region 
induction definition iterated dominance frontiers result proved iterated dominance frontiers general 
note implies region containing definitions needs oe functions 
result exploit global structure sparsity pst 
computing dominance frontiers entire procedure compute dominance frontiers sese region separately 
advantageous example size dominance frontiers nested repeat loops reaches worst case bound cfr 
exploit nesting structure pst loop sese region dominance frontiers computed independently avoiding quadratic blowup 
example illustrates exploitation global structure pst 
exploit sparsity note sese regions contain assignment variable omitted analysis 
putting observations gives algorithm enhancing performance ssa algorithms 
algorithm oe placement build program structure tree 
variable 

pst mark region containing assignment 
region collapse immediately nested regions single statements follows region contains definition variable treat region definition variable treat region op 
theorem follows collapsing nested regions described maintains path properties determine oe functions needed 

apply algorithm finding ssa form region treating entry point region definition exit variable 
maintaining list definitions variable perform marking step time proportional number regions marked 
shows fraction sese regions examined placing oe functions variables 
see variables small fraction sese regions examined 
percent variables required examining fifth regions 
step possible exploit local structure different ssa algorithms region procedure size maximum region size versus procedure size percentage regions examined percentage regions examined placing oe functions desired 
example trivial convert loop structures ssa form 
suggests worth doing type algorithm specialization 
pst distributed local memories parallel machine computations sese regions performed parallel 
overheads parallel computation current machines approach yield speed principle clear pst exploit parallelism compilation tells divide combine partial results 
divide conquer strategy works particularly problem combining individual region solutions needed generate solution entire procedure 
discuss dataflow analysis problem region solutions combined yield solution entire procedure 
pst data flow analysis solution techniques monotone data flow analysis problems classified iterative methods elimination methods ken rp 
show discuss pst class methods 
exploiting global local structure elimination methods exploit nested program structure solve data flow equations efficiently 
hierarchical decomposition program structure analysis performed phases 
phase local information computed increasingly larger regions program stage information nested regions taken consideration 
second phase global information propagated increasingly smaller regions 
classic approach elimination algorithms uses interval decomposition program ac 
pst hierarchical decomposition solving data flow systems elimination method phase local information computed sese region bottom order pst global information propagated larger smaller sese regions top traversal pst 
phases need algorithm collect propagate information sese region 
discussed section regions simple constructs blocks loop constructs regions may processed quickly structure methods ken 
remaining unstructured regions 
important aspect pst compatible methods intervals 
particular theorem proof straightforward 
theorem control flow graph reducible sese regions reducible 
original graph reducible small unstructured sese regions pst analyzed interval methods 
irreducible regions fall back general iterative method similar spirit called hybrid algorithms 
interesting note graham wegman exploited single exit intervals speed elimination data flow analysis gw 
exploiting sparsity speeding data flow analysis focused solving individual instances data flow problems finding availability opposed analyzing property variables expressions simultaneously done traditional bit vector approach 
case control flow graph contribute modify solution 
sparse methods data flow analysis attempt avoid propagating information regions program data flow values modified 
approach exploiting sparsity pst bypass sese regions having identity transfer functions 
easy show bypassing transparent regions effect global data flow solution 
data flow problem instance build quick propagation graph smaller control flow graph solve data flow system graph 
solution projected back control flow graph 
nodes subset control flow graph nodes edge denoted pair control flow edges edge encloses sese region 
edge connects source destination constructed edge bypasses maximal sese region having identity transfer functions 
optimizations allow additional forms bypassing special treatment constant transfer functions discussed johnson dissertation 
quick propagation graph built data flow system solved graph avoiding transparent regions altogether 
bypassing performed basis sese regions regions basis exploiting structure elimination method pst allows structure sparsity exploited simultaneously 
course precludes iterative method entire 
solution obtained simple matter transfer solution cfg explained 
algorithm pst data flow analysis 
mark sese regions containing non identity transfer function 
done starting leaf nodes basic blocks having statements non identity transfer functions marking ancestors pst 

construct traversing cfg bypassing unmarked sese regions explained 

solve data flow system solution method 

transfer solution cfg follows 
edge cfg part transparent sese region bypassed construction 
case data flow solution corresponding edge transferred cfg edge 
second case data flow solution edge transferred cfg edge 
note marking step done time proportional number marked regions know location non identity transfer functions 
common optimizations non identity transfer functions maintaining list definitions uses variable 
total time required build proportional size plus number marked pst regions 
worst case pst regions marked regions bypassed simply original cfg 
shown section psts tend broad shallow 
number leaf nodes contain ing non identity transfer functions small total number regions bypassed small 
preliminary studies show usually quite small compared original cfg averaging size statement level cfg 
small relative size cfg significant savings algorithm examine transparent regions 
previous discussed representation dependences called dependence flow graph dfg jp 
intuitively dfg set basis graphs construct data flow problem 
lack space postpone discussion connection 
principle pst perform data flow analysis parallel standard divide conquer algorithms leaf regions parallel interior node pst children processed 
refer interested reader related gupta pollack soffa gps sese decomposition programs structured programming language perform data flow analysis parallel 
note definition sese regions stronger theirs require unique entry exit edges allow multiple edges entry node outside region exit node 
case ssa computation parallel data flow analysis idea communication latencies parallel machines reduced significantly 
discussion pst design divide conquer style algorithms surprising variety problems 
example difficult design algorithm computing dominator tree control flow graph build dominator tree sese region piece local trees global structure nesting information pst 
approach lead fast incremental algorithms analysis problems pst isolate regions graph information recomputed 
pst useful generating code dataflow machines programs language fortran exposes sese regions dataflow edges potentially bypass bmo 
enormous body elimination iteration algorithms refer reader surveys ryder rp kennedy ken 
tarjan valdes hierarchical representation sese regions different kind elimination val tv 
sparsity highlighted choi cytron ferrante ccf dhamdhere rosen zadeck 
choi extend ssa form build sparse evaluation graphs graphs bypass uninteresting regions control flow graph general smaller quick propagation graphs 
costly build unclear exploit sparsity structure edges cross interval sese region boundaries ad hoc manner 
cytron ferrante cf improved time placing oe functions needed build ssa form eff time sreedhar gao sg linear time algorithm oe function placement 
interesting compare performance algorithms performance pst algorithm dominance frontier algorithm cfr selectively small unstructured sese regions psts typical programs 
program structure tree pst hierarchical representation program structure nodes represent single entry single exit sese regions edges represent region nesting 
pst defined arbitrary flow graphs irreducible ones 
showed finding sese regions equivalent solving naturally stated graph problem cycle equivalence edges equivalent iff cycle graph contains edges equivalence class 
discussed algorithm cycle equivalence problem compute pst control flow graph time 
experimental evidence real programs contain abundant sese regions organized broad shallow psts worst unstructured portions procedures contain nested structure comprise small fraction total procedure size 
intuitively pst enables isolate effect lack structure small sese regions letting exploit structure globally 
results applications 
showed problem determining control regions needed global code scheduling example solved time cycle equivalence algorithm 
recursive structure pst possible design conquer style algorithms control flow data flow problems exploiting global structure local structure sparsity 
conclude single entry single exit regions nesting relationship provide simple intuitive inexpensive approach representing exploiting hierarchical program structure control dependence equivalence 
acknowledgments bob tarjan extensive comments earlier version bringing valdes attention 
wrote maintained software gather experimental results 
discussions dexter kozen eva tardos helped simplify presentation results 
beck wei li paul gave extensive feedback research 
pst give linear time space factorization control dependences usually returns control dependence sets time proportional size 
problem providing factorization returns control dependence sets proportional time remains open 
ac allen cocke 
program data flow analysis procedure 
communications acm march 
bal thomas ball 
region 
computing control linear time space 
technical report university wisconsin madison computer sciences department september 
appear 
beck richard johnson keshav pingali 
control flow dataflow 
journal parallel distributed computing 
bmo robert arthur maccabe karl ottenstein 
program dependence web representation supporting control data demand driven interpretation imperative languages 
proceedings sigplan conferenceon design implementation pages white plains new york june 
ccf jong deok choi ron cytron jeanne ferrante 
automatic construction sparse data flow evaluation graphs 
th annual acm principles pages orlando florida january 
cf ron cytron jeanne ferrante 
efficiently computing oe nodes fly 
proceedings sixth workshop languages compilers parallel computing pages august 
published lecture notes computer science number 
cfr cytron ferrante rosen wegman zadeck 
efficiently computing static single assignment form control dependence graph 
acm transactions programming languages systems october 
cfs ron cytron jeanne ferrante vivek sarkar 
compact representations control dependence 
proceedingsof sigplan conferenceon programming language design implementation pages white plains new york june 
dhamdhere barry rosen kenneth zadeck 
analyze large programs efficiently 
proceedings sigplan conferenceon programming language design implementation pages san francisco california june 
fow ferrante ottenstein warren 
program dependency graph uses optimization 
acm transactions programming languages systems june 
gps rajiv gupta lori pollock mary lou soffa 
parallelizing data flow analysis 
proceedings workshop parallel compilation kingston ontario may 
queen university 
gs rajiv gupta mary lou soffa 
region scheduling 
nd international conference supercomputing pages 
gw graham wegman 
fast usually linear algorithm global flow analysis 
journal acm january 
horwitz demers andt 
teitelbaum 
efficient general iterative algorithm data flow analysis 
acta informatica 
jp richard johnson keshav pingali 
program analysis 
proceedings sigplan conferenceon implementation pages albuquerque new mexico june 
richard johnson david pearson keshav pingali 
finding regions fast single entry single exit control regions linear time 
technical report department computer science cornell university july 
kas kas 
distinguishing directed graph 
soviet math 
doklady 
ken ken kennedy 
survey data flow analysis techniques 
steven muchnick neil jones editors analysis theory application chapter pages 
prentice hall englewood cliffs nj 
lt thomas lengauer robert endre tarjan 
fast algorithm finding dominators flowgraph 
acm transactions programming languages systems july 
thomas marlowe ryder 
efficient hybrid algorithm incremental data flow analysis 
conference record th annual acm symposium principles pages san francisco california january 
pod andy podgurski 
reordering transformations preserve control dependence 
technical report ces case western reserve university july 
rp ryder 
elimination algorithms data flow analysis 
acm computing surveys september 
sg sreedhar guang gao 
computing oe nodes linear time dj graphs 
technical report acaps technical memo mcgill university school computer science january 
tv robert tarjan valdes 
prime subprogram parsing program 
conference record th annual acm symposium principles programming languages pages las vegas nevada january 
val valdes 
parsing flowcharts graphs 
phd thesis stanford university december 
report stan cs 
kenneth zadeck 
incremental data flow analysis structured program editor 
proceedings compiler construction pages montreal canada june 
