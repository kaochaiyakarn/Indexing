reaching agreement processor group membership synchronous distributed systems cristian computer science engineering university california san diego la jolla california cs ucsd edu reaching agreement identity correctly functioning processors distributed system presence random communication delays failures processor joins fundamental problem fault tolerant distributed systems 
assuming synchronous communication network subject partition occurrences specify processor group membership problem propose simple protocols solving 
protocols provide correct processors consistent views processor group membership guarantee bounded processor failure detection join delays 
key words communication network distributed system failure detection fault tolerance real time system replicated data designing computing service remain available despite component failures key idea replicate service state information servers running distinct processors 
service state typically consists server group membership set correctly functioning servers cooperate provide service service specific state information queue service requests accepted completed current assignment various active servers state physical resources provide service 
server replication lets service highly available despite processor server failures 
surviving servers detect failure published distributed computing vol 
pp 
peers state information redistribute workload handled failed servers 
replication creates problems exist non redundant systems 
difficult new problem achieving agreement replicated servers global service state despite random information propagation delays component failures server joins 
agreement necessary goal replicated server group behave single logical server group autonomous processes 
earlier papers investigated fault tolerant protocols agreeing service specific global states replicated server groups membership decrease increase cri 
focuses problem reaching agreement membership dynamic server groups shrink failures grow joins 
break goal sub goals 
show achieve agreement identity correctly functioning processors execute server processes 
refer problem processor group membership problem 
second assuming processor group membership problem solved show solve server group membership problem 
solution problem shows maintain agreement global state server group server joins cause group membership increase 
describing system model failure assumptions specifying processor group membership problem 
clear isolation precise specification problem key contribution 
contribution description protocols solving problem 
protocol provides fast processor failure detection require significant message traffic overhead failures occur 
reduce overhead derive protocols provably minimal message overhead absence failures provide longer failure detection delays 
simplicity protocols compares favorably complexity earlier known solutions membership problem bj car cm asc wal 
membership problem fundamental problem distributed computing routing clock synchronization atomic broadcast atomic commit sense solved allows easy solutions important problems encountered designing fault tolerant distributed applications 
illustrate point show processor membership service helps solve server group membership problem problem ensuring high availability computing services distributed system problem precisely defining scope server group communication 
examine optimizations possible extensions algorithms 
conclude comparing approach published approaches 
system model failure hypotheses consider system consisting distributed server processes running processors linked physical network 
total order oe set processor identifiers 
processor consists hardware cpus controllers storage clock software operating system communication subsystem 
operating system supports process execution 
communication subsystem accepts messages delivers messages processes manages message queues drives physical network links 
collectively communication subsystems provide distributed processes run various processors abstraction communication network 
communication subsystems nodes network 
synchronous communication network communication services assume network provides simplest datagram service 
service provides cheap means process send message process 
works follows source process network node node sends single physical route node delivers available target process 
assumption topology network 
point point broadcast channels token rings busses 
fully connected assume nodes implement message forwarding 
assumption datagram message transmission protocols 
instance datagram message broken transmitted sequence datagram packets lost packets retransmitted finite priori known number times message considered lost 
acceptance datagram message source node moment delivered destination process target node arbitrary random delay 
avoid waiting forever packets arrive need decide timeout delay datagram message travels time units node node considered lost 
timeout delays introduced system designers prevent situations process waits forever message process arrive example failure 
datagram timeout delays established studying statistics network behavior various load patterns ensure node node datagram message transmission delays smaller high probability 
adoption bound datagram message delays divides datagram service behaviors classes correct behaviors failures 
datagram service provided network nodes correct datagram message accepted target process delivered process time units 
datagram omission failure occurs delivered performance failure occurs delivered time units :10.1.1.54.9773
causes failures 
physical packets transmit messages repeatedly low level re transmissions implemented corrupted discarded 
buffer overflow occurred target node 
cause slow processing datagram packets source target communication subsystems due randomly occurring excessive network load conditions 
assume datagram service suffer omission performance failures 
addition datagram service assume communication network provides diffusion service 
node diffuses message node sending diffusion packets parallel physically independent routes point topoint networks diffusion implemented discussed networks redundant broadcast channels rings busses diffusion implemented reported cri :10.1.1.54.9773
assume arbitrary fixed bound number communication components nodes links faulty diffusion network possesses redundant independent physical links pairs nodes node receives copy packet diffused node despite faulty communication components 
assume rate diffusions initiated bounded rate smaller rate nodes receive process diffusion packets communication subsystems properly dimensioned provide buffer capacity bounded processing delays diffusion packets worst case network load conditions typically diffusion packets higher priority type packets 
assumptions message diffused correct node received processed correct node known network delay function network topology worst case transmission processing delay diffusion packets cri 
call communication network diffusion synchronous simply synchronous ensures diffusion message correct node received processed correct nodes time units 
characteristic property synchronous network communication partitions prevent correct nodes diffusing information time units occur 
synchronous network reason nodes communicate network message diffusion service failure 
synchronous communication network enables processor clocks synchronized 
assume processor clocks reliable monotonic successive readings yield strictly increasing values run linear envelope real time show real time values known constant maximum deviation function network delay re synchronization period cas 
synchronized clocks allow reason terms global system clock time real time 
time means clock time 
instance phrases message takes time units processes broadcast message time mean delay experienced measured processor clock broadcasts local clock displays time broadcasts clock displays respectively 
synchronous communication network enables implementation synchronous atomic broadcast communication service cri 
synchronous atomic broadcast protocols ensure time constant depends properties 
node attempts broadcast message time time correct nodes deliver delivers atomicity 
messages delivered delivered order correct node order 
sending node correct correct nodes deliver termination 
atomic broadcast primitive broadcasting information say broadcast mean atomic broadcast 
description solutions membership problem relies existence lower level clock synchronization atomic broadcast network services clear lower level protocols just structuring tools shorten presentation 
essential assumption synchronous communication network 
protocols implementing lower level services synchronous communication networks presence arbitrary fixed number faulty components suffer crash omission performance failures described previous publications cas describes diffusion clock synchronization protocol cri describe diffusion clock synchronization atomic broadcast protocols point point broadcast networks :10.1.1.54.9773
reliable communication achieved diffusions broadcast information comes price 
datagram messages cheap diffusions atomic broadcast expensive 
example point point network atomic broadcast costs approximately theta datagram messages number correct nodes average node degree number neighbors node :10.1.1.54.9773
similarly protocols cri require theta datagram messages atomically broadcast information despite processor performance failures processor crash failures occur number messages absence failures 
task scheduling rules datagram clock synchronization atomic broadcast services provided communication network accessible processes running operating system supervision 
processes structured parallel tasks threads 
explicitly start task input parameters time operating systems running network processors provide schedule primitive 
correct operating system interprets invocation primitive follows 
invocation time task start deadline started 
started input parameters time interval maximum task scheduling delay positive constant 
invocations schedule identical parameters times smaller result just start parameters task execution suspended instance task waits messages 
task suspended waits message delivered communication subsystem time correct operating system interprets start deadline system starts interval 
assume tasks scheduled started different times started order start deadlines 
example tasks process intervals respectively started tasks common start deadline assume started arbitrary fixed order known operating system instances processors 
example tasks uniquely identified alphanumeric identifiers order lexicographic order character strings 
total order task identifiers assumed 
assume operating system violates ordering rules task start events 
due excessive load conditions system experience delays longer occurrence task start deadlines task starts 
constant constant determined empirically studying statistics task scheduling delays various load conditions ensure event occurs time results start task waiting time high probability 
operating system starts task time time suffers performance failure 
operating system performance failures cause task process performance failures 
process crash occurs underlying operating system crashes execution process command results unanticipated exception causes underlying system abort process 
operating system crashes handler exception detected execution terminates abort command 
invocation command triggers execution predefined sequence system restart commands 
similarly process abort explicitly invoked process task underlying operating system prevents process reacting events occur process restart 
process crashes minimum restart delay crash occurs time resume correct operation time assume processes suffer crash performance failures 
typical system constants orders magnitude greater time needed consume process message short non interruptible task simplify presentation ignore message processing times assume task started completes zero time units 
correct processor task time starts completes interval 
short tasks described consistent assumption 
note uncertainty task process scheduling delays introduces new bound ffi process process datagram message delays 
term represents upper bound random delay moment process sends message moment message accepted source node second upper bound node node delay third upper bound delay target node target process 
similar manner denote delta bound process process atomic broadcast delays 
processor group membership service enable client process correct processor synchronous distributed system processor membership service service implemented group server processes replicated processors system 
far processor group service concerned processors represented membership servers run 
failure server interpreted failure underlying processor 
correspondence equate membership servers processors follows 
denote set correct membership servers adopt convention refer correct servers simply servers 
qualifying adjective failed talking failed servers 
service provided membership server follows 
local client process declares interest knowing processor membership gives membership current processor group notifies subsequent membership changes timely manner 
notifications sent declares longer interested receiving failure reported underlying operating system 
management set local clients interested membership mechanics notification membership changes occur straightforward explicitly mentioned follows 
focus difficult problem maintaining consistent knowledge processor group membership correct processor 
new processor groups created response processor starts failures 
processor start occurs processor restarts failure shut new processor added system 
simplify presentation equate voluntary processor shut example maintenance reasons processor failure 
point real time require processor joined group 
exist times processor joined group example start moment processor joins group 
unambiguously designate different processor groups exist time uniquely identify group unique processor group identifier reasons requirement discussed section 
denote set possible processor group identifiers 
denote joined gamma 
true false total predicate processor true joined group false joined group 
processor joined group take part coordinated group activity 
group gamma 
partial mapping records group processor joined joined joined group yields identifier group joined furthermore members gamma 
set partial mapping records processor view membership group joined joined joined true members yields view membership group 
value mappings varies time 
keep presentation simple decided mention time domain explicitly 
require processor group membership service satisfy safety requirements ss stability local views 
processor joins group stays joined group failure detected processor start occurs 
sh agreement history 
processors correct certain time interval 
interval joined common group groups joined leaving respectively 
sa agreement group membership 
correct processors joined group joined joined group group processors view membership group members members 
property members denote view common members group requirements sa sh violated different group servers depend processor membership service perform inconsistent operations replicated data manage leading inconsistent replicas 
easiest way achieve sa set views processors empty set 
avoid trivial solutions require processor joined group member group sr reflexivity 
joined members 
sr rules trivial solution setting processor views empty set rule equally trivial solution setting total set processor 
views group members close possible reality require processor group membership protocol satisfy timeliness requirements 
require upper bound join delay delay elapse start processor moment joins processor group failures joins occur concurrently join tj bounded join delays 
exists time constant processor starts time stays correct time processor joins group joined processor correct 
note processors correct join completion time required join group newcomer 
way correct processors forced agree identifier group resulting join 
second require bound failure detection delay time needed detect processor failures td bounded failure detection delays 
exists time constant processor joined group fails time member stays correct joins group members 
require property hold despite number failure join events occur concurrently failure td property lets surviving processors automatically distribute workload departing processors bounded time 
systems meet hard real time deadlines component failures joins occur clustered time requirement essential 
note 
requirements imply essential property processor starts joins group member see sequence membership changes long remain correct 
precisely stay correct joining time sees certain sequence membership changes time max sees membership changes order time property total order delivery group atomic broadcast messages correct processors convey state updates correct processors enable events affect state system seen correct processors order 
total event ordering substantially simplify programming replicated fault tolerant services lam 
periodic broadcast membership protocol presentation membership protocols introducing simple periodic broadcast protocol 
sketching simplifying assumption bound task scheduling delays 
relax assumption protocol detail 
sketch periodic broadcast membership protocol join handling 
membership server starts time invites servers form new group broadcasting new group message timestamped message received arbitrary correct server time delta 
response new group message server broadcasts message contains identifier indicates willingness join new group 
call set servers broadcast messages time processor membership view time denote members set 
atomicity termination properties atomic broadcast ensure servers correct delta receive time delta set messages compute local membership views members members equal members 
servers agree members unique identifier new group membership members 
server computes membership group pp leaves group previously joined joins failure handling 
server starts alert peers event failed server tell surviving members group form new group 
case passage time trigger failure formation new group excluded 
implemented letting member group check time units view time view membership consistent reality 
simplicity require delta learn membership view time checks 
possible design membership protocols delta analysis somewhat complex 
simple way checking membership time time members group broadcast membership check time messages 
membership confirmation time delta member detects members members atomicity termination properties atomic broadcast surviving members detect delta members 
surviving member detects failure joins new group members 
membership changes detected surviving processor schedules new membership check time check view membership 
method effectively imposes discrete sampling continuously changing processor membership reality sequence snapshots taken agreement membership check times 
processor group membership check time integer consider join initiated processor results new group membership check time exist new group created 
check time scheduled old group new check time choose new check time 
way join leads creation unscheduled check time cancels previously scheduled check time members know 
choice motivated reasons 
task membership var group time members set initially fg joined boolean initially false broadcast new group delta cycle receive new group abort fi cancel broadcast broadcast schedule broadcast od task broadcast time abort fi broadcast myid schedule broadcast bf members communicate scheduled check time second worry information get fast able broadcast time detailed description periodic broadcast membership protocol processor membership server structured concurrent tasks shown 
refer line 
membership task started processor local clock synchronized 
controls processor joins processes messages received communication subsystem 
respond membership inquiries clients deal membership change notifications discussed sect 
simplicity code dealing membership inquiries change notifications omitted fig 

broadcast task broadcasts messages scheduled membership check times 
construct expresses nondeterministic choice alternatives enabled chosen random 
alternative execution new cycle starts 
assume start subsequent suspension task executes mutual exclusion 
execution command sequences atomic respect synchronization 
requirement execution task commands atomic respect failures failure interrupt delay execution time 
programs independent processors run standard function myid 
invoked program function returns identifier processor program runs 
simplify description assume intelligent communication subsystem batches messages broadcast identical view times message containing set members processors broadcast delivering messages 
straightforward modify message deliver tasks cri achieve :10.1.1.54.9773
tests detect task performance failures 
invocation abort commands transforms performance failures membership server crash failures 
cancel command cancels previously scheduled starts task removal null assumption adopted simplicity section introduces kinds complications 
minor computation task start times delays 
example taken account existence uncertainty task starts setting start deadline broadcast want task broadcast message time similarly want member group broadcast message check time learns membership initial requirement delta delta 
second complication need sure joined replicated servers execute identical sequences actions despite random task scheduling delays 
instance unacceptable new group message creating unscheduled view time received moment broadcast task previously scheduled check time nondeterministic choice task start tasks possible joined membership servers broadcast messages broadcast messages 
result incorrect failure detections time delta server assign value members members 
particular server cancelled earlier processing new group message detect failure process delta messages send servers time 
task scheduling rules sect 
essential achieving agreement view membership check times servers presence random task scheduling delays 
rules reception new group message unscheduled view time time units check time consequences 
start membership task broadcast task servers results consistent cancellation previously joined servers cancels broadcast time analysis intention provide lengthy formal proofs correctness protocols 
long longer 
describe informally protocols properly 
time uniquely identify successive processor groups 
membership change detected view check time atomicity termination properties atomic broadcast imply values assigned local variables group members members respectively 
way creation successive groups server joined local variables group equal members respectively 
implementation satisfies requirements ss sa 
broadcasts delivered source processor test ensures processor incorrectly join group member requirement sr satisfied 
requirement sh follows termination atomicity properties atomic broadcast service joining processor properties force correct processors agree new view time sequence membership check times serve group identifiers occurrence new processor start event 
implementation satisfies timeliness requirements tj td 
instance consider processor starts join procedure time arbitrary processor stay correct past time joins started processors time delta receive new group message times interval delta 
hypothesis correct broadcast view time delta 
messages received interval delta 
processor processor joined group delta time delta 
consider case processor started join procedure time interval delta processor started join procedure smallest time interval 
possible receive new group message broadcast view time delta 
case broadcast view time join group times smaller delta 
yields delta worst case join delay 
joined processor fails immediately broadcasting happen early time view time created join take worst case concurrent joins cause view times smaller time units occurrence scheduled membership check time missed members time delta surviving server detects members members failure detected 
worst case failure detection time delta 
assume delta way surviving member removes failed processor members reinserted 
attendance list membership protocol main drawback periodic broadcast protocol requires atomic broadcasts time units failures joins occur cardinality current membership 
reduce message overhead absence joins failures derive second protocol uses datagram messages time units check group stability 
sketch previous protocol assume deal complications caused positive detailed protocol description 
sketch attendance list membership protocol join handling 
joins handled exactly periodic broadcast protocol 
failure handling 
consider starting time processor causes creation new processor group delta membership members 
time delta correct members know new membership 
check membership current time units view time members agree highest processor identifier issue membership check time attendance list circulated datagram messages group members 
assume delta allow list originator time learn membership group issuing list 
group members relay list returns initiator 
way passing attendance list members arrange virtual ring lel wal member relay list known successor ring max min min fp oe pg members group correct datagram service failures occur member receive list time interval fl fl ffi lists stamped origination time late lists received fl performance failures detected discarded 
assume reliable clocks need check early lists arrive 
membership confirmation time fl correct group member checks accepted attendance list origin greater equal fl 
fl attendance lists coexist real time 
group members accepted lists membership current time member detects time accepted attendance list origin smaller fl concludes processor datagram service failure occurred 
distinguish cases initiates join procedure broadcasting newgroup message 
processor members failed excluded new group delta join create 
new group created new rounds attendance list circulation check stability membership subsequent join failure 
note periodic broadcast protocol check time costs atomic broadcasts attendance list protocol check time costs datagram messages 
result significant saving steady state message traffic absence failures joins 
example point point network reduction theta datagram messages time units datagram messages time units 
minimum number messages necessary checking stability group size group size protocol messages group members say send message group stability check 
hypothetical protocol assumes optimistically message means correct protocol violate td requirement detect failure hypothetical protocol pessimistically assume receive message create new group excluded remains correct violate ss requirement group changes occur failures joins occur 
protocol exist minimum number messages needed check membership stability group members 
agreement membership check times 
previous protocol unscheduled view times caused processor joins cancel membership check membership confirmation events scheduled old processors learn joins 
detailed description attendance list membership protocol membership server structured tasks membership membership check membership confirmation fig 

membership task controls initial join processor receives arriving messages 
membership check task periodically generates attendance lists check membership stability 
membership confirmation task examines joined processor timely passage lists 
new state variable record origin time accepted attendance list 
manner similar discussed previously positive constant influences computation start termination task deadlines 
changes previously mentioned requirement delta 
imposed list initiator learn membership new group circulating list group final requirement delta 
task membership var members set initially group time time initially joined boolean initially false broadcast new group delta cycle receive new group abort fi cancel membership check membership confirmation broadcast myid schedule membership check od receive joined myid joined gamma true fi members members gamma group gamma fi od receive list fl gamma myid max members send list myid members fi fi od task membership check time myid max members send list myid members fi schedule membership confirmation fl fl schedule membership check task membership confirmation time abort fi fl broadcast new group delta fi analysis upper bound join delays attendance list protocol periodic broadcast protocol delta 
saving steady state message overhead causes increase processor failure detection time 
worst case happen processor fails immediately broadcast message view time created join joins failures occur sufficiently long time 
view time broadcast failing failure occurred early 
assuming joins failures occur scheduled membership check time unable relay attendance list timestamped time 
membership confirmation time fl exists correct member detect missed list initiate join procedure lead creation new processor group excluded time moment processor fails moment failure detected surviving processors worst case delay fl 
detection failure faster fails relaying attendance list concurrent joins failures cause view time occur delta 
algorithm assume restart delay failed processor join delay bigger failure detection time imposes constraint fl neighbor surveillance protocol attendance list protocol checks membership stability requiring members relay attendance list message 
alternative approach checking group stability check stability neighborhood relation defined section pairs group members 
denote previous inverse relation previous refer processor successor previous predecessor neighbor surveillance protocol handles joins manner previous protocols 
different failure handling 
briefly sketch failures detected assuming null creation new processor group member agrees check predecessor correctly functioning neighbor check time members learn neighbors checking alive require delta 
time member sends neighbor message timestamped successor 
absence failures member receives message time fl fl ffi 
neighbor message arrives fl accepted 
neighbor confirmation time fl member checks accepted neighbor message timestamp greater equal fl 
members receive messages membership stability confirmed new neighbor check time scheduled time member detects neighbor message accepted origin fl processor datagram service failure occurred 
distinguish possibilities attendance list protocol initiate time join procedure leading creation new processor group delta new periodic neighborhood stability checks 
great similarity attendance list protocol give detailed description neighbor surveillance protocol 
analysis protocol join detection delay constant attendance list protocol 
main advantage protocol attendance list protocol improved worst case single processor failure detection delay derive 
assume processor departs time failure join occurs time fl 
failure detected successor time initiate join cause surviving group members detect failure time worst case delay detecting single failure fl worst case scenario multiple failures 
processor departs time immediately broadcasting view time caused join processor succeeding departs time interval fl detecting failure predecessor sending neighbor message check time successor departs detecting failure sending neighbor message check time successor 
chain close failures members group leads worst case multiple failure detection delay fl 
yields upper bound failure detection delay possible processor membership fl large values worse upper bound derived attendance list protocol 
processor group membership service useful 
section illustrates implement server group membership service top processor group membership service adding message overhead joins failures occur 
sketch processor group membership service helps solve problems service availability problem problem limiting communication replicated servers group members 
server group membership objective server group membership sgm service member replicated server team know membership group correctly functioning members 
server teams sgm service gives joining server identity correct members subsequently notifies group membership changes 
briefly sketch sgm service implemented extension processor group membership service 
assume operating system processor capable notifying sgm server failure server running global state sgm service recorded joined group members variables maintained underlying processor group membership service new state variable table type server theta team theta processor 
existence entry means server team runs processor 
sgm server processor learns local server wants join group correct members atomically broadcasts global sgm state update joins sgm servers including 
message received arbitrary joined sgm server inserts entry local table notifies members run group membership change 
sgm server sends current membership 
complex protocol needed join time local sgm server give membership entire global state group 
leave interested reader derive protocol analogy sgm server join protocol 
failure server processor explicitly notified implicitly notified operating system detects failure case sgm server needs consult find team belonged 
sgm server learns failure atomically broadcasts global sgm state update departs sgm servers 
message received arbitrary joined sgm server removes local variable notifies members running failure joined sgm server processor detects failure processor interprets failure servers running local table contains information identify servers running server sgm server consults determine group belonged deletes notifies local members failure sketch sgm server newly started processor joins existing group correctly functioning sgm servers 
simplicity assume null leave reader analyze joins positive 
server starts join time sending new group message create unscheduled view time delta 
message processed arbitrary joined sgm server time adds message broadcasts identity discussed previously value local variable time server monitors global sgm state updates initiated times joined sgm members sequence updates 
time delta receive message concludes joins processor group size member initializes empty relation fg 
suppose time delta receives message containing value 
value outdated sequence updates broadcast empty compute current state time delta apply updates assigning resulting delta value local variable 
concludes join reliance processor group membership detect processor failures operating system services detect server failures leads efficient server group membership service implementation periodic message exchange overhead checking server group stability required lower level overhead needed solving processor group membership problem 
increase number server groups number servers cause amount periodic overhead grow number processors remains constant 
solution satisfies safety timeliness properties described processor group membership service section 
particular total order server names team sgm server interprets simultaneous failure set servers failure order sgm servers totally order server join server failure events system 
server group level possible total ordering server group state updates similar mentioned processor group membership abstraction 
service availability despite processor failures define problem follows choose processors group processors run totally ordered set services long correctly functioning processors network 
simplicity assume service hosted processor processor capacity run single service 
services partitioned subset vital services subset non vital services 
availability vital services necessary system able 
non vital services unavailable system goes gracefully degraded mode 
objective ensure vital services available long working processors services provided working processors excess non vital service considered important non vital service 
examples common vital services network reconfiguration coordinator central lock manager name manager primary host important database 
examples vital services network administrator back host database service communication gateway network 
avoid confusion necessary instant real time processor providing service 
processor provides certain service fail processor start service short bounded time interval 
problem continuous leader election problem gm 
processor group membership service allows problem solved quite simply assume follows time processor group change occurs processor joins departs leave reader deal case arbitrary subsets processors join depart simultaneously 
processor joins group size older members provide set services starts service min 
failure processor detected new group created running service done 
running service size greater oldest member service start processor runs aborts starts rules ensure processor membership size vital services important non vital services available processor failures cause minimum number service migrations 
solution superior static assignment services processors render service unavailable long processor statically assigned static primary back scheme crash just processors vital system services assigned primary back lock manager bring entire system despite fact network processors function correctly 
limiting group communication members consider group processors ensure availability certain service correctly provided exists server existence servers lead service failure 
suppose time member start locally 
performance failure prevents starting time time surviving members form new group excluded 
availability reasons started new group processor availability reasons started new group processor equipped timeliness checks transform performance failures crash failures illustrated time broadcast message started members ignore message avoid confusion 
solve related problems necessary clearly define scope group communication 
communication join communication illustrated section restricted established group members 
groups exist time uniquely identified distinct group identifiers identifiers filter group messages 
example messages stamped group identifier sender joined easy members discard messages stamped coming member past group longer member 
systematic stamping group messages group identifiers rules dealing message transmissions overlap group transitions prevent members group sending messages receiving confusing messages outside group 
optimizations extensions section discusses optimizations applied protocols possible hierarchical extension attendance list protocol handle increased number processors 
straightforward optimization lead better failure join delays consists merging membership layer atomic broadcast algorithms discussed cri single layer :10.1.1.54.9773
elimination communication lower broadcast layer upper membership layer save join failure processing delays previously 
second optimization relies observation view time members broadcast messages view time short real time interval length 
message diffusions corresponding broadcasts merged reduce total number exchanged messages diffusion optimization rule followed processor send message containing information neighbor sure knows way enforcing rule record message diffused view time carries information identity processors know processor relay message view time carries information neighbors 
third optimization prevents excessive message traffic caused processor crashes restarts frequently 
prevent traffic possible associate processor network set join times check join processor frequent joiner 
number processor group members significant undesirable processors send messages clock times especially system small maximum deviation clocks 
case spread message traffic technique called staggering 
main idea staggering follows 
rank member processor group defined relative position virtual circle associated described section starting member greatest processor identifier 
membership protocol requires send message time staggered protocol require send message ks staggering time constant chosen greater ensure proper dispersion message traffic 
staggering lead increase membership check period worsen bounds failure detection delays 
resulting increase compensated elimination membership protocol related traffic spikes 
membership protocols scale large point point networks number messages broadcast membership changes occur 
design protocols provide bounded membership change detection delays presence concurrent failures joins scale large point point networks challenging problem 
internet composed smaller networks natural solution problem local attendance list protocols determine membership leader small network leaders participate global leader attendance list protocol internet level 
leader report change membership small network piggybacking global attendance list 
changes turn propagated leaders small networks 
level hierarchy course generalized level hierarchy 
hierarchical schemes provide bounded crash join processing delays require message traffic process membership changes brute force level attendance list protocol run entire internet 
cost increase protocol complexity join crash detection delays 
specified processor group membership problem provided simple protocols solving synchronous networks 
protocol provides fastest failure detection time significant message overhead failures joins occur 
second third protocols minimum message overhead absence failures joins 
failures rare detection time provided third protocol best 
failures cluster time second protocol provides better upper bound failure detection times third 
processor group membership problem fundamental problem distributed faulttolerant system design allows problems easily solved 
illustrated processor group membership service helps solve server group membership problem service availability problem problem restricting group communication group members 
membership service useful solving problems load balancing enforcing service group replication strategies various system services cri 
processor joins failures significant events load balancer service availability manager processor membership service reliably notifies programs joins failures considerably simplifies design subsystems 
published cri knew publications dis cussed processor membership problem synchronous networks 
synchronous membership protocol time division multiplexing access tdma broadcast networks published 
kopetz formally state properties protocol possesses interprets tdma cycle numbers measuring global system time uses cycle numbers uniquely identify processor groups realizes properties protocol satisfies basically safety timeliness properties discussed 
protocol achieves agreement local membership views assuming call quasi atomic broadcast channels message sent processor channel correct processors receive correct processor receives exactly correct processor receive channel failures cause correct processors message received correct processor agreement property membership views violated 
protocols network independent implemented point point broadcast synchronous environments 
implemented broadcast environment approach rely existence quasi atomic channels protocols described cri achieve atomic broadcast faulty channels allowed deliver messages arbitrary subsets correct processors 
processor group membership protocols know assume asynchronous communication network partition failures occur bj car cm asc klw wal 
asynchronous protocols guarantee bound processor failure detection processor join delays run environment delays bounded 
progress reaching agreement new processor group memberships learning new processor failures joins infinitely delayed appropriately chosen sequences events joins omission communication failures processor crash failures 
hand 
asynchronous protocols ones described cm asc designed satisfy safety requirements sa sh partitions occur 
ensure properties presence partitions protocols require time processor group authorized carry 
achieved requiring majority quorum processors group processors group system users 
asynchronous protocols safe timely synchronous protocols timely safe absence partitions 
example partition occurs correct processor diffuses membership check time correctly functioning processors receive message delta receive 
lead divergent views membership violation requirements sh sa 
exist known approaches see example detecting reconciling processor views computed synchronous protocols partition occurrences optimistic approaches applications compensate actions taken certain processors local views inconsistent views processors 
currently faced dilemma 
adopt synchronous approach guarantees bounded response times presence sequence failures joins continue long exists working processor system violate safety requirements communication partitions occur adopt asynchronous approach violates safety requirements sa sh communication partitions occur requires presence majority quorum correct processors done guarantee bounded response times 
design protocols safe timely synchronous environment run asynchronous environment open problem 

comments jean raymond danny dolev joe halpern michael raynal frank schmuck dale skeen jim stamos ray strong moshe vardi pierre wolper referees helped clarify understanding membership problem 
research partially sponsored ibm system integration division part faa sponsored project build new air traffic control system 
asc abbadi skeen cristian 
efficient fault tolerant protocol replicated data management 
sigact sigmod 
bj birman joseph 
reliable communication presence failures 
acm transactions computer systems feb 
car carr 
tandem global update protocol 
tandem systems review jun 
cas cristian strong 
approximate clock synchronization despite omission performance failures processor joins 
proceedings th international symposium fault tolerant computing pages wien austria jun 
cristian strong dolev :10.1.1.54.9773
atomic broadcast simple message diffusion byzantine agreement 
proceedings fifteenth international symposium fault tolerant computing pages ann arbor mi jun 
cm chang maxemchuk 
reliable broadcast protocols 
acm transactions computer systems aug 
cri cristian 
agreeing absent synchronous distributed system 
proceedings eighteenth international conference fault tolerant computing pages tokyo jun 
cri cristian 
synchronous atomic broadcast redundant broadcast channels 
journal real time systems 
cri cristian 
understanding fault tolerant distributed systems 
communications acm feb 
gm garcia molina 
elections distributed computing system 
ieee transactions computers jan 
kopetz 
fault tolerant membership service synchronous distributed real time system 
avizienis laprie editors dependable computing critical applications pages 
springer verlag wien 
klw levy strecker vax clusters closely coupled distributed system 
acm tr 
computer systems 
lam lamport 
time timeout fault tolerant distributed systems 
acm transactions programming languages systems 
lel 
algorithms distributed data sharing tickets 
proceedings third berkeley workshop distributed data management computer networks pages berkeley ca aug 
strong skeen cristian 
handshake protocols 
proceedings seventh international conference distributed computing systems pages berlin sep 
wal walter 
robust efficient protocol checking availability remote sites 
proc 
th berkeley workshop distributed data management computer networks pages 

