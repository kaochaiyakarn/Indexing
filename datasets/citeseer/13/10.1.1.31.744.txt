quantum automata quantum grammars moore james eld santa fe institute hyde park road santa fe nm usa santafe edu 
study quantum computation helpful generalize structures language automata theory quantum case 
propose quantum versions nite state push automata regular context free grammars 
nd analogs classical theorems including pumping lemmas closure properties rational algebraic generating functions greibach normal form 
show quantum context free languages context free cfl 
nontraditional models computation real valued analog spatial molecular stochastic quantum computation received great deal interest physics computer science years :10.1.1.17.5983
stems partly desire understand computation dynamical systems ordinary di erential equations iterated maps cellular automata recurrent neural networks partly desire circumvent fundamental limits current technologies inventing new computational model classes 
quantum computation particular highly active research area 
driven discovery quantum algorithms factoring operate polynomial time suggestion quantum computers built familiar physical systems hope errors decoherence quantum state suppressed computers operate long times 
understand computation quantum context useful translate concepts possible classical computation theory quantum case 
practical viewpoint start lowest levels computational hierarchy upward 
just way de ning quantum versions simplest language classes regular context free languages 
de ne quantum nite state push automata qfas special cases general object real time quantum automaton 
setting formal language function assigns quantum probabilities words 
de ne quantum grammars sum derivations nd amplitude word 
show corresponding languages generated quantum grammars recognized quantum automata pleasing properties analogy classical counterparts 
properties include pumping lemmas closure properties rational algebraic generating functions greibach normal form 
part proofs simply consist tracking standard results theory classical languages automata stochastic automata formal power series attaching complex amplitudes transitions productions automata grammars 
places notably lemmas theorems introduce original ideas 
believe strategy starting lowest chomsky hierarchy bene ts 
prove low lying classical quantum computational models di erent instance show cfl quantum context free languages classically context free 
separations dicult prove powerful models deterministic vs quantum polynomial time rely partly classical separations vs np 
second studying computational power physical system give detailed insights natural system structure dynamics 
example may case spatial density physical computation nite 
case nite quantum computer qfa 
system fact cris moore james eld nite memory sense ask kinds long time correlations memory stack queue 
provide way formalize questions 
molecular biology suggests example lines class protein secondary structures coded rna 
approximation long range correlations rna nucleotide base pairs responsible secondary structure modeled parenthesis matching grammars 
rna macromolecules quantum mechanical objects constructed processes respect atomic molecular quantum physics class secondary structures coded rna may appropriately modeled quantum analogs context free grammars introduced 
vein dna rna nucleotide sequences recognized manipulated various active molecules transcription factors 
functioning modeled qfas 
theory context free languages extremely useful designing compilers parsing algorithms programming languages classical computers 
possible quantum context free languages play similar role design quantum computers algorithms 
quantum mechanics give brief quantum mechanics 
quantum system state described vector complex numbers 
dimension quantum system number complex numbers state vector 
column vector written jai hermitian conjugate jai complex conjugate transpose row vector 
vectors live hilbert space equipped inner product 

probability observing state norm jaj 
time dynamics quantum system rotates state jai complex vector space unitary matrix inverse equal hermitian conjugate total probability system conserved ha ha ja jai 
eigenvalues unitary matrix form 
real valued angle restricted unit circle complex plane 
dynamics dimensional quantum system governed unitary matrix simply rotation schr equation determined hamiltonian energy operator measurement consists applying operator quantum state write operators right 
correspond classical observable hermitian eigenvalues real measurable 
eigenvalues associated single eigenvector observe value probability ij component generally eigenvector eigenvalue probability observing system state jap projection operator hu jp hu 
projects subspace spanned instance suppose consider dimensional quantum system hamiltonian eigenvectors eigenvalues respectively 
system state measurement energy yield probabilities respectively 
projection operators classical nite automata regular languages readers familiar basic automata theory skip section 

alphabet set symbols set nite sequences words language subset word jwj length th symbol 
denote empty word concatenation words uv repeated times deterministic nite state automaton dfa consists nite set states input alphabet transition function initial state init set accepting states accept machine starts init reads input word left right 
ith step reads symbol quantum automata quantum grammars updates state 
accepts nal state reached reading jwj accept say machine recognizes language accepted words 
nondeterministic nite state automaton nfa transition function power set may transitions machine symbol 
nfa accepts allowed computation path series allowed transitions leads state accept turns dfas nfas recognize exactly languages nfa set states simulated dfa states correspond subsets language recognized dfa nfa called regular 
instance set words fa bg occur consecutively regular 
fa rg init accept fa bg enter reject state stay encounter string bb 
init accept constitute dfa 
way view nite state automata matrices vectors 
nfa states set allowed transitions described transition matrix symbol ij transition state state allowed reading init component column vector init init accept column vector accept accept number accepting paths input init 
mw 
accept mw shorthand mw mw 
mw jwj word accepted path leading init accepting subspace spanned accept 
apply matrices right occur order symbols reverse 
course identity matrix denote 
equation starting point de ning quantum versions nite state automata regular languages 
push automata context free languages push automaton pda nite state automaton control access stack nite memory storing string symbols alphabet transition function allows examine control state top stack symbol input symbol 
updates control state pops top symbol stack pushes possibly empty word stack 
pda starts initial state stack con guration 
reading word accepts computation path exists ends accepting control state produces empty stack 
pdas recognize context free languages name motivation clear moment 
instance dyck language properly nested words brackets context free 
recognized pda single stack symbol pda pushes stack sees pops sees 
attempts pop symbol empty stack enters reject state stays 
deterministic push automaton dpda allowed transition combination control state stack symbol input symbol 
recognize deterministic contextfree languages dyck language 
cris moore james eld grammars context free regular grammar consists alphabets variables terminals initial variable set productions derivation chain strings step substring replaced productions 
language generated grammar consists strings consisting terminals derived chain productions example grammar fig fi 
generates dyck language 
note left hand side production consists single symbol require neighboring symbols term context free 
context free grammars generate exactly languages recognized pdas 
dyck language grammar unambiguous word unique derivation tree 
contextfree language unambiguous unambiguous grammar generates 
notably inherently ambiguous context free languages unambiguous grammar exists 
restrict grammar production form wv variable string 
result derivation leaves strings terminals variable moves right 
grammars called regular generate exactly regular languages 
quantum languages automata quantum systems predict observables probabilistic way sense de ne quantum language function mapping words probabilities 
generalizes classical boolean situation language characteristic function de ned 
fact order compare quantum language classes classical ones occasionally abuse terminology identifying boolean language characteristic function saying language class characteristic function analogy equation de ne quantum automata way de nition 
real time quantum automaton qa consists hilbert space initial state vector hs init js init subspace accept operator accept projects input alphabet unitary transition matrix symbol shorthand uw uw uw 
uw jwj de ne quantum language recognized function fq js init accept words probabilities 
apply linear operators right symbols occur left right order 
words start hs init apply unitary matrices uw symbols order measure probability resulting state accept applying projection operator accept measuring norm 
real time automaton takes exactly step input symbol additional computation time word input 
physically interpreted follows 
quantum system prepared superposition initial states 
expose time di erent uences depending input symbols time step symbol 
process perform measurement system probability measurement having acceptable outcome energy level 
note measure space words 
probability particular measurement input 
quantum automata quantum grammars basic setting new 
restrict real complex values replace unitarity transition matrices stochasticity elements row sum get stochastic automata rabin see review 
generalize nonlinear maps get real time dynamical recognizers 
generalize nonlinear bayes optimal update maps simplex get machine deterministic representations recurrent hidden markov models 
note ect matrix product uw uw uw 
sum possible paths machine take 
path complex amplitude equal product amplitudes transitions step 
uw components representing possible paths initial state nal state jwj sum 
uw jwj jwj uw uw 
uw jwj jwj jwj possible choices intervening states jwj di erence real valued stochastic case destructive interference take place 
paths opposite phases complex plane cancel leaving total probability sum ja bj jaj jbj note paths di erent perpendicular states accept add jaj jbj paths state add ja bj come times discussion 
analogy generalized stochastic automata transition matrices necessarily preserve probability nd useful relax unitarity de nition 
generalized real time quantum automaton matrices necessarily unitary norm initial state init necessarily 
de ne di erent classes quantum automata restricting hilbert space transition matrices various ways rst nite dimensional case nite memory form stack 
quantum nite state automata regular languages quantum analog nite state machine system nite dimensional state space de nition 
quantum nite state automaton qfa real time quantum automaton init nite dimensionality quantum regular language quantum language recognized qfa 
section try reproduce results possible classical regular languages quantum case 
closure properties de ne operations quantum automata allow add multiply quantum languages 
result set closed operations just stochastic languages 
de nition 
vectors dimension respectively direct sum dimensional vector um vn 
matrices quantum automata input alphabet complex numbers jaj jbj weighted direct sum aq br initial state init init bs init projection operator accept accept accept transition matrices input symbol cris moore james eld lemma 
qfas jaj jbj aq br qfa faq br jaj fq jbj fr real constants 
proof 
clearly js init jas init init jaj jbj 
direct sum subspaces subspace direct sum unitary matrices unitary direct sum nite dimensional quantum automata nite dimensional aq br qfa 
furthermore faq br jas init accept init accept jaj fq jbj fr note phases don matter norms 
induction sum way long 
ut de nition 
vectors dimension respectively tensor product mn dimensional vector hi ji hi ji say pairing function 
matrices mn mn matrix hi ki hj li ij kl quantum automata input alphabet de ned tensor products respective init accept lemma 
qfas qfa fq fq fr product number 
proof 
easy show dimensional vectors dimensional vectors ha bjc di 
js init js init js init 
tensor product nite dimensional unitary matrices unitary nite dimensional qfa 
furthermore fq js init accept 
js init accept fq fr induction multiply number way 
ut lemma 
constant function 
proof 
just choose init accept js init accept ut add multiply corollary 
set constants 
polynomial product nite number 
sense closure weighted addition multiplication complex valued analogs 
classical regular languages closed boolean operations complementation lemma 

proof 
accept subspace perpendicular accept accept projection operator 
accept accept accept accept uw unitary js init js init uw js init uw accept accept js init accept js init accept js init accept ut property classical regular languages closure inverse homomorphism quantum automata quantum grammars de nition 
homomorphism function replaces symbols words 
instance ab bab 
quantum language inverse image language 
looks wrong fact proper form characteristic function inverse image set 
formally mapping sets characteristic functions acts contravariant functor 
lemma 
homomorphism inverse image 
proof 
simply replace recall composition unitary matrices unitary 
ut pumping lemma known classical result lemma pumping lemma regular languages 
regular language suciently long word written xyz xy 
proof 
nfa states path longer transitions contains loop repeated times desired 
ut unitarity slightly stronger result subword pumped 
classical case repeat word arbitrarily times 
dynamics irrational rotation circle rotations brings back distance started 
theorem pumping 
word jf uw uv words automaton dimensional constant fig 

iterating unitary matrix uw equivalent rotating torus 
ball radius volume iterations state return distance initial position 
proof 
diagonal basis uw rotates complex numbers unit circle di erent angles think rotation dimensional torus 
volume dimensional ball radius distance identity matrix number iterations illustrate gure 
cris moore james eld write diagonal matrix jj ii uw js init accept js init accept js init ju accept 
uv uv uv uv js init ju accept js init jj ii prove uw uv similarly 
jf uw uv theorem proved 
ut angles rational fractions return dimensional torus steps case unitary qfa recognizes classical language identify characteristic function gives theorem 
regular language transition matrices minimal dfa recognizing generate group regular languages 
proof 
set matrices forms semigroup just show sequence transitions mw inverse 
de ne words equivalent followed suxes uw vw known states minimal dfa correspondence equivalence classes 
characteristic function setting theorem shows exists uw uv implies uw minimal dfa returns original equivalence class mw inverse group 
regular languages don property 
consider language subword bb forbidden 
inserting bb allowed word disallowed undone bb subword 
bb inverse 
ut contrast generalized case don unitary lemma 
regular language generalized 
proof 
boolean transition matrices dfa 
exactly allowed path allowed word 
ut combining previous corollary gives corollary 
proper subclass generalized 
rational classical language theory interested generating function language jwj equivalently nn nn number words length generally think symbols variables write formal power series gl setting gives gl gl 
quantum automata quantum grammars beautiful theory series 
particular generating function regular language rational quotient polynomials 
see sum equation lengths labelling transitions respective symbols 
dfa computation path word de ne am rewrite sum words sum lengths gl init 
mw 
accept init 

accept init 

accept rational symbol component restricting gives rational 
instance regular language bb forbidden init accept 
represents reject state 
reader check ab gl ab aa ab ba 
empty word denoted 
setting gives gl recovering known fact number words length th fibonacci number 
obvious generalization de nition 
quantum language generating function formal sum theorem 
generalized rational 
proof 
rst consider generating functions complex amplitudes total probabilities 
accepting subspace accept spanned nite number perpendicular unit vectors de ne hs init ju jh au hs init rational 
hadamard product series ww series formed multiplying coecients term term 
accept ij vector probability accept noninterfering sum squares amplitudes class rational series closed addition hadamard product rational 
closure properties generalizations closure class regular languages union intersection 
ut theory rational generating functions recognition languages neural networks 
cris moore james eld real representation stochastic automata investigate relationship quantum real valued stochastic automata extensively studied 
alluded de nition 
generalized stochastic function function words alphabet real numbers real valued vectors real valued matrices bilinear form 
mw 
mw mw mw 
mw jwj 
call function dimensional dimensional 
components denoting accepting states rows non negative entries sum probability preserved stochastic function 
allow negative entries require rows sum pseudo stochastic 
known complex numbers bi represented real matrices reader check multiplication faithfully reproduced jcj 
way complex matrix simulated real valued matrix 
matrix unitary original matrix representation show theorem 
generalized recognized dimensional generalized qfa dimensional generalized stochastic function 
proof 
transform automaton output bilinear quadratic function machine state 
set perpendicular unit vectors spanning accept init uw ij hs init init uw hs init init uw form 
mw 
init init tensor products dimensional objects dimensions 
entries complex valued 
representation transform realvalued matrices respectively 

letting top row left column respectively gives desired real valued bilinear form 
ut expression generalized stochastic function gives transition matrices unitary stochastic pseudo stochastic 
logical question class contained class stochastic functions vice versa similarly pseudo stochastic functions 
matrices pseudo stochastic unitary permutation matrices incomparable classes 
case intersection stochastic quantum regular languages 
generalized stochastic function characteristic function language de ned fw 
showed replaced stochastic function case stochastic language 
shown language regular converse lemma corollary 
characteristic function language generalized regular 
quantum automata quantum grammars quantum context free languages quantum push automata de ne quantum push automata show modi cations de nition result equivalent machines 
de nition 
quantum push automaton qpda real time quantum automaton tensor product nite dimensional space basis vectors states nite state control nite dimensional stack space basis vectors correspond nite words stack alphabet require init nite dimensional superposition nite number di erent initial control stack states 
rst structure stack certain transitions occur 
control states stack states transition amplitude ju nonzero words transitions push pop single symbols stack leave stack unchanged 
furthermore transition amplitudes depend control state stack top leftmost symbol stack empty 
acceptance demand qpda accepting control state empty stack 
accept accept subspace accept de nition di ers ways classical pdas 
amplitude popping transition depend top stack symbol top symbol stack re making transition 
sake unitarity time symmetry amplitude pushing transition depends top symbol symbol pushed 
similarly popping transition amplitudes depend stack empty 
generalized case transition matrices constrained unitary easily get rid dependence lemma 
generalized qpda simulated generalized qpda transition amplitudes depend second topmost stack symbol 
proof 
simply expand stack alphabet stack symbol inform qpda symbol bottom symbol 
instance stack stu ut believe lemma holds generalized case 
machine dynamic unitary subset stack space visit see way extend entire stack space including nonsense stacks unitary time symmetric way 
time symmetry sake pop symbol time allow push symbol time 
show allowing push words arbitrary length adds additional power just classical pdas generalized case lemma 
generalized qpda allowed push words arbitrary length stack simulated generalized qpda de ned move pushes pops symbol leaves stack unchanged 
proof 
classical case simply adding extra control states push word symbol time lemma 
allows steps input symbol violates real time restriction need slightly subtle construction 
suppose old qpda pushes words length expand stack alphabet composite symbols kg denote expand set control states kg denote 
represent old qpda stack shown gure 
stack new qpda 
represents chunk old qpda stack starting th symbol 
alternately pointer telling skip th symbol pointer stored control state 
cris moore james eld new state stack old state stack fig 

simulating qpda push words length stack pushes pops single symbols 
counter stack symbol acts pointer rst relevant symbol pointer stored control state 
symbols left pointer dummies symbols popped original qpda stack 
lemma assume old qpda transition amplitudes depend top stack symbol 
operate new qpda follows replacing transitions old qpda new ones amplitude pop top symbol th symbol change control state incrementing pop stack set control state 
push nonempty word length choose dummy symbol push stack padding length set control state 
converts qpda transition pushes pops symbol changes topmost symbol stack popping pushing nonempty simulation preserves real time restriction creates qpda pushes pops symbol changes top symbol step 
complete proof need convert qpda pushes pops leaves stack unchanged 
done making top symbol part control state change top symbol changing state lemma 
ut lemma believe lemma holds generalized case 
unitarity appears lost set stacks visited 
stack state old qpda represented stack states new qpda depending intervening computation receive probability 
classical case acceptance control state empty stack equivalent 
prove direction unitary generalized case lemma 
quantum language accepted generalized qpda empty stack accepted generalized qpda control state 
proof 
standard construction theorem simply allows pda empty stack computation reading additional input 
violates real time restriction step input symbol slightly di erent construction preserves unitarity 
double number control states marked control state state marked control states denote empty stack 
replace transitions old qpda pop push empty stack new transitions amplitudes follows replace pops form 

replace pushes form 

replace transitions empty stack 

require states unmarked control state empty stack marked control state nonempty stack transitions amplitude 
init nonzero components states marked empty unmarked nonempty 
new qpda marked control state stack empty accept accept accept 
new transition matrices direct sums old ones basis vectors replaced identity matrix space generated 
old qpda unitary new 
ut quantum automata quantum grammars unfortunately believe qpda accepting control state regard stack general simulated accepting empty stack 
accepting subspace accept accept nite dimensional allowing nite number di erent paths add noninterfering way 
see way map nite dimensional subspace form accept reader nd proof 
di erence classical pdas depending precise de nition classical pda halts accepts soon stack empty rejects asked pop empty stack 
case allow qpda sense stack empty act accordingly 
strict real time constraint time qpda allowed talk back perform measurement input process 
tell machine stack empty receives input 
quantum context free grammars propose de nition quantum grammars production set complex amplitudes multiple derivations word interfere constructively destructively 
show context free case grammars generate exactly languages recognized quantum pdas 
de nition 
quantum grammar consists alphabets variables terminals initial variable nite set productions production set complex amplitudes dimensionality grammar 
de ne th amplitude derivation product productions chain sum derivations amplitudes word probability associated norm vector amplitudes summed dimension grammar jc say generates quantum language quantum grammar context free productions single variable nonzero amplitudes 
quantum context free language generated quantum contextfree grammar 
main result section quantum language context free recognized generalized qpda 
prove series lemmas track standard proof exactly 
innovation attaching complex amplitudes productions transitions showing match 
similar proof real valued case probabilistic tree automata 
multiple amplitudes attached production awkward 
see needed paths perpendicular states accept add noninterfering way 
amplitude paths interfere 
grammars construct equal productions 
de nition 
quantum grammars equivalent generate quantum language de nition 
quantum context free grammar greibach normal form productions form nonzero amplitudes product consists terminal followed possibly empty string variables 
nd requirement useful requiring grammar generates nite word probability de nition 
quantum grammar terminating nite derivation trees zero amplitudes 
lemma 
terminating quantum context free grammar equivalent greibach normal form 
cris moore james eld proof 
essentially proof real valued case 
clearly equivalent derivation terminal word exactly derivation set amplitudes 
summing amplitudes derivations give answer grammars 
need attach amplitudes standard proof classical grammars lemmas theorems show carried correctly 
shorthand refer simply respectively 
theorem shows eliminate unit productions variable productions production single variable give productions ij ij sums paths unit productions ij 
sum works lim true grammar terminating nite chains unit productions zero amplitude 
setting leaves unit productions 
second theorem converts grammar chomsky normal form consists single terminal variables 
production consists variables 
introduce additional variables dm allow productions 
dm give productions 

equal choosing right hand site appropriately set 
lemma eliminates productions form productions productions add variable give productions 




derivation tree produces left right right left 
reader easily check rest proof theorem rewritten way derivations complex amplitudes 
ut greibach normal form useful derivation trees generates create terminal symbol left production 
tree corresponds computation real time pda accepts empty stack 
adding complex amplitudes gives quantum version theorem theorem 
recognized generalized qpda 
quantum automata quantum grammars proof 
convert grammar greibach normal form 
construct qpda terminals input symbols variables stack alphabet control state dimension grammar qpda transitions follows 
production control state top stack symbol pop push stack amplitude 
leave control state unchanged 
read input symbols qpda guesses derivation tree ends empty stack 
amplitude computation path control state equal th amplitude corresponding derivation 
summing paths equivalent summing derivations 
qpda initial control state vector init initial stack accept projecting accept sums gives norm jc gives qpda pushes words stack 
lemma convert pushes pops symbol leaves stack unchanged re done 
ut conversely assigning correct amplitudes productions theorem derivation match computation path qpda theorem 
quantum language recognized generalized qpda 
proof 
lemma assume qpda transition amplitudes depend stack symbol 
variables form leftmost variable tell qpda control state top symbol empty stack state time popped 
previous theorem terminals input symbols qpda th amplitude derivation amplitude paths nal state dimensionality grammar equal accept start guess qpda nal state initial state initial stack states go pop symbols allowed control state accept state stack pair nonzero amplitude init possible chains control states allow production 
amplitudes hs init 
productions depends 
reading input symbol pushing symbol stack entering state represented production form amplitudes equal amplitude ju qpda transition 
production allowed state guess pass popping time 
similarly reading input symbol popping stack entering state represented amplitudes equal amplitude ju transition 
changing state leaving stack unchanged represented amplitudes ju apply productions leftmost variable see derivation tree corresponds computation path qpda amplitude derivation 
summing derivations sums computation paths 
hs init ju amplitude paths qpda control state empty stack 
jc sums accept theorem proved 
ut cris moore james eld representation control state control state occurs variables necessary enforce consistent series transitions symbols context free derivation way communicating created 
alternate approach give productions matrix valued amplitudes transitions keep track state 
current de nition simply multiplied componentwise equivalent diagonal matrices 
matrices commute general choose order multiply production amplitudes de ne derivation amplitude 
leftmost depth rst search derivation greibach normal form correspond computation path qpda 
proof greibach normal form breaks way lemma changes shape tree 
grammars put greibach normal form theorem works equivalent 
may powerful 
productions proof look produce probability allowed choice little may correspond transitions allowed 
de ne de nition 
unitary recognized unitary qpda 
clear constraints quantum grammar needs meet unitary 
clear constraints put simple form preserved kinds transformations lemma 
grammar productions ect unitarity similar way rule table quantum cellular automaton 
algorithm tell quantum ca unitary 
note theorems corollaries corollary 
quantum context free grammar equivalent production amplitudes depend productions initial variable 
generalized qpda simulated transitions change control state accept initial stack consists single symbol 
clear true unitary case 
closure properties classical context free languages closed intersection regular language 
quantum version follows easily lemma 
unitary fg unitary 
proof 
simply form tensor product automata 
nite dimensional state spaces construct new qpda control states transition matrices recall preserves unitarity accepting subspace accept accept accept ut classical closed union addition lemma 

proof 
de ne direct sum grammars follows 
suppose grammars generating dimensions variables initial variables denote amplitudes create new grammar dimensions variables fkg initial variable productions allowed amplitudes 
productions allowed reader easily check grammar generates ut say weighted sum af bg unitary unitary 
true accepting stack alphabets size 
just take direct sum control state spaces sets states interpret stack 
stack alphabet bigger gure handle dynamics unitary way states tries read stack symbols 
leave question reader 
quantum automata quantum grammars generating functions de ne generating function context free language counts multiple derivations gl number derivations grammar gl algebraic 
solution nite set polynomial equations variables 
don count multiple derivations de ne gl gl algebraic unambiguous context free languages word unique derivation 
instance dyck language generated unambiguous grammar fi replaced left right brackets respectively 
generating function obeys quadratic equation variables set solution coecient catalan number 
closest come quantum case 
de nition 
hadamard square formal power series hadamard product theorem 
restriction hadamard square algebraic power series 
proof 
theorem start generating functions weighted complex amplitudes probabilities 
dimension grammar write de ne generating function terminal words derived variable weighted th amplitudes derivation 
terminal de ne produce 
shorthand 
words derived word simply concatenations derived symbols 
obey equations term production polynomial order max jc system equations algebraic solution call th amplitude sum hadamard squares jc write single hadamard square way 
dimension grammar introduce new symbol de ne restriction ut cris moore james eld unfortunately class rational series class algebraic series closed hadamard product 
corresponds fact context free languages closed intersection 
fact set accepting computations turing machine intersection undecidable algebraic series nonzero hadamard product 
means hadamard square algebraic series transcendental 
algebraic series transcendental 
transcendental 
concrete example algebraic shown transcendental asymptotic techniques 
ideally result show certain inherently ambiguous context free languages generating functions aren hadamard square algebraic function 
unfortunately obvious prove case 
regular grammars painfully obvious point include completeness 
de nition 
quantum grammar regular productions form wv nonzero amplitudes variables possibly empty word terminals 
theorem 
quantum language generalized generated regular quantum grammar 
proof 
show language generated regular quantum grammar generalized 
techniques lemma convert regular grammar jwj productions form av variables dimension grammar de ne set dimensional transition matrices ij av jc js init accept init unit vector init accept um accept projects vector st component 
jc lemma sum jc conversely generalized 
state space spanned set unit vectors identify variables accepting subspace accept spanned set unit vectors theorem corresponds dimension grammar 
de ne production amplitudes follows hs init av ij hv jh jc init jh ij init jp accept ij theorem proved 
ut amplitudes theorem depend add corollary corollary 
regular grammar equivalent don depend productions form 
just regular languages proper subclass context free languages show proper subclass unitary non unitary cases quantum automata quantum grammars theorem 
proper subclass unitary generalized proper subclass 
proof 
containment cases control state unitary qpda simulate unitary qfa leaving stack 
proper language words fa bg equal number unitary characteristic function generalized show 
consider qpda control states stack symbol stack indicate excess control state indicating dominates 
starting empty stack init recognize transition matrices xx xx xxx xxx 
xx xx xxx 
xxx 
entries zero left unchanged unused unitary qpda unitary 
hand generating function algebraic rational generalized theorem 
ut regular grammars context free theorem proof generalized subclass 
compare quantum classes classical counterparts 
lemma states regular language generalized 
similarly con ating language characteristic function lemma 
unambiguous context free language 
speci cally unambiguous cfl quantum grammar dimensionality 
proof 
simply give allowed disallowed productions amplitudes respectively 
unambiguous allowed word exactly derivation 
squares jc 
ut quantum ect destructive interference get nonclassical result showing quantum context free grammars strictly powerful classical ones theorem 
unambiguous context free languages symmetric di erence 
proof 
generated grammars initial variables create new initial variable allow productions amplitudes respectively 
jc 
ut cris moore james eld corollary 
unambiguous context free language complement 
proof 
ut theorem 
context free 
proof 
fa fa unambiguous context free 
fa shown free pumping lemma context free languages 
ut proof cfl relies simply non closure 
idea low lying complexity classes 
interference amusing way theorem 
unambiguous context free languages 
proof 
create new initial variable allow productions amplitudes respectively 
apart jc languages 
ut corollary 
unambiguous context free languages 
proof 
respectively 
ut unfortunately sets vectors norm sum subset norm far argument goes 
gives undecidability result analogous undecidability classical cfl 
theorem 
undecidable words undecidable equivalent 
proof 
undecidable intersection empty 
corollary characteristic function 
ut question nonempty support decidable classical 
clear destructive interference cancel derivations word 
leave open question 
nice examples uses interference fundamental way way derivation tree just joining trees di erent phases top 
reader come examples 
nice theorem show inherently ambiguous transcendental generating functions case incomparable 
directions de ned quantum versions nite state automata push automata context free grammars 
classical results carry quantum case shown classical quantum provably di erent 
leave reader set open questions mentioned indebted jan christoph david benjamin dan asimov providing proofs fact 
quantum automata quantum grammars 
happens remove real time restriction allowing machine choose read input symbol 
adds power classical dfas pdas 
quantum case 

way automata qfas choose move left right input 
watrous shown qfa recognize non regular language fa model allows user perform measurement machine step 
qfas powerful classical counterparts restricted single measurement speci ed time 

natural quantum analog rational transductions closed losing unitarity 

incomparable stochastic pseudo stochastic functions 

recognized unique qfa isomorphism minimal number dimensions 
possible determine eigenvalues uw fourier analysis uw 
reconstruct set matrices determined eigenvalues products 

grammars matrix valued amplitudes de ned consistent way put greibach normal form 

simple way determining quantum context free grammar generates unitary 

qpda simulated changes control state accept losing unitarity 

weighted sum unitary unitary stack alphabets di erent sizes 

quantum analog dyck languages chomsky theorem cfl homomorphic image intersection regular language 

non emptiness decidable 

context sensitive 



de ne quantum versions real time recognizer classes queue automata counter automata real time turing machines 

valid computations real time qtms product analogous classical case 

easily de ne quantum context sensitive grammars 
correspond quantum version linear bounded turing machines 
hope quantum grammars automata fruitful areas research useful people studying quantum computation 
acknowledgments grateful bruce philippe flajolet christophe reutenauer proof hadamard square algebraic series transcendental bruce jan christoph alf van der timothy chow robert israel advice rational generating functions john baez pointing eduardo sontag reading manuscript christian help functors umesh vazirani helpful discussions referees corrections suggestions 
wishes rose caf du nord inspiration 
supported uc berkeley onr santa fe institute onr nsf asc 

adleman molecular computation solutions combinatorial problems 
science 

quantum mechanical hamiltonian models turing machines dissipate energy 
phys 
rev lett 
stat 
phys 


berstel transductions context free languages 
teubner berlin 

blum shub smale theory computation complexity real numbers npcompleteness recursive functions universal machines 
bull 
amer 
math 
soc 

cris moore james eld 
representability events probabilistic automata 
prob 
methods cybernetics russian 

mandrioli qrt fifo automata breadth rst grammars relations 
theo 
comp 
sci 


quantum computations cold trapped ions 
phys 
rev lett 


eld calculi emergence computation dynamics induction 
physica 

eld mitchell evolution emergent computation 
proc 
natl 
acad 
sci 


deutsch quantum theory church turing principle universal quantum computer 
proc 
soc 
london ser 


decision procedure unitary linear quantum cellular automata 
proc 
th symp 
foundations computer science 

ellis probabilistic languages automata 
ph thesis university illinois urbana 

flajolet analytic models ambiguity context free languages 
theo 
comp 
sci 


gershenfeld chuang bulk spin resonance quantum computation 
science 

giles reconstruction gauge potentials wilson loops 
phys 
rev 

hopcroft ullman automata theory languages computation 
addison wesley new york 

watrous power quantum nite state automata 
appear proc 
th symp 
foundations computer science 

kuich salomaa semirings automata languages 
eatcs monographs theoretical computer science vol 

springer verlag berlin 

lloyd potentially realizable quantum computer 
science 

closure properties stochastic languages 
university rochester computer science technical report 

moore unpredictability undecidability dynamical systems 
phys 
rev lett 
nonlinearity 

moore dynamical recognizers real time language recognition analog computers 
theo 
comp 
sci 


paz probabilistic automata 
academic press new york 

rabin probabilistic automata 
info 
control 

el personal communication 

rosenberg real time de nable languages 
acm 

sakakibara brown hughey mian underwood haussler methods rna modeling stochastic context free grammars combinatorial pattern matching th annual symposium crochemore gus eld eds springer verlag berlin 

linguistics dna 
am 
scientist 

shor algorithms quantum computation discrete logarithms factoring 
proc 
th symp 
foundations computer science 

shor fault tolerant quantum computation 
proc 
th symp 
foundations computer science 

siegelmann sontag analog computation neural networks 
theo 
comp 
sci 


siegelmann sontag giles complexity language recognition neural networks 
algorithms software architecture van leeuwen ed 
north holland 

active stabilization quantum computation quantum state synthesis 
phys 
rev lett 


townsend modern approach quantum mechanics 
mcgraw hill 

stochastic languages 
info 
control 

upper theory algorithms hidden markov models generalized hidden markov models 
ph thesis mathematics department university california berkeley 
