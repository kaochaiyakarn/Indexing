lr parsing grammar transformation ll parsing making lr parsing understandable efficient peter pepper april aims 
primary focus derivation method contrast classical presentations literature easy comprehend easy adapt different needs 
secondly presents improved lr parser power lr parsing efficiency lalr parsing 
elucidates strong conceptual relationships exist ll lr parsing 
briefly shown flexibility easy adaptability techniques open possibility new applications 
example outline type overload resolution type analysis arbitrary mixfix operators implemented framework polymorphic functional language 
contents basic concepts grammars transformations grammars 
parse trees postfix notation 
adding rule numbers 
continuations lookahead 
equivalence preserving transformations grammars 
lr grammars normal forms grammars normal form bounded production length 
second normal form leading terminals 
third normal form unique shifting 
main theorem nf ll lr ii grammars parsers emulated versus classical lr parsing simple top parsing scheme 
emulated lr parsing 
true lr parsing 
termination nf construction problem 
simple solution backtracking 
simple solution lazy grammar transformation 
solution equivalence classes 
relationship classical lr style parser generation classical sets items construction lr parser 
stronger lalr 
expensive classical lr empirical results 
iii variations observations applications facts grammars languages variations variations grammar presentation 
features ebnf 
action productions 
precedence associativity 
variations grammar transformation process 
optimizations 
incremental parser generation 
simple left recursion elimination fails 
variations parsing process 
lookahead backtrack 
multi pass parsing versus generalized lr parsing 
error handling 
integrating context sensitive aspects 
sketch non standard application type dependent overload resolution mixfix operators appendix functional parsing chapter area parsing undoubtedly best researched areas computer science 
wonder new insights left worth presenting 
clear reveal new parsing techniques heard 
studies remain classical highly successful realm ll lr parsing 
number contributions 
foremost new derivation process lr style parsing advantages ffl simpler easier comprehend verify traditional ways presenting lr parsing 
main reason entire development takes place single formalism switching back forth mechanisms grammars automata tables programs 
ffl simplicity clarity approach flexible facilitates construction variations incremental parallel parsers parser generators integration different environments 
ffl easy obtain parser combines lr style efficiency full backtrack power needed cope parts languages satisfy necessary prerequisites 
referred generalized lr parsing 

equally importantly approach unifies paradigms ll lr parsing 
derivation method simultaneously generates ll lr parser 

somewhat surprising result method generates parser combines power lr parsing efficiency lalr parsing 
parser lr size tables closer lalr parser traditional lr parsers 

approach trivially includes sentential form parsing suited tools syntax directed editors integrated software development environments transformation extensive bibliography 
claim confirmed years teaching method students find lr parsing complex ll parsing 
matter fact implementation command line option checked points program order output ll lr parser 
systems 

implementation easily adaptable incremental parser generation important prerequisite applications 

obtain informative insights relationship different parsing paradigms showing example difference ll lr parsing lr parsing powerful ll parsing 

flexibility opens new application domains lr style parsing type analysis overload resolution polymorphic languages 
regards comprehensibility mathematician familiar uneasy feeling caused certain proofs follow step wonder steps lead result 
idea proof 
short proof 
people lr parsing techniques articles textbooks fall category 
step step basis ffs fis fls fit big picture emerge 
effect particularly noticeable tried derive parallel parser 
means clear changes applied standard table generating procedures order achieve necessary 
similar problem arose tried allow user functional language opal define arbitrary mixfix operators connection liberal rules overloading polymorphism analysis programs led need incremental parser generation fuzzy nonterminals 
decided reconsider derivation process lr style parsing 
guiding principle design proofs straightforward simple amenable automatic verification tools 
derivation solely equivalence preserving transformations grammars 
opinion transparent concept traditional approach sets lr items odd dotted production rules spontaneous propagated lookahead symbols 
note literature 
topic parsing subject intensive research decades completely futile strive list comes close completeness 
hand topic extremely covered standard textbooks 
basically content textbooks add individual specifically address issues cover 
basic terminology section main parts part sections presents approach lr style parsing may paraphrased follows 
traditionally lr parsers obtained applying complex generation algorithm original grammar 
apply simple generation algorithm transformed grammar 
leads main theorem visualized follows lr iff ll transform wagner graham stress importance sentential form parsing 
seen complex extension traditional parsing techniques 
observation albeit setting 
order interrupt flow presentation defer footnotes 
specifically interested literature may skip footnotes 
original grammar lr iff transformed grammar ll 
way proceeding beneficial transformation simple 
part ii sections considers actual parsing process induced transformed grammars 
shown approach captures conceptual essence lr parsing sense decisions expressive power classical approaches 
different implementation techniques speak emulation lr parsing top parser ll parser 
basis study relationship approach traditional way proceeding lr lalr parsers 
part iii sections presents extensions non standard applications 
include short discussion generalized lr parsing lr parsing ambiguous grammars error handling 
ideas underlying number years student courses technical university berlin 
experience shows approach appears considerably easier comprehend traditional methods 
decided pursue subject order principle easier understand 
result effort reported 
chapter basic concepts grammars transformations assume reader familiar basic notions formal languages 
list briefly notational conventions 
grammars fundamental notions need discussion grammars derivations reductions 
definition grammar grammar tuple set terminal symbols set nonterminal symbols start symbol set production rules form 
usual require 
denote set symbols 
definition derivation reduction derivation string sequence derivation steps start symbol string step denoted nonterminal intermediate string replaced right hand sides grammar yielding usually denote derives relation needed notion derivation extended start symbol arbitrary nonterminals 
reduction converse derivation 
definition language language grammar set terminal strings derivable start symbol fu ug 
strings called sentences words 
straightforward generalization considers sentential forms may contain terminals nonterminals language sentential forms denoted 
concepts formalized dual forms grammars generative analytic 
necessary lr style parsing useful connection certain tools syntax directed editors incremental editors program transformation systems works called program schemes 
schemes sentential forms 
illustrate concepts grammar running example 
generates sentences kind arbitrarily stars 
parse trees postfix notation essence derivations reductions captured called parse trees parse tree represents full derivation sentence tree represents partial derivation sentential form 
full tree sentence intermediate tree sentential form variations parse trees note subsequent specifications convenient employ apply operator known functional programming application function elements set denoted def definition parse trees parse trees short trees grammar defined set tree fulfilling condition see subtree contained property take root lefthand side sequence roots subtrees right hand side obtain production formally root root subtrees obvious functions root subtrees 
properties trivial consequences definition see 
lemma leaves read left right yield sentence sentential form 
formally leaves obvious function leaves 
example taken standard textbook smallest grammars illustrating difference slr lalr parsers 
lemma redices occurring reduction process correspond complete subtrees height 
adding rule numbers note technique helpful circumstances concept called null nonterminals add grammar new nonterminals derive empty string change language 
additional nonterminals various purposes may carry semantic actions may act assertions guide reductions enable correctness proofs 
employ technique purposes section integrating tree generation parsing process 
section coping easily idea follow sets 
standard notion production rules transfers little information parse trees 
briefly redesign grammars parse trees 
add production numbers grammar illustrated modified grammar table 
grammar table grammar rule annotations longer label inner nodes parse tree nonterminals numbers corresponding production rules 
result illustrated tree additionally attributed nodes nonterminals types 
note better representation traditional form contains information 
nonterminals trivially retrieved rule numbers rule numbers differentiate different productions nonterminal 
crucial point representation conveys information classical parse trees conveys essential information carry postorder traversal tree obtain string symbols dual nature 
hand considered empty string invisible 
hand tell reductions applied 
see consider corresponding derivations running example variants grammar 
original grammar modified grammar told numbering kind don knuth early parsing unfortunately able track 
incidentally illustrates clearly close connection term algebras signature sigma syntax trees grammars discussed great detail numbers correspond function symbols signature named production rules 
original tree tree rule numbers parse trees numbers view considers null nonterminals second set pseudo terminals called actions 
lemma consider grammar number augmented variants set actions viewed null nonterminals actions viewed pseudo terminals 
ffl languages coincide filtering actions filter filter filter filter eliminates symbols ffl strings extended grammar correspondence parse trees original grammar postorder proof obvious definitions trivial induction height trees 
matter fact extension conveys information 
numbers string left right determine succession reduction rules positions applied obtain lr parsing sentence 
evident course 
relationship elucidating mention proof ffl postorder traversal tree corresponds lr parsing ffl preorder traversal corresponds ll parsing 
effect grammar transformations addition numbers essential advantages approach freely transform grammars see section 
numbers determine tree generation part rules kept proper places transformations 
known fact postorder traversals isomorphic representation corresponding trees base subsequent discussions number augmented grammars 
continuations lookahead parsing situations ll lr parsing need know symbols possibly follow point usually action symbol reached 
traditionally uses concept follow sets providing knowledge 
treatment smoother integrate knowledge homogeneously approach suitable null nonterminals continuation symbol intuitively stands follow nonterminal sentential form 
definition nonterminal define continuation language set def start symbol employ convention contains special input symbol 
occurrence continuation symbol derivation kind considered assertion substring contained 
assertion certain points parsing process needed disambiguate conflicting productions see 
integration continuations tackle problems shall continuation symbols attached grammar 
continuation languages described 
aspect trivial simply append pertinent continuation symbol righthand side nonterminal admissible consider null nonterminal 
extension illustrated running example left part table 
grammar continuation grammar table grammar continuations second aspect hard illustrated right part table continuation grammar directly read grammar 
entailed observation consider production bu derivation vu bu entails relationship equivalent production different derivation symbol description continuation grammar order confuse aspects continuation symbols act null nonterminals regular derivations act assertions representing continuation languages 
computing continuation languages treat normal nonterminals defined continuation grammar 
symbolize change view symbol derivations 
obtain continuation grammar essentially scan extended grammar occurrences nonterminals order obtain definitions principles determine continuation grammar 
contains rule 
aw continuation grammar contains rule 
action symbols ignored 
null nonterminals contribute visible symbols 

trivial rules kind eliminated 
contribute continuation language 

axiom rule added 
address lr grammars add input symbols order avoid undefined lookaheads 
right half table shows continuation grammar running example 
principle grammar simplified transformations moment 
general need extract little information 
simplification general worth effort 
remarks elucidate continuation symbols ffl mainly serve purpose simplifying unifying considerations connection lr parsing encounter elements string generated ff 
situations require continuation symbols ff generate sufficiently long string 
ffl occurrence continuation symbol string assertion meaning extension vw continuation language 
consequently string usually shortened information conveyed weaker assertion provided continuation symbols uniquely determined action symbols usually omit explicitly needed 
equivalence preserving transformations grammars mentioned essence approach lies suitable transformations grammars 
transformations composed elementary rules sequel 
fact rules trivial clue simplicity comprehensibility flexibility approach 
definition equivalence grammars call grammars equivalent generate language 
note definition implies grammars set terminal symbols 
nonterminals productions may different 
course encounter generalized notion equivalence isn equivalence relation needs name observed knuth original 
definition quasi equivalence say grammar models grammar sentences sentential forms say grammars quasi equivalent 
introduce elementary operations produce equivalent grammars 
definition unfolding folding grammar contains productions form may empty 
unfolding yields new production new grammar uvw unfolding production kept new grammar retains sentential forms 
converse transformation called folding 
definition deletion addition grammar 
call nonterminal derivation contains symbol may delete production kind conversely may add arbitrary productions nonterminals 
course add delete null nonterminals nonterminals derive empty string 
definition left factoring grammar contains productions form shown may empty 
left factoring short factoring extracts common part new production new nonterminal vw 
vw vz 
left factoring top parsers presence left recursive productions 
eliminate left recursive production introducing new nonterminal suitable production rules 
alternatively kleene star 
traditional form transformation connection lr parsing generated production may cause problems 
slightly complex form left recursion elimination 
extended form considers definition nonterminal application points aw take kleene star version transformation unfold 
leads vu reduce kleene star normal productions obtain rule 
prohibit pathological situation folding right hand side production 
converted definition left recursion elimination replace left recursive symbols application points rule aw left recursion removal way left recursion replaced right recursion decisive advantage form generate productions 
seen retains lr property cases conflict 
cases simple variant left recursion removal fail 
price paid need new application want keep nonterminal example need sentential forms just sentences 
variant transformation aw az variant occurrences transformed simultaneously productions changed 
correctness approach obvious property lemma operations viz 
unfolding folding factoring addition deletion left recursion elimination generate equivalent grammars 
addition rule numbers section particularly important connection transformations 
shows clearly rule recursion removal aw rule numbers transformed grammar lead completely different kind parse tree rule numbers represent tree constructors transformed accordingly rest productions original tree productions kept place 
string extended grammar remains unaffected transformations string postfix representation original tree 
lemma number augmented grammars transformations retain generated trees 
similar observation holds continuation symbols principles laid section integrated transformations problems 
example suppose left recursion removal right hand sides continuations 
obtain aw note continuations longer needed followed true string conveys information assertion example illustrates usually easiest way proceeding apply transformations grammar continuations add uniquely determined continuations productions action symbols 
part lr grammars chapter normal forms grammars main idea approach transform grammar equivalent form better suited parsing 
incidentally forms want bring grammars close known normal forms chomsky normal form greibach normal form 
split transformation consecutive bring grammar closer closer intended final form 
transformations solely rules section immediately guaranteeing correctness transformation process 
normal form bounded production length transformation trivial customization inspired known chomsky normal form 
idea 
lr style parsing owes speed extent fact utilizes induced regular grammar 
goal bring grammar bit closer form 
order generate envisaged normal form introduce auxiliary nonterminals production rules obtain grammar right hand sides productions length 
consider variant continuation symbols admitted 
definition normal form chomsky normal form grammar said normal form short nf production forms respectively note constrain symbols second position right hand sides special set newly introduced auxiliary nonterminals 
construction transforms grammar nf 
formulate variant continuation symbols 
normal form basis cocke younger kasami algorithm lr style parsing bottom parser 
quite chomsky normal form convert productions 
bz terminal bz suited design 
construction normal form apply process long possible production delta delta delta introduce new nonterminal transform production productions delta delta delta start symbol introduce special start production action indicates successful parse string 
running example see table construction leads grammar 
reasons easier readability stages rearrange layout grammar bit leading version table serve point 
grammar table normal form rearranged layout theorem correctness nf construction construction transforms grammar equivalent grammar nf 
proof trivial equivalence preserving transformations 
construction obviously terminates right hand sides shorter 
production ends symbol nf form follows immediately 
discussion 
obvious relationship size grammar number new nonterminals required nf 
size grammar sum lengths right hand sides counting action symbols 
lemma nf construction introduces auxiliary nonterminals gammak size grammar number productions number actions 
observation interesting shown ll grammar size coincides number states corresponding lalr grammar 
turn deeper connection section 
second normal form leading terminals lr style parsing obtains efficiency great extent fact decisions conflicting reductions inspecting input symbol 
ll parsers principle embodied called follow sets 
motivates second customization grammar crucial step inspired known greibach normal form 
idea 
nonterminals start rule unfolded ultimately want arrive grammar rules start terminal symbol action symbol distinguish variants continuation symbols 
strive productions kind delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta indicate arbitrary mixtures formalized definition 
definition second normal form greibach normal form grammar said second normal form short nf production forms admit continuation symbols strings action symbol followed continuation symbol note byproduct called sets traditional approaches immediately evident grammar 
example grammar see table start unfolding applications 
principle order nonterminals unfolded matter reasons efficiency orders better 
note eliminated longer needed 
point apply left factoring productions nonterminal leads auxiliary nonterminal want rules leftmost symbol unfold immediately 
eliminated longer reachable 
call transformation full left factoring left factoring subsequent unfolding leading generated 
analogous principle full removal 
kind production admitted true greibach normal form unavoidable generalization close 
unfold nonterminals entail need left factoring done example 
result shown table 
grammar table second normal form including sentential forms 
extension sentential forms achieved minor adaption nf construction unfolding nonterminal simply keep pertinent production eliminating 
modification running example table obtains form table 
grammar table second normal form sentential forms grammar nonterminals treated terminals longer exist productions 
language generated grammar comprises sentential forms language original grammar 
illustrated example apply construction 
contrast example apply left factoring 
construction second normal form grammar nf 
possible pick nonterminal means occurs leftmost symbol production 

left recursive apply full left recursion elimination 

unfold occurrences grammar 
feasible due absence productions 

eliminate productions grammar unreachable 
employ construction different variants depending want terminal sentences sentential forms additional productions correspond called goto table traditional lr style parsers original productions correspond action table see section 
variant eliminate productions contain occurrences variant keep productions 
theorem correctness nf construction variant construction transforms grammar nf equivalent grammar nf 
proof proof requires verification facts equivalence nf property termination 
equivalence trivial apply equivalence preserving transformations 
nf property requires observations step complete unfolding lets pertinent nonterminal vanish grammar 
ultimately nonterminals left 
rules invariantly required forms initially true nf nf special case nf 
unfolding obviously retains patterns 
termination easily seen major step nonterminal vanishes 
nonterminal finitely occurrences need unfolded considered left recursion elimination 
corollary variant construction yields grammar models sense def 
generates sentential forms 
auxiliary nonterminals essentially correspond lr items traditional approaches 
discussed greater depth section third normal form unique shifting major deficiency nf construction omission left factoring 
left factoring mandatory normal forms 
correctness theorem works nicely 
crucial efficiency construction resulting parser 
matter fact turn key issue establishing lr property 
certain pathological cases left factoring process may run termination problems 
technically simpler separate presentation aspect rest normalization process 
practice amalgamated transformations order increase efficiency process 
running example left plus subsequent unfoldings eliminating nonterminal unfolding 
obviously reasonable avoids duplication productions right hand sides lead left factoring equivalence preserving transformation reason integrating process 
subtle problem process may terminate 
happen pathological cases unpleasant 
order interrupt derivation process point defer discussion termination problem section proceed normalizing transformations 
definition third normal form grammar said third normal form short nf nf productions right hand sides start symbol 
aforementioned rare termination problem normal form obviously obtained principle ffl apply left factoring possible 
improve efficiency delaying left long possible 
may called lazy left factoring 
construction third normal form modify nf construction adding transformation step 
apply full left factoring occurrences nonterminal nonterminals unfolded apply full left factoring terminals productions 
note apply left factoring soon possible create unnecessarily additional symbols 
consider situation due successive unfolding create auxiliary symbols suffices factorize occurrences sweep 
wait left factoring long possible 
forget latest unfolding nonterminal nf construction demonstrated nonterminal running example 
theorem correctness nf construction grammar construction yields equivalent grammar nf provided construction terminates 
proof 
follows directly correctness nf construction fact left factoring equivalence preserving transformation 
chapter main theorem nf ll lr far derivation led construction transforms grammar equivalent grammar argued intuitive grounds transformed grammar better suited parsing purposes lr property 
informal claim argument precise 
done main theorem 
theorem main theorem consider grammar transformed nf version original grammar lr iff transformed grammar ll 
proof theorem sheds light close relationship lr ll property 
recall difference nf nf include left factoring 
turns difference ll lr style parsers 
corollary consider grammar left recursion transformed nf version conflict free sense def 
ll 
remainder section devoted proof theorem 
unfortunate difficulty find different definitions lr parser literature 
forces choose definitions prove equivalence 
situation advisable employ standard textbooks point 
unfortunately choice class books treats problem point view practical compiler construction main course famous dragon book books refer 
class takes viewpoint formal language theory choice obvious basically employ 
knuth original addresses variants 
second problem take consideration mentioned construction current form necessarily terminate 
order obfuscate discussion ignore problem moment 
formulation transformed nf version theorem entails successful completion construction 
telling point connection lalr parsing papers define call quite lalr 
comes surprise books papers literature attempt establish equivalence definitions 
go details proof repeat outcome normalization process running example 
table contains essence nf albeit continuation symbols 
refer course proof time explicitly show done table 
grammar table third normal form continuations seen information mandatory disambiguating productions proof main theorem point straightforward simplicity approach ends link traditional notions notations 
books papers follow adapted notations original definitions knuth seminal see 
summarize concepts extent needed proof 
focus attention points reductions take place occurrences right hand sides productions ff strings 
definition handle viable prefix consider rightmost derivation ends application production ff aw ff ff called handle string ff prefix ff called viable prefix 
lr parsing concerned rightmost derivations presume property derivations remainder section mentioning time anew 
action symbols approach yield nice characterization handles handle ff ends action symbol 
unfortunately conceptual characterization invisible input string 
quest efficient parsing suffers fundamental problem point time general seen initial fragment string deal limited horizon 
interested languages action handle uniquely determined spite limited horizon 
important class kind lr grammars horizon extends symbols handle 
similar functions left contexts introduce corresponding function horizon property explicit definition horizon define horizon production ff function horizon ff ff juj starts relation express fact string prefix string suitable possibly empty extend relation sets strings letting express fact string prefix string lr property expressed definition lr grammar grammar lr grammar condition holds horizon ff horizon fi ff fi means strings rightmost derivations form ff juj fi different productions ff fi ff fi put words string handle ff consider horizon extends symbols handle string different handle differ horizon 
example see meaning definitions consider simplest possible counterexamples see table 
grammar table simple non lr grammar consider different strings rightmost derivations order avoid problems right input strings provide file symbols continuation start symbol done knuth 
example simplified variant examples 
nice provides counterexample ambiguous 
example shows grammar lr 
consider string handle ends third symbol lr horizon comprises symbols 
symbols identical different handle 
example happens production point 
example shows grammar lr 
arbitrarily long strings easily seen lr impact construction 
transformation grammar generates version table 
called shift reduce conflict contains grammar table transformed non lr grammar lookahead symbol grammar lr 
matter fact continuation shift production continuation reduce production generate arbitrarily long sequences aaa demonstrates grammar lr notion conflict example precise 
recall denotes derivation relation continuation symbols generate continuation strings 
definition conflict grammar nf 
nonterminal shift reduce conflict length productions kind uw juj gamma 
reduce reduce conflict length productions kind uw uw juj concept coincides special case grammars nf classical notion strong ll grammar formulated 
lemma nf grammar conflicts strong ll grammar 
ready prove main theorem 
proof main theorem 
want show original grammar lr iff transformed nf grammar ll conflicts 
correctness theorems normal forms know quasi equivalent 
fact show directions theorem separately 

conflict free lr equivalent negated form lr conflicts 
lr rightmost derivations ff fi ffu fiu ju large fi horizon may inside fi influence argument 
assume long due aforementioned equivalence corresponding derivation ff ff production talking rightmost derivations leftmost action symbol 
due left entail uniqueness property nf derivation ff uniquely determined 
point choice may occur distinguish cases jffj jfij 
entails ff fi productions obtain ff ff ff ff entails ju reduce reduce conflict 
jffj jfij 
take jffj jfij 
uniqueness nf entails fi suitable argument obtain need productions uu ju shift reduce conflict 

lr conflict free 
equivalent negated form conflicts lr 
consider case reduce reduce conflict uw uw juj consider derivations exhibit conflict ff ff uw ff ff uw loss generality assume leftmost action symbol string 
corresponding sentential form action symbols left reduced corresponding nonterminals 
due nf property ff uniquely determined 
equivalence grammars corresponding derivations ff uw ff uw juj violates lr condition 
case shift reduce conflict shown analogously 
concludes proof main theorem 
part ii grammars parsers chapter emulated versus classical lr parsing observation transformed grammars induce parsing algorithms behave classical lr parsers sense decisions expressive power 
programmed differently induced parsers grammars realized recursive descent style traditional lr parsers table driven paradigm stack automata 
want study relationship closely show approach produce classical lr parsers 
simple top parsing scheme discussion refer parser induced grammar 
sufficiently precise briefly sketch way obtaining parsers 
approach parsers written generated language feel paradigm functional programming provides far best elegant framework expressing pertinent concepts 
recursive descent parser higher order functions 
programming technique philosophy grammar parser 
basically nonterminal function productions provide corresponding function definitions 
illustrated standard grammar table 
seen merely introduce connectors symbols grammar leave structure grammar completely unchanged 
sequential composition stands apply parser apply parser choice ajb apply parser parser 
addition need lifting operator convert terminal symbols parsers 
production add action action takes care tree constructor functional programming defer actual code higher higher order functions elegant means directly implementing parsers grammars functional programming community quite 
principle successfully teaching parsing concepts students years 
detailed descriptions techniques 
essentially notation functional language opal slightly enriched order increase flexibility 
noted code look essentially functional languages ml haskell miranda 
fun parser def 
action action def 
action 
action def action table grammar functional program order functions appendix lines 
suffice list functionalities fun parser theta parser parser fun parser theta parser parser fun string parser sequential composition alternative parsers commutative lifting tokens type parser tree theta string tree theta string mentioned equivalence preserving grammar transformations considered section valid functional interpretation lemma operations unfolding folding factoring addition deletion equivalence preserving transformations functions associated grammar 
note left recursive grammars undefined functional interpretation similar result hold 
contrary left recursion elimination functional interpretation sense 
parsing scheme uses recursive descent strategy contains backtracking works reservations framework left recursion eliminated backtracking due shift shift conflicts minimized left factoring 
emulated lr parsing apply parser generation nf grammar obtain may called emulated lr parsing 
parser lr power decisions performs actions traditional lr parser programmed style recursive descent parser 
relatively straightforward exercise derive parser classical lr parser 
consider induced parser nf running example see table 
parse simple string obtain process 
recall function composition applies left right denote prepending token list write action increase readability 
seen function compositions act essentially stack 
evident introduce compact notation representing calculation process theta theta give notation kinds meaning ffl consider shorthand describing functional computation process 
interpretation simply record point string composed function applied point 
ffl consider shorthand classical mathematical formula ff fi means ff xfi 
view provides nice calculus doing correctness calculations 
case representation provides formal basis argue dynamic execution induced parser 
definition parsing process call term parsing process elements string composed parsing function applied point recorded form 
true lr parsing transition emulated classical lr parsing simple observation hinted gray coloring 
lemma parsing process bottom elements composed functions needed 
functions redundant 
sketch proof shown relatively easily intermediate step better understanding effect consider variant apply reductions recording 
example production 
leads reduction theta theta inspecting nf table see production yields action bottom element function composition 
information needed deducing bottom element continue example suppose applied reduction proceed situation theta theta nf grammar provides production lz necessary information deduce bottom function 
course necessary perform reductions done didactic purposes 
see consider stage process theta 




reduction tells see table go elements back counting 
doing encounter recursively forces go element back 
analogously brings 
second element requested 

reduction generates production lz nf yields bottom element 
formally expressed lemma entails proof lemma 
lemma consider production 
ff original grammar 
handle ff occur parsing process form omit intermediate functions 
ff 
iff nf contains production az analogously proof follows directly construction nf illustrated examples note way proceeding gives complete freedom reductions right away delay better suited time freedom wouldn lose 
note recursive backward search course shortened appropriate data structure stack memoization 
programming techniques defer technical appendix 
mentioned implementation leads program directly mimics classical stack automata literature 
modification nf construction 
longer look higher stacks reason keep grammar 
shorten grammar table form table cutting right hand sides note cutting time apply transformation equivalence preserving derives correctness grammar glr table traditional lr style grammar alteration corresponding algorithm 
grammar describes language called viable prefixes 
proceeding cutting helpful notion viable prefix literature 
chapter termination nf construction essentially completed presentation construction correctness unpleasant termination problem 
allowed comfort simply ignoring problem 
reasons reasonable way proceeding 
pragmatic viewpoint nontermination problem may worth effort special treatment ffl nontermination endanger correctness approach efficiency 
strong reason 
ffl possibilities overcoming nontermination problem discuss moment 
strong reason 
ffl nontermination happens quite pathological situations illustrated 
weak reason 
ffl note passing ll grammar nf construction suffices terminates 
criterium weak context lr parsing 
problem 
discuss solutions want see clearly problem arises 
example illustrates way simplest possible grammar transformation process may run infinite cycling 
example consider toy grammar table 
grammar nonterminal generates odd number stars nonterminal generates number stars 
transform grammar nf arrive intermediate form nice experiment theoretical viewpoint considerations particular possibility lazy grammar transformation allow perceive infinite grammars 
left factoring transforms grammar new consider larger suitably chosen ordering induced unfolding 
enables classical method ideal completion notion infinite grammars defined 
basis grammars theorems hold reservations 
grammar table pathological counterexample move nf unfolding nonterminals left factoring leads situation unfold order re establish nf form leading requires left factoring unfolding turn leads evidently repeats problem just solved albeit longer right hand sides 
sequence growing elements process terminate 
problem example clearly lies fact auxiliary nonterminals occur combined left factoring situation 
strange setting plausible situation pathological virtually happen practice 
grammar lr slr accept fact construction include left factoring 
illustrated example shown normal form theorems termination problem may arise iterated full left factoring 
clue solutions lies fact 
fact grammar transformation process point time losing correctness 
stopping process obtain partly non normalized grammars grammars nf productions 
definition say grammar nf nf productions violate uniqueness requirement nf 
equally useful variant definition admitting productions violate nf property having productions form leading unfolded 
problem decide factor unfold process stopped content nf grammar 
simple criterium decision initially full left block productions generated nf 
leads general block new productions turn call left forth 
obtain series blocks new productions 
empirical data indicates consecutive blocks strictly decreasing size 
construction infinite 
matter fact case experiments 
note danger prematurely stopping transformation process due coarse block size criterium concerns efficiency resulting parser correctness 
construction modified nf construction alter nf construction performs left blockwise manner described 
process soon blocks longer strictly decreasing 
lemma modified nf construction terminates generates nf grammar nf grammar 
proof trivial 
practice result nf 
pathological cases illustrated example non nf productions remain 
nf 
sections consider ways dealing nf grammars 
simple solution backtracking nf grammar containing unnormalized productions example apply parsing schemes section 
effect backtracking facility built programm occur parsing process 
question efficiency correctness 
section briefly sketch implementation techniques backtracking practical cases 
simple solution lazy grammar transformation consider nf grammar encounter production apply backtracking parser 
perform unfolding factorization step grammar leading modified grammar continue parsing call technique lazy grammar transformation 
allows proceed symbol ahead input string number possibly needed transformation steps bound length input string 
guarantees termination 
note passing allows nice adaption incremental parser generation 
solution equivalence classes solutions disadvantage burden runtime parser 
consider solution slightly intricate burdens parser generator 
closer classical lr style parsing 
unfortunately solution major drawback works classical lr parsing section emulated lr parsing section 
freedom choosing algorithmic realization gets lost 
clue solution observation expressed lemma parsing process bottom elements needed 
put words elements production ignored 
allows cut infinite unfold factor cycles 
understand underlying idea consider production requires left factoring 
resume example section schematic form situation original nf construction stops nf grammar 
means unnormalized productions kind 
explanation arguments easier prefer letters new symbols 
stand sequences possibly trailing continuations resulting new production calls immediate unfolding problem arises identical terminals created necessitating left factoring 
illustration purposes assume run cycle 
accordance popular terminology java just time transformation 
note traditional lr parsing realizes possibilities 
unfold productions need left may arise 
assume point cycle occurs 
left factoring leads repetition situation albeit longer trailers 
processes kind source nontermination 
classical lr parser decisive feature distinguishes emulated lr parser productions leading cut 
indicated light printing may consider productions equivalent equal cutting 
definition core equivalence production part called core extension 
analogously 
call nonterminals equivalent cores productions identical 
schematic example cores fz fz fz shows equivalence may push modified nf construction bit continue unfolding factorization process equivalent existing way brute force stopping criterium section blocks strictly decreasing size extended finer criterium equivalent productions treated anew 
matter fact refine equivalences dangerous lead cycle 
example situation equivalence generates dag situation harmless equivalent may continue transformation creates additional nonterminals great advantage keep freedom choosing parsing algorithms 
extended transformation process possible outcomes fully succeeds nf grammar ends nf grammar 
grammar unnormalized nonterminal known equivalent existing normalized known responsible cycle 
construction modified nf construction attempt modify nf construction follows left factoring lead new nonterminal equivalent existing old 
finer criterium costly block size criterium needed pathological cases 
lemma modification construction terminates 
proof 
set productions resulting nf start process left factoring 
finitely number sets number possible new finite 
guaranteed termination construction 
correctness provided classical lr parsing variant looks bottom elements parsing process see section 
may lose lr property 
reason notion equivalence take lookahead consideration 
formulate definition notion frontier convenient frontier string set prefixes length strings frontier juj derivation may employ continuation symbols order achieve required length 
definition equivalence consider equivalent nonterminals core 
called equivalent pair corresponding productions generates prefixes length frontier frontier 
theorem adaption main theorem equivalence modified nf construction main theorem holds 
proof need show identification equivalent nonterminals introduce additional conflicts 
seen schematic example 
consider identification transformed equivalent shift reduce reduce reduce conflict length conflict 
note emulated lr parser uses extension parts parsing process 
identified setting 
classical lr parser extension parts needed lookahead case conflicts 
respected notion equivalence 
chapter relationship classical lr style parser generation main theorem demonstrates result nf construction lr grammar 
want study construction relates classical ways obtaining lr style parsers 
provide insights method traditional techniques 
turn somewhat surprisingly approach combines power lr parsers efficiency lalr parsers extent 
classical sets items construction lr parser classical construction lr parsers sets items construction described standard textbook 
appears worthwhile study connections traditional construction method deeply 
roughly speaking correspondences ffl nf construction produces called kernel items 
ffl nf construction corresponds closure forming 
ffl nf construction generates called sets items 
precisely holds nf construction modulo core equivalence relations def 

order ease understanding illustrate comparison classical example see table presents known grammar arithmetical expressions 
proposition 
consider grammar table lr items 
correspondence kernel items nf 
precisely represent exactly parts dot 
proof lemma shown simple induction 
due straightforward simplicity induction formally illustrate basis nf grammar see table 
unfortunately take running example need serious left recursion order demonstrate complexities 
grammar 
table left recursive grammar grammar 
table normal form canonical collection sets lr items functions closure goto 
start process forming closure productions delta added front right hand sides 
kernel items original productions items added closure forming productions nonterminals directly preceded delta added recursively necessary set 
evidently corresponds unfolding process nf construction 
deltae kernel item 
deltae 
deltat deltat items deltaf delta deltai right kernel item point corresponding nf 
operation goto applied set nonterminal preceded dot operation shifts delta nonterminal generates kernel items set 
necessary closure operation applied kernel items 
final result process shown table 
illustration lemma evident shifting dot goto operation corresponds new nf construction 
kernel items correspondence mentioned nf construction corresponds closure forming 
sets kernel items points nf construction performs left factorization 
essentially yields sets kernel items 
deltae 
deltae 
deltat deltat deltaf delta deltai goto delta delta goto delta delta goto delta goto 
deltae 
deltae 
deltat deltat deltaf delta deltai goto delta goto deltat deltat deltaf delta deltai goto deltaf delta deltai goto 
delta delta goto delta delta goto delta goto 
delta table sets items grammar proposition 
sets items correspondence equivalence classes nf core equivalence relation def 

proof illustrate proof terms grammar 
example nf construction situations see table left factorization obtain new productions undergo usual unfolding necessary iterated factorization process leading nf 
core equivalent belong set items 
set determined core case 
example grammar left factorizations yields new cores fz obtain correspondences fz core equivalence classes demonstrates traditional lr style parsing corresponds classical lr parsing 
grammar table second normal form plain notion equivalence leads sets lr items lr parser 
equivalence obtain lr parser 
relationship fact traditional techniques discussed 
stronger lalr known literature lalr strong lr respect shift reduce conflicts 
may perform reductions realizes conflict 
strictly weaker respect reduce reduce conflicts 
shown method leads lr parsing corollary theorem corollary parsing induced nf strictly stronger lalr parsing 
want illustrate property concrete example order gain insights reasons greater power 
literature find various little grammars demonstrate superiority lr usual pick example table 
grammar table lr non lalr grammar usual derive nf grammar particular creates productions incidentally beatty uses grammar example ll grammar lalr calls left create final result table 
grammar table third normal form potential reduce reduce conflicts resolved inspecting lookahead productions case second case 
conflict resolved lalr parser see demonstrates parser strictly stronger 
explanation simple lalr technique puts core equivalence class merges extensions 
example applies leads situation form fz fz resulting union longer disambiguate reductions 
note example method successfully terminates basic nf construction look cores induced equivalences 
criterium admissible inefficient employ notion equivalence order obtain lr parser 
equivalence identified 
expensive classical lr empirical results big disadvantage lr parsers huge size tables 
superiority lalr parsing shows relatively pathological cases size prohibits practical 
claim approach produces 
smaller tables lr parsers general quite small lalr tables 
known difference sizes lalr tables lr tables orders magnitude opposed thousands 
naturally raises question size grammars closer 
open problem 
unfortunately formal proof gives precise cost analysis reasons conclude size closer lalr parser higher level reasoning weak second evidence gained experimental test data strong 
plausibility 
classical construction lr parsers essentially duplicates productions sets items possible follow symbols 
duplication causes explosive growth size 
contrast nf construction works continuation symbols represent continuation languages groups follow symbols 
duplication happens groups symbol group 
essentially principle equivalence classes lalr parsers 
approach quite coarse lalr approach cores extent violate lr property 
example illustrate claim concrete example 
grammar table illustrate derivation lr parser 
grammar table initial grammar generate nf grammar table 
grammar table second normal form grammar states symbols actions corresponding lr grammar states see 
shows approach produces smaller tables example 
illustrates meta level reasoning observations ffl recall lemma number symbols nf equal size original grammar size grammar sum lengths right hand sides 
number kernel items sets lr items 
ffl nf get larger nf transformations unfoldings leave number invariant 
increase occur left recursion removals 
rare classical lr parsing variant needed 
ffl left transition nf introduce new harm left frequent 
cases left factoring entails unfolding vanishes leaving count invariant 
matter fact left factoring necessary due unfolding different nonterminals needed productions number increases 
telling examples nf equal smaller nf 
may expect number nf order size original grammar contrast lr tables order number terminal symbols grammar size reasoning left lead reduction sets items lr set duplicated follow symbols 
empirical evidence 
meta level reasoning needs backing empirical measurements 
major grammars grammar nonterminals productions pascal opal comparison table sizes grammar specified standard book pascal grammar original version published simplified version revised language opal ff 
dark shaded areas represent number states generated traditional lr method described light shaded areas represent number states generated method 
seen figures method creates tables factor smaller traditional tables 
empirical results back meta level reasoning 
part iii variations observations applications chapter facts grammars languages part derivation note passing approach provides nice insights general properties grammars languages 
example facts known literature see proposition 
properties hold various grammar classes 
ll grammar lr grammar 

grammar decidable lr grammar analogously ll grammars 

lr grammar unambiguous 
analogously ll grammars 

lr grammars slr lalr property evident construction symbols ll refer handle plus lookahead length lr refers lookahead 
see quite clearly lr style parsing powerful ll style parsing suppose nonterminal productions form situation recursive descent parser choose productions take 
suppose nonterminals productions 

leading terminal 
means language ll property 
case may shift shift conflict parser choice simply looking token needs backtracking 
points construction delays need making decision applying left factoring 
delaying decisions lr paradigm powerful 
coincides observation see section ll parsing corresponds preorder traversal tree 
means parser decide insert invisible action symbol seen handle ff lr parsing decision taken having seen handle 
properties follow directly fact construction works 
property shown example section 
properties show strong lr grammars 
weaker slr lalr grammars relationships complicated 
proposition 
grammars productions ll slr classes incomparable free grammars properties shown 
ll lr 

ll grammars lalr 
reduced grammars grammars null nonterminals property holds ll lalr 
property follows directly fact need left factoring 
absence productions guarantees occurs element right hand side 
grammar lr 
kind reasoning shows property 
second property shown grammar section 
proposition 
properties hold various language classes 
lr language lr language 

lr language lr language see 

lr language slr 

ll language lr slr 
note talk induced languages grammars 
sketch proof 
longer interested grammar dependent trees pure strings ignore actions means continue left factoring process guaranteed terminate point due lr property 
constructed grammar clearly lr grammar 
short sketches shall suffice indicate modified approach yields useful techniques practical parser generation provides insights theoretical questions 
chapter variations previous sections approach flexible easier comprehend traditional lr style parsers exhibits expressive power 
want show increased flexibility utilized ease certain features error handling increase power adaption non lr languages 
variations grammar presentation presentation grammars productions obey classical form context free grammars action symbols 
practice need notational comfort flexibility 
features ebnf practical grammars wants convenience called ebnf form 
features trivially translated elementary forms productions 
representative example consider kleene star 
question opting left right recursive solution difference 
left recursive solution right recursive solution shows solutions equally left recursive solution problems arise exhibit conflict 
right recursive solution problems occur exhibit conflict 
situations identical 
considerations apply case features optional terms repetitions separators 
action productions action symbols central means organizing transformation parsing tree formation process 
situations wants action symbols 
done problems precautions observed 
major reason may want omit action symbols nicely illustrated classical grammar arithmetic expressions see table 
write modified form table retain numbering old version 
grammar 
table left recursive grammar action symbols places want perform semantic actions 
spare number pure adaption actions 
illustrates main reason omitting action symbols desirable introduce auxiliary nonterminals grammar modularization purposes 
nonterminals play role syntax tree grammar better may express precedences avoid ambiguities simply readable 
typically happens kinds situations 
nonterminal variants readable making right hand side separate production new nonterminal 
cause problems seen application production effect nonterminal show syntax tree action creates production omitted 

converse situation wants nonterminal syntax tree variants effect nonterminals show syntax tree pertinent right hand sides eliminated 
schematic examples illustrate techniques go problems situations 
careful recursive productions involved 
see consider productions transformed form 
impossible give useful code semantic action information lost 
precedence associativity language encounters problem standard operators arithmetic logical expressions shall written infix notation obey certain precedence associativity rules 
complicates grammar considerably 
quite different intended syntax tree 
section show handle applications programmer allowed invent infix operators 
famous example grammar probably arithmetic expressions table 
expresses essence envisaged syntax tree 
precedence rules switch obvious grammar practice see table 
sketch ambiguous grammar parsing add additional information 
need say operator binds stronger shall treated left associative 
grammar left assoc left assoc table highly ambiguous grammar nf construction grammar yields grammar table 
grammar table nf obviously highly ambiguous leads possible symbols 
want employ information higher precedence shall left associative 
consider symbol lookahead 
ffl precedence information says reduction may take place symbol 
production modified minus symbol 
ffl precedence information says reduction take place symbol 
reduction precedence shift 
means eliminate production 
ffl left associativity says shift reduce conflict resolved favor reduction 
means productions eliminated grammar 
ffl right associativity say take symbol 
act precedence hold 
results considerations table 
seen immediately grammar table nf disambiguation grammar conflicts 
systematic process disambiguate grammars associativity precedence information 
convenient feature ffl specification grammars simpler particular people familiar art syntax specification 
ffl mandatory applications programmers shall able define mixfix operators see section 
variations grammar transformation process description transformation process section concise 
want point possibilities optimizations extensions 
want give posteriori motivation certain design choices 
optimizations order interrupt presentation approach section mentioned straightforward means improving efficiency ffl chain productions 
construction generates byproduct optimization may speed final lr style parser considerably 
seen table obtain various places sequences actions sequences result called chain productions 
non optimized lr parsing sequence ultimately leads individual state plus corresponding reductions optimized version handled state transition combined reduction 
variant generated automatically approach 
ffl optimization 
construction allow arbitrary order nonterminals unfolded eliminated 
specific ordering improve process need fewer left produces smaller result grammar 
determining order start topmost nonterminals 
context nonterminal nonterminal occurs symbol rule rule reason chose nonterminal earlier example 
lazy left factoring better collect pertinent right hand sides treat single transformation 
connection left recursive productions apply classical algorithm finding maximal strongly connected components directed graph 
incremental parser generation applications see section helpful build parsers incrementally 
nf construction provides facility relatively easily 
distinguish cases 
suppose want add new nonterminal productions 
nonterminal unreachable extend existing nonterminals say new production 
situation easily handled construction provided left recursion introduced 
ffl nf construction independent existing grammar determining new available 
ffl nf construction proceeds nonterminals successively anyway 
simply treat nonterminal unfolded 
modification remember productions nonterminals unfold right hand sides unfold literature known done lr paradigm simpler ll paradigm 

story intricate admit complex extensions existing nonterminal extensions reduced situation exception addition leads direct indirect left recursion careful 
see underlying principle consider simplest possible situation 
suppose grammar table 
grammar table trivial nonrecursive grammar nf grammar table 
grammar table nf assume want add production add production original grammar apply nf construction obtain grammar table 
compare grammars table grammar table nf modified grammar table find correspondences ffl defined exactly required left recursion removal def 
applied nf grammar table 
ffl complication replace trailer productions obtained unfolding obviously doable little effort 
short considerations demonstrate nf construction adapted incremental parser generation 
simple left recursion elimination fails section opted traditional form left recursion elimination literature chosen slightly complex version see def 

want demonstrate choice mandatory 

simple form guarantee lr property 

simple form works classical emulated lr parsing algorithm 
aspect seen counterexample def 
grammar lr transform grammar simple recursion removal obtain exhibits conflict 
contrast complex variant recursion removal generates grammar avoids conflict 
explanation simple symbol follows recursive case application position 
simple variant decide recursion finished production 
complex variant resolves problem way left factoring leads conflict free aspect seen little counterexample 
classical lr variant left recursion removal 
keeping retain option switch different parsing methods 
example consider maximally simplified variant classical grammar arithmetic expressions 
grammar shown table 
grammar table left recursive grammar nf shown table 
intermediate longer reachable eliminated 
grammar table second normal form left recursion removal apply parsing methods sample string obtain derivation classical lr parsing ignores upper elements theta theta hand apply variant nf construction left recursion removal obtain grammar table 
note comes left factoring grammar table second normal form left recursion removal variant leads essentially classical lr parsing process grammar table 
grammar emulated lr parsing process get stuck immediately theta theta demonstrates variant recursion removal superior sense enables parsing methods variant recursion removal works variants 
variations parsing process presentation grammars transformation process grammars parser generation allow variations 
parsing algorithms implemented different ways adapted changing requirements 
variations way ambiguity 

grammar lr may consider backtracking lookahead 

truly ambiguous grammars need backtracking 

errors sense worst form ambiguity know string restart problems essentially handled techniques 
demonstrate case sketch pertinent cases 
lookahead backtrack 
known lr parsers efficient case may expensive 
see affects approach consider example derived slightly modified syntax import declarations opal import encounter identifier clear identifier list name new import 
essence situation captured grammar table 
grammar table non lr grammar nf table 
note reachable eliminated 
grammar table third normal form seen continuation information suffices disambiguate productions rules shift reduce conflict resolved leading symbol continuation look ahead find production iz terminal symbol second production terminal symbol symbol generated symbols lookahead conflict resolved lr parser 
shows property 
proposition 
method automatically generates lr parsers arbitrary additional effort 
analyze continuation grammar ahead 
easy description exists nf 
additional effort invested conflict encountered 
property contrasts approach nicely traditional way proceeding 
spite simplicity questionable effort extra analysis worth cost 
firstly problem occurs rarely 
secondly parser full backtrack parser 
cases symbol lookahead needed simply employ backtracking order perform successful parse 
step backtrack cost 
illustrate effect parse simple term 
look parsing process defined def 
obvious generalization ambiguous parses ambiguous production encountered possibilities recorded 
potential reduce action list candidate alternative 
theta phi psi phi psi point evident alternative valid impossible symbol eliminate choices proceed phi psi phi psi time second variant excluded symbol impossible eliminate second choices proceed 
theta realization slightly complex indicated example happen branches split case simply flatten choice pairs triples nested choices order allow correct backwards elimination 
note passing internal organization lists functional language opal effects desired sharing sublists automatically 
implementation extremely simple languages 
multi pass parsing versus generalized lr parsing realization parsing process major disadvantage simultaneous performance multiple parses frequently encounter situations threads lead happens constructs possible parses perform local 
means avoid waste 
ffl order duplicate realize various threads complex data structure viz 
dag 
worked tomita concept lr parsing see 
bates lavie similar technique termed forest structured stacks 
ffl practice lr parsing complex data handling efficient way proceeding 
multi pass parsing scheme may efficient 
technique sketched 
essential point multi pass parsing perform reductions unambiguously possible 
encounter ambiguity proceed demonstrated section set possible states steps create new sets states frequently encounter locally unambiguous substrings sets reduced simple nonterminals 
way perform unique 
result obtain maximally sentential form focusses actual ambiguities 
sentential form general short easily accept overhead backtrack parsing 
idea improved shown section find certain members set possible states inconsistent input symbol 
allows backward elimination predecessors 
efficient variant second pass finished 
backward pass inconsistencies removed sweep 
illustrated example previous section second pass solve problems case lr grammars 
happen truly ambiguous grammars real backtracking needed 
note passing principles applicable design parallel parsers see 
ambiguous grammars 
principles apply truly ambiguous grammars 
important aspect point view efficiency splitting potential branches managed way common done 
illustrate example derived slightly modified syntax declarations languages opal haskell ml 
additional conventions haskell offside rule way parsing program fragment uniquely 
example means clear arguments leading function symbol declaration 
essence situation captured grammar table 
transform grammar nf obtain exhibits conflict grammar 
table ambiguous grammar iz shift reduce conflict 
immediately see conflict resolved lookahead 
words grammar lr backtracking unavoidable reduced absolute minimum uniquely determined 
multi pass paradigm shorten input string short sentential form enters true backtracking process 
clue simple method type dependent overload resolution ambiguous constructs may generate possible parses apply typing algorithm resulting trees throw away type correct 
error handling literature treatments integration error handling parsing see 
connection paradigm functional parsing subject extensively treated 
special form nf allows systematic straightforward error handling 
ffl pointed section error handling performed lines treatment non lr grammars 
matter fact consider generating second nf inverse direction parsing right left 
second pass encapsulate error positions high accuracy 
ffl possibilities 
example points error recovery need sets collections terminals occurrence indicates pop deeper error level 
typical instance occurrence unexpected parsing clause 
indicate lacking closing 
error recognized symbol set put parsing symbol 
parsing process described def 
section set directly obtainable intermediate composed functions 
integrating context sensitive aspects functional programming community known flexibility provided functional parsing defined section allows extent integration context dependent grammars 
go details merely want point pertinent principle 
parsers defined section convert production function definition def action want integrate context dependent information typing information potential offside positions may extend function appropriate parameter 
leads definitions kind def action auxiliary functions propagate context dependent information various parts parser 
simple exercise extend notations grammars nonterminals form allowed 
extended forms constructions go analogously 
far providing full power attribute grammars simple tool solves number practical problems 
chapter sketch non standard application type dependent overload resolution mixfix operators nonstandard nontrivial application approach consider parsing type analysis combined user defined mixfix operations 
want allow programmer write declarations form def int theta int int left associative oe def matrix theta matrix matrix left associative oe def array ff theta ff theta nat array ff def ffi fi fl theta ff fi 
ff fl need mixfix operators higher order functions overloading polymorphism 
modularisation concepts available classes modules structures 
fundamental principle underlying concept observation group grammar induces signature algebraic structure notion syntax precise 
observation works way round signature structure induces grammar 
correspondence simple types signature correspond nonterminals grammar 
operations mixfix examples fragments operations correspond terminal symbols 
wish list deduce number requirements ffl analyzer constrained lr grammars programmers modules willing obey constraints capable recognizing 
need full power backtrack parsing 
provided parser described section 
ffl modularization entails module import module moment grammar extended grammar need incremental exception arbitrary mixfix notations parser language opal cope features 
parser generation 
section shown requirement easily met framework 
ffl situations known priori role certain identifier plays 
happens example pattern definitions functional programming 
may immediately clear identifier parameter fragment mixfix operator 
obtain fuzzy terminal symbols 
techniques sections adapted easily slight complication 
ffl translate correspondences situation polymorphic functions run concept generic nonterminals 
best dealt context dependent parsing sketched section 
practice system coarse grammar takes care basic structure program 
result obtain coarse syntax tree contains sequences unparsed fragments 
example program fragment sin cos fi may lead tree kind cond sin cos parse subexpressions tree grammar deduced function declarations program modules 
fortunately general need backtracking hurt applied short terms 
advantage applying coarse structure parse 
seen approach requires intricate interaction parser hindley milner type algorithm 
various aspects approach discussed previous sections enable application concrete requires research effort 
chapter technique simple flexible generation ll lr parsers 
idea transform grammar particularly suitable form means recursive descent parsing 
recursive descent parsing section extremely simple mechanism attractive short elegant 
keep problems mind ffl start biggest drawback ll parsing grammars productions 
construction eliminates left recursion 
ffl parsing process may slow may perform finding right production nonterminal 
nf construction eliminates possible shift shift conflicts 
performs lookahead reductions 
true backtracking may occur grammar lr want backtrack power 
ffl provided decent treatment errors 
easily added described 
brief discussion section indicates error handling fostered approach 
simple may technique number important advantages ffl full backtrack parser works arbitrary context free grammars just ll lr grammars 
ffl parser yields successful parse easily varied yields set parses 
ffl easily change viewpoint grammar parsing function directly executed data structure interpreted 
switch back forth transformations grammar parsing grammar 
way apply lazy grammar transformations triggered parsing process sketched section 
ffl higher order functions defined fetched library 
order obtain parser grammar 
ffl parsing operators part library exploit full power programming language writing semantic actions 
flexible working external tools parser generators 
instance easily add attribute computations parser see section 
ffl due simplicity parser easily verified considered obviously correct 
verification fact outlined appendix 
ffl special form nf allows simplify implementation parser see appendix 
feel combination grammar transformations highly elegant simple flexible implementation scheme provides extremely powerful parsing concept 

ideas approach evolved years stimulated teaching principles compiler construction students 
time people provided critical assessments proceeding notably wolfram schulte andreas 
am especially grateful doug smith green members kestrel institute stimulating research environment place intensive discussions formalization software development lead final shaping 
number valuable comments provided members ifip wg 
helped formulate parts 
appendix appendix functional parsing functional parsing sketched basic principles briefly section 
sake completeness want fill missing details appendix 
essentially parser take input string yield corresponding tree indicate failure 
true parsing full input intermediate parsing stages turn initial fragment input tree 
unread remainder input returned result 
programming slightly facilitated add reasons symmetry type tree argument 
parser takes input partial tree string yields output properly extended tree plus unread remainder string type parser tree theta string tree theta string function type operations working type parser higher order functions 
look definitions operators explain basis elementary operation fby essentially connects parser possible continuation parsers success failure fun parser theta parser parser def fby fail sequential composition fun parser theta parser parser def ajb fby id alternative parsers commutative connectors introduce kleene star variant fun parser parser def fby id kleene star fun parser parser def need understand operations viz 
fby fail lifting operator 
basis program basic operations 
fun fby parser theta parser theta parser parser def fby input remainder input okay remainder fail input fi continuations backtrack 
parser fail merely returns failure indication note overloading parser called fail tree called fail 
note need return string reasons type conformity purpose empty string 
fun fail parser def fail input fail sigma terminal symbols lifted parsers simply look input token check expected failure indication returned 
operation trees discussed moment 
fun token parser def sigma fail sigma def remainder remainder fail sigma fi lift tokens unexpected input input symbol shifted tree unexpected input symbol want go details representation construction trees 
adopt view section realize operation simply appending token tree string operations action append number tree action tree input tree input 
special form nf simplify operator write case distinction leading terminal symbols avoid step fail tests 
conclude brief sketch noting concrete programming chosen obligatory details easily varied suit different tastes styles 
example hutton meijer design operators fulfil monad laws popular functional programming 
correctness 
functional parser straightforward correctness appears evident verifying derivation sake completeness 
start initial specification directly represents correspondence functional parsers derivations parser transforms string tree ease presentation consider trees postorder form strings number augmented grammar described section 
initial specification employ type parser parser string tree 
help filter function eliminates numbers formulate initial specification definition deduce properties course implementations realize actions building trees right away 
ab summarizing parse ab parse fulfils property ease readability consider defined case omit premise specifications 
specification evidently suffers existential quantifier non constructive 
existential quantifiers converted skolem functions leads new specification ha embed parser new parser returns value corresponding function yield simple tree extends tree def note specification constructive clearly embedding sigma requiring sigma sigma component result full parse provided second result empty 
take derivation def ha ha ha ha hb way formally derived definition auxiliary function fby operator 
operators derived analogously 
improved implementation 
section employed backward search order find taken bottom element function 
course unnecessarily inefficient implemented elaborate way 
clue improvement cases data structure remembering necessary information 
consider reductions section 
effect twofold reduce substring handle ff symbol 
eliminate intermediate functions inside ff 
apply reduction explicitly add action symbol output perform elimination intermediate functions 
idea suggests keep functions bottom ones separate list 
resulting process illustrated example corresponding rules moment 
theta theta theta theta theta theta theta theta theta theta theta theta specification steps quite simple consists main rules 
perform step terminal symbol theta theta theta theta production tz nf grammar 
perform step theta gamma theta theta gamma theta production ff original grammar 
number elements popped list length handle ff 
corresponding nonterminal determines newly added comes production az respectively nf grammar 
perform step theta gamma theta theta gamma theta applicable production gamma nf grammar rest analogous case 
evidently rules just mimic effect reduction handle ff symbol performing reduction 
obviously correct 
discussion 
transformation process major influences programming techniques 
main aspects resulting changes briefly discussed 
ffl list functions 
want adhere functional programming style longer function composition popping functions compositions impossible need list functions theta appropriate number functions popped actions programming remains 
ffl interpretative parsing 
list theta may consider changing functions simple values numbers 
play exactly role states traditional lr style parsers 
programming different functional version direct applications functions operation apply style interpreter 
ffl efficiency 
interesting issue efficiency different variants 
emulated lr concept carry composed function needs applied rest string 
considers overhead higher order functions costly easily implement composition stack functions stack numbers interpreted 
shift operation adds elements stack reduce operation takes element stack 
true lr version carry stack albeit different 
shift operation adds element stack reduce operation takes elements stack adds 
traditional lr style technique stack management explicit generation tree fragments 
conceptual comparison clear various implementation techniques cause different costs 
consider stacks original version time obtain stack stacks 
bottom elements stacks form stack second approach 
bibliography alfred aho ravi sethi jeffrey 
compilers principles techniques tools 
addison wesley 
roland backhouse 
syntax programming languages 
prentice hall 
snelting 
psg system formal language definitions interactive programming environments 
acm transactions programming languages 
bates lavie 
recognizing substrings lr languages linear time 
acm transactions programming languages 
beatty 
relationship ll lr grammars 
journal acm 

practical arbitrary lr parsing 
journal computer system sciences 
degano 
efficient incremental lr parsing editors 
acm transactions programming languages 
th 

efficient computation lalr look ahead sets 
acm transactions programming languages 

simple lr grammars 
comm 
acm 
pepper 
design implementation algebraic programming language 
gutknecht editor programming languages system architectures lecture notes computer science pages 
springer verlag 
ch 
pepper redesign opal 
technical report fachbereich informatik technische universitat berlin february 
hill 
combinators parsing expressions 
functional programming may 
hutton 
higher order functions parsing 
functional programming july 
hutton meijer 
monadic parser combinators 
functional programming may 
jensen wirth 
user manual report 
springer 
kasami 
efficient recognition syntax analysis algorithm context free languages 
technical report air force cambridge research laboratory 
kernighan ritchie 
programming language 
prentice hall 
knuth 
translation languages left right 
information control 
moll arbib kfoury 
formal language theory 
springer verlag 
nijholt 
deterministic top bottom parsing historical notes bibliographies 
mathematical centre amsterdam 

glr parsing grammars 
tomita editor generalized lr parsing pages 
kluwer academic publishers 
partridge wright 
predictive parser combinators need values report errors 
functional programming march 
pepper 
grundlagen des 
course notes fachbereich informatik technische universitat berlin 
pepper 
programming language opal 
technical report fachbereich informatik technische universitat berlin june 
pepper 
deductive derivation parallel programs 
paige reif wachter editors parallel algorithm derivation program transformation pages 
kluwer academic publishers 
pepper 
funktionale programmierung opal ml haskell und gofer 
springer verlag 
plasmeijer van 
functional programming parallel graph rewriting 
addison wesley 
jan rekers 
parser generation interactive environments 
phd thesis university amsterdam 
salomaa 
formal languages 
academic press 
schmitz 

teubner 
th 

ein ansatz fur eine allgemeine theorie 
phd thesis fakultat informatik der universitat stuttgart 
sikkel 
parsing schemata 
springer verlag 
soininen 
syntax error handling technique experimental analysis 
acm transactions programming languages 
soininen 
parsing theory vol ii lr ll parsing 
eatcs monographs theoretical computer science 
springer verlag 
thatcher wagner wright 
initial algebra semantics continuous algebras 
journal acm 
tomita 
efficient parsing natural languages 
kluwer academic publishers 
wagner graham 
incremental analysis real programming languages 
acm sigplan conference programming language design implementation pages 
wagner graham 
efficient flexible incremental parsing 
acm transactions programming languages 
waite goos 
compiler construction 
springer verlag 
younger 
recognition context free languages time information control 

