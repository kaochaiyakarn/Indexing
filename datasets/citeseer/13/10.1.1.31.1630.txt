inverse entailment progol stephen muggleton oxford university computing laboratory wolfson building parks road oxford ox qd united kingdom 
firstly provides re appraisal development techniques inverting deduction secondly introduces mode directed inverse entailment generalisation enhancement previous approaches thirdly describes implementation progol system 
progol implemented available anonymous ftp 
re assessment previous techniques terms inverse entailment leads new results learning positive data inverting implication pairs clauses 
keywords learning logic programming induction predicate invention inverse resolution inverse entailment information compression 
inception journal inductive logic programming ilp grown substantial sub area machine learning logic programming see :10.1.1.35.951
success subject lies partly choice core representation language logic programs 
herbrand models logic programs fit neatly distinction examples conjectured theories inductive inference 
syntax logic programs provides modular blocks added removed generalise specialise program 
depth bounded prolog interpreters theorem proving allow efficient testing hypothesised horn clause theories 
importantly turing equivalence logic programs allowing broader range machine learning applications ilp possible restrictive representations 
research ilp spawned variety new theoretical topics 
include problem inverting resolution inversion clausal implication predicate invention closed world specialisation learnability :10.1.1.54.6870
subject diversity sub topics better understood development particular line ideas 
aims firstly provide re appraisal development techniques inverting deduction secondly introduce mode directed inverse entailment generalisation enhancement previous approaches thirdly describe implementation progol system 
stage development ilp attempt solve existing technical restrictions implemented systems 
main approaches described follows 

inverse resolution ir propositional logic 
ir order definite clause logic 
determinate relative general generalisation 
inverse implication 
mode directed inverse entailment 
structured follows 
logical statistical setting ilp introduced section 
followed synopsis results restrictions approaches sections 
remainder sections deals theoretical practical aspects mode directed inverse entailment 
instructions obtaining progol anonymous ftp section 
closes discussion research issues related inverse entailment 
standard definitions taken logic programming prolog inverted middle 
ilp appendix appendix statistical setting ilp described 
properties subsumption lattice described appendix algorithms progol appendix table progol runtimes various data sets appendix logical statistical setting ilp deductive inference derives consequences prior theory says white state particular swan white 
inductive inference derives general belief specific beliefs observing white conjecture white 
deduction induction consistent requirement consistency means observation black swan rules conjecture inductive inference sense inverse deduction 
deductive inference proceeds application sound rules inference inductive inference typically involves unsound conjecture 
conjectures best statistical support observed data 
association probability values hypotheses requires assumption prior probability distribution hypothesis language 
occam razor taken instance distribution assigns higher prior probability simpler hypotheses 
shown distributional assumptions class logic programs pac predictable 
hand demonstrated class time bounded logic programs polynomial time learnable learnable fairly broad families prior probability distributions 
appendix gives details relationship data posterior probabilities learnability 
ilp usual separate elements examples background knowledge hypothesis 
relationship logic programs 
usually consists ground unit clauses single target predicate 
separated ground unit definite clauses gamma ground unit horn clauses 
separation matter convenience example shows 
example white 
swan example represented logic program 
white swan swan swan gamma black swan swan swan black white white swan relationship hold swan swan entailed help argue swan swan background knowledge observations swan 
gamma contain horn clauses refutes problems simply avoided dropping restriction arbitrary logic programs 
inverse resolution propositional logic idea carrying induction inverting deduction investigated depth mathematically th century political economist philosopher science stanley solved tabulation inverse inductive problem involving propositional symbols 
quote book inductive inference modern sounding relevant problems addressed 
induction fact inverse operation deduction conceived exist corresponding operation question relative importance arise 
thinks asking addition subtraction important process arithmetic 
time difference difficulty may exist direct inverse operation integral calculus instance infinitely difficult differential calculus inverse 
similarly allowed inductive investigations far higher degree difficulty complexity questions deduction 
time logicians persuaded boole algebraic approach logic employed array inference rules derived aristotelian 
robinson show deductive inference order predicate calculus effected single rule inference resolution 
inductive inference inverting resolution propositional logic discussed originally technical report analysis inductive inference rules duce system 
george boole algebraic approach deduction inspired truth functional design build logical calculator 
mechanical complete deciding satisfiability propositional clauses variables museum scientific instruments oxford 
inductive inference rules duce inductive inference rules 
concerned definite clause propositional logic 
description inference rules lower case letters represent propositional variables upper case letters represent conjunctions propositional variables 
absorption identification intra construction inter construction duce rules superficially similar deductive rule inference form deductive inference rule called sound entailed call rule inference inductively sound logically entails equivalently entails set inductive inference rules written clause line resolvent clauses line line 
duce inference rules invert applications resolution 
rules set resolution trees deriving examples constructed backwards roots 
set leaves trees represent theory examples derived 
process new proposition symbols examples invented intra inter construction rules 
completeness continuing analogy deduction write say theory derivable inductive inference rules examples senses set inference rules may said complete 
definition weak completeness 
example language hypothesis language subsets order predicate calculus set inductive inference rules 
said weak complete exists shown consisting absorption intra construction weak complete particular hypothesis example language restrictions 
definition strong completeness 
example language hypothesis language subsets order predicate calculus set inductive inference rules 
said strong complete implies duce inference rules section strong complete definite clause propositional calculus 
occam compression duce application inductive inference rule chosen maximise information compression 
definition occam compression 
wffs 
jxj jy number bits required encode occam compression relative jxj gamma jy suppose jp symbols symbols number propositional symbol occurrences number bits encode occurrence 
appendix encoding expression prior distribution 
expresses relative frequency teacher chooses target concept 
assume learner knows uses prior distribution shannon weaver jp gammalog note exponential decay distribution situation learner knows results show class time bounded logic programs polynomial time learnable learnable 
note teacher prior known learner average theories chosen teacher extremely low information content 
alternatively viewed expectation small augmentation existing theory expected short presentation teacher examples 
wff set wffs containing case 
max maximum compression relative compression relative single resolution 
max maximum posterior probability posterior probability equal proof 
equation appendix hje eje je hje maximal jej gamma jhj maximal 
jej gamma jhj hje eje 
hypothesis maximum posterior probability max maximum expected predictive accuracy 
inverse resolution order logic inverse resolution lifted order predicate calculus 
involved algebraic inversion equations resolution 
shows resolution step 
derived base clauses arms 
contrast inductive inference step derives clauses arm clause arm clause base 
literal resolved positive negative duce absorption rule constructs identification rule derives algebraic inversion resolution complex non deterministic solution restricted form absorption implemented cigol logic backwards 
shown independently unique specific solution inductive inference rules :10.1.1.35.951
inverting equations resolution consider resolution model theoretic point view 
applying deduction theorem gives deductive solution absorption 
special case inverting implication section 
clauses conjunctions ground literals 
specific solution corresponds general solution contains maximum set literals derivable solution restricted single depth resolutions clause cardinality finitely bounded 
example recursive list membership 
member xjy member 
member member member member clause member member maintains relationship derivation steps subsumed single step resolution solutions 
contains infinite sequence atoms member member 
owing weak completeness results duce inductive inference rules section absorption intra construction implemented cigol 
compression duce cigol occam compression definition guide choice inverse resolution steps 
encoding measure total number predicate function symbol occurrences logic program 
duce inverse resolution step allowed produced positive compression value 
lead difficulties 

local generalisation 
consider recursive multiplication clause mult dec mult plus large set ground instances valid multiplications compression achievable series inverse resolution steps steps produce compression 

learning positive examples 
noted compression measure cigol allow learning positive data simplest possible hypothesis say consistent 
alternative compression measures suggested 
measures closely allied rissanen minimal description length mdl principle 
problem addressed considering inversion multiple resolution steps saturating clauses :10.1.1.35.951
clause saturation closely related techniques inverse entailment described section 
saturation inverting resolution proof steps deal built predicates 
interpretations predicates computed calling functions 
progol system sections uses mode declarations access interpretations 
learning positive data second problem different nature 
learning positive data predictive accuracy maximised choosing general consistent hypothesis agree new data 
applications grammar learning positive data available grammar produces strings acceptable hypothesis 
suppose modification learning setting appendix teacher draws instances randomly distribution gives learner positive examples target setting need find tradeoff generality complexity hypothesis 
define measure generality hypothesis 
definition generality measure 
wff probability distribution possibly infinite set wffs generality defined hj probability distribution follows 
probability instance drawn randomly entailed note implies 
clearly infinite instance spaces calculated exactly 
central limit theorem sufficiently large random sample proportion entailed arbitrarily estimate 
consider probability distribution 
fm gamma number examples far normalising constant ensure function fm sums 
fm trades complexity hypothesis generality 
note fm varies viewed prior distribution hypotheses 
mdl fm increases discrimination generality increasing numbers examples 
choose hypotheses positive data fm convergence property 
theorem finite elimination false conjectures positive data 
element set wffs probability distribution set wffs non zero probability minimal complexity expression hx infinite series wffs drawn randomly value gamma entail value 
element entail subset exists finite natural number 
proof 
suppose case jhj jt 
suppose jhj jt gamma decreases monotonically exists case 
jhj jt 
exists 
contradicts assumption completes proof 
fm provides basis simplified version compression models defined 
definition positive compression 
wff distribution instance space set examples jhj jej number bits required encode positive sight theorem appears clash fundamental result gold regular languages identified limit positive data 
guaranteed finite number examples lower values compression log fm fm jej gamma jhj gamma log gamma gamma log gamma jej gamma jhj gamma approximation line applies small case close 
relative general generalisations commonly advocated approach learning positive data relative general generalisations clauses see appendix 
suppose section teacher chooses target presents learner examples fx 
background knowledge rlgg hypothesis relative subsumption lattice fewest possible errors commission instances 
approach learning positive data problems 

arbitrary background knowledge 
plotkin showed unrestricted definite clause background knowledge may finite rlgg 

extensional background knowledge 
suppose consist ground unit clauses respectively 
worst case number literals rlgg making construction intractable large 
multiple clause hypothesis 
target concepts multiple clauses learned rlgg single clause 
contrast problems occur chosen set definite clause theories maximum positive compression definition 
suppose hypothesis maximum positive compression 
rlgg maximally specific clauses complexity 
complexity lastly multiple clause hypothesis 
golem golem designed overcome search problems cigol section 
unique construction contrasts highly non deterministic choices involved inverting resolution step 
golem extensional background knowledge avoid problem 
extensional background knowledge generated intensional background knowledge generating ground unit clauses derivable resolution steps 
parameter provided user 
constructed golem forced tractable number literals requiring contain definite clause theories ij determinate 
idea ij determinacy follows 
definite clause form vector variables suppose variables head variables body equivalently written zb determinacy constraint restricts quantification variables body definite clauses hilbert ffl exists exactly quantification 
equivalent requiring predicates background knowledge represent functions 
example hypothesised clause exist valid substitution variables body determinate clauses constrained having variables literal 
ij determinate clauses restricted variable depth depth variable depth defined recursively follows 
definition depth variables 
head max uv variables atoms body containing multiple clause theories learned golem due negative examples 
clause built rlgg set positive examples 
negative examples general 
application experience golem ilp system applied wide variety real world applications 
included construction satellite fault diagnosis model design qualitative physics model finite element mesh design protein secondary structure prediction structure activity prediction drugs 
qualitative physics domain golem hampered requiring large tabulation qsim simulator 
determinacy restriction inappropriate finite element mesh design application 
restrictions golem ilp algorithms discussed 
golem applied various list number theoretic learning tasks involving construction recursive theories 
learning recursive theories awkward golem partly intensional hypothesised base cases augment entirely extensional background knowledge 
golem search subsumption lattice lattice implication clauses 
implication clauses plotkin noted clause subsumes clause notes imply shown example 
example implication subsumption 
consider clauses 
nat nat nat nat efficient methods known enumerating clause subsumes arbitrary clause case clauses imply known problem inverting implication clauses 
inability invert implication clauses limits completeness inverse resolution subsumption place clause implication 
gottlob proves number properties concerning implication clauses 
lemma notable 
lemma gottlob lemma 
non tautological clauses 
gamma sets positive negative literals clauses gamma implies gamma gamma attempt solve inverting implication problem matwin introduced sub unification process matching sub terms produce demonstrate sub unification able construct recursive clauses fewer examples required ilp systems golem foil 
operations described matwin shown number examples clear general mechanism various general properties implication clauses investigated 
particular shown lee subsumption lemma corollary 
corollary implication recursion 
clauses 
tautology clause constructed repeatedly self resolving difference subsumption implication pertinent example self resolve 
attempts extend inverse resolution mixture inverse resolution lgg solve problem 
extended inverse resolution method suffers problems non determinacy cigol 
almquist lgg suffers standard problem intractably large clauses see section 
approaches incomplete inverting implication technique complete restricted form entailment called implication 
shown certain recursive clauses clauses imply subsume logically equivalent clause renaming variables clause specific form subsumption lattice 
called self saturation self saturation example simply shown exist definite clauses finite self saturation 
inverting entailment clauses section gives complete efficient method inverting implication function free definite clauses 
techniques inverting entailment deduction theorem 
define definite sub 
definition definite sub 
definite clause 
herbrand base restricted predicate symbol minimal herbrand model desk atom skolem constants replaced corresponding variables gamma 
sub set definite clauses desk 
arbitrary definite clauses infinite sub set function free definite clauses 
shown function free clauses bound arity predicates cardinality set polynomially bounded number variables cardinality sub set 
function free definite clause arity predicate symbol head number variables sub cardinality proof 
arguments heads clauses length permutations variables permutations 
main theorem concerning sub 
theorem definite non tautological clauses sub exists proof 
suppose exist lemma heads predicate symbol 
follows satisfiable 
herbrand theorem case herbrand model 
lemma body subsumes body exists ground substitution elements body true model substitution head false herbrand model herbrand model 
construction definition predicate symbol contradicts assumption completes proof 
theorem efficiently enumerate function free definite clauses finite set sub constructed 
clauses subsume clause enumerated efficient interleaved enumeration subsumption lattice 
function free order predicate calculus decidable clauses enumerated testing 
example factorial 
gamma gamma overly specific recurrence formula factorial function 
formula represented clause predicate symbols factorial decrement multiply 
variables follows cardinality 
contains clause clause implies subsume corresponds general recurrence factorial 
gamma example demonstrates clauses function symbols example dealt function free flattening 
example flattening inverse implication 
clause nat nat flattened function free clause nat nat defined 
nat nat subsumed nat nat 
clause implies subsume nat nat inverting entailment inverse resolution subsumption oriented approaches induction re assessed previous sections 
demonstrated great deal clarity simplicity achieved approaching problem direction model theory resolution proof theory 
duce inductive inference rule sound deductive sense viewed stating relationship cigol solutions absorption simply rewriting inductive specification equivalent deduction oriented relationship lastly shown solution plotkin year old problem generalising subsumption achieved relative ease simply viewing solutions clauses eliminate herbrand models consider general problem specification ilp section light 
background knowledge examples find simplest consistent hypothesis simplicity measured relative prior distribution demonstrated example general arbitrary logic programs 
clause simplest explain example simpler 
consider case single horn clauses 
seen generalised form absorption relation section rearranged similarly give single clauses logic programs consisting ground unit clauses 
potentially infinite conjunction ground literals true models true model contain subset ground literals 
subset solutions considering clauses subsume 
complete set candidates considering clauses subsume sub 
section 
example various examples 
shows various 
case clauses subsume include reached order absorption section 
second case definite clauses subsume reached order version duce identification operator section 
form identification anim pet 
nice dog 
nice dog pet pet dog 
anim 
bird 
tweety 
tweety bird tweety bird 
tweety 
white swan 
black swan 
black swan white swan 
sentence 
sentence 
sentence sentence 
specific clause 
various versions background knowledge example 
general form kakas abduction central interest theory revision alterations theory revision range definitions hierarchical set predicates 
third case demonstrates constraints horn clauses learned negative examples clause black white subsumes 
fourth case clauses subsumes flattened 
see example dcg grammar rule sentence ajx sentence definite mode language general infinite cardinality 
progol uses mode declarations constrain search clauses subsume 
see section 
definition mode declaration 
mode declaration form atom atom recall integer atom ground atom 
terms atom normal 
normal term constant function symbol followed bracketed tuple terms 
place marker type type type type constant 
mode declaration denotes atom place markers replaced distinct variables 
sign positive negative 
instance mode declarations 
plus int int int append list list list append list list int int recall bound number alternative solutions instantiating atom 
simplicity assume modes recall meaning solutions 
defines clause progol definite mode language definition definite mode language 
definite clause defined total ordering literals set mode declarations 
definite mode language atom declaration place marker type type replaced variables place marker type replaced ground term atom body atom declaration place marker type type replaced variables place marker type replaced ground term variable type atom type type atom golem progol constructs clauses bounded depth see definition section 
definition depth bounded mode language 
definite clause defined total ordering literals set mode declarations 
variables depth definition 
example factorial revisited 
reconsider example int int int int int int int int clause 
specific clauses progol searches bounded sub lattice example relative background knowledge mode declarations sub lattice general element 
empty clause general element specific element denotes derivation empty clause resolutions 
definition specific clause natural numbers set horn clauses definite clause set mode declarations containing exactly specific potentially infinite definite clause 
specific clause 
progol constructs algorithm appendix 
theorem correctness algorithm 
defined definition 
algorithm returns alphabetic variant proof 
induction 
step head definite mode language definition type type replaced variables type place marker replaced ground terms variable depth definition 
construction head returned subsumes inverting function hash gives substitution variables terms substitution specific variable replaced unique term 
proves base case 
suppose including algorithm correctly constructs specific clause specific clause subsumes 
shown implies hold 
consider step 
type place markers atom replaced variables depth represent terms 
terms placed type head step type step earlier value type place markers replaced variables depth type ground terms 

construction subsumes atom body substitution substitution specific variables map unique terms 
corresponds combinations type substitutions alphabetic variant maximally specific clause subsumes 
proves step completes proof 
time complexity algorithm proportional cardinality theorem cardinality defined definition jm denote cardinality number type type occurrences bounded constants gamma respectively 
number type type occurrences bounded gamma respectively 
recall bounded constant cardinality bounded jj gamma ij proof 
induction 
clause contains head cardinality 
proves base case 
assume true including show 
number terms associated type head type body gamma jj gamma kj replace type place markers jm declarations atom recalled times giving cardinality jj gamma proves step completes proof 
default progol typically 
cases relatively atoms true herbrand model jm usually case cardinality atoms 
refinement refinement operators generalising example relative background knowledge progol constructs searches general specific sub lattice single clause hypotheses sub lattice bounded 
search better constrained general specific searches mis foil sub lattice searched bounded 
purposes searching lattice clauses ordered subsumption shapiro introduced concept refinement operators 
suppose potentially infinite set clauses element refinement operator ae defined ae ae said sound ae case ae fcg ae exists ae gamma ae 
closure ae ae ae 
ae complete alphabetic variant ae 
ae finite cardinality ae finite 
ae proper clause ae case oe shown shapiro ae complete 
shown exist ae finite proper complete 
redundancy refinement operators investigated 
refinement operator ae redundant exist clauses ae ae alphabetic variant mis foil employ redundant refinement operators clause reached repeatedly applying ae various refinement operator progol refinement operator progol designed avoid redundancy maintain relationship clause case exists substitution literal exists literal clearly uniquely defined subset consisting exists non deterministic approach choosing arbitrary subset set involves maintaining index value cardinality decide include kth element clearly set series choices corresponds set subsets subset exactly series choices 
avoid redundancy maintain subsumption progol refinement operator maintains 
definition progol refinement operator 
defined definition cardinality natural number clause substitution literal corresponding mode denoted simply vm despite sign function symbols 
variable splittable corresponds type type corresponds type 
hc ae hc ki 
flg hl ffi 
hp vm ffi initialised um kth literal 
splittable 
splittable new variable dom fv definition variables form set equivalences classes variables clause subsumes write equivalence class set variables 
second choice definition ffi adds new variable equivalence class referred splitting variable note definition variable splittable corresponds type resulting clause violate mode declaration language see definition 
example variable splitting 
example applying ae list reversal 
suppose consists mode 
reverse list list list intj list reverse list list append list int list types background knowledge defined follows 
term list list hjt list erm erm reverse append append hjt append example 
reverse reverse fd ag reverse fd ag reverse jg reverse reverse jg reverse fh cg reverse jg applications ae :10.1.1.54.6870
case follows 
reverse bjc reverse append hc ae :10.1.1.54.6870
hc shown table 
suppose reverse jg fd cg hc ae hc ki 
hc shown second table 
analogy shapiro ae talk soundness progol ae 
lemma soundness progol ae 
defined definition cardinality natural number clause substitution hc ae hc ki 
proof 
suppose lemma false 
case exists hc ae hc ki 
definition case 
case flg hl ffi 
definition ffi contradicts assumption completes proof 
shapiro refinement operator define closure set progol ae 
stand triples form hc ki 
ae fxg ae exists ae gamma ae 
closure ae ae ae 
example shows progol ae complete due choice ordering example incompleteness search 
contain definitions dec addition plus clause mult appropriate mode declarations example clause mult 
clause mult dec plus plus mult mult ordering element progol ae containing clause mult dec mult plus complexity ae order analyse complexity ae introduce incremental variant bell number combinatorics 
mth bell number number ways set cardinality partitioned non empty equivalence classes 
lemma number splits variable 
suppose ffi definition arguments kth literal splittable occurrences variable suppose cardinality number variants function follows 
proof 
substitution 
consider occurrence ffi choice split case split case 
case set variants crossed set choices crossed set variants remaining occurrences case new variable set variants crossed fv ug crossed set variants remaining occurrences gives total variants partial tabulation function shown 
bounds natural numbers 
proof 

consider terms recurrence gamma case gamma 
gamma gamma 
example suppose definition fv ug occurrences type 
lemma gives 
variants 
bell function expressed simply 
partial tabulation function position give function cardinality ae 
theorem cardinality ae 
definition 
suppose contains splittable variables non splittable variables 
denote respectively number occurrences splittable non splittable variables denote respectively number 
cardinality ae hc ki jae hc ki pi mx pi proof 
definition ae chooses cases 
second choice produces unique solution cardinality ae greater cardinality associated function ffi 
case ffi applicable non splittable variables 
occurrences choices giving mx variants 
set substitutions crossed set variants crossed set variants gives total pi mx pi different substitutions function ffi value plus cardinality ae 
seen jae hc ki exponential reiterates requirement indicated theorem sake polynomial tractability bounded respectively constants gamma implementation ae progol simply decodes natural numbers jae hc ki clauses updates appropriately 
details decoding process omitted 
searching subsumption lattice search subsumption lattice progol applies algorithm find clause maximal occam compression definition 
encoding measure total number atom occurrences reduced logic program 
logic programs reduced eliminating redundant clauses 
definition redundant clauses 
clause set clauses 
redundant definition reduced set clauses 
set clauses 
reduced iff contains redundant clauses 
progol algorithm finding maximal occam compression algorithm appendix 
algorithm searches state space defined elements ae 
lookahead function increase efficiency searching variable chaining clauses 
clause variable chaining contains chain variables type type respectively head type type respectively atom body recursive clause reversing lists reverse cjd reverse append see example variable chaining 
clause called complete type variable head body clause complete mode declarations example 
lemma function defines complete lookahead 
hc ki definition section 
complete hc ae hc ki case jc gamma jcj proof 
mathematical induction suppose body lemma holds base case 
suppose mathematical induction complete hc case jc gamma jc suppose exists ae 
definition case complete case jc gamma jcj flg jc gamma jcj proves step completes proof 
correctness time complexity note order ensure polynomial tractability algorithm user required provide bound cardinality clause body 
theorem correctness algorithm 

definition 
ae set elements hc ki say clause explains example 
contain explains algorithm returns compression 
algorithm returns explains exist explains proof 
contradiction 
assume theorem false 
algorithm terminate exists explains compression returned returned explain returned explains exists explains consider 
ae definition adds literal moves forward finite number elements cycle say transferred open closed steps reappears open due construction step 
open contain elements due third condition predicate prune 
finite number cycles operation terminates finite time 
refutes 
suppose exists explains compression returned step 
step entered step case open terminated false closed contained explained 
exists explains prune true eventually transferred closed 
condition prune true worst succeeded best terminated 
second condition prune true 
third condition prune true refutes 
suppose returned explain 
returned step terminated true case 
construction definition soundness ae definition 
follows 
explains 
refutes 
lastly suppose returned explains exists explains closed best closed return step exist open ae 
case terminated predicate refutes completes proof 
worst case algorithm consider elements theorem 
theorem cardinality definition 
gamma theorem gamma jsj denote cardinality set js 
proof 
elements hc ki ae jcj 
view construction choice possible repeats elements followed choice 
simplest treat repeat literals single atom bounds calculate worst case number variants 
case 
ways choosing elements ways choosing 
js 
theorem find js order ij 
clearly tractability small constants 
cover set algorithm progol uses simple cover set algorithm employed michalski aq family algorithms 
repeatedly generalises examples order progol source file adds generalisation background knowledge 
examples redundant relative background knowledge removed redundancy definition 
cover set algorithm appendix 
clearly algorithm terminates jej iterations 
note clause added background knowledge 
prolog equality assumed completely defined axiom identity effect herbrand models logic program 
improve readability 
instance clause section simpler clause 
reverse ajb reverse append note declarations example followed algorithm allows progol search term structure hypothesised clauses 
despite fact progol refinement operator definition considers variable variable substitutions map hypothesised clauses subsets progol system progol written author 
progol version source code example files manual pages freely available academic research anonymous ftp ftp comlab ox ac uk directory pub packages ilp progol 
design methodology progol user standard prolog interpreter augmented inductive capabilities 
syntax examples background knowledge hypotheses dec prolog usual set prefix postfix infix operators 
horn clauses representing constraints represent negative examples constraints 
stored internally clauses head false 
statement placed progol source file 
white stored internally definite clause 
false white way testing negative examples general constraints reduces seeing false provable 
clause constraints learned ground unit clauses predicate false 
example progol distribution dataset animals pl 
standard library primitive predicates described clocksin mellish built progol available background knowledge 
command line progol infix predicate learning ranges integers 
gamma int int 
int int 
int 
progol prompt gamma int built single arity predicate true integers 
note progol queries terminated usual prolog 
allows queries distinguished assertions 
assertions terminated progol prompt level 
user request examples generalised prompt terminating example clause 
predicate search executed statement simply show user clause example 
mode declarations allow interaction 
gamma 
specific clause 
clause declarations 
step algorithm goals 

recalled times succeed substitutions int place markers replaced respectively int place marker replaced unique variable hash function described algorithm 
progol interactively convenient run batch mode 
case called operating system shell progol name example file argument 
progol simply generalises predicate declared shows results output 
progol learn ranges functions numeric data 
integer floating point simply making built predicates best exemplified progol dataset order qualitative regression applied newton inverse square law artificial floating point data 
choice engineering complete prolog interpreter taken order induction class efficient operation footing deductive theorem proving 
allows implementation low level operations depth bounding theorem prover rapid virtual assertion retraction clauses clause set 
results results series experiments involving progol learning predict mutagenic molecules 
description progol doing qualitative regression 
qualitative regression carried mode declarations define family different functions linear polynomial term exponential competition fit data 
equation solver supplied user defined background knowledge 
appendix gives table runtimes sparcstation learning various examples distribution version progol 
numbers clauses gamma dataset 
note datasets animals exp family set involve learning series related predicates 
runtimes comparable foil despite fact foil incomplete heuristic search find clauses 
foil uses extensional background knowledge intensional background knowledge progol 
traces line development followed author investigating induction inverse deduction 
shown idea inverting resolution proofs duce cigol greatly simplified considering special case inversion entailment 
notion inverting entailment fundamental nature inverting proof model theory underlies proof 
approach led development new state art ilp system called progol available academic research purposes anonymous ftp see section 
example progol develops specific clause user defined mode language uses guide search clauses subsume invocation search returns clause guaranteed maximally compress data 
despite admissibility search learning times appendix comparable foil algorithm carries truncated heuristic search allows extensional background knowledge 
section shows various ways progol powerful 
progol deal effectively third form 
progol prove positive ground facts negative ones possible construct form second entry 
applications theory revision 
purposes theory revision progol need strategy specialising general clauses 
construction sub section allow progol find generalisations recursive clauses fourth entry 
second fourth form generalisation lead multiple definite clauses 
dealing multiplicity clauses require improvements progol search techniques 
incompleteness search see example needs addressed 
definition suggests way progol learn effectively provided positive example data 
real world applications areas natural language learning common find positive data sources 
learnability results shown progol 
learnability appendix offers promising direction results 
author believes inverse entailment offers new avenues rapidly maturing research area inductive logic programming 
due wife cortes shown super human tolerance long incubation writing helped proof reading various versions 
author donald pointing foundational wholly disregarded stanley 
due david page donald michie helpful discussions advice ashwin srinivasan produced initial prolog version progol 
valuable suggestions concerning learnability model tony hoare bill mccoll michael kearns paul vitanyi 
supported partly esprit basic research action ilp project epsrc gr experimental application development ilp epsrc advanced research fellowship held author 
author supported non research fellowship wolfson college oxford 
bain muggleton :10.1.1.54.6870
non monotonic learning 
michie editor machine intelligence 
oxford university press 
bratko muggleton 
learning qualitative models dynamic systems 
proceedings eighth international machine learning workshop san mateo ca 
morgan kaufmann 
clocksin mellish 
programming prolog 
springer verlag berlin 
cohen 
learnability restricted logic programs 
muggleton editor proceedings rd international workshop inductive logic programming technical report ijs dp josef stefan institute ljubljana slovenia pages 
conklin witten 
complexity induction 
technical report dept computing information science queen university kingston ontario canada 
muggleton 
application inductive logic programming finite element mesh design 
muggleton editor inductive logic programming 
academic press london 

inductive logic programming implementation 
phd thesis oxford university computing laboratory oxford 
feng 
inducing temporal fault rules qualitative model 
muggleton editor inductive logic programming 
academic press london 

confirmation theory machine learning 
proceedings second inductive logic programming workshop tokyo 
icot tm 
gold 
language identification limit 
information control 
gottlob 
subsumption implication 
information processing letters 
grobelnik 
markus optimized model inference system 
proceedings ecai workshop logical approaches machine learning 
almquist 
learning missing clauses inverse resolution 
proceedings international conference fifth generation computer systems pages tokyo 
icot 
almquist 
generalisation clauses 
phd thesis stockholm university 

mechanisation deductive inference 
philosophical transactions royal society london 

principles science treatise logic scientific method 
macmillan london 
kakas kowalski toni 
abductive logic programming 
journal logic computation 
king muggleton lewis sternberg 
drug design machine learning inductive logic programming model relationships analogues binding 
proceedings national academy sciences 
krishnamurthy 
combinatorics theory applications 
ellis horwood chichester england 
van der cheng 
subsumption refinement model inference 
brazdil editor proceedings th european conference machine learning volume lecture notes artificial intelligence pages 
springer verlag 
van der cheng 
existence nonexistence complete refinement operators 
bergadano de raedt editors proceedings th european conference machine learning volume lecture notes artificial intelligence pages 
springer verlag 
matwin 
sub unification tool efficient induction recursive programs 
proceedings ninth international machine learning conference los altos 
morgan kaufmann 
lee 
completeness theorem computer program finding theorems derivable axioms 
phd thesis university california berkeley 
li vitanyi 
kolmogorov complexity applications 
springer verlag berlin 
ling 
learning past tense english verbs symbolic pattern vs connectionist models 
journal artificial intelligence research 
lloyd 
foundations logic programming 
springer verlag berlin 
meltzer 
power amplification automatic theorem proving 
meltzer michie editors machine intelligence pages 
edinburgh university press edinburgh 
michalski larson 
incremental generation vl hypotheses underlying methodology description program aq 
isg computer science department univ illinois urbana champaign 
muggleton 
duce oracle approach constructive induction 
ijcai pages 
kaufmann 
muggleton 
strategy constructing new predicates order logic 
proceedings third european working session learning pages 
pitman 
muggleton :10.1.1.35.951
inductive logic programming 
new generation computing 
muggleton 
inverting resolution principle 
machine 
oxford university press 
muggleton 
inverting implication 
proceedings second inductive logic programming workshop tokyo 
icot technical report tm muggleton 
bayesian inductive logic programming 
cohen hirsh editors proceedings eleventh international machine learning conference pages san mateo ca 
morgan kaufmann 
muggleton 
inductive logic programming derivations successes shortcomings 
sigart bulletin 
muggleton 
predicate invention utilization 
journal experimental theoretical artificial intelligence 
muggleton buntine 
machine invention order predicates inverting resolution 
proceedings fifth international conference machine learning pages 
kaufmann 
muggleton feng 
efficient induction logic programs 
proceedings conference algorithmic learning theory tokyo 
ohmsha 
muggleton king sternberg 
protein secondary structure prediction logic machine learning 
protein engineering 
muggleton page 
self saturation definite clauses 
wrobel editor proceedings fourth international inductive logic programming workshop pages 
gesellschaft fur mathematik und mbh 
gmd studien nr 
muggleton page 
order learning inductive learning higher order logic 
technical report prg tr oxford university computing laboratory oxford 
muggleton page 
learnability model universal representations 
technical report prg tr oxford university computing laboratory oxford 
muggleton de raedt 
inductive logic programming theory methods 
journal logic programming 
muggleton srinivasan bain 
compression significance accuracy 
sleeman edwards editors proceedings ninth international machine learning conference pages san mateo ca 
morgan kaufmann 
nilsson 
principles artificial intelligence 
tioga palo alto ca 
plotkin 
note inductive generalisation 
meltzer michie editors machine intelligence pages 
edinburgh university press edinburgh 
plotkin 
automatic methods inductive inference 
phd thesis edinburgh university august 

experiment automatic induction 
meltzer michie editors machine intelligence pages 
edinburgh university press edinburgh 
quinlan 
learning logical definitions relations 
machine learning 
quinlan 
past tenses verbs order learning 
zhang lukose editors proceedings th australian joint conference artificial intelligence pages singapore 
world scientific 
reynolds 
transformational systems algebraic structure atomic formulas 
meltzer michie editors machine intelligence pages 
edinburgh university press edinburgh 
rissanen 
modeling shortest data description 
automatica 
robinson 
machine oriented logic resolution principle 
jacm january 
rouveirol 
extensions inversion resolution applied theory completion 
muggleton editor inductive logic programming 
academic press london 
rouveirol 
puget 
simple general solution inverting resolution 
ewsl pages london 
pitman 
shannon weaver 
mathematical theory communication 
university illinois press urbana 
shapiro 
algorithmic program debugging 
mit press 
srinivasan muggleton king sternberg 
mutagenesis ilp experiments non determinate biological domain 
wrobel editor proceedings fourth international inductive logic programming workshop 
gesellschaft fur mathematik und mbh 
gmd studien nr 
srinivasan muggleton king sternberg 
effect background knowledge inductive logic programming case study 
technical report prg tr oxford university computing laboratory oxford 
srinivasan muggleton king sternberg 
theories mutagenicity study order feature induction 
technical report prg tr oxford university computing laboratory oxford 
wirth 
completing logic programs inverse resolution 
ewsl pages london 
pitman 
definitions logic formulae order predicate calculus variable represented upper case letter followed string lower case letters digits 
function symbol lower case letter followed string lower case letters digits 
predicate symbol lower case letter followed string lower case letters digits 
variable term function symbol immediately followed bracketed tuple terms term 
term function symbols variable 
prolog integers function symbols terms equivalently denoted jt equivalently denoted 
predicate symbol immediately followed bracketed tuple terms called atomic formula atom 
atom formed formula wff 
wffs implied wffs 
conjunction disjunction 
variable wff exists wffs 
said universally quantified existentially quantified wff said function free contains function symbols 
literals atom 
case called positive literal called negative literal 
set literals called clause 
empty clause represented 
clause represents disjunction literals 
clause fa equivalently represented variables clause implicitly universally quantified 
horn clause clause contains positive literal 
definite clause clause contains exactly positive literal 
positive literal horn clause definite clause called head clause negative literals collectively called body clause 
set clauses pair clauses share common variable called clausal theory 
empty clausal theory represented clausal theory represents conjunction clauses 
clausal theory fc equivalently represented 
clausal theory said clause normal form 
wff transformed equivalent wff clause normal form 
clause case clause normal form variables existentially quantified 
put clause normal form substituting occurrence variable unique constant process replacing existential variables constants called 
unique constants called skolem constants 
set horn clauses called logic program 
apart representing empty clause empty theory symbols represent logical constants false true respectively 
wff term 
vars denotes set variables said ground vars 
substitutions models fv said substitution variable term distinct set fv called domain dom ft range rng 
lower case greek letters denote substitutions 
wff term fv substitution 
instantiation written formed replacing occurrence atom subsumes atom exists substitution clause subsumes clause exists substitution herbrand universe wff set ground terms composed function symbols herbrand base wff set ground atoms composed predicate function symbols interpretation total function ground atoms herbrand interpretation wff interpretation domain herbrand base equivalently represented subset atoms herbrand base interpretations assumed herbrand 
atom true false 
wff true false false 
wff true true false 
wff true true false 
wff true true false 
variable wff true term herbrand universe wff tg true false variable wff true true false 
interpretation model wff true wff satisfiable exists model unsatisfiable 
consequently unsatisfiable 
herbrand theorem states wff satisfiable herbrand model 
logic program unique herbrand model model atom true true herbrand models wffs 
say semantically entails model model wffs 
deduction theorem inference rule 
said sound suppose set inference rules containing wffs 
formed replacing occurrence say syntactically entails inference rules set inference rules said deductively sound complete rule sound wffs 
say general conversely specific resolution substitution said variable renaming dom rng variables 
wffs 
exists variable renaming said alphabetic variants 
wffs said standardised apart exists variable renaming fu vars vars substitution said unifier atoms 
general unifier mgu unifiers fl exists substitution ffi ffi afl 
clauses atom 
sound inference rule called resolution 
said resolvent clauses fag fa standardised apart mgu atoms clausal theory 
robinson defined function recursively follows 
set resolvents constructed pairs clauses gamma 
robinson showed unsatisfiable contains empty clause 
hypotheses probabilities learnability learnability variant learnability framework 
teacher starts choosing distributions family distributions concept descriptions wffs associated bounds time taken test entailment instances ground wffs respectively 
teacher uses carry infinite series teaching sessions 
session target theory chosen provide labels true false set instances randomly chosen distribution teacher labels instance series hx xm 
hypothesis said explain set examples entails consistent basis prior posterior probabilities hypotheses 
series labelled instances turing machine learner produces sequence hypotheses hh explains fe suggested expected time bounded fixed polynomial function teacher stops session learner suggests hypothesis hm expected error ffl label xm chosen randomly hf gi said learnable exists turing machine learner choice ffi ffl ffi ffl probability gamma ffi sessions fixed polynomial function ffi ffl bayesian interpretation setting shows effect fe probabilities associated hypotheses learner hypothesis language laid xaxis prior probability measured axis descending dotted line represents bound prior probabilities hypotheses consideration examples hypotheses explain marked vertical bars 
prior probability simply sum probabilities hypotheses conditional probability case explains 
posterior probability bayes theorem hje hypotheses explains data hje increase monotonically increasing different hypotheses explain holds 
je je subsumption general generalisation late success robinson resolution procedure produced considerable interest problem inducing order formulae 
meltzer carried initial investigations generalisation ground formulae replacement constants variables 
implementing approach meltzer decided bound number resolutions involved checking hypothesis examples 
important innovation progol section 
alternative approach reynolds plotkin investigated problem finding general generalisations atoms 
plotkin started suggestion private communication just unification algorithm fundamental deduction converse induction 
relationship lgg unification depicted 
atom common generalisation atoms exist substitutions ff fi gff atom lgg general generalisation lgg common generalisation common generalisation exists substitution ffi lgg common instance general instance similarly defined see 
case general instance robinson calls ff fi general unifier robinson describes algorithm constructing general unifier atoms 
robinson unification algorithm basis resolution theorem proving 
plotkin reynolds describe efficient algorithm computing general generalisation atoms 
equivalence class atoms variable renamings reynolds showed set equivalence classes atoms augmented symbols form non modular lattice 
lgg mgi commutative associative distributes 
mgi lgg relationship lgg mgi 
plotkin extended investigation clauses ordered subsumption 
clause subsumes clause exists substitution just atoms clause respectively common generalisation common instance clauses general generalisation lgg general instance mgi unique renaming common generalisation common instance case lgg mgi cardinality general generalisation clauses bounded product cardinalities clauses 
plotkin went define lgg clauses relative clausal background knowledge relative general generalisation clauses rlgg potentially infinite arbitrary consists ground unit clauses rlgg clauses finite 
cardinality rlgg clauses relative ground unit clauses worst case cardinality order making construction rlgg intractable 
progol algorithm construction specific clause algorithm algorithm constructing 
natural numbers horn clauses definite clause set mode declarations 
hash hash function uniquely maps terms natural numbers clause normal form logic program hi 

return 
declaration substitution copy corresponds type replace replace hash add corresponds type 
add 
return 
fv variables type theta theta set tuples terms corresponds set terms type associated term tested particular type calling prolog type goal 
ht copy fv prolog depth bound succeeds goal set answer substitutions theta theta corresponds type replace replace hash add corresponds type 
add 
goto step 
algorithm finding clause maximal compression firstly define auxiliary functions algorithm 
definition auxiliary functions 
examples set horn clauses 

definition section definition section 
type variable head type head min uv type variables atoms body contain type occurrences state form hc ki 
user defined parameter maximal clause body length 
jsj denotes cardinality set gj gj jcj gamma fv body cg min vs gamma gamma best state exist prune true true true false terminated true best case false algorithm algorithm searching 
definition 

open fh ig closed 

best open open open 

closed closed fsg 

prune goto 
open open ae 

terminated closed open return best closed 

open print compression return 

goto 
progol cover set algorithm definition 
definite clause conjunction atoms predicate symbol conjunction atoms predicate symbols 
clause called derived successively resolving away clause 
algorithm cover set algorithm 
theorem subset corresponding atoms declarations 
return 
example 
construct algorithm 

construct state algorithm 

definition 


fe 

gamma 
goto 
progol runtimes data set predicate je je gamma jbj jhj time sec animals false class append append arch arch chess move cyclic cyclic delete delete exp plus mult exp family parent grandfather grandparent grammar illegal min min nim won order order order order order parity parity qsort qsort range inrange reverse reverse set member pair subset sumx sumx train 
