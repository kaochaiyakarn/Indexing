temporal logic refinement compositional verification concurrent systems dominique ery cnrs inria lorraine bp es nancy france 
simple elegant formulation compositional proof systems concurrent programs results refinement temporal logic semantics 
refined temporal language propose closed stuttering provides fully semantics respect chosen observation level avoids incorporating irrelevant detail temporal semantics parallel programs 
compositional verification concurrent program design implementation coarser grained program finer grained easily practicable setting new temporal logic 
known problem verification construction concurrent programs specifications satisfied process viewed isolation invalidated actions performed processes executing parallel 
composition principles provide way overcome problem 
compositional verification properties composite system established properties components knowledge interior structure 
conversely compositional refinement method provides mechanism deriving refinements composed system components 
traditionally composition principles specification verification concurrent systems considered difficult establish previous shown difficulty lies formulation compositional rule parallel composition 
opinion formulating compositional rule parallel composition careful initial stage defining specification language semantics 
explores point proposes new semantics temporal logic formalism required fully 
semantic criterion define appropriate basis compositional theory specification verification concurrent programs 
temporal theory specifying programs reasoning parts general part provides axioms rules deriving general theorems formulas valid model specific interpretation symbols priori domain part provides axioms rules reasoning specific data domains program specification refer program part restricts set considered models correspond behaviour specific program verified 
classical temporal logic provides powerful tool global specification non compositional verification existing concurrent programs 
logic offers poor support modular specification verification consequently systematic design concurrent programs hard impossible setting 
lack modularity comes fact semantics temporal formalism defined terms global state behaviours way temporal properties component viewed context away invisible state changes performed components 
invariance stuttering useful concept may help find solution problem 
notion means behaviour satisfies formula behaviour equivalent modulo state changes considered irrelevant satisfies purpose provide complete methodology compositional specification verification development concurrent systems 
term concurrent systems refer open systems may involve concurrent processes 
open system interacts environment contrast closed system completely self contained 
programming notation ipl describing concurrent modules open system introduced computational model representation module semantics defined 
obtained semantics compositional sense semantics composite system computed formal relation semantics sub modules 
temporal logic mtl defined specification language derived establishing closed connection computations ipl programs models mtl formulas 
logic state 
system may specified levels abstraction highest level properties described terms stuttering invariant temporal formulas implementations programs intermediate programming language ipl 
highest level specification deal expected behaviour system avoiding efficiency architectural details implementation 
details introduced stage design process parallel algorithmic solution available 
organized follows 
section programming notation concurrent systems defined 
section state problems wish overcome temporal logic 
section introduce concept stuttering 
response abstraction problem refines temporal semantics basic operators cause trouble abstraction 
show resulting temporal logic fully stuttering 
section give axiomatization refined temporal logic mtl sketch soundness 
justify advantages new logic mtl give section formulation ipl programs semantics mtl show compositional proof system verification derivation ipl programs built setting obtained temporal theory 
show implementation concurrent system finer grained equivalent system formalized elegant way theory 
section example illustrating compositional construction proofs properties ipl programs developed theory 
section concludes describing related 
programming notation concurrent systems concurrent systems described language ipl slight modification language introduced 
purpose modifications give compositional open semantics ipl programs aid design compositional proof system ipl 
particular introduce dual mode environment mode external defined 
external represents sends executed environment represents receives executed environment 
uniform kind statement primitive describe programs simplifies technique needed analyse programs 
syntax central notions ipl module statement individual transition 
excerpt syntax 
module statement form module interface body interface declares moded channels module communicates environment body describes data transitions module 
interface module interface dcl chg modes dcl ch type init important concept abstraction define 
concurrent modules communicate asynchronous message passing unbounded channels 
module communicate environment modules interface modes assigned channels 
channel declared transition may receive resp 
send declared mode resp 

transition module parallel may receive resp 
send declared viewed mode resp 
external 
modes call internal modes declare kind module may channel external call environment modes declare kind environment may channel 
module external definition corresponds environment module definition corresponds environment 
close correspondence permits define fully compositional semantics ipl 
body module body var dcl init statement init init variable label dcl type local init statement transition label guard action label action skip assignment random send receive guard expression send channel expression receive channel variable concurrent system net syntax net net net channels denote respectively channel hiding channel renaming 
module operates finite set unshared variables 
modules communicate explicitly channels 
certain variables may local operational point view means observational behaviour module abstracted 
local variables execution module variables observable behaviour depend values take execution 
similarly channels hidden binder net channels variables obtained net renaming interface compatibility modules operate parallel provided compatible interfaces 
define interface compatibility complete definition compositional definition interfaces networks 
instance interface km obtained interfaces notation module 
ffl interface denotes interface ffl iew denotes set viewed channels variables module contains nonlocal variables non hidden channels declared ffl chan inter denotes te set channels declared inter 
definition 
modules 
interface compatible compat declaration channel iew iew satisfies requirements types declarations match conjunction clauses supposed true specified consistent declarations specifies resp 
mode specifies external resp 
mode 
notation module modem modem denote respectively set internal modes set environment modes assigned channel module modem df modem modem 
interface networks 
parallel composition km channel hiding free modules modules binder occur inter inter respective interfaces 
ffl interface km df inter phi inter chan inter phi inter chan inter chan inter chan inter chan inter modem modem modem modem modem modem chan inter chan inter modem modem chan inter chan inter modem modem definition assume binder free equations move needed complete definition 
equations hold proved semantics defined kc km iew kc km iew new channel variable 
channel hiding module inter interface 
ffl interface df inter chan inter chan inter modem modem modem chan inter fcg modem modem 
renaming module inter interface 
ffl interface df inter additional notation theta module inter theta module inter delta theta module inter phi inter kb theta module inter delta theta module inter theta module inter delta theta module inter notation useful relate ipl modules specification modules section 
proposition 
relation compat satisfies properties modules compat compat ii compatible modules 
compat jjm iff compat compat proof 
straightforward definitions definition interfaces networks 
example 
consider modules module external channel integer channel integer var integer init true true true module channel integer var integer init theta true module external channel integer channel integer channel char var integer init true true gamma true interface compatible compatible concurrent programs km km syntactically defined km km 
interface km channel integer channel integer channel char interface km channel integer channel integer channel char semantics basic computational model assign meanings concurrent programs fair transition system fts short 
associate ipl module fair transition system sm pi sigma tm theta jm fm consists components pi state variables cm ym 
control variable ranges lm lm denotes set locations cm denotes set channels declared interface ym denotes variables sigma states possible interpretations variables pi consistent types 
tm transitions 
internal transitions transitions ff associated individual transitions ff body characterize individual transitions relations express operational semantics follows 
non communication transitions communication transitions transitions ff associated relations ae ff skip ffl jcj tl hd note relation ae ff associated transition ff don express unchanged transition 
instance ff omit say variable assume implicitly expressed relation ae ff 
environment transitions characterize environment follows ffl idling transition represented transition relation ae true gamma corresponds stuttering step abadi lamport terminology characterizes internal transitions executed environment 
ffl environment receiving transition er channel cm represented relation ae er jbj tl gamma 
corresponds receive executed environment channel ffl environment sending transition es external channel cm represented relation ae es ffl 
corresponds send executed environment channel theta initial condition consists theta represents parts declarations channels variables represents initial locations control declared clause init environment controls initial value external channels 
jm just transitions contains transitions enabled continually taken finitely times 
consists internal transitions associated actions fm fair transitions contains transitions enabled infinitely taken finitely times 
consists internal transitions associated communication actions environment transitions contained jm fm comment note important feature semantics adopting open semantics meaning program takes account happens environment formalized means environment transitions closed semantics corresponds reduced case removed set transitions idea introducing environment steps module new see 
contrast styles open computations need explicit transition labeling 
looking variable channel modified transition decide component module environment responsible 
example 
consider module example 
associated fts sm pi sigma theta pi theta es er ae ae ffl ae jc hd tl ae es ffl ae er jc tl definition computations sm possible computation sm infinite sequence states oe satisfies initial condition theta tm oe satisfies justice fairness requirements imposed sets jm fm computations oe said stuttering equivalent denoted oe equal modulo idling steps 
recall semantic model finite computations represented infinite sequences adding infinite number idling steps take halting state 
definition behaviour sm behaviour sm defined set possible computations sm closed stuttering variance local variables hidden channels 
oe belongs behaviour sm exists oed iew iew possible computation sm say oe behaviour sm denote restriction projection state set variables extended sequences states way 
semantics concurrent program knn fair transition system resulting composition fair transition systems associated modules notation sn knn sn omega omega snn executions sn knn represented interleaving concurrent actions different modules respecting fairness constraints component sn limited critical lcr restriction order capture closed connection interleaving overlapped executions 
lcr restriction satisfied programs class asynchronously communicating modules consider 
definition 
modules shared channel pi pi define loc share environment modes declared modules loc share df modem modem modem modem 
definition 
sm pi sigma tm theta jm fm fts associated modules fts associated composed module km defined follows sm km sm omega sm pi sigma tm theta jm fm 
pi pi pi modes channels pi defined interface phi interface 
sigma fs pi dm sd pi sigma sd pi sigma components arbitrary concurrent systems called modules semantically concurrent system considered new composed module 

tm pi pi nf es er pi pi external loc share loc share pi transitions tm extended pi pi similarly pi 

theta theta theta consistency guaranteed interface compatibility requirement 
jm jm jm fm fm fm definition 
semantics hiding renaming channels defined pi sigma theta jm fm tm er es pi pi modes channels pi defined interface 
sm sm renaming extended tuples usual way 
showing separated modules composite concurrent programs semantics formalized terms structure fair transition systems shall term module composite concurrent programs separated modules 
definition compatible computations 
compatible modules iew iew oe oe computations sm sm respectively 
oe oe said compatible iff oe dv oe dv es er er es er er fig 

oe oe compatible computations oe oe phi oe proposition 
behaviour closure idling steps sm fts associated module oe sequences pi oe 
oe behaviour sm iff behaviour sm proof 
fts contains idling transition enabled terminates set computations closed idling steps 
definition behaviour sm contains possible variants computations set hidden channels local variables 
proposition compositionality 
compatible modules jjm sm fts associated relation sm sm omega sm oe sequence states pi pi propositions equivalent oe computation sm oed pi oed pi compatible computations sm sm respectively 
proof 
straightforward consequence open computations 
complete proof give 
program equivalence module congruence properties regard composition operators elucidated notions program equivalence module congruence 
manna pnueli notion reduced behaviours set observable variables define program equivalence 
briefly programs said equivalent relative set variables denoted iff ro ro ro denotes set reduced behaviours generated program definition adequate comparing entire programs considered transition systems 
consider components modules ipl expected parts large systems need stringent notion equivalence 
short wish able interchange modules context changing semantics system set observable variables 
modules said congruent denoted iff interchangeable program context 
definition intuitive prefer give strong sufficient formal condition say modules congruent associated transition systems sm pi sigma tm theta jm fm modulo renaming local variables hidden channels iew iew sm iew sm iew 
proposition 
kc km iew kc km iew new channel variable 
proof 
follows obviously definitions 
important consequence definition associative law parallel construction 
proposition 
interface compatible modules km km km km km proof 
sm omega sm sm omega sm sm omega sm omega sm sm omega sm omega sm straightforward definition 
section defined modular programming notation ipl concurrent systems elaborated computational model compositionally models semantics concurrent systems described ipl 
section describe logical framework adequately permits expression desired properties concurrent systems verification compositional way 
framework decided ipl program implements refinement generally ipl implementations concurrent systems derived specifications systematic way 
problem tl linear discrete temporal logic tl perceived appropriate tool semantic description concurrent sequential programs reasoning 
relies fact concurrent program behaviour easily modeled possible totally ordered execution sequences arising interleavings actions separate sequential processes concurrent program interleaving semantics 
serious problems arise wants apply tl parallel programs realistic size 
proofs compositional consequently hard master 
develop program correctness proof 
constructive fashion aim able decompose proof large program lemmas associated components lemmas remain valid context components ignore details reasoning required take account losing proved properties 
logic tl provide appropriate tool support notions strongly criticized point view 
lamport objects operator cause trouble abstraction forcing irrelevant detail semantic description 
turns lowest level atomicity visible occur properly semantics 
holds quantification flexible variables 
semantics operators abstraction stuttering invisible steps 
hand manna pnueli state points dissatisfaction temporal logic due floating interpretation assign special significance initial state satisfiability validity evaluated positions models 
fact anchored temporal logic consider formula defined valid resp 
satisfiable set sequences holds position resp 
sequence example 
consider programs 
var integer var integer var integer integer local gamma gamma 
df oe flq fl denote respectively operators temporal logic tl 

abstraction problem gamma 
gamma 
observationally equivalent satisfies safety property satisfied 
lesson tl especially operator fl operationally precise gamma invisible changes tl lacks abstractness 

compositionality problem gamma 
kp gamma 
kp gamma 
programs share variables concurrency communication composition kp behaviour program safety property 
tl provide efficient tool compositionally reasoning concurrent programs 

refinement problem desirable gamma 
hold difference finer grained behaviour concerns invisible variable completely hidden binder success easily check gamma 
implies gamma 
unfortunately case classical definition logic tl gamma 

lesson logic tl provide adequate mathematical tool formalizing refinement implication 
suggests refinement formalized logical implication 
logic mtl concerned problems mentioned 
propose refined temporal logic mtl notions abstraction compositionality refinement turn rigorously treated 
logic assume anchored version fragment flexible quantifiers semantics operator quantifiers refined way invisible steps 
temporal semantics programs formulated terms refined temporal logic mtl 
notice design decisions especially motivated need reach sufficient abstraction temporal language semantics enable design composition principles compositionally reasoning concurrent programs 
interested open semantic model temporal semantics program describes execution sequences possible environments 
resulting logic require suffix closure program behaviour guarantees invariance stuttering properties 
allowing semantic description open systems provides abstraction compositional specification verification concurrent systems offers support systematic design concurrent programs 
syntax semantics describe basic syntax state formulas models define syntax semantics mtl 
state formulas called assertions formulas expressed fragment predicate logic language describe properties individual states 
assume infinite countable set flexible variables infinite countable set rigid variables 
flexible variable may assume different values different states model values rigid variables depend states 
computer science mathematical point view rigid variables intended represent constants flexible variables represent program variables 
assume set val values including booleans false natural numbers strings 
assume contains values needed examples considered 
addition variables assume concrete predicates concrete functions respective domains included val 
agree view constants ary functions propositions boolean variables assume boolean connectives oe equality 
values flexible variables rigid variables range val status variables may assume different values different states rigid variables may assume fixed value prefer interpret different ways 
definition 
define state resp 
valuation assignment values variables resp 
gamma mapping val resp 
val 
denote ffj value mapping ff assigns variable flexible rigid variable 
ff ff mappings variable say ff variant ff ff ff notation ffj ff 
ff mapping denotes projection ff set variables partial mapping takes values ff undefined 
state formulas interpreted couples usual way hx hu gamma df sj gamma sj df df true 
denote sigma oe oe oe oe gamma set states set mtl stands modular temporal logic call flexible variables simply variables infinite sequences states respectively 
set valuations denoted delta 
oe oe sequences states variable say oe variant oe write oe oe oe sequence states subset denote sequence dw dw 
oe sequence oe denotes sequence oe denotes sub sequence denote oe th state oe 
definition stuttering 
oe sequence step gamma oe called stuttering step iff gamma call finite stuttering resp 
infinite stuttering finite number stuttering steps resp 
infinite number stuttering steps 
define oe sequence obtained oe removing finite 
definition stuttering remove 
oe sequence oe oe oe ffl oe definition stuttering 
oe sequences oe said stuttering equivalent notation oe dw 
simply say oe stuttering equivalent case write oe proposition 
oe dw 
proof 
consequence definition 
definition 
temporal model kripke model mtl couple oe consists valuation infinite sequence states oe positive index 
new central concept definition mtl lies new kind operator denoted dual denoted indexed set flexible variables important feature insensitive finite stuttering sensitive infinite stuttering respect set variables dual insensitive finite infinite stuttering 
define index formula set flexible variables freely occur formula 
applying mtl programs index represents observable variables 
new concept similar introduced lamport defined consist flexible quantification modulo stuttering steps 
define temporal operators new concepts order obtain temporal logic enable semantic descriptions invariant stuttering represents set variables viewed component 
major results ensure desired level abstraction necessary modular specification compositional verification concurrent systems 
syntax semantics mtl additional notation write mtl formulas summarized 
assuming meaning state formulas easily defined predicate logic see provide needs understand mtl formulas 
inductively define mtl formulas indexes 
name mtl formulas symbols fp names precise index formula denoted denote resp 
set flexible variables resp 
rigid variables freely occur called index syntax formula 
state formula 
formula 
formula 
formula 
formula 
formula 
formula 
variable 
formula 
rigid variable 
formula 
variable provided includes free flexible variables occur formula 
state formula fx flexible variable free pg fu rigid variable free pg syntax requires included fug fxg semantics oe iff oe state formula oe iff oe dw oe dw oe dw oe dw oe oe dw oe dw oe iff oe dw oe dw oe oe dw oe dw oe iff oe oe iff delta oe oe iff tae gamma ae oe ae oe iff oe oe iff oe oe provided oe contains free variables interpreted formula 
notation df oe df df oe oe df df oe df df df shuffle df true comment insist main difference dual includes liveness part 
difficult show comparison lamport tla looks ffl looks predicate shuffle axiom formalizing conjunction independent transitions 
intuitively asserts sequence changes leading state may involve variables abstractness consider abstraction problem stated section arises applying temporal logic describe concurrent program behaviour 
suggestion aims solving problem new semantics abstracting state changes invisible variables variables outside index 
show truth value formula depends free variables explicitness 
show meaning formula insensitive stuttering steps keeping values variables unchanged index stuttering invariance 
proposition explicitness 
formula 
oe oe iff du proof 
proof showing oe oe oe iff oe proved induction formula structure 
focus pertinent cases 
consider arbitrary oe oe oe 
proof 
case state formula oe iff oe iff logic oe oe oe iff oe oe oe case form oe iff oe dw oe dw oe dw oe dw oe iff fx implies oe oe oe oe ind hyp oe dw oe dw oe dw oe dw oe iff oe oe oe case form flexible variable oe iff ae ae oe ae iff fx implies ae ae oe ae iff fu ind hyp ae ae oe ae iff oe case form rigid variable oe iff exists delta oe iff fu implies exists delta oe iff fx implies ind hyp exists delta oe iff oe proof 
proposition stuttering invariance 
formula valuation sequence oe oe iff oe proof 
show induction structure formula oe oe iff oe case state formula oe iff oe iff oe oe oe iff oe case form oe iff oe dw oe dw oe dw oe dw oe iff fby definition ind hyp 
oe pg oe oe oe dw oe dw oe dw oe dw oe iff oe case form oe iff oe iff fby ind hyp oe fby proposition oe iff oe case form oe iff oe iff fby ind hyp oe iff ae case form oe iff oe oe iff find 
oe oe iff iff oe case form variable oe iff oe oe oe oe iff fby definition oe oe oe oe oe oe iff oe case form rigid variable oe iff exists delta oe iff fby ind hyp exists delta oe proof 
proposition stuttering invariance 
formula valuation pair sequences oe oe oe iff proof 
oe sequences oe 
oe iff iff iff foe dw iff proof 
proposition asserts truth value depend variables occur free proposition asserts meaning formula insensitive steps preserving value variables index allows description temporal semantics concurrent programs modular way 
validity provability types validity considered 
state formula defined valid denoted sj state sigma temporal formula defined temporally valid denoted oe valuation delta sequence oe gamma corresponding types validity possible deductive proof systems may considered 
proof system supports proving assertional validity state formulas second system support proving temporal validity temporal formulas 
leads notions provability 
say state formula provable denoted assertional validity proven assertional proof system 
similarly say formula temporally provable denoted temporal validity proven temporal proof system 
mainly interested temporal validity provability assume underlying assertional proof system give axioms rules dealing temporal validity 
famous results godel set valid assertions allowing quantification interpretation concrete structures including natural numbers general non recursive consequently temporal proof system non recursive 
circumvent situation assume called oracle decide assertion assertion language valid 
temporal proof system section recursive relatively oracle set temporally valid formulas may described recursive proof system may call oracle decide validity assertions 
focusing temporal part omit subscript true interpret simpler respectively 
quantifiers section discussed problem concerns implementing program 
problem refered action refinement problem precisely rises action program decomposed actions 
lamport logic tla solves problem defining semantics quantification account possible stuttering steps 
adopted definition flexible quantification logic mtl conserving classical laws quantifiers 
results fact temporal operators insensitive stuttering operator 
define ree set flexible rigid variables occur free formula ree df 
example 
ffl ree df fx yg ffl ree df fy ug theorem 
theorem 
respectively variable rigid variable 
ree ree 
ree ree proof 
variable rigid variable respectively formula index 
oe iff ae ae oe ae ae ae ree ae iff fg iff ae ae oe ae fby proposition ae oe implies ae oe iff oe oe iff exists delta oe ree iff oe 
similar 
proof syntax semantics logic mtl interesting properties semantics 
instance shown truth value formula relate interleaving steps changing values variables outside index 
proof system mtl give system axioms rules dedicated mechanizing theorem proving mtl 
important notion connected construction proofs instantiation 
definition 
formula scheme propositional sentence symbols appearing 
temporal replacement ff 

specifies replacing formula denote ff formula obtained replacing occurrences respectively 
refer ff instantiation 
example formula instantiation obtained replacement 

working variables wish extend temporal replacement parameterize sentence symbols additional restrictions required order instantiation rule sound 
problem arise uncontrolled temporal replacement parameterized sentence symbols clearly stated 
give restriction undertaken overcome problem details see 
restricts temporal replacement rigid parametrized sentence symbols require variables appearing replacing formulas captured quantifiers instantiated formula 
definition 
define parametrized occurrence sentence symbol rigid variables rigid 
formula un rigid parametrized sentence symbol occurring define general temporal replacement um 
um admissible um contain variable quantified 
note definition covers case replacement 
preceding discussion considers replacing sentence symbol formula 
dealing quantifiers equality need replace variables expressions 
write imply free occurrence variable term operator designate definition 
flexible variable rigid variable respectively expression respectively set flexible variables rigid variable 
replacement 
said compatible free occurrence scope operator 
replacement 
said admissible compatible variables appearing quantified 

replacement 
said admissible variables appearing quantified 
definition instantiation 
consider admissible replacement 


state formula 
defined similarly substitution order logic 


df 


df 

instantiation defined law order logic 
example 


admissible 
proof system write instantiated formula 
variable rigid variable 
axioms temporal operators oe oe oe oe oe oe oe true true false true oe true shuffle oe axioms quantifiers provided 
admissible provided 
admissible respectively variable rigid variable expression 
inference rules gen state formula decided oracle ins ff ff admissible general temporal replacement mp oe exi exi respectively variable rigid variable occur freely comment 
observe programming point view axioms may assumed modeling concurrency communication axiom modeling concurrency communication 
axioms changes concern variables shared indexes changes involve variables common theorems derived rules axioms rules derive additional theorems rules 
theorem statement form claiming formula provable deductive system valid assuming soundness defined 
proof theorem oe assumptions gamma finite sequence oe oe ng 
oe valid assertion 
oe axiom oe gamma 
oe derived foe oe gamma rule deductive system 
oe oe write gamma oe proof oe gamma write simply oe gamma empty 
say derived rule proof theorem derived rule proven may subsequent proofs justify additional steps 
give examples theorems derived rules appendix soundness system shown axioms rules dealing propositional fragment temporal language complete 
valid propositional temporal formula proven proof system 
drop variables quantifiers obtain exactly propositional fragment regular temporal logic tl operator equivalent fl 
fragment proof system provides axioms rules tl proven complete propositional fragment 
whilst axioms rules provide deal variables quantifiers allow derivation large number valid formulas lead complete proof system 
surprising underlying assertional language assumes variables range concrete structures 
includes integers complete deductive system reason exists 
theorem 
proof system sound formula proof theorem appendix properties ipl programs order relate formula ipl module supposed specify necessary behaviours module serve models logical sense formula 
means evaluate formula behaviours ascertain holds behaviour 
introduce specific validity call concerning behaviours 
augment mtl logic program specific predicates functions referring additional ipl domains constructs needed fully describe state behaviour concurrent program instance functions integers booleans lists ffl hd tl control predicate rules allow derivation theorems ipl program behaviours 
definition semantics state sj iff sj intuitively holds states control location definition program validity 
pi sigma theta fts associated ipl module vocabulary consists set variables contains pi set rigid variables disjoint 
oe sequence states valuation say model oe corresponds behaviour ae iff oed pi aed pi refer oe model denote open set formula denote vocabulary vf define valid equivalently valid program denoted oe iff oe open delta oe vf pi observe program variables considered flexible variables specifications 
specification may contain variables appear program rigid variables 
rigid variables appear specification interpreted valuation relate dynamic behaviour program 
stated mainly specification purposes relate values different states sequences 
program validity oe defined open semantics open 
establish relationship strong notion program validity classical defined close semantics usually denoted 
establish close relationship program validity oe modular validity relation sense manna pnueli 
define property modularly valid module jjm module interface compatible theorem justifies informal notes 
theorem 

iff oe iew 
oe iff interface compatible proof 
iew prove 
show oe close iff exists oe vf pi validity invariant vf stuttering stuttering deduce close iff state follows 
recall close set models correspond behaviours sm set transitions reduced removing environment transitions open set models correspond behaviours semantics corresponds sm reduced removing environment transitions associated channels iew environment transitions kept close differ models differ stuttering 
proof 
sketched follows 
comp set module interface compatible may infinite show open comp close 
comp close open 
arbitrary module interface compatible difficult show oe close oe open 
satisfied viewed channel environment transitions associated communication transitions executed channel 
possible interface compatibility hypothesis 
comp close difficult prove 
sufficient show behaviour oe able construct module interface compatible simulates viewed channel environment transitions occur oe 
matter transition er achieved including receive transition 
ii matter transition es simulation sending non deterministic value module corresponds including non deterministic assignment 
followed send transition proof 
invariance eventuality properties types properties ipl programs interest invariance called safety properties eventuality properties subclass liveness 
invariance expresses property true state behaviour expressed formula form state formula informally states holds initialized behaviours 
prove invariance properties usual computational induction invariance principle 
principle find invariant init oe init predicate specifying intial states program 
examples invariance partial correctness mutual exclusion deadlock freedom 
eventuality asserts eventually happens 
forms eventuality considered df oe df 
operator called weak eventuality examples termination total correctness second strong eventuality examples absence starvation response service 
difficult see operator transitive operator 
explicit induction called structural induction prove eventuality properties 
induction represented application founded argument element state 
modular specification large systems contain components modules separate specification specifying desired behaviour system 
specifying concurrent modules convenient way explore lamport modular specification method similar notions introduced 
emphasize particular relevance complementing specification module specification interface mechanism module communicates environment 
interface specification module stipulates constraints environment satisfy correct interaction module 
information interface contain essential completeness specification module intended eliminate need communication user module implementor 
behavioural part highest level specification interface part low level specification 
specification module 
specification module object form inter fw inter specifies interaction constraints environment fw formula specifies initial states safety properties liveness properties expected behaviour module runs environment interacting inter 
wish sensitive changes viewed interface index set contain channels appearing inter 
definition correctness formulas 
module inter body ipl module hinter specification module 
define correctness formula written hinter follows hinter iff oe intuitively hinter means body module behaviour description body operates environment compatible interface inter module behaviour satisfies property note indexing body variable module identified associate specific variable serves specify control values locations module 
names control variables associated different modules differ 
shall see section rules proof system associated program part focus algorithmic aspect 
rules essentially intended reason behaviour content specifications programs 
mean reasoning domains excluded 
reasoning data types formulated logic proofs invariance properties 
instance prove ranges integers execution program sufficient derive correctness formula hinter init proof system program part proof system mtl section provides axioms rules derive temporal tautologies true regardless meanings elementary formulas 
section logic mtl augmented collection axioms rules deal mtl formulas elementary formulas instantiated assertions domains control ipl programs 
extension permits derivation ipl program theorems valid set models corresponding behaviour clearly temporal tautology basic logic mtl theorem program formulas valid program valid general 
search establish proof system support compositional verification incremental modular construction ipl programs composition rules needed program part specification part correctness formulas premisses reduce complexity 
criterion large specification implemented rules allow implementor decompose elementary ones implemented separately 
conversely correctness proofs small modules allow verifier establish correctness bigger modules 
collection axioms consists program axioms describe temporal semantics basic transitions ipl modules 
main rules mechanizing compositional reasoning ipl modules 
axioms transitions 
fvar idg jcj tl 
fvar idg ffl 
fvar skip hfalse 
fvar hfalse 
fvar hfalse 
fvar hout ffl 
fvar hin jcj hd tl globally transition axioms associate transition ff mtl formula providing temporal description behaviour ff communicates environment interface inter 
axioms require explanation 
serve give individual temporal semantics environment transitions corresponding external channel 
idling transition denoted id transition relation ae true consequently temporal formulas appear axioms denote exactly semantics environment transitions question 
give rule rule env combine pure environment semantics semantics individual transitions appear module body 
axioms describe temporal semantics individual transition ff operating close system means environment mode external appears interface 
claimed closed semantics combined environment semantics rule env achieve open semantics transitions 
note environment transitions internal transitions 
operational semantics fairness conditions concern internal transitions environment transitions 
note predicate false represent empty interface disjunction represent union interfaces 
soundness axioms proven ipl semantics defined section 
difficult check axiom form ffg hinter inter dcl ff oe holds 
equivalently verify model satisfies inter dcl ff pi vf reduces verify formula specifies transition relation fairness requirements associated ff 
consider axiom illustrate 
intuitively states proper execution transition describable follows control module location current state satisfies guard eventually state possibly preceded finite number stuttering steps obtained executing assignment correctly expressed instantiated precondition hoare axiom 
eventual existence state asserted strong operator expresses fairness constraint requiring transition eventually executed enabled 
rules modules env idg hinter ffg hinter ffg hinter inter argue soundness rule oe model corresponding execution sequence inter inter dcl ff inter consists environment modes 
oe correspond execution sequence inter dcl id inter dcl ff 
module collects environment transitions associated modes inter second collects internal transitions associated ff 
body ff hinter 
ff hinter fn dcl ff ff hinter inter fn rule execution list transitions consists execution sequences satisfy transition relations fairness requirements individual transitions list 
note combination different transitions module conjunction rules env body relates expression individual transition semantics form entailment soundness rules strongly relate fact 
init sg hinter init sg hinter soundness rule trivial 
give starting location module control rule strengthens specification module proposition restricting set possible execution sequences initial control state sg hinter sg hinter rule similar previous concerns initialization program variables 
way strengthens specification module assertion hold state execution sequence 
local sg hinter local sg hinter formula specify right behaviour module inter dcl 
specifies visible value variable declared dcl 
module inter dcl local wish specify variables change exactly way module mind variable changes 
require formula specifying second module asserting variables behave described matter values assume 
intuitive meaning exactly quantified formula localization fl lb fbg hinter falsei provided lb denotes fbg hinter lb set locations axioms concern localization control module 
asserts module control different locations time 
second asserts time module control location 
rules networks bind fbg hinter fw fc bg hc inter soundness rule argued similar way previous 
hiding channel equivalent considering local module values assumes insignificant outside module 
meaning captured terms flexible quantifier 
rename fbg hinter fb hinter provided new channel 
denotes renaming variable new variable formula renaming extended mtl formulas usual way df renaming channel module new channel simple case implementing channel renaming 
channel assume behaviour channel specifies behaviour channel renaming corresponds exactly renaming specification denoted par fb hinter fw fb hinter gw fw gw shuffle oe psi fb kb hinter phi inter psi provided inter compat inter iew inter iew inter expression inter phi inter inter par rule defined definition section combines compatible interfaces inter inter compute global interface parallel module km inter inter provided inter inter compatible 
general idea underlying par rule execution module km viewed execution steps true environment steps regarded environmental symmetrically execution steps true environment steps regarded environmental additional constraint variables shared shared channels 
additional constraint expressed formula shuffle asserts steps involving steps involving interleave change 
third requirement concerns control postulates control variable parallel program fb kb implemented pair formed control variables components adaptation rules conjunction hinter hinter hinter consequence hinter oe hinter gi rules useful proof adaptation incremental proofs 
rule allows decompose proof large specification proofs elementary specifications 
consequence rule allows adopt valid specification formula follows logically valid specification 
rules interest bottom verification approach 
small example section presents example illustrating compositional construction proofs properties ipl programs developed theory 
simplify formulas assume rigid variables implicitly universally quantified formula appear give quantification explicitly 
name formulas needed proof construction 
range respectively fl fm init ffl ffl ffl ffl ffl ffl ffl init ffl ffl ffl ffl ffl ffl theorems directly derived axioms program part proof system 
gamma fvar idg gamma fvar idg gamma fvar hout gamma fvar hin gamma fvar hout gamma fvar idg gamma fvar idg gamma fvar hin gamma fvar hout rules env body theorems order derive specification large module 
similarly rules env body theorems order derive specification module 
represented theorems 
th fvar external th fvar external rules init specify intial values control variables 
theorems derived th th th fvar ffl ffl init external init th fvar ffl init external init level derived temporal specification modules module external channel integer channel integer ffl ffl var integer theta module external channel integer channel integer ffl var integer theta temporal specification module describes semantics 
pure temporal logic mtl derive theorems basic ones th th derived theorems represent valid specifications module follows logically logic mtl basic specification contained th th 
interested deriving specifications describing desired safety liveness properties module 
illustrate rule par derive basic specification parallel module km derive desired properties program logic mtl 
difficult verify conditions rule par satisfied interfaces compatible theorem derived th th th fvar ffl ffl init fvar ffl init hout init init shuffle df df consider logic mtl derive consequences formula init init shuffle theorem th derived consequences valid specifications module km 
init init shuffle mpg 
ffl ffl ffl ffl ffl ffl ffl rules axioms mpg 
ffl ffl ffl mpg 
ffl ffl ffl ffl rules axioms mpg 
ffl ffl ffl note liveness properties directly derived previous ones consequence mtl 
example theorem derivable ones previously 
km hinter init init ffl ffl ffl inter df section just sketched compositional proof desired properties small concurrent program 
construct proofs rules forwards order verify properties composite program basis properties elementary components 
rules backwards find ourself doing task consists incrementally deriving pieces large system decomposing specifications smaller ones 
example developed point view 
related preliminary concepts refined temporal logic guarantees fully semantics chosen level observation 
shown compositional temporal proof system concurrent programs derived 
resulting full logic provides practicable method compositional verification modular construction concurrent programs 
novelty refined temporal logic lies mainly ability express properties chosen level abstraction 
versions pnueli temporal logic proposed describe program temporal formula 
differ expressiveness represent programs formulas invariant stuttering 
consequently compositional rule parallel composition hard obtain possible result complex 
finer grained program implement coarser grained logics 
lamport tla logic programs described formulas invariant stuttering 
refined semantics basic temporal operators proposed shown results equivalent tla may reformulated regular temporal logic advantage logic temporal quantifiers behave order quantifiers 
attempt tackle problem stuttering classical temporal logic done pnueli 
main difference pnueli lies fact contrary discrete temporal logic pnueli deals temporal logic tlr dense time domain isomorphic reals 
proposal mainly intends achieve results equivalent lamport tla pnueli ones tlr discrete temporal logic tl 
define discrete temporal logic supports refinement systematic development concurrent systems 
undertaken idea refining previous logic felt cumbersome reasoning real size concurrent programs 
closure stuttering aimed reaching modular practical method support systematic design concurrent programs starting desired properties 

abadi lamport 
existence refinement mappings 
third annual symposium logic computer science pages edinburgh july 

abadi lamport 
composing specifications 
acm transactions programming languages systems january 

abadi plotkin 
logical view composition 
technical report dec palo alto may 

barringer 
temporal logic compositional specification concurrent systems 
galton editor temporal logics applications pages london 
academic press 

barringer kuiper pnueli 
may compose temporal logic specifications 
sixteenth acm symposium theory computing pages april 
acm 

godel 
uber formal der mathematica systeme fur mathematic und physik 

lamport 
hoare logic concurrent programs 
acta informatica 

lamport 
specifying concurrent program modules 
acm transactions programming languages systems april 

lamport 
temporal logic 
pages 
ifip 

lamport 
simple approach specifying concurrent systems 
communications acm january 

lamport 
temporal logic actions 
technical report dec palo alto december 

lichtenstein pnueli zuck 
glory past 
logics programs pages 
spinger verlag 
lncs 

manna pnueli 
anchored version temporal framework 
de bakker 
de roever rozenberg editors linear time branching time partial order logics models concurrency pages new york 
spinger verlag 
lncs 

manna pnueli 
verification concurrent programs temporal proof system 
th school advanced programming pages june 

manna pnueli 
verification concurrent programs temporal proof system 
th school advanced programming pages june 

manna pnueli 
verification concurrent programs temporal framework 
boyer moore editors correctness problem computer science pages london 
academic press 

manna pnueli 
cook temporal proof system pet language 


manna pnueli 
temporal logic reactive concurrent systems 
springerverlag 
isbn 

ery 
proof environment subset sdl 
reed editors fifth sdl forum evolving methods 
north holland 

ery 
integrated environment interactive verification sdl specifications 
probst editors computer aided verification volume lncs 
springer verlag 

ery 
composition principle design parallel programs 
nivat rattray rus scollo editors third international conference algebraic methodology software technology 
twente springer verlag june 
workshops computing 

ery 
temporal logic refinement compositional verification concurrent systems 
technical report 

ery 
stuttering closed temporal logic modular reasoning concurrent programs 
international conference temporal logic 
bonn germany springer verlag july 

owicki gries 
axiomatic proof technique parallel programs acta informatica 

pnueli 
temporal semantics concurrent programs 
gilles kahn editor semantics concurrent computation pages 
lncs 

pnueli 
transition global modular temporal reasoning programs 
logic models concurrent systems 
spinger verlag 
nato asi series 

pnueli 
system specification refinement temporal logic 
pages 
spinger verlag 
lncs 


compositionality partial correctness 

lncs 
appendix ex rule gmp proof oe oe oe oe oe mp oe premise definition oe mp premise mp ex rule proof premise oe mp ex rule proof premise oe oe oe mp ex theorem proof oe gen true oe true ins gmp ex theorem proof prop definition false false ins false false prop prop definition ex theorem false proof false gen gen false false prop ex theorem oe oe proof oe oe oe true true prop oe true true prop oe prop oe prop oe prop oe oe prop step prop proof constructions explicit explanation 
done step corresponds propositional reasoning generalized rule gen mp ins 
appendix proof sketch 
prove soundness axioms rules directly definition semantics 
classically show axiom temporally valid rule pn gamma pn preserve temporal validity delta oe gamma oe oe oe pn formal proofs soundness axioms rules lengthy difficult feel intuitively give proofs complete proof 
axioms trivially valid axiom oe iff oe oe dw index oe oe axiom position oe true iff oe dw oe dw oe dw oe dw 
oe dw oe dw oe oe dw oe dw iff oe dw oe dw 
oe dw oe dw oe iff oe axiom position oe iff oe dw oe dw oe dw oe dw 
oe dw oe dw oe oe dw oe dw oe dw oe dw 
oe dw oe dw oe iff oe dw oe dw oe dw oe dw 
oe dw oe dw oe oe proposition iff oe axiom position oe iff oe dw oe dw oe dw oe dw 
oe dw oe dw oe oe dw oe dw oe dw oe dw 
oe dw oe dw oe oe dw oe dw oe dw oe dw 
oe dw oe dw oe oe oe axiom position oe true oe true iff oe false true iff oe dw oe dw oe dw oe dw hyp oe iff oe dw oe dw oe dw oe dw 
oe dw oe dw oe oe dw oe dw oe dw oe dw 
oe dw oe dw oe iff oe dw oe dw oe dw oe dw 
oe dw oe dw oe oe dw oe dw 
oe dw oe dw oe fby hyp iff oe axioms quantifiers follow obviously definitions 
rules gen ins mp concern reasoning general level 
similar classical temporal proof system manna pnueli soundness preserved 
soundness rule exi follows theorem 
proof 

