memory management explicit regions david gay alex aiken eecs department university california berkeley cs berkeley edu research devoted studies algorithms memory management garbage collection explicit allocation deallocation 
alternative approach region memory management known decades 
region system allocation specifies region memory reclaimed destroying region freeing storage allocated 
show suite allocation intensive programs regions competitive malloc free substantially faster 
show regions support safe memory management low overhead 
experience benchmarks suggests modifying existing programs regions difficult 
popular memory management techniques explicit allocation deallocation malloc free various forms wil :10.1.1.142.3082
known advantages disadvantages discussed 
third alternative region memory allocation widely implementation technique years variety names zones ros groups iy arenas han 
regions attracted research attention target static inference memory management tt improving locality dynamically allocated data sto :10.1.1.23.5498
region memory allocation scheme allocated object placed program specified region 
memory reclaimed destroying region freeing objects allocated 
simple example shown 
iteration loop allocates small array 
call frees arrays 
material part supported nsf young investigator award 
ccr darpa contract microsoft graduate fellowship 
void region newregion int sizeof int example region allocation 
commonly version region programming regions explicit program entirely programmer control 
knowledge performance popular implementation technique studied 
contribution detailed comparison performance regions malloc free libraries conservative garbage collection set benchmark programs 
explicit regions benchmarks faster malloc free conservative garbage collection significantly 
memory consumption experiments regions memory best alternative rank second see section 
study supports regions performance grounds common implementation regions unsafe region deleted regions accessible pointers objects second contribution study safe region implementation region deleted external objects external pointer stored 
enforce rule keeping count region op count nonzero 
note counting regions individual objects common problems counting ameliorated minimal space devoted storing counts cyclic structures collected long allocated single region 
overhead safety varies negligible benchmarks comparative performance remains regions faster alternatives cases cases regions slightly slower 
third contribution assessment difficult program explicit regions 
metric number type changes required modify application regions 
benchmarks required modest recoding regions needed region organization straightforward derive see section 
explicit regions particular strengths 
regions bring structure memory management making programs clearer subjective assessment easier write compared malloc free 
example necessary walk complex data structure deallocate 
second evidence regions provide significantly improved data locality posited stoutamire sto 
execution time benchmark improved simply reorganizing allocation frequently accessed objects allocated single region 
malloc free garbage collected systems provide mechanism expressing locality 
third regions useful building software predictable performance cost operation easily bounded unsafe regions tt safe regions see section :10.1.1.23.5498
safe implementation uses moderately sophisticated scheme efficiency show overhead scheme amortized constant time instruction executed assuming size stack frames bounded constant see section 
advantage region memory management nearly unchanged explicitly parallel programming language 
operations require synchronization processes region creation deletion 
process keeps local count region counts created deleted process 
region deleted sum local counts zero 
writes regions done atomic exchange simple write prevent incorrect behaviour presence data races local counts adjusted synchronization communication 
situations regions model particularly programmer know lifetime objects place appropriate regions 
example encountered game objects allocated deallocated result player actions way place objects similar lifetimes common region 
purpose study costs benefits regions normally 
leave generalizations explicit regions 
conclude section high level comparison region scheme malloc free garbage collection 
region model reminiscent malloc free allocation twice fast deallocation faster 
safe version scheme additional overhead maintaining region counts 
garbage collection easier regions efficient application uses fraction available memory 
application needs available memory performance degrades 
garbage collection prevents local reasoning performance introducing unpredictable pauses 
real time collectors bak wj eliminate problem cost higher overhead 
considerations believe regions best suited high performance applications large fraction machine memory lifetimes values statically predicted 
regions useful writing software predictable performance garbage collection systems 
rest begins detailed survey related section 
introduce safe region memory management system section implementation section 
section details costs safe regions compares performance applications malloc free implementations boehm weiser conservative garbage collector bw 
related literature memory management vast 
surveys wil garbage collection wjnb explicit allocation deallocation :10.1.1.142.3082:10.1.1.111.8237
regions decades 
ross ros presents storage package allows objects allocated specific zones 
zone different allocation policy deallocation done object basis 
vo vo package similar allocations done regions specific allocation policies 
regions allow object object deallocation regions freed 
hanson presents arenas han measure performance 
barrett zorn bz profiling determine allocations short lived place allocations fixed size regions 
new region created previous fills regions deleted objects contain freed 
provides performance advantages regions programmer intervention programs 
proposals attempt provide safe memory management 
stoutamire sto adds zones regions sather allow explicit programming locality 
benchmarks compare zones sather standard garbage collector 
reclamation object object basis 
published empirical studies regions region inference system tofte talpin tt automatically infers ml programs regions allocated regions freed region allocation site write :10.1.1.23.5498
sophisticated tofte talpin system relies critically fact regions region allocation region deallocation introduced compiler programmer 
fully automatic tofte talpin system advantage runtime overhead memory manage ment reduced absolute minimum safe 
unfortunately region inference perfect 
avoid leaking great deal memory necessary programmer understand regions inferred compiler adjust program compiler infers better region assignments 
second optimizations basic inference procedure enormous difference memory management performance afl 
properties suggest explicit class regions may appropriate combining explicit programmer controlled regions region inference appears difficult problem 
bobrow bob propose regions counting tolerant cycles 
idea taken yonezawa iy distributed systems 
papers considers regions enhancing locality include performance measurements 
grunwald zorn gz detlefs zorn study performance various allocators 
vo regions vo compares performance malloc free allocator package malloc free implementations 
grunwald zorn henderson compare performance cache locality different allocators 
studies consider region allocation 
programming model implemented prototype safe region memory management system extension 
allows compare existing programs versions applications modified regions 
prototype requires language compiler support reasons 
easier compiler generate counting code insert counts hand 
second implementation locate live local variables containing pointers information available compiler 
added advantage modifying language enforce requirements pointers objects regions compile time 
rest section presents region allocation library gives simple example 
language distinguishes kinds pointers normal pointers region pointers pointers objects regions 
region pointers defined int types different types implicit conversion exists explicit casts allowed 
casts unsafe necessary experiments standard libraries aware region pointers 
particular account region pointers cast normal pointers 
region pointer updated potentially necessary adjust counts old typedef struct region region typedef struct 
typedef struct 
region newregion void int region void region size cleanup void region size cleanup void region size region void region allocation interface 
region points decrement new region points increment 
implies region pointers initialized enforced requiring initialization local variables contain region pointers clearing writing objects allocated regions 
recognise writes region pointers copying structs containing region pointers forbidden unions impossible know parts structure contain region pointers 
region pointers behave normal ansi pointers particular address arithmetic allowed 
restrictions regions pointers onerous worth noting explicit regions integrated modern languages fewer modifications 
example java gjs pointers initialized union exist 
region library shows region interface 
new region created newregion 
objects allocated arrays 
objects arrays contain region pointers allocated cleanup arguments discussed section 
memory returned cleared 
object region returned 
attempt delete region calling 
deletion succeeds excepting region live variables regions 
success set null returned 
failure unchanged returned 
shows simple example copies list region deletes region 
cleanup list function section 
struct list int struct list struct list cons region int struct list struct list sizeof struct list return struct list region struct list null return null return cons void struct list region tmp newregion tmp tmp list copy regions 
implementation implementation safe regions lcc fh compiler runtime library implementing region interface 
modified lcc handles language extensions section cooperates runtime library maintain region counts 
target machine sun ultrasparc 
section discusses implementation manages regions section counts section 
modified version implementation supports unsafe regions identical safe version support maintaining counts disabled 
section concludes argument overhead memory management amortized constant time instruction executed 
managing regions goal region library provide cheap object allocation region deletion 
maintain mapping memory addresses regions counting code 
region data structure shown 
region contains count allocators normal allocations region pointer free data 
struct allocator char offset allocate int struct region int rc struct allocator normal struct allocator string region structure 
locator maintains list byte pages allocation occurring page list 
allocation simple allocation fits page just return increment allocate new page try 
functions save cleanup function start allocated object see clear rest allocated memory 
save size array 
allocators maintain array mapping page addresses memory addresses regions 
space overheads scheme low bytes page map pages regions list allocated pages 
object fit space remaining page space wasted 
allocation needs zero strings twelve arrays bytes bookkeeping information 
region stored page allocated region 
reduce cache conflicts region structures successive regions offset bytes nd level cache line size page maximum offset 
managing counts object allocated deallocated object may change arbitrary number times 
object allocation region deallocation inexpensive system maintaining counts potentially expensive 
useful distinguish local variables change frequently heap updated rarely 
main aim counting scheme avoid large overhead incurred counting local variables exactly 
components scheme maintaining approximate counts local variables maintaining exact counts pointers heap performing scan stack scanning deleted regions 
prototype handles allocations page benchmarks larger objects 
restriction lifted affecting cost small allocations 
byte page pointers objects supported 
local variables exact count region number pointers objects region regions global storage including global static variables memory returned malloc live variables active call frames 
need exact count called times need maintain information compute count principle deferred counting db 
actual count stored region reflects number pointers objects region regions global storage live variables active call frames high water mark stack note stack grows downward sparc 
high water mark just location stack frames 
system maintains invariant number frames high water mark 
writes local variables update counts 
invariant maintained procedure call may required procedure return 
control returns call frame high water mark region counts attributable local variables decremented high water mark adjusted call frame 
describe function detail 
requires exact count scans portion stack high water mark updates region counts 
point actual exact counts equal 
stack scan sets high water mark frame scanned 
global region compiler generates code update counts writes region pointers global storage objects regions 
counting different writes global storage writes regions 
pointer region written region count incremented 
call pointers pointers 
global storage belong region contain pointers 
shows pseudo code kinds count updates 
instruction counts reflect number sparc instructions required implementation kind write 
compiler attempts distinguish writes local variables global storage regions compile time possible writes normal pointers writes global storage variables stack 
writes stack counted variable high water mark 
writes statically writes instructions rc rc region writes instructions rc rc count methods expensive runtime routine determine case applies 
stack scan allow stack scanned runtime compiler records function call site set registers offsets current call frame contain live region pointers 
implementation lcc liveness information available prototype considers variables scope live 
liveness information static data location recorded unused bits nop instruction call site 
complex implementation avoid extra instruction 
scan call frame increments region counts live variables high water mark placed just call frame 
call frame scanned automatically control returns frame 
achieved modifying return addresses scan point special function decrements region counts adjusts high water mark call frame jumps original return address 
region scan deleted region may contain pointers objects regions 
adjust counts regions examine region pointers objects allocated user supplies function performs task cleanup argument 
function call destroy region pointer allocated object return size object 
require user provide function reason forbid copying structures contain region pointers presence unions impossible compiler locate region pointer 
cases union higher level languages cleanup function generated automatically compiler 
cleanup function allows object finalization 
shows cleanup list function list type 
pseudo code scanning deleted regions 
struct list destroy return sizeof example cleanup function 
pages region deleting pagesize deleting cln deleting unfilled pages marked null cln break deleting sizeof cln deleting deleting align alignment region cleanup 
amortized cost safe regions primary justification counting scheme solves engineering problem avoiding maintaining counts time bounding cost memory management 
assumptions 
assume size largest stack frame bounded constant second assume allocated word referenced program instruction 
argue amortized cost memory management constant instruction executed 
costs region system incurred region allocation object allocation updates counting region deletion scanning regions stack procedure return 
show bound distribute costs memory procedure calls way maximum cost associated operation bounded constant 
allocating new region constant time operation 
cost allocating object worst proportional size plus cost acquiring new page 
cost constant distributed program scanning deleted region simply scans object region cost assigned program count operation charged assignment 
analysis stack scan requires bit care 
scan frame eventually paired sufficient number live region pointers frame bounded constant 
corresponding frame 
frame bottom downward growing stack cost scanning frame charged call creates frame immediately stack 
high water mark moves procedure return follows function call charged scan frame 
assuming stack frames size call charged constant cost 
results describe benchmarks changes required adapt regions section 
benchmarks compare performance regions malloc free implementations described section boehm weiser conservative garbage collector 
find safe regionbased programs memory section allocator uses memory slower faster fastest allocator 
unsafe regions slower allocators faster section 
benchmark regions group frequently accessed data structures obtain performance improvement 
measure overhead safe regions find exceed generally lower section 
benchmarks compared performance safe region memory management allocation intensive programs 
programs inputs measurements ffl cfrac program factor large integers continued fraction method 
original application uses explicit counting reclaim storage 
factor 
ffl grobner find grobner basis set polynomials 
input variable polynomials 
ffl mudlle byte code compiler scheme language 
original version program uses unsafe regions 
line file compiled times 
ffl lcc modified version lcc compiler 
original program uses unsafe regions hanson arenas han 
input line file 
ffl tile automatically partitions set text files subsections frequency grouping words text 
program uses malloc free 
copies text input 
ffl moss software plagiarism detection system written originally malloc free 
input student compiler projects mb 
modified programs safe regions 
step choose appropriate regions applications region 
applications simple region structure data structures stored regions complex 
instance region cfrac creates region temporary computations iterations main algorithm 
partial solutions copied region solution region old temporary regions deleted 
mudlle region holds syntax tree file compiled region created hold data structures needed compile function 
programs similarly simple region structures 
general fairly easy modify benchmarks regions 
difficulty lay selecting create delete regions tedious process changing types writing cleanup functions pointed necessary higher level language 
difficulty finding stale pointers prevent region deleted environment debugging regions helpful 
region structure selected basic modifications calls malloc free replaced appropriate region operations normal pointers changed region pointers cleanup functions written initializations added local region pointers 
application changes ffl cfrac disable explicit counting allocate static objects regions 
add copies partial solutions solution region 
ffl mudlle necessary clear global variables stale pointers original code pointers prevent region deletion 
ffl grobner replace bulk copies assignment explicit copies statically allocate structures originally stack add copies polynomials form basis result region 
frees replaced clearing corresponding pointer number pointers explicitly cleared 
ffl lcc replace bulk copies assignment memcpy calls hand written copy functions replace uses memset explicit null writes 
information added types cleanup functions written 
static stack objects allocated regions global variables region allocated objects cleared 
memory strings allocated individually blocks 
improve lcc performance create region statements compiled statement 
ffl tile local variable cleared allow region deleted 
addition numerous memory management bugs original code repaired 
ffl moss allocates large static arrays region 
name lines changed lines cfrac grobner mudlle lcc tile moss table complexity benchmark changes 
size changes summarized table 
lines columns counts number lines original source code 
number changed lines represents number changed extra lines code region version results diff second number counts lines part basic modifications 
allocators compare performance regions allocators ffl sun default allocator supplied solaris 
provides interesting point comparison default 
ffl bsd version bsd memory allocator supplied sun 
rounds allocations nearest power 
features fast allocation deallocation large memory overhead 
ffl lea doug lea implementation malloc 
improved version allocator previous surveys memory allocation costs vo 
surveys allocator exhibited performance 
ffl gc boehm weiser conservative garbage collector bw 
disable free compiling collector guaranteeing safe memory management 
different region libraries measurements ffl safe safe region memory management described section 
library region measurements reg bars figures 
ffl unsafe safe operations maintain test counts disabled 
library unsafe region measurements bar unsafe 
ffl emulation region library uses malloc free allocate free individual object 
library approximates performance region application written malloc free 
experiments available ftp edu pub misc malloc name total total kbytes max 
kbytes total max 
max 
kbytes avg 
kbytes avg allocated allocated regions regions region region region cfrac grobner mudlle lcc tile moss table allocation behaviour regions 
name total total kbytes max 
kbytes allocated allocated cfrac grobner mudlle overhead lcc overhead tile moss table allocation behaviour malloc 
library measure performance mudlle lcc malloc free allocators 
library imposes small space overhead objects allocated region kept linked list freed called 
table include additional entries estimating memory usage overhead 
library calls malloc applications regions inevitably include mix memory allocated regions malloc 
regionbased programs linked default sun allocator results regions include time space cost calls malloc 
allocation characteristics tables give memory allocation characteristics region malloc free versions applications 
total total number memory allocations performed program total kbytes allocated total number kilobytes allocated allocation sizes rounded nearest multiple 
max 
kbytes allocated column contains maximum amount memory allocated time 
remaining columns concern regions total regions number regions created max 
regions maximum number regions time max 
kbytes region size application largest region avg 
kbytes region average size regions avg 
region average number objects allocated region 
discrepancies tables number allocations amount memory allocated generally small attributable small changes needed convert applications regions 
exception cfrac region version need allocate space counts need allocate extra copies results 
second exception lcc region version extra allocations strings allocated individually stack allocated structures converted region allocated structures 
region deleted region versions applications tend free memory malloc free versions 
maximum amount memory allocated time tends slightly larger table table 
memory usage compares amount memory requested operating system bar os different allocators memory requested programmer bar requested see tables 
graphs cfrac tile clipped garbage collector kbytes respectively 
lcc mudlle bar raw memory usage second bar overhead removed 
cfrac garbage collector pair requests memory malloc free versions need counts 
regions memory doug lea allocator 
regions memory allocators cases tile benchmark regions sun allocator 
bsd allocator garbage collector lot memory unsuitable applications 
performance application allocator combination measure wall clock execution time base memory including portion time spent memory management memory 
reports processor cycles lost read waiting result load instruction write store buffer full stalls 
allocator uses memory hierarchy efficiently loses fewer cycles read write stalls 
measurements sun bsd lea gc reg cfrac memory kilobytes sun bsd lea gc reg grobner sun bsd lea gc reg mudlle sun bsd lea gc reg lcc sun bsd lea gc reg tile sun bsd lea gc reg moss requested os memory overhead 
sun bsd lea gc reg cfrac time sun bsd lea gc reg grobner sun bsd lea gc reg mudlle sun bsd lea gc reg lcc sun bsd lea gc reg tile sun gc reg moss base memory unsafe slow execution time memory management overhead 
performed mhz ultrasparc workstation ultrasparc internal counters precision 
applications compiled lcc non optimizing compiler 
time spent actual application represented base part execution time 
allocation libraries compiled optimization gnu compiler supplied sun 
portion time spent libraries counting region allocation memory part execution time 
compiling applications optimizing compiler change time spent memory management reduce base part execution time uniformly allocators 
optimizing compiler change results comparison 
benchmarks unsafe regions bar unsafe faster allocators 
safe regions fast faster allocators cfrac tile moss slightly slower bsd allocator slower boehm weiser garbage collector slower mudlle 
lcc safe regions slower bsd allocator slower competitive doug lea allocator application highest overhead safe regions 
graph moss includes time optimised version base memory bar original region version slow bar 
memory allocation pattern moss alternately allocate small frequently accessed object large infrequently accessed object 
pattern reduces memory locality small objects 
improvement execution time moss obtained regions small objects large objects 
improvement reflected graph moss shows optimized region version reg column approximately half stalls original version slow column 
interesting note bsd memory allocator automatically objects size tends fewer stalls explicit allocators resulting performance advantage visible moss 
cost safety costs safe regions divided parts mirror implementation cost calling cleanup functions regions deleted cost scanning stack called cost maintaining counts region pointer writes 
gives breakdown costs applications 
gc reg cfrac gc reg grobner gc reg mudlle gc reg lcc gc reg tile moss read stalls write stalls processor cycles lost stalls 
cost safety varies negligible tile lcc 
allocation pointer intensive programs expect results similar tile 
considered various methods reducing cost safety recognizing pointers compiletime various schemes optimizing cleanup regions 
plan implement ideas version region memory management 
cfrac grobner mudlle lcc tile moss cost safety execution time base rc stack scan region cleanup region costs 
new region memory management technique combines efficiency safety 
shown technique uses memory fast faster traditional malloc memory management 
safe regions faster conservative garbage collection cases memory 
programmer regions explicitly take advantage locality dynamically allocated data structures 
lead better performance moss example shows 
style region memory management requires extensions useful applications 
plan address issue part providing regionbased memory management titanium ysp explicitly parallel java gjs programming language 
afl alexander aiken manuel fahndrich levien 
better static memory management improving region analysis higher order languages 
proceedings acm sigplan conference programming language design implementation pldi pages la jolla ca june 
bak henry baker 
list processing real time serial computer 
communications acm 
bob daniel bobrow 
managing re entrant structures counts 
acm transactions programming languages systems july 
lars birkedal mads tofte magnus 
region inference von neumann machines region representation inference 
proceedings rd acm sigplan sigact symposium principles programming languages st petersburg beach fl january 
bw hans juergen boehm mark weiser 
garbage collection uncooperative environment 
software practice experience 
bz david barrett benjamin zorn 
lifetime predictors improve memory allocation performance 
proceedings acm sigplan conference programming languages design implementation pages albuquerque new mexico june 
db peter deutsch daniel bobrow 
efficient incremental automatic garbage collector 
communications acm september 
david detlefs benjamin zorn 
memory allocation costs large programs 
software practice experience 
fh chris fraser david hanson 
retargetable compiler design implementation 
benjamin cummings pub 
redwood city ca usa 
gjs gosling joy steele 
java language specification 
java series 
addison wesley reading ma usa june 
gz dirk grunwald benjamin zorn 
efficient synthesised memory allocators 
software practice experience 
dirk grunwald benjamin zorn robert henderson 
improving cache locality memory allocation 
proceedings acm sigplan conference programming languages design implementation pages albuquerque new mexico june 
han david hanson 
fast allocation deallocation memory object lifetimes 
software practice experience january 
iy akinori yonezawa 
distributed garbage collection group counting 
oopsla ecoop workshop garbage collection objectoriented systems october 
ros ross 
aed free storage package 
communications acm august 
david stoutamire stephen omohundro 
sather specification 
technical report tr international computer science institute berkeley ca august 
sto stoutamire 
portable modular expression locality 
phd thesis university california berkeley 
tt mads tofte jean pierre talpin :10.1.1.23.5498
regionbased memory management 
information computation february 
vo phong vo 
general efficient memory allocator 
software practice experience march 
wil paul wilson :10.1.1.142.3082
uniprocessor garbage collection techniques 
proceedings international workshop memory management volume lecture notes computer science st malo france september 
springer verlag 
wj paul wilson mark johnstone 
truly real time non copying garbage collection 
oopsla ecoop workshop garbage collection object oriented systems october 
wjnb paul wilson mark johnstone michael neely david boles :10.1.1.111.8237
dynamic storage allocation survey critical review 
proceedings international workshop memory management volume lecture notes computer science scotland september 
springer verlag 
ysp kathy yelick luigi geoff pike carleton miyamoto ben arvind krishnamurthy paul hilfinger susan graham david gay phil colella alex aiken 
titanium high performance java dialect 
proceedings acm workshop java high performance network computing pages palo alto ca february 
