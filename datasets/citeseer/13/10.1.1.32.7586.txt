journal arti cial intelligence research submitted published conformant planning symbolic model checking alessandro cimatti cimatti irst itc itc irst sommarive povo trento italy marco roveri roveri irst itc itc irst sommarive povo trento italy dsi university milano milano italy tackle problem planning nondeterministic domains presenting new approach conformant planning 
conformant planning problem nding sequence actions guaranteed achieve goal despite nondeterminism domain 
approach representation planning domain nite state automaton 
symbolic model checking techniques particular binary decision diagrams compactly represent eciently search automaton 
contributions 
general planning algorithm conformant planning applies fully nondeterministic domains uncertainty initial condition action ects 
algorithm breadth rst backward search returns conformant plans minimal length solution planning problem exists terminates concluding problem admits conformant solution 
second provide symbolic representation search space binary decision diagrams bdds basis search techniques derived symbolic model checking 
symbolic representation possible analyze potentially large sets states transitions single computation step providing ecient implementation 
third cmbp conformant model planner ecient implementation data structures algorithm described directly bdd manipulations allows compact representation search layers ecient implementation search steps 
experimental comparison approach state art conformant planners cgp qbfplan gpt 
analysis includes planning problems distribution packages systems plus problems de ned stress number speci factors 
approach appears ective cmbp strictly expressive qbfplan cgp problems comparison possible cmbp outperforms competitors orders magnitude 

years growing interest planning nondeterministic domains 
rejecting fundamental unrealistic assumptions classical planning domains considered actions uncertain ects exogenous events possible initial state partly speci ed 
challenge nd strong plan guaranteed achieve goal despite nondeterminism domain regardless uncertainty initial condition ect actions 
conditional planning cassandra kaelbling littman weld anderson smith cimatti roveri traverso tackles problem searching conditional course ai access foundation morgan kaufmann publishers 
rights reserved 
cimatti roveri actions depends information gathered run time 
certain domains run time information gathering may expensive simply impossible 
conformant planning goldman boddy problem nding unconditioned course actions classical plan depend run time information gathering guarantee achievement goal 
conformant planning recognized signi cant problem arti cial intelligence michie blind robot problem requires program activity agent positioned location room guaranteed achieve goal 
conformant planning seen problem control system unobservable unknown state microprocessor power software system black box testing 
uncertainty plan associated potentially di erent executions taken account order guarantee goal achievement 
conformant planning signi cantly harder classical planning rintanen de giacomo vardi 
despite increased complexity approaches conformant planning proposed extensions main planning techniques classical planning 
interesting cgp smith weld graphplan qbfplan rintanen extends sat plan approach qbf gpt bonet ge ner encodes conformant planning heuristic search 
propose new approach conformant planning symbolic model checking mcmillan 
symbolic model checking formal veri cation technique allows analyze nite state automata high complexity relying symbolic techniques binary decision diagrams bdds bryant particular compact representation ecient search automaton :10.1.1.1.5124:10.1.1.1.5124
approach builds planning model checking paradigm cimatti colleagues nite state automata represent complex nondeterministic planning domains planning extensions basic model checking steps 
contributions 
general algorithm conformant planning applies nondeterministic domain uncertain action ects initial condition expressed nondeterministic nite state automaton 
algorithm performs breadth rst search exploring plans increasing length plan candidate plans available 
algorithm complete returns failure problem admits conformant solution 
problem admits solution algorithm returns conformant plan minimal length 
second provide symbolic representation search space binary decision diagrams allows application search techniques derived symbolic model checking 
symbolic representation possible analyze sets transitions single computation step 
sets compactly represented eciently manipulated despite potentially large cardinality 
way possible overcome enumerative nature approaches conformant planning degree nondeterminism tends limiting factor 
conformant planning symbolic model checking third developed cmbp conformant model planner ecient implementation data structures algorithm described 
cmbp developed top mbp planner symbolic model checking techniques developed cimatti roveri 
cmbp implements new techniques directly bdd manipulations compact search layers optimize termination checking 
provide experimental evaluation state art conformant planners comparing cmbp cgp qbfplan gpt 
di erence expressivity problems tackled cmbp represented planners 
problems direct comparison possible cmbp outperforms competitors 
particular features better qualitative behavior directly related number initial states uncertain action ects stable respect heuristics 
structured follows 
section review representation nondeterministic planning domains nite state automata 
section provide intuitions formal de nition conformant planning setting 
section planning algorithm section discuss symbolic representation search space allows ecient implementation 
section cmbp planner section experimental results 
section discuss related 
section draw discuss research directions 

planning domains finite state automata interested complex nondeterministic planning domains actions preconditions conditional ects uncertain ects initial state partly speci ed 
rest simple paradigmatic domain explanatory purposes variation moore bomb toilet domain mcdermott called btuc bt uncertain 
packages contains armed bomb 
possible dunk package toilet actions dunk dunk provided toilet clogged 
package uncertain ect toilet 
furthermore package containing bomb ect bomb 
action ect toilet 
represent domains nite state automata 
depicts automaton btuc domain 
state number contains propositions holding state 
instance state represents state bomb package defused toilet clogged 
bomb write abbreviation negation arrows states depict transitions automaton representing possible behavior actions 
transition state state labeled represents fact action executed state ect removing 
execution dunk state uncertain ect toilet represented multiple transitions states 
transition outgoing state labelled dunk cimatti roveri defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged flush flush dunk dunk flush flush dunk dunk flush flush flush flush dunk dunk dunk dunk automaton btuc domain state satisfy preconditions action dunk dunk applicable state 
formally de ne nondeterministic planning domains follows 
de nition planning domain planning domain tuple nite set atomic propositions set states nite set actions transition relation 
intuitively proposition state holds state 
assume planning domain 
denote states denote actions 
holds executing action state state possible outcome 
say action applicable state holds 
say action deterministic unique state holds 
action uncertain outcome distinct states hold 
described cimatti colleagues automaton domain eciently built starting compact description expressive high level action language instance ar giunchiglia kartha lifschitz 

conformant planning conformant planning goldman boddy described problem nding sequence actions guaranteed achieve goal regardless nondeterminism domain 
possible initial states uncertain action ects execution plan results goal state 
consider problem btuc domain 
initially bomb armed position status toilet uncertain initial state states 
goal reach state bomb defused toilet conformant planning symbolic model checking defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged flush flush flush flush dunk dunk dunk dunk flush flush flush flush flush flush flush flush conformant solution btuc problem clogged set goal states 
conformant plan solving problem dunk dunk outlines possible executions plan possible initial states uncertain action ects 
initial uncertainty lies fact domain states 
possible initial states planning domain collected set dashed line 
call set belief state 
intuitively belief state expresses condition uncertainty domain collecting states indistinguishable point view agent reasoning domain 
rst action remove possible 
reduces uncertainty belief state 
despite remaining uncertainty known package bomb action dunk guaranteed applicable precondition met states 
dunk ect bomb contained package uncertain ect toilet 
resulting belief state 
action removes reducing uncertainty belief state guarantees applicability dunk dunk bomb guaranteed defused toilet clogged states belief state 
nal reduces uncertainty belief state guarantees achievement goal 
general order plan conformant solution action executed states satisfy preconditions state result execution plan initial states uncertain action ects goal state 
main diculty achieving conditions information assumed available run time 
planning time face problem reasoning action execution belief state condition uncertainty 
de nition action applicability bs belief state 
action applicable bs bs applicable state bs 
cimatti roveri order action applicable belief state require preconditions guaranteed notwithstanding uncertainty 
words reject plans take chance applying action guarantee applicability 
choice strongly motivated practical domains possibly fatal consequences follow attempt apply action preconditions satis ed starting electrical device sure powered 
ect action execution uncertain condition de ned follows 
de nition action image bs belief state action applicable bs 
image called execution bs written image bs de ned follows 
image bs fs exists bs notice image action combines uncertainty belief state uncertainty action ects 
consider instance image dunk 
write image image fsg 
plans elements nite sequences actions 
length plan denote generic plans plan concatenation 
notions applicability image generalize plans follows 
de nition plan applicability image bs applicable bs holds 
bs 
applicable bs applicable image bs 
image called execution bs written image bs de ned 
image bs bs 
image bs image image bs planning problem formally characterized set initial goal states 
de nition captures intuitive meaning conformant plan 
de nition conformant planning planning domain 
planning problem triple plan conformant plan conformant solution planning problem conditions hold applicable ii image clear context omit domain planning problem simply write 
conformant planning symbolic model checking 
conformant planning algorithm conformant planning algorithm exploration space plans limiting exploration plans conformant construction 
algorithm builds belief state plan bsp pairs form bs non empty belief state plan 
idea bsp pair associate explored plan maximal belief state applicable guaranteed result goal states 
exploration basic function bs belief state bs action returns belief state containing states applicable image contained bs 
de nition strong pre image bs belief state action 
strong pre image bs written bs de ned follows 
bs fs applicable image bs empty applicable conformant solution problem bs bs 
plan conformant solution problem bs plan conformant solution problem bs 
depicts space bsp pairs built algorithm solving btuc problem 
levels built goal right initial states left 
level bsp pair hf composed set goal states indexed length plan 
notice conformant solution problem goal set initial states contained 
dashed arrows represent application level bsp pair hf built strong pre image belief state actions dunk dunk empty 
level bsp pairs overlapping belief states bs bs bs indexed respectively length plans dunk dunk 
plan associated belief state bs sequence actions labeling path bs bs notice bs equal bs deserves expansion 
expansion belief states gives belief states obtained strong pre image strong pre image actions dunk dunk returns empty belief states 
expansion bs results belief states 
resulting strong pre image reported equal bs belief state equal bs deserves expansion 
belief state obtained expanding bs bs level expansion produces bs contains initial states 
corresponding plans conformant solutions problem 
conformant planning algorithm 
takes input planning problem form set states domain assumed globally available 
algorithm performs backwards breadth rst search exploring bsp pairs corresponding plans increasing length step 
status search level represented bsp table set bsp pairs ig cimatti roveri bs bs bs bs bs bs bs bs bs bs bs level defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged defused clogged flush flush dunk dunk flush flush flush dunk dunk dunk dunk bsp tables btuc problem plans length call bs belief set indexed ambiguity arises write bs array store bsp tables representing levels search 
algorithm rst checks line plans length solution 
conformant plan length exists lans line loop entered 
iteration conformant plans increasing length explored lines 
step line expands bsp table stores resulting bsp table 
bsp pairs redundant respect current search eliminated line 
possible solutions contained extracted stored lans line 
loop terminates plan lans space conformant plans completely explored 
de nitions basic functions algorithm reported 
function expands bsp table provided argument containing conformant plans length returns bsp table conformant plans length bsp input bsp table expanded 
possible conformant planning symbolic model checking function hg plans lans plans done return fail return plans conformant planning algorithm 
action strong pre image bs computed resulting belief state bs empty belief state guarantees achievement bs plan extended returned 
expansion bsp table union expansions bsp pair 
function takes input bsp table returns possibly empty set plans index belief states containing takes input bsp table pruned array previously constructed bsp tables index current step 
removes bsp table input plans worth explored corresponding belief states visited 
algorithm properties 
terminates 
follows fact set explored belief sets stored monotonically increasing step proceed new belief state generated 
niteness set accumulated belief states contained nite point eventually reached 
second correct plan returned conformant solution problem 
correctness algorithm follows properties plan associated belief state conformant guaranteed applicable results belief state contained goal 
third algorithm optimal returns plans minimal length 
property follows breadth rst style search 
algorithm able decide problem admits solution returning fail cases 
conformant solution associated belief state containing initial states 
generates maximal belief state associated conformant plan new belief state generated exploration compared initial states check solution plan pruned equivalent plan explored 
cimatti roveri ij bs bs bs bs exists primitives conformant planning algorithm 

conformant planning symbolic model checking model checking formal veri cation technique exploration nite state automata clarke emerson sistla 
symbolic model checking mcmillan particular form model checking binary decision diagrams compactly represent eciently analyze nite state automata 
symbolic techniques model checking led breakthrough size model analyzed burch possible model checking routinely applied industry especially logic circuits design survey see clarke wing 
rest section provide overview binary decision diagrams describe representation planning domains bdd representation nite state automata model checking 
discuss extension allows symbolically represent bsp tables transformations allowing ecient implementation algorithm described previous section 
binary decision diagrams reduced ordered binary decision diagram bryant improperly called bdd directed acyclic graph dag 
terminal nodes rue alse 
nonterminal node associated boolean variable bdds called left right branches 
depicts bdd 
non terminal node right left respectively branch depicted solid dashed resp 
line represents assignment value rue alse resp 
corresponding variable 
bdd represents boolean function 
truth assignment variables bdd value function determined traversing graph root leaves branch indicated value assigned variables 
path root leaf visit nodes associated subset variables bdd 
see instance path associated 
conformant planning symbolic model checking true false false true bdds formula 
reached leaf node labeled resulting truth value 
bdd size jvj number nodes 
node var indicates variable indexing node bdds canonical representation boolean functions 
canonicity follows imposing total order set variables label nodes node respective non terminal child variables ordered var var requiring bdd contains isomorphic subgraphs 
bdds combined usual boolean transformations negation conjunction disjunction 
bdds instance conjunction operator builds returns bdd corresponding conjunction arguments 
substitution represented bdd transformations 
variable bdds indicate bdd resulting substitution 
vectors number distinct variables indicate parallel substitution variables vector corresponding variables bdds allow transformations described quanti cations style quanti ed boolean formulae qbf 
qbf de nitional extension propositional logic propositional variables universally existentially quanti ed 
terms bdd computations quanti cation corresponds mapping bdd variable quanti ed bdd resulting propositional formula 
formula variables existential quanti cation written equivalent alse rue 
analogously universal quanti cation equivalent alse cimatti roveri rue 
qbf quanti ers arbitrarily applied nested 
general qbf formula equivalent propositional formula conversion subject exponential blow 
time complexity algorithm computing truth functional boolean transformation jf 
jf 
far quanti cations concerned time complexity quadratic size bdd quanti ed linear number variables quanti ed jvj 
jf bryant 
bdd packages ecient implementations data structures algorithms brace somenzi yang coudert 
basically bdd package deals single multi rooted dag node represents boolean function 
memory eciency obtained unique table sharing common subgraphs bdds 
unique table guarantee time isomorphic subgraphs redundant nodes multi rooted dag 
creating new node unique table checked see node case new node created stored unique table 
unique table allows perform equivalence check bdds constant time equivalent functions share subgraph brace somenzi 
time eciency obtained maintaining computed table keeps track results computed transformations avoiding recomputation 
critical computational factor bdds order variables 
shows example impact change variable ordering size bdd 
certain class boolean functions size corresponding bdd exponential number variables possible variable ordering bryant 
practical cases nding variable ordering easy 
ecting memory represent boolean function nding variable ordering big impact computation times complexity transformation algorithms depends size operands 
bdd packages provide heuristic algorithms nding variable orderings called try reduce size stored bdds 
reordering algorithms activated dynamically package bdd computation total number nodes package reaches prede ned threshold dynamic 
symbolic representation planning domains planning domain represented symbolically bdds follows 
set distinct bdd variables called state variables devoted representation states domain 
variables direct association proposition domain description domain 
instance btuc domain defused clogged associated unique bdd variable 
write vector state variables 
particular order irrelevant performance issues rest section distinguish proposition corresponding bdd variable 
state set propositions speci cally propositions intended hold 
state corresponding assignment state variables assignment variable corresponding proposition assigned conformant planning symbolic model checking rue variable assigned alse 
represent bdd having assignment unique satisfying assignment 
instance defused clogged bdd representing state defused clogged represents state 
loss generality distinguish propositional formula corresponding bdd 
representation naturally extends set states follows words associate set states generalized disjunction bdds representing states 
notice satisfying assignments exactly assignment representations states representation mechanism natural 
instance bdd representing set initial states btuc defused set goal states corresponding bdd defused clogged 
bdd represent set states domain automaton 
btuc rue di erent formulation independent propositions represent position bomb bdd general bdd represents set states correspond models 
consequence set theoretic transformations naturally represented propositional operations follows 
main eciency symbolic representation lies fact cardinality represented set directly related size bdd 
instance uses non terminal nodes represent states uses node represent states 
limit cases fg leaf bdds rue alse respectively 
advantage symbolic representation extremely ecient dealing irrelevant information 
notice instance variable defused occurs 
reason symbolic representation dramatic improvement explicit enumerative representation 
allows symbolic bdd model checkers handle nite state automata large number states see instance burch 
collapse set states bdd representing 
set bdd variables called action variables written represent actions 
action variable possible action intuitively bdd action variable true corresponding action executed 
assume sequential encoding concurrent actions allowed bdd seq express exactly action variables true time 
speci case sequential encoding alternative approach dlog possible assignment action variables denotes speci action executed 
assignments mutually exclusive constraint seq needs represented 
cardinality set actions power standard solution associate assignment certain values 
optimized solution implementation described sake simplicity 
cimatti roveri btuc problem contains actions bdd variables dunk dunk express serial encoding constraint bdd seq dunk dunk dunk dunk dunk dunk state variables referring bdd action variables symbolic names sake simplicity 
practice internally represented integers position ordering bdd package totally irrelevant logical terms 
bdd variables represents set state action pairs relation states actions 
instance applicability relation btuc actions possible states actions require toilet clogged represented bdd clogged dunk dunk 
notice represents set state action pairs associating state applicable action 
transition tuple composed state initial state transition action action executed state resulting state transition 
represent transitions vector bdd variables called state variables allocated bdd package 
write representation state state variables 
denote construction bdd corresponding set states variable state vector current state variables require jx xj jx assume th variable th variable correspond 
de ne representation set states variables follows 
call operation forward shifting transforms representation set current states representation set states 
dual operation called backward shifting 
call current state variables distinguish state variables 
transition represented assignment btuc transition corresponding application action dunk state resulting state represented bdd dunk dunk transition relation automaton corresponding planning domain simply set transitions represented bdd bdd variables satisfying assignment represents possible transition 
seq rest assume bdd representation planning domain 
particular assume vectors variables encoding functions simply call bdd representing states domain transition relation initial states goal states respectively 
write stress bdd depends variables representation possible reason plans simulating symbolically execution sets actions sets states means qbf transformations 
bdd representing applicability relation directly obtained computation 
applicable conformant planning symbolic model checking resulting bdd applicable represents set state action pairs action applicable state 
bdd representing states reachable step obtained computation 
notice single operation symbolically simulate ect application applicable action states similarly transformation allows symbolically compute set states possible actions single computation applicable resulting bdd represents state action pairs hx applicable execution results states symbolic search space belief states main strength symbolic approach allows perform symbolic breadth rst search provides way compactly representing eciently expanding frontier 
instance plans constructed symbolic breadth rst search space states repeatedly applying strong pre image goal states cimatti 
machinery previous section directly applied tackle conformant planning 
basic di erence conformant planning searching space belief states frontier search basically set sets states 
introduce way symbolically represent bsp tables 
basically seen construction demand algorithm steps increasingly large portions space belief states 
key intuition bsp table hfs ig represented relation plans length states associating plan directly state belief state indexed plan follows fhs hs hs hs ig additional variables represent plans bsp tables 
order represent plans increasing length step algorithm vector new bdd variables called plan variables introduced 
vector plan variables introduced th step algorithm written encode th action plan step algorithm introduce vector plan variables represent action corresponding length possible conformant plan 
bsp 
principle machinery symbolic search conformant planning applied determinization domain automaton automaton having state space 
require exponential number state variables impractical small domains 

search performed backwards plans need reversed 
cimatti roveri table level built performing bdd computation starting bsp table level applicable computation collects state action pairs hx action represented applicable state represented resulting states represented goal states 
replace vector action variables rst vector plan variables resulting bdd represents bsp table containing plans length form relation states plans 
general case step bsp table associating belief states plans length represented bdd state variables plan variables computation performed step implemented bdd transformation applicable state variables resulting forward shifting disappear universal quanti cation 
action variables renamed newly introduced plan variables step algorithm construction repeated 
extracts assignments plan variables corresponding set contains initial states 
terms bdd transformations implemented follows result bdd plan variables bdd alse solutions length satisfying assignments resulting bdd represents conformant solution problem 
guarantee termination algorithm step bsp table returned simpli ed removing belief states deserve expansion 
requires comparison belief states contained bsp table belief states contained bsp tables built previous levels 
crucial steps terms eciency 
earlier implementation step logical bdd transformations directly set theoretical de nition extremely inecient cimatti roveri 
furthermore noticed serial encoding yield bsp tables containing large number equivalent plans indexing exactly belief state 
equivalent plans di er order independent actions potential source combinatorial explosion 
occurs simple version btuc equivalent conformant plans associated bs 
developed new implementation tackle problems operating directly bsp table 
idea depicted 
initially cache contains bs bs bs simpli cation performs traversal bdd accumulating subtrees representing belief states comparing ones built previous levels inserting new ones cache bs bs bs 
time path identi ed conformant planning symbolic model checking bs bs bs bs bs bs bs bs bs bs bs bs bs bs bs bs cached belief states cached belief states bsp table pruned bsp table example pruning bsp table represents plan indexing cached belief state plan redundant corresponding path pruned cost simpli cation linear size bsp simpli ed highly ective pruning 

cmbp bdd conformant planner cmbp conformant model planner conformant planner implementing data structures algorithms conformant planning described previous sections 
cmbp inherits features mbp cimatti planner symbolic model checking techniques 
mbp built top nusmv symbolic model checker jointly developed itc irst cmu cimatti uses somenzi state art bdd package 
mbp stage system 
rst stage internal bdd representation domain built second stage planning problems solved 
currently planning domains described means high level action language ar giunchiglia 
ar allows specify conditional uncertain ects actions means high level assertions 
instance shows ar description btuc problem semantics ar yields serial encoding exactly action assumed executed 
pruning mechanism weaker earlier cimatti roveri 
require belief state expanded twice search earlier version prune belief states contained previously explored ones 
may increase number explored belief states 
allows ecient implementation impacting properties algorithm 

stand negation conjunction respectively 
description slightly edited sake readability 
particular mbp currently accept parameterized ar descriptions 
practice script language generate ground instances di erent complexity parameterized problem description 
cimatti roveri domain btuc actions dunk dunk flush fluents defused clogged boolean inertial clogged defused flush causes clogged dunk preconditions clogged dunk causes defused dunk possibly changes clogged initially defused conformant defused clogged ar description btuc problem time 
automaton corresponding ar description obtained means minimization procedure giunchiglia 
procedure solves frame problem rami cation problem eciently implemented mbp cimatti 
separation domain construction planning phases mbp bound ar 
standard deterministic domains speci ed pddl ghallab mbp means prototype compiler 
starting investigate potential action language giunchiglia lifschitz allows represent domains parallel actions 
di erent planning algorithms applied speci ed planning problems 
operate solely automaton representation completely independent particular language specify domain 
mbp allows automatic construction conditional plans total observability implementing algorithms strong planning cimatti strong cyclic cimatti daniele traverso vardi 
cmbp implemented ideas described previous sections 
primitives construct prune bsp tables required lot tuning particular ordering bdd variables 
general ordering strategy works reasonably action variables positioned top ordering followed plan variables followed state variables current state state variables interleaved 
speci ordering action variables plan variables state variables determined standard mechanism implemented nusmv 
cmbp implements algorithms conformant planning 
addition backward algorithm conformant planning symbolic model checking section cmbp implements algorithm forward search allows exploit initial knowledge problem resulting signi cant speed ups cimatti roveri 
backward forward search combined tackle exponential growth search time depth search 
algorithms di erent options enable disable di erent versions termination check 

experimental evaluation section experimental evaluation approach carried comparing cmbp state art conformant planners 
rst describe conformant planners considered analysis experimental comparison carried 
conformant planners cgp smith weld extends ideas graphplan blum furst deal uncertainty 
basically planning graph built possible sequence possible worlds constraints planning graphs propagated ensure conformance 
cgp system takes input domains described extension pddl ghallab possible specify uncertainty initial state 
cgp inherits graphplan ability deal parallel actions 
cgp rst ecient conformant planner shown outperform planners buridan peot kushmerick hanks weld 
detailed comparison reported smith weld leaves doubt superiority cgp respect systems 
compared cmbp cgp consider systems analyzed smith weld 
cmbp expressive cgp respects 
cgp handle uncertainty initial state 
instance cgp analyze btuc domain section 
smith weld describe approach extended actions uncertain ects 
second cgp conclude planning problem conformant solutions 
qbfplan name planning system rintanen 
qbfplan generalizes idea sat planning kautz mcallester selman kautz selman nondeterministic domains encoding problems qbf 
qbfplan approach limited conformant planning conditional planning uncertainty partial observability di erent encodings corresponding di erent structures resulting plan synthesized 
considering encodings enforce resulting plan sequence 
bound length plan rst qbf encoding problem generated qbf solver rintanen called 
solution new encoding longer plan generated solved 
qbfplan able handle actions uncertain ects 
done introducing auxiliary choice variables assignments different possible outcomes actions correspond 
variables universally quanti ed ensure conformance solution 
di erently blackbox kautz selman qbfplan heuristic guess right length plan 
limit length plan generates encodings speci ed length repeatedly calls qbf solver encodings increasing length plan 
cimatti roveri cgp qbfplan conclude planning problem conformant solutions 
similarly cmbp qbfplan relies symbolic representation problem qbf transformations performed theorem prover bdds 
gpt bonet ge ner general planning framework conformant planning problem seen deterministic search problem space belief states 
gpt uses explicit representation search space belief state represented separate data structure 
search algorithm nilsson driven domain dependent heuristics automatically generated problem description 
gpt accepts problem descriptions syntax pddl extended deal probabilities uncertainty 
possible represent domains uncertain action ects representation actions resulting large number di erent states awkward 
planning algorithm gpt able conclude planning problem conformant solution exhaustively exploring space belief states 
experiments results evaluation performed running systems number parameterized problem domains 
considered problems cgp gpt distributions plus problems de ned test speci features planners 
considered domains uncertainty limited initial state domains uncertain action ects 
problems admitting solution considered problems admitting solution case measured ectiveness returning failure 
di erent expressivity possible run systems examples 
cmbp run classes examples gpt run 
cgp run problems admit solution uncertainty limited initial condition 
qbfplan run examples encoding available qbfplan distribution 
subset problems expressible cgp 
main limiting factor low level input format qbfplan problem descriptions speci ed ml code generates qbf encodings 
writing new encodings turned dicult task especially due lack documentation 
ran cgp qbfplan cmbp intel mhz pentium ii mb ram running linux 
comparison cmbp gpt run sun ultra sparc mhz mb ram running solaris gpt available binary 
performance machines comparable run times cmbp identical 
cpu time limited sec hours test 
avoid swapping memory limit xed physical memory machine 
write test complete time memory limits respectively 
performance systems reported tables listing search time 
excludes time needed qbfplan generate encodings time spent cmbp construct automaton representation bdd time needed gpt generate source code internal representation compile 
signi cant time ignored automaton construction cmbp 
conformant planning symbolic model checking currently automaton construction fully optimized 
complex examples construction required couple minutes bomb toilet bomb toilet 
rst domain tackled classical bomb toilet notion 
call problem bt parameter number packages 
uncertainty initial condition known package contains bomb 
goal bomb 
results bt problem shown table 
columns relative cmbp length plan jpj number cached belief states number hits cache bs nbs respectively time expressed seconds needed searching automaton pentium linux time sparc solaris time 
clear context execution platform omitted 
columns relative cgp number levels planning graphs jlj search time 
column relative gpt search time 
cmbp cgp gpt jpj bs bsh time time jlj time time bt bt bt bt bt bt bt bt bt table results bt problems 
bt problem intrinsically parallel depth planning graph packages time 
cgp inherits graphplan ability deal parallel actions eciently insensitive problem size 
problem cgp outperforms cmbp gpt 
notice number levels explored cgp length plan produced cmbp cgp grows linearly 
cmbp performs slightly better gpt 
bomb toilet 
call btc extension bt package toilet remove precondition package 
number packages 
toilet initially clogged 
modi cation problem longer allows parallel solution 
results problem listed table 
impact depth plan length signi cant systems 
cmbp gpt outperform cgp 
case cmbp performs better gpt especially large instances see btc 

precisely maximum time building automaton required examples secs ring example secs examples secs examples secs 
examples time required automaton construction seconds 
cimatti roveri cmbp cgp gpt jpj bs bsh time time jlj time time btc btc btc btc btc btc btc btc btc btc qbfplan btc btc jpj time jpj time table results btc problems 
comparison qbfplan limited package instances ones available distribution package 
performance qbfplan reported left table table 
line reports time needed decide plan length performance qbfplan tackling encoding admitting solution table entries labeled 
instance btc qbfplan nds solution solving encodings depth reasonably fast 
solution qbf formula admits model performance qbfplan degrades signi cantly depth encoding solver run cpu hours complete search 
di erence performance diculty writing new domains rest comparison consider qbfplan 
bomb multiple 
domain called generalization btc problem case multiple number packages number 
problem parallelizable number increases 
furthermore considered versions problem increasing uncertainty initial states 
rst class tests low uncertainty columns uncertainty position bomb unknown known clogged 
mid uncertainty high uncertainty columns show results presence uncertainty initial state 
second third respectively class tests status odd resp 
toilet clogged clogged 
increases number possible initial states 
results reported table comparison cgp table comparison gpt 
column represents number initial states corresponding problem 
cgp able fully exploit parallelism problem 
cgp able explore levels planning graph depth decreasing number initial states 
results show cmbp gpt sensitive number initial states cgp 
increasing initial conformant planning symbolic model checking low uncertainty mid uncertainty high uncertainty cmbp cgp cmbp cgp cmbp cgp jpj bs bsh time jlj time bs bsh time jlj time bs bsh time jlj time table results problems 
cimatti roveri low unc 
high unc 
cmbp gpt cmbp gpt time time time time table results problems 
uncertainty cgp unable solve trivial problems 
gpt performs better cgp su ers explicit representation search space 
bomb toilet uncertain 
btuc domain domain described section uncertain outcome package 
kind problem expressed cgp 
results cmbp gpt reported table 
cmbp performs better gpt factor signi cant di erence behavior 
interesting compare results cmbp btc btuc problems 
gpt slight di erence noticeable resulting increased branching factor search space due uncertainties ects action executions 
performance cmbp number uncertainties direct factor example btc btuc performance 
ring rooms simple ring room 
considered domain robot move ring rooms 
room window open closed locked 
robot move clockwise counterclockwise close window room lock closed 
goal windows locked 
conformant planning symbolic model checking cmbp gpt jpj bs bsh time time btuc btuc btuc btuc btuc btuc btuc btuc btuc btuc table results btuc problems 
problem ring number rooms uncertainty initial condition position robot status windows uncertain 
problems parallel solution large number initial states corresponding full uncertainty position robot status window 
results reported left table 
cmbp outperforms cmbp cgp gpt jpj bs bsh time jlj time time ring ring ring ring ring ring ring ring ring cgp ring jlj time jlj time table results ring problems 
cgp gpt gpt performs better cgp 
cgp gpt su er increasing complexity problem 
right table plot ring problem dependency cgp number initial states combined number levels explored di erent goals provided require exploration di erent levels 
clear number initial states depth search critical factors cgp 

times reported cgp refer scaled version problem locking taken account maximum number initial states cimatti roveri ring rooms uncertain action ects 
considered variation ring domain called rst introduced cimatti roveri expressible cgp 
window locked robot performing action determine status closing window open close nondeterministically 
instance robot moving room room windows room open closed wind 
domain clearly designed stress ability planner deal actions having large number resulting states 
worst case move action performed window locked possible resulting states 
seemingly arti cial captures fact environments practice highly nondeterministic 
tried compare cmbp gpt problem 
principle gpt able deal uncertainty action ects 
failed codify gpt language requires conditional description uncertain ects 
experimented variation ring domain featuring higher degree nondeterminism called 
domain contains increasing number additional propositions called noninertial propositions initially unknown nondeterministically altered action 
number noninertial propositions action cmbp gpt jpj bs bsh time time time time time table results problems 
possible outcomes 
results listed table columns labeled time 
growing branching factor search major impact performance gpt cmbp insensitive kind uncertainty 
performance cmbp lower number noninertial propositions reported basically 
problem run cmbp 
results listed table 
noticed performances cmbp improve signi cantly respect ring problem 
explained considering despite larger number transitions number explored belief states signi cantly smaller see bs cache statistics tables 
square cube domains square cube gpt distribution bonet ge ner 
problems consist robot navigating square cube side domains actions moving robot possible directions 
moving robot boundary leaves robot position 
original conformant planning symbolic model checking cmbp jpj bs bsh time table results problems 
problems called corner require robot reach corner starting completely unspeci ed position 
introduced variations 
rst called face initial position position side face square cube goal reach central position opposite side face 
second called center initial position completely unspeci ed goal center square cube 
corner problem simple heuristic perform steps corner pruning half actions 
variations designed allow simple heuristic instance center problem action eliminated 
corner face center square cmbp gpt cmbp gpt cmbp gpt jpj bs bsh time time jpj bs bsh time time jpj bs bsh time time square square square square square square square square square square corner face center cube cmbp gpt cmbp gpt cmbp gpt jpj bs bsh time time jpj bs bsh time time jpj bs bsh time time cube cube cube cube cube cube cube cube cube cube table results square cube problems 
results problems reported table 
tests run cmbp gpt 
experiments highlight eciency gpt strongly depends quality heuristic function 
rst set experiments heuristics cimatti roveri ective gpt cmbp 
gpt degrades signi cantly 
general nding heuristics ective belief space appears nontrivial problem 
cmbp appears stable performs blind breadth rst search relies cleverness symbolic representation achieve eciency 
considered problem levesque 
goal eggs bad ones capacity unlimited number eggs unpredictably bad 
eggs grabbed broken bowl 
content bowl discarded poured bowl 
breaking egg bowl ect spoiling bowl 
bowl cleaned discarding content 
problem originally partial observability problem sensing action allowing test bowl spoiled 
considered variation problem sensing action case conformant solution exists 
problems test ability cmbp gpt discover problem admits conformant solution 
results reported table 
table shows cmbp ective checking absence conformant solution outperforms gpt orders magnitude 
cmbp gpt steps bs bsh time time table results problems 
summarizing remarks cmbp appears implement ective approach conformant planning terms expressivity performance 
cgp able deal uncertainties initial states conclude problem admit conformant solution 
main problem cgp enumerative approach uncertainties increased number initial states severely ects performance see table table 
qbfplan principle able deal uncertain action ects conclude problem admit conformant solution 
small number ex 
consider problems increasingly dicult see instance plan length 
conformant planning symbolic model checking periments perform approach implemented qbfplan limited satplan style search intermediate results obtained solving encoding depth reused solving encodings increasing depth 
furthermore solver appears specialized nding model proving unsatis ability 
ability needed encodings nal 
gpt expressive system allows eciently dealing wide class planning problems 
far conformant planning concerned expressive cmbp 
allows dealing uncertain action ects conclude problem conformant solution 
cmbp appears outperform gpt respects 
behaviour gpt appears directly related number possible outcomes action 
furthermore eciency gpt depends ectiveness heuristic functions dicult devise help problem admit solution 
main strength cmbp independence number uncertainties achieved symbolic techniques 
fully symbolic cmbp exhibit enumerative behaviour competitors 
compared original approach described cimatti roveri substantial improvement performance obtained new implementation pruning step 
disclaimer order 
known bdd computations subject blow memory requirements computing certain classes boolean functions multipliers bryant :10.1.1.1.5124:10.1.1.1.5124
trivial example performance cmbp degrades exponentially 
examples considered included examples distribution cgp gpt phenomenon occurred 

related term conformant planning rst introduced goldman presenting formalism constructing conformant plans extension dynamic logic 
giunchiglia conformant planner sat techniques 
system available direct comparison cmbp 
ectiveness approach dicult evaluate limited testing described giunchiglia 
performance claimed comparable cgp 
results reported corresponding solution behaviour qbfplan reported table suggests kind analysis limited 
works share idea planning automata theory 
closely related works lines planning model checking cimatti 
approach allows instance automatically construct universal plans guaranteed achieve goal nite number steps cimatti implement trial error strategies cimatti daniele 
results obtained hypothesis total observability run time observation available 
main di erence substantial extension required lift symbolic techniques search space belief states 
de giacomo vardi analyze forms planning automata theoretic framework 
goldman musliner method model checking timed automata interleaved plan formation activity sure cimatti roveri timing constraints met 
hoey colleagues algebraic decision diagrams tackle problem stochastic planning 

new approach conformant planning symbolic model checking techniques 
algorithm general applies complex planning domains uncertainty initial condition action ects described nite state automata 
algorithm breadth rst backward search returns conformant plans minimal length solution planning problem exists 
terminates failure 
algorithm designed take full advantage symbolic representation bdds 
implementation approach cmbp system highly optimized particular crucial step termination checking 
performed experimental comparison approach state art conformant planners cgp qbfplan gpt 
cmbp strictly expressive qbfplan cgp 
problems comparison possible cmbp outperformed competitors terms run times orders magnitude 
symbolic data structures cmbp able deal eciently problems large numbers initial states action outcomes 
hand qualitative behavior cgp gpt depend heavily enumerative nature algorithms 
di erently gpt cmbp independent ectiveness heuristic drive search 
research extended directions 
investigating alternative approach conformant planning breadth rst style search 
techniques appear extremely promising preliminary experiments led speed ups orders magnitude results problems admit solution 
second tackle problem conditional planning partial observability hypothesis limited amount information acquired run time 
conformant planning problem seen search belief space 
appears signi cantly complicated need dealing run time observation conditional plans 
considering extension domain construction planner expressive input language invariant detection techniques 
fausto giunchiglia provided continuous encouragement feedback 
bertoli bonet marco daniele hector ge ner enrico giunchiglia jussi rintanen david smith paolo traverso dan weld valuable discussions conformant planning various comments 
david smith provided code cgp large number examples time mechanism experimental evaluation 
jussi rintanen qbfplan available linux 
conformant planning symbolic model checking blum furst 

fast planning planning graph analysis 
proc 
ijcai 
blum furst 

fast planning planning graph analysis 
arti cial intelligence 
bonet ge ner 

planning incomplete information heuristic se arch belief space 
chien kambhampati knoblock 
eds th international conference arti cial intelligence planning scheduling pp 

aaai press 
brace bryant 

ecient implementation bdd package 
th acm ieee design automation conference pp 
orlando florida 
acm ieee ieee computer society press 
bryant 

graph algorithms boolean function manipulation 
ieee transactions computers 
bryant 

complexity vlsi implementations graph representations boolean functions application integer multiplication 
ieee transactions computers 
bryant 

symbolic boolean manipulation ordered binary decision diagrams 
acm computing surveys 
burch clarke mcmillan dill hwang 

symbolic model checking states 
information computation 
cassandra kaelbling littman 

acting optimally partially observable stochastic domains 
proc 
aaai 
aaai press 
cimatti clarke giunchiglia roveri 

nusmv new symbolic model checker 
international journal software tools technology transfer 
cimatti giunchiglia giunchiglia traverso 

planning model checking decision procedure ar 
steel alami 
eds proceeding fourth european conference planning lecture notes arti cial intelligence pp 
toulouse france 
springer verlag 
itc irst technical report itc irst trento italy 
cimatti roveri 

conformant planning model checking 

ed proceeding fifth european conference planning lecture notes arti cial intelligence durham united kingdom 
springer verlag 
itc irst technical report itc irst trento italy 
cimatti roveri cimatti roveri 

forward conformant planning symbolic model checking 
proceeding aips workshop model theoretic approaches planning breckenridge colorado 
cimatti roveri traverso 

automatic obdd generation universal plans non deterministic domains 
proceeding fifteenth national conference arti cial intelligence aaai madison wisconsin 
aaai press 
irst technical report trento italy 
cimatti roveri traverso 

strong planning non deterministic domains model checking 
proceeding fourth international conference arti cial intelligence planning systems aips carnegie mellon university pittsburgh usa 
aaai press 
clarke wing 

formal methods state art directions 
acm computing surveys 
clarke emerson sistla 

automatic veri cation nite state concurrent systems temporal logic speci cations 
acm transactions programming languages systems 
coudert madre touati 

tiger version user guide 
digital paris research lab 
daniele traverso vardi 

strong cyclic planning revisited 

ed proceeding fifth european conference planning lecture notes arti cial intelligence durham united kingdom 
springer verlag 
de giacomo vardi 

automata theoretic approach planning temporally extended goals 

ed proceeding fifth european conference planning lecture notes arti cial intelligence durham united kingdom 
springer verlag 
giunchiglia 

planning satis ability nondeterministic domains 
proceedings seventeenth national conference arti cial intelligence aaai austin texas 
aaai press 
ghallab howe knoblock mcdermott ram weld wilkins 

pddl planning domain de nition language 
tech 
rep cvc tr dcs tr yale center computational vision control 
giunchiglia 

determining rami cations situation calculus 
fifth international conference principles knowledge representation reasoning kr cambridge massachusetts 
morgan kaufmann publishers 
giunchiglia kartha lifschitz 

representing action indeterminacy rami cations 
arti cial intelligence 
conformant planning symbolic model checking giunchiglia lifschitz 

action language causal explanation preliminary report 
proceedings th national conference arti cial intelligence aaai th conference innovative applications arti cial intelligence iaai pp 
menlo park 
aaai press 
goldman musliner 

model checking plan hard real time controllers 
proceeding aips workshop modeltheoretic approaches planning breckenridge colorado 
goldman boddy 

expressive planning explicit knowledge 
proceedings rd international conference arti cial intelligence planning systems aips pp 

aaai press 
hoey st aubin hu boutilier 

spudd stochastic planning decision diagrams 
proceedings fifteenth conference uncertainty articial intelligence pp 

aaai press 
kautz selman 

blackbox new approach application theorem proving problem solving 
working notes workshop planning combinatorial search pittsburgh pa usa 
kautz mcallester selman 

encoding plans propositional logic 
proc 
kr 
kautz selman 

pushing envelope planning propositional logic stochastic search 
proc 
aaai 
kushmerick hanks weld 

algorithm probabilistic planning 
arti cial intelligence 
levesque 

planning presence sensing 
proceedings thirteenth national conference arti cial intelligence eighth innovative applications arti cial intelligence conference pp 
menlo park 
aaai press mit press 
mcdermott 

critique pure reason 
computational intelligence 
mcmillan 

symbolic model checking 
kluwer academic publ 
michie 

machine intelligence edinburgh 
machine intelligence pp 

edinburgh university press 
nilsson 

principles arti cial intelligence 
morgan kaufmann publishers los altos ca 
peot 

decision theoretic planning 
ph thesis dept engineering economic systems stanford university 
rintanen 

constructing conditional plans theorem prover 
journal arti cial research 
cimatti roveri rintanen 

improvements evaluation quanti ed boolean formulae 
dean 
ed th joint conference arti cial intelligence pp 

morgan kaufmann publishers 
smith weld 

conformant graphplan 
proceedings th national conference arti cial intelligence aaai th conference innovative applications arti cial intelligence iaai pp 
menlo park 
aaai press 
somenzi 

cu decision diagram package release 
department electrical computer engineering university colorado boulder 
weld anderson smith 

extending graphplan handle uncertainty sensing actions 
proceedings th national conference arti cial intelligence aaai th conference innovative applications arti cial intelligence iaai pp 
menlo park 
aaai press 
yang bryant hallaron biere coudert janssen ranjan somenzi 

performance study bdd model checking 
proceedings formal methods computer aided design pp 


