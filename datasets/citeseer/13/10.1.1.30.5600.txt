geneva convention treatment object aliasing john hogg bell northern research doug lea suny alan wills university manchester dennis hewlett packard richard holt university toronto aliasing problem formal verification practical programming number years 
difficult prove simple hoare formula fx trueg false fx trueg 
refer boolean variable aliased formula valid proving aliasing occur straightforward 
practicing programmer aliases result mysterious bugs variables change values seemingly 
classic example matrix multiply routine mult left right result puts product parameters third 
works perfectly day unsuspecting programmer writes reasonable statement mult 
implementor routine consider possibility argument may aliased result disaster inevitable 
years solutions workarounds aliasing problems traditional languages matter seemingly control 
unfortunately described solutions tend conservative useful object oriented programs 
object paradigm sold partly basis strong encapsulation provides 
misleading claim 
single object may encapsulated single objects interesting 
object part system useful system objects necessarily encapsulated 
picture entirely 
partial solutions object oriented aliasing problem put forward 
research needed fill rest puzzle looks bright researchers treat problem truly object oriented perspective 
convention defines explains aliasing object oriented context 
various approaches described proposals areas research 
definitions start defining terms informally 
model objectoriented systems simple smalltalk flavour terms defined assumed smalltalk meanings 
object primitive integer boolean constructed constructed object set instance variables hold objects 
variable implicitly pointer variable 
object set methods instance variables local variables parameters 
method invoked sending message object may turn send messages set variables 
set object address values associated variables execution method context 
meaningful speak aliasing occurring context instance variables refer single object belongs object reached system aliasing irrelevant 
accord smalltalk snyder object model assume method argument result passing performed manner classically described better labelled identity 
objects may accessed directly bound variable indirectly instance variables objects 
generally access path sequence variable names 
evaluation variable current context yields new context object set instance variable evaluation successive variable path yields object context 
particular access paths may include traversals objects held collections 
method objects may accessed paths rooted 
self 

anonymous locally constructed object 

method argument 

result returned method 

global variable accessible method scope 

local method variable bound 
object aliased respect context paths exist 
conceptual operational stance aliasing occurs object accessed possible roles program different roles indicated multiple names access paths aliasing problem roles conflict 
conflicts simple trying simultaneously serve source destination matrix multiplication intricate account payment various side channels complex financial system 
determination object referred different roles just surprising conceptually difficult analytically discovering dealing alias conditions program semantically meaningful challenge merely technical exercise determining correctness safety properties 
illustrate ancient example centuries astronomers distinct terms evening star morning star realizing referred object planet venus 
programming situations detection aliasing matter analysis scientific discovery large programs difficult distinguish 
aliasing problems may result insufficient problem analysis leading situations roles accidentally conflict typically arise class method design implementation decisions ignore possibility aliasing intentionally disallow making fact visible clients 
case fact objects referred variables describing roles manipulated terms identities means aliasing essentially aliasing problems possible object weg paradigm constructs inheritance concurrency persistence supported 
features accentuate complicate problems 
simple subclass polymorphism aliasing opportunities difficult notice appreciate especially statically typed languages 
example function may aliased subclass vice versa 
aliasing objects aspect object system set apart traditional procedural languages presence persistent local state 
object encapsulates set variables externally visible retain values method invocations 
traditional languages aliasing dynamic sense exists duration particular scope entry 
global variables exist duration global scope 
scope exit aliases created scope disappear 
contrast method scope left dynamic aliases involving parameters temporary variables go away 
instance variables retain values static aliasing object scope 
worry aliasing execution method may change behaviour seemingly object may happen affected object accessed 
real state object fully specified just variables states objects variables refer 
value predicate denotational terms result method operational terms may depend states object reached context state object state transitive closure objects reached 
objects effectively aliased transitive closures objects reachable non empty intersection 
example consider bank object containing number portfolios port port 
portfolio attributes class account 
account instance understands methods debit credit decrease increase balance respectively 
methods understood portfolio apply turn 
portfolio instance understands method amount debit credit parameter amount second parameter 
port port amount really decrease amount money port 
ways fail happen 
port port may portfolio port port aliases 
recognized bank object require port port object identity comparator 
unfortunately port unaltered final balance port port different share common 
account aliased respect bank context portfolios effectively aliased 
difficult deal express idea programming language claims provide encapsulation 
amount method port entered way refer account object held portfolio parameter 
treatment aliasing object aliasing problem known time mey discussions reached print 
broadly categorize approaches aware terms detection 
static dynamic run time diagnosis potential actual aliasing 
advertisement 
annotations help modularize detection declaring aliasing properties methods 
prevention 
constructs disallow aliasing statically checkable fashion 
control 
methods isolate effects aliasing 
alias detection alias detection post hoc activity 
determining variables reasonably expected alias object determines alias patterns potentially program static compile time dynamic run time techniques 
especially absence priori information useful compilers static analysis tools programmers detect aliasing conflicts programs 
compilers generate efficient code static analyzers assist discovering cases aliasing may invalidate predicates programmers specially deal troublesome conflicts 
aliasing usually non local phenomenon static detection requires np hard interprocedural analysis lr resulting information variables alias object aliased refers situations variables aliased invocations including paths necessarily taken actual execution 
aliased aliased cases useful optimization purposes 
example arrays aliased independently manipulated vector processors variables aliased represented single pointer 
unfortunately ubiquity aliasing opportunities objectoriented programs full analyses slow practical result aliased case 
techniques message splitting customization pioneered self cu show promise improving matters 
example automatically splitting specially generating code aliased versus non aliased versions method may simplify analysis allow optimizations 
programmers write code detect aliasing conflicts run time take evasive action 
possible runtime alias detection object identity comparison fully supported object oriented languages 
pointer identity operations purposes may cases 
notable examples include variables object referred terms multiply inherited base classes languages full support object persistence identity preservation objects recovered secondary storage 
described access protection may impede programmer ability check identities 
alias advertisement global detection impractical important develop methods constructs lead modular analysis 
programmers benefit constructs enhance locality analysis annotating methods terms resulting aliasing properties 
evidence contrary people tend optimistic assumptions aliasing properties methods 
example programmers find surprising arg method boolean object programmed return self self held true arg 
correct behaviour programmers expect return new object aliased operands expressions 
popular object oriented languages means indicating methods capture objects creating access paths instance variables return variables globals persist invocation 
constructs annotations indicating object bindings captured method aliases method able cope play role similar independent qualifiers const related constructs integrate useful subsets full behavioural specifications 
annotations describing mutability negatively expressed qualifiers useful 
way qualifying parameter const advertises argument modified qualifier indicate object bound variable cause modified side channels method returns 
example typical constructive implementation may declare self arg const return variable 
addition indicating postcondition sorts aliases propagated method may similarly advertised restriction precondition actual arguments aliased construct 
default restriction turing 
pattern const operands results object oriented analog pure functions opposed procedures discussed hog languages specially mark operations special category turing enhance informal formal reasoning program behaviour 
actual enforcement qualifiers leads notion alias prevention 
alias prevention alias prevention techniques introduce constructs promise aliasing occur particular contexts ways guarantee static compilers program analyzers 
static requires conservative definitions constructs 
example checkable version prohibit bindings variable method calls methods attributes 
prohibit uses programmers happen know propagate aliases syntactically determined safe 
statically checkable form 
example rules aliasing prevention turing assume change single entity collection assumed affected entire collection 
result strong aliasing protection turing applied object turing losing ability express common object oriented idioms 
conservatism useful ensures validity able prove formulas invalid due aliasing programmer able compile code aliasing produce surprises example 
valid formulas may provable proof system complete sense coo perfectly safe code may compile errors warnings 
fine grained alias prevention constructs limited utility 
higher level constructs required order overcome problems 
islands hog provide mechanism isolating group objects 
set syntactic mechanisms ensure static exist boundary island 
atomic assignment operation sets previous null allows objects passed boundary 
island system aliasing control nested island completely encapsulated unit 
means prevention mechanism scales control strategy confined small groups objects need scale 
radical approach hw traditional assignment operator copies right side left replaced swapping operator exchanges bindings sides 
avoiding copying aliasing avoided problems disappear 
naturally programmer learn different paradigm 
unclear paradigm mesh mainstream object oriented pro gramming techniques 
alias control aliasing prevention sufficient aliasing avoidable conventional object oriented paradigm 
remain cases effects aliasing determined account runtime state system 
circumstances aliasing control applied 
programmer determine system reach state unexpected aliasing precluded examination code components isolation 
show predicate affected effectively aliased left side assignment statement 
control analysis state reachability 
proof system object oriented language spool adb 
uses aliasing control exclusively prevention component management strategy 
predicate language extension programming language encapsulation removed 
context variables objects referred variable paths defined earlier 
example assert port port context bank 
approach impractical smallest application forms foundation 
wil approach aliasing control proposed 
concept related reaches lg 
set objects participate representation value 
programmer defines class function yields union singleton set containing self instance variables 
backward pointers cache variables omitted 
named may provided class 
functions need implemented reason program 
example statements parameters allowed intersect 
statements framing objects may changed method terms preserve encapsulation detailed definition classes 
aliasing problem attracting increasing amount attention 
component reuse requires adequate description component behaviour components sufficiently encapsulated behaviours predictable 
ensure aliasing detected occurs advertised possible prevented wanted controlled needed 
adb pierre america frank de boer 
sound complete proof system spool 
technical report philips research laboratories may 
cu craig chambers david ungar 
making pure object oriented languages practical 
oopsla proceedings october 
coo stephen cook 
soundness completeness axiom system program verification 
siam journal computing february 
richard holt philip matthews alan james cordy 
turing language design definition 
prentice hall 
hog john hogg 
islands aliasing protection object oriented languages 
oopsla proceedings october 
hw harms weide 
copying swapping influences design reusable software components 
ieee transactions software engineering may 
lr william landi barbara ryder 
pointer induced aliasing problem taxonomy 
proceedings eighteenth annual acm sigact sigplan symposium principles programming languages pages january 
lg john lucassen david gifford 
polymorphic effect systems 
proceedings fifteenth annual acm sigact sigplan symposium principles programming languages pages january 
mey bertrand meyer 
object oriented software construction 
prentice hall 
alan snyder 
modelling object model application object model ecoop proceedings springer verlag lncs pages july 
weg peter wegner 
dimensions object language design 
oopsla proceedings october 
wil alan wills 
capsules types program verification smalltalk 
ecoop proceedings springer verlag lncs pages july 

