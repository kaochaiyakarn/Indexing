xi pi theta gamma delta mcgill university school computer science acaps laboratory advanced compilers architectures parallel systems register allocation framework hierarchical cyclic interval graphs laurie hendren guang gao erik acaps technical memo revised february original version november 
electrical mcgill university university street montr eal qu ebec acaps ffl school computer science ffl university st ffl montr eal ffl canada ffl propose cyclic interval graphs alternative representation register allocation 
thickness cyclic interval graph captures notion overlap live ranges variables relative particular point time program execution 
demonstrate cyclic interval graphs provide feasible effective representation accurately captures periodic nature live ranges loops 
new heuristic algorithm minimum register allocation fat cover algorithm developed implemented exploit program structure 
addition new spilling algorithm proposed extra information available interval graph representation 
algorithms provide phase register allocation process require iteration spilling coloring phases 
extend notion cyclic interval graphs hierarchical cyclic interval graphs outline framework compiler representation performing register allocation programs hierarchical control structure nested conditionals loops 
effectiveness approach demonstrated experimenting collection challenging loops 
contents interval graphs interference graphs chaitin heuristics cyclic interval graphs coloring cyclic interval graphs observations cyclic interval graphs finding minimal coloring cyclic interval graphs fat cover algorithm introductory example fat cover algorithm formal description fat cover algorithm approaches interference graph algorithm greedy algorithm hybrid algorithm experimental comparison finding coloring cyclic interval graphs chameleon intervals register floats register spills reducing width interval graph hierarchical cyclic interval graphs interval graph performance benchmark programs related ii list figures interference graph interval graph cyclic interval graph example fat cover algorithm example applying hybrid fat cover algorithm number extra registers coloring random graphs example register spilling register floating example introducing spill code nested loops hierarchical structured interval graphs examples consistent allocation required conditionals nested conditional hierarchical structured interval graph list tables number double precision loads stores registers tomcat 
number double precision loads stores registers loop 
number double precision loads stores registers 
interval graph statistics spilling 
iii register allocation plays important role compiler optimization 
fact modern high performance processor architectures register allocation viewed technique adds largest single improvement various compiler optimizations 
technology advance past decade widened gap speed cpu memory drams gap form von neumann bottleneck expected continue grow 
benefit keeping variables registers increasing impact register allocation strategies increasing 
register allocators modern compilers employ classical graph coloring method originally proposed chaitin improved 
method interference graph built direct register allocation 
node graph corresponds live range program variable 
edge nodes graph represents interference live ranges 
chaitin heuristics color graph colors adjacent nodes assigned different colors 
coloring interference graph corresponds feasible register assignment registers 
graph colorable spill code introduced 
set live ranges interference graph encodes overlapping interference live ranges entire code segment entire procedure function body 
representation provides concise summary constraints met correct register allocation 
furthermore interference graph approaches suited general purpose register allocation works programs irregular complex flow control 
believe concise general strategy weakness interference graph approach 
point view interference graphs provide representation problem particularly case structured inner loop nests 
specifically interference graph encode notion relative time overlaps live ranges 
information useful developing effective coloring spilling heuristics 
particularly true considers effectively model live range loop variable lifetime may cross boundary iterations may defined repetitively regular intervals 
weakness interference graph approach potential expense required rebuild interference graph spill code introduced 
successful efforts improve chaitin original interference graph approach section propose new approach different representation cyclic interval graphs 
intuitively thickness point cyclic interval graph captures information overlapping live ranges variables particular location program 
see information fat spot crucial developing new heuristic algorithms 
argue approach interval graphs address shortcomings interference graph approaches 
approach takes advantage program structure relative times live ranges focused methods structured programs particular large inner loops loop nests 
main contributions include ffl demonstrate cyclic interval graphs provide feasible effective representation characterize sequences live ranges variables successive iterations loop 
section ffl new heuristic algorithm minimum register allocation fat cover algorithm developed implemented studied 
section ffl new spilling algorithm proposed extra information available interval graph representation 
possible favors register floats moving values register traditional register spills storing spilled variable memory 
furthermore spilling phase invoked need iterating allocation spilling phases section possibility interval graphs model register allocation noted 
knowledge previous research theoretical nature mainly focussed algorithmic aspects interval graph model 
furthermore issues applying models real programs hierarchical control structures nested conditionals loops addressed 
objective quite different primarily interested feasibility interval graphs register allocators real life compilers 
important note claim interval graph methods solve problems register allocation 
general accept view ultimate best method register allocation 
contrary believe different approaches suited different sorts programs 
example program segments irregular control flow little program structure exploit interference graph representation probably best abstraction 
program segments nested loops structured conditionals program structure exploited encoding problem cyclic interval graphs 
view interference graph approach cyclic interval graph approach complementary 
noted concentrate examples innermost loops 
section discuss scheme naturally extends hierarchical method handle nested loops conditionals 
section experimental results demonstrate effectiveness approach large loops difficult color 
compare results prototype spilling coloring implementations results observed compiling loops state art optimizing compilers sun sparc compiler mips compiler ibm rs compiler 
related section section 
interval graphs section review traditional interference graph representation introduce cyclic interval graph representation 
interference graphs chaitin heuristics outlined section traditional approach uses interference graph representation nodes represent live ranges variables edges represent interference live ranges 
precise live ranges interfere live definition point 
node degree neighbors 
chaitin method colors graph colors adjacent nodes assigned different colors 
coloring interference graph corresponds feasible register assignment registers 
basic heuristics chaitin original method simple observation graph having node degree colorable reduced graph formed removing adjacent edges colorable 
chaitin algorithm tries remove nodes degree point remains nodes degree greater equal spilling performed 
involves spill code store definition spilled variable memory load uses heuristic 
spill code replaces long live range short live ranges interference graph rebuilt coloring process repeated coloring succeeds introducing new spill code 
improvements chaitin original method proposed 
example improvement observation necessary spill node neighbors 
neighbors allocated color spilling necessary 
example observe coloring achieved correct subset nodes colored color 
cyclic interval graphs cyclic interval graph approach designed expose program structure useful choosing intervals color color intervals best spill 
challenge designing new representation determining represent live ranges loop variables 
shows loop iterations 
numbers written alongside instructions instruction numbers 
scalar variables defined loop 
note case loops variable sequence live ranges correspond different iterations loop 
example live range variable split segments 
iteration defined outside loop dies instruction loop 
section live range 
addition iteration loop defined instruction iteration live definition instruction iteration 
similar situation 
order accurately capture information approach find representation incorporates regular periodic nature variables defined iteration iteration show interval graph program 
axis represents instruction numbers code axis represents variables program 
solid circles diagram illustrate point definition crosses illustrate points 
example defined instruction instruction 
note lifetimes variable represented sequence intervals interval iteration 
period period loop program interference graph interval graph interference graph interval graph illustrated live range loop variable represented periodic interval sequence lifetime intervals equally spaced time period 
periodic interval characterized interval corresponding period 
example live ranges variables period iteration 
live ranges variables extend boundary iterations expressed interval 
variables defined iteration 
convenience represent live range pair intervals interval instance considered extension interval wrapped fit period 
numbers correspond instructions merely provide joining point successive iterations 
call wrapped interval cyclic interval 
show cyclic interval graph representation 
cyclic interval graph circular arc graph cyclic interval graph general conventions cyclic interval graph representations 
starting time points sequence machine operations 
loss generality non negative integers time points 
denote interval including points 
notation denotes interval point left 
assume machine operation form quadruple begins time point precise say variable defined time point live range continue time point statement time value longer live 
define lifetime interval 
confusion may occur terms interval lifetime interval interchangeably 
relation live ranges set variables completely defined corresponding set lifetime intervals 
note cyclic intervals represent live ranges variables loops unrolled 
course variable original loop split variables depending unrolling factor 
interval graph constructed new variable unrolled loop associated cyclic interval 
note period cyclic interval graph may greater iteration 
may happen loop body contains array dependency dependence distance greater 
straightforward extension represent certain array loop cyclic intervals 
full discussion scope readers referred 
cyclic interval graphs represent programs hierarchical control structures nested loops conditionals 
case nested loops naturally get nested cyclic interval graphs 
case conditionals create structure similar nested loops introducing proper constraints branches conditionals 
section discuss process 
presenting main problems solved cyclic interval graphs introduce definitions 
definition time covered interval interval cyclic interval covered 
definition intervals overlap exists time covered 
coloring cyclic interval graphs main coloring problems formulated ffl problem finding minimum coloring cyclic interval graph set live ranges represented cyclic interval graph find minimum register color assignment intervals overlapping intervals assigned different registers 
ffl problem finding coloring cyclic interval graph minimum spilling cost set live ranges represented cyclic interval graph set registers find assignment registers intervals introduce spill code necessary keep spill cost minimum 
importance problem obvious probably familiar compiler writers 
focus importance problem problem finding minimum coloring cyclic interval graph 
argue important problem reasons 
important applications situations smallest number registers required 
example allocating registers interprocedurally beneficial allocate minimal number registers procedure solution 
reduces amount register saving required procedure call time improve interprocedural register allocation 

information captured interval graphs developed step approach solving problem 
approach effective optimal solution problem minimize spilling cost 
show section particularly important programs register pressure close problems treated section section respectively 
observations cyclic interval graphs problems related class circular arc graph coloring problems 
graph called circular arc graph vertices placed correspondence set circular arcs circle way vertices joined edge corresponding arcs intersect 
show circular arc graph representation example 
intuitively think bending interval arc intervals periodic fit circle 
theoretically problem determining coloring circular arc graph arcs complexity nk 
interested fast heuristic methods find coloring quickly generates efficient code spilling necessary 
general graph coloring problem finding minimum coloring cyclic interval graph np hard 
purpose register allocation important information provided interval graph guiding heuristics algorithmic solutions 
examples observe number minimum registers needed cyclic interval graph related thickness graph formally define 
definition width cyclic interval graph time written width number intervals covering definition maximum width cyclic interval graph written max maximum width covered interval minimum width cyclic interval graph written min minimum width covered interval state theorems number colors required minimally color acyclic cyclic interval graphs 
theorem addresses problem optimal coloring acyclic interval graphs 
theorem interval graph containing cyclic intervals 
optimally colorable max colors 
proof obvious colored colors 
complete proof sketching algorithm called left right algorithm guarantee find optimal coloring assume spans time time starting left time move left right time line 
interval ends release color back pool free colors 
interval give free color interval covering initially pool contains max free colors 
max intervals covering time algorithm successfully find coloring cyclic interval graph max may color due constraints caused cyclic intervals 
establish upper bound theorem interval graph containing cyclic intervals 
optimally colorable max max min colors 
proof obvious colored colors 
complete proof sketching algorithm guarantee find coloring max min colors 
cut point minimum width min 
take intervals covering cutting point call remaining part obviously treat acyclic graph 
coloring left right algorithm guarantees colored max colors theorem 
trivial see min colors color removed intervals 
finding minimal coloring cyclic interval graphs section examine heuristic algorithms coloring cyclic interval graphs minimal number colors 
specifically cyclic interval graph find fast algorithm color colors possible 
algorithms sort heuristic guaranteed find optimal solution 
goal find algorithms find optimal close optimal solutions 
subsection develop new algorithm fat cover algorithm 
subsection give short summary approaches minimal coloring problem subsection describe important method hybrid algorithm 
subsection experimental results compare effectiveness algorithms 
fat cover algorithm fact optimal cyclic interval graph bounded max min max theorem experimental observations indicate large majority graphs represent programs colored max colors developed algorithm called fat cover algorithm specifically designed graphs colored max colors 
key algorithm observation fat spots interval graph locations important iteratively reduce maximum width uncolored portion graph finding non overlapping set intervals covers fat spots coloring intervals color 
introduce idea informally example give formal development algorithm 
introductory example fat cover algorithm consider graph maximum width cyclic intervals fat spots points maximum width indicated arrows 
objective fat cover algorithm find set non overlapping intervals includes cyclic interval 
indicated set dashed lines intervals call fat cover relative color color reduce original problem finding coloring graph 
find fat cover fb gg 
reduce problem coloring acyclic interval graph clearly colorable 
finding fat cover finding fat cover remaining graph example fat cover algorithm formal description fat cover algorithm basic idea algorithm previous section give rigorous description algorithm 
definition fat spots cyclic interval graph written set times width wmax 
definition fat cover cyclic interval graph relative interval subgraph obeys properties intervals non overlapping exists interval covers theorem cyclic interval graph colorable max colors cyclic interval exists fat cover relative call gamma gamma colorable 
proof wmax coloring pick color associated cyclic interval call form set intervals colored show fat cover relative definition valid coloring intervals non overlapping satisfies property definition 
furthermore colorable exactly max colors exactly interval fat spot colored clearly satisfies property definition 
secondly clear removing left graph colored gamma colors 
development fat cover algorithm inspired theorems 
graph cyclic intervals cm algorithm proceeds phases 
phase attempts colors find fat cover cyclic intervals 
ith step traversal left right performed find fat cover interval call fat cover 
implementation ensures fat cover left right traversal exists 
cover traversal right left performed assigns new color intervals cyclic intervals dealt phase second phase uses straightforward left right algorithm color remaining intervals 
phase succeeds second phase need consider reduced graph contains cyclic intervals maximum width max gamma coloring guaranteed new colors see proof theorem 
phase succeeds find optimal coloring max colors graph phase fails find fat cover stage second phase simply colors remaining cyclic intervals new colors applies simple left right algorithm color remaining intervals 
case resulting coloring may may optimal 
theorem ensures graph wmax colorable possible algorithm succeed handling cyclic intervals finding appropriate fat covers 
noted algorithm finds fat cover step may find fat cover leads optimal solution 
colorable graph may select gamma gamma colorable exists gamma colorable 
graphs cyclic interval fat cover find optimal solution 
guaranteed find fat cover exists 
furthermore fat cover know graph gamma maximum thickness gamma gamma contain cyclic intervals 
theorem guarantee gamma colored gamma colors colored colors 
fat cover algorithm thought smart way deciding subset intervals colored color 
traditional approaches interference graphs simplification phase applied interference graph pairs nodes coalesced node forcing colored color 
case searching sets nodes specific property belong fat cover cyclic interval 
finding set intervals requires information regarding location fat spots interval graph 
information explicit cyclic interval graph representation available interference graph representation 
noted fat cover algorithm computationally expensive 
cyclic intervals sweep graph required size graph exactly number address statements program 
remaining intervals handled final left right sweep 
furthermore interval graphs correspond programs new interval time step complexity point sweep effectively constant 
approaches subsection describe naive coloring algorithm chaitin original interference graph approach greedy algorithm 
interference graph algorithm cyclic interval graph contains information interference overlap intervals chaitin style reduction algorithm discover guarantees cyclic interval graph colored colors 
ith step algorithm removes remaining intervals interval fewest number overlapping intervals corresponds removing node degree interference graph 
graph intervals steps 
call interval removed step denote number overlapping intervals degree step pick max 
color original graph colors coloring intervals order gamma step color interval gamma previously colored overlapping intervals 
greedy algorithm approach coloring cyclic interval graph color cyclical intervals greedy algorithm color remaining intervals 
step greedy algorithm steps performed 
uncolored intervals choose best color call possible criteria choosing best interval include leftmost uncolored interval interval lowest starting time longest uncolored interval interval overlaps uncolored intervals interval fewest number available colors color available interval interval overlaps 

colors available choose best color call color available interval allocate new color 
possible criteria choosing best color include best fit color available time intervals color best fits starting times color best match starting times interval worst fit color fewest number unallocated intervals 

assign color interval experimental results reported greedy algorithm option choosing interval color option choosing color best heuristics 
hybrid algorithm hybrid algorithm combine best points interference graph approach fat cover method greedy method 
graph algorithm finds coloring phases 
phase applies reduction step interference information 
phase repeatedly removes intervals fewer max overlapping intervals 
call intervals removed graph remaining phase applies greedy algorithm fat cover algorithm color intervals phase colors intervals removed phase order gamma illustrate hybrid algorithm step step example 
picture give input interval graph 
notice graph maximum width fat cover algorithm try color colors 
illustrate graph initial reduction phase 
reduction phase simplifies graph removing intervals overlap intervals 
equivalent applying chaitin algorithm 
note intervals removed remaining intervals overlap intervals 
means order colors naive interference graph algorithm resort spilling point 
illustrated pictures fat cover algorithm applied remaining intervals coloring 
phase fat cover algorithm find fat cover cyclic interval 
shown arrows picture fat spots covered 
traversing left interval cover fa dg 
color new color red proceed phase 
shows remaining uncolored intervals 
note width fat spots indicated arrows 
find fb gg forms fat cover remaining cyclic interval color new color blue 
shows remaining intervals consider 
note cyclic intervals easily color intervals third color green 
general phase handles cyclic intervals succeeds guaranteed able color remaining intervals max gamma colors 
example max 
final coloring shown 
note red blue green intervals removed step colored colors overlapping intervals 
noted algorithm improved allowing multiple alternations interference graph heuristic fat cover algorithm 
example finding fat cover remove intervals degree 
experimental comparison order experiment wide variety coloring approaches coloring heuristics implemented experimental platform supports approaches outlined supports wide variety heuristics greedy approach 
tables summarize experimental results collected algorithms algorithm naive interference graph see section greedy algorithm see section fat cover algorithm described section hybrid algorithm phase interference information second phase applies greedy method see section hybrid algorithm uses fat cover method second phase 
think experiments heuristic algorithm challenge 
experimented graph sizes intervals 
graph size studied graphs original interval graph removing intervals degree finding fat cover fa dg finding fat cover fb gg red red red blue blue blue green green blue coloring rest final coloring example applying hybrid fat cover algorithm contained cyclic intervals 
combinations graph size number cyclic intervals ran experiments program graphs generated cyclic intervals intervals naive interference greedy fat cover hybrid greedy hybrid fat cover cyclic intervals intervals naive interference greedy fat cover hybrid greedy hybrid fat cover cyclic intervals intervals naive interference greedy fat cover hybrid greedy hybrid fat cover cyclic intervals intervals naive interference greedy fat cover hybrid greedy hybrid fat cover number extra registers coloring random graphs randomly 
program graphs correspond cyclic interval graphs arise inner loop constructs program truly random graphs 
time point graph corresponds instruction may definition uses 
non cyclic intervals correspond live ranges defined iteration cyclic intervals correspond live ranges live loop defined iteration 
graph example graph intervals cyclic intervals 
experiment run follows 
input interval graph algorithms applied graph number colors algorithm reported 
min minimum number algorithms algorithm charged penalty points point register min 
numbers reported corresponds number penalty points charged algorithm experiments 
score algorithm means produced minimal number registers experiments 
results clearly indicate hybrid fat cover algorithm winner 
cases gave best result experiments score cases equaled beat algorithms case intervals cyclic intervals close second 
results give conclusive answers various algorithms behave real application programs show general trend large number graphs correspond possible programs graph generate corresponds possible program 
see hybrid algorithm worth implementing real compiler fat cover better idea wide variety greedy heuristics 
see section fat cover algorithm provides advantages trying reduce spill code 
experiments important demonstrate fat cover algorithm appears quite wide variety graphs 
furthermore results motivated pursue step integrating fat cover algorithm new spilling strategy 
finding coloring cyclic interval graphs previous section fat cover algorithm designed find coloring minimal number registers 
section new approach allocating registers constraint registers available minimal number registers required color graphs general interference graphs drawbacks interval graph representation solves naturally separation spill phase coloring phase developed algorithm coloring graph maximum thickness max take approach register allocation proceed phases 
max phase transforms equivalent graph maximum thickness max transformation process introduces register spills guaranteed produce graph colored second phase introducing register spills 
application phase required 
differs approaches interference graphs introduce spilling register allocation phase 
approaches guarantee spilling result colorable interference graph pass necessary iterate coloring spilling process colorable solution 
noted approach suggested means avoiding iteration uses complex algorithm required 
choice spilled quantities information stored cyclic interval graph decisions intervals spill 
information available interference graph representation exploited spilling techniques representation 
noted similar approach context interference graphs 
approach width interference graph spill heuristics 
similarly algorithm uses width interval graph width interference graph point time defined number live variables point 
criteria choosing node spill 
representation captures width graph point program naturally easier beneficially exploit information 
furthermore natural metric distance cyclic intervals 
register floats approach uses level mechanism floating registers spilling registers 
fully explained section register float corresponds moving value register register register spill corresponds moving value register memory location back 
clearly register float preferred register spill 
chameleon intervals register floats register spills carefully studying structure cyclic interval graphs see quite different constraints graph colorable registers 
evident 
graph time intervals covering impossible allocate different color interval example consider graph 
intervals overlap 
way graph colored colors spill intervals memory 
illustrate process interval spilled leaving short intervals representing definition followed store memory load memory followed 
red red green red graph max graph spilling max colorable colorable red green red green red graph cyclic interval graph chameleon interval colorable colorable example register spilling register floating second situation subtle 
consider graph 
graph maximum width colorable 
situation really run important choose spill 
spilling result reducing wmax 
colors need resort spilling order graph colorable 
notion chameleon interval interval change color depending surroundings 
allow interval variable change color location indicated solid bar easily color graph colors 
introducing loads stores required register spill need introduce register move corresponds location interval changes green red 
call register move operation register float value floats register register spilled 
chameleon intervals find register floats color cyclic interval graph max exactly colors introducing spilling 
graph max immediately colorable belong class graphs colored allow chameleon intervals illustrated 
fat cover algorithm color graph cyclic interval covered simply introduce chameleon interval 
extra loads stores need introduced simply introduce register float chameleon interval 
introduce chameleon intervals cyclic intervals fat cover number chameleon intervals introduced small min 
register float introduced possible register moves depend 
example red interval needs turn green green interval needs turn red 
accomplished rotating values temporary register swapping contents registers trick xor xor xor straightforward temporary number cyclic intervals maximum width graph temporary register available 
reducing width interval graph coloring algorithm described previous section problem coloring reduces problem transforming graph max equivalent graph max trying reduce width graph shown transformation introduce register spills 
approach attempts minimize number register spills 
developed new algorithm sweep split algorithm cyclic interval graph representation 
fat cover coloring algorithm sweep split idea register floats new difficulty efficiently identifying values treat register floats prevented widespread 
interval graph representation provides natural mechanism chameleon intervals recognizing register floats quantities 
similar method proposed basic blocks 
algorithm takes advantage extra information available interval representation 
algorithm straight forward give overview 
central idea algorithm sweep left right cyclic interval graph 
invariant time step time left time guaranteed maximum width max move time step situations 
width second width case action required 
second case select gamma intervals split introducing spill code 
difficulty developing heuristic selecting intervals split 
developed heuristic uses information time readily available interval graphs 
heuristic favors intervals clear longest time interval right non cyclic intervals equivalent choosing furthest note split interval segment overlaps time segments split sweep selects intervals ones split step reasoning heuristic invariant times left widths reduced favor intervals reduce widths right multiple intervals clear longest distance interval requires load preferred interval requires load store store required store outside loop preferred 
give concrete example applying sweep split algorithm cyclic interval graph corresponds small program 
give small illustrative program give address code 
assuming number available registers gives address code program results applying sweep split algorithm 
shows cyclic interval graph loop figures illustrate sweep split process transforms original graph maximum thickness transforms colorable graph 
steps follows time sweeping process starts time step 
note sweeping line indicated vertical dotted line 
intervals covering time step 
order reduce width intervals selected split 
interval split time 
remaining intervals best intervals select splitting intervals frees longest time interval right sweeping line 
time illustrates graph resulting splitting previous step 
intervals covering time step interval chosen split 
assuming right associativity right left evaluation 
time intervals covering time step interval chosen rightmost 
see importance heuristic 
note situation choosing important choosing reduce width time step spill introduced 
time time step times greater width spilling required 
hierarchical cyclic interval graphs previous sections concentrated cyclic interval graphs represent innermost loops 
important note techniques limited cases 
fact natural hierarchical representation structured programs contain nested conditionals loops 
note emphasis application methods innermost loops 
include discussion hierarchical structures show plausible relatively straight forward extend method structured programs 
parts program irregular control structure interference graph approach probably effective 
strategy hierarchical graphs allocate pseudo register numbers bottom fashion nested structure program assign real register numbers top pass 
consider case nested loops illustrated 
example quite clear just nesting cyclic interval graphs cyclic interval graph loop nested inside cyclic interval graph loop 
apply spilling coloring algorithms structured manner starting innermost loop working outwards 
example assume find coloring loop 
shown proceed outermost loop loop replacing loop intervals 
intervals grafted lifetime variables autonomous intervals represent colors required loop intervals 
find coloring loop non hierarchical cyclic interval graph 
topmost level hierarchy pseudo register numbers real register numbers non autonomous intervals 
autonomous intervals real register numbers assigned intervals loop correspond autonomous intervals 
example consider situation autonomous intervals assigned real registers intervals inside loop assigned pseudo sum sum sum sum goto load sum store load load load sum load goto original loop address code address code spilling sum sum sum sum original interval graph time time time time example introducing spill code loop loop loop nested loop allocating inner loop nested loops hierarchical structured interval graphs registers top pass assign intervals assigned occurrences 
case nested conditionals hierarchical interval graph nesting quite obvious 
basic problems 
problem enforce consistent allocation intervals name live entry exit sides conditional 
example program live entry conditional allocated register sides conditional 
similarly program live exit conditional allocated register sides conditional 
second problem may constraints require consistent allocation live ranges name enter exit conditional 
consider program 
case outer loop creates cyclic interval imposes constraint interval entering conditional allocated register intervals exiting conditional 
combine problems example conditional nested inside loop illustrated 
note constraints variables live start conditional example variable live conditional variables 
variable allocated register sides conditional 
example allocated register part conditional allocated part 
variable live conditional may allocated different registers side conditional 
example variable may assigned different registers side conditional 
illustrated 





examples consistent allocation required conditionals capture exactly constraints constraints creating cyclic interval graph connects input variables parts output variables parts 
example means connect inputs outputs 
connections created cyclic interval graph 
execution branches conditional mutually exclusive think cyclic interval graph nested conditional composed time line wrapped branch conditional 
apply spilling coloring heuristics cyclic interval graph embedded conditional outer loop 
encoding problem address problem consistent allocation intervals entering exiting sides conditional 
example force intervals entering conditionals allocated color say intervals allocated exiting conditional allocated color say looking conditional ignoring presence outer loop reason color 
leads second problem conditionals 
note cyclic interval hierarchical level loop 
means loop nested conditional hierarchical structured interval graph loop level really allocate color entry conditional exit conditional 
methods handling second problem 
solution introduce chameleon intervals cyclic intervals allocated different registers nested structure 
course may introduce extra register move instructions 
approach force related ends cyclic interval pre allocated color 
example means pre allocate entry exit intervals pseudo register say 
third method reallocate registers top pass 
disadvantage requiring allocations advantage propagating exactly constraints imposed allocations higher level 
example case cyclic interval allocated chameleon interval processing loop extra overhead introduced assigning different registers conditional 
summary apply cyclic interval graph coloring spilling algorithms structured programs repeatedly applying steps bottom phase step solve innermost nested construct loop conditional 
case loop cyclic interval graph 
case conditional create proper cyclic interval graph joining input output variables common parts conditional 
step solution step replace nested structure simple intervals illustrated 
bottom phase followed top phase propagates real register numbers pseudo allocation done bottom phase 
top phase extra constraints due cyclic intervals entering exiting conditionals resolved introducing chameleon intervals lower level extra initial coloring constraints 
shall briefly survey section interesting conducted hierarchical methods register allocation 
belief clear simple representation cyclic interval graph provides basis representing live ranges cross boundaries nested program structures 
course helps hierarchical register allocation process 
interval graph performance benchmark programs standalone versions spilling coloring algorithms implemented section compare performance interval graph method spilling register allocation performance advanced production compilers ibm rs version sun sparc version bundled sunos mips version 
comparisons highest level optimization offered compilers 
architectures bit integer registers 
rs bit floating point registers sparc mips bit floating point registers 
focus inner loop bodies taken livermore loop tomcat spec benchmark release 
benchmarks selected relatively large size loop bodies large number variables referenced 
large size necessary order evaluate efficiency register allocation spilling architectures large register sets 
benchmarks floating point intensive double precision bit arithmetic 
concentrate allocation spilling floating point registers 
order give compilers approximately equal input transformed input source code complex transformations explicit 
loops manually unrolled software pipelined 
common subexpression elimination performed reused data values explicitly assigned local scalar variables 
transformed code isomorphic interval graphs fed allocator 
aggressive optimizations performed tend increase lifetime variables increasing currently integrating register allocator interference graph approach mccat mcgill compiler architecture testbed research compiler 
precise tomcat loop loop 
standards performance evaluation spec benchmark suite obtained parkway suite ca 
benchmarks derived cpu intensive application programs 
importance register allocator 
sophisticated analysis array indices unusual optimization required commercial compilers match performance standalone implementation 
originally implemented interval graph representation gcc version 
optimizations common subexpression elimination alias analysis poor 
variable lifetimes short receive meaningful benefit register allocation scheme 
decided meaningful results take approach complex transformations explicit rely observing output compilers modify source 
course preliminary step demonstrate ideas worth pursuing studying compilers 
mccat compiler supports complex transformations automatically able thorough study different register allocation strategies 
assumptions generating interval graph results 
rest assume instruction register dead point 
assume instructions executed source code order 
instruction scheduling register allocation done code reordered reduce live range certain variables reduce register pressure 
simplicity assume constructing interval graphs instructions execute unit time 
assumption biases results needing registers 
example executing floating point divide destination register filled cycles initiation divide register purpose cycles 
generating spills scan interval graph left right 
thickness exceeds number registers excess spilled 
registers chosen spilling distant 
cyclic interval graphs distance measure cyclic distance measured current time wrapping iteration 
registers available method requires spills benchmarks 
seen tables number spills required substantially required sparc mips compilers 
reduction load spills ranges loads iteration loads iteration 
proportional dynamic loads stores performed 
reduction store spills slightly smaller ranging stores iteration 
please note total number loads stores include loads stores introduced spilling intrinsic loads stores final store array elements respectively 
table gives analogous results registers available rs 
increased number registers alleviates need spills 
interval graph method allows loop rolled version tomcat execute load store spills 
rolled unrolled theta int gr sparc mips int gr sparc mips loads total loads spill stores total stores spill table number double precision loads stores registers tomcat 
rolled unrolled theta int gr sparc mips int gr sparc mips loads total loads spill stores total stores spill table number double precision loads stores registers loop 
interesting performance unrolled version tomcat 
case interval graph method required spills rs load spills store spills 
loop fewer load spills fewer store spills 
similarly registers available largest absolute reduction spills came unrolled tomcat loop 
registers spilled interval graph colored 
discussed section possible color interval graph maximum width max chameleon registers moving values register 
loop rolled unrolled theta rolled unrolled theta int gr int gr int gr int gr loads total loads spill stores total stores spill table number double precision loads stores registers 
cover algorithm unrolled version tomcat successfully colored chameleon intervals seen table 
unrolled tomcat loop interval graph minimal coloring method introduced chameleon intervals colorable 
state art compilers studied gcc sparc mips rs compilers costly spills memory graph colorable 
case needed register moves interval graph provided natural representation allowed avoid spills 
cyclic min max colors chameleon intervals width width rolled tomcat regs rolled tomcat regs unrolled tomcat regs unrolled tomcat regs rolled loop regs rolled loop regs unrolled loop regs unrolled loop regs table interval graph statistics spilling 
main point experiments cyclic interval graph approach job complex loops high register pressure 
seen low number loads stores required cases register floats spills unrolled tomcat case 
absolute observation depend comparing results register allocation strategies 
point programs production quality compilers produce substantially worse spill code challenging examples 
slight variations compilers due slightly different low level optimizations instruction scheduling 
main point performed significantly worse interval graph approach 
evidence indicates cyclic interval graph approach worth tests show kinds programs cyclic interval graph method superior 
related section survey related register allocation graph coloring interval graphs 
number publications researchers trying improve chaitin method register allocation 
briggs recognized fact chaitin original heuristic guaranteed find minimum coloring 
proposed different heuristic method simplifies coloring phase separating spilling phase 
graph reduced stage remaining nodes degree greater equal spill 
algorithm continues coloring process selecting remaining node reduce graph heuristics 
reduction phase nodes processed reverse order assigned colors 
possible process node degree greater equal colored neighbor may allocated color 
method interference graphs coloring spilling process may iterated times 
avoiding pointless spilling improved code generated number test programs 
bernstein introduced collection heuristics reduces likelihood excessive spill code generation 
width number live ranges certain point program compute spill cost variable 
width coupled depth loop nesting form basis area heuristics 
method employs interference graph basic representation program may require graph rebuilt spill code introduced 
callahan carr kennedy studied register allocation methods subscripted variables poses problem compilers 
method array live iterations recognized source source transformation called scalar replacement performed handled coloring register allocators 
register moves introduced transfer values subscripted variables iterations eliminating load store operations 
register moves subsequent processing register allocation orthogonal exists single unified framework optimization problem 
approach problem register allocation scalar subscripted variables suggested duesterwald gupta soffa 
method uses integrated register allocation graph extension interference graph represent coloring problem scalars subscripted variables 
subscripted variables allocated set registers form register pipeline 
proposed method cyclic scheduling optimizing register usage cray 
interprocedural register allocation studied number people 
example steenkiste hennessy developed algorithm interprocedural register allocation procedure interference graph constructed 
node graph procedure program 
procedures active time adjacent procedure interference graph 
node graph assigned number color equals number registers needed local variables procedure 
number determined intraprocedural procedure allocation phase 
coloring algorithm assigns different colors adjacent nodes procedure interference graph 
evident solution minimum register allocation problem described problem section important intraprocedural allocation phase 
cytron ferrante proposed method storage allocation amount storage needed equal maximum number simultaneously live variables original program 
objective allocate storage temporary variables renaming compiler technique transforms imperative programs dataflow graphs 
pointed formulation register allocation problem graph coloring problem traditional interference graph may away vital information original program width interval graph method uses guide register allocator achieve optimal solution efficiently 
difference proposed lies treatment loop variables 
example scalar variable defined loop changed array scalar expansion loop bound known priori transformed dynamically allocated variable loop bound known statically 
treat variables cyclic intervals overhead extra arrays dynamic allocation avoided 
callahan koblenz register allocation method hierarchical graph coloring 
main idea represent hierarchical program structure tree tiles 
tiles processed bottom fashion local interference graph created colored pseudo registers tile tile basis capture local usage pattern 
top walk binds pseudo registers physical registers 
spill code introduced frequently executed portions program 
knobe zadeck proposed hierarchical register allocation scheme control trees 
prune procedure executed coloring reduce register pressure desired threshold value storing values memory entry program region reloading exit 
authors claim pruning coloring process terminate threshold value set properly 
live range may need split coloring process 
coloring algorithms hierarchical methods described accept interference graph input 
gupta reported area global register allocation clique separators 
clique separator completely connected subgraph 
removed graph disconnects graph subgraphs 
algorithm partitions code code segments clique separators 
code segment colored separately interference graph coloring method 
colored subgraphs combined global register allocator 
presence branching combining process may introduce register copying point different control flow paths merge 
pointed problems related class circular arc graph coloring problems 
idea interval graphs register allocation goes back years 
tucker note advantages representation 
noted related concept circular arc graphs applied program loops 
interval graphs overlay arrays minimize program memory requirements perform channel routing vlsi layouts 
practical interval graphs register allocation appears largely ignored perceived difficulties dealing circular arc graphs hierarchical interval graphs arise dealing real programs 
great deal theoretical done summary may 
circular arc graphs register allocation proposed high level dataflow synthesis digital systems 
application domain computation represented data flow graphs 
data flow graphs loops modeled cyclic dataflow graphs corresponding register allocation problem modeled circular arc graphs 
compiler optimization hardware oriented synthesis traditionally address issue code spilling 
application described cyclic interval graph representation unified framework loop scheduling register allocation 
fact lifetime intervals naturally derived instruction schedule register allocation scheme developed utilized effectively scheduling framework 
reiterate view relation related register allocation 
believe approach interval graphs appear suited certain structured programs particular large inner loops loop nests 
structured programs interference graph best representation 
expect representations complement compiler experiments clearly required determine combine effective fashion 
currently implementing combined approach mccat compiler 
new approach register allocation hierarchical cyclic interval graph representation 
representation effectively characterize overlap live ranges variables different times program execution 
furthermore demonstrated additional information representation useful coloring spilling algorithms 
believe method particularly suitable handle structured program segments structured loops conditionals 
interval graph framework approaches minimal coloring problem notion fat cover 
addition new approach coloring problem 
approach introduces notion chameleon intervals register floats help avoid expensive register spills introducing expensive register moves 
new sweep split algorithm transform graphs colorable graphs guaranteed colorable 
transformation minimizes spills powerful heuristic guided information available interval graph representation available traditional interference graph representation 
addition illustrating algorithms inner loops shown cyclic interval graph representation extended accurately capture register allocation constraints programs nested loops conditionals 
implemented spilling algorithm applied collection challenging loops 
comparing results produced mips sparc production compilers demonstrated cyclic interval graph representation combined new algorithms produces encouraging results 
experimental coloring testbed prototype spilling program register allocation framework integrated low level structured intermediate representation supported mccat compiler 
addition implementation effort continuing exploit extra information available interval graph representation 
example potential information combination instruction scheduling register allocation 
referees insightful comments helped improve presentation ideas 
acknowledge suggestion referee pointed natural improvement hybrid coloring scheme interference phases fat cover phases alternate 
john hennessy david patterson 
computer architecture quantitative approach 
morgan kaufmann publishers 
john hennessy norman jouppi 
computer technology architecture evolving interaction 
computer september 
chaitin auslander chandra cocke hopkins markstein 
register allocation coloring 
computer languages january 
chaitin 
register allocation spilling graph coloring 
proceedings sigplan symposium compiler construction pages boston massachusetts june 
acm sigplan 
sigplan notices june 
frederick chow john hennessy 
register allocation priority coloring 
proceedings sigplan symposium compiler construction pages montr eal qu ebec june 
acm sigplan 
sigplan notices june 
preston briggs keith cooper ken kennedy linda torczon 
coloring heuristics register allocation 
proceedings sigplan conference programming language design implementation pages portland oregon june 
sigplan notices july 
alan tucker 
coloring family circular arcs 
siam journal applied mathematics november 
alan tucker 
applied combinatorics 
john wiley sons nd edition 
ning gao 
novel framework register allocation software pipelining 
conference record twentieth annual acm sigplan sigact symposium principles programming languages pages charleston south carolina january 
peter steenkiste john hennessy 
simple interprocedural register allocation algorithm effectiveness lisp 
acm transactions programming languages systems january 
klee 
intersection graphs arcs circle 
american mathematics monthly 
garey johnson miller papadimitriou 
complexity coloring circular arcs chords 
siam journal algebraic discrete methods june 
fred chow john hennessy 
priority coloring approach register allocation 
acm transactions programming languages systems october 
david bernstein dina goldin martin golumbic hugo krawczyk mansour itai ron pinter 
spill code minimization techniques optimizing compilers 
proceedings sigplan conference programming language design implementation pages portland oregon june 
sigplan notices july 
david callahan brian koblenz 
register allocation hierarchical graph coloring 
proceedings acm sigplan conference programming language design implementation pages toronto ontario june 
sigplan notices june 
rajiv gupta mary lou soffa tim steele 
register allocation clique separators 
proceedings sigplan conference programming language design implementation pages portland oregon june 
sigplan notices july 
kathleen knobe kenneth zadeck 
register allocation control trees 
technical report cs department computer science brown university march 
evelyn duesterwald rajiv gupta mary lou soffa 
register pipelining integrated approach register allocation scalar subscripted variables 
kastens editors proceedings th international conference compiler construction cc number lecture notes computer science pages paderborn germany october 
springer verlag 
christine william jalby alain 
compiler techniques optimizing memory register usage cray 
international journal high speed computing 
published inria research report october 
fred chow 
minimizing register usage penalty procedure calls 
proceedings sigplan conference programming language design implementation pages atlanta georgia june 
sigplan notices july 
george taylor paul hilfinger james larus david patterson benjamin zorn 
evaluation spur lisp architecture 
proceedings th annual international symposium computer architecture pages tokyo japan june 
ieee computer society acm sigarch 
computer architecture news june 
ron cytron jeanne ferrante 
name 
value renaming parallelism detection storage allocation 
proceedings international conference parallel processing pages st charles illinois august 
kuck kuhn padua wolfe 
dependence graphs compiler optimizations 
conference record eighth annual acm symposium principles programming languages pages williamsburg virginia january 
acm sigact sigplan 
jack dennis 
data flow supercomputers 
computer november 
fabri 
automatic storage optimization 
phd thesis university michigan 
michael burstein 
channel routing 
editor layout design verification volume advances cad vlsi pages 
north holland publishing amsterdam 
ido dagan martin charles golumbic ron yair pinter 
trapezoid graphs coloring 
discrete applied mathematics september 
martin charles golumbic 
interval graphs related topics 
discrete mathematics 
wei shih wen hsu 
algorithm color proper circular arcs 
discrete applied mathematics november 
tseng siewiorek 
automated synthesis data paths digital systems 
ieee transactions computer aided design july 
alice parker 
real program register allocation 
proceedings th acm ieee design automation conference pages miami beach florida june july 
van den born 
synthesis concurrent hardware structures 
proceedings international symposium circuits systems pages june 
pierre paulin john knight 
scheduling binding algorithms high level synthesis 
proceedings th acm ieee design automation conference pages las vegas nevada june 

transfer free register allocation cyclic data flow graphs 
proceedings european conference design automation pages brussels march 
hendren emami gao sridharan 
designing mccat compiler family structured intermediate representations 
banerjee david gelernter alex nicolau david padua editors proceedings th international workshop languages compilers parallel computing number lecture notes computer science pages new haven connecticut august 
springer verlag 
published 

