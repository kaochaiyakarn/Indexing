indexing large metric spaces similarity search queries ozsoyoglu oracle department computer engineering science usa case western reserve university oracle com ces edu database applications common queries find approximate matches query item collection data items 
example image database may want retrieve images similar query image 
distance index structures proposed applications distance computations objects data domain expensive high dimensional data distance function metric 
consider distance index structures similarity queries large metric spaces 
elaborate approach points vantage points partition data space spherical shell regions hierarchical manner 
introduce multi vantage point tree structure mvp tree uses vantage points partition space spherical cuts level 
answering similarity queries mvp tree utilizes pre computed construction time distances data points vantage points 
summarize experiments compare mvp trees vp trees similar partitioning strategy vantage point level pre computed distances 
empirical studies show mvp tree outperforms vp tree varying query ranges different distance distributions 
generalize idea multiple vantage points discuss results experiments done see varying number vantage points node affects search performance performance gain obtained making pre computed distances 
results show may best large number vantage points internal node single directory node keep pre computed distances possible provide efficient filtering search operations 
provide experimental results comparing mvp trees dynamic distance index structure metric domains 

database applications desirable answer queries proximity asking data items similar query item closest query item 
face queries context database applications genetics text matching image picture databases time series analysis information retrieval 
genetics concern find dna protein sequences similar genetic database 
time series analysis find similar patterns collection sequences 
image databases queried find retrieve images database similar query image respect specified criteria 
similarity images measured number ways 
features shape color texture extracted images database content information distance calculations 
images compared pixel pixel basis calculating distance images accumulation differences intensities pixels 
preliminary version bo appeared acm sigmod 
research partially supported national science foundation iri national science foundation award iri applications problem find data items similar query item similarity items computed distance function defined application domain 
objective provide efficient access mechanism answer similarity queries 
consider applications distance function employed metric computation distances expensive 
important application metric distance function filtering distant data items similarity query triangle inequality property section 
distance computations assumed expensive efficient access mechanism certainly minimize number distance calculations similarity queries improve speed answering 
usually done employing techniques index structures filter distant non similar data items quickly avoiding expensive distance computations 
data items result similarity query filtered user visual browsing 
happens image database applications user pick semantically related images query image examining images retrieved result similarity query 
inevitable impossible extract represent semantic information image simply extracting features image 
best image database images related close query image leave identification semantic interpretation images users 
number distance computations required similarity search query taken efficiency measure 
incorporate operations required evaluation queries cost measure 
partly justified target applications ones distance computations expensive 
applications distance computations measure reflects costs costs network costs degree distance computation requires retrieval database object secondary memory reflect operations required index structure 
example consider www site index large number pages www sites 
similarity query cost searching index similarity query directly related number www pages retrieved distance computations making costs index site negligible 
role costs incorporated general performance comparisons mvp trees access structures general case costs neglected remains done research 
introduce mvp tree multi vantage point tree general solution problem answering similarity queries efficiently high dimensional metric spaces 
mvp tree similar vp tree vantage point tree uhl sense structures relative distances vantage point partition domain space 
vp trees node tree vantage point chosen data points distances vantage point points points indexed node computed 
points sorted ordered list respect distances vantage point 
list partitioned create sublists equal cardinality 
order tree corresponds number partitions 
partitions keep data points fall spherical cut inner outer radii minimum maximum distances points vantage point 
mvp tree behaves cleverly making vantage points employing level tree increase fanout node tree 
vp trees similarity query distance computations query point vantage points 
vantage point node mvp tree vantage points compared vp tree 
distances data points leaf nodes vantage points higher levels computed construction time kept mvp trees distances efficient filtering search time 
efficient filtering leaf level utilized making leaf nodes higher node capacities 
way major filtering step search delayed leaf level 
experiments high dimensional euclidean vectors gray level images compare mvp trees demonstrate mvp trees efficiency 
experiments mvp tree vantage points node 
distance distribution data points plays important role efficiency index structures experimented different sets euclidean vectors different distance distributions 
experiments dimensional euclidean vectors showed mvp trees require distance computations compared vp trees small query ranges 
higher query ranges difference decrease gradually mvp trees perform better making distance computations largest query ranges 
experiments gray level images metrics see section reveal fact mvp trees perform better vp trees 
data set images experiment shallow trees mvp trees performed distance computations 
explore issue choosing better vantage points preferably introducing overhead construction step 
test simple heuristic choosing points far away data points euclidean vectors compare results vantage points chosen randomly 
generalize mvp tree structure number vantage points internal node conduct experiments see vantage point node scales 
experiments euclidean vectors observe compare performance mvp trees vantage points node 
ultimate case vantage points kept single directory node creating level tree structure internal node leaves vantage points single directory node hierarchically partition data space 
interestingly level mvp tree keeps vantage points single directory efficient structure terms minimizing number distance computations answering similarity queries high dimensional euclidean vectors experiments 
final step compare generalized mvp trees trees state art index structures metric spaces 
rest organized follows 
section gives definitions metric spaces similarity queries 
section presents problem indexing large spaces presents previous approaches problem 
related distance index structures section 
section introduces mvp tree structure 
experimental results comparing mvp trees vp trees section 
section elaborates choose better vantage points 
section explains mvp tree structure generalized vantage points kept node 
section presents experimental results generalized version mvp trees having different numbers vantage points results experiments conducted comparing mvp trees trees 
section 
metric spaces similarity queries section briefly give definitions metric distance functions different types similarity queries 
metric distance function metric space defined follows ii iii iv triangle inequality conditions ones assume designing index structure distances objects metric space 
note metric space geometric information utilized case euclidean space 
set objects metric space distance function compute distance objects 
similarity queries posed number ways 
common asks data objects specified distance query object 
queries require retrieval near neighbors query object 
formal definition type queries follows near neighbor query set data objects metric space metric distance function retrieve data objects distance query point resulting set 
generally referred similarity measure tolerance factor 
variations near neighbor query possible 
nearest neighbor query asks closest object query object 
similarly closest objects may requested 
common objects farther range query object asked farthest farthest objects query object 
formulation queries similar definition near neighbor query 
mainly concerned distance indexing large metric spaces 
concentrate near neighbor queries introduce index structure 
main objective minimize number distance calculations similarity query distance computations assumed expensive applications target 
section discuss indexing problem large metric spaces review previous approaches problem 

indexing large metric spaces problem indexing large metric spaces approached different ways 
approach distance transformations euclidean spaces discussed section 
approach distance index structures 
section discuss distance index structures briefly review previous 
section vp tree structure discussed detail 
distance transformations euclidean spaces low dimensional euclidean domains conventional index structures sam trees variations gut srf bkss effectively answer similarity queries 
cases near neighbor search query ask objects intersects spherical search window center query object radius tolerance factor special techniques forms similarity queries nearest neighbor queries 
example heuristics introduced efficiently search tree structure answer nearest neighbor queries 
conventional spatial structures efficient dimensionality high 
experimental results ott show trees inefficient dimensional spaces greater 
possible conventional spatial index structures high dimensional euclidean domains 
way apply mapping objects original high dimensional space low dimensional euclidean space distance transformation conventional index structures major filtering mechanism transformed space 
distance transformation highdimensional domain lower dimensional domain effective distances objects transformation original space greater equal distances transformation transformed space transformation may impose false dismissals similarity search queries 
distance transformation function underestimate actual distances objects transformed space 
efficiency distances transformed space close estimates distances actual space 
transformations successfully index high dimensional data applications time sequences afs frm images fef 
possible general transformations dft karhunen loeve euclidean domain possible come application specific distance transformations 
qbic query image content system fef color content images compute similarity images 
difference color contents images computed color histograms 
computation distance color histograms images quite expensive color histograms high dimensional number different colors generally vectors crosstalk colors similar colors considered 
increase speed color distance computation qbic keeps index average color images 
average color image dimensional vector average red blue green values pixels image 
distance average color vectors images proven equal distance color histograms transformation underestimates actual distances 
similarity queries color contents images answered index average color vectors major filtering step refining result actual computations histogram distances 
note idea distance transformation works fine applications assumption transformation exists applicable domain interest 
transformations dft karhunen loeve effective indexing high dimensional vectors values dimension uncorrelated vector 
unfortunately possible cost effective employ distance transformation 
distance indexing techniques applicable domains metric distance functions employed 
techniques directly highdimensional spatial domains conventional distance functions euclidean distance defined domains metric 
sequence matching time series analysis image databases example applications having domains 
distance techniques applicable domains data non spatial data objects mapped points multi dimensional space text databases generally edit distance metric computing similarity data items lines text words 
review distance indexing techniques section 
distance index structures number research results efficiently answering similarity search queries different contexts 
burkhard keller bk suggested different techniques problem finding best matching closest key words file query key 
employ metric distance function key space returns discrete values distances integers 
method hierarchical multi way tree decomposition 
top level pick arbitrary element key domain group rest keys respect distances key 
keys distance key get group 
note possible distance values discrete 
hierarchical composition goes groups recursively creating tree structure 
second method bk partitions data space number sets keys 
set center key arbitrarily picked radius maximum distance center key set calculated 
keys set partitioned way recursively creating multi way tree 
node tree keeps centers radii sets keys indexed 
strategy partitioning keys sets discussed left parameter 
third method bk similar second requirement diameter maximum distance points group group constant value different level 
group satisfying criterion called clique 
method relies finding set maximal cliques level keeping representatives nodes direct trim search 
note keys may appear clique aim select representative keys ones appear cliques possible 
approach shasha wang sw suggested pre computed distances data elements efficiently answer similarity search queries 
aim minimize number distance computations possible assumed expensive 
search algorithms log number data objects acceptable minimize number distance computations 
shasha wang method sw table size keeps distances data objects pre computed 
pairwise distances estimated specifying interval making pre computed distances 
technique storing pre computed distances may effective data domains small cardinality space requirements search complexity overwhelming larger domains 
uhlmann introduced uhl hierarchical index structures similarity search 
vp tree vantage point tree 
vp tree basically partitions data space spherical cuts chosen vantage point level 
approach referred ball decomposition similar method bk 
node distances vantage point node data points indexed node computed 
median data points partitioned groups accommodating points distances vantage point equal median distance group accommodating points distances larger equal median 
groups data points indexed separately left right node constructed way recursively 
vp tree introduced binary tree possible generalize multi way tree larger 
provided analytical results vp trees suggested ways pick better vantage points 
chi chiueh proposed algorithm vp tree structure answer nearest neighbor queries 
talk vp trees detail section 
gh tree generalized hyperplane tree structure introduced uhl 
gh tree constructed follows 
top level points picked remaining points divided groups depending points closer 
partitioning descends recursively create tree structure 
vp trees branching factor 
pivot points selected level gh tree tends balanced structure 
fq tree fixed queries tree tree structure uses idea partitioning data space points 
main difference vp tree fq tree uses point internal nodes level 
total number points vantage points equal height tree 
partitioning fq trees similar approach bk 
discrete discretized distance function assumed data space partitioned respect possible distance value point 
performance analysis fq trees 
idea single point nodes level interesting idea 
similar technique design mvp trees 
gnat geometric near neighbor access tree structure bri mechanism answering near neighbor queries 
number split points chosen top level 
remaining points associated data sets split point depending split point closest 
split point minimum maximum distance points data sets split points recorded 
tree recursively built data set level 
number split points parameterized chosen different value data set depending cardinality 
gnat structure compared binary vp tree shown preprocessing construction step gnat expensive vp tree search algorithm distance computations experiments different data sets 
ciaccia introduced tree structure differs distance index structures able handle dynamic operations 
tree constructed bottom contrast structures vp tree gnat gh tree constructed top handle dynamic operations reasonable costs requiring periodical restructuring 
tree stores set objects fixed size leaf nodes correspond sphere regions metric space 
leaf node entry contains id data object feature values distance computation distance routing object kept parent node 
internal node entry keeps child pointer routing object distance parent routing object root course radius sphere region accommodates objects indexed entry called covering radius 
search pruned making covering radii distances objects routing objects parent nodes 
experimental results trees provided cp 
analytical cost model distance distribution objects derived trees 
evaluation complex similarity queries multiple similarity predicates trees discussed 
cp provides algorithm creating tree set objects 
provide experimental results trees section 
vantage point tree structure briefly discuss vp tree explain idea partitioning data space selected points vantage points different levels forming hierarchical tree structure effective filtering similarity search queries 
structure binary vp tree simple 
internal node form ptr ptr vantage point median distance distances points indexed node ptr ptr pointers left right branches 
left branch node indexes points distances equal right branch node indexes points distances greater equal leaf nodes pointers left right branches data points kept 
finite set 
objects metric distance function binary vp tree constructed follows 
create empty tree 
arbitrary object 
vantage point median cardinality equal recursively create vp trees left right branches root binary vp tree balanced easily paged storage secondary memory 
construction step requires log distance computations number objects 
query object set data objects distance search algorithm 
vantage point root answer set 
median recursively search right branch recursively search left branch 
note branches searched search conditions satisfied correctness simple search strategy proven easily triangle inequality distances objects metric data space see appendix 
generalizing binary vp trees multi way vp trees 
binary vp tree easily generalized multi way tree structure larger node hoping decrease height tree decrease number distance computations 
construction vp tree order similar binary vp tree 
finding median distances vantage point data points points ordered respect distances vantage point partitioned groups equal cardinality 
distance values partition data points recorded node 
refer values cutoff values 
cutoff values node 
groups data points indexed root node children order created way recursively 
construction way vp tree requires log distance computations 
creating way vp tree decreases number distance computations factor log construction stage compared binary vp trees 
problem high order vp trees 
vp tree partitions data space spherical cuts see spherical cuts thin high dimensional domains leading search regions intersect leading branching similarity search 
example consider dimensional euclidean space large number vp tree order built index uniformly distributed data points space 
root level dimensional space 
root level partitioning branching factor 
different regions labeled shaded differently 
partitioned spherical regions shown 
different regions colored differently labeled 
radius region radius sphere enclosing regions 
uniform distribution assumption dimensional volumes regions considered equal 
volume dimensional sphere directly proportional th factor radius deduce thickness spherical shell region 
give idea spherical cuts thin chances search operation descending branch higher 
search path descends children node distance computations needed level distance query point vantage point child node 
vp tree keeps different vantage point node level 
child node associated region spherical shell innermost child spherical region data points indexed child node belong region 
regions disjoint siblings 
vantage point node chosen data points indexed node vantage points siblings different 

multi vantage point trees section mvp tree multi vantage point tree 
similar vp tree mvp tree partitions data space spherical cuts vantage points 
creates partitions respect vantage points level keeps extra information leaf nodes effective filtering distant points similarity search operation 
motivation introducing mvp tree discuss useful observations heuristics designing better search structure vantage points 
observation possible partition spherical shell region vantage point chosen outside region 
shown vantage point outside region partition parts labeled shaded differently region consists disjoint parts 
means vantage point partition regions associated nodes level 
search operation descends branches different distance computation root branch 
vantage point children node vantage point kept parent 
way keeping vantage points parent node 
avoid creating children nodes incorporating parent 
done increasing fanout parent node 
mvp tree takes approach uses vantage points nodes higher utilization 
observation construction vp tree structure data point leaves compute distances point vantage points path root node leaf node keeps data point 
data point log distance computations vp tree order equal height tree 
vp trees distances distance vantage point leaf node kept 
possible keep distances data points leaf nodes provide filtering leaf level search operations 
idea mvp trees 
mvp trees 
partitioning spherical shell region vantage point outside 
data point leaf keep distances parameter computed construction step data point vantage points upper levels tree 
search algorithm modified distances 
illustrates pre computed distances helpful filtering distant objects 
shallow vp tree shown internal nodes having vantage points vp vp leaf node data point 
consider near neighbor query query point similarity range depicted 
data space partitioned regions respect vp boundary shown bold circle vp 
outer region partitioned vp 
similarity search proceeds leaf node kept 
considering distance vp way done able filter compute see inequality 
distance vp computed construction time considered filtered due inequality 
vp vp vp vp 
vp tree decomposition pre computed construction time distances possible filter distant point 
vp vp vp vp vp vp vp having shown motivation mvp tree structure explain construction search algorithms 
mvp tree structure mvp tree uses vantage points node 
node mvp tree viewed levels vantage point tree parent node children children nodes lower level vantage point 
possible mvp tree node large smaller number vantage points non leaf levels 
section show structure mvp trees construction algorithm binary 
general mvp tree parameters number partitions created vantage point maximum fanout leaf nodes number distances data points kept leaves 
binary mvp trees vantage point referred divides space parts second vantage point referred divides partitions 
fanout node binary mvp tree 
general fanout internal node denoted parameter number partitions created vantage point 
vantage point creates partitions second point creates partitions partitions created vantage point making fanout node internal node keep median partition respect vantage point medians partitions respect second vantage point 
leaf node exact distances data points leaf vantage points leaf kept 

distances second vantage points respectively maximum fanout leaf nodes may chosen larger fanout internal nodes 
data point leaves array path keeps pre computed distances data point vantage points path root leaf node keeps parameter bigger maximum number vantage points path root leaf node 
shows structure internal leaf nodes binary mvp tree 
child pointers 

path path 
path internal node leaf node data points having explanation parameters structure construction algorithm 
note took simplicity presenting algorithm 
construction mvp trees finite set 
objects metric distance function mvp tree parameters constructed follows 
notation 
variable level keep track number vantage points path current node root 
initialized 
create empty tree quit 
select arbitrary object vantage point 
delete calculate store array farthest point second vantage point 
delete calculate store array quit 
arbitrary object vantage point 
delete calculate level path level 
order objects respect distances median 
break list lists equal cardinality median 

node structure binary mvp tree 
ss ss sets order ss keeps farthest objects arbitrary object ss second vantage point 
ss ss delete ss calculate ss ss level path level median ss median ss break list ss sets equal cardinality 
similarly break ss sets equal cardinality 
level level recursively create mvp trees sets 
mvp tree construction modified easily vantage points kept node 
talk generalization section 
higher internal nodes possible may favorable cases 
observe choose second vantage point farthest points vantage point 
vantage points close able effectively partition data set 
farthest point may best candidate second vantage point 
chose second vantage point leaf node farthest point vantage point leaf node 
note optimization technique heuristic choose best vantage point vp trees applied mvp trees 
briefly discuss better ways choosing vantage points section 
construction step requires log distance computations mvp tree 
extra storage requirement mvp trees keep distances data point leaf node 
full mvp tree parameters height vantage points 
twice number nodes mvp tree vantage points kept node 
number data points vantage points number leaf nodes times capacity leaf node 
idea large data items kept leaves 
large ratio number vantage points versus number points leaf nodes smaller meaning data points accommodated leaf nodes 
possible filter distant search region points consideration making pre computed distances point leaf node 
words making distance computations vantage points internal nodes delay major filtering step search algorithm leaf level effective ways avoiding unnecessary distance computations 
search algorithm mvp trees search algorithm proceeds depth mvp trees 
keep distances query object vantage points current search path distances filtering data points leaves possible 
array path size keep distances 
similarity search mvp trees query object set data objects distance search algorithm compute distances 
second vantage points answer set 
answer set 
current node leaf node data points node find arrays respectively 

path path path holds compute 
answer set 
current node internal node level path level 
level path level 
recursively search branch level level recursively search second branch level level recursively search third branch level level recursively search fourth branch level level efficiency search algorithm depends distribution distances data points query range selection vantage points 
worst case data points relatively far away randomly generated vectors high dimensional domain section 
search algorithm case distance computations cardinality data set 
worst case number distance computations search algorithm far making significant improvement linear search 
note claim worst case complexity true distance index structures simply triangle inequality filter data points distant query point 
section results experimental study evaluation performance mvp trees 

implementation implemented main memory model mvp trees test compare vp trees 
mvp tree vp trees implemented unix operating system 
distance computations assumed expensive metric spaces consider number distance computations cost measure 
mvp tree structure paged structure discuss performance 
counted number distance computations required similarity search queries mvp vp trees comparison 
data sets types data high dimensional euclidean vectors gray level mri images image pixels empirical study 
high dimensional euclidean vectors sets euclidean vectors different distributions 
euclidean distance metric distance metric experiments 
note dimensionality euclidean data sets choice euclidean distance metric particular significance 
indexing techniques tv trees trees bkp particularly designed high dimensional euclidean data 
general metric spaces pairwise distances objects data space index construction search assume geometric information available 
characteristics affect query performance pairwise distance distribution objects metric space 
mvp trees vp trees specifically designed euclidean vectors experimented experiments provides convenient test bed relating search performances different distance distributions 
set experiments conducted uniformly distributed euclidean vectors 
uniformly distributed vectors dimensional euclidean spaces 
sets vectors chosen randomly dimensional unit hypercube 
pairwise distance distribution uniformly distributed vectors dimensions shown 
distance values sampled intervals length 
distance distribution histogram uniform ly distributed vectors distance value dim dim consider distance distribution dimensional case 
vectors far away distance distribution similar sharp gaussian curve distances points fall interval concentrating midpoint 
result vantage points vp trees mvp trees partition space thin spherical shells large void spherical region center accommodate data points 
distribution structures hierarchical method effective queries having values similarity ranges larger higher values may quite reasonable legitimate similarity queries 
matter fact query points generated way practically impossible find near neighbor query point similarity ranges randomly generated pairs points closer 
means selectivity queries similarity ranges low close zero equal 
distance distribution narrow hard trim search larger similarity ranges leads slight improvements sequential search 
experimented dimensional random vectors 
dimensions distance distribution pattern data points far pairwise distances fall interval concentrating midpoint 
selectivity queries small query ranges smaller higher dimensions allows relate selectivity factor query performance experiments uniformly distributed vectors 
selectivity different query ranges dimensional vectors section 
distance distribution histogram vectors generated clusters distance value 
distance distribution dimensional euclidean vectors generated clusters 
axis shows number data object pairs corresponding distance value distance values sampled intervals length 
distance distribution uniformly distributed vectors dimensional euclidean space 
axis shows number data object pairs corresponding distance value distance values sampled intervals length set experiments conducted dimensional euclidean vectors generated clusters equal size 
clusters generated follows 
random vector generated hypercube side size 
random vector seed cluster 
vectors cluster generated vector previously generated vector cluster simply altering dimension vector addition random value chosen interval small constant 
points generated previously generated points accumulation differences may large points distant seed cluster outside unit hypercube 
call groups points clusters way generated bunch points physically close euclidean space 
distance distribution histogram set clustered data shown cluster size 
distance values sampled intervals size 
quickly realize data set different distance distribution possible pairwise distances wider range 
distribution sharp random vectors 
data set tested similarity queries ranging different query sets 
try experiments dimensional vectors generated way able observe query range selectivity relationship dimensional space 
selectivity queries data set discussed section 
gray level mri images experimented mri images pixels values gray level 
images collection mri head scans people 
content information images simply metrics compute distances images 
remember distance dimensional euclidean vectors denoted calculated follows metric euclidean distance metric 
distance vectors simply accumulating absolute differences dimension 
calculating distances images simply treated dimensional euclidean vectors pixel pixel intensity differences accumulated metrics 
data set example desirable decrease number distance computations index structure 
distance computations require large number arithmetic operations require considerable time images stored disk image images binary pgm format byte pixel 
distance distribution ith respect metric distance values divided 
distance histogram images metric 
distance distributions mri images metrics shown histograms figures 
different pairs images computations 
distance values normalized avoid large values distance calculations images 
distance values normalized similarly 
normalization distance values sampled intervals length case 
distance distribution respect metric distance values divided distance distribution images different euclidean vectors 
peaks indicating images distant quite similar probably forming clusters 
distribution gives idea choosing meaningful tolerance factors similarity queries sense see distance ranges considered similar 
metric tolerance factor quite meaningful metric tolerance factor possible distance measures 
metric just metric weighted fashion pixel position assigned weight multiply intensity differences images pixel position computing distances 
distance function easily shown metric 
give importance particular regions example center images computing distances 
experimental results high dimensional euclidean vectors euclidean vectors search performances tree structures 
vp trees order mvp trees values respectively structures 
experiments vp trees higher order observed higher order vp trees give similar worse performances results 
tried mvp trees different parameters observed order gives slightly better close results compared order value higher 
kept points data point leaf nodes 
mvp trees display results different leaf capacity values see effects search efficiency 
take account leaf internal nodes mvpt tree paged consider behavior study 
figures mvp tree values referred mvpt mvp tree referred mvpt trees values 
vp trees order referred vpt vpt respectively 
discuss results uniformly distributed data sets 
experiments query points generated way data points conform uniform distribution 
results figures obtained average different runs structure different seed random function pick vantage points run 
result run obtained averaging results search queries 

distance histogram images metric 
shows performance results dimensional uniformly distributed euclidean data set 
shown mvp trees perform better vp trees vpt slightly better vpt 
mvpt number distance computations compared vpt small query ranges 
performance gap shrinks slowly query range increases mvpt distance computations query range 
mvpt performs better needs percent number distance calculations compared vpt small ranges 
query ranges mvpt respectively distance computations compared vpt 
higher query ranges gain efficiency decreases due fact data points domain quite distant making harder filter distant points search operations 
distance calculations search dimensional random vectors query range vpt vpt mvpt mvpt said section selectivity queries dimensional vectors zero 
case experiments dimensional euclidean vectors 
selectivity versus query range information table total number near neighbors queries shown query ranges 
results averaging different runs different seeds 
query points distributed uniformly 
table 
total number near neighbors experiments dimensional random vectors 
distance calculations search dimensional random vectors query range computations vpt vpt mvpt mvpt 
search performances vp mvp trees dimensional randomly generated euclidean vectors 
query range near neighbors 
search performances vp mvp trees dimensional randomly generated euclidean vectors 
shows performance results dimensional uniformly distributed euclidean vectors 
vpt superior vpt query ranges 
compared vpt mvpt performed distance computations query ranges respectively mvpt performed distance computations query ranges 
see performances close high query ranges 
points closer see dimensional space compared dimensional space harder filter non near neighbor points search structures 
observed table selectivity jumps quickly high query ranges 
euclidean vectors generated clusters different query sets 
query set refer query objects generated randomly dimensional unit hypercube done previous test case 
second query set refer query objects generated slightly altering randomly chosen data objects guaranteed find near neighbors query evaluation 
note set query points conform data distribution data points generated way 
experimental results query sets shown figures 
query set contains objects results obtained averaging different runs different seeds 
table shows total number near neighbors evaluation queries different query ranges 
table 
total number near neighbors query sets respect different query ranges euclidean vectors generated clusters 
shows performance results data set vectors generated clusters query objects generated randomly query set 
data query sets vpt performs slightly better vpt 
mvp trees perform better vp trees 
mvpt number distance computations vpt small query ranges mvpt number computations query ranges 
higher query ranges gain efficiency decreases slowly query range increases 
query range mvpt requires distance computations compared vpt mvpt requires 
distance computations search vectors generated clusters 
query set query range distance computations vpt vpt mvpt mvpt 
search performances vp mvp trees euclidean vectors generated clusters 
query set 
query range near neighbors near neighbors shows performance results data set vectors generated clusters query set 
data set vpt vpt performed close 
relative performances index structures similar previous case absolute number distance computations randomly generated query points query set 
mvpt starts making distance computations compared vpt small query ranges highest query ranges 
mvpt distance computations compared vpt 
distance search vectors generated clusters 
query set query range distance computations vpt vpt mvpt mvpt summarize observations follows higher order vp trees perform slightly better wider distance distributions difference small 
data sets narrow distance distributions low order vp trees better 
mvp trees perform better vp trees 
idea increasing leaf capacity pays decreases number vantage points shortening height tree delays major filtering step leaf level 
random clustered vectors mvp trees high leaf node capacity perform considerable improvement vp trees especially small query ranges 
efficiency gain terms number distance computations smaller larger query ranges significant dimensional vectors 
gray level mri images experimental results similarity search performances vp mvp trees mri images figures 
domain results vp trees mvp trees 
vp trees order referred vpt vpt 
mvp trees parameter 
mvp trees mvpt mvpt mvpt parameter order second leaf capacity 
try higher values number data items domain small 
maximum value common mvp tree structures low cardinality data domain 
results averages taken different runs different seeds different query objects run 
query objects mri images selected randomly data set 
selectivity query ranges shown tables metrics respectively 
mentioned section images form clusters number near neighbors moderate large query ranges distance metrics 

search performances vp mvp trees euclidean vectors generated clusters 
query set 
distance calculations search metric query range divided vpt vpt mvpt mvpt mvpt search performances structures tested vp trees mvp trees metric shown 
query range values shown normalized done 
vp trees vpt performs percent better vpt 
mvpt mvpt perform close having edge vpt 
best mvpt performing number distance computations compared vpt 
distance calculations search metric query range divided vpt vpt mvpt mvpt mvpt 
similarity search performances vp mvp trees mri images metric distance computations 
query range normalized metric near neighbors table average number near neighbors images metric 
similarity search performances vp mvp trees mri images metric distance computations 
query range normalized metric near neighbors table 
average number near neighbors images metric search performances metric shown 
query range values shown normalized done 
similar case metric vpt outperforms vpt similar approximate margin 
mvpt performs better vpt performance degrades higher query range values 
taken general result random function pick vantage points considerable effect efficiency structures especially small cardinality domains 
similar previous case mvpt gives best performance structures making distance computations compared vpt 
summary experimental results data set gray level images support previous observations efficiency mvp trees high leaf node capacity 
image data set low cardinality leading shallow tree structures able get gain efficiency 
experiments conducted larger set images expect higher performance gains 

choosing vantage points suggested constructing vantage point trees choosing vantage points corners space leads better partitions better performance 
heuristic idea geometry data space distribution data points data space 
general case simply idea corners data space 
information pairwise distances objects 
reason vantage points chosen corners data space provide better partitions 
basically distance distributions corner points flat distance distributions center points 
illustrates point 
uniformly distributed dimensional euclidean data space computed distances data points vantage points center point second corner point 
easily seen distribution center point sharper means center point vantage point useful trimming search similarity queries 
distribution distances vantage point distance value corner point middle point data points far away corner points trivial fact observed 
simple fact vantage points corners better 
general case metric spaces may able choose vantage points corners space may able choose better vantage points 
suggest simple heuristic 
choosing vantage point choose random point 
compute distances point points 
choose farthest point vantage point 

distance distributions vantage points center dimensional euclidean hypercube middle point corners cube corner point 
data points distributed uniformly 
note simple procedure guarantee choosing best vantage point helps choosing better vantage points compared chosen heuristic randomly 
case euclidean spaces heuristic verifiable distributions simply farthest point point point close corner sides euclidean hypercube 
tested simple heuristic see provides better performance dimensional euclidean vector sets comparing vp trees mvp trees 
time comparison mvp trees choose vantage point internal node randomly mvp trees choose vantage point heuristic shown 
data sets uniformly distributed vectors vectors generated clusters show results randomly generated query objects referred section 
comparison methods ing vantage point random ly generated euclidean vectors query range random heuristic comparison methods ing vantage points euclidean vectors generated clusters query range distance computations random heuristic figures show result comparison mvp tree parameters mvpt 
cases performance gain varied terms average number distance computations query 
note performance gain comes expense increased number distance computations construction time 
possible random vantage point picked step second vantage point case extra distance computations 
trimming search similarity queries important consecutive vantage points seen path close 
mvp trees better utilization 
query performance mvpt different methods choosing vantage points uniformly distributed dimensional euclidean vectors 

query performance mvpt different methods choosing vantage points dimensional euclidean vectors generated clusters 
pre computed distances search time 
adopted strategy choosing second vantage point internal node farthest points 
section explaining generalized mvp tree structure may number vantage points internal node strategy 

generalized mvp trees section introduce multi vantage point tree structure consider case vantage points internal node hierarchically partition data space 
mentioned construction search algorithms easily modified vantage points internal node 
section change structure mvp tree little bit treat number vantage points internal node parameter 
addition parameters fourth parameter introduced number vantage points internal node 
leaf node structure changed minor improvement 
leaf nodes contain vantage points accommodate data points pre computed distances data point 
search proceeds leaf node pre computed distances filter distant data items 
distances kept data item distances vantage points path starting root node leaf node contains data item 
construction generalized mvp trees vantage points internal node selected similar way explained section 
vantage point say vp picked randomly heuristic section partition data space spherical shell regions referred 
rm partition keeps closest points rm partition keeps farthest points 
farthest point vp selected second vantage point vp time vp partition regions 
rm regions creating regions 

partitions region third vantage point chosen farthest point vp rm guarantees third vantage point distant previous vantage points vp vp distant vp data points partition rm accommodates farthest points vp similarly vp distant vp farthest point vp points rm note vp may farthest point vp farthest point may im distant point 
process continues way vantage points chosen data space partitioned regions iv iv 
construction algorithm 
construction mvp tree parameters finite set 
objects metric distance function mvp tree parameters constructed follows 
notation section 
create empty tree quit 
create leaf node put data items quit 
arbitrary object vantage point 
delete calculate level path 
level level order objects respect distances break list lists equal cardinality recording distance values cutoff points 
denote lists sr 
srm just loop variable jv choose vj farthest point srm 
delete vj srm 
calculate vj sr 
level path level vj distances partition sr 
regions regions creating sr ij ij record cutoff values 
level level recursively create mvpt tree partitions sr iv iv 
search algorithm similar discussed section 
starting root children regions intersect spherical query region visited search query 
leaf node reached distant data points filtered looking pre computed distances vantage points higher tree 
updating mvp trees briefly discuss update characteristics generalized mvp tree structure 
mvp tree created initial set data objects top fashion static index structure 
balanced way constructed number objects indexed subtrees node differ 
note distance index structures trees created top static mvp trees 
possible handle dynamic insertions allowed violate balance mvp tree case tree structure may grow downwards direction tree branches insertions 
distribution dynamically inserted data points conform distribution initial data set index built mvp tree grows smoothly staying balanced close balanced 
insertions cause tree structure skewed additions new data points change distance distribution data set global restructuring may done possibly hours operation 
number distance computations done restructuring process depends number pre computed distance values kept leaf nodes 
pre computed distance values kept reused choosing vantage points restructuring process restructuring done minimum distance computation possible 
implementation evaluation strategies updating mvp trees agenda 
section results experiments different values parameters mvp trees provided query performances compared cases 

experiments generalized mvp trees experiments sets euclidean vectors section set vectors generated randomly second set vectors generated clusters 
pairwise distance distributions data sets section 
query ranges starting randomly generated vectors vectors generated clusters 
randomly generated vectors tested randomly generated query objects euclidean vectors generated clusters tested query sets randomly generated query objects query objects generated randomly chosen data objects done section 
section investigate effect different number vantage points internal nodes utilization pre computed distances search time 
section experimental results done state art distance index structures trees comparison 
authors paolo ciaccia marco patella providing code tree 
tuning mvp tree parameters set experiments try see effects changing number vantage points internal node mvp tree 
figures show results mvp trees different values parameter structures parameters having values respectively 
figures structures referred parameters 
parameter chosen way trees number vantage points path root node leaf node 
example structure mvpt set euclidean vectors vantage points path root leaf log 
holds structures 
note structure mvpt different binary vp tree vantage point internal node fact pre computed distances structure search time leaf size larger 
mention mvpt tree structure internal node meaning total number vantage points tree 
varying number vantage points internal node random vectors query range varying number vantage points internal node random vectors query range distance computations performance results shown figures quite interesting 
clustered vectors query set randomly generated query objects see mvpt catches ones moderate query ranges performs slightly better large query ranges mvpt remains best query ranges 
tells large query ranges 
performance mvp trees different values dimensional uniformly distributed euclidean vectors 

performance mvp trees different values dimensional uniformly distributed euclidean vectors 
lot distance computations anyway having large number vantage points internal levels tree helps trimming search better 
hand small query ranges distance computations vantage points query point mvp trees smaller values perform worse mvp trees larger values 
dimensional random vectors figures observe similar behavior large query ranges mvp trees smaller values close performance gap query ranges get larger perform better mvp trees larger values query range mvpt performs slightly better mvpt 
situation similar case dimensional random vectors mvp trees smaller values close gap faster perform largest query range 
query set clustered vectors mvp trees higher values performed better query ranges 
performance difference quite high especially small query ranges 
varying number vantage points internal node clustered vectors query set query range distance computations varying number vantage points internal node clustered vectors query set query range set experiments parameter varied kept constant 
set mvpt structure varying performed best previous test 
performance results obtained data sets euclidean vectors shown figures 
parameter varied maximum 

performance different values euclidean vectors generated clusters 
query set 

performance different values euclidean vectors generated clusters 
query set 
performance mvp trees different values random vectors query range distance performance mvp trees different values random vectors query range computations clearly observe higher values improves search performance significantly 
give idea mvpt performs distance computations compared mvpt query range dimensional euclidean vectors 
performance difference gradually decreases query range performs distance computations 
performance gains similar dimensional random vectors 
similar behavior observed experiments euclidean vectors generated clusters 
query set performance difference ranges query ranges 
query set performance difference goes 
storage needed higher values may affect time queries 
performance mvp trees different values clustered vectors query set query range distance computations 
performance mvpt different values euclidean vectors generated clusters 
query set 

performance mvpt different values dimensional uniformly distributed euclidean vectors 

performance mvpt different values dimensional uniformly distributed euclidean vectors 
performance mvp trees different values clustered vectors query set query range distance computations set experiments done investigate changing leaf size number vantage points internal nodes affects performance 
experimented mvp trees single directory internal node different number vantage points directory nodes different leaf size 
basically varying number vantage points root leaf node done introducing extra levels decomposition decreasing leaf size 
parameter chosen structures 
performance results shown figures 
performance mvp trees different values random vectors query range performance mvp tree different values random vectors query range computations 
performance mvpt different values euclidean vectors generated clusters 
query set 

performance mvp trees different parameters dimensional uniformly distributed euclidean vectors 

performance mvp trees different parameters dimensional uniformly distributed euclidean vectors 
figures see vantage points increases performance trimming branches lower levels tree 
structures number pre computed distances search queries values structures larger vantage points mvpt equal vantage points mvp tree structures 
means structures set pre computed distances kept data points leaves 
furthermore performance difference structures simply extra trimming done internal level 
performance mvp trees different values clustered vectors query set query range distance computations performance mvp trees different values clustered vectors query set query range mvpt uses vantage points compared mvpt 
employment extra vantage points mvpt results distance computations performance difference decreasing increasing query ranges dimensional random vectors dimensional random vectors number distance computations euclidean vectors generated clusters query set query set observations experiments summarized follows best performance obtained internal node single set vantage points seen figures mvpt performed best 
interesting 
performance different parameters euclidean vectors generated clusters 
query set 

performance different parameters euclidean vectors generated clusters 
query set 
result implies really need come complex structures just pick set points vantage points compute distances points points create simple directory structure distances direct search 
expected pre computed distances search time clearly improves search performance terms number distance computations 
pre computed distances kept data points leaves mvp tree structure consists single internal node discussed ex mvpt may implication restructuring tree batch dynamic operations handled minimum number distance computations cost sorting partitioning data points respect distances vantage points 
vantage points keeping small leaf sizes increases trimming directory nodes provided internal level 
internal level mvp tree suffer making distance computations query objects vantage points provides better filtering data points leaves 
comparison trees experiments compare tree structure mvp trees terms average number distance computations similarity queries 
algorithm cp creating tree 
remind tree distance index structures including dynamic index structure created bottom 
designed paged index structure minimize operations required distance computations 
parameters tune tree better performance minimum node utilization page size 
chosen minimum node utilization page size 
minimum node utilization affect number distance computations search query cp difference building costs consider 
tried values 
trees minimum utilization performed slightly better include results value 
node size affects query performance regarding costs distance computations note consider performance 
page size shown best choice minimizing distance computations referred cpu cost experiments dimensional vectors metric difference choice page sizes drastically different 
tried page sizes 
trees page size gave best performance terms minimizing number distance computations show results page size 
experiments conducted data sets euclidean vectors discussed section 
comparison included structures trees 
vpt vantage point tree order experiments discussed section 
mvp trees denoted parameters usual 
remember mvpt vp tree pre computed distances mvpt internal node vantage points large leaf capacity 
note results vp tree mvp trees sections 
figures see query performances index structures terms average number distance computations similarity search query 
dimensional randomly generated euclidean vectors tree performs close vpt moderate query ranges 
small query ranges performance poor 
gets better query range increases range performs mvp tree structures surpassing vpt performance making distance computations 
reason believe trees catch mvp trees distance distribution narrow mvp vp tree performances degenerate faster increasing query range compared trees 
mvp trees vantage point employed node partition data points node necessarily physically close vantage point 
uniformly distributed data leads filtering mechanism effective query ranges relatively large highly efficient small moderate query ranges 
talk query range relatively large mean relative distance distribution data space 
trees adjust increasing query ranges gracefully partition data points physical closeness trying create clusters leads overhead small query ranges efficient compared mvp trees 
see similar trend dimensional case performance trees better 
dimensional case trees perform worse query ranges catch query range increases give best performance query range high query range dimensional space case dimensional space 
distances dimensional space smaller compared dimensional case tree structure efficient able decrease radii spherical regions partitions data space 
results comparably better performances high query ranges 
performance index structures dimensional random vectors query range tree vpt mvpt mvpt performance index structures dimensional random vectors query range tree vpt mvpt mvpt tree perform vectors generated clusters 
query set range mvp trees distance computations tree 
query range mvpt mvpt give idea 
small query ranges tree order magnitude distance computations structures especially 
query set relative performances display similar pattern seen 
query set tree performs close vpt large query ranges performs distance computations range 

comparison tree performance mvp trees vp tree order dimensional randomly generated euclidean vectors 

comparison tree performance mvp trees vp tree order dimensional randomly generated euclidean vectors 
performance index structures clustered vectors query set query range tree vpt mvpt mvpt performance index structures clustered vectors query set query range tree vpt mvpt mvpt partitioning strategy trees different mvp trees partition data space number sphere regions node recording center point routing object covering radius partition 
naturally kind partitioning strategy supposed applications data objects form clusters points physically close 
done experiments data set dimensional vectors clusters 
clusters centers uniformly distributed unit hypercube variance 
euclidean distance metric distance metric 
generated query points conform distribution 
table provides performance results different query ranges terms number distance computations 
expected performance trees terms number distance computations better data set physical clusters 
important performances mvp trees vp tree comparable difference cases 

comparison performance mvp trees vp tree order dimensional euclidean vectors generated clusters 
query set 

comparison performance mvp trees vp tree order dimensional euclidean vectors generated clusters 
query set 
query range total number near neighbors queries total number distance computations tree total number distance computations vpt total number distance computations mvpt total number distance computations mvpt table 
performance results queries data set data points form physical clusters 
introduced mvp tree distance index structure metric data domain 
distance index structures mvp tree assumptions geometry application data space provides filtering method similarity search queries relative distances data objects 
similar vp tree mvp tree takes approach partitioning data space vantage points behaves choosing points pre computed construction time distances answering similarity search queries 
generalize idea multiple vantage points internal node experiment mvpt trees different number vantage points internal node 
experimental results show small set vantage points single directory node provides best results 
distance index structures mvp tree static index structure 
constructed top fashion set data points guaranteed balanced 
handling update operations insertion deletion reasonable costs mvp tree currently open problem 
general difficulty distance index structures stems fact possible cost efficient impose global total order grouping mechanism objects application data domain 
case mvp trees keep tree balanced periodic restructuring operations may needed 
restructuring unavoidable balanced mvp trees done minimum number distance computations pre computed distances kept mvpt tree single directory node 
considered number distance computations cost measure performance comparisons mvp trees access structures 
justifiable applications distance computations expensive general case costs may negligible 
performance comparisons incorporating costs distance computations remains done research 
section discussed heuristics choosing better vantage points show empirically heuristics improve performance mvp trees 
selection better vantage points construction time open problem especially metric spaces data distribution known priori geometry data space assumed 
especially important mvp trees employ large number vantage points internal nodes vantage points node partition data space hierarchical manner vantage point node partition multiple number regions 
afa agrawal faloutsos swami 
efficient similarity search sequence databases 
fodo conference 
bk burkhard keller approaches best match file searching communications acm pages april 
bkss beckmann kriegel schneider seeger tree efficient robust access method points rectangles proceedings acm sigmod conference atlantic city pages may 
berchtold bohm keim 
kriegel cost model nearest neighbor search high dimensional data space proceedings th symposium principles database systems pages 
bkp berchtold keim 
kriegel tree index structure high dimensional data proceedings nd vldb conference pages 
bo ozsoyoglu distance indexing high dimensional metric spaces proceedings acm sigmod conference tucson pages bri brin near neighbor search large metric spaces proceedings st vldb conference pages 
chi chiueh content image indexing proceedings th vldb conference pages 
cp ciaccia patella bulk loading tree proceedings th australasian database conference adc perth australia february 
ciaccia patella tree efficient access method similarity search metric spaces proceedings rd vldb conference 
ciaccia patella processing complex similarity queries distance access methods proceedings th edbt international conference march 
ciaccia patella cost similarity queries metric spaces appear proceedings th symposium principles database systems may 
fef faloutsos equitz flickner efficient effective querying image content journal intelligent information systems pages 
frm faloutsos ranganathan manolopoulos 
fast subsequence matching time series databases 
proceedings acm sigmod conference minneapolis pages may 
gut guttman trees dynamic index structure spatial searching proceedings acm sigmod conference boston pages june 

lin jagadish faloutsos tv tree index structure high dimensional data vldb journal volume pages october 
ott approximate matching high dimensionality trees 
sc scholarly dept computer science univ maryland collage park md 
supervised faloutsos 
roussopoulos kelley vincent nearest neighbor queries proceedings acm sigmod conference san jose pages may 
sam samet design analysis spatial data structures addison wesley 
srf sellis roussopoulos faloutsos tree dynamic index multi dimensional objects proceedings th vldb conference pages september 
sw shasha wang new techniques best match retrieval acm transactions information systems pages 
uhl uhlmann satisfying general proximity similarity queries metric trees information processing letters vol pages 
data structures algorithms nearest neighbor search general metric spaces acm siam symposium discrete algorithms pages 
appendix show correctness search algorithm vp trees 
query object query range vantage point node visit search median distance value node 
show search left branch 
ii denote data object indexed right branch hypothesis triangle inequality summation query result means check object right branch 
denote data object indexed left branch hypothesis triangle inequality summation query result means check object left branch 
