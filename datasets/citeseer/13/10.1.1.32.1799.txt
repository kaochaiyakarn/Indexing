robust oses appliances new approach domain specific languages gilles muller charles consel renaud marlet luciano porto barreto fabrice laurent compose group www irisa fr compose irisa inria campus de beaulieu rennes cedex france consel marlet irisa fr tel fax appliances represent quickly growing domain raises new challenges os design development 
new products appear rapid pace satisfy emerging needs 
second nature markets needs unpredictable 
lastly competitiveness markets exists tremendous pressure deliver new products 
fact innovation requirement emerging markets gain commercial success 
embedded nature appliances upgrading fixing bugs difficult impossible achieve 
consequently high level confidence software 
additionally pace innovation requires rapid os development match changing needs new appliances 
offer confidence software highly robust 
type appliance critical behavioral properties determined guaranteed power management ensure data lost 
robustness provided mechanisms tools 
ideal approach takes form certification tools aimed statically verifying critical properties 
tools avoid need laborious error prone testing process 
market requires testing process shortened development time 
achieve goal strategies needed re code rapidly produce new product assembling existing building blocks factorization expertise capitalize domain specific experience open software systems match evolving functionalities hardware features 
existing os approaches assessed respect requirements raised appliances 
limitations approaches analyzed basis propose new approach designing structuring oses appliances 
approach domain specific languages dsls offers rapid development robust oses 
illustrate assess approach concrete examples 
existing os approaches os os sub system conventionally consists levels mechanisms policies 
mechanisms take form libraries machines 
policies correspond algorithms mechanisms 
ideally policy implemented code gluing mechanisms 
practice separation levels systematically achieved 
lack separation difficult understand reason behavior os turn compromises robustness 
furthermore blurred separation hard identify building blocks causes poor code re 
building blocks clearly exposed code expertise fully exploited 
factorizing expertise harder general purpose usually low level programming language domain specific knowledge explicit 
situation puts limitations robustness code re os expertise 
examine limitations turn 
limited robustness os designers traditionally limited view robustness isolation system components 
view component may consist policy associated mechanisms may represent single policy set related mechanisms 
component isolation implemented boundary protection relying hardware capabilities mmu code instrumentation :10.1.1.142.4909
approach high level type safe language guarantees correct memory access examples include modula spin ml fox net :10.1.1.117.6702
compilation technology languages level performance generated code compare code produced compiler 
furthermore developing os requires low level expressiveness covered high level language manipulation raw data 
situation necessitates additional programming languages develop various extensions 
static approach aimed verifying predefined safety rules binary code proposed necula lee :10.1.1.142.6054
addition static approach goes memory isolation 
example enables verify quantity resources program 
main limitation assumes programs written general purpose language properties interest may undecidable general 
circumvent problem programmer assistance required various stages 
microsoft proposed tool improve driver quality combines static dynamic strategies expose driver errors 
strategies include allocation fault injection parameter verification 
common limitation approaches assume software architecture separation mechanisms policies explicit result specific reasoning strategy applied layer 
limited code re software architecture system plays key role code re 
structuring software system terms components recognized strategy achieve code reuse 
notably os field structuring technique lead micro kernel architectures 
micro kernel architecture component server corresponds domain boundary 
communication domain introduces overhead 
software components directly mapped protected entities granularity impacts system performance 
os architect faces dilemma defining finegrain components expose code re opportunities introducing coarse grain components optimize performance 
shown workplace project ibm compromise necessarily reached 
research projects aimed developing extensible oses :10.1.1.117.6702
oses rely hardware protection boundaries strongly typed languages isolation :10.1.1.142.4909
extensible kernels consist fine grain components enable low level functionalities exposed 
system architecture drastically improve code re 
extensible oses provide effective solution code re address expertise re 
fact low level kernel mechanisms require detailed expertise necessarily correspond skills industry programmer 
limited expertise re mechanisms defined appropriate level granularity expertise required implement policies 
kernel mechanisms highly parameterized cover large set needs poorly documented 
incorrect invocation leads unexpected behavior 
example requirements resource allocations explicit resource leaks prevented 
furthermore combination mechanisms follow precise rules rarely explicitly documented 
situation requires policy programmer master kernel mechanisms 
expertise unfortunately gained careful examination source code laborious debugging 
fact programmers reach sufficient level expertise rapidly develop correct kernel code 
context appliances variety products increases demand experts 
lack tools assist developers verifying mechanism usage demand experts critical 
limited extensibility appliances typically form family products evolve time 
expertise gained product development turn high computer industry expertise may retained 
result new product generations may require expertise re acquired 
expertise extensibility critically depends os architecture 
specifically building blocks clearly staged policies mechanisms may intertwined 
result difficult extend mechanisms policies 
existing approaches extending oses enable new components added modules servers :10.1.1.117.6702
memory protection offer guarantees regarding behavior added components 
limitation disastrous consequences considering widespread nature appliances 
new approach domain specific languages common thread approach designing oses domain specific languages dsls 
approach dsl developed family sub systems 
overview approach 
dsl consists distinct parts machine compiler dsl machine 
structure enforces level design policies written dsl machine directly mapped mechanisms 
level approach forces designer stage design issues step aimed characterizing policies needed target sub system family second step consists determining mechanisms common policies 
library mechanisms define machine 
policy characterization defines program patterns needed express policies interest 
addition properties critical family sub systems identified termination resource allocation 
program patterns properties design language dedicated writing target policies 
program patterns suggest specific syntactic abstractions properties lead specific language restrictions properties decidable 
feature contrasts general purpose languages expressiveness traded verification 
importantly development new dsl rarely means brand new syntax 
process usually consists restricting existing language adding domain specific constructs values 
improving robustness dsl expose information trigger domainspecific optimizations 
example parameter passed layers need copied language guarantees policy reads optimizations performed flick idl compiler 
experience shown restricted nature dsls drastically improves development time compilers reduces number concepts treat enables production high quality code 
dsls 
approach carried practice families sub systems device drivers active networks 
device driver study lead design implementation languages gal devil :10.1.1.34.3868:10.1.1.24.1577
gal specifically targets graphics cards high level specification compiler generates complete device driver 
devil covers types devices seen idl hardware programming device specification compiler generates low level code operate device 
dsls offer high level abstractions overcome intricacies interaction hardware error prone bit manipulations 
enable critical properties device specifications verified example writing devil specification times prone errors writing equivalent code 
drastically improve productivity example gal specification times smaller corresponding driver 
gal devil demonstrated dsls compete equivalent code :10.1.1.34.3868
study active networks lead development dsl called plan 
dsl allows application specific protocols written dynamically deployed routers terminal equipment appliances 
network infrastructure shared resource applicationspecific protocols behaved 
consequently plan designed properties guaranteeing network safety preserved termination linear packet duplication 
practice protocol implementations plan shown times smaller efficient equivalent code 
examine detail ways dsl approach improves robustness code re os expertise 
improved robustness explicit separation mechanisms policies enforced dsl approach enables specific reasoning level 
expressiveness dsl defined behaved policies written 
compilation policies address static dynamic verification mechanism usage machine usage 
statically compiler ensures mechanisms invoked proper parameters follow precise usage rules 
dsl designer considers particular static verification places large burden language expressiveness dynamic checks emitted compiler 
example devil enumerated types permit precisely define set valid commands register 
run time assertions debug mode enforce correct usage generated interfaces programmer 
result verification dsl programs intrinsic language design robustness policies certified 
fact guarantees dsls key technology innovation intensive domain appliances 
improved code re code re intrinsic approach dsl associated machine target specific family sub systems 
common building blocks clearly identified implementing policy guaranteed dsl compiler 
process ensures full re code contrast libraries re depends programmer knowledge 
traditional os improving re consists opening mechanisms low level enable large variety policies defined 
mechanisms expose lower level functionalities programmer needs introduce glue code set appropriate invocation context 
context dsls level mechanisms exposed issue anymore compiler generates code set invocation context 
improved expertise re discussed previously expertise low level mechanisms gained appliances developed 
expertise explicit lost programmers change assignments 
approach expertise form implementation knowledge safety rules captured dsl compiler 
accordingly programmers need domain experts 
practice dsl compiler corresponds expertise repository 
example current plan run time system relies solaris streams library known difficult error prone 
plan compiler fully hides complexity programmer 
fact non kernel expert students able develop plan protocols day 
dsl approach represents framework policy development enables programmer focus policy algorithm abstracts away implementation details 
result attention devoted functionalities policies 
addition experimenting policies tuning easier 
improved extensibility level design enforced dsl approach allows extensions conceptual levels policies mechanisms 
extensions policy level characterized dsl syntax property verification 
extensions mechanism level achieved changing machine implementation 
active networks represent outstanding example extensible system protocols dynamically deployed heterogeneous infrastructure routers workstations appliances 
plan enables protocols introduced policies allows different machine implementations developed various hardware platforms 
proposed methodology design implement new generation oses quickly evolving domains appliances 
developing oses domains puts tremendous stress robustness code re expertise re extensibility 
showed dsl approach represents new solution issues 
dsl approach validated various families sub systems 
dsls successfully addressed issues loss efficiency 
goal dsls design develop embedded os scratch 
new os service captured dsl 
currently analyzing families sub systems determine critical properties domain 
stage plan conduct comparative studies existing embedded oses assess benefits drawbacks approach 
driver verifier expose driver errors 
www microsoft com driver htm 
baron bolosky golub rashid tevanian young 
mach new kernel foundation unix development 
summer usenix conference pages 
bershad savage pardyak gun sirer fiuczynski becker chambers eggers :10.1.1.117.6702
extensibility safety performance spin operating system 
sosp pages 
eide frei ford lepreau lindstrom 
flick flexible optimizing idl compiler 
proceedings acm sigplan conference programming language design implementation pages las vegas nv usa june 
engler kaashoek toole 
exokernel operating system architecture applicationlevel resource management 
sosp pages 

failure personalities generalize 
hotos pages 
ford back benson lepreau lin shivers 
flux oskit substrate kernel language research 
proceedings acm symposium operating systems principles pages st malo france october 
ford hibler lepreau back 
microkernels meet recursive virtual machines 
osdi pages 
harper lee pfenning 
fox project advanced language technology extensible systems 
technical report cmu cs school computer science carnegie mellon university pittsburgh pa january 
published fox memorandum cmu cs fox 
th workshop hot topics operating systems cape cod ma may 
ieee computer society 
hsieh fiuczynski garrett savage becker bershad language support extensible operating systems 
workshop record workshop compiler support systems software pages tucson az usa february 
ladd 
programming web application oriented language hypermedia service programming 
fourth international world wide web conference boston massachusetts december 
liedtke 
kernel construction 
sosp pages 
consel marlet muller 
devil idl hardware programming 
proceedings fourth symposium operating systems design implementation san diego california october 
appear 
necula lee :10.1.1.142.6054
safe kernel extensions run time checking 
osdi pages 
proceedings second symposium operating systems design implementation seattle washington october 
consel marlet muller 
dsl approach improve productivity safety device drivers development 
proceedings th ieee international conference automated software engineering ase grenoble france september 
ieee computer society press 
appear 
rozier armand herrmann kaiser leonard 
overview chorus distributed operating system 
usenix workshop proceedings micro kernels kernel architectures pages seattle wa usa april 
proceedings acm symposium operating systems principles copper mountain resort usa december 
acm operating systems reviews acm press 
thibault consel muller 
safe efficient active network programming 
th ieee symposium reliable distributed systems pages west lafayette indiana october 
thibault muller 
adapting distributed applications extensible networks 
proceedings th international conference distributed computing systems pages austin texas may 
ieee computer society press 
thibault marlet consel 
domain specific languages design implementation application video device drivers generation 
ieee transactions software engineering may june 
wahbe lucco anderson graham :10.1.1.142.4909
efficient software fault isolation 
proceedings acm symposium operating systems principles pages asheville nc usa december 
acm operating systems reviews acm press 
wetherall 
active network vision reality lessons capsule system 
proceedings acm symposium operating systems principles kiawah island sc december 
