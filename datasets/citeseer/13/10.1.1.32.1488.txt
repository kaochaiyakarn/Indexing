magic templates approach logic programs raghu ramakrishnan university wisconsin madison consider bottom query evaluation scheme facts relations allowed nonground terms 
magic sets query rewriting technique generalized allow arguments predicates treated bound rules provide ground bindings arguments 
particular regard bound argument containing function symbol variable appears argument list 
generalized magic predicates defined compute set goals reached top exploration rules starting query goal goals facts constants previous versions magic sets algorithm 
magic predicates restrict bottom evaluation rules redundant actions step bottom computation performed algorithm uses sideways information passing strategy sips 
price paid compared previous versions magic sets store relations nonground facts perform unifications evaluating rules bottom 
method applicable general horn clause logic programs 

strategies proposed evaluating recursive queries expressed sets horn clauses ber dw hn kl kl kl na na rl sz sz ul vg vi vi 
see bar bar survey performance comparison 
thesis strategies distinct components binding passing sideways information passing strategy sip rule control strategy 
sip represents decision information gained literals rule subsequently evaluating literals rule 
control strategy implements decision possibly additional optimization techniques 
sip collection may implemented control strategies control strategy may implement distinct sip collections 
particular show simple bottom evaluation may implement sip collection rewriting set horn clauses evaluating rewritten set 
result generalizes generalized magic sets related strategies ber 
importance generalization bottom methods apply horn clause logic program 
results clarify relationship top strategies prolog bottom strategies showing execution top strategy mimicked rewriting program evaluating fixpoint bottomup 
rewriting introduces auxiliary magic predicates magic facts computed bottom evaluation correspond goals generated topdown strategy 
fact generated bottom evaluation generated top strategy solving goals 
consider programs extra logical predicates assert retract cut programs containing negation 
approach evaluate stratified programs containing negation refer reader supported part ibm faculty development award nsf iri 
bpr 
believe prolog style evaluation bottom approaches advantages preferable certain important domains 
show power bottom approach careful separation binding propagation flow control ber clarify relationship top bottom evaluation strategies 
consider techniques implement constraint logic programs jl jm 
example consider rule says values domain program true constraint holds 
difficulty information represented fact relation associated predicate fact viewed conditional associated set constraints 
assumed constraint solver problem collecting appropriate sets constraints computation progresses 
organized follows 
notation definitions introduced rest section 
define sips section 
section consider nonground facts overview approach 
section describe obtain adorned program section magic templates algorithm rewriting adorned program 
discuss aspects algorithm examples 
section characterize relationship rewritten programs sips rewriting illustrate aspects safety termination 

preliminary definitions assume usual definitions horn clause rules terms literals 
program finite set rules 
database finite set finite relations 
relation collection possibly nonground facts 
logic program 
predicates name database relations called base predicates predicates called derived 
loss generality assume base predicate appears head rule set base predicates disjoint set derived predicates 
separation program database allows consider equivalence programs respect possible databases 
greek letters denote vector arguments 
letters denote substitutions state explicitly 
projection vector arguments subset set argument positions defined vector arguments positions 
substitution 
assigns terms variables 
applied syntactic object term rule simultaneously replacing occurrences result called instance set variables 
called domain set variables appearing 
called range 
shall consider substitutions domain range empty understood stated rest 
substitutions idempotent lmm 
element substitution called binding 
notation vars denote set variables object 
follow lmm presentation 
unifier terms substitution call unifier general unifier mgu property unifier substitution terms program query pair database result applying refer set answers query set facts instances query logical consequences 
see vk lm fixpoint characterizations set answers 
say programs queries equivalent database produce answers respective queries 

sideways information passing notion sideways information passing studied ber refer reader detailed discussion 
discussion section follows presentation important differences 
bindings considered form variable ground term 
show involves loss generality requirement variable head rule appear body 
requirement relax definition bindings precludes information passing strategies 
consider arbitrary bindings form term 
sideways information passing strategy henceforth referred sip inherent component query evaluation strategy 
intuitively sip describes evaluate rule set head arguments bound unification goal possibly nonground terms variables 
term bound arguments accurately described term potentially restricted 
particular confusion may arise bound logic programming deductive database literatures somewhat different sense 
rule head predicate denote projection arguments bound rule invoked 
arguments bound called free arguments 
head literal assume arguments bound rule invoked 
similarly define projection free arguments example follow conventions rest 
possible rule invoked pattern bound arguments 
analyze rule pattern bound arguments invoked details clear proceed 
special literal denoting head literal restricted bound arguments 
arguments denote set literals body 
sip set bound head arguments labeled graph satisfies conditions 
node subset 

arc form label subset member set variables variable appears 
exists partial ordering literals arc literals tail precede literal head literals appear sip follow appear sip 
head sip arc singleton set omit curly braces 
explain meaning graph explaining computation rule uses arc simplicity assume arc entering node multiple arcs dealt ber 
explaining complete computation rule 
arc means variables bound terms solving literals join database terminology 
consider arc facts binding 
binding variable partially instantiates literal sip interpreted requiring fact substitution instance partially instantiated literal logical consequence program database ought inferred 
example fact logical consequence program substitution instance fact ought inferred 
observe partially instantiated fact corresponds goal topdown prolog style execution definition sip requires goal identified answers inferred 
sip provides potential restriction set facts computed required compute facts solving literal 
literals body rule solved obtain instance rule instantiated head literal logical consequence program database 
new facts inferred 
suppose want rule arguments head predicate bound 
argument designated bound means interested evaluating rule argument bound set terms 
special node may thought relation fields corresponding bound arguments head predicate 
tuple corresponds vector bindings arguments 
intuitively tuple contains vector bindings bound arguments call adorned predicate prolog style execution 
emphasize discussion interpretation sip understood abstraction conveys done done 
example prolog create special predicates store bindings head arguments explicitly evaluate joins mentioned 
operations implicit way prolog maintains variable bindings unification backtracking 
interpretation sip forms basis definition sip strategy section 
example consider rules sg flat 
sg sg flat sg 
query sg john 
non linear version generation program ber 
numbered sg occurrences second rule convenience 
query natural way second rule solve predicates indicated order bindings predicate solve predicate 
information passing strategy may represented sip sg sg sg 
sg sg 
flat sg sg 
flat sg 
focus evaluation derived predicates ignore bindings passed base predicates retrieve subset corresponding relations simplicity exposition 
previous example introduced notion sips sips satisfy earlier definition sip ber 
example illustrates differences 
example 
program disallowed earlier approaches rules 
rule range restricted variable head appears body 
consider query 
solved solving goal bind solving goal bind 
fact prolog sip describes valid sip definition valid sip definition ber bound ground terms arc entering second condition defining sip sip arc label require variables appear arguments simply consequence fact bindings variables interest evaluating predicate occurrence 
depart definition sip ber important way longer require variables appear arguments predicates variables appear essentially free variables see example restrict set facts compute 
example 
base relation 
fields contain second fields consider rule 
query rules program 
need compute facts value arguments 
expressed sip second rule relation large reduction number inferences significant 
sections see sip implemented bottom fixpoint computation 
sip clearly invalid definition ber implemented algorithms 
show bottom implementation sip requires introduce rules range restricted 
example illustrates general notion binding contrast earlier bound meant bound ground term 
important difference definition sip earlier definition partially bound arguments arguments variables bound free 
example illustrates 
example 

program illustrates sideways information passing strategy disallowed ber efficiently implemented rewriting methods 
reflects decision followed deductive database literature discussed ul 
consider query 
possible sip rule compute entire relation subset 
valid sip definition ber bound argument 

full sips consider rule set arguments bound head literal general sips choose identify important class sips called full sips 
full sip sip unique total ordering induced sip literals ii exactly arc entering singleton node associated body literal contains predecessors contains variables full sip indicates body literals solved sip induced order solving literal bindings solving preceding literals restrict goal 
body literal argument considered bound 
unique full sip associated distinct total ordering literals example prolog uses full sip left ordering literals 
results hold arbitrary choices sips case full sips rule simplifies details shows intuition clearly 
return point sections 
overview proposed evaluation strategy section main objectives extend definitions rule application duplicate elimination deductive database concepts case nonground terms ii overview approach evaluating logic programs 
remarked earlier methods generalize previous 
consider program possibly obtained program query applying program transformations evaluated 
important restriction relaxed requirement final program variable head rule appear body 
central feature generalization revised notion tuple 
tuple usually defined ground fact derived base relation 
allow tuples possibly nonground facts tuple fact purposes 
easy see requiring rules range restricted ensures relation contains nonground fact 
lemma rule program range restricted fact predicate appearing program ground 
proof induction 
basis fact database predicate ground range restricted rules empty bodies 
facts derived steps ground consider derivation fact steps 
consider step rule application 
fact rule body ground hypothesis 
follows head fact ground head variable appears body bound ground term 
notion nonground facts standard logic programming literature 
knowledge facts deductive database literature kl 
kifer evaluation method called allow rules range restricted objective dealing general logic programs 
method fully restrict search possible combine ideas sophisticated version method called dynamic filtering defined earlier range restricted rules kl 
rule application defined follows 
consider rule 
substitution body literal fact substitution vars vars 
rule applied set facts generate fact consider logic program compute fixpoint program follows 
set known facts initially set facts repeatedly apply rules set known facts add generated facts set known facts fact generated instance known fact 
practice perform generalized join operation relations containing known facts corresponding body literals generate set facts head 
choosing body literals order unify literal known fact apply resulting substitution general unifier mgu rule 
composition body literals order corresponds substitution description rule application 
fact containing variables denote potentially infinite set facts 
set consists facts generated substitution binds variable fact term set infinite terms constructed function symbols domain contains infinite set constants variables 
rule generate new fact scope variable precisely fact 
facts equivalent upto variable renamings 
note maintain environment variable bindings example done prolog implementations variable may bound instantiated different terms course program execution 
fact general fact substitution terms variables identical general general 
general 
general 
may appear little strange general simply consequence way property 
newly generated fact existing fact need recognize facts denoted denoted 
don need know denote set facts 
fact generated applying rule check set facts denoted subset set facts denoted previously generated fact 
add new fact set known facts 
observe operation generalization duplicate elimination database operations 
note introduced allow detect termination 
affect completeness bottom evaluation 
possible devise termination conditions 
example test fact identical general newly generated fact upto renaming variables 
check facts denote set facts 
checked efficiently fails detect termination cases 
discuss termination issue detail subsequent sections 
outline approach evaluating logic programs 
basic idea rewrite program evaluate fixpoint rewritten program repeatedly evaluating rule bottom new facts produced 
objective rewriting produce program bottom evaluation reflects sips chosen original program facts agree values passed sip arcs generated 
rewriting algorithms consider proceed phases 
logic program query produce adorned program 
generation adorned program done conjunction choice sips 
final program produced rewriting algorithm adorned program sips 
generalization generalized magic sets rewriting algorithm ber called magic templates algorithm 
generalization level sips 
rewriting algorithm affected give different name indicate changed nature sips adorned programs accepts final programs produces 

adorned rule set adornment ary predicate string length alphabet stands bound stands free 
consider literal body rule set variables labels sip arcs entering literal 
solving literals tails arcs bindings generated variables wish compute facts match bindings 
variable appears argument interested facts argument bound term bound bindings passed sip 
set interesting bindings argument potentially restricted designate argument bound argument 
important note solution predicates tail sip arc may leave variable label free particular tail may empty variable designated bound 
program query 

construct new adorned version program denoted ad adorned predicate rule head choose sip generate adorned version rule details 
head rule may appear follows may attach distinct sips versions rule version 
details similar corresponding algorithm ber important differences discuss presenting algorithm 
process starts query 
query determines bindings replace adorned version precisely positions bound query designated bound say particular may treat bound argument position contains function symbol constant repeated variable potentially restrict computation answers 
proceed collection adorned predicates fixpoint computation refinement avoids repeating inferences different iterations 
see ba 
note non linear rules treated 
processed mark processed 
unmarked adorned predicate rule head generate adorned version rule add ad marked processed 
adorned version rule contains additional adorned predicates added collection appear 
process terminates unmarked adorned predicates left 
termination guaranteed number adorned versions predicates program finite 
rule head generate adorned version corresponding unmarked adorned predicate follows 
new rule head 
choose sip rule matches adornment argument sip bound special predicate head restricted arguments designated bound adornment replace derived predicate body rule adorned version version new add collection 
obtain adorned version derived predicate body rule follows 
occurrence derived predicate rule union labels arcs coming 
arc coming denote empty label 
replace argument bound variable appearing contains constant 
example ber adorned rule set corresponding nonlinear generation example sip example 
sg bf flat 

sg bf sg bf flat sg bf 
query sg bf john 
adorned rules illustrate rule rewriting algorithms 
example adorned rule set corresponding program sip example ff ff bb 
ff bb adorned program contains rule range restricted rule 
program disallowed ber 
example adorned rule set corresponding program sip example bbf 
bbf 
adorned program produced algorithm ber 
adorned version fff considered occurrence rule bound left rule 
see leads rule rewritten magic program 
example adorned rule set corresponding program sip example 

variant program example illustrates subtle point 

sip chosen rule 
adornment reachable appears ad consider recursive rule defining 
head choose sip rule bind argument body rule 
gives adorned program 

adornment occurrence body second rule optimistic 
adornment chosen rule bound 
adornment head second rule optimistically alas mistakenly assume bound 
technically bound free variable 
recall bound understood potentially restricted 
see set answers computed correctly 
general important remember sips generate adorned program subsequent rewriting 
note single adorned version rule chosen adorned version head predicate 
goals binding pattern matches adornment adorned head predicate solved adorned version rule chosen compile time 

case full sips number adorned versions ary predicate number adorned versions reachable query appear ad typically smaller 
particular full sip chosen rule program strings bs 
ad identical understanding ad ary predicate adorned string bs 

magic templates henceforth consider adorned set rules ad stage proposed transformation define additional predicates compute values passed predicate original rules sip strategy chosen rule 
original rules modified applies values additional predicates available 
auxiliary predicates called magic predicates sets facts compute called magic templates 
intention bottom evaluation modified set rules simulate sip chosen adorned rule restricting search space 
name strategy 
earliest version called magic sets generalization arbitrary range restricted rules called generalized magic sets ber 
rewriting algorithm described section ber 
evaluation rewritten programs notion program equivalence proofs theorems lemmas characterizing rewritten programs differ due different interpretations sips reconsidered 
order keep self contained description rewriting algorithm 
create new predicate magic ad 
create magic predicates derived predicates possibly 
arity new predicate number occurrences adornment arguments correspond bound arguments 
rule ad occurrence adorned predicate body generate magic rule defining magic see 

rule head say ad modified addition literal magic body 

create seed fact magic query 
explain second step detail 
consider adorned rule 
sip associated rule 
assume predicates body ordered sip 
participate sip precede predicates tail arc precede predicate head arc consider arc entering sip 
generate magic rule defining magic follows 
head magic rule magic 
add body magic rule 
special predicate denoting bound arguments head add magic body magic rule 
note argument magic predicate corresponds adornment fs correspond free arguments correspond arguments magic predicate 
magic thought magic predicate predicate magic adornment restriction programs ber stated terms rewritten programs produced rewriting algorithms rule rewritten program range restricted 
restrictions sips particular restriction sip arc variable appear restriction partially bound arguments considered free arguments ber necessary ensure 
illustrate rewriting algorithm examples 
example sips example generalized magic sets strategy rewrites adorned rule set corresponding non linear generation example set rules 
rule numbers refer adorned rule set 
magic sg bf john seed query rule magic sg bf magic sg bf rule nd body literal magic sg bf magic sg bf sg bf flat rule th body literal consider case multiple arcs entering predicate see ber 
sg bf magic sg bf flat modified rule sg bf magic sg bf sg bf flat sg bf modified rule example observe joins repeated bodies rules defining magic sg bf generated rule body rule 
variant magic sets called supplementary magic sets ber avoids duplication effort storing results joins projecting unnecessary arguments 
supplementary algorithm easily generalized lines indicated 
focus magic templates algorithm easier see intuition supplementary variant may rewriting algorithm choice 
example rewritten program corresponding adorned program example ff ff bb 
ff bb magic bb 
magic bb ff 
rewritten program contains rule range restricted rule 
program disallowed restrictions ber 
execution program proceeds follows 
rule applied generate magic bb 
third rule applied generate bb rule applied generate ff 
observe facts generated program halts 
example rewritten program corresponding adorned program example bbf 
bbf magic bbf 
magic bbf mentioned earlier program rule range restricted third rule 
sip contained arc variable label appear tail arc arcs lead rules range restricted rewritten program arcs disallowed definition sips ber 
example rewritten program corresponding adorned program example 
magic 
magic 
execution program proceed follows 
rule applied generate fact magic 
third rule prevented producing facts 
rule produce facts computation halts 
rewritten program corresponding second adorned program example 
magic 
magic 
magic 
magic magic 
second rule defining magic produced occurrence body rule defining observe rule produces fact magic 
fact relation magic trivial filter restrict computation 
exactly happen argument body rule defining really free variable discussed example 
previous examples illustrated nature extension magic sets magic templates 
ability deal rules range restricted rewritten program provides elegant solution problem utilizing partially bound arguments examples 
example illustrated situation repeated free variables ability deal rules allowed extend range sips implemented bottom strategies 
ability required utilize standard logic programming techniques difference lists 
example program appends lists constant time 
input lists represented difference lists 
difference list term representing list difference lists 
example consider list composed elements order 
think difference list composed list list syntax dlist denote term 
append dlist dlist dlist expect rule arguments bound difference lists 
third argument resulting fact list obtained appending second list 
adorned version rule append bbf dlist dlist dlist call append dlist dlist 
succeeds generating fact append bbf dlist dlist dlist 
computation binding unification 
rule range restricted 
input arguments variables bound free variables 
rule generates fact containing input argument lists generate facts free variables 
implies program contain rule range restricted 
consider program uses technique 
program mw breaks list parts 
problem may know break list process part 
efficiently stepping list part difference lists 
better appreciation power difference lists reader referred mw alternative program difference lists 
dlist dlist dlist 
dlist executed prolog program argument bound difference list 
consider call dlist 
generates goal dlist solved dlist 
input list processed broken 
solve goal dlist 
rules defining included 
realize rewriting program dlist magic dlist dlist dlist 
dlist magic dlist 
magic dlist magic dlist 
magic dlist magic dlist dlist 
magic dlist 
rule seed obtained call 
details sip chosen intermediate adorned program clear 
point note rule defining magic range restricted appears head body 
bottom execution program mimics prolog execution reader easily verify 
notice generation magic facts corresponds generation goals prolog execution 
consider correctness transformation 
mg denote program obtained ad magic transformation 
resolve small detail 
query seed definition magic sets 
choose different query query form magic predicates magic predicate definitions modified rules result seed specific query 
consider seed part mg respect original program adorned predicate viewed query form 
represents queries form arguments corresponding adornment bound 
say mg equivalent programs produce results instance query form corresponding seed added mg show mg equivalent query form 
follows stronger result 
remind reader consider pure horn clause programs negation 
theorem ad mg predicate appears ad equivalent mg 
proof note modified rule produced step transformation mg predicate magic literal corresponding head dropped obtain rule modified rules contain predicates ad head 
follows modified rule mg applied facts produce new fact corresponding rule applied versions facts generate corresponding new fact 
induction adorned version fact generated bottom computation mg version fact generated bottom computation answer set mg contained answer set 
direction generated computation exists derivation tree 
fact root tree leaves base facts internal node labeled fact rule generates fact facts labeling children 
prove induction height derivation trees derivation tree fact ad derivation tree mg magic 
basis induction set derivation trees height 
simply base facts derivation trees mg hypothesis refer subsequently hypothesis hold trees height consider derivation tree height assume rule derive root 
notation denote vectors arguments rule instance order distinguish corresponding arguments text rule 
rule instance corresponding derivation root rule 
modified rule mg form magic 
corresponding rule instance magic 
fact root derivation tree height show derivation tree mg magic show exist derivation trees facts base predicate derivation tree height 
derived predicate follows induction hypothesis show derivation tree mg magic facts magic proof derivation tree magic facts induction position predicate occurrence body rule basis case derived predicate occurrence body 
construction rule say mg head magic body contains base literals occur left magic 
corresponding facts body rule instance body rule obtain instance rule head fact magic 
derivation tree mg magic magic 
follows induction hypothesis derivation tree 
jth derived predicate occurrence body rule hypothesis refer hypothesis hold derived predicate occurrences 
construction mg contains rule say head magic body contains magic base literals derived predicate occurrences corresponding magic literals 
facts corresponding literals instance rule generated induction hypothesis rule construct derivation tree magic 
follows derivation tree 
completes proof theorem 
loss generality assume body literals ordered partial order induced sips 

magic programs full sips syntactic simplification possible need explicitly indicate predicates argument considered bound 
note certain arguments designated bound really provide restriction 
consider original program 
argument position body literal say rule contains just variable variable appears literal preceding literals argument provides restriction 
magic rule generated literal occurrence magic head literal variable ith argument replaced don care variable 
fact reduce arity magic predicate considering arguments free obviously mean sacrificing simplicity having just reachable adornment string bs predicate 
observe argument position potentially restricted cases variable appears preceding literal literal position contains non variable term 

properties magic programs previous section showed magic templates algorithm transformed program equivalent program respect query 
fixpoint transformed program computed bottom iteration possibly refinements evaluation ba 
section consider properties fixpoint evaluation transformed program 

optimality magic sips main result concerns optimality magic templates strategy sense implements set sips computing minimum set facts 
define class strategies claim optimality ber 
definition generalizes ber including strategies generate nonground facts 
essentially definition seeks capture done establish answer computed preclude strategies behave oracles knowledge logical consequences rules facts database 
limits consideration strategies follow set rules collection sips 
accordingly define sip strategy computing answers query expressed set horn clause rules set sips adornment rule head follows 
assume strategy constructs queries query constructs answers rules program compute new facts 
set queries set facts generated computation satisfy certain conditions express requirement strategy follow sips computing answers 
sip strategy takes input query ii 
program collection sips rule exactly sip head adornment 
computation satisfy conditions 

query answer computed 


query rule head predicate query constructed predicate rule body sip rule 
sip strategy initially called set rules facts database query 
condition requires compute answers query generates 
second condition describes answers generated query 
rule head matching query invoke rule determining adornment selecting sip follow 
rule body evaluated 
body literal subqueries generated sip 
consider body literal 
subquery generated 
vector bound arguments subquery obtained substituting variables terms passed sip arc entering node corresponding literal 
free argument unique variable subquery restrict terms may appear free argument positions 
defining passing bindings argument considered bound variable bound 
subquery generated set answers 
pass bindings sip create additional subqueries 
combining answers subqueries generate answers original query involving rule head 
sip optimal strategy defined sip strategy generates set facts queries required definition predicates program 
example example designed illustrate definition sip optimality 
consider program 




query 
magic program mp 
mq 
mq 
mq mp 


mp 
denote collections queries facts conditions definition method respectively 
subqueries generated mp mq 
ignore subqueries base predicates simplicity 
facts generated 
possible generate 
strategy considered sip optimal definition 
words includes 
practice subsumption checks discard generating result generating 
sip optimal strategy 
reasons distinguish different executions definition subsumption checks possible generate rule generated 
executions produced different rule application orders evaluation method choose consider worst case possibility uniformly 
effect rule ordering opinion outside scope sips specify essentially binding propagation order rules 
theorem 
theorem consider query set rules sip associated adornment rule head 
mg set rewritten rules produced magic templates method 
bottom evaluation mg sip optimal 
proof denote collections queries facts conditions definition method respectively 
consider bottom computation mg need identify facts generated computation 
magic seed generated fact 
suppose generated facts corresponding derived predicates body rule 
facts base predicates body body satisfied generates fact head 
generated fact 
remains show fact generated predicate bottom computation mg answer query denotes query precisely claim generated fact magic fact magic query 
generated fact fact query 
instance proof induction height derivation trees 
basis induction seed say magic corresponds query 
suppose claim holds facts generated derivation tree height 
consider fact generated rule derived facts 
body derivation trees height 
fact ad say magic construction modified rules mg induction hypothesis magic corresponds query vector distinct variables substitution instance claim holds fact 
fact magic fact magic generated rule head say magic consider adorned rule ad say sip arc produced magic rule construction magic rules mg predicate corresponds literal magic appear body facts corresponds query answer query induction hypothesis 
interpretation sip terms substituted variables obtain passed sip arc entering node bindings variables 
condition simplicity exposition assume base predicates adorned 
definition method query 
completes proof theorem 
consider significance result 
definition tries capture intuitive idea strategy evaluates program sip collection 
method generate queries facts considered collection rules sips 
stage computation corresponding missing queries facts guessing oracle 
strategies auxiliary information avoid generating answers subqueries covered definition method 
example method vi global optimization 
appropriate comparison methods weigh advantage inferring fewer facts goals cost maintaining auxiliary information 
strategies proceed generating subgoals program strategies covered 
examples methods include counting ber sz sz methods proposed hn na na 
typically methods seek exploit structure rules way goes sideways information passing generally applicable 
definition sufficiently broad include large number proposed strategies 
include prolog versions top evaluation memoing vi extension tables dw static dynamic filtering kl kl parallel evaluation strategies proposed logic programming literature including ka vg 
strategy may generate additional queries facts addition generated conditions reason consider inferior sip optimal strategy magic templates 
sip optimality imply facts queries generated 
bottom computation done evaluation ba fact inferred twice derivation 
general possible avoid inferring fact distinct derivations sacrificing completeness evaluation strategy 
prolog property importance distinction magic templates prolog emphasized study bar bar 
examples considered magic templates identical generalized magic sets method comparison 
examples study assigns lower cost prolog terms number facts inferred 
note contradict results goals generated counted cost magic sets facts generated rules mg cost prolog facts generated rules program prolog 
sip optimality necessarily imply computation efficient resources consumes 
particular reflect overhead associated method inferring new fact goal facts goals 
example bottom evaluations offer potential advantage utilizing efficient set time join algorithms especially relations containing ground facts 
hand fact query magic fact stored new fact checked see previously generated 
overhead incurred prolog 
course consequences prolog including repeated inferences potential looping 
observe assumed answers query required 
answer subset answers desired ability explicitly direct search prolog may useful 
restricted discussion pure horn clause programs negation 

termination issues consider question bottom evaluation mg terminates computing answers query 
corollary theorem 
corollary consider query set rules sip associated adornment rule head 
mg set rewritten rules produced magic templates method 
bottom evaluation mg terminates terminating sip strategy exists evaluating associated sips 
bottom evaluation mg terminates set goals facts generated finite 
terminates programs contain function symbols 
example illustrates aspects termination arise due consideration nonground terms 
compare prolog bottom evaluation 
rewriting 
example 
consider queries 


prolog terminate queries 
program evaluated bottom rewriting terminates producing single new fact regardless query 
rewriting thought rewriting sip contains arcs 
simply reflects certain choice sips 
suppose rewrite program sip prolog gives adorned program query 

rewritten program 
magic 
magic 
magic magic magic 
execution proceeds follows 
apply rule produce magic generated magic assigning 
magic general magic discarded 
apply fourth rule produce 
apply rule produce 
new facts produced computation halts 
consider second query 
adorned program 
rewritten program magic 
magic 
magic magic 
seed magic 
rule repeatedly applied produce magic magic apply rule produce easy see computation stopped answer fact 
consider third query 
adorned rewritten programs second query seed magic 
rule repeatedly applied produce magic magic case fact produced way computation produces facts magic forever 
note faithful implementation prolog sip queries bottom computation terminated due duplicate elimination answer generated 
case computation mimics prolog faithfully 
consider test bottom evaluation terminates program 
refer reader kl krs problem 

constraint logic programming describe constraint logic programming clp implemented bottom approach described earlier sections 
ability deal rules range restricted crucial 
ability extension deal clp programs natural essentially fact associate set constraints 
observed earlier fact variables denotes possibly infinite set facts 
constraints limit set facts excluding violate set constraints associated fact 
obviously facts contain variables associated constraints represent single fact 
consider rule query clp system returns constraint answer constrained fact notion constraints really new form constraints 
example fact thought constrained fact exist 
rule thought constrained fact true 
useful distinguish constraints constraint solver 
henceforth constraint refer new forms constraints examples arithmetic constraints necessary long sound complete constraint solver 
keyword associate constraints facts example rule clp program contains set constraints addition conjunction literals 
logic programs applying rule bottom involves join body literals generate facts head predicate generated facts satisfy constraints rule discarded 
slight simplification fact unified body literal may set constraints associated 
constraints applying unifying substitution added set constraints associated rule order generate new constrained fact corresponding head 
example consider program 


assume rewriting done order focus basic properties clp programs bottom vs top execution 
consider query 
rules defining generate generate facts 
easy see second fact subsumed 
natural extension definition fact general depending intelligent constraint solver discard second fact 
consider query 
substituting fact rule defining conflict facts produced 
query allows important comparison top bottom strategies 
top strategy solve goal independently 
fact derived twice 
bottom strategy infers 
recursion effect major impact performance 
consider query 
answer just fact 
leave reader details execution 
example rewrite program reflect top execution compare bottom top approaches respect termination 

query 
rewritten program bf magic bf bf bf 
bf magic bf 
bf magic bf magic bf magic bf bf 
magic bf magic bf 
magic bf 
applying rule defining magic bf produce facts magic bf magic bf fact general second 
constraint solver able establish discard second fact computation magic bf facts stops producing fact magic bf 
fact rule produce fact bf magic bf generate fact bf fact answer 
computation terminates 
contrast top strategy sets goals forever corresponding infinite set magic facts listed producing answer fact 
note constraint solver smart detect fact magic bf general cause bottom strategy produce infinite number magic facts terminate bottom strategy produces answer fact 
binding propagation standpoint shown distinction top bottom strategies blurred top strategy implemented bottom rewriting 
appropriate control strategy depends problem 
applications top strategy say prolog performs better cases bottom strategies perform better ideally choice careful cost estimates 
bottom strategies important virtue completeness 
saw example facts answer eventually produced top strategy 
depending constraint solver bottom strategy terminates cases top strategy 

bottom strategy applicable general horn clause programs 
method sound complete efficient computes facts goals computed top strategy prolog 
virtue underlying fixpoint evaluation fact inferred twice derivation respect superior prolog 
method terminates prolog particular terminates program contains function symbols 
bottom fixpoint evaluation offers opportunity efficient set oriented operations joins 
method attractive properties 
hand requires store facts relative real costs inferences approaches hard measure backtracking offers advantages interested answer query 
contribution sideways information passing binding propagation distinguished control strategy implement providing insight relationship top bottom methods 

beeri great influence development ideas particular idea sips guide rewriting strategies arose joint ber 
discussions jaffar jean louis lassez helpful seeing applicability results constraint logic programs 
jeff ullman helpful comments earlier version revised 
michael kifer commented draft gave pointers clarified discussions 
saumya debray provided extensive comments greatly improved 
help 

afrati papadimitriou papageorgiou sagiv ullman convergence sideways query evaluation proc 
acm sigart symposium principles database systems 
ba bancilhon note performance rule systems mcc technical report db 
bar bancilhon ramakrishnan amateur recursive query processing strategies proc 
sigmod 
bar bancilhon ramakrishnan performance evaluation data intensive logic programs foundations deductive databases logic programming ed 
minker morgan kaufman 
ber beeri ramakrishnan power magic proc 
acm sigart symposium principles database systems 
bancilhon maier sagiv ullman magic sets strange ways implement logic programs proc 
th acm sigmod sigact symposium principles database systems 
beeri naqvi ramakrishnan shmueli tsur sets negation logic database language ldl proc 
acm sigact sigmod sigart symposium principles database systems 
bpr port ramamohanarao magic set computation stratified databases technical report university melbourne 
dw dietrich warren extension tables memo relations logic programming proc 
symposium logic programming 
gallaire minker 
nicolas logic data bases deductive approach computing surveys vol 
june 
hn naqvi compiling queries recursive order data bases jacm vol january pp 
jl jaffar 
lassez constraint logic programming proc 
conference principles programming languages 
ka reduce process model parallel evaluation logic programs proc 
intl 
conf 
logic programming 
kl kifer filtering data flow deductive databases proc 
intl 
conf 
database theory 
kl kifer framework efficient implementation deductive databases proc 
advanced database symposium tokyo 
kl kifer implementing logic programs database system proc 
intl 
conf 
data engineering 
krs krishnamurthy ramakrishnan shmueli framework testing safety effective computability extended datalog proc 
sigmod 
lm 
lassez maher closures fairness semantics programming logic theoretical computer science 
lmm 
lassez maher marriott unification revisited foundations deductive databases logic programming ed 
minker morgan kaufman 
mw maier warren computing logic logic programming prolog benjamin cummings publishing 
na naughton sided recursions proc 
acm sigmod sigact symposium principles database systems 
na naughton compiling separable recursions proc 
sigmod 
alexander method technique processing recursive axioms deductive databases new generation computing 
sz zaniolo implementation simple class logic queries databases proc 
acm sigmod sigact symposium principles database systems 
sz zaniolo generalized counting method recursive logic queries proc 
intl 
conference database theory 
ul ullman implementation logical query languages databases tods vol 
pp 

vk van emden kowalski semantics predicate logic programming language jacm oct 
vg van gelder message passing framework recursive query evaluation proc 
sigmod 
vi recursive axioms deductive databases query subquery approach proc 
intl 
conference expert database systems 
vi global optimization recursive queries proc 
intl 
conf 
expert database systems 
