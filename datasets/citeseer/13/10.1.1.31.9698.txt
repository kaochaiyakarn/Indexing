complexity theory revision russell greiner department computing science university alberta edmonton ab canada greiner cs ualberta ca www cs ualberta ca greiner november knowledge system uses database theory produce answers queries receives 
unfortunately answers may incorrect underlying theory faulty 
standard theory revision systems set labeled queries query paired correct answer transform theory adding deleting rules antecedents related theory accurate possible 
formally defining theory revision task provides sample computational complexity bounds process 
specifies number labeled queries necessary identify revised theory error close minimal high probability 
considers computational complexity finding best theory proves np polynomial time algorithm identify near optimal revision exact distribution queries certain simple situation 
shows simple situations polynomial time algorithm produce theory error close particular polynomial factor optimal 
sample complexity results suggest reasons theory revision effective learning scratch second computational complexity results explain aspects standard theory revision systems including practice hill climbing locally optimal theory set labeled queries 
keywords theory revision computational learning theory inductive logic programming agnostic learning extends short article appeared proceedings fourteenth international joint conference artificial intelligence ijcai montreal august 
done worked siemens corporate research princeton nj 
gratefully acknowledge receiving helpful comments dalal george adam grove tom hancock sheila mcilraith roni khardon dan roth especially thorough comments anonymous referees 
complexity theory revision fielded knowledge systems ranging expert systems logic programs production systems database management systems 
system uses database general task related information theory produce answer query correspond retrieving information database providing diagnosis repair appropriate set symptoms 
unfortunately responses may incorrect underlying theory includes erroneous information 
observe answers incorrect patient get better proposed repair correct device faults ask human expert supply correct answer 
set correctly answered queries produce new theory accurate fewer mistakes queries drawn distribution 
standard learning algorithms queries learn theory 
wasteful common situation initial theory accurate learning algorithms effect re learn initial theory 
efficient correct initial theory 
theory revision process correctly answered queries modify initial theory produce new accurate theory 
theory revision algorithms set transformations hill climb successive theories reaching theory empirical error locally optimal set correctly answered queries cf pol mb coh om wp cs 
report addresses obvious questions approach theory revision idea particular effectively learning scratch 
correctly answered training queries required 
possible efficiently compute globally optimal revised theory 
section states theory revision objective precisely finding theory lowest expected error space theories formed applying sequence transformations initial theory transform involves adding deleting rule antecedent 
sections address challenges finding best revised theory 
error theory depends distribution queries addressed theory best distribution may best 
need know information distribution decide theory optimal 
information usually known priori relevant information estimated sampling 
section considers sample complexity values ffl ffi samples query answer pair required find theory error ffl optimum specified space theories probability gamma ffi 
argue theory revision process require fewer samples required learn theory scratch compare relative difficulties deleting arbitrary portions theory versus adding new parts new antecedents new rules 
second issue finding optimal near optimal revised theory computational complexity task samples 
section observes finding theory easy theory syntactically close complexity theory revision initial theory appears case practice 
prove general task computing optimal theory obvious spaces theories intractable simple contexts dealing propositional horn theories considering atomic queries considering bounded number transformations results hold situations perfect horn theory horn theory correctly labels instances agnostic setting kss need theory 
show agnostic task approximated efficient algorithm find theory error close particular small polynomial optimum 
prove negative results apply generalizing specializing initial theory 
providing efficient algorithms restricted variants theory revision provide sharp boundaries describe exactly task guaranteed tractable 
results provide insights theory revision process sample complexity results argue theory revision better tabula rasa learning theory revision require fewer samples 
computational complexity results show theory revision performed efficiently initial theory syntactically close highly accurate theory tractable algorithm able find globally optimal theory syntactically far away initial theory 
results may help motivate standard practice hill climbing local optimum space formed specified transformations usually find acceptable theory intractable find optimal 
negative results may inspire researchers developers look techniques modify existing theories changing underlying representation kks kr exploiting information may available assumption true training example includes information required classify instance 
appendix supplies relevant proofs 
close section describing related research 
related results underlying task producing theory correct possible main objective research inductive learning including notable instances cart qui connectionist learning algorithms hin 
systems learn descriptions bit vectors simple hierarchies deals logical descriptions 
history dating back plotkin plo shapiro sha including contemporary foil qui body inductive logic programming ilp mug 
projects empty theory attempt learn target logic program adding new clauses theory revision processes modifying initial theory involve adding deleting clauses attempting approximate general target function need correspond logical theory 
see comparison section assume np gj implies np hard problem intractable 
implies certain approximation claims 
complexity theory revision implemented theory revision systems 
essentially set transformations described wp mb om delta consider adding deleting antecedents rules 
analysis results easily applied types modifications specializing generalizing antecedents om rules bm merging rules removing chains rules produced incorrect results coh coh 
projects provide empirical evidence effectiveness specific algorithms deal classification determining element tuple member target class general derivation formally addresses complexities inherent finding best theory handling arbitrary queries 
related complexity results cohen coh observed challenge computing smallest modification intractable particular context relates corollary 
second wilkins ma wm show intractability determining best set rules delete context weighted rules believed particular function weights supporting rules exceeds threshold 
results show problem remains intractable fact propositional case rules unit weight single rule sufficient establish 
third ling lv lv considered computational complexity modifying theory 
analysis dealt different type modifications viz adjusting various numeric weights network altering certainty factors associated rules changing structure adding deleting rules 
fourth mooney moo addressed sample complexity certain types theory revision systems 
analysis assumes completely correct theory reached sequence transformations sample complexity bounds extend considering various specified sets possible transformations requiring perfect theory transformations starting theory 
fact analysis require existence perfect theory 
consider computational complexity processes 
number results complexity pac learning logic programs scratch inductive logic programming ilp cf coh coh coh dmr 
mentioned framework different ilp systems return horn theory just theories syntactically close initial theory ilp systems assume horn theory perfect 
frameworks new observations improve description world 
example bayesian systems observations update representations adjusting continuous parameters dirichlet distribution belief net structure hec 
making discrete changes structure horn theory 
similarly belief revision systems agm dal gar km take input claims concerning applicability techniques systems kbann tow completely different means modifying theory 
companion gre considers ways modifying theory viz rearranging order component rules antecedents 
complexity theory revision initial theory new assertion hq resp new retraction hr gammai return new consistent theory entails resp entail close dal 
general resulting revised theory depend syntactic structure initial theory theory obtained revising assertion hq equivalent theory obtained revising hq belief revision formalisms single labeled query assertion retraction modify initial theory seeking theory semantically close correctly entail query 
contrast theory revision uses set labeled queries modifying searching space theories syntactically close theory optimal accuracy respect queries 
notice theory revision system require revised theory correct specific labeled query may produce semantically different theories semantically equivalent initial theories may search different spaces theories 
final distinction results show theory revision task difficult initial final theories queries horn contrast belief revision frameworks deal arbitrary cnf formulae 
course standard belief revision tasks counterfactual problem complete higher levels polynomial time hierarchy 
notice theory revision seeks theory syntactically defined class theories produced applying certain syntactical modifications initial theory performance optimal semantically defined task entailing entailing certain queries 
research corpora similarly seek semantically best theory syntactically defined class 
may class member exhibits perfect performance task example horn theory may able correctly classify labeled queries 
want find optimal member class 
corresponds exactly tic learning model kearns schapire sellie kss shown task intractable 
framework differs dealing different class samples arbitrary queries bit vectors having different class hypotheses predicate calculus horn theories propositional conjunctions 
significantly situations computational task just intractable 
second works approximations sk de gs structural identification dp seek theory specified syntactic form semantically close explicitly theory target entails essentially set propositions target entails 
representative results dechter pearl dp agnostically seek theory opt specified syntactic form horn horn strongest weakening extension target kautz kearns selman kks provide iterated revision bou gps fl dp considers single assertion usually deals sequence assertions new assertion incorporated arrives 
longer distinguished information current theory see fh 
consider assertions set seen elements need incorporated 
horn theory horn theory defined clauses contain literals 
ii theory opt strongest weakening theory target target opt theories syntactic form strictly target opt target opt implies complexity theory revision efficient randomized algorithm extension target agnostically produces horn theory usually strong weakening target high probability models include models original target small number 
results differ semantic task involves accommodating set positively negatively labeled queries loosely resembles conjunction horn disjunctions complete extension cnf dnf formula seek theory minimizes sided error set positively labeled queries necessarily entail revised theory consider horn theories specified space theories implicitly defined syntactic transformations applied theory 
space typically smaller space horn theories 
framework define horn theory conjunction propositional order horn clauses clause disjunction literals positive 
borrowing lev dp view theory function maps query proposed answer 
possibly infinite set horn queries set possible answers 
upsilon sigma xi pi upsilon sigma xi pi gamma gamma upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi gamma gamma upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi gamma gamma upsilon sigma xi pi 
theory differs excluding rule 
non atomic queries may unusual quite common 
example medical expert system typically collects relevant data individual patient determines specific disease disease disease expert system initial theory contains general information diseases notice entailment condition holds iff disease iff horn query disease follows initial theory 
queries clearly connect standard classification task machine learning complete assignment attributes determine class membership entailed 
opt 
iii extension dnf formula conjuncts complete assignment variables 
answer means theory find answer 
simplify presentation main body deal propositional logic section discusses extensions needed deal predicate calculus 
complexity theory revision necessary deal single complete assignment theory entails gamma instances positive instances hf hf model 
model allow different classes specifying positive instances specifying positive instances 
classes interrelated chaining see entailment queries fp kr 
assume single correct answer question represent target function real world oracle 
meaning hold 
consider classes target functions member corresponds horn theory member corresponds deterministic mapping queries answers 
class target function standard inductive logic programming literature guarantees horn theory capable correctly classifying training data realistic real world task finding best possible theory explain observed data real world data may fact noisy correspond situation perfect theory 
motivation gave rise study agnostic learning kss 
general goal find theory close target function delta possible 
quantify define error function err delta delta err error answer theory returned query err def notice err delta implicitly depends target function delta 
err provides correct answer err returns wrong answer 
err delta function measures error single query 
general theories deal range queries 
model stationary unknown probability function 
probability query posed 
distribution compute expected error theory err err theta err consider various sets possible theories ft contains set theories formed applying various sequences transformations initial theory see section 
challenge identify theory opt expected error minimal err opt err sections address challenges finding optimal theories complexity theory revision optimal theory depends distribution queries 
known initially relevant information estimated observing set samples query answer pair drawn distribution 
section quantifies number samples required obtain information needed identify high probability depends space theories searched provides sample complexity various spaces 
left challenge computing best theory samples 
section addresses computational complexity process showing task just intractable efficient algorithm find theory expected error close sense defined optimal value 
rest section describes transformations define various spaces theories discusses extensions needed handle stochastic oracles predicate calculus theories queries non categorical responses 
standard transformations standard theory revision algorithms modify initial theory applying sequence zero transformations 
consider classes transformations upsilon dr dr 
dr deletes existing rule upsilon ar ar 
ar adds new rule upsilon da da 
da deletes existing antecedent existing rule upsilon aa aa 
aa adds new antecedent existing rule upsilon upsilon dr upsilon ar upsilon da upsilon aa set transformations upsilon upsilon ae upsilon theories formed applying sequence theory theory transformations ae ffi ffi ffi upsilon initial theory 
table provides concise notation 
cost function upsilon 
maps transformation number symbols adds deletes form ae cost sequence transformations ae ffi ffi ffi propositional case aa da transformation adds deletes antecedent ar ae dr ae add rule resp delete rule transformation adds resp deletes rule ae gamma antecedent literals 
predicate calculus costs complicated depend number symbols affected literals 
na ive way evaluating err require computing 
require proving arbitrary theorem computation computationally intractable undecidable 
results show task finding optimal theory intractable polynomial time oracle performs arbitrary derivations course considering horn theories computations guaranteed polynomial time propositional case bch 
complexity theory revision theory set horn clauses language set transformations upsilon map theory set new theories upsilon upsilon ar ar ar adds new clause theory upsilon dr dr dr deletes existing clauses theory upsilon aa aa aa adds new antecedent existing rule upsilon da da da deletes existing antecedent existing rule sequences transformations upsilon gammaa gammar theories formed adding new antecedents existing rules adding new rules deleting existing antecedents existing rules deleting existing rules notes jtj may function size theory considered upsilon upsilon gammaa gammar upsilon upsilon gammaa gammar decision problem upsilon upsilon gammaa gammar maps theory set theories threv upsilon decision problem defined definition threv erf upsilon threv upsilon gen upsilon allows arbitrary threv rop upsilon threv upsilon propositional theories gen threv pc upsilon allows predicate calculus threv atom upsilon threv atom upsilon atomic queries gen upsilon allows horn queries gen upsilon allows arbitrary disjunctive queries optimization problem upsilon maps theory set theories minthrev ae upsilon minimization problem constraints ae ae perf prop atom see minthrev ae upsilon error score algorithm instance see equation table definitions notation complexity theory revision cost function define bounded sequences upsilon ae ffi ffi ffi upsilon ae members ae ffi ffi ffi upsilon sequences transformations total cost ae situations allow number transformations grow size theory abuse notation viewing function 
returns integer value function input size initial theory 
illustrate transformations consider theory equation 
dr gammae delete rule transformation remove rule reducing new theory clauses rules atomic literals called 
delete rule dr removes atomic clause 
da gammaf gammag delete antecedent transformation removes antecedent rule alternative delete antecedent transformation da gammaf gammaf removes rule 
course delete antecedent transformations modify rules 
add antecedent transformation aa gammae adds literal rule forming cost aa gammae 
second add antecedent transformation aa gammae add literal rule forming aa gammag adds literal form add rule transformations add new clauses ar gammaf adds leading element theory cost ar gammaf 
different add rule ar adds atomic clause 
cost expected transformation sequence sequence transformations applying element sequence ae ar gammac ffi aa gammae ffi da gammac gammac total cost ae ar gammac aa gammae da gammac gammac transform ae ar gammac aa gammae da gammac gammac theory clauses differs including clause including clause including extra clause upsilon sigma xi pi upsilon sigma xi pi gamma gamma upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi xxxx upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi upsilon sigma xi pi gamma gamma upsilon sigma xi pi course transformation sequence modify clause affected earlier transformation sequence ae dr gammaf ffi ar gammaf op ae provided albeit cost dr gammaf ffi ar gammaf 
dealing pure version logic programs seeking answers query order antecedents matter 
similarly order rules irrelevant model 
companion gre considers alternative models orders matter 
complexity theory revision consider various spaces transformations form upsilon gammaa gammar ae ffi ffi ffi fi fi fi fi fi fi fi fi fi upsilon upsilon aa upsilon ar upsilon da upsilon dr integer bound sum costs transformations type upsilon abbreviate superscripts omitting term form replacing simply upsilon gammaa gammar written upsilon gammaa gammar values functions size theory 
extensions theorems hold stochastic real world oracle encoded theta 
correct answer query probability 
allows model situation particular set observations different repairs appropriate different times happen example correct repair depends unobserved variables observations see ks 
notice err gamma deterministic oracle special case single handle predicate calculus expressions may consider answers form expression delta binding list free variables corresponds single answer query 
example theory pc tall john 
short fred 
rich john 
rich fred 
eligible tall rich 
query short return pc short fred query rich return pair answers pc rich john fred pc eligible john delta delta may return set answers query define accuracy score gamma err ratio number correct answers answers err gamma jo jo 
indicate instantiation satisfied particular value instantiation important 
corresponds existential question 
results hold considering nonrecursive theories computational results hold datalog function free theories 
related extension allow theories return stands non categorical answer don know err 
obvious ways extending analysis allow comprehensive error function prolog conventions capitalize variable 
complexity theory revision err delta apply different rewards penalties different queries permit different penalties incorrectly identifying location salt shaker versus location tiger 
extensions lead strictly general situations underlying task identifying optimal theory remains difficult remains computationally intractable general 
sample complexity mentioned theory revision process seeks revision initial theory allowed set revisions minimum possible expected error distribution queries 
distribution unknown set labeled samples ig implicitly obtain empirical error theories written err jsj hq err select theory empirical error smallest err err 
theory error training samples may error entire distribution queries know opt err err opt opt defined equation 
basically know err close err err opt close err opt 
statistical methods quantify confidence closeness estimates function number samples jsj size space possible theories jt theorem provides upper bound number samples required gamma ffi confident true error empirically optimal theory ffl truly best theory opt theorem vap theorem class theories ffl ffi theory smallest empirical error upper ffl ffi ffl ln jt ffi labeled queries drawn independently stationary distribution 
probability gamma ffi expected error ffl optimal theory err err opt ffl gamma ffi opt equation 
notice means polynomial number samples sufficient identify ffl theory probability gamma ffi ln jt polynomial relevant parameters 
course bound depend jlj number symbols note fewer samples required reliably determine theory space theories error ffl quantity say see vap theorem 
complexity theory revision language theories 
considering new symbols set fixed 
boundedness property true upsilon observation ln upsilon theta ln jlj ln jt set symbols language theories 
observation gives insights theory revision may useful 
ilp tabula rasa learning system starts approximation target theory may require great samples collect information required identify optimal theory opt propositional case omega gamma labeled queries required reliably build clause theory scratch see theorem 
theory revision system exploit initial theory situations syntactically close optimal opt theory error nearly optimal sense opt upsilon small particular jt opt number samples required transform opt required learn opt scratch 
way look small number samples usually sufficient identify best theory small set theories 
theory revision framework set corresponds theories syntactically close initial theory practice tends fairly accurate 
syntactically similar theories tend similar accuracies space may include accurate theories optimal theory 
contrast ilp system biased find best small theory prefers theories syntactically close empty theory 
unfortunately best theory may accurate 
close section describing alternative spaces transformations providing lower bounds required number samples 
comments provide theoretical justification intuition takes evidence justify adding new part theory required delete existing part 
note theory revision systems including cs incorporate bias 
alternative spaces set upsilon gammaa gammar strictly extends upsilon including transformation sequences delete unrestricted number symbols add symbols 
observe ln upsilon gammaa gammar polynomial jlj jtj meaning potentially learned polynomial number samples 
contrast consider upsilon gammaa gammar transformation sequences delete bounded number symbols add unrestricted number 
non trivial includes constant function relation symbol upsilon gammaa gammar ln upsilon gammaa gammar infinite 
see fg empty theory observe upsilon gammaa gammar oe upsilon includes subsets countably infinite 
comment provides stronger claim showing supply priori bound number samples required learn best theory upsilon set upsilon gammaa gammar upsilon 
course just heuristic hold 
complexity theory revision lower bounds obtain lower bound number samples required gamma ffi confident finding theory ffl optimal theorem sample complexity eh class theories values ffl ffi theory empirical error err samples drawn independently stationary distribution query class gamma ffi confident err ffl err ffl gamma ffi distribution product distribution sets samples drawn revision algorithm need lower ffl ffi max gamma ffl ffl log ffi gamma samples vapnik chervonenkis dimension set respect query set defined 
notice lower bound assumes theory error require samples find optimal theory 
largest number queries shatter subset largest number queries fq possible answer lists ha nog theory produces exactly answers include theory tn returns query tn tn returns final third tn returns gamma fourth 
th returns queries 
largest say infinite 
clearly set theories upsilon fg infinite vc dimension provided jlj non trivial shatter set queries size consider propositions gamma note upsilon fg includes theory contains entails exactly subset means possible answer lists ha nog upsilon fg includes theory perfect hr hr hr hr gamma produce set theories exponentially large vc dimension simply adding new antecedents observation class theories ft jt theory set upsilon formed applying add antecedent transformations readers wishing learn vapnik chervonenkis dimension referred hau 
complexity theory revision exponential upsilon holds queries atomic correspond simple instantiations relation horn theory labels set perfectly 
contrast observations upsilon gammar jt ln jt see upsilon gammar jtj 
similarly upsilon gammaa jt holds immediately implies upsilon gammaa jtj types transformations gammar upper upsilon ffl ffi ffl jtj ln ffi shows sample size worst linear size initial theory 
earlier worst case results upsilon upsilon cases require predicate calculus rely function symbols 
context propositional logic system variables gamma gamma easily get upsilon fg queries sigma sigma sigma gamma observe theory upsilon fg size corresponds possible deterministic oracles oracle maps subset queries rest 
see oracles leads distinct theory note corresponds distinct boolean formula holds iff disjunction rules respective antecedents holds corresponds arbitrary dnf formula identifying gamma formulae 
allowed ask atomic queries queries pose number variables possible responses meaning vcdim set propositional theories considering atomic queries 
computational complexity basic challenge identify theory opt set revisions smallest possible error 
previous section supplied number samples needed guarantee high probability expected error theory empirical error smallest ffl expected error opt section discusses computational challenge determining samples 
show task tractable simple situations considering atomic queries posed propositional theory allowed arbitrarily large number modifications initial theory produce perfect theory returns correct answer query 
task intractable remove essentially restrictions seek optimal seeking perfect propositional theories allowed pose horn queries consider predicate calculus theories 
fact np hard theta theta theta theory revision situations shown left side 
see particular revising theory bounded number modifications difficult theta theta situations considering atomic queries seeking perfect propositional theory 
implies task determining smallest number modifications required find perfect complexity theory revision bounded unbounded arbitrary upsilon gammaa gammar generalization upsilon gammaa specialization upsilon gammar np hard ffl np hard ffl np hard ffl gamma gamma gamma gamma psi perf opt prop atom horn disj ffi ffi ffl ffi ffl ffl gamma gamma gamma gamma psi perf opt prop atom horn disj ffi ffl ffl ffi ffl gamma gamma gamma gamma psi perf opt prop atom horn disj ffi ffl ffl ffl ffl legend ffi easy solve ffl np hard bounded unbounded arbitrary upsilon upsilon gammaa gammar generalization upsilon gammaa upsilon upsilon gammaa specialization upsilon gammar upsilon gammar upsilon task projects np hard task axis np hard 
means cross terms np hard 
example horn perf upsilon np hard projection prop theta perf opt plane atom perf upsilon np hard 
horn opt upsilon case shown explicitly projections easy figures omit cross terms 
tractability theory revision tasks theory intractable 
show tasks just intractable worse simple situations 
consider restricted subtasks allow transformation specialize respectively generalize initial theory 
show tasks intractable non essentially situations conditions hold 
figures summarize various cases 
tractable case generalization situation see 
note hardness restricted situations say generalizing theory follow hardness earlier general case consider generalization specializing theory agnostic case 
complexity theory revision basic complexity results formally state problem upsilon delta function maps theory set candidate revised theories refers upsilon kar dr da transformation set 
definition threv upsilon decision problem instance gamma initial theory gamma labeled training sample hq containing set horn queries correct answers gamma error value 
question theory upsilon err jsj hq err simplify notation henceforth write err err 
consider special cases ffl threv erf upsilon requires seeking perfect theories optimal theories upsilon ffl threv rop upsilon deals propositional logic predicate calculus threv upsilon ffl threv atom upsilon deals atomic queries opposed horn queries upsilon 
upsilon refer task queries arbitrary disjunctions need horn 
subscripts restrictions threv upsilon disj case permissive 
combine subscripts obvious meanings general write threv upsilon fprop horn 
default threv horn opt upsilon 
threv upsilon special case threv upsilon finding threv upsilon hard non immediately implies threv upsilon hard 
similarly seeing threv upsilon easy immediately implies special case threv upsilon easy 
final note hardness results hold consider horn theories rules antecedents contain literals 
easy find optimal theory certain degenerate cases individual queries decoupled atomic propositional queries actions forced seeking perfect propositional theories just throw away original theory add propositions corresponding labeled queries 
case task intractable theorem threv rop atom opt upsilon threv rop horn erf upsilon decision problems threv rop atom erf upsilon easy problem particular threv rop horn opt upsilon complexity theory revision threv atom erf upsilon threv rop disj erf upsilon generalizations np hard 
information summarized lower left unbounded arbitrary graph 
negative results parts requires training data produced oracle supplies deterministic mapping queries answers guarantee implied target theory necessarily consistent 
theorems explicitly state results hold knows oracle theorem describes complexity computing best theory allowed arbitrarily expensive sequence transformations 
permits theory revision system throw away entire initial theory generate arbitrary new theory 
cases may want consider short sequences transformations consider members upsilon small constant upsilon contains polynomial number theories means efficiently simply enumerate test theories 
associated decision problem easy observation constant threv rop atom erf upsilon decision problem solved polynomial time 
small assumption implicit theory revision systems 
notice particular renders theory revision solvable means need see small number samples see observation perform simple computation 
non constant values task intractable theorem omega gamma jt threv rop atom erf upsilon decision problem np hard 
true consider labeled queries produced oracle know horn theory correctly labels queries 
observation determining step perfect theories np hard leads immediately corollary np hard compute minimal cost transformation sequence required produce perfect theory compute smallest perfect upsilon err perfect propositional case considering atomic queries labeled queries produced oracle 
np hard compute minimal length transformation length transformation sequence ffi ffi ffi simply transformation unit cost 
obvious minimization problem corresponding theorem decision problem 
negative result shows intractability obvious proposal transversal space possible theory revisions test initial theory labeled queries return error 
consider theories complexity theory revision bounded unbounded arbitrary upsilon generalization specialization ffl ffl ffl atom horn disj ffi ffl ffl ffl atom horn disj ffl ffl ffl ffl atom horn disj ffl ffl ffl ffl ffl ffl ffi easy poly time decision class known theory revision tasks formed applying single unit cost transformation return perfect upsilon consider theories upsilon formed applying sequences transformations cost return perfect upsilon forth 
notice may involve successively samples iteration la lmr 
decision problems correspond immediately optimization problems example decision problem graph hn ei positive integer node labeled colors way edge connects nodes color see gj chromatic number corresponds minimization problem find minimal coloring graph similarly view threv upsilon decision problem minimization problem find upsilon error minimal maximization problem find upsilon accuracy maximal theory accuracy gamma err 
maximally accurate theory minimal error formulations lead different results 
notation minthrev upsilon resp upsilon refer minimization resp maximization problem 
consider algorithm minthrev upsilon instance ht initial theory labeled training sample computes syntactically legal necessarily optimal revision upsilon 
performance ratio instance defined minthrev upsilon err err opt err opt opt opt minthrev upsilon optimal solution instance opt ht si theory opt upsilon minimal error complexity theory revision say function delta bounds performance ratio minthrev upsilon iff instances minthrev upsilon minthrev upsilon jxj jxj size instance ht define number symbols plus number symbols intuitively delta function indicates closely algorithm comes returning best answer worst case minthrev upsilon instances poly minthrev upsilon collection polytime algorithms return legal necessarily optimal answers minthrev upsilon instances 
natural ask algorithm poly minthrev upsilon best performance ratio indicate close come optimal solution feasible computational time 
example function constant minthrev rop upsilon polynomial time algorithm produce optimal solution minthrev rop upsilon instance threv rop upsilon np complete mean np expect obtain result 
bound constant efficiently obtain solution factor optimal may applications 
problems approximated 
cp kan define definition minimization problem minp fl fl poly minp minp minp fl jxj fl lund yannakakis ly prove np minimization problem fl polynomial time algorithm find solution jxj fl optimal 
result prove theorem np minthrev rop disj upsilon minthrev horn upsilon minthrev rop atom upsilon 
results may immediate np hard determine perfect theory exists notice equation minthrev upsilon delta essentially ignores perfect theories 
note result holds context inconsistent oracle situations theory perfect 
jxj get arbitrary large result means minthrev upsilon tasks approximated constant logarithmic factor sufficiently small polynomial theorem proves upsilon np hard problem clearly np 
constants np hard minimization problems 
example polynomial time algorithm computes solution cost factor triangle inequality problem see gj theorem 
complexity theory revision special cases theory general returns may want consider specializing applying delete rule add antecedent transformations 
particular recall upsilon gammar set theories obtained arbitrary number transformations upsilon gammar resp upsilon set theories obtained applying arbitrary number delete rule respectively add antecedent transformations 
similarly theory specific returns may want consider generalizing applying add rule delete antecedent transformations consider upsilon gammaa upsilon upsilon gammaa set theories obtained applying arbitrary number transformations 
transformations tasks remain intractable theorem upsilon gammar upsilon gammar upsilon upsilon gammar upsilon gammar upsilon upsilon gammaa upsilon upsilon gammaa upsilon gammaa upsilon upsilon gammaa 
easy solve threv rop atom erf threv rop horn erf 
np hard threv rop atom opt threv rop horn erf threv atom erf threv rop atom erf 
np hard threv rop atom opt threv rop disj erf threv atom erf threv rop atom erf 
indicate problem hard target function constrained worse theorem np 
minthrev atom minthrev rop horn upsilon gammar upsilon gammar upsilon 
minthrev atom minthrev rop disj upsilon gammaa upsilon upsilon gammaa 
minthrev rop atom upsilon upsilon upsilon gammar upsilon gammar upsilon upsilon gammaa upsilon upsilon gammaa cases straight forward polynomial time algorithm produce theory accuracy inaccuracy factor optimal 
ratio algorithm accuracy optimal value upsilon opt theorem upsilon upsilon gammar upsilon gammar upsilon upsilon gammaa upsilon upsilon gammaa poly upsilon upsilon complexity theory revision companion gre considers related cases including special cases context underlying theories delta operator return specified goal proven negation failure cla 
considers effect re ordering rules antecedents context affect answers returned 
cases show corresponding maximization problem particular polynomial 
comments asymmetry interesting asymmetry complexities addressing threv rop horn erf upsilon versus threv rop horn erf upsilon gammar easy compute second intractable 
explaining notice actions add rule revision system rev forced encountering positively labeled query hae yesi simply add ae initial theory entail ae encountering negatively labeled query hae noi add clearly perfect theory upsilon iff resulting theory perfect 
actions delete rule revision system rev gammar obvious pair labeled queries hae yesi hae noi rev gammar happens deleted rev gammar select 
shown proof theorem np hard find appropriate labeled queries 
notice contrast sample complexity deleting rules easily bounded sample complexity adding rules predicate calculus case bound 
suggests opposite adding rules harder 
need positive non horn queries proofs non atomic queries queries positive form hae yesi 
theorems deal minthrev horn delta continue hold horn queries restricted labeled positively 
proofs require atomic queries labeled positively atomic queries labeled negatively 
relation inductive logic programming ilp proofs involve adding new clauses initially empty theory see theorems notice target function delta approximated necessarily correspond horn theory delta results deal situation differs standard ilp task 
fact tasks easy consider target functions correspond horn theories 
frazier pitt fp prove learning perfect horn theory horn queries corresponds threv rop horn erf upsilon target oracle hard learning arbitrary cnfs examples pac framework open problem computational learning theory community 
final comment theme tempting view theory revision simply ilp initial theory non empty 
lift ilp results complexity theory revision theory revision context simply dividing initial theory 
typical ilp results deal adding new facts rules 
theory revision systems consider removing parts theory deleting existing rules antecedents rules directly apply ilp results 
knowledge system produce incorrect answers queries underlying theory faulty 
theory revision system transforms theory related accurate possible set correctly answered training queries 
analyses task attempt obtain better understanding underlying process 
positive results especially observations show theory revision system effectively initial theory close theory low error upsilon small guarantees required number samples small considerably required learn effective theory scratch importantly naive exhaustive algorithm able identify theory efficiently 
notice condition true typical situation initial theory corresponds deployed system low error 
course revision process usually find better theory 
negative results show essentially situation theory revision guaranteed computationally feasible prove finding theory error close optimal done efficiently forced consider expensive revisions involve extensive modifications 
negative results hold consider obvious restricted sets possible modifications generalization transformations specification transformations 
view results partially explaining standard theory revision practices 
standard justification theory revision general intuition relatively small number samples sufficient transform nearly perfect theory better theory note intuition borne empirically 
sample complexity results prove general showing take fewer samples produce theory revising theory required learn scratch 
observation fewer samples required justify deleting parts theory adding new parts motivates theory revision algorithms focus task cs 
examined computational challenge producing theories saw intractable syntactically far initial theory priori know close theory minimal error seeking globally optimal theory problematic 
sense accept locally optimal revised theory turn standard theory revision practice hill climbing 
noted hope results help push researchers developers consider approaches revising sub optimal theory finding useful special cases employing alternative approaches possibly stochastic kbann tow changing representations exploiting types information complexity theory revision labeled queries prior knowledge 
proofs theorem vap theorem class theories ffl ffi theory smallest empirical error upper ffl ffi ffl ln jt ffi labeled queries drawn independently stationary distribution 
probability gamma ffi expected error ffl optimal theory err err opt gamma ffl gamma ffi 
proof queries generated stationary distribution view values independent identically distributed random values common population mean err 
err sample mean upper ffl ffi samples hoeffding chernoff bounds che bol bound confidence err close err gamma err gamma value means gamma err ffl ffi jt holds implies probability gamma err ffl holds gamma err ffl jt ffi jt particular means empirical accuracy opt theories mentioned ffl respective expected accuracy probability gamma ffi 
probability gamma ffi err gamma err opt err gamma err err gamma err opt err opt gamma err opt ffl ffl ffl desired 
theorem observation ln upsilon theta ln jlj ln jt set symbols language theories 
proof get quick upper bound jlj possible symbols add possible symbols scattered existing jt symbols leading new theories 
theories remove symbols symbols leads total upsilon theta logarithm 
observation complexity theory revision observation class theories ft jt theory set upsilon formed applying add antecedent transformations exponential upsilon holds queries atomic correspond simple instantiations relation horn theory labels set perfectly 
proof theory true true index 
index rest index rest 
index rest index rest 
size 
notice index relation basically uses argument index dimensional second argument succeeds indexed value second argument 
query index subgoal index index index succeeds 
index reach subgoal index fail 
consider possible literals form ae index hri formed storing hri locations note aa ae upsilon aa add literal true rule forming true index hri 
notice requires hri exponentially large 
upsilon space includes theories return subset queries meaning upsilon observation theorem threv rop atom opt upsilon threv rop horn erf upsilon decision problems threv rop atom erf upsilon easy problem particular threv rop horn opt upsilon threv atom erf upsilon threv rop disj erf upsilon generalizations np hard 
proof obvious algorithm threv rop atom opt upsilon threv rop horn erf upsilon takes ht pi argument removes initial theory adds labeled queries stochastic case adds includes instances yesi noi returns iff resulting new theory sufficiently accurate 
show threv rop horn opt upsilon np hard reducing np complete decision problem definition decision problem gj graph hn ei nodes fn edges ae theta positive integer independent set size subset ae jsj hs complexity theory revision graph hn ei specified size independent set tg fg empty theory sg jn theta jej theta jn theta jn queries sg hn yesi ask jn queries time hb yesi hn mi ask jej queries jn times hb noi ask query jn times observe independent set size iff theory opt upsilon tg formed adding new rules tg fg error je gammak jn jej suppose independent set size call independent set fn ae theory obtained adding tg fg corresponding atomic clauses jej rules hn mi correct jn copies jej different hb yesi queries 
independent contains hn mi pair means contain fn mg pair means entail literal 
correct jn copies hb noi query 
entails literals jej rules error je gammak jn jej desired 
suppose add set clauses tg form theory error je gammak jn jej notice obvious clauses add form adding clause increase error 
assume includes jej clauses error strictly fn set added 
includes literals corresponding rule entail prevents error assume includes fn mg pair means corresponds independent set 
err set contain elements desired 
show threv atom erf upsilon np hard reducing canonical np complete problem definition sat decision problem gj set fu variables formula fc conjunction clauses clause disjunction positive negative literals satisfying truth assignment 
sat formula fg empty theory 
define query answer pairs clause sgn sgn sgn sgn sgn 
example fu variables 
tg empty reason consider type transformation 
proof considers adding atomic clauses literals trivial consider variant adds non degenerate clauses replacing literal rule true assuming initial theory tg includes literal true complexity theory revision sat formula fc delta delta delta hv fx hv noi assume require language theory include constant symbols function symbols relation symbol show theory opt upsilon fg error err opt iff satisfying assignment 

assignment satisfies upsilon fg theory formed adding fg unit clause 
hu hu hu ig fv observe immediately entails instance satisfies query match literals consider fu satisfies satisfy means means match 
produce correct answers queries error 
suppose form perfect theory opt adding clauses fg 
satisfy query opt include instance 
literal 
need show mapping satisfying assignment 
recall constant symbols means range appropriate 
second contradiction assume satisfy clause say fu means 
means literal opt match literal means opt perfect contradiction 
remove restriction language language includes constant symbols say fs sm just include theta additional labeled queries form hv gamma noi 
similarly deal function symbols say ff including theta additional labeled queries form hv gamma ym noi 
course arity 
sat show threv rop disj erf upsilon np hard initial theory empty fg yesi hb yesi hb noi explain notation query corresponding fu correct answer query 
show theory opt upsilon fg error err opt iff satisfying assignment 

assignment satisfies upsilon fg theory complexity theory revision formed adding fg unit clause rules see err observe answers queries correctly 
secondly includes exactly fu pair answer query 
satisfying assignment means includes ij corresponding element means 
suppose form perfect theory opt adding set rules fg 
opt entail rule 
opt entails fu return wrong answer query 
assume opt entails pair fu assume opt includes literals clause opt return incorrect answer query 
define assignment 
iff opt observe immediately satisfies 
theorem theorem omega gamma jt threv rop atom erf upsilon decision problem np hard 
true consider labeled queries produced oracle 
proof reduce sat definition problem sat formula fc delta delta delta variables fu clause theory query answer pairs hb noi hc yesi omega gamma jt 
need show theory opt upsilon error err opt iff satisfying assignment 
proof differs proof theorem fact copies query eliminate degenerate solutions modify rules transformations simply delete rules avoid effect rules simply adding new antecedent 
assume rule appear final opt means opt opt contain similar counting argument simply add new atomic clauses opt way insure opt opt includes literal corresponds element ji 
show labeled queries function notice satisfied theory contains exactly theta singleton clauses theorem complexity theory revision theorem np minthrev rop disj upsilon minthrev horn upsilon minthrev rop atom upsilon 
proof proofs result definition minimization problem gj find minimal colorable graph hn ei colorable function 
kg hn 
theorem ly np ffi polynomial time algorithm find coloring arbitrary graphs hn ei factor jn ffi optimal 

reduction show minthrev rop disj upsilon graph hn ei tg fg empty theory sg jn jn jej theta jn jn query answer pairs requiring jn jn jej theta jn jn symbols hc cn cn jnj noi jn hc cn cn jn yesi ask query jn times cn cm yesi hn mi jn ask query jn times noi ask query jn times understand connection propositions problem think cn meaning node colored color coloring 

set queries seeks minimize number distinct colors range second set queries attempts insure complete satisfied node color third fourth sets attempt insure legal coloring satisfied pair nodes connected edge color 
show theory upsilon tg error err iff solution problem colors 
legal coloring function 
range values form new tc theory adding tg singleton literal cn clause viol cn cm hn mi jn notice satisfy final sets queries fail satisfy exactly set err tc suppose theory tc upsilon tg error err tc observe tc violate final sets queries produce error jn assume entails second simplify presentation assume jn complexity theory revision set queries means entails cn define 
min entails viol cn cm rule entail viol entail cn cm hn mi means defines legal coloring 
error due violations set queries function colors 
suppose ffi poly time algorithm ffi theory labeled query set ht si ffi ht si returns theory ffi upsilon error factor jxj ffi error optimal opt upsilon err ffi err opt jxj ffi algorithms find approximately optimal solutions problem problem hn ei jn transformation form xg sg optimal solution minimal number colors corresponds optimal solution xg call opt error err opt ffi algorithm produce theory ffi performance ratio err ffi err opt ffi ffi sg ij ffi jn ffi jn ffi recall js jn jn jej theta jn jn jn symbols jn 
notice corresponds feasible solution ffi colors meaning produced solution performance ratio jn ffi polynomial time 
ffi arbitrary contradicts theorem assuming np 
prove minthrev horn upsilon graph hn ei tg fg sg hc noi jn ask jn queries time hc yesi ask jn queries jn times yesi ask single query jn times noi hn mi ask jej queries jn times means node colored color essentially arguments show theory tc upsilon tg error err tc iff solution problem colors show correspondence sufficient show minthrev horn upsilon np 
show minthrev rop atom upsilon identify graph hn ei tg color cn jn viol cn cm hn mi jn jn colored cn jn jn complexity theory revision sg jn jn jn jn jn query answer pairs color noi jn noi jn ask jn queries jn times yesi jn ask jn theta jn queries jn times tg jn trick multiple copies literals avoid degenerate solutions see proof theorem 
show theory upsilon tg error err iff solution problem colors legal coloring function 
range values form new theory adding single literal cn notice satisfy final sets queries fail satisfy exactly set err suppose theory upsilon tg error err upsilon transformations modify rules notice upsilon tg include viol cn rules hn mi 
tc included fcn cm arc hn mi answer corresponding viol query incorrectly producing error jn strictly exceeds assumed error assume includes fcn cm pair 
similar argument include cn colored query answered incorrectly force err jn quota jn symbols just number needed add exactly fc node required satisfy colored queries 
define coloring 
letting fc tc single tc includes literal cn observe feasible solution node color arc connects nodes color 
notice satisfies final sets queries meaning inaccurate set exactly color noi labeled queries meaning associated coloring requires exactly colors 
rest proof isomorphic final piece part shown 
theorem theorem upsilon gammar upsilon gammar upsilon upsilon gammar upsilon gammar upsilon upsilon gammaa upsilon upsilon gammaa upsilon gammaa upsilon upsilon gammaa complexity theory revision 
easy solve threv rop atom erf threv rop horn erf 
np hard threv rop atom opt threv rop horn erf threv atom erf threv rop atom erf 
np hard threv rop atom opt threv rop disj erf threv atom erf threv rop atom erf 
indicate problem hard target function constrained proof deal threv rop atom erf upsilon gammar threv rop atom erf upsilon gammar labeled query noi dr gamma transformation delete rule head matches check resulting theory perfect 
handle threv rop atom erf upsilon labeled query noi note include rule form 
rule add new unsatisfied literal false cases performing appropriate transformations return iff resulting theory perfect 
deal threv rop horn erf upsilon threv rop horn erf upsilon gammaa positively labeled query hoe yesi oe transformation add possibly new clause oe return iff resulting theory perfect 
similar approach handle threv rop horn erf upsilon gammaa 
reduce np complete problem threv rop atom opt upsilon gammar definition decision problem gj set elements fx collection fc subsets integer subset size intersects subset set ae jsj fg arbitrary instance hx ki tdr sdr hx noi ask jx queries time hc yesi ask jcj queries jx time observe hitting set size iff theory upsilon gammar tdr formed deleting clause tdr error jx theta jcj suppose hx ci hitting set size call set fx ae gamma fx complement set upsilon gammar tdr theory complexity theory revision obtained deleting corresponding literals jxj theory correspond elements hitting set contain able derive able derive literals expected error jx theta jcj 
suppose delete set rules tdr form theory upsilon gammar tdr error deleting rule detrimental consider deleting atomic clauses fx set removed leaving set observe corresponds hitting set ae size hitting set unable derive prevent obtaining needed accuracy 
second elements error proof threv rop atom opt upsilon gammar identical shown observation adding antecedents rule detrimental adding antecedents clause effect deleting 
second observation handle threv rop atom opt upsilon gammaa simply repeat proof just substituting operation adding false antecedent atomic clause forming false deleting clause 
notice operations effect preventing entailed 
sat definition show threv rop horn erf upsilon gammar np hard 
cnf formula hc yesi hb yesi hb noi notice deleting rule detrimental queries deleting rule hurt corresponding non atomic queries 
way form perfect perf upsilon gammar deleting subset atomic clauses 
just re arguments prove theorem remove fu pair satisfy set queries suggesting assignment 
iff perf observe satisfies satisfies clause perf 
show threv rop horn erf upsilon gammar threv rop horn erf upsilon nphard just observe adding antecedents non atomic clauses counterproductive adding unsatisfied false effect deleting atomic clause 
complexity theory revision handle threv atom erf upsilon gammar 






hb noi hc yesi hb yesi identify resp literal resp values prevent rules deleted deleting rules prevent remaining theory answering final set queries correctly 
consider deleting atomic clauses leads basic proof shown 
situations consider dealing threv atom erf upsilon gammar threv atom erf upsilon depending underlying languages includes equality 
proof holds threv atom erf upsilon gammar advantage adding antecedent 
deal threv atom erf upsilon replaying proof replacing operation deleting atomic clause operation adding unsatisfied antecedent form false 
situation slightly trickier allow equality 
perfect theory upsilon formed simply adding rule forming 
get problem differs including new set literals includes additional hb yesi query answer pairs 
simple trick adding antecedents sufficient forces revision system changes shown 
show threv rop atom erf upsilon gammar np hard hb noi hc yesi spend delete rule transformations delete symbols clauses meaning afford leave fu final theory proof reduces solution shown 
similar proofs deal threv rop atom erf upsilon threv rop atom erf upsilon gammar 
show threv rop atom opt upsilon np hard reduce np complete complexity theory revision decision problem definition 
graph hn ei nodes edges specified size independent set tg hn mi sg hn yesi ask jn queries time hb noi ask query jn times observe independent set size iff theory opt upsilon tg formed adding new rules tg error jn gammak jn suppose independent set size call independent set fn ae theory obtained adding tg corresponding atomic clauses independent contains hn mi pair means contain fn mg pair means entail literal 
entails jn literals error jn gamma 
suppose add set clauses tg form theory error notice obvious clauses add form adding clause hurt 
fn set added 
includes literals corresponding rule entail prevent error assume includes pair fn mg means corresponds independent set 
err set contain elements desired 
proof threv rop atom opt upsilon deals transformations add clauses isomorphic proof holds threv rop atom opt upsilon gammaa observation deleting antecedents detrimental 
virtually isomorphic proof deal threv rop atom opt upsilon gammaa theory tg hn mi false notice false tg sg shown 
simply repeat proof just substituting operation deleting false literal false clause adding literal 
notice immediately operations effect causing entailed 
notice deleting antecedent particular rule detrimental 
proof threv rop disj erf upsilon proof theorem 
similar proofs apply threv rop disj erf upsilon gammaa threv rop disj erf upsilon gammaa 
proofs identical proof theorem 
show threv rop atom erf upsilon np hard complexity theory revision hb noi hc yesi spend add rule transformations add symbols atomic clauses query meaning add atomic clause associated clause 
proof reduces solution shown 
similar proofs deal threv rop atom erf upsilon gammaa threv rop atom erf upsilon gammaa 
theorem theorem np 
minthrev atom minthrev rop horn upsilon gammar upsilon gammar upsilon 
minthrev atom minthrev rop disj upsilon gammaa upsilon upsilon gammaa 
minthrev rop atom upsilon upsilon upsilon gammar upsilon gammar upsilon upsilon gammaa upsilon upsilon gammaa proof proofs modification theorem reduction definition 
graph hn ei tdr tdr cn jn cn jn viol cn hn mi jn color cn jn sdr jn jn jn jej theta jn jn query answer pairs color noi jn yesi ask queries jn times noi ask query jn times cn yesi hn mi jn ask queries jn times color cn yesi jn ask queries jn times theorem show theory upsilon gammar tdr error err tc iff solution problem colors 
proof involves observing viol err jn exceeds allowed similarly include viol cn rule error jn due fourth set queries 
similar argument prevents tc excluding color cn rules 
removing colored cn rule detrimental assume tc formed deleting atomic cn clauses literal remains rest proof isomorphic theorem 
arguments show adding antecedents non atomic clause problematic leading proof involves simply adding unsatisfied false antecedents various complexity theory revision cn clauses shows minthrev rop horn upsilon gammar minthrev rop horn upsilon 
deal minthrev atom upsilon gammar theory tdr cn 
cn 
jn cn 
jn viol cn cm 
hn mi jn color cn 
jn labeled queries dr color noi jn yesi ask queries jn times noi ask query jn times yesi ask query jn times color yesi jn ask queries jn times role yesi color yesi queries prevent deleting viol cn cm color cn rules 
re proofs show approximate minthrev atom upsilon gammar minthrev atom upsilon gammar minthrev atom upsilon 
deal minthrev atom upsilon tar sar hc jn ask queries jn times noi hn ask queries jn times hc noi jn coloring 
cg uses colors form theory upsilon tar adding atomic clauses vice versa 
re address minthrev atom upsilon gammaa minthrev atom upsilon gammaa 
propositional variant proof handle minthrev rop disj upsilon ar fg ar hc delta delta delta jn noi jn hc delta delta delta jn yesi jn ask queries jn times noi hn ask queries jn times yesi hn jn ask queries jn times coloring 
cg uses colors form complexity theory revision ory upsilon tar adding atomic clauses jej theta jn viol clauses vice versa re proof deal minthrev rop disj upsilon gammaa minthrev rop disj upsilon gammaa 
proof minthrev rop atom upsilon identical proof theorem 
proofs minthrev rop atom upsilon gammaa minthrev rop atom upsilon gammaa similar 
handle minthrev rop atom upsilon gammar initial theory fcn jn includes jn cn literals jn gamma jn plausible solution involves deleting jn cn literals leaving proofs minthrev rop atom upsilon minthrev rop atom upsilon gammar similar 
theorem theorem upsilon upsilon gammar upsilon gammar upsilon upsilon gammaa upsilon upsilon gammaa poly upsilon upsilon proof consider situation upsilon gammar upsilon upsilon gammar theta grid partitions set queries probably encountering query class 
predicate calculus case require binding lists match 
set contains queries delta 
accuracy initial nn optimal possible accuracy opt opt ht si nn ny weaker entail fewer weaker remove propositions equivalently add new unsatisfied literal new antecedent clause resulting degenerate oe fg accuracy score ny nn longer able derive desired 
delta best possible polynomial time algorithm algorithm ht si produce revised ht si best score polynomial time algorithms 
notice trivially nn ny nn nn ny delta simply leave delete clauses 
opt nn nn ny ny claimed 
situation upsilon upsilon gammaa upsilon gammaa just observation adding new rule deleting existing antecedent cause previously am indebted tom hancock construction 
complexity theory revision queries derivable derived remain derivable 
need reverse roles columns 
theorem agm carlos alchourr peter gardenfors david makinson 
logic theory change partial meet contraction revision functions 
journal symbolic logic 
bch hammer 
polynomial time inference valid implications horn related formulae 
annals mathematics artificial intelligence 
alex borgida david etherington 
hierarchical knowledge bases efficient disjunctive reasoning 
proceedings kr pages toronto may 
blumer ehrenfeucht david haussler manfred warmuth 
learnability vapnik chervonenkis dimension 
journal association computing machinery october 
breiman friedman olshen stone 
classification regression trees 
wadsworth brooks monterey ca 
bm paul raymond mooney 
symbolic revision theories rules 
proceedings ijcai august 
bol bollob 
random graphs 
academic press 
bou boutilier 
revision sequences nested conditionals 
proceedings ijcai pages 
che herman chernoff 
measure asymptotic efficiency tests hypothesis sums observations 
annals mathematical statistics 
cla clark 
negation failure 
gallaire minker editors logic data bases pages 
plenum press new york 
coh william cohen 
learning textbook knowledge case study 
proceeding aaai 
coh william cohen 
abductive explanation learning solution multiple inconsistent explanation problems 
machine learning march 
coh william cohen 
pac learning recursive logic programs efficient algorithms 
journal artificial intelligence research 
complexity theory revision coh william cohen 
pac learning recursive logic programs negative results 
journal artificial intelligence research 
coh william cohen 
pac learning non recursive prolog clauses 
artificial intelligence 
cp crescenzi 
completeness approximation classes 
information computation 
cs susan craw derek sleeman 
automating refinement knowledge systems 
aiello editor proceedings ecai 
pitman 
dal dalal 
investigations theory knowledge base revision preliminary report 
proceedings aaai pages 
de dalal david etherington 
tractable approximate deduction limited vocabulary 
proceedings ninth canadian conference artificial intelligence vancouver may 
dmr dzeroski muggleton russell 
pac learnability determinate logic programs 
proceedings fifth workshop computational learning theory pittsburgh 
dp jon doyle ramesh patil 
theses knowledge representation language restrictions taxonomic classification utility representation services 
artificial intelligence 
dp rina dechter judea pearl 
structure identification relational data 
artificial intelligence 
dp darwiche pearl 
logic iterated belief revision 
tark pages 
eiter gottlob 
complexity propositional knowledge base updates counterfactuals 
artificial intelligence 
eh ehrenfeucht david haussler 
general lower bound number examples needed learning 
inform 
comput september 
fh friedman halpern 
belief revision critique 
kr 
fl freund lehmann 
belief revision rational inference 
technical report tr hebrew university 
fp michael frazier leonard pitt 
learning entailment application propositional horn sentences 
proceedings pages 
morgan kaufmann 
complexity theory revision gar peter gardenfors 
knowledge flux modeling dynamics epistemic states 
bradford book mit press cambridge ma 
russell greiner adam grove alex kogan 
knowing doesn matter exploiting omission irrelevant data 
artificial intelligence december 
www cs ualberta ca greiner papers superfluous journal ps 
gj michael garey david johnson 
computers intractability guide theory np completeness 
freeman new york 
gps papadimitriou 
incremental recompilation knowledge 
proceedings aaai pages 
gre russell greiner 
complexity revising logic programs 
journal logic programming appear 
www cs ualberta ca greiner papers impure ps 
gs russell greiner dale schuurmans 
learning useful horn approximations 
nebel rich swartout editors proceedings kr san mateo ca october 
morgan kaufmann 
www cs ualberta ca greiner papers horn ps 
hau david haussler 
quantifying inductive bias ai learning algorithms valiant learning framework 
artificial intelligence pages 
hec david heckerman 
tutorial learning bayesian networks 
technical report msr tr microsoft research 
hin geoff hinton 
connectionist learning procedures 
artificial intelligence september 
frederick hayes roth neil 
knowledge engineering systems 
communication acm pages march 
kan kann 
approximability np complete optimization problems 
phd thesis royal institute technology stockholm 
kks henry kautz michael kearns bart selman 
reasoning characteristic models 
aaai pages 
kks henry kautz michael kearns bart selman 
horn approximations empirical data 
artificial intelligence 
km katsuno alberto mendelzon 
difference updating knowledge base revising 
proceedings kr pages boston april 
complexity theory revision kr roni khardon dan roth 
learning reason 
aaai pages 
kr roni khardon dan roth 
reasoning models 
aaai pages 
ks michael kearns robert shapire 
efficient distribution free learning probabilistic concepts 
proceedings st symposium foundation computer science october 
kss kearns schapire sellie 
efficient agnostic leaning 
proceedings colt pages 
acm press 
pat langley george bharat rao russell greiner 
theory revision fault hierarchies 
proceedings fifth international workshop principles diagnosis dx new paltz ny 
www cs ualberta ca greiner papers th rev ps 
lev hector levesque 
foundations functional approach knowledge representation 
artificial intelligence 
lmr nathan linial mansour ronald rivest 
results learnability vapnik chervonenkis dimension 
proceedings colt 
lv charles ling marco 
results computational complexity refining certainty factors 
international journal approximate reasoning 
lv charles ling marco 
refinement uncertain rule bases reduction 
international journal approximate reasoning 
ly carsten lund yannakakis 
hardness approximating minimization problems 
proceeding fifth annual acm symposium theory computation stoc pages 
mb muggleton buntine 
machine invention order predicates inverting resolution 
proceedings pages 
morgan kaufmann 
moo raymond mooney 
preliminary pac analysis theory revision 
petsche hanson editors third annual workshop computational learning theory natural learning systems 
mit press 
mug muggleton 
inductive logic programming 
academic press 
om dirk ourston raymond mooney 
theory refinement combining analytical empirical methods 
artificial intelligence 
complexity theory revision plo plotkin 
automatic methods inductive inference 
phd thesis university edinburgh 
pol 
empirical analysis expert systems 
pitman research notes artificial intelligence 
qui ross quinlan 
learning logical definitions relations 
machine learning journal august 
qui ross quinlan 
programs machine learning 
morgan kaufmann publishers san mateo 
beeri krishnamurthy 
optimizing existential datalog queries 
proc 
th symposium principles database systems pages austin tx march 
sha ehud shapiro 
algorithmic program debugging 
mit press 
sk bart selman henry kautz 
knowledge compilation horn approximations 
proceedings aaai pages anaheim august 
tow geoff towell 
symbolic knowledge neural networks insertion refinement extraction 
phd thesis university wisconsin madison 
vap vapnik 
estimation dependencies empirical data 
springerverlag new york 
wm david wilkins yong ma 
refinement probabilistic rule sets interactions 
artificial intelligence 
wp james michael pazzani 
methodology evaluating theory revision systems results ii 
proceedings ijcai pages 
