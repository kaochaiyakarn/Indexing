observable sharing functional circuit description koen claessen david sands chalmers pure functional programming languages proposed vehicle describe simulate manipulate circuit specifications 
propose extension haskell solve standard problem manipulating data types representing circuits lazy functional language 
problem circuits finite graphs viewing algebraic lazy datatype indistinguishable potentially infinite regular trees 
implementations haskell represent cyclic structures graphs 
problem sharing nodes creates cycles observable function traverses structure 
propose extension call need languages graph sharing observable 
extension non updatable cells equality test sharing detection type 
show simple practical extension behaved semantic properties means typical source program transformations performed compiler valid presence extension 
investigate particular problem embedding hardware description language lazy functional language case haskell 
embedded language approach domain specific languages typically involves designing set combinators higher order reusable programs application area constructing individual applications combining coordinating individual combinators 
see hud examples domain specific languages embedded haskell 
case hardware design objects constructed descriptions circuits providing different interpretations objects example simulate test model check compile circuits lower level description 
application embedded description languages motivate extension haskell feature call observable sharing allows detect manipulate cycles datastructures particularly useful feature describing circuits containing feedback 
observable sharing added language providing immutable cells equality test 
part problem motivate addition observable sharing 
department computing sciences chalmers university technology goteborg university sweden 
www cs chalmers se problem observable sharing conservative extension pure functional language 
side effect albeit limited form semantic implications immediately apparent 
means addition feature risks loss desirable semantic features host language 
donnell considered form observable sharing lisp style pointer equality eq precisely context manipulation hardware descriptions dismissed idea equality hack breaks referential transparency destroying advantages functional language place 
destroyed construct 
second part show constrained version pointer equality practice lost 
formally define semantics language extensions investigate semantic implications 
semantics extension call need machine faithfully reflects amount sharing typical haskell implementations 
laws pure functional programming sound extension 
classic law beta reduction lazy functional programs represent fx mg hold theory 
law duplicate arbitrary amount computation duplication sub expression proposed law appropriate language haskell afm restrictive laws adopted 
haskell compilers haskell programmers apply arbitrary transformations efficiency reasons careful change amount sharing internal graph structure programs 
haskell call need parameter passing mechanism argument function call evaluated 
develop theory operational equivalence language demonstrate extended language rich equational theory containing example laws ariola call need lambda calculus afm 
functional hardware description deal description synchronous hardware circuits behaviour circuit components modelled functions streams inputs streams outputs 
description realised embedded language pure functional language haskell 
motivations literature able higher order functions polymorphism laziness describe hardware clm 
describing circuits approach modelling circuits functions streams taken early days fp systems hydra hawk clm 
functional circuit description owes description 
examples primitive circuit components modelled functions 
assume existence datatype signal represents input output internal wire circuit 
inv signal 
signal signal 
signal 
signal latch signal 
signal xor signal 
signal 
signal put components normal way compose functions abstraction application local naming 
examples circuits 
consists just gate xor gate component 
halfadd xor fulladd halfadd halfadd xor local naming results subcomponents expression 
types terms halfadd signal 
signal 
signal signal fulladd signal 
signal 
signal 
signal signal third example circuit 
consists inverter latch put loop called feedback 
result circuit toggles output 
toggle signal toggle output inv latch output output note express loop naming wire recursively 
simulating circuits interpreting type signal streams bits primitive components functions streams run simulate circuit descriptions concrete input 
possible instantiation model streams haskell lazy lists 
type signal bool possibly infinite inv bs map bs bs zipwith bs latch bs false bs xor bs zipwith bs simulate circuit applying inputs 
result evaluating fulladd false true true true true true false true true true result toggle true false true false true parameters provide lists streams inputs result get stream outputs 
note toggle circuit take parameter results infinite stream outputs 
ability specify execute perform operations hardware functional program claimed strength approach 
generating simulating circuit 
want implement example fpga prove properties need generate netlist circuit 
description components circuit connected 
reach goal symbolic evaluation 
means supply variables inputs circuit concrete values construct expression representing circuit 
order reinterpret signal type operations 
try lines 
signal variable name wire result component supplied input signals 
type signal var string comp string signal inv comp inv comp latch comp latch xor comp xor example symbolically evaluate halfadd var var comp xor var var comp var var similarly full adder 
happens try evaluate toggle 
comp inv comp latch comp inv comp latch 
signal datatype essentially tree toggle circuit contains cycle result infinite structure 
course usable symbolic description implementation 
get infinite data structure representing finite circuit 
encounter similar problem provide inputs circuit output wires circuit 
signal type tree means result twice copied 
shows trees inappropriate modelling circuits physically circuits richer graph structure 
previous solutions possible solution proposed donnell give component unique tag explicitly 
signal datatype tree traverse tree keep track tags encountered avoid cycles detect sharing 
order change signal datatype slightly adding tag component example follows 
data signal var string comp tag string signal define circuit explicitly label component unique tag 
donnell introduces syntactic sugar making easier programmer 
real solution problem generating executable circuit specifications 
functional language awkward 
particular weakness abstraction enforce components tag identical programmer mistakenly introducing tag different components 
explicit tagging desired solution underlying machinery guarantee tags unique 
monads standard approach problems see wad 
functional programming monad data structure underlying computation model 
common monad state monad threads changing piece state computation 
state monad generate fresh tags signal datatype 
monadic approach taken lava 
introducing monad implies types primitive components circuit descriptions monadic result type monadic 
big disadvantage approach change types syntax 
longer normal function abstraction local naming recursion anymore express monadic operators 
turns inconvenient programmer 
looking solution require change natural circuit description style local naming recursion allows detect sharing loops description language 
proposed solution core problem description circuit basically graph observe sharing nodes program 
solution propose graph structure program observable adding new language construct 
objects identity idea want weakest extension powerful observe objects previously created object 
reason wanting weak extension possible want retain semantic properties original language possible 
just benefit programmer important compilers semantic properties programs perform program transformations want write compiler implement extension 
know advance kind objects compare way choose explicit creation time object comparing 
fact view objects non updatable 
create compare equality dereference 
interface provide 
introduce type ref operators type ref ref 
ref 
ref 
ref 
bool deref ref 
examples show new constructs detect sharing undefined ref 
ii undefined ref 
ref create compare yields true 
ii create different variable comparison yields false 
non conservative extension language previously possible distinguish shared expression different instances expression 
call extension observable sharing 
give formal description semantics section 
back circuits extension help symbolically evaluate circuits 
take look circuits 
circ output latch output output circ output latch latch output output haskell denotational semantics circuits identified circ just recursive unfolding circ 
descriptions represent different circuits circ latch loop circ latches loop 
signal type includes compare identities latch components conclude circ latches identical circ different latches 
modify signal datatype way creation identities happens transparently programmer 
data signal var string comp ref string signal comp name args comp ref name args inv comp inv comp latch comp latch xor comp xor way circuit toggle creates cyclic structure possible define function observes terminates generating netlist circuit 
possible solutions briefly discuss solutions known extensions functional programming languages 
pointer equality language extended operator 


bool investigates expressions pointer equal refer bindings 
extension basically provide pointer equality controlled way perform expressions type 
means implement certain kind pointer equality 
way possible shows extension weaker 
gensym language extended new type sym symbols equality operator generates fresh symbols gensym 
possible define gensym terms refs way 
approach get important law definition 
rue deref deref semantic theory section formally define operational semantics observable sharing study induced notion operational equivalence 
technical development de sugared core language untyped lambda calculus recursive lets structured data 
language terms ref grammar mg ref deref omega note restricted syntax arguments function applications arguments constructors variables pjs lau ses 
trivial translate programs syntax bindings non variable arguments 
set values val ref ranged write mg shorthand fx xn mng distinct order bindings syntactically significant considered bound lets potentially recursive 
kind substitution consider variable variable oe ranging substitutions 
simultaneous substitution vector variables written assumed distinct need 
machine semantics standard part language section essentially sestoft mark machine laziness ses 
ms believe machine semantics suited basis studying operational equivalence 
transitions machine defined configurations consisting heap containing set bindings ii expression currently evaluated full version include constructors case expression strict sequential composition operator 
iii stack representing actions performed result current expression 
number possible ways represent machine 
straightforward possibility global environment evaluation ref operation creates fresh argument 
equivalent syntactically economical version 
environment represented new constructor constructor part ref denote ref ref def ref varg val ref def val varg 
write gamma machine configuration heap gamma expression ref stack heap set bindings variables terms ref denote empty heap addition group bindings heap gamma juxtaposition gamma mg 
stack list stack elements 
stack written denote stack pushed top 
empty stack denoted ffl concatenation stacks st top 
stack elements variable representing argument function update marker indicating result current computation bound variable heap pending equality test form omega ref omega dereference deref indicating produced current computation dereferenced 
refer set variables bound gamma dom gamma set variables marked update stack doms 
update markers thought binding occurrences variables 
binding occurrence variable configuration deemed formed dom gamma doms disjoint 
write dom gamma union 
configuration gamma closed free variables gamma contained dom gamma 
sets variables write mean disjoint 
free variables term denoted fv vector terms write fv 
machine semantics implicitly restrict definition formed configurations 
collection rules standard 
second collection rules concern observable sharing 
rule forces evaluation left argument ref switches evaluation right argument evaluated ref constructors variable equality implement pointer equality test 
convergence approximation equivalence terms considered equal exhibit behaviours program context 
behaviour test equiv gamma fx mg gamma lookup gamma gamma fx update gamma gamma unwind gamma gamma subst gamma mg gamma mg dom gamma letrec gamma ref gamma fx mg ref dom gamma ref gamma deref gamma deref deref gamma ref deref gamma deref gamma omega gamma omega gamma ref omega gamma ref omega ref gamma ref ref omega gamma true false ref fig 

machine semantics simply termination 
termination behaviour formalised convergence predicate definition convergence closed configuration gamma converges written gamma exists heap delta value gamma delta ffl write identifying closed initial configuration ffl closed configurations converge types reduce indefinitely get stuck ii type error iii case expression incomplete set alternatives iv black hole self dependent expression 
non converging closed configurations semantically identified 
range contexts terms containing zero occurrences hole delta place arbitrary subterm occur 
denote result filling holes term possibly causing free variables bound 
definition operational approximation say operationally approximates written closed implies say operationally equivalent written note equivalence non trivial equivalence relation 
sample basic laws equivalence 
statement laws follow standard convention bound variables statement law distinct disjoint free variables 
fx fx fx fx fx mg fx mg fv omega omega fact constructor ref available directly language crucial variable inlining properties 
example derivable law fx zg fail terms contain ref failure disastrous implementations effect configuration level analogy law applied garbage collectors 
proof techniques equivalence collection laws approximation equivalence established 
definition operational equivalence suffers standard problem prove terms related requires examine behaviour contexts 
reason common seek prove context lemma mil operational semantics tries show prove operationally approximates need compare immediate behaviour 
context lemma simplifies proof laws lemma context lemma 
terms gamma substitutions oe gamma oe implies gamma oe says need consider configuration contexts form gamma delta hole delta appears 
substitution oe variables variables necessary laws typically closed substitutions noticeable proof burden 
proof context lemma follows lines corresponding proof improvement theory call need ms involves uniform computation arguments similar proofs related properties call value languages state mt 
full key technical properties proof compiler optimisation performed called strictness analysis sound presence observable sharing 
relation calculi similar languages considered odersky ode call name semantics pitts stark ps call value semantics 
approach call need introduced afm extended deal mutable state ariola sabry 
reduction calculi approach general pioneered felleisen fh advantage builds idea core calculus equivalences generated confluent rewriting relation terms language extension conservative extension core theory 
price paid modularity theory equality limited 
approach taken studying operational equivalence exemplified mason talcott call value lambda calculi state mt 
advantage operational equivalence approach richer theory induction principles may derived inexpressible reduction calculi 
starting point call need improvement theory introduced moran sands ms 
improvement theory definition operational equivalences includes observation number reduction steps convergence 
sharing observable slightly indirectly 
scratched surface existing theory 
induction principles useful straightforward adapt ms 
techniques specific subtleties parametricity properties local names pit relevant 
motivated small extension haskell provides practical solution common problem manipulating data structures representing circuits 
precise operational semantics extension investigated laws operational approximation 
shown extended language rich equational theory means semantics robust respect program transformations respect sharing properties 
extension propose small turns easy add existing haskell compilers interpreters form data type module hidden data constructors 
fact similar functionality hidden away nonstandard libraries implementations 
simple implementation hugs ghc library extensions full version 
feature useful embedded description languages briefly consider applications full writing parsers left recursive grammars optimised representation decision trees 
www haskell org implementations afm ariola felleisen odersky wadler 
call lambda calculus 
proc 
popl acm press 
ariola sabry 
correctness monadic state imperative call need calculus 
proc 
popl pages 
acm press 
claessen sheeran singh 
lava hardware design haskell 
icfp 
acm press 
clm cook launchbury matthews 
specifying superscalar microprocessors hawk 
formal techniques hardware hardware systems 
sweden 
fh matthias felleisen robert hieb 
revised report syntactic theories sequential control state 
tcs 
hud paul hudak 
building domain specific embedded languages 
acm computing surveys december 
lau launchbury 
natural semantics lazy evaluation 
proc 
popl pages 
acm press 
mil milner 
fully models typed calculus 
tcs 
ms andrew moran david sands 
improvement lazy context operational theory call need 
proc 
popl acm press 
mt mason talcott 
equivalence functional languages effects 
journal functional programming july 
donnell 
generating executable circuit specifications pure functional language 
functional programming glasgow springerverlag workshops computing pages 
donnell 
transistors computer architecture teaching functional circuit specification hydra 
functional programming education lncs vol pages 
springer verlag 
ode martin odersky 
functional theory local names 
popl pages acm press 
pit pitts 
reasoning local variables operationally logical relations 
th annual symposium logic computer science pages 
ieee computer society press 
peyton jones partain santos 
floating moving bindings give faster programs 
proc 
icfp pages 
acm press 
pjs peyton jones santos 
transformation optimiser haskell 
science computer programming 
ps pitts stark 
observable properties higher order functions create local names new 
mfcs lncs vol pages springer verlag 
ses sestoft 
deriving lazy machine 
journal functional programming may 
sheeran 
designing regular array architectures higher order functions 
lncs vol springer verlag 
wad wadler 
monads functional programming 
lecture notes marktoberdorf summer school program design calculi nato asi series computer systems sciences 
springer verlag august 
