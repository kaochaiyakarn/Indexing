including group query optimization surajit chaudhuri kyuseok shim hewlett packard laboratories palo alto ca chaudhuri hpl hp com shim cs umd edu existing relational database systems processing group computation aggregate functions postponed joins performed 
transformations possible push group operation past joins potentially reduce cost processing query significantly 
placement group decided cost estimation 
explain traditional system style optimizers modified incorporating greedy conservative heuristic developed 
prove applications greedy conservative heuristic produce plans better worse plans generated traditional optimizer 
experimental study shows extent improvement quality plans significant modest increase optimization cost 
technique applies optimization select distinct queries pushing duplicate elimination cost fashion 
decision support systems sql operation group aggregate functions extensively formulating queries 
example queries create summary data great importance data warehouse applications 
queries partition data done author visiting hewlett packard laboratories 
author current address division research statistics federal reserve board washington 
permission copy fee part material granted provided copies distributed direct commercial advantage vldb copyright notice title publication date appear notice copying permission large data base endowment 
copy republish requires fee special permission endowment 
proceedings th vldb conference santiago chile groups business sectors aggregate attributes sum total sales 
study customer queries db tm surveys group construct occurs large fraction sql queries decision support applications 
efficient processing optimization queries group aggregation significant importance 
unfortunately problem far received little attention 
single block sql query group operator traditionally executed joins processed 
phase execution aggregate queries consequence fact optimizers concentrate selection projection join operators 
conventional relational optimizers exploit knowledge group clause query including grouping columns list interesting orders join enumeration discussed section 
significant new techniques processing optimization queries group 
motivating application examples taken data warehouse application analyzes trends order placement 
simplified presentation ease exposition 
set business divisions 
division belongs sector 
product belongs division 
product fixed processing overhead order 
order placed dealer 
order name product amount date sale registered 
dealer state street address recorded 
relations attributes schema division product overhead order amount date dealer state address transformations key observation group reduces cardinality relation early evaluation group result potential saving costs subsequent joins 
example illustrates transformation observation 
appropriate application transformation result plans superior plans produced conventional optimizers order magnitude 
example consider query computes total sales sector 
traditionally query computed join division product order subsequently doing group computing sum amount 
alternative plan possible 
group order relation attribute joining relation product 
words compute total sales product join 
product large number orders step may lead significant reduction size relation cost subsequent join product 
group resulting relation 
intuitively computes total sales achieved division 
join resulting relation division residual group 
example single group traditional execution tree replaced multiple groupby operators equivalent execution plan grouping done stages interleaved join 
transformations 
simpler case transformation group operator query moved past joins broken stages 
cases execution plan contains group multiple alternatives execution plan may placed 
furthermore maintaining count tuples coalesced group push group transformations apply 
discuss generalized transformations 
optimization transformations push group operator past joins judiciously applied depending query database 
example shows transformations blindly 
example consider example 
assume product large number orders division markets products 
statistics ordering joins traditional plan left right division product order 
alternative execution plan suggested example attractive database early group operations result significant reduction cardinality relations 
join ordering alternative plan different traditional plan 
order relation group joins product 
subsequently resulting relation possibly group joined division 
shows decision push group operations influences join order 
early application group operator optimal 
orders product division markets products alternative plan perform worse traditional plan 
optimizer needs identify correctly place group operator evaluated early 
example shows decision push group operator past joins cost transformations affect ordering joins applications need considered conjunction task choosing join order 
optimization queries group treated isolation imperative incorporate techniques framework conventional optimizers 
system style optimization algorithm commercial systems prototypical conventional optimizer 
integration optimization ideas conventional optimizer raises issues 
effect size execution space 
extend search algorithm account trade cost optimization improvement quality plans 
note duplicate elimination viewed special case group aggregates computed group columns projection list 
recognized pushing duplicate elimination past join result saving cost processing select distinct queries select project join expressions 
pushing group decision push duplicate elimination interacts ordering joins 
optimization algorithm group applies problem placing duplicate elimination operators execution plans select distinct queries may explicit group clauses 
related yl yan larson identified transformation enables pushing group past joins 
approach deriving queries group clause sql query 
result query obtained joining queries formed 
approach query unique alternate placement group operator 
observe transformation reduces space choices join ordering ordering considered query 
transformations vastly generalize proposal avoids problem reduced search space join ordering 
example alternative execution suggested example obtained transformations yl 
prior group addressed problem pipelining group aggregation join kl group flatten nested sql queries 
problems orthogonal problem optimizing queries containing group addressing 
outline section discusses preliminary concepts assumptions 
section define proposed transformations 
section devoted optimization algorithm 
section discuss experimental results implementation optimizer 
results section demonstrate incorporating transformations traditional cost optimizer practical results significant improvement quality plan produced 
preliminaries notation query follow operational semantics associated sql queries dd iso 
assume query single block sql query 
select 
agg bn 
cond cond 
group col clause query conjunction simple predicates 
sql semantics require 
col 
notation agg represent built sql aggregate functions 
discussing cases having order clause query 
assume nulls database 
extensions addressed cs 
refer columns fb aggregating columns query 
columns called grouping columns query 
functions fagg called aggregating functions query 
purposes assume aggregate function forms sum max min 
excluded avg count cases aggregate functions apply columns qualifier distinct 
section discuss extensions techniques 
extended annotated join trees execution plan query specifies choice access methods relation ordering joins query 
traditionally execution plan represented syntactically annotated join tree root group operation leaf node scan operation 
internal node represents join operation 
annotations join node include choice join method selection conditions list projection attributes 
assume selection conditions evaluated projections applied early possible 
optimization problem choose plan cost execution space 
optimization efficiency execution space restricted class left deep join trees 
annotated join trees right child internal node leaf 
transformations propose introduce group operators internal nodes 
define extended annotated join trees annotated join trees group may occur internal node 
likewise define extended left deep join trees 
trees subject restrictions traditional left deep join trees 
example tree denotes left deep join tree trees extended left deep join trees group occurs internal node trees 
note mark scan nodes name relation 
group operator assume group operator extended join tree specified annotations grouping columns aggregating columns 
meaning annotations analogous corresponding properties query see section 
reality need somewhat elaborate annotations including aggregating functions details germane discussion 
consider question determining annotations group node place immediately join scan node definition join columns node columns participate join predicates evalu ated ancestor nodes required columns node join columns grouping columns query 
definition candidate aggregating columns node columns aggregating columns query required columns node 
observe columns node needed subsequent processing required columns candidate aggregating columns 
words columns retained projection applied node definition important subtlety 
excludes aggregating columns participate join predicates occur required columns 
columns aggregated node retained join predicates evaluated 
annotations group node placed join scan node defined set grouping columns set required columns 
set aggregating columns set candidate aggregating columns node specification group node may placed immediately unique 
note annotations columns correctly aggregated immediately node aggregated group example consider tree 
required columns scan node order 
candidate aggregating column scan node order amount 
tree shows extended execution tree group node specifications placed order 
consider variant query tree added selection condition order amount product overhead 
case column amount order required columns aggregated tree join product completed 
implementations group possible 
example group may implemented sorting data grouping columns group node 
implementation particularly useful order sql query conjunction group 
popular alternative hashing data stream hashed grouping columns operator 
subsequently data sorted bucket 
implementation ensures grouping ordering data 
scan group operations combined index structures 
detailed discussion appears cs 
duplicate elimination operator duplicate elimination operation may pushed node annotated join trees 
challenge decide applications duplicate elimination cost way 
consider select expressions form note require queries groupby clause 
select distinct 

cond observe duplicate elimination special case group operator aggregating columns columns 
grouping columns 
optimization techniques developed apply directly cost application duplicate elimination 
refer reader cs details 
transformation annotated trees say annotated join trees equivalent schema result sets answers database 
section transformations generate equivalent extended left deep tree left deep tree 
show transformations increasing generality 
transformation extended left deep tree obtained simply moving group operator root internal node 
second transformation single group left deep tree replaced multiple group operators extended left deep tree 
final transformation generalizes previous transformations maintaining count tuples groups coalesced 
invariant grouping intuition invariant grouping transformation identify nodes left deep tree obtain equivalent extended left deep tree left deep tree moving group operator just node call transformation invariant annotations group operator left deep tree modified transformation 
observe traditional left deep tree grouping columns aggregating columns group operator grouping columns aggregating columns query respectively 
section follows group operator placed immediately scan join node candidate aggregating columns required columns aggregating columns group compute sum amount join product compute sum amount join order dealer group join product join order dealer join order dealer join group compute sum amount product plan plan plan foreign key join invariant grouping transformation query grouping columns query respectively 
case tuples belong different groups early evaluation groupby belong different groups answer 
ensure equivalence left deep tree subsequent joins result answer tuples belong group need coalesced 
condition satisfied joins subsequent group columns foreign keys explained 
foreign key join tuple referenced relation contributes tuple answer 
joins subsequent group foreign keys group formed early group tuple group fails produce answer tuples tuple produces exactly answer tuple 
subsequent joins result multiple tuples belonging group answer relation extended annotated join tree equivalent left deep tree 
definition identifies nodes invariant grouping property 
definition node left deep tree invariant grouping property conditions true 
aggregating column query candidate aggregating column 
join column grouping column query 

join node ancestor join equijoin predicate foreign key column theorem node left deep tree invariant grouping property extended tree obtained moving group node parent equivalent definition follows node left deep tree invariant grouping property ancestors 
words nodes invariant grouping property form chain equivalent extended annotated join tree may obtained moving group operator nodes chain 
observation significant point view execution space optimizer 
note placing group nodes invariant grouping property computationally redundant 
example consider query computes dealer california product telecom division dollar value orders placed month 
tree left deep join tree query 
shown predicates 
intuitively join checks dealer california second join checks telecom 
observe node order tree required columns grouping columns query candidate aggregate column aggregating column query join predicates equi join foreign keys respectively 
order invariant grouping property ancestors 
theorem follows tree tree equivalent tree 
intuitively tree corresponds alternative execution plan product dealer sum orders computed 
joining grouped relation dealer product retain groups correspond dealers california products marketed telecom division respectively 
simple coalescing grouping simplicity invariant grouping transformation remarkable enables move groupby operator modification annotations operator 
applicability invariant grouping requires satisfying conditions definition 
simple coalescing grouping generalizes invariant grouping relaxing conditions 
invariant grouping simple coalescing grouping property useful performing early group compute sum amount join join order plan product group join compute sum amount group product order compute sum amount join group compute sum amount group product order compute sum amount join group plan plan division division join compute sum amount group division simple coalescing grouping may require additional group subsequently coalesces multiple groups 
consequence application simple coalescing multiple group operators may replace single group left deep tree yield equivalent extended left deep tree 
mentioned transformation help obtain execution plan superior plan produced traditional optimizer order magnitude 
considering possible effect early group node execution tree satisfy condition definition 
case tuple corresponding coalesced group may result tuples output relation agree grouping columns query 
example grouping column query grouping columns node final result groups agree value coalesced 
effect relaxing condition definition similar 
push group conditions definition true able subsequently coalesce groups agree grouping columns 
fortunately built sql aggregate functions agg sum considering see section aggregate bag tuples may computed aggregates computed partitions bag agg agg fagg agg arbitrary bags denotes union bags 
groups coalesced application group 
formally define property simple coalescing grouping node left deep tree 
definition left deep tree node simple coalescing grouping property aggregating columns query candidate aggregating columns node follows node simple coalescing grouping property ancestors left deep join tree 
theorem says placing group operators nodes chain nodes simple coalescing grouping property creates extended left deep tree equivalent left deep tree 
theorem node left deep tree simple coalescing grouping property extended left deep tree obtained adding group operator immediately ancestors equivalent theorem provides optimizer opportunities alternate placements group operators 
notice extended left deep tree contains group node left deep tree 
additional group nodes chain semantically redundant 
contrast invariant grouping multiple applications group operator chain nodes computationally redundant results stagewise grouping example illustrates 
example reconsider example grouping aggregation done stagewise fashion 
node order satisfy invariant grouping property column 
aggregating column query amount candidate aggregating column order satisfy simple coalescing grouping property 
theorem follows tree equivalent tree 
observe multiple applications group computationally redundant 
successive group operators compute sum orders product division sector respectively 
notice tree provides variant group node placed join product 
tree equivalent tree 
node invariant grouping property special case node simple coalescing grouping property 
recognize groupby operator introduced simple coalescing transformation placed node invariant grouping property know subsequent group nodes computationally redundant 
generalized coalescing grouping scope early grouping extended require aggregating columns query node early group operator placed 
example consider query computes product overhead expenses incurred product due orders month 
traditional plan obtained join order product 
subsequently result relation grouped aggregate sum overhead computed 
intuitively alternative plan count number orders product multiply number overhead obtain total overhead product 
groupby order relation grouping column join product 
total overhead sales computed join multiplying value overhead number order tuples coalesced single tuple application group order 
note order satisfy simple coalescing grouping property aggregating column query overhead columns order 
example represents significant family queries referencing relation order foreign key connects referenced relation aggregate attribute product 
refer queries foreign relation aggregate queries 
get informal understanding generalized coalescing assume traditional plan apply aggregate function agg function column obtaining result group relation join columns obtain relation join assume tuple joins tuple obtained coalescing tuples simplicity assume tuple joins 
case function agg needs applied bag consisting copies tuple denoted ns 
fortunately sql built functions result agg ns derived result agg fsg identities show min ns max ns avg ns sum ns count ns keeping count coalesced group identity result aggregation coalesced group derived 
formal account generalized coalescing property 
transformation applicable aggregate function agg query property function agg ns 
proposal supporting generalized coalescing requires extensions group join operations discussed 
ffl general group augmented groupby operator addition grouping ensures output stream special attribute group count carries size coalesced group data stream 
data stream group count attribute values column summed coalesced group 
ffl aggregate join traditional join handles join stream group count attribute identities aggregates listed 
example example illustrates generalized coalescing transformation 
second alternative plan group order precedes join product general group operator introduces group count field coalesced group 
certain product orders group count coalesced group tuples order 
join order product aggregate join applies identity sum value group count column relation performing general group order value overhead attribute 
theorem left deep tree node extended left deep tree obtained modifications equivalent ffl replace join node ancestor aggregate join 
ffl place general group nodes immediately parent ancestor nodes 
restriction general group operators placed chain central generalization theorem straight forward cs 
foreign key join comparison transformations respect theorem worth noting case functions aggregating columns appear ancestor node max min avg column group count necessary 
aggregate joins chain may degenerate traditional joins certain conditions true 
generalized coalescing useful optimizing queries group cs 
discussion transformations transformations increasing generality complexity 
applicability transformations indicated 
subtree marked denotes aggregating columns query occur subtree 
node marked represents application group 
tree represents left deep tree obtained traditional optimizer tree denotes tree chain nodes dotted circles invariant grouping property holds 
dotted circles indicate group operator may placed dotted nodes 
nodes tree simple coalescing property multiple group operators may appear chain 
tree shows generalized coalescing transformation group operator may placed aggregating columns query candidate aggregating columns 
note transformations context left deep trees transformations apply bushy annotated join trees obvious generalizations cs 
section said considering sql built functions max min sum 
transformations proposed apply aggregate functions generalized coalescing transformation handles avg count correctly group count 
consider earlier assumption require aggregates columns qualified sum amount 
restriction easily relaxed 
note invariant grouping transformation applicable aggregates quali default specification sql 
fied distinct 
simple generalized coalescing aggregates query distinct qualifiers consider distinct columns part grouping columns query point view transformations 
aggregates columns computed early grouping transformations remaining aggregates qualifier 
note invocation group operator redundant set required columns functionally determines rest columns 
case group singleton 
important case optimizer recognize order avoid generating redundant alternatives 
single block select distinct query group duplicate elimination operator may pushed join scan nodes applications computationally redundant 
model duplicate elimination simple coalescing transformation 
condition simple coalescing grouping property trivially satisfied queries nodes left deep tree aggregating columns 
optimization algorithm transformations section translate execution tree equivalent extended execution tree 
example shows decision apply transformation optimizer cost fashion 
choice interacts join ordering need consider modifications needed algorithm chooses optimal join order 
algorithm described section incorporates invariant grouping simple coalescing transformations extended left deep join trees 
extensions incorporate generalized coalescing described cs 
traditional approach aim optimizer produce execution plan cost execution space 
traditionally execution space limited left deep join trees see section correspond linear orderings joins 
known algorithm choose optimal linear ordering joins query uses dynamic programming 
query say viewed set relations say fr ng sequenced optimization yield join order 
optimization algorithm proceeds stagewise producing optimal plans subqueries stage 
ith stage optimizer produces optimal plans subqueries size subqueries consist join relations consider subquery size 
steps function enumerate followed find optimal plan 
function enumerate 
fr 
joinp lan lan 

lan mincost steps possible ways plan constructed extending optimal plan subquery size considered 
note remaining relation occurs function creates plan joining relation intermediate base relation 
access methods choice join algorithms considered 
step mincost compares plans constructed picks plan cost 
shown algorithm optimal respect execution space trees 
refer reader ghk details 
soundness enumeration algorithm relies cost model satisfying principle optimality clr 
violation principle optimality requires extensions 
violation occur presence appropriate order relations help reduce cost subsequent sort merge join sorting phase required 
example consider query fr predicates suboptimal plan fr sorted join column sort merge join method 
join column subsequent join ordering may lead optimal plan fr obtain optimal plan query optimal subquery 
order take account violation principle optimality due effect ordering cost notion interesting orders proposed 
order interesting grouping join columns query orders may useful join group operation 
interesting orders generated due choice join method sort merge existing physical access paths 
optimizer generates small number interesting orders 
cost comparison takes place plans interesting orders 
suboptimal plan interesting order may result optimal plan unique optimal plan generated interesting order retained 
plan interesting order cheaper plan interesting orders discarded 
execution space extended left deep trees order incorporate transformations involving group optimizer considers space extended left deep trees execution space group join may occur internal nodes 
unfortunately resulting execution space considerably larger traditional execution space left deep trees interesting orders reasons 
addition ordering joins optimizer decide placement group operators 
consequence plans extended left deep trees set relations may differ interesting order sequences groupby operators applied 
example plan product incomparable plan obtained join division relation obtained application group join order product 
set relations interesting order optimal plans need stored 
better understanding space alternative executions gained considering representation plans 
traditional case query longer viewed set relations linearly ordered 
simple coalescing transformations property group operators applied intervening join nodes resulting relation obtained applying simply group operator optimization extended left deep trees query subquery viewed list sets relations group operator applied join relations subsequently resulting relation joined relations set special case fg group applied joining relations space potential interesting orders larger compared traditional case groupby operators implemented sorting see section 
intuitively orders reduce cost include orders useful remaining join predicates grouping columns resulting relations cost plans may different 
query grouping columns possible major minor ordering possible group operators may follow subplan 
understand group operators implemented sorting applied intervening join operators preserve order created choice major minor ordering grouping columns sorting ensures stream sorted grouping columns cost evaluating simply coalescing evaluating aggregates sorting needed form groups 
space possible major minor orderings possible group operators potentially large 
factors cost simple minded enumeration extended left deep join trees prohibitive 
defer complete analysis effect factors size execution space full cs 
greedy conservative heuristic optimization technique propose greedy applies group yields better plan locally 
technique conservative point view time spends optimizing query 
greedy conservative heuristic places group preceding table scan join results cheaper plan scan join 
words modify step enumerate construct optimal plans cases plan cost interesting order chosen fr application group relation prior join 
fr application group operator prior join step enumerate application group simply join 
incidentally optimizer check plans semantically correct 
example simultaneously correct simple coalescing transformation 
observe greedy strategy significant payoff point view reducing optimization cost 
locally choosing group query viewed set relations unique plan interesting order 
different traditional case 
complete description optimization algorithm need specify major minor orderings grouping columns considered optimizer alternatives sort implementation group 
greedy conservative heuristic chosen generate single major minor ordering group operator 
ordering determined method join 
sort merge choose major minor ordering join node 

group outer relation join choose grouping columns query major sort columns 
consider join methods nested loop preserve ordering outer relation 
subsequent joins preserve order introduced sorting needed remainder query evaluation 
true choice major minor ordering may determined cost sorting absence detailed cost model arbitrary order chosen 
strategy picking major minor ordering leads conservative increase number interesting orders generated 
note interesting orders generated traditional optimizer 
optimizer may generate additional interesting order applicable 
avoided problem generating interesting orders 
example consider sql query select sum group simple coalescing transformation enables pushing group relation prior doing scan grouping columns fr dg 
considering join choice evaluating evaluating early group considered cheapest plan retained joining consider plans generated greedy conservative heuristic considering join early group 
assume nested loop sort merge methods 
case consider major minor ordering nested loop sort merge 
candidate plans early group 
discussed greedy conservative heuristic ensures search space reasonable 
section experimental study indicates increase optimization cost modest 
detailed analysis see cs 
discuss important aspects 
explain cost models plan produced greedy conservative expensive obtained traditional algorithm 
experimental results indicate extent improvement quality plans significant 
show integrate greedy heuristic system style optimizer 
optimality formal treatment optimality results greedy conservative heuristic appears cs sketch intuitive proof plans obtained greedy conservative worse obtained traditional optimization algorithm cost models cost 
precise show result cost models satisfy property ffl interesting order cost groupby monotonic function size relation grouped 
observations hold key optimality 
definition greedy conservative heuristic ensures choose early groupby local cost application group followed join scan doing join 
application group increases size relation 
follows assumption just cost model greedy conservative heuristic adds cost group final step 
note greedy conservative heuristic retains interesting orders generated traditional optimizer 
plan chosen greedy conservative heuristic worse traditional plan 
join groupby sum amount join groupby sum amount sum amount order product residual groupby division implementation group ease integration incorporating greedy conservative heuristic needed modest extensions existing optimizer option early group considered conjunction choice access methods join algorithms 
view group operator precedes join new access path needs considered 
model join preceding group single operator join groupby 
operator considered step enumerate 
may need residual groupby operator succeeds join operators 
extended left deep tree plan represented terms operators 
benefits style modeling extensions similar needed adding alternative implementations join scan 
order predict costs alternatives correctly implementation detects cases group redundant section cases set group nodes introduced simple coalescing satisfies invariant grouping section 
cost models note transformations dependent specificity cost model 
extension traditional cost model need estimating number tuples relation group 
group single grouping column number groups equal number distinct values column 
multi column group need develop estimate number groups 
wanted conservative pushing early group adopted cost model discourages early grouping providing guaranteed overestimation number groups ffl assumed grouping columns independent 
number distinct values estimated minimum quantities number tuples relation product number unique values grouping columns 
optimal plan obtained cost model perform worse traditional plan 
choice cost model justified 
conservative realistic estimates number groups possible 
example cost model assume number distinct values equals maximum value cardinality grouping columns 
words assume columns hierarchical ordering 
experimental study section shown greedy conservative heuristic worse traditional optimizer 
order get sense better terms quality plans corresponding optimization overhead experimental study 
achieved statistically significant improvement quality plans modest increase optimization cost 
experiments conducted current implementation optimizer 
optimizer considers join methods nested loops merge scan comparison quality plans optimization overhead av 
ratio av 
ratio max ratio diff 
av 
plans stored av 
plans stored joins total diff plans traditional optimizer traditional optimizer study performance metrics simple hybrid hash join 
detailed description appears cs 
framework conventional modified optimization algorithm executed queries group clause consisting equality joins 
sizes queries generated randomly ranged joins 
attributes participating query attributes chosen randomly group attributes aggregation attributes 
attribute assigned grouping aggregation column query 
borrowed experimental framework ik inss review important details framework 
randomly generated relation catalog relation cardinalities ranged tuples 
number unique values column cardinality relation 
relation attributes attribute randomly chosen primary key relation 
relation physically sorted hashing primary index key attribute 
attribute probability having secondary index attribute 
experiment cost number page accesses cs ik accounted 
performance metrics choice query size parameters experiment chose report quantities indexes comparison quality plans produced 
average ratio represents average ratio cost optimal plan produced traditional optimizer cost plan obtained extended optimization algorithm 
factor indicates average plan produced traditional optimizer costs cost plan obtained modified optimizer 
difference tells plan produced modified optimizer better plan produced traditional optimizer 
observe result section assures greedy conservative worse 
average ratio diff metric similar average ratio compute average data points traditional modified algorithms differ 
intuitively metric represents average extent benefit modified optimizer produced different plan 
max ratio parameter measures largest difference optimal plan traditional optimizer modified algorithm 
maximum value ratios cost optimal plans traditional modified algorithm 
factor studied relative increase cost optimization 
comparison parameters average number plans stored traditional algorithm average number plans stored modified algorithm 
observations generated queries joins experimental set 
kind queries generated 
ensured number trials carried average ratio parameter estimated error confidence 
observations average ratio average ratio diff indicated plans significantly better traditional algorithm 
number plans maintained modified algorithm modest 
results show significant benefit incorporating transformation assumed conservative cost model discourages group 
new transformations possible push group past join operations 
advantage early group possible reduction sizes relations 
transformations increasing generality shown soundness 
observed proposed transformations applied cost fashion applications transformations may influence join order 
addressed question transformations incorporated system style dynamic programming algorithm widely commercial optimizers 
proposed greedy conservative heuristic constrains search space ensuring enumeration heuristic arrives plan worse produced traditional optimizer 
experimental results indicate plan chosen modified algorithm outperforms plans produced traditional optimizer significant optimization overhead 
solution provides simple optimization technique push duplicate elimination select distinct queries ensure plans obtained pushing duplicate elimination worse traditional plans 
provided techniques process optimize single block queries aggregates grouping practical easy adopt efficient 
house data warehouse applications techniques helped processing queries significantly 
optimization processing issues application brought attention mark hewlett packard corporate data management group 
discussions suggestions umesh dayal useful 
due hasan ravi krishnamurthy neimat help 
clr cormen leiserson rivest algorithms mit press 
cs chaudhuri shim promise early aggregation hpl technical report 
dd date darwen guide sql standard user guide addison wesley 
dayal goodman katz extended relational algebra control duplicate elimination proc 
acm symposium principles database systems pp 

dayal nests trees unified approach processing queries contain subqueries aggregates quantifiers proceedings th vldb aug 
ghk ganguly hasan krishnamurthy query optimization parallel execution proceedings acm sigmod conference manage ment data 
wong optimization nested queries revisited proceedings conference management data san francisco may 
inss ioannidis ng shim sellis parametric query optimization proceedings th international vldb conference vancouver canada august ik ioannidis kang randomized algorithms optimizing large join queries proceedings acm sigmod conference management data atlantic city nj may 
iso iso 
database language sql iso iec document iso iec 
available ansi document ansi 
kang randomized algorithms query optimization ph thesis university wisconsin madison wi april 
kim optimizing sql nested query acm transactions database systems sep 
kl klug access paths abe statistical query facility proceedings conference management data 
lu chan wei survey usage sql sigmod record vol 
improved unnesting algorithms join aggregate sql queries proceedings th vldb 
pirahesh hellerstein hasan extensible rule query rewrite optimization starburst proc 
acm sigmod conference management data june 
selinger access path selection relational database management proc 
acm sigmod conference management data june pp 
tm tsang study database customer queries ibm santa teresa laboratory tr 
yl yan larson performing group join international conference data engineering feb houston 
