reflexive cham join calculus fournet georges gonthier cedric fournet inria fr georges gonthier inria fr inria rocquencourt le chesnay cedex france adding reflexion chemical machine berry boudol obtain formal model concurrency consistent mobility distribution 
model provides foundations programming language functional object oriented features 
seen process calculus join calculus prove equivalent calculus milner parrow walker 
mismatch calculi concurrent processes languages programming distributed mobile systems 
calculi ccs calculus introduce small number constructs thoroughly studied metatheory :10.1.1.36.865
atomic non local interaction typically rendez vous difficult implement fully distributed setting 
programming languages actors obliq separate primitives transmission synchronization instance remote procedure call semaphores :10.1.1.17.6050
larger set constructs usually including imperative primitives hinders formal investigation 
bridge gap introduce new elementary model concurrency reflexive chemical machine 
model basis practical programming language design study model formally process calculus join calculus 
reflexive cham model obtained generic cham imposing locality adding reflexion 
locality achieved barring non linear reaction patterns implies reaction rule molecule associated single reaction site 
reflexion added letting reactions extend machine new kinds molecules reaction rules lets model computationally complete 
model effective generic cham molecules travel reaction site having mix match 
turns sequential deterministic subset model basically continuation passing style calculus embed calculus cps transform 
language design extends higher order sequential language parallelism expressions fork calls partly supported esprit basic research action confer 
function patterns join patterns 
jointly defined functions provide synchronization capabilities synchronous channels concurrent objects 
join patterns consistent lexical scope statically bind joint function calls body code binding messages receptors dynamic 
join calculus simply syntactic description reflexive cham molecules 
quite similar calculus combines restriction reception replication single joint receptor definition 
main theorem states calculus join calculus expressive power weak barbed congruence obtained exhibiting fully encodings direction 
result expect calculus metatheory carry directly join calculus 
overview process calculi synchronous channels 
channel abstraction communication media data exchanged send receive operations channels provide concise denotation transmission routing synchronization occur concurrent system 
calculus demonstrated combination elegant scope management technique channel operations computationally complete 
pict experiment shown calculus specifically asynchronous fragment basis useful higher order concurrent language non distributed setting :10.1.1.38.4600
distributed setting channels introduce atomic interaction distant emitters receivers communication ether 
difficult implement recovery local failures supported channel implementation includes sophisticated fault tolerant consensus protocol implementation details revealed failures 
problem occurs asynchronous setting interaction distant receivers contention 
hand channels absolutely required high level distributed programming 
instance primitive object languages unfortunately languages lack foundation simple precise calculus :10.1.1.17.6050
model purport develop 
starting point chemical machine regarded computational model calculus 
cham interaction local molecules simply move solution meet matching pairs react random motion description effective 
assuming chemical rules disjoint domains cham operational interpretation molecules travel reaction site associated rule sorted matched react reactions sites 
interpretation cham concurrent communication centralized fixed set sites bottlenecks management site complex number different expected molecule shapes grow clog 
better larger number sites simpler matching exactly reflexive cham modifications bring allowing dynamic creation sites restricting reaction patterns 
sketch basic mechanisms reflexive cham formal definition exposed section 
model operates higher order solutions comprising multisets 
molecules represent processes running parallel reactions define current reduction rules 
names values model cal 
twofold usage port names transmitted values 
write mean name sent name atom pending message 
compound molecule consists sub molecules glued join operator 
molecules heated smaller ones reversible way 
example consider print ports available printers laser send name port named ready users send filenames printed port named job 
atoms solution line versus atom compound molecule second line molecule joins laser printer file 
structural equivalence relates solutions reactions 
denoted reaction consumes compound molecules specific join pattern produces new molecules solution copies formal parameters instantiated transmitted values 
corresponds reduction steps solution gamma 

continuing example add reaction matches printers jobs sends filename printer add chemical reaction solution reduce previous molecule generate new atom 
notice non determinism comes just committed reaction 
gamma 
model reflexive meaning reactions dynamically created 
done kind molecule 
defining molecule def heated parts new reaction molecule case newly defined ports solution just considered come single molecule structural rules def realistic send name job users name ready printer drivers 
corresponds known scope extrusion calculus 
strict lexical discipline behaviour ready job may deterministic statically defined 
processes receive names may send messages add new reactions 
essential restriction reflexion lets extend language safely 
instance special names ffi rules may added machine special care calculus process may mistakenly alter behaviour 
section expand model simple programming language mobility illustrate features 
programmer point view high level concurrent language lexical scope asynchronous messages 
identify function calls special case message passing cps analyze reduction strategies calculus define convenient syntactic sugar sequential control 
language object oriented features 
elementary objects defined new names new reaction rules methods names returned behaviours declared rules states held messages internal names 
elaborate synchronization schemes expressed concurrent objects patternmatching rules 
firm commitment lexical scoping objects static meaning imperative features cloning explicitly encoded 
sections explore properties relation calculus 
join process calculus induced reflexive cham 
define observational equivalence basis compare relative expressive powers different calculi 
translations calculus proved fully regards weak barbed congruence sense technical results precise substitution encodings context host calculus 
section strip join calculus convenient unnecessary features recursion join patterns including messages polyadic messages definitions clauses obtain core join calculus retain expressive power model 
section compare core join calculus asynchronous calculus 
spite significant differences calculi provide exactly expressive power 
scoping conventions accurate encodings surprisingly complex 
simple accurate encodings discuss characteristics illuminate separates calculi 
conclude words 
implementation way evaluate language practice mention extensions support types explicit distribution failure detection migration 
sketch proofs full abstraction encodings cal join calculus described section 
results obtained auxiliary encodings bisimulation techniques particular weak bisimulation expansion proposed 
related knowledge banatre suggest multi functions primitives synchronization 
correspond order version join definitions procedural synchronous language 
directly related asynchronous trend calculus applications :10.1.1.53.4500
calculus focuses mobility minimal setting 
contrast extensions concurrency object oriented functional kernel 
likewise distributed systems built actor paradigm proposed layered architecture functional kernel wrapped imperative extension communication 
calculi introduce concurrency distribution different primitives 
directed communication functional flavour rely instance unification broadcast 
case oz linear objects 
reflexive chemistry give syntax processes scope names 
reflexive chemical machine illustrate simple examples 
names processes definitions values reflexive cham names case calculus 
infinite set names name variables lowercase letters denote elements 
ex notation tuple name variables delta delta delta xn grammar defines processes join patterns definitions 
process emission asynchronous polyadic message xhevi definition new names parallel composition processes 
definition consists elementary definitions match patterns joining messages guarded processes connected operator 
entirely describe behaviour defined names 
def xhevi def xhevi def def jj jp names appear process may captured enclosing definition 
binder join pattern scope names depends position messages 
formal parameters received bound corresponding guarded process 
defined port names bound defining process main process recursively guarded processes 
received variables rv defined variables dv dv free variables fv fv specified structural induction 
notice syntactic restriction processes received variable may appear twice pattern rules comparison names guarantees join patterns remain linear 
rv xhevi def fu rv jj def rv rv dv xhevi def fxg dv jj def dv dv dv def dv dv def dv dv fv def dv fv gamma rv fv def fv fv fv xhevi def fxg fu fv def def fv fv gamma dv fv jp def fv fv name fresh regards process solution free 
substitutions oe possibly implicit ff renaming non free variables avoid name clashes 
needed join calculus assume name variable number arguments message 
formally amounts recursive sort discipline consider sorted processes calculus 
operational semantics extend chemical approach berry boudol reflexion 
give heating cooling reversible rules 
corresponds underlying structural equivalence processes includes reflexion 
molecules suitably dissolved single reduction rule gamma 
expresses mechanism communication simpler way calculus 
rules operate higher order solutions right hand side active processes molecules multiset left hand side active definitions reactions multiset sake simplicity mention elements multisets participate rule separated commas 
str join jq str str def def oe dv red oe rv gamma 
oe rv side conditions substitutions str def oe dv instantiates port variables dv distinct fresh names dom fv red oe rv substitutes transmitted names distinct received variables rv 
structural rules express commutative associative 
str def describes heating molecule defines new names 
restriction oe dv reminiscent restriction prefix cal regards scope extrusion time enforces strict static scope definitions 
red meta reduction rule associates actual reduction rule reaction computation step reductions consume molecule port pattern fresh copy guarded process substitute received parameters sent names release process new floating molecule 
examples give examples processes definitions intuitive description meaning 
formal treatment observations deferred section 
def def def def hvi vi def hvi def shi shi shi def yh def simpler definitions perform wiring names messages local name forwarded outside messages leftmost free name rightmost locally bound require renaming messages local forwarded steps external performs multiplexing messages parts supplied introduced print overview generally models calculus channels values sent requests values sent matched definition express internal non determinism compound definition xh xh xh message lock replicates process starting new copy time definition 
finish series longer example illustrates higher order internal messages store local state 
cell abstraction defined def def seti message triggers external definition turn defines fresh names get set sent back access update new cell 
lexical scoping name remains local initial message internal rules guarantee invariant cell exactly message contains current value 
programming join calculus reflexive cham foundation concurrent programming language 
model provides expressive power features lowlevel actual programming 
instance convenient way express sequential control process strongly suggest syntactic sugar 
study embedding higher order functional programming 
continuation passing styles encode reduction strategies calculus clear cut subsets join calculus 
describe toy concurrent language ideas give programming examples 
discuss object oriented features 
programming 
encodings calculus definitions form def similar statement functional programming 
particular share static scoping discipline 
major difference comes asynchrony model meaning explicitly create send continuations 
cps encode terms processes triggered compare respective behaviour 
minor adaptations obtain results adequacy similar calculus terms translations converge diverge accordingly 
purpose illuminate tight connection functions join definitions encodings simpler 
syntax calculus usual def tt call name reduction strategy terms reduced leftmost order reduction may occur encoding def def def hx wi def def def whi hx vi intuitively process sends value value process serves evaluation requests sent requests supply names send requests value argument eventually return value evaluation converges 
image translation exactly deterministic subset join calculus defined set processes contain parallel composition definitions 
expected reductions processes subset entirely sequential 
parallel call value term tu reduced soon reduced values allowing function argument evaluated parallel 
reduction may occur larger subset join calculus encode confluent non deterministic reduction strategy def def def hx wi def def hw vi encoding sends value value process serves evaluation requests sent evaluation requests supply value parameter name value term 
image translation uses parallel composition capture non determinism strategy 
symmetry evaluation function argument apparent backed symmetries fork evaluation requests join results 
language sequencing basic model synchronization happens molecules consumed suffices express control flow 
practice resulting programs contain explicit continuations difficult understand 
sequential control apparent fix cps provide syntactic sugar language 
new grammar extends syntax steps ffl names split families synchronous asynchronous ffl processes consist series instructions fi executed sequentially 
def ev asynchronous message fi sequence instructions jp parallel composition def def recursive definition ev named values run asynchronous process synchronous call conditional return implicit continuation def value name synchronous call def ev asynchronous message ev synchronous message jj join messages calculus asynchronous names defined asynchronous messages synchronous names names implicitly transmit continuation message 
extend sort discipline distinguish names consistently 
message sent synchronous name continuation channel defined remaining part current instruction sequence continuation added message 
message received part join pattern continuation bound corresponding guarded process may send back results return instruction 
briefly binds names synchronous calls result synchronisation signal run asynchronously forks process return asynchronously sends results back continuation received value may contain nested synchronous calls 
formal translation omitted 
underlying model smoothly merges declarative style non deterministic programming functional framework 
definitions message pattern particular continuations substitution lemma holds instantiated body substituted calling message functional language 
examples synchronous names capitalised instance example compilation program def def get return get set return set run return get set second example elaborates print overview imperative style 
user select printer format files pre processed accordingly printing 
channels print synchronous calls library 
run time files letter note laser printed current printer changed file drawing printed colour 
def print format current run current print format return job file current print format run current print format print file format return job run current laser ps job letter job note colour job drawing style comes design pict functional syntax emissions static definition receptions direct allow finer control 
main drawback pict channel emitters receptors parallel compiled join definition see example fortunately uncommon programming examples 
approach offers object languages need mutate systematically receptor 
concerning implementation set rules comes definition independent definition 
advantage asynchrony rules managed locally queues messages automaton matches join patterns forks accordingly guarded processes 
known compilation techniques available 
embedding large functional style definitions reasonably efficient tail recursion optimizations 
concrete values built functions easily added behaviour reserved names specific ffi rules describe consumption messages implemented low level function calls 
concurrent objects synchronization patterns model provides essential features objects case calculus 
consider primitive objects language message passing pattern matching definitions encode objects servers receive requests execute methods 
design full fledged object oriented language require encoding instance inheritance cloning primitive 
sketch features support general objects dynamic definitions inheritance 
primitive objects objects created definitions port names may returned public kept private body definition 
sense cell example simple primitive object 
identify names methods definitions active concurrent objects 
current state object split components held internal messages critical sections 
interface may feature states different synchronization capabilities 
declarative pattern matching join messages expressive serialization method calls contains expressiveness coloured petri nets dynamically expanded 
illustrate combination concurrency synchronization example priority queues def def empty run return true empty empty run return false empty add return add run add return add max run min remove return remove run run run return empty add remove priority queue features synchronous methods empty add remove expected meaning remove retrieves smallest value blocks value available 
internal states empty containing smallest value head priority queue methods tail 
statically check exactly state message available definition 
values concurrently tested added removed particular new message released comparison new value added update propagates tail parallel 
tail eventually reached new empty priority queue created recursive definition mk priority queue returns fresh methods empty priority queue stored message 
class objects inheritance primitive objects lack dynamicity lexical scope definitions forbids overloading cloning 
known inheritance synchronization concurrent objects merge gracefully case recover ad hoc dynamicity indirections 
example dynamic method print files implemented static methods job invocation overriding current name associated method kept internal state 
likewise substitute state overwriting method overriding cases mix freely static dynamic components objects 
solution better traditional object server encoding requires local syntactic sugar 
alternative approach consists complementing join calculus new features general records obtain richer primitive objects 
join calculus join calculus simply set molecules reflexive cham 
section study details properties process calculus give equivalent definition variant join calculus 
briefly discuss observation identify observational equivalence barbed bisimulation congruence tool precisely reduce join calculus essential features 
reflexive chemical machine entirely defines syntax molecules processes structural congruence reduction relation gamma 
chemical solution cooled single process wrapping reactions big definition header 
join calculus processes provide presentation model order rewriting system modulo structural equivalence 
syntactic approach especially useful compare model calculi subsets join calculus section calculus 
join calculus process calculus core recursive join calculus restriction full calculus simpler definitions join patterns messages 
syntax grammar def jp def scope scope extends definition 
structural congruence smallest relation processes definitions dv dv contain fresh names jq qjp jq jr qjr def def jq def def def def ff jr qjr def def define reduction relation transitions labelled transition system ffi gamma ffi ranges fdg fg 
transition relation smallest relation definition gamma 
rf transition ffi gamma 
jq ffi gamma 
jq def ffi gamma 
def fv dv ffi def ffi gamma 
def ffi ffi ffi gamma 
lemma structural congruence smallest congruence contains pair processes reduction relation gamma 
contains exactly pairs processes gamma observation observation concurrent processes difficult general join calculus benefits experience gained ccs calculus 
informal discussion observation criteria introduce equivalence processes largest congruence suitable properties approach proposed calculus 
provides accurate basis comparisons calculi 
observable 
way process communicate outside export names messages free names wait answer enclosing definition 
distinguish processes accordingly free name associate asynchronous output barb tests ability processes emit gamma 
stands sequence gamma 

def fv ev gamma 
xhevi observational congruence congruence processes largest equivalence relation refinement output barbs weak reduction closed congruence definitions parallel compositions 
implies 
gamma 
implies gamma 

def def 
rjq proofs need finer auxiliary expansion relation apply bisimulation expansion technique expansion processes largest relation verifies properties gamma 
implies gamma 
example fv def def def process barb reductions simulated reduction side processes don barbs names distinguished contexts distinct names sent behaviour context internal reduction needed relay values 
despite technical differences definitions congruence contexts obtained weak barbed bisimulation barbs defined calculus 
barbed congruences defined process calculi independently syntaxes take advantage common framework obtain precise results 
full abstraction assess relative expressive powers miscellaneous calculi existence fully encodings 
definition process calculi respective equivalences ae theta ae theta expressive fully encoding expressive power expressive 
observational congruence equivalence process calculus meaning full abstraction results observation context 
finest results expect different process calculi 
internal encodings reflexive cham model corresponds join calculus convenient kernel programming language 
possible reduce simpler primitives 
successively remove recursive scope definitions clauses join patterns messages messages transmitted values 
replace internal encodings prove fully 
purpose isolate essential features join calculus give useful examples 
course derived features taken primitives realistic implementation 
theorem core join calculus expressive power full join calculus congruence particular fully encoding full calculus core calculus processes full join calculus actual proof consists successive internal encodings redundant features part section explain stage encoding 
omit proofs 
please note encodings chosen accuracy regards observation simplicity exposition result may busy waiting introduce infinite sequences internal reductions meant practice implement features remove join calculus 
plan implement efficiently full calculus directly reflexive machine specification 
recursive binding non recursive variant join calculus defined restricting scope defined variables def guarded processes inside refer 
get rid recursive usage names definitions encoding simply shift binding variables definition reception 
name ae defined hold recursive names message containing recursive names available 
particular received variable ae bound ae time molecule received 
lemma vector variables fv dv ae ae fresh variables 
def def ae hex ae aei complex definitions compile complex definition way join patterns multiple clauses connected simpler definitions pattern joins atoms 
purpose implement invisible layer emitters guarded processes definition explicit automaton matches messages patterns 
clarity syntactic sugar developped language encoding notation indicate names capitalization section 
encode definition jn pn ff conversion may assume patterns jk joins messages form translation def def get vi return get def ui get run seth fig vf gi run hv delta delta delta def pk hi get sk ae run pk gamma sk vi run seth vi run pk run pk hi delta delta delta run seth run translation consists simple way join definition matches internal actions internal state hes evi caches current pending messages defined names es represents set names available messages ev contains pending values names 
jk auxiliary process definition pk repeatedly checks current state contains defined variables sk jk triggers guarded process pk successful 
new definition inserts values messages current state 
notice message removed re sent sure choice messages cache ev freely reconsidered sent pk lemma dq translation defined def dq defined join term obtained applying translation compound definitions fully 
polyadic messages calculus communicate tuples names auxiliary private names describe protocol pairs process sends pair context extracts pair pair name executes sender side internal state holds value returned rw 
syntactic sugar language hide continuations def def return run def rw run return rw run def run translation sorted polyadic processes defined inductively processes encoding tuples nested pairs describe translations dyadic messages definitions vi def def zi def def jy def def run encoding may appear redundant pairs encoded decoded twice 
ensures valid pairs involved actual join definition 
level encodings contexts comply protocol may interfere case example def def zi ai def def zi def def def lemma encoding fully 
core monadic core polyadic variants join calculus expressive power 
comparison calculus despite syntactic differences join calculus considered offspring calculus asynchronous branch family 
introduced independently mini asynchronous calculus calculus :10.1.1.53.4500
authors suppress guards emission compare result original calculus 
going direction join calculus asynchronous calculus strong restrictions ffl binders scope restriction reception replicated reception syntactically merged single construct definition ffl communication occurs defined names ffl defined name exactly replicated reception 
reasons interested formal comparison calculi calculus thoroughly studied calculus results relate formalisms implementations 
appealing translate results automatically join calculus 
hand issues best addressed join calculus instance locality implementation purposes explicit distribution 
provides deep insight common different join calculus calculus 
encodings get precise results complex underlying ideas simple 
particular simpler encodings obtained general settings instance programs written pict programs language section similar implementation techniques 
results previous section consider recursive polyadic join calculus way join definitions target calculus encode calculus monadic variant reverse encoding 
recall definition asynchronous cal encode calculus join calculus 
naive encoding replaces channel cal way definition needed achieve full abstraction 
approach firewalls detail defer presentation proof annex manner encode join calculus calculus straightforward translation definitions scope restriction replicated reception 
approach need refine encoding 
sketch proof annex encodings assume name introduced translation rules fresh name appear terms 
may involve ff conversion 
asynchronous calculus study relationship precisely compare asynchronous calculus 
syntax milner 
loss generality allow monadic messages replicated input general recursion 
def jq xu observational approach congruence defined calculus asynchronous barbed congruence barbs emissions free channels 
theorem join calculus summation free asynchronous calculus expressive power weak output barbed congruences 
asynchrony relays encodings essentially rely properties asynchronous reduction calculus discussed similar properties join calculus 
calculi possible observe reception message instance xu possible distinguish different names external behaviour 
illustrate definition names def xv process repeatedly receives values forwards vice versa matter name send value available reception name internal reduction lemma processes pf qf implies jp jq encoding calculus naive structural definition channel calculus associate names xo output input enclosing definition matches output input emitter simply sends values xo receiver defines name continuation sends reception offer jq def def def ijx hi xv def def def hi def def hij hi example translate process reduction yu join process series reductions def ijx hi def huo hi def huo def ijx hi manner reduction bound name calculus simulated join reduction followed deterministic reduction join calculus conversely reduction join calculus translation belongs cases simulated reduction calculus 
full abstraction encoding unfortunately previous encoding reflect behaviour processes calculus placed arbitrary join calculus context protocol relies presence specific definitions free name context may define way 
example translation yu reduce anymore worse xu exhibits barb reveals presence input allows context distinguish process 
mobility supply correct definition xo translated free name context able forge message ti names arbitrary definitions 
protect translation hostile contexts names resulting free channels term set firewall enforces protocol 
refine idea channel represented pairs xo naive encoding distinguished outside 
pairs merged repeatedly communicating pending messages 
new pairs defined run time secure protocol ffl pair names received outside firewall defines new correct proxy pair merges external pair transmits new pair 
ffl pair names sent outside new firewall inserted set proxies messages pair 
result translation context exchange names syntactic point view 
contexts build firewall top naive translation px def def ijx hi def ex def px xe ij def def xo py ij free name px encodes creation new proxy output 
ex exports proxy conventional free name xe recursively defines proxy creator translation 
notation context defined name index appears index stands application context free variables term definition instance xy def ex ey xy 
theorem processes calculus note catches free variables jq 
proof give auxiliary encoding strictly compositional 
encoding join calculus reverse translation simpler join calculus calculus restrictions communication patterns 
careful encoding needed prevent contexts calculus reading messages names receive translation 
structural definition qjr def def xv def def xy reductions calculus translations correspond exactly reception messages join patterns 
translation loose symmetry atomicity join reduction matter scope restriction guarantee details observed 
translation reveals source process context calculus start reading values names bound translation definitions 
translating join calculus asynchronous calculus extended type system polarities specify write types channel communicated inside translation typed previous encoding fully 
full abstraction obtain second full abstraction result need build firewall 
interface recursively sets oneway relays name crosses boundary 
built terms convention indices 
rxy def def xe def global definition translation sets way relays rxx second argument 
relay forwards message sets relay going reverse direction transmitted value 
syntactic scope extrusion translations definitions synonym receive messages 
notation convention stands application followed applications free variables theorem processes join calculus interesting issues join calculus outside scope 
include actual implementation techniques type systems particular linear types names represent continuations extensions calculus records better support object oriented programming 
observation equivalences deserve detailed treatment comparison counterparts asynchronous calculus 
conclude briefly mention current usage reflexive cham join calculus programming language design resources environments explicitly distributed details network connectivity remain hidden 
practical distributed setting sites may fail atomicity interaction specified accurately way implemented locally 
join calculus relieves difficult issues synchronization happen definitions sufficient require definition annotated location shared names guarded processes 
likewise actual allocation resources definition waiting queues automaton closures happens locally definition activated chemical rule str def 
setting messages forwarded definition asynchronously handled locally 
currently study extensions reflexive cham language provide explicit control localization definitions sites possibly imperative migration site 
intensive interaction local protect local failure 
distributed prototype way assess feasibility interest distributed implementation process calculi 
acknowledgments works started seminar distributing calculus held inria participation damien doligez guillaume jean jacques evy luc didier remy 
roberto amadio gerard boudol xavier leroy benjamin pierce davide sangiorgi david turner fruitful discussions comments 
paul taylor macros typesetting diagrams 
agha mason smith talcott 
foundation actor computation 
technical report uiuc 
agha 
actors model concurrent computation distributed systems 
mit press cambridge ma 
amadio prasad 
localities failures 
foundations software technology theoretical computer science 

andreoli pareschi 
communication fair distribution knowledge 
proceedings oopsla acm sigplan notices pages nov 
published proceedings oopsla acm sigplan notices volume number 

banatre banatre 
distributed system structuring multi functions 
rapport de recherche inria rennes june 
berry boudol 
chemical machine 
theoretical computer science 
boudol 
asynchrony calculus note 
rapport de recherche inria sophia antipolis 
cardelli :10.1.1.17.6050
language distributed scope 
computing systems jan 
preliminary version appeared proceedings nd acm symposium principles programming languages 
mishra prasad 
facile symmetric integration concurrent functional programming 
international journal parallel programming 
tapsoft ed 
diaz orejas pp 
springer verlag lecture notes computer science 
honda tokoro :10.1.1.53.4500
object calculus asynchronous communication 
america editor proceedings ecoop lncs pages geneva switzerland july 
springer verlag 
honda tokoro 
asynchronous communication semantics 
tokoro nierstrasz editors proceedings ecoop workshop object concurrent computing lncs pages 
springer verlag 
honda yoshida 
reduction process semantics 
foundations software technology theoretical computer science 
honda yoshida 
combinatory representation mobile processes 
proceedings popl 
kobayashi pierce turner 
linearity pi calculus 
proceedings popl 

techniques compiling lazy pattern matching 
research report inria 
milner 
communication concurrency 
prentice hall new york 
milner 
functions processes 
automata languages programming th int 
coll volume lncs pages 
springer verlag july 
milner 
polyadic calculus tutorial 
bauer brauer schwichtenberg editors logic algebra specification 
springer verlag 
milner parrow walker 
calculus mobile processes parts ii 
information computation pages sept 
milner sangiorgi 
barbed bisimulation 
proceedings icalp lncs pages vienna 
springer verlag 
pierce emy turner 
typed higher order programming language 
workshop type theory application computer systems kyoto university july 
pierce sangiorgi 
typing subtyping mobile processes 
mathematical structures computer science 
appear 
summary lics 
pierce turner 
concurrent objects process calculus 
ito yonezawa editors theory practice parallel programming sendai japan nov number lecture notes computer science pages 
springerverlag apr 
pierce turner 
pict programming language pi calculus 
technical report preparation 
sangiorgi milner 
problem weak bisimulation 
cleaveland editor proceedings concur lncs pages 
springer verlag 
smolka 
foundation higher order concurrent constraint programming 

jouannaud editor st international conference constraints computational logics lecture notes computer science vol 
pages munchen germany sept 
springer verlag 
turner 
calculus types polymorphism implementation 
phd thesis lfcs university edinburgh 
preparation 
walker 
objects pi calculus 
information computation 
sketch proofs section notation diagrams follow usual conventions relations plain lines exists relations dotted lines stars denotes closure relation 
fully combining translations contexts prove direct implication studying translation interact arbitrary join calculus context 
performed auxiliary translation similar definition translation maps processes structural definition scope restriction output leads creation new proxy pair unguarded outputs definition xo unfolded def px xv def pz theta ij unguarded definition hybrid terms terms join calculus structurally equivalent ej join calculus process calculus process header definitions free names px appears message channels matches pv appears particular processes appear theorem hybrid terms 
study reductions inside hybrid terms 
reductions 
reductions join definition correspond reductions calculus 
reductions manipulate pairs synonyms trigger continuations induced encoding 
reductions inside independent translation 
interested family reductions 
get rid details encoding define auxiliary expansions relate hybrid terms differ deterministic reduction hasn performed extra synonyms introduced pairs xo weak bisimulation expansion technique 
lemma det relation join processes contains pairs deterministic reductions det def 
det det def gamma det det barbed expansion 
lemma merge relates hybrid terms additional pair synonyms left hand side theta ej merge ej merge def merge gamma merge barbed expansion 
lemma theta lemma reductions calculus mimicked translations 
det merge theta lemma pair hybrid terms ej ej ej ej proof relation contains pairs hybrid terms obtained congruent processes ej ej establish ae distinguish reactions may happen left hand side hybrid term case simulate right 
consider cases reduction outside translation sides 
reduction inside translation communication occurs reception offer output corresponds communication original term value received new proxy created deterministic reductions may necessary reach hybrid term 
right side obtain sequence reductions mimic translation 
ej ej delta theta ej theta ej delta intrusion pair channels environment translation receiving term form eu jx correct pending value join calculus definition match 
auxiliary commutative diagram push emission translation 
lemma build reductions right term deterministic reductions bottom left get new pair sides expansions hybrid terms switch xz 
jx eu jq ejx ij ejx ij delta theta ej eu jq delta extrusion pair channels translation environment emitting term form possibly fresh names get similar emission applying congruence context def yz theta jm yz jm diagram reductions right reordered internal reductions followed reductions ones build corresponding reductions translation right term expansion jm 
theta hi hi theta jm delta previous diagrams congruence respects barbs obtain definition ae particular ae correctness need translation fully compositional term wrapped protective context step structural definition conversely names subterm synonym names current term definition translation maps processes processes jq def ji def nx xv def def def hi def def hi definitions convention indices ix def def nx def def catches exported synonyms channels scope context 
prevents extension providing locality 
lemma proof case structural induction variants relation det merge ex 
significant cases jq def ji jie jq def nx lemma proof barbed congruence calculus congruence follows previous result congruence property asynchronous barbs individually tested simple contexts 
bisimulation obtained previous lemmas 
fully part conventions names calculus free variable translation corresponds external name join calculus introduce name name may appear process port name unguarded message note process may contain messages 
messages keep track internal names exported context adapt translate incoming relays 
bx def rxy definition hybrid term term calculus structurally equivalent context form rj join process possibly unguarded messages bx free variables xg 
lemma rx rx lemma gamma largest expansion calculus join calculus respects barbs 
join process gamma lemma relation contains pairs hybrid terms extended join processes congruent barbed congruence calculus 
proof congruence property obvious bisimulation requires case analysis establishes barbs preserved 
study details interactions translation context set new relays 
kinds reductions may occur external communication apply side 
intrusion external message received incoming relay messages withdrawn calculus context committed internal usage step prevents input message context steps deterministic lead new hybrid term 
bx det obtain bisimilar hybrid term side join calculus context def def def join processes barb necessarily single unguarded message 
consuming sides leads pair congruent processes 
discard useless definition wrap processes new pair related hybrid terms 
internal reduction translation definition join calculus obtain sequence reductions left side mimic translation 
deterministic reductions may needed sides reach hybrid term 
extrusion internal reduction export relay deterministic reductions messages translations free variables exported public calculus name det bx context oe obtain adequate sequence reductions right side emission handled special way ones silently transmitted 
oe def def def def hxi def def hxi bx ch oe oe delta delta barb reorder reductions right defer interaction context oe obtain sequence reductions mimic translation 
lemma join calculus definition compositional encoding obtain second half theorem qjr def def def def xy lemma join process free variables conclude argument reverse translation 
