remote mobile objects thor mark day barbara liskov umesh maheshwari andrew myers massachusetts institute technology cambridge ma usa thor distributed object oriented database objects stored persistently highly available servers called object repositories ors 
large thor system performance tuning system reconfiguration dictate objects able migrate ors 
describes schemes object support object migration location independent names location dependent names 
analyzes performance schemes concludes location dependent names right choice systems thor want fast access objects migrated 
categories subject descriptors database management systems distributed systems computer communication networks distributed systems distributed databases operating systems organization design distributed systems data storage representations linked representations database management physical design general terms design additional key words phrases addressing distributed object management distributed object oriented database location dependent location independent naming object migration object mobility object scalability 
distributed systems expect find object oriented databases objects reside hundreds thousands nodes 
object residing nodes may contain objects nodes may migrate node 
useful system provide efficient mechanisms users access objects interest despite complications 
efficient access mechanism allows remote objects located quickly 
describes implementation object meets criterion 
describes efficient technique accessing objects objects allowed migrate 
describes ways extending scheme mobile objects accessed 
location dependent names objects accessed additional time penalty modest space penalty location independent names consume space earlier version titled naming locating objects thor workshop objects large distributed applications vancouver bc th october 
research supported part advanced research projects agency department defense monitored office naval research contract part national science foundation ccr 
accessing object moved requires additional communication 
schemes developed context thor object oriented database system results applicable distributed object systems 
section brief overview architecture thor 
section discusses requirements object 
section describes schemes implementing object 
conclude analysis performance mechanisms 
overview thor thor provides universe objects persistent highly available 
object universe survives system failures high probability accessible needed 
object encapsulated state directly observed set methods users call interact 
state contains data integers booleans characters objects estimate average object order bytes contains objects similar 
size object vary lifetime 
thor universe appears clients single entity distributed servers called object repositories ors stores subset persistent objects 
moment object resides single migrate 
achieve high availability replicated number server machines objects copies stored servers 
thor attempts cluster objects ors disk single 
example refers objects stored disk locations fairly close 
assume clustering ors achieved cross boundaries rare 
thor provides persistent root object universe 
object persistent reachable persistent root 
object unreachable root storage reclaimed distributed garbage collector 
client programs run client workstations typically distinct servers run ors 
client program front fe running client machine 
fe provides interface client access thor 
ensure consistency despite failures concurrency client calls take place atomic transaction client program indicates current transaction attempt commit 
client programs obtain direct pointers objects fe issues handles 
handles identify objects subsequent clients calls local client session 
starting client request handle persistent root object execute methods object fact directory obtaining handles objects 
direct pointers objects move outside thor safe destroy storage objects reachable root handle issued active fe 
speed method execution fe keeps copies objects object cache 
client program call communication ors occur objects needed carry call reside client cache 
cache fe fetch needed object 
fe fetches object supply additional objects may shortly 
fe caches prefetched objects addition objects client 
objects fe cache may contain objects cache fe object attempt follow triggers fetch request 
example object contains objects 
fe cache contains copies objects prefetched fetched copy fe points directly local copy fe copy attempt call method part executing call method fe determine stores fetch 
requirements concerned form ors fes refer remote objects discuss form fes 
form determines quickly fetch requests carried prefetching done 
believe prefetching fast fetches critical system performance 
prefetching determines method calls hit fe cache hope happens time 
occurs critical path user direct effect latency call 
misses rare heavily affect performance perceived users 
want provide performance clients invoke methods objects 
implementation approach consistent number constraints 
thor big 
object universe large objects servers clients 

size system may change time 
example load system grows may add additional ors store persistent objects 

objects may persist long time years 

objects may migrate 
object mobility needed system intended larger scale single workgroup long time system initial configuration 
system grows shrinks usage patterns shift may find system performance improve moving objects current 
example entire group related objects moved reduce load old new closer client nodes usually access objects object moved contains system shrinking fewer machines available may desirable eliminate entirely moving objects ors 
individual objects probably move moment number objects moved hour probably quite small 
objects may persist long times number objects moved original birth may large 
design intended deal situation 
main issues designing object scheme system mobile objects 
way locating objects needed determining currently stores object 
second object located find memory 
goal minimize costs activities determine object resides communication determine memory location reading addressing information disk 
possibility virtual memory addresses 
idea partition address space ors stores portion address space objects addresses portion 
fixed global addresses mean ors control local memory layout relocate objects 
object relocation may needed objects grow shrink persistent objects cease persistent garbage collected 
conclude names refer objects 
section describes naming schemes location independent names location dependent names 
location independent names change object migrates location dependent names change happens 
forms object section describes forms object 
assuming objects don move describe efficient way implementing technique somewhat mneme 
discuss handle mobile objects 
approaches differ object name changes moves 
basic scheme object persistent selected 
birth site assigns entity called xref name 
xref pair containing id name object 
structure easy issue newly persistent objects just selects locally 
addition xref contains id fe knows object assumption objects don move fetching object requires just message round trip 
easily determine fetched object local objects 
prefetched returned fe message fetched object 
stores objects segments 
segment stored contiguous region memory read written disk unit 
contains group objects related objects clustered segments 
structured efficiently find corresponding object 
divided segment id object number 
table maps segment ids disk addresses 
segment header maps object numbers objects disk locations header stored segment read written segment read written 
want read segment unit big size bytes disk throughput effectively 
limit segment size means storing large objects requires scheme discussed 
objects average bytes segment hold objects 
segment table reasonably small 
bits long bits allocated indexing objects segment number segments indexed 
hold objects need table size bytes assuming entry holds byte disk address 
table fit primary memory machines near 
find object looks segment id segment table 
reads segment disk necessary read may necessary segments cached primary memory 
object clustering segments expect disk access segment table entry segment 
scheme excellent performance allow objects migrate 
show extend handle mobile objects 
extension continues object xref assigned persistent 
second gives object new xref time moves propagates information new name new name old 
location independent names location independent names called object identifiers oids attractive stay object moves 
object continue accurate spite move 
finding stores object difficult encode location 
entity locator record information current locations objects 
xref assigned object birth site oid continues refer moves 
object moves new assigns new xref containing id new part tells locator new xref 
new xref selected way assigned newly created objects places object local segment close related objects assigns segment 
fe fetches object determines current xref object discussed 
sends fetch request identified current xref new xref included fetch request 
fetch request arrives new handled usual way locating object segment segment table reading segment disk necessary 
prefetching possible scheme recognize local objects 
object may refer objects segment tracking mobile object location independent names 
fetched able prefetch objects refers 
object moves containing objects refer prefetching stored segment objects objects refer oid appears object different 
ways fe find current xref object 
possibility keeps track object objects move created obvious locator birth site 
fetch fe sends fetch request listed object oid responds object prefetched objects tells fe current xref object 
birth site locator store locations objects born longer referenced 
object moves birth site new location stored small stub 
illustrates scheme 
contains object refers object moved birth site object refers oid oid refers stub contains new xref 
problem scheme message round trips needed locate object moved cost incurred objects expect sizable fraction objects eventually migrate 
addition happens act locator heavily objects bottleneck 
objects move move location workload away change encoded objects oids 
locator logically exist long objects exist remove requires assigning locator role 
way locate object name service maintains mapping oids 
name service highly available 
object unavailable crash name service current available name service requires lot replicated storage 
worse round trips needed fetch object name server second storing 
object birth site may idea check consulting name service 
round trips needed fetch object moved 
birth site name service schemes speeded storing hint making xref pair 
hint contains information current location object object moved 
scheme won birth site locator scheme 
sites highly available crash locator migrated object unavailable object site available 
problem exist thor ors highly available 
mechanisms implementing highly available services described 
hint usually accurate 
accomplished tracking mechanism described section 
birth site locator preferable name service simpler performance 
consider scheme rest 
final point object moves isn birth site mark xref unused example marking entry object segment header 
mark retained xref longer determined tracking mechanism section 
location dependent names section describes alternative location independent names location dependent names 
object moves new places local segment contains related objects gives new local xref 
object previous storage old turned surrogate contains new xref 
surrogates forwarders mneme leaves loom 
predefined locator held object date information location 
information new xref moved object propagated manner discussed objects refer 
propagation complete old location exist surrogate garbage collected 
fe fetches object sends fetch request named xref 
hold object object moved 
object located just segment table prefetching works just objects didn move 
illustrates location dependent names 
part object moved object object refer object refers new xref uses old xref old gets surrogate contains new xref 
part ii information new xref propagated system 
refers new xref superfluous surrogate deleted 
location dependent names object moves different segment 
location independent names old new segments moved object read fetched location dependent names usually new segment needs read 
tracking objects location dependent names depends timely propagation xref information moved objects 
section describes tracking mechanism 
distributed garbage collection maintains inlist listing local objects referred objects 
table acts additional root garbage collection preventing externally referenced objects collected may reachable locally 
similar table keeping information exists fes 
ors maintain location table stores hold xref new xref pairs 
object moves away addition turning object storage surrogate sends messages ors object informing ii 
tracking mobile object location dependent names 
new xref 
uses determine ors contact 
ors learn new location object objects refer add entry location table 
garbage collector uses location table substitute new 
xref contained object looked table replaced new xref match 
information new propagated objects fetched prefetched 
speed information new xref propagates depends frequency garbage collection assume garbage collection happens reasonably 
propagation new xref means surrogates location table entries eventually unneeded 
garbage collector recognize discard surrogates table entries 
forwarding addresses similar fowler 
frequently moved objects may generate chains surrogates 
fowler scheme clients perform path compression sending updates members chain forwarding addresses 
thor path compression performed ors 
vs location dependent names choice 
described system 
plan implementation 
attractive smaller 
example allow maximum objects get bit 
contrast bits 
plan reasons 
expect client machines bit machines 
ors objects copied bit fes need expand replacing bit bit virtual memory addresses fe 
require extra copy object avoided ors 
second simpler 
objects hold objects ors 
need surrogates cross 
refer remote object object contain local surrogate surrogate contain xref remote object 
want prefetch surrogates fetch objects fe follows cross fetch surrogate surrogate fetch object 
contrast prefetching surrogates unnecessary 
usually correct xref referenced object fetched fe 
third reason imposes upper bound number objects single 
limiting way may bad reused constrains number objects existence particular moment time 
furthermore thor easy add objects needed thor hides existence multiple ors client programs 
single application data set large led cross performance poor 
xref scheme application supported larger scheme lacks flexibility 
need unique identifiers location dependent names different may refer object 
situation shown 
object refers xref form ffi contains xref form fii heard move 
despite difference form refer object 
implement object identity correctly object contains unique identifier field uid visible client code 
determinations object identity uids pointers 
fe fetches object compares uid objects uid table discards object duplicate 
identity test performed follows 
operands fe obvious thing operands identical virtual memory address 
operands xref identical 
operand differ operands fe fetched test carried 
location independent names fetch wouldn necessary 
discussion discussed implement distributed object oriented database system 
base mechanism suitable system objects allowed move server 
described ways mobile objects supported building top base mechanism 
scheme uses location independent names location dependent names 
base mechanism allows objects accessed communication disk reads assuming segment table paged 
way objects clustered segments expect disk reads needed 
performance schemes mobile objects summarized 
schemes referred ind location independent names dep location dependent names addition analyze scheme ind hint uses location independent names augments scheme messages disk space ind round trip read bytes moved object ind hint bytes object bytes moved object dep bytes object additional cost schemes space time 
hint contains current xref object object moved 
shows additional cost supporting mobile objects 
example locating object moved ind requires message round trip object birth site addition communication object actual 
may require disk access birth site object original segment primary memory 
space calculations assume bits sufficient hold 
scheme ind requires additional space proportional number objects moved birth site bytes moved object stub contain new xref plus bytes segment header store index stub 
scheme ind hint requires additional bytes object average cost bytes object objects system just moved objects 
scheme dep requires bytes object store object uid 
count space store surrogates short lived 
see scheme ind hint consumes space dep achieving better performance 
true shorter hints just identified object new 
eliminate ind hint consideration 
comparison ind dep simple dep better time performance ind consumes space 
note time cost ind ind unable prefetch object migrated 
conclude choice scheme depends important fetch moved objects quickly important prefetching 
performance moved objects important goal thor want allow objects migrate freely expect large proportion total objects system move 
plan location dependent names implementation 
authors gratefully acknowledge assistance sanjay ghemawat anonymous referees 
carey dewitt naughton oo benchmark 
proceedings acm sigmod washington dc may pp 

carson setia optimal write batch size log structured file systems 
proceedings usenix file systems workshop pp 

fowler decentralized object finding forwarding addresses 
tech 
rep department computer science university washington december 
gray reuter transaction processing concepts techniques 
morgan kaufmann san mateo california 
hornick zdonik shared segmented memory system objectoriented database 
acm transactions office information systems january 
hwang 
constructing highly available location service distributed environment 
tech 
rep mit lcs tr mit laboratory computer science january 
jul levy hutchinson black fine grained mobility emerald system 
acm transactions computer systems february 
krasner loom large object oriented memory smalltalk systems 
readings object oriented database systems zdonik maier eds 
morgan kaufmann pp 

ladin liskov shrira ghemawat lazy replication exploiting semantics distributed services 
tech 
rep mit lcs tr mit laboratory computer science july 
lindsay object naming catalog management distributed database manager 
proceedings nd international conference distributed computing systems paris pp 

liskov day shrira distributed object management thor 
distributed object management ozsu dayal valduriez eds 
morgan kaufmann san mateo california 
maheshwari distributed garbage collection client server transactional persistent object system 
tech 
rep mit lcs tr massachusetts institute technology 
moss design mneme persistent object store 
acm transactions information systems april 
stamos large object oriented virtual memory grouping strategies measurements performance 
tech 
rep scg xerox parc may 

