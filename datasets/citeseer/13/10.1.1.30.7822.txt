electronic notes theoretical computer science url www elsevier nl locate entcs volume html pages overview elan peter borovansk claude kirchner el ene kirchner pierre etienne moreau christophe ringeissen loria cnrs inria campus scientifique bp es nancy cedex mail elan loria fr presents comprehensive elan rule programming language 
describe main features language elan environment introduce bibliographic various papers addressing foundations implementation applications elan 
elan system provides environment specifying prototyping deduction systems language rules controlled strategies 
purpose support design theorem provers logic programming languages constraints solvers decision procedures offer modular framework studying combination 
elan takes functional programming concept data types function evaluation principle rewriting 
rewriting inherently non deterministic rules applied different positions term elan computation may results 
aspect taken account choice operations backtracking capability 
main originality language provide strategy constructors specify function call returns result 
declarative handling non determinism part strategy language allowing programmer specify control rules application 
contrast existing rewriting languages term reduction strategy hard wired accessible designer application 
strategy language offers primitives partially supported esprit basic research working group construction computational logics ii 
fl published elsevier science borovansk kirchner kirchner moreau ringeissen sequential composition iteration deterministic non deterministic choices elementary strategies labelled rules 
primitives complex strategies expressed 
addition user introduce new strategy operators define rewrite rules 
evaluation strategy application rewriting 
simple known paradigm rewriting provides logical framework deduction systems expressed combined evaluation mechanism language 
purpose summarize elan features library environment provide guide literature language 
main features elan language section 
current version elan includes interpreter compiler written respectively java library standard elan modules user manual examples applications 
different components environment described section 
section provides commented bibliography foundations implementation applications elan 
section shortly compares elan existing rule systems 
informations current version system web site specification language specification formalism provided elan system close algebraic specification formalism 
signatures introduce sorts data operations applied 
particularity elan provide mixfix syntax operators 
defining booleans instance sort bool declared inhabited constants true false 
boolean terms constructed operators 
attributes ac may declare operator left associative right associative parsing purposes associative commutative 
associativity commutativity axioms called structural axioms application embedded matching process 
priorities may defined attribute pri aliased syntactic forms operator introduced attribute alias 
www loria fr projects elan elan html 
borovansk kirchner kirchner moreau ringeissen module boolean sort bool operators global true bool false bool bool bool bool pri bool bool bool pri bool bool bool pri alias bool bool bool pri alias bool bool pri bool bool pri alias may useful define injection sort 
done elan anonymous operator 
assume want define sort constraint embedding sort bool boolean formula constraint 
expressed elan follows module constraint sort constraint operators global bool constraint algebraic style semantics operations data described set order formulas 
elan formulas general form rewrite rules conditions local evaluations 
instance simple rewrite rules booleans follows rules bool bool global true 
true false 
true 
false 
false true 
false false 
true values true false said irreducible normal form 
set rules terminating confluent ensures boolean formula unique normal form 
systems needed specify order rules applied position term 
elan system adopts case strategy default selects leftmost innermost redex step 
situations especially deal non confluent non terminating rewrite systems suitable express rule apply 
specifying kind control elan introduces possibility name rules brackets front rule enclose name 
previous boolean example names unspecified borovansk kirchner kirchner moreau ringeissen rules said unlabelled 
capability specifying control main originality elan compared specification languages 
explain details build strategies compute results specify order applied rules iterate possible application strategy rule term 
strategies specification labelled rule elementary strategy called primal strategy 
result applying rule labelled lab term set terms 
note may rules label 
rule labelled lab applies term set results empty say rule lab fails 
understand applying rule top term yield results know local assignments rewrite rule call strategies subterms 
strategy local assignment results rewrite rule 
labelled rule lab considered simplest form strategy returns results rule application 
strategy lab encapsulated operator dc returns non deterministically chosen result 
case dc lab returns result 
addition elan provides built strategy operators take possibly strategies arguments build new strategies ffl concatenation operator denoted builds sequential composition strategies strategy fails fails returns results applied results ffl dk operator variable arity abbreviation dont know choose 
dk takes strategies arguments returns set results 
dk fails strategies fail 
ffl dc operator variable arity abbreviation dont care choose 
dc selects strategy fail arguments say returns results 
dc fails strategies fail 
choose specified 
ffl specific way choose provided operator selects strategy fail arguments returns results 
selected means strategies gamma failed 
fails strategies fail 
ffl result wanted operators dc select non failing strategy arguments respectively return non deterministically chosen result selected strategy 
ffl id identity strategy fails 
ffl fail fails returns empty set results 
borovansk kirchner kirchner moreau ringeissen ffl repeat iterates strategy fails returns obtained result 
repeat fails terminates fails 
ffl iterate similar repeat returns intermediate results successive applications addition primitive strategy operators user define new strategy operators strategy rules evaluation 
non deterministic computations order illustrate constructions write program computes images function element occurring input list 
lists defined module empty list denoted nil concatenation operator module list sort element list operators global element element element nil list element list list list composed elements represented term nil 
function element element define map list element rewrite rules element list respectively local variables sort element list 
head map element list 
element tail map element list 
map list introduce constant strategy operator defined strategy rule 
iterate dc tail dc head applied map nil returns successively 
defined identity element get strategy called extracts elements list 
illustrates notion strategy compute set normal forms explicitly notion set 
rules specification seen apply labelled rules strategies top term 
order apply strategies subterms syntax rewrite rules enriched local evaluations call strategies sequences computations specify conditions application 
general syntax elan rule follows rule 
label 
term 
term 
local evaluation 
borovansk kirchner kirchner moreau ringeissen local evaluation 
boolean term 
variable 
strategy 
term 
term 
strategy 
term 
choose try local evaluation 
selection rule matching left hand side term reduce local evaluations evaluated order potentially enrich matching substitution 
evaluation fails rule apply resulting term built right hand side enriched matching substitution 
see kinds local evaluations significantly increase expressivity rewrite rules ffl condition boolean expression introduced keyword 
term put normal form compared predefined boolean value true 
equal condition satisfied local evaluation considered 
backtracks previous local evaluation 
ffl local assignment allows calling strategy 
term normalised unlabelled rules strategy applied normal form 
practice result computed assigned variable fails local assignment fails backtracking applied 
result strategy may required backtracking mechanism 
notion local assignment extended matching condition term 
case term matched result provides values variables ffl third kind local evaluation allows factorisation computations construction choose try 
especially useful rules left hand side rules int global 

order reduce term instance rule selected say 
assume strategy term fails 
case second rule tried normal form re computed 
avoid kind redundancy choose try construc borovansk kirchner kirchner moreau ringeissen tion write equivalent elan program avoids drawback rules int result global 
result choose try result try result modularity parameterization elan modular language allows parameterized modules 
provides subtle parameterization preprocessing described section 
module defines computational system composed sets sorts operators rewrite rules strategy operators strategy rules 
import modules keyword import followed module names 
approach importation seen textual copy imported module importing 
useful specify operations local visible module belong 
keyword local declare operator rule locally visible hidden outside module 
dual keyword global operator rule visible outside module defined 
module imported importation specified local global 
entities visible global module imported global remain visible global whilst global entities local module imported local 
prototyping environment elan prototyping environment components 
library provides user collection modules may imported reused various applications 
preprocessor expands concise constructions allowed language 
parser checks syntax programs verify terms syntactically formed 
interpreter interactive tool allowing user check results expects obtained 
compiler transforms specifications independent executable code 
borovansk kirchner kirchner moreau ringeissen library elementary data types booleans integers identifiers strings builtin 
equality disequality operations sort built basic operations terms occurrence test replacement 
standard input output primitives fully integrated system built 
built module imported elan module contains declaration built operations mapped internal functions special code attribute 
addition modules implementing elan useful data structures provided elan library modules defining parameterized lists tuples arrays 
structures specific application domains elan library provides modules manipulate terms substitutions equational systems perform syntactic unification 
enumeration exhaustive library continuously enriched new modules written elan 
third level library provided functionalities related strategy language 
syntactic constructions strategy language depend user specifications described elan module library 
operations dynamically create typed strategies provided 
module dedicated user defined strategies imported full expressivity strategy language elan programs 
parser elan allows user define syntax giving signature mixfix syntax syntactic analysis complex possible generators lex yacc fixed part syntax excludes user defined terms 
earley algorithm analyse part programs depends user defined syntax terms part analysed automaton generated yacc tool 
preprocessor elan syntax provides fancy constructions instance construction ig processed processed elan preprocessor performs textual replacements 
construction seen program generation feature 
construction replaces sequence occurrences variable result strategy applied specification written elan borovansk kirchner kirchner moreau ringeissen operators global list identifier identifier nil extract term variant sort list identifier strategy previously defined 
preprocessor extracts elements list nil creates declarations operators global term term preprocessor may automatically generate parts specifications analyse rest program 
emphasised needs power elan interpreter perform task previous example strategy executed analysis 
illustrates strong interaction parser preprocessor interpreter 
interpreter interpreter takes formed program formed query checked parser applies rules strategies defined program query 
order find rules apply selection guided top symbol rules rules left hand side top symbol term reduced selected 
tried order program 
kind choices arbitrarily interpreter strategy dc select randomly non failing strategy practice interpreter selects implements dc way 
note exists version elan concurrently executes strategies selects terminates failure 
set rules selected matching algorithm applied 
associative commutative ac short operators involved external ac matching algorithm described eke called 
algorithm fully integrated interpreter data structure conversions required lower efficiency ac matching quite complex 
match local evaluations performed succeed result term built advantage right hand side rule term sharing 
eke eker 
associative commutative matching bipartite graph matching 
computer journal 
borovansk kirchner kirchner moreau ringeissen compiler elan compiler designed 
experimentations clear higher level programming achieved functions may declared ac 
rewriting theories computationally difficult providing efficient compiler language real challenge 
compilation techniques design new elan compiler ffl matching implemented deterministic automata 
ffl ac symbols handled 
order get efficiency compiled programs effort concentrated patterns layers ac symbols 
patterns transformed preprocessing step introduces new local assignments left hand sides rules 
compact bipartite graph data structure design efficient ac matching algorithm described 
ffl due non deterministic strategies particular choice point management needed 
implementation backtracking functions usually required create choice point save execution environment second backtrack created choice point restore saved environment 
flow control functions set fail implemented assembly language 
set sets choice point computation goes 
fail function performs jump call set choice point 
implementation described 
ffl efficiency achieved determinism analysis 
determinism analysis phase elan compiler annotates rule strategy program determinism mode phases compiler matching phase various optimisations generated code detection non termination 
developed 
exchange format exchange format elan programs called ref format reduced elan format provides representation programs shared different tools elan environment parser interpreter preprocessor compiler 
format facilitates connection systems asf sdf execute elan programs asf sdf conversely 
advantage ref format provide term representation easily handled elan programs module specifying ref format available library 
example unlabelled rules elan program may completed completion process provide confluent terminating rewrite system 
representation functionalities allow access modify different borovansk kirchner kirchner moreau ringeissen parts format basis implementing reflection elan 
insights foundations logical foundations elan described papers 
initial ideas notion computational systems introduced constraint solving context 
design elan described vittek phd thesis 
initial approach strategies expressed strategy constructors dc dk concatenation iteration 
idea user defined strategy language implemented rewriting logic elan 
functional view rewriting strategies provides functional semantics elan 
ideas partial evaluation strategy language explained 
preliminary ideas build reflective extension elan 
implementation elan manual version available 
describes implementation elan compiler compilation techniques associative commutative normalisation studied details compilation matching non determinism management 
ref format implementation described 
applications computational processes automated deduction expressed instances general schema consists applying transformation rules formulas strategy reaching specific normal forms 
processes naturally elan 
applications designed classified area interest programming proving solving 
programming application prototype fundamental mechanisms logic functional programming languages order resolution calculus 
general framework constraint logic programming jm easily designed elan framework operational semantics clearly formalised rewrite rules application strategy defined informal way 
implementations related calculus explicit substitutions order rewrite system oe mimics calculus open way implementing higher order logic jm jaffar maher 
constraint logic programming survey 
journal logic programming 
borovansk kirchner kirchner moreau ringeissen programming languages order setting 
calculus explicit substitutions calculus provide formal specification input output elan 
proving elan order implement predicate prover rules proposed 
abrial implemented tools abr developed propositional sequent calculus completion procedures rewrite systems sufficient conditions termination problem 
library automata construction manipulation designed 
approximation automata check conditions reachability sufficient completeness absence conflicts systems described non conditional rewrite rules 
solving notion rewriting controlled strategies describe unified way constraint solving mechanism meta language needed manipulate constraints 
provides programs close proof theoretical setting describe constraint manipulations unification numerical constraint solving 
elan offers constraint programming environment formal description constraint solver directly executable 
elan tested examples constraint solvers various computation domains combinations domains term algebras concrete ones booleans integers reals 
shown computational systems general framework handling constraint satisfaction problems csp short 
approach leads design elan solver constraints integers finite domains 
related systems elan similarities rule systems asf sdf dhk cafeobj fn maude cde compared elan positive aspects ffl elan programming language rewriting logic integrating notion strategy relevant express non deterministic computations 
analogous notions proposed maude asf sdf 
ffl fast elan compiler available couple years actual ver abr 
abrial 
book assigning programs meanings 
cambridge university press 
dhk deursen heering klint 
language prototyping 
world scientific 
isbn 
fn futatsugi nakagawa 
overview cafe project 
proceedings cafeobj workshop yokohama japan august 
cde clavel eker lincoln meseguer 
maude beta version 
technical report sri international computer science laboratory menlo park ca usa march 
borovansk kirchner kirchner moreau ringeissen sion written java encompasses improved garbage collector handles specifications involving ac symbols 
due promising results obtained compilation techniques rewriting development compilers rule languages attracted considerable interest asf sdf cafeobj communities 
common exchange format ref help development language independent compiler rewrite specifications 
ffl elan system provides powerful parser original pre processing facilities allow writing modular parametric specifications syntax 
preprocessor useful writing specifications concise generic way 
hand elan weaknesses respect systems 
exchange format elan quite new ref format considered attempt 
point expertise asf sdf asfix format architecture interconnection asfix tools 
asf sdf system designed meta environment prototyping programming languages formalism syntax definition carefully worked 
elan system comparable asf part incorporate facilities specify user defined lexical entities 
exchange format possible solution deal reflection facilities fully integrated maude cla maude allows possible equational axioms user defined function symbols associativity commutativity identity idempotency combinations whilst elan handles associativity commutativity possibly combination different ac symbols 
behavioural specifications hidden sorts states order sorted sorts object orientation provided cafeobj integrated elan 
points provide potential improvements elan 
elan borovansk 
control rewriting study implementation strategy formalism 
volume 
borovansk 
implementation higher order unification calculus explicit substitutions 
proceedings lecture notes computer science pages 
springer verlag 
van den brand heering klint 
renovation old asf current state affairs 
proceedings international workshop theory practice algebraic specifications asf sdf amsterdam workshops computing 
springer verlag 
cla clavel 
reflection general logics rewriting logic maude 
phd thesis university spain 
borovansk kirchner kirchner moreau ringeissen borovansk 
le de la etude implantation un de strat 
th ese de doctorat universit universit henri poincar nancy 
borovansk castro 
cooperation constraint solvers new process control facilities elan 
volume 
borovansk 
moreau ringeissen 
handling elan rewrite programs exchange format 
volume 
borovansk kirchner kirchner 
controlling rewriting rewriting 
meseguer editor proc 
intl 
workshop rewriting logic applications volume electronic notes theoretical computer science asilomar california september 
elsevier 
borovansk kirchner kirchner 
rewriting unified specification tool logic control elan language 
proceedings international workshop theory practice algebraic specifications asf sdf workshops computing amsterdam september 
springer verlag 
borovansk kirchner kirchner 
functional view rewriting strategies semantics elan 
sato toyama editors third fuji international symposium functional logic programming pages kyoto april 
world scientific 
borovansk kirchner kirchner 
moreau vittek 
elan logical framework computational systems 
meseguer editor proc 
intl 
workshop rewriting logic applications volume electronic notes theoretical computer science asilomar california september 
elsevier 
borovansk kirchner kirchner 
moreau vittek 
elan user manual 
inria lorraine loria nancy france second edition january 
borovansk kirchner 
strategies elan meta interpretation partial evaluation 
proceedings international workshop theory practice algebraic specifications asf sdf workshops computing amsterdam september 
springer verlag 
castro 
binary csp solving inference process 
proceedings eighth international conference tools artificial intelligence toulouse france pages november 
castro 
solving binary csp computational systems 
meseguer editor proc 
intl 
workshop rewriting logic applications volume electronic notes theoretical computer science asilomar california september 
elsevier 
castro 
constraint manipulation rewrite rules strategies 

editors proceedings second borovansk kirchner kirchner moreau ringeissen esslli student session th european summer school logic language information esslli pages aix en provence france august 
castro 
building constraint satisfaction problem solvers rewrite rules strategies 
fundamenta informaticae september 
genet 
decidable approximations sets descendants sets normal forms 
proceedings th conference rewriting techniques applications tsukuba japan volume lecture notes computer science pages 
springer verlag 
genet 
termination proofs gpo ordering constraints 
bidoit dauchet editors proceedings nd international colloquium trees algebra programming lille france volume lecture notes computer science pages 
springer verlag 
kirchner kirchner vittek 
designing constraint logic programming languages computational systems 
van hentenryck saraswat editors principles practice constraint programming 
newport papers pages 
mit press 
kirchner ringeissen 
rule constraint programming 
fundamenta informaticae september 
kirchner 
moreau 
prototyping completion constraints computational systems 
hsiang editor proceedings th conference rewriting techniques applications kaiserslautern germany volume lecture notes computer science pages 
springer verlag 
kirchner 
moreau 
reflective extension elan 
meseguer editor proc 
intl 
workshop rewriting logic applications volume electronic notes theoretical computer science asilomar california september 
elsevier 
kirchner 
moreau 
non deterministic computations elan 
submitted 
moreau kirchner 
compiler rewrite programs theories 
palamidessi glaser meinke editors principles declarative programming number lecture notes computer science pages 
springer verlag september 

moreau 
choice point library backtrack programming 
jicslp post conference workshop implementation technologies programming languages logic june 

moreau kirchner 
compilation techniques normalisation 
proceedings international workshop theory practice algebraic specifications asf sdf workshops computing amsterdam september 
springer verlag 
borovansk kirchner kirchner moreau ringeissen ringeissen 
prototyping combination unification algorithms elan rule programming language 
proceedings th conference rewriting techniques applications spain volume lecture notes computer science pages 
springer verlag 

input output elan 
meseguer editor proc 
intl 
workshop rewriting logic applications volume electronic notes theoretical computer science asilomar california september 
elsevier 
vittek 
elan un cadre logique pour le de langages de programmation avec contraintes 
th ese de doctorat universit universit henri poincar nancy 
vittek 
compiler nondeterministic term rewriting systems 
ganzinger editor proceedings th conference rewriting techniques applications new brunswick new jersey usa volume lecture notes computer science pages 
springer verlag july 

