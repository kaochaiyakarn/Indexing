cartesian product algorithm simple precise type inference parametric polymorphism ole agesen computer science department stanford university stanford ca agesen cs stanford edu 
concrete types types different serve different purposes 
concrete types focus essential support compilation application delivery debugging object oriented environments 
concrete types obtained explicit type declarations presence limits polymorphism unacceptably 
leaves type inference 
unfortunately polymorphism demands type inference hardest challenge type inference 
review previous type inference algorithms analyze code parametric polymorphism new cartesian product algorithm 
improves precision efficiency previous algorithms deals directly inheritance relying preprocessor expand away 
conceptually simple 
cartesian product algorithm self system late 
measurements document performance compare previous algorithms 
keywords concrete types types type inference polymorphism inheritance self 
concrete versus types concrete types implementation types representation types sets classes 
example expression returns instances class concrete type expression returns instances class concrete type 
concrete types provide detailed information distinguish different implementations data type 
contrast types interface types principal types capture properties objects 
may distinguish different implementations data type list array stacks may type push pop 
probably best known inference algorithm types milner 
concrete types extremes spectrum type systems 
class types beta eiffel fully impossible express type object push pop operation fully concrete declaring object class type stack reveal specific subclass instance 
concrete types focus 
previous publications argued directly support solutions important problems object oriented programming environments compilation 
concrete types support important optimizations elimination dynamic dispatch method inlining :10.1.1.48.5515
extraction 
concrete types support delivery compact applications enabling extractor sift image objects selecting essential run application 
browsing debugging 
concrete types help programmer understand programs allowing browser track control flow data flow dynamically dispatched message sends 
published ecoop conference proceedings denmark august springer verlag lncs need concrete type information may greater object oriented environments conventional environments object oriented programs consist small methods inlining important emphasis code reuse yields large general class libraries extraction important understanding object oriented programs harder control data flow coupled browsers assist 
statically typed languages concrete type information problems supported class types 
instance knowing object instance class stack generally sufficient inline operations program may contain subclasses stack static type declaration tell specific occurs concrete type inference may tell 
polymorphism polymorphism ability piece code kinds objects central part objectoriented programming 
polymorphism desirable enables code reuse 
distinguish kinds 
parametric polymorphism ability routines invoked arguments types 
length function works singly linked doubly linked lists exhibits parametric polymorphism 
data polymorphism ability store objects different types variable slot link objects forming heterogeneous list integers floats strings exhibit data polymorphism contents slots contain objects types 
explicit programmer inserted concrete type declarations undesirable limit polymorphism code reuse 
example adding type declaration int float formal arguments max routine reusable longer find larger strings 
explicit concrete type declarations undesirable considerable interest inference algorithms surprising :10.1.1.48.5515
ironically desire maximize polymorphism demands type inference polymorphism hardest challenge inference algorithms 
illustrate applied simple inference algorithm basic algorithm see section self expression factorial factorial method integer receiver defined factorial self smallint polymorphic imprecise type reported smallint collector memory float link list time false true nil blk blk blk 
fairness situation complex just analyzing factorial 
methods invoked factorial methods turn invoke analyzed 
furthermore arithmetic overflows ruled forcing analysis implementation uses lists byte vectors total approximately lines code analyzed find type factorial 
complexity peculiar self system better results may obtained systems example clearly demonstrates insufficient precision basic algorithm analyzing polymorphic code 
address imprecision accurate algorithms developed see survey 
infer precise type smallint factorial example 
improved precision came cost 
type inference got efficient complex understand 
instance phillips shepard implemented precise algorithms took hours infer types expression parcplace smalltalk 

slots self provide functionality instance variables parents formal arguments local variables 
contributions propose new algorithm analyzing parametric polymorphism 
algorithm applies cartesian product break analysis send case analysis case represents monomorphic combination actual arguments 
way simultaneously achieves precision efficiency factorial infers type smallint seconds see section 
specifically cartesian product algorithm offers advantages precise cases previously published algorithms 
efficient simultaneously avoids redundant analysis iteration major performance limitations previous algorithms 
general applying traditional expanding away inheritance new algorithm handles directly permitting precise analysis combination single multiple static dynamic inheritance inheritance state prototype languages multiple dispatch 
conceptually simple involves expansions iteration 
validated real programs self system late 
consider data polymorphism briefly 
succinctness refer parametric polymorphism simply polymorphism concrete type type 
rest organized follows 
section presents background material including overview previous algorithms 
section presents detail new algorithm compares previous algorithms 
section compares algorithms measurements obtained self system 
section offers outlines possible directions 
appendix briefly lists number issues lack space prevents discussing detail 
background algorithms describe language independent self source examples measurements 
detailed knowledge self required basic familiarity self smalltalk syntax programming style helpful 
section reviews background material 
section defines concrete types prototype context 
section describes basic type inference algorithm flow analysis 
section introduces templates high level way understand algorithms 
templates review previous algorithms new algorithm 
section pinpoints polymorphism hard analyze 
section reviews previous algorithms deal polymorphism 
detailed complete version background material 
definition type informally types sets classes suzuki johnson 
self prototype classes need modify definition type slightly 
self program finite set objects prototypes 
example may true may point 
program execution computation results sending designated message say main particular object main object 
message invokes main method turn may invoke methods 
main method equivalent function main program 
conceptually prototypes created program execution starts 
objects participating execution created cloning prototype object recursively cloned prototype 
transitive closure relation cloned partitions objects clone families prototype 
write clone family 
concrete type arbitrary subset set clone families 
take standard interpretation expression slot type evaluates holds objects belonging clone families examples types type true false type factorial smallint 
range analysis constant folding say small integer big integer may result 
type nil nil 
type expression nil returns nil object nil 
language treat nil null object may worth doing type inference 
prize complimentary null analysis types include null identify null pointers may show execution 
definition expression slot type type tt 
permits conservative type inference inferred types may overestimate occur execution 
universal type trivially sound slot expression useful type infer conveys information 
goal infer precise types precise type smaller set 
program prototypes possible concrete types 
contrast programmer writing semi type declarations granted possible types class 
precision difference exponential linear number types significant 
concrete types programmer express type inference algorithm infer 
basic type inference algorithm basic type inference algorithm palsberg schwartzbach constraint solving problem derive set constraints program analyzed solve constraints fix point algorithm map solution back program obtain desired type information 
algorithm deficiencies analyzing polymorphic code constitutes core improved algorithms review 
take operational view presenting type inference combined control data flow analysis domain types 
interpretation perspective allows direct correspondence analyzing program executing making analysis algorithms easier understand 
referring program analyzed target program steps basic algorithm 
step 
allocate type variables 
step associate type variable slot expression target program see 
type variable simply variable possible values types sets clone families 
initially type variables empty steps adds clone families hold sound types slots expressions associated 
removed type variable 
type variables 
slot fig 

type variable associated slot expression target program 
program fragment shown left frame type variables particular order right frame 
type variable slot labelled slot distinguish expression reads slot 
slot declaration 
increment 
target program 
step 
seed type variables 
second step adds single clone family certain type variables type variables seeded 
goal capture initial state target program initializing type variables correspond slots expressions objects initially 
example type variable slot nil 
similarly type variable literal object bicycle string added 
seeded type variable member shown small dot 
step 
establish constraints propagate 
step builds directed graph nodes type variables 
edges added represent constraints 
constraint type inference time equivalent run time data flow 
example target program executes assignment exp data flow exp intuitively data flow means object may result evaluating exp slot 
algorithm encounters data flow edge added exp type variable type variable reflecting type exp type 
depicts 
edge added graph clone families propagated 
clone families exp node pushed arrow node 
constraints added network clone families originally seeded type variables flow 
eager propagation ensures subset relations type exp type hold clone family added type exp immediately propagated type subset relation 
adding constraints propagation necessary 
reverse holds propagation receiver type send grow dynamic dispatch means send may invoke new methods constraints needed 
step consists repeatedly establishing constraints propagating done 
ensure soundness constraint generated possible data flow target program 
different languages different constructs produce data flows general examples examples assignments generate data flows new value expressions assigned variables :10.1.1.48.5515
variable reads generate data flows accessed variables accessing expressions 
message sends generate data flows actual argument expressions including receiver formal arguments invoked methods 
furthermore data flows return results invoked methods message sends 
primitive data types integers floats operations including built control structures 
templates introduced templates study previously published type inference algorithms analyze polymorphism 
templates enable concise exposition new algorithm review 
just methods raise abstraction level encapsulating statements templates raise abstraction level encapsulating constraints 
starting unstructured constraint graph produced basic type inference algorithm carve number subgraphs corresponding method target program 
subgraphs templates 
precisely template method subgraph consisting nodes type variables corresponding expressions local variables formal arguments fig 

situation establishing constraint propagating 
edges constraints originating nodes 
nodes corresponding instance variables part template instance variables belong particular method type course 
remainder template level avoid complexity dealing myriad individual constraint 
example template consider max method top number hierarchy self system safe ignore method contains blocks discuss briefly appendix max self iftrue self false 
shows template method 
box input type variables top corresponding formal arguments self type variable result bottom 
result type determined contributions iftrue false templates conditional statement self send iftrue false false true connections templates iftrue false methods false true respectively 
simplify picture omitted constraints comparison self constraints propagating result self slots iftrue false templates 
illustrates send max connected max tem plate 
inference algorithm determines send type propagating actual argument types template method may invoked 
send may invoke methods type union result types methods 
polymorphism analyzed imprecisely basic algorithm turn attention polymorphic methods 
shows happens target program contains sends max integer arguments float arguments 
basic algorithm infers type smallint float sends 
imprecise invoking max integers obviously produce float vice versa 
problem different types smallint float merge produce type smallint float input type variables max template 
merge causes information loss merged types easily separated result imprecise types sends invoking max full union type 
previous improvements basic algorithm problem basic algorithm creates max template 
type general imprecise accommodate uses max 
algorithm basic analyzes method called monovariant 
improved algorithms polyvariant may analyze methods multiple times creating template 
max fig 

template max method send connecting 
type send determined propagating types actual arguments template 
self self result max smallint iftrue false level level expansion algorithms palsberg schwartzbach saw limitations basic algorithm proposed polyvariant improvement 
level expansion connect different sends target program different templates 
example max sends target program max templates created send 
intuition different sends may supply actual arguments different types share template causes types merge 
intuition problems level expansion 
inefficient due redundant analysis 
different sends selector supply argument types sends add integers 
level expansion algorithm recognize unnecessarily re analyzes integer addition method send 
self integer addition method trivial handles type coercions overflows 
second precision inadequate 
shows level expansion just imprecise basic algorithm applied sends computing maxima integers floats 
difference merging happens pair iftrue false templates shared max templates 
templates shared send iftrue false max method 
obvious way improve precision avoid sharing iftrue false templates level expansion 
allows precise type inference situation shown max max fig 

basic algorithm infers imprecise type smallint float sends max computes max integers max floats 
self self result max smallint float iftrue false max fig 

level expansion algorithm creates max template sends single send iftrue false max templates share pair iftrue false templates types merge 
self self result max smallint float iftrue false max self self result max smallint float inefficient second expansion worsens redundancy problems 
code fragments precisely analyzed method invokes max twice compute max numbers receiver max max self max max 
method defeats level expansion having deep polymorphic call chain max max max iftrue false 
general level expansion algorithm precise polymorphic call chains calls deep worst case complexity exponential expansion incurs quadratic cost increase 
vitek described algorithm concept call strings phillips shepard applied parcplace smalltalk 
iterative algorithm iterative algorithm plevyak chien broke unfavorable precision efficiency trade inherent expansion algorithms 
simultaneously improved precision efficiency allowing variable amount expansion different parts program 
understand algorithm assume analyzing sends rcvr max arg rcvr max arg consider question safe connect sends shared template 
answer sends share template safely loss precision type rcvr type rcvr type arg type arg 
call algorithm answers sharing question test ideal 
precise allows different types merge efficient avoids redundant analysis sharing template sends invoke method actual arguments types 
unfortunately algorithm ideal regard implemented 
reason types compares decide shared template types computed 
words ideal algorithm needs know types compute 
plevyak chien way dilemma iterating type inference 
iteration basic algorithm 
subsequent iterations ideal algorithm sharing test approximated types previous iteration 
sends share template iteration type rcvr type rcvr type arg type arg 
iterative algorithm precise handle arbitrarily deep polymorphic call chains iterations iterations precision level expansion algorithm 
iterative algorithm achieves precision lower expected computational cost selectively expands program needed avoid non equal types merging calls 
iteration improving precision drawbacks 
overhead iteration possibly slowing type inference factor roughly equal number iterations required 
implementation complexity may issue nontrivial map type information iterations program expanded differently 
particular maintaining validity previous iteration type information downstream method expanded current iteration challenge 
hard know iterating 
principle pr length longest polymorphic call chain precision improvements possible 
reality situation complex due block specialization recursion see appendix 
cartesian product algorithm previous algorithms aim obtain precision efficiency partitioning sends types actual arguments 
iterative algorithm reaches goal incurs overhead iteration harvest timely type information needed analysis 
cartesian product algorithm cpa short fundamentally different 
partition sends turns analysis send case analysis 
send analyze cpa computes cartesian product types actual arguments 
tuple cartesian product analyzed independent case 
exact type information available case immediately eliminates need iteration 
turn type information ensure precision avoiding type merges efficiency sharing cases avoid redundant analysis 
description cpa mainly compare iterative algorithm powerful algorithms 
idea cpa best understood going back analogy program execution program analysis 
program execution activation records created simply slot contains single object 
consider example polymorphic send invokes max method integer float receivers 
means send invokes max integer receiver times invokes float receiver 
particular invocation receiver integer float 

summarize observation follows thing polymorphic call polymorphic call sites 
cpa previous algorithms exploits observation 
cpa creates monomorphic templates 
send rcvr max arg 
type rcvr type arg 
suppose known 
general course types fully known type inference motivation iterative algorithm 
section explain possible types iterating approximating 
analyze send cpa computes cartesian product receiver type argument types 
case argument cartesian product set pairs 
general set tuples number arguments 

cpa propagates separate max template 
max template exists pair reused template exists new created available pairs sends 
type send obtained union result types templates send connected 
illustrates situation concrete objects single send 
self implementation dictionary method organize templates 
templates method matter send invoking caused creation stored dictionary 
dictionaries keyed tuples allow fast retrieval template corresponding tuple 
structures analysis send proceeds follows 
determine methods send may invoke 

generate cartesian product lazily described section 

method tuple cartesian product look template dictionary 
matching template create add dictionary 

connect send new old template 
obtain efficient terminating 
algorithm necessary maintain method pools templates send pools ensure different sends cartesian products tuples common share templates 
worth noting template dictionaries filled advance 
templates added gradually new argument combinations tuples encountered analysis sends target program 
fact possible know advance templates going needed 
clear gradually analysis progressing 
cpa exact type information iterating explain cpa types arguments receivers process computing 
iterative algorithm way dilemma iterating approximating types computed previous iteration 
cpa avoids dilemma altogether approximations iteration 
achieved 
key iterative algorithm comparing types find share templates cpa computes cartesian products 
cartesian product type comparison computed correctly albeit gradually types partially known analysis 
specifically send processed cartesian product current members receiver argument types computed connections relevant templates 
types grow cpa goes back extends cartesian product new combinations possible 
yields correct solution types grow monotonically type inference 
illustration assume started situation shown new clone family rational just arrived type argument 
extend cartesian product new pairs int rational float rational 
propagate pairs new old max templates collect new possible result types 
illustrates 
key properties allow cpa avoid iteration 
cartesian product monotonic function 
grows cartesian product grows 
second cartesian product applied monotone context cartesian product grows correct compensating action grow constraint network 
cpa manages preserve monotonicity run single pass occasion regret previous action 
iterative algorithm contrast breaks monotonicity comparing max max max max send rcvr max arg type rcvr int float type arg int int int int float int float int float fig 

cpa forms cartesian product receiver type argument types send analyzing 
member product propagated template reserved exclusively receiver argument combination 
result type send obtained collecting contributions template 
types equality monotone function 
buy back monotonicity plevyak chien pays price iteration 
seen light level expansion algorithms form family algorithms apply particularly simple monotonic functions decide share 
functions depend types inferred merely static program text 
algorithms called non adaptive uniformly apply effort target program focusing parts complex polymorphism 
iterative algorithm cpa adaptive type information inference concentrate analysis effort demanding parts target program 
hash function algorithm described hybrid level expansion cartesian product algorithm 
applies case analysis receiver types cpa uses level expansion non receiver arguments 
hash algorithm adaptive uses receiver types analysis 
algorithms hybrid monotone implemented pass 
assessing cartesian product algorithm cpa precise sense analyze arbitrarily deep polymorphic call chains loss precision 
reason cpa creates monomorphic templates allows different tuples sends propagated template 
words merging matter deep call chain cpa efficient redundant analysis avoided 
seen key avoiding redundancy sharing 
time pair occur call max connected shared template 
combination specific receiver argument analyzed 
contrast iterative algorithm may generate templates overlapping types template type self int float type arg int rational template type self int float type arg int max max max max max max send rcvr max arg type rcvr int float type arg int rational int int int float int float int rational float rational int float rational fig 

cartesian product algorithm tolerates growing types way type receiver argument grows cartesian product extended send connected additional templates 
new structures shown bold 
situation cpa generates templates iterative algorithm versus 
necessarily mean cpa slower templates generates singleton types receiver arguments processed faster templates larger types 
scaling issues iterative cartesian product algorithms may problems analyzing large programs extremely rich polymorphism 
give scenarios 
favors cpa 
simplicity consider method argument straightforward generalize arbitrary number arguments 
assume set possible receivers arguments method drawn domains possible receivers possible arguments worst case iterative algorithm may generate exponential number templates subset templates subsets subsets 
cpa contrast generates polynomial number templates member pq templates 
far encountered worst case scenario programs analyzed 
second scenario favors iterative algorithm 
assume target program contains send receiver arguments 
type smallint float 
cartesian product size extreme case attempting compute cartesian product mention creating templates bad idea 
encountered extreme polymorphism apply test determine danger starting unreasonably large computation receiver actual argument type test size small number 
useful values range different values receivers arguments possibly letting value depend number arguments send arguments smaller limit appropriate 
say argument receiver fails test 
arguments occur full cartesian product longer computed 
create tuples form star indicates argument 
tuple propagated template star expanded full type 
contraction arguments effective technique avoid large cartesian products cases mentioned collapsed single monovariant analysis 
cost course may loss precision 
limit loss templates shared sends arguments avoid polluting non cases 
loss limited applying expansions iteration cases 
practice exact choice matter 
offer possible explanations 
rare 
measuring number self programs sends argument limit 
precision lost sends consequences limited 
second plausible programmer writes send kinds arguments may distinct cases mind dozen kinds probably exploiting uniform behavior turn limits loss precision cases merged analysis 
case cartesian product algorithm improves precision iterative cartesian product algorithm avoid losing precision due merging types property cpa analyzes argument combination gives precision edge 
consider method mod arg self arg self div arg 
assume div denotes integer division division operator fails receiver argument integer 
consider analysis send mod context type type smallint float 
iterative algorithm infer type mod smallint float cartesian product algorithm infer precise type smallint 
iterative algorithm analyzes mod connecting mod template type self arg smallint float 
proceeds find type self div arg smallint div fails floats 
far precision optimal 
iterative algorithm determines type arg self div arg 
arg type smallint float type product smallint float 
turn type inferred self arg self div arg smallint float type mod smallint float 
cpa analyzes mod connecting templates tuple cartesian product types template self arg type smallint straightforwardly result type smallint 
templates empty result types type self div arg empty div fails floats integer backup 
cpa combines smallint empty result types find type mod smallint 
mod method chosen expose property cpa similar structures conceivably embedded complex situations 
argued enhancements iterative algorithm allow cases analyzed precisely 
example graver johnson case analysis methods analyze similar structures precisely 
find preferable strive best precision available tool constraints consider enhancements truly needed 
inheritance terminology readers familiar give examples class language section 
inheritance important code reuse mechanism object oriented programming 
inheritance way attains substitutability ensures instance subclass instance superclass expected 
substitutability may enforced language self 
inheritance restricted manner fact remains expressions inherited methods may different types context subclass context superclass 
instance message sent self may bound differently method inherited causing type change 
simpler example method returns self display method implemented points inherited coloured points 
left hand side illustrates situation 
naively type inferred display point may applied point coloured point 
propagating type send invokes display coloured points imprecise send type 
compiler writers facing issue solutions customization idea recompile method class inherits class self known compiled code 
previous type inference algorithms object oriented languages achieved similar effect preprocessor eliminate inheritance 
preprocessor copies methods classes inheriting 
result expansion shown right hand side identical methods display point display applies points result type point 
applies coloured points result type 
send invokes display exclusively coloured points type send connected templates display 
expanding away inheritance improves precision inaccuracies resulting analyzing single method context classes avoided 
expansion expensive 
worst case program size increases quadratically programs single inheritance 
care taken handle overridden methods correctly including sends super resends 
self additional complications non trivial eliminate inheritance state mention dynamic inheritance expansion 
cartesian product algorithm removes need expansion 
analyze unexpanded program precision expanded 
reason cpa algorithms creates templates type self exactly member cpa analyzes method context class time avoiding inheritance expansion advantages simplicity 
reuse existing mechanism cartesian product applying special purpose mechanism deal inheritance 
efficiency 
templates created needed static expansion assumes method invoked class inheriting 
optimizing expansion possible course 
generality 
cartesian product handles inheritance state dynamic inheritance multiple inheritance 
supports languages multiple dispatch multi methods straightforward extension single dispatch case cartesian product generated tuple propagated template specific method implements operation combination arguments tuple 
summary table important attributes algorithms discussed 
hash algorithm included show fits touched briefly 
efficiency column informal extensive measurements theoretical complexity studies algorithms require statistical model typical programs polymorphism 

hash function algorithm property restricted singly dispatched languages 
algorithm efficiency precision advantages contributions drawbacks basic fast inadequate simple monovariant imprecise level expansion slow meager polyvariant algorithm fails polymorphic call chains length level expansion slow parameterized cost precision trade gets slow reaching high precision redundant hash fast handling polymorphic receivers polymorphic arg need ad hoc rules iterative medium better better cost precision trade previous algorithms iteration overhead complex cpa fast better non iterative partition sends scaling 
table 
summary type inference algorithms 
class point method display class class point method display point class method display inheritance expansion fig 

type inference algorithms cpa expand away inheritance gain precision 
expansion copies inherited methods subclasses 
measurements implemented tested type inference algorithms basic level expansion cartesian product algorithm iterative algorithm implementation consists lines self source code addition type inference parses byte codes expression trees performs grouping see appendix incremental analysis ssa transformation application extraction 
applied inference algorithms existing programs self system factorial invocation recursive factorial function shown 
richards operating system simulator 
deltablue multi way constraint solver 
diff mario wolczko self version unix diff command 
programs analyzed unmodified exception patch mirror primitive return mirror mirrors way write reflective code self reflection partially supported type inference implementation 
patch basic level expansion algorithm get lost reflective part self system 
patch removed running inference algorithms precise avoid falling reflective trap programs self contained 
reuse extend existing objects data structures 
example factorial method line source needs implementation comprises hundreds lines 
obtain useful measure program size applied extractor described measured size resulting self contained source files 
counting including variable definitions blank lines names spaces factorial lines richards lines deltablue lines diff lines 
counting method bodies statements expressions factorial lines richards lines deltablue lines diff lines 
extractor type inference property precise type information forces extract 
plugged type inference algorithms extractor measured lines methods extracted test program 
results shown table 
general cpa delivers smallest extractions indicating precise inference method 
diff expansion algorithm improves dramatically increased shows little additional gain past 
increasing line counts factorial richards deltablue explained removal reflective patch 
numbers table important indicating type inference precision 
compiler type inference compiles fewer methods uses cpa algorithms note current self compiler type inference 
table compares cpu times type inference algorithms measured mhz sparcstation 
focus type inference algorithms se time spent grouping objects omitted 
cpa consistently fastest fairness best tuned implementations 
remarkably faster basic algorithm analyzing simpler patched programs 
expansion algorithms opposing trends battle increases 
hand precision improves enabling analysis stay 
implemented iterative algorithm self include direct comparison 
refrained comparing numbers published plevyak system implemented different language self possibly efficient analyzes different benchmarks written different language 

pure form iterative algorithm need patch iteration basic algorithm 
basic level level level level level cpa factorial richards deltablue diff table 
number source lines methods extracted 
clear irrelevant code part application 
speeds type inference 
hand redundancy increases acting slow type inference 
effect trend wears cost redundancy shows 
note basic algorithm times lower bounds iterative algorithm iteration basic algorithm 
essential obtain precision hurts efficiency 
table contains numbers algorithm program combination average number times method analyzed number templates divided number methods average number times expression analyzed 
second number allows large method weigh heavier average 
degree cpa level expansion algorithms cpa faster algorithms monomorphic templates processed faster 
paying price certain amount 
table shows average type sizes expressions 
averages polyvariant domains expression analyzed twice counts twice average 
cpa achieves lowest sizes compared level expansion algorithms analyze expression times see table 
expansion algorithms improvements particularly clear table 
conclude empirical results amusing see types inferred algorithm expression factorial 
shown basic algorithm inferred smallint collector memory float link list time false true nil blk blk blk 
level expansion algorithm slightly better smallint collector float link list time false true nil 
surprisingly level expansion algorithm significantly better perfect smallint float 
level algorithms inferred type level algorithm 
cpa inferred smallint 
basic level level level level level cpa factorial richards deltablue diff table 
type inference time seconds cpu time mhz sparcstation 
basic level level level level level cpa factorial richards deltablue diff table 
number times method expression analyzed 
basic level level level level level cpa factorial richards deltablue diff table 
average size types expressions 
cartesian product algorithm 
key insight cartesian product monotonically soundly decompose analysis send number monomorphic cases 
decomposition accurately mirrors situation program execution time activation records monomorphic 
advantages precision sharpened methods analyzed precisely monomorphic contexts 
measurements additionally show cpa achieves smallest average size inferred types 
efficiency improved monotonicity cartesian product allows pass implementation redundant analysis done 
sends partially overlapping types share analysis cases 
measurements show cpa faster basic algorithm 
generality improved 
algorithms expand away inheritance cpa handles directly permitting precise analysis wider range languages including ones inheritance state dynamic inheritance multiple inheritance multiple dispatch 
simplicity preserved 
core algorithm familiar cartesian product 
expansions required inheritance elimination unnecessary iteration mapping type information differently expanded versions target program avoided 
cpa addresses parametric polymorphism 
improve analysis code data polymorphism better worse regard basic algorithm 
done data polymorphism 
number algorithms published target data polymorphism 
analogous analyzing parametric polymorphism copying methods algorithms copy classes attempt keep different uses data polymorphic instance variables separate 
example proposed level class expansion phillips shepard generalized levels plevyak chien developed iterative algorithm 
cpa address data polymorphism conflict existing algorithms analyzing data polymorphism 
practical combine cpa algorithms obtain comprehensive type inference system 
particularly interesting question investigate iterative data iterative combination compares cartesian product data iterative combination 
answer obvious 
combination may practice kinds iterations develop constraint network parallel 
combination may excel cpa strong handling parametric polymorphism clears away brush giving data iterative part immediate access dig potatoes 
acknowledgments 
lars bak craig chambers bay wei chang ole lehrmann madsen john mitchell ivan moore david ungar jan vitek mario wolczko discussions comments earlier drafts referees feedback submitted version 
author generously supported natural science faculty aarhus university danish research academy sun microsystems laboratories 
self project supported nsf pyi ccr sun microsystems ibm apple computer cray laboratories tandem computers ncr texas instruments dec 
agesen constraint type inference parametric polymorphism 
sas international static analysis symposium namur belgium sept 
springer verlag lncs 

agesen bak chambers chang hlzle maloney smith ungar wolczko 
self self programmer manual 

sun microsystems laboratories garcia avenue mountain view ca usa 
available anon 
ftp self stanford edu www self stanford edu 

agesen palsberg schwartzbach type inference self analysis objects dynamic multiple inheritance 
ecoop seventh european conference object oriented programming kaiserslautern germany july 
springer verlag lncs 

agesen ungar sifting gold delivering compact applications exploratory object oriented programming environment 
oopsla object oriented programming systems languages applications portland oregon oct 

bobrow kahn kiczales masinter stefik merging lisp object oriented programming 
oopsla object oriented programming systems languages applications portland oregon sept 

chambers object oriented multi methods cecil 
ecoop sixth european conference object oriented programming june utrecht netherlands 
springer verlag lncs 

chambers ungar making pure object oriented languages practical 
oopsla sixth annual conference object oriented programming systems languages applications phoenix arizona oct 

chambers ungar lee efficient implementation self dynamically typed object oriented language prototypes 
lisp symbolic computation kluwer academic publishers june 
originally published proc 
oopsla 

cousot cousot interpretation unified lattice model static analysis programs construction approximation fixpoints 
conference record fourth acm symposium principles programming languages jan 

graver type checking type inference object oriented programming languages ph thesis university illinois urbana champaign 

graver johnson type system smalltalk 
conference record seventeenth annual acm symposium principles programming languages san francisco california jan 

hunt szymanski fast algorithm computing longest common subsequences communications acm may 

hlzle static typing important efficiency 
palsberg schwartzbach eds 
types inheritance assignment technical report daimi pb computer science department aarhus university denmark june 

hlzle ungar optimizing dynamically dispatched calls run time type feedback 
pldi conference programming language design implementation orlando florida june 

johnson type checking smalltalk 
oopsla object oriented programming systems languages applications portland oregon sept 

milner theory type polymorphism programming 
journal computer system sciences 

palsberg schwartzbach making type inference practical 
ecoop sixth european conference object oriented programming utrecht netherlands june springer verlag lncs 

palsberg schwartzbach object oriented type inference 
oopsla object oriented programming systems languages applications phoenix arizona oct 

phillips shepard static typing explicit types 
technical report dept electrical computer engineering royal military college canada kingston ontario canada 

plevyak chien precise concrete type inference object oriented languages 
oopsla object oriented programming systems languages applications portland oregon oct 

plevyak zhang chien obtaining sequential efficiency concurrent object oriented programs 
conference record nd symposium principles programming languages san francisco california jan 
maloney freeman benson borning multi way versus way constraints user interfaces experience deltablue algorithm 
software practice experience may 

suzuki inferring types smalltalk conference record eighth annual acm symposium principles programming languages williamsburg virginia jan 

ungar smith self power simplicity 
lisp symbolic computing kluwer academic publishers june 
originally published proc 
oopsla 

vitek horspool uhl compile time analysis object oriented programs 
compiler construction th international conference cc paderborn germany oct springer verlag lncs 
appendix appendix discusses issues encountered years type inference 
tackling important obtain type inference results central understanding cpa discuss briefly appendix 
issues specific cpa self 
incrementality 
fast type inference essential applications support browsing program development 
large speedup achieved reusing templates analysis 
method target program modified templates flushed templates kept 
program fast needed templates exist 
speedups observed programs shared code needs analyzed 
take arithmetic 
program uses arithmetic forces analysis methods implementing arithmetic 
subsequent programs analyzed faster connected arithmetic templates created analysis 
incremental analysis may precise full analysis care taken avoid assignments global state visible analyses 
blocks closures precision 
expressions blocks may access slots lexical environment 
retain precision accesses analyzed precisely 
blocks max method access slots lexical environment max self iftrue self false 
slot denote slot read expression reads slot block 
type type slot expression template assume max templates type self type slot int type self type slot float 
type read 
simple approach assume read may access slot max tem plate type read type slot type slot int float 
unfortunately precise types inferred pessimistic assumption 
better analysis closely parallel execution 
invoking max integer argument creates activation record bound integer 
block evaluated result closure lexical pointer set activation record 
closure invoked lexical pointer retrieve value improve type inference precision phase evaluation blocks simulated 
templates correspond activation records create type inference time closures lexical pointer referring template 
closure analyzed lexical pointer find type read type slot int 
possible infer precise types 
approach specific self smalltalk style blocks applies pascal nested procedures scheme closures beta nested patterns 
closures termination 
precise way analyze blocks may result non termination type inference adaptive type inference algorithm iterative algorithm cpa 
reason new templates result creation new block closures turn may result creation new templates 
simplest example method invokes closure foo blk foo blk value 
complicated cases involve indirect recursion 
plevyak chien discuss 
general solution break infinite computation creating cycle constraint graph 
closures efficiency 
efficiency type inference highly sensitive number closures created 
due self amplification closures result templates turn result closures consequently create closures possible 
outlined simple approach having single closure block imprecise 
way reduce number closures impairing precision fuse closures safe 
assume templates max type self int type slot float type self float type slot int 
max templates closures blocks self suffice 
reason types block depends type slot type creating closures saves analysis effort turn necessitate fewer iftrue false templates 
optimization complicates matters closures analysis time execution time may scopes 
self performance gain high worth added complexity 
reaching definitions 
assignments non destructive type inference 
erase old type slot assign clone families keep accumulating types assignable slots 
conservatism necessary general better 
increasingly powerful approaches eliminate dead initializers static single assignment ssa form propagate definitions call graph constructed type inference 
self implementation tested approaches local slots 
instance slots harder deal may aliased represent multiple locations 
simple elimination unused initializers pays significantly ssa slightly better 
suspect local slots initialized nil immediately assigned useful simply getting rid nil type slot achieves obtained 
coupled arguments 
assume type int float type int float 
send connects templates tuples cartesian product types contrast send connect templates int int float float receiver integer argument form send enforces receiver argument object 
receiver argument coupled 
coupling need involve exact object just objects bound clone family 
general determining arguments coupled computable safe approximations possible 
implemented simple approximation marginal effect analysis typical self programs possibly need powerful detection just coupling rare 
grouping 
self type inferencer analyzes image objects programmer written source code 
consequently may encounter similar objects image point objects part graph display 
inferring types object individually computationally infeasible 
overcome problem group objects structural similarity inferring types 
grouping may cost precision speeds inference members group analyzed parallel 
