appear information computation 
safety analysis versus type inference jens palsberg michael schwartzbach palsberg daimi aau dk mis daimi aau dk computer science department aarhus university ny munkegade dk denmark safety analysis algorithm determining term untyped lambda calculus constants safe cause error evaluation 
ambition shared algorithms type inference 
safety analysis type inference different perspectives 
safety analysis global analyze complete program 
contrast type inference local analyze pieces program isolation 
prove safety analysis sound relative strict lazy operational semantics 
prove safety analysis accepts strictly safe lambda terms type inference simple types 
result demonstrates global program analyses precise local ones 
compare techniques analyzing safety terms untyped lambda calculus constants see 
safety concerned absence run time errors arise misuse constants attempt compute true 
consider just constants succ 
misused applying number argument applying succ abstraction 
safety undecidable sound analysis algorithm reject safe programs 
succ lambda calculus 
way achieving safety guarantee perform type inference term typable safety guaranteed 
propose technique shall simply call safety analysis closure analysis called control flow analysis perform type reconstruction 
prove new technique sound accepts strictly safe lambda terms type inference simple types 
results illustrated 
examples lambda terms demonstrate strictness established inclusions 
type inference accepted terms normal form pure terms accepted safety analysis safe relative lazy semantics safe relative strict semantics sets safe lambda terms 
safety analysis may alternative type inference implementations untyped functional languages 
apart safety property type inference computes actual type information may useful improving efficiency implementations 
safety analysis similarly computes closure information useful improving efficiency 
type inference lambda calculus implemented linear time polymorphic 
safety analysis implemented worst case cubic time 
practice program abstraction program takes input variable yields value obtained evaluating body analysis program take possible inputs account 
technical reasons assume lambda terms analyzed take input free variables 
means program analyzed analyze free occurrences variable corresponds input 
example consider program written larger language give formal treatment 
program analyzed analyze assumption input free variables convenient defining constraints inputs 
notion free variable independent form lambda term analyzed 
henceforth assume lambda terms put appropriate form 
safety analysis type inference different perspectives 
safety analysis global analyze complete program takes firstorder values inputs 
contrast type inference local analyze pieces program isolation 
comparison techniques demonstrates global program analysis precise local 
safety analysis analyze programs take order values inputs course limitation 
practice represent higher order input order data structure 
example done bondorf partial evaluator similix gomard jones partial evaluator lambda mix 
partial evaluator applicable higher order subset scheme lambda calculus constants 
similix example contains parser transforms scheme programs order representation 
advantage local analysis modular incremental new routines added program creating need re analyze program 
complete program analyzed greater precision safety analysis may provide safety guarantee situations type inference fails 
safety analysis may practice useful language scheme run time tagging tag checking type inference 
safety guarantee provided run time tag checks eliminated 
safety analysis steps 
basic form analysis type inference analyzes subterms term 
extend analysis device detecting avoiding analysis dead code 
dead code subterm term evaluated strict lazy evaluation 
example subterm dead code 
extended safety analysis accept abstractions body dead code 
avoiding safety analysis dead code may useful practice 
example program uses small part large library routines routines need analyzed 
saves time avoids possible type errors routines called 
basic safety analysis may interesting conjecture analysis sound respect arbitrary fi reduction 
treat constants succ safety analysis technique results generalized handle arbitrary constants 
technical reasons convenient succ require argument desired combinator version programmed succ polymorphic constants treated manner similar treat lambda abstractions 
section recall definition type inference section introduce definition safety analysis 
section give soundness proofs safety analysis section give proof comparison safety analysis type inference 
type inference common notion practical type inference shall compare safety analysis type inference simple types 
polymorphic treated doing syntactic expansion type inference 
mairson mitchell proved expansion may exponentially increase size program type inference algorithm polymorphic better worst case complexity 
expansion similarly performed safety analysis 
ff int type schemes 
straightforward presentation simple type inference due wand follows 
lambda term ff converted bound variable distinct 
second type variable assigned subterm variables range type schemes shown 
third finite collection constraints variables generated syntax 
constraints solved 
constraints generated inductively syntax shown 
ti denote collection constraints subterms 
phrase constraint int succ succ int constraints type variables 
finite collection constraints solved unification yielding general solution 
solution exists program typable 
soundness syntactic completeness algorithm known 
ti constraint system term shown 
term running example section 
constraints int solution int int int int int int ti constraints 
safety analysis safety analysis closure analysis called control flow analysis jones shivers 
closures term simply subterms corresponding lambda abstractions 
closure analysis approximates subterm set possible closures may evaluate 
basic form safety analysis simply closure analysis appropriate safety checks 
safety analysis essentially similix partial evaluator 
having basic analysis proceed extending detection dead code 
involves notion trace graph 
safety analysis algorithms share similarities type inference 
lambda term ff converted bound variable distinct 
means closure denoted unique token second type variable assigned subterm variables range sets closures simple type int 
third finite collection constraints variables generated syntax 
constraints solved 
safety analysis type inference differ domain constraints specified manner generated syntax 
previous successfully applied safety analysis substantial subset object oriented language smalltalk demonstrating deal inheritance assignments conditionals late binding basic safety analysis remaining consider fixed lambda term denote lambda finite set lambda tokens constraint system generate type variables range subsets union lambda fintg :10.1.1.136.9764
constraints generated syntax see 
conceptual aid constraints grouped basic safety connecting constraints 
phrase basic constraints fxg fintg succ succ fintg phrase safety constraints lambda succ fintg phrase connecting constraints safety analysis 
connecting constraints reflect relationship formal actual arguments results 
condition states inclusions relevant closure denoted possible result sa denote global constraint system collection constraints subterm 
safety constraints excluded remaining constraint system denoted ca yields closure analysis 
sa constraint system term shown 
assume lambda term takes input free variables 
term safety analyzed take order values inputs 
means free variable input taken add initial constraint int ti constraint system add initial constraint fintg sa constraint system 
solution constraint system assigns set variable constraints satisfied 
solutions ordered variable wise set inclusion 
ca system solvable inclusion form obtain maximal solution assigning lambda fintg variable 
closure information obtained lambda term 
contrast sa need solvable lambda terms safe 
proved subsection sa solution minimal 
ayers cubic time algorithm computes essentially minimal solution ca 
straightforward incorporate algorithm checks yielded safety constraints 
ayers algorithm applies extension safety analysis consider 
sketch cubic time algorithm similar ayers computes minimal solution sa decides exists 
indicate modified deal extension 
constraints fyg fxg fintg fx yg fx yg minimal solution fintg fxg fyg sa constraints 
detection dead code dead code subterm term evaluated strict lazy evaluation 
intuitively dead code may near leaves syntax trees strict lazy evaluation top evaluation strategies 
extend basic safety analysis detects dead code avoids analyzing code 
approach detection dead code essentially add conditions constraints yielded basic safety analysis 
constraint system solution terms deemed safe 
explain addition conditions means trace graph 
define need auxiliary notion local nodes parse tree arbitrary lambda term shall call parse tree node local reached root parse tree passing lambda abstraction 
illustrated 
define trace graphs 
intuitively nodes correspond functions edges correspond possible applications 
definition trace graph associated lambda term directed graph ffl nodes 
abstraction node denoted corresponding lambda token node denoted main 
local subterms said occur main similarly local subterms abstraction said occur trace graph node abstraction 
trace graph node labeled basic safety constraints see previous subsection generated local expressions 
ffl ffi fi fl ffl ffi fi fl ffl ffi fi fl omega omega omega omega omega omega omega omega omega omega omega omega omega omega omega omega omega omega omega xi xi xi gamma gamma pi delta delta delta delta delta delta delta delta delta local local local local nodes parse tree 
ffl edges 
trace graph node occurs directed edge trace graph node abstractions main 
notice node outgoing edge local application 
edges labeled conditions connecting constraints follows 
edge yielded application edge leads node abstraction edge labeled condition connecting constraints 
notice number edges quadratic number nodes 
trace graph term shown omitting connecting constraints avoid clutter 
trace graph derive finite set global constraints 
intuitively set union constraints potential top evaluation sequence 
potential top evaluation sequence represented trace graph path main node 
path illustrated omits constraints avoid clutter main delta delta delta constraints derive path local connect local local constraints final node connect connecting constraints final edge gamma gamma 

oe main fx yg fxg fyg fintg fx yg trace graph 
notice may infinitely paths main node 
yield redundant constraints condition appears 
derive constraints paths edges 
yields finite constraint system solvable constraint system generated paths solvable 
notice constraints normalized linear time set constraints form normalization proceeds rewriting constraints form rewriting constraints possibly empty conjunction conditions inclusions 
sar reachability denote global finite constraint system 
car denote subset sar safety constraints excluded 
proposition sar solution unique minimal 
proof result follows solutions closed intersection 
see consider conditional inclusion form fl solutions 
shall show solution 
condition true 
conditions true true furthermore solutions true general implies follows solution 
solutions unique smallest 
subset sa constraint system previous subsection obtained sar deleting conditions basic safety constraints deleting constraints local main fyg fxg fx yg connecting main connecting main local fintg fx yg connecting connecting connecting minimal solution fintg fxg fyg sar constraints 
final conjunct conditions connecting constraints 
subset obtained constraints dead code may appear sar follows sar solvable sa 
set global constraints term 
notice similarities differences shows sa constraints term 
example term accepted safety analysis detection dead code rejected consider 
trace graph edge main unsafe application unreachable 
reflected global constraint system consists constraint fxg 
clearly constraint system solvable 
solving constraints sketch cubic time algorithm computes minimal solution sa constraint system decides exists 
indicate modified handle detection dead code 
input algorithm finite set constraints constraint forms lambda token set lambda tokens variables 
notice constraints size lambda term constraint system generated 
algorithm phases 
phase constraint form inserted data structure solver 
notice omit constraints form remaining constraints solution 
second phase extract solver minimal solution inserted constraints check constraints form satisfied 
process inserting constraints solver represents minimal solution constraints inserted far 
implementation solver uses directed graph henceforth called graph 
ffl nodes graph correspond type variables ffl edges graph correspond inclusions type variables 
graph nodes type variables correspondence 
graph node type variable represents set lambda tokens type variable currently assigned 
represent set lambda tokens bitvector entry lambda token 
entry associate list constraints form list handle insertion constraints form explained 
organization graph node illustrated follows 
graph node bitvector idea graph lambda token inserted set inclusions automatically maintained 
involves propagating bits edges 
bit set constraint associated list removed inserted solver 
initially graph node represents empty set lists constraints empty 
consider insert constraints 
ffl consider constraint form union set bitvector graph node maintain inclusions recursively insert constraints contained lists associated newly set bits 
ffl second consider constraint form create graph edge node node maintenance inclusions recursive insertion previous case 
ffl third consider constraint form set contains recursively insert constraint solver 
insert list associated bit graph node implementation solver time complexity inserting constraints solver size lambda term constraint system generated 
see observe bit propagated edge 
edges cost maintaining inclusions time 
remaining constant constraint constraints arrive time 
second phase algorithm extract time minimal solution solver check time constraints form satisfied 
total algorithm runs time 
handle detection dead code modify phase algorithm follows 
idea mark trace graph node dead live 
initially main node live 
extend solver operation live trace graph nodes 
operation extract set trace graph nodes far marked live 
algorithm uses variable holds set trace graph nodes 
algorithm follows 

insert constraints main node solver 

solver live trace graph nodes choose solver live trace graph nodes 
insert constraints solver 
fmg 
solver maintains bitvector representing set trace graph nodes marked live 
conditional constraint carry lambda token potentially invoked lambda abstraction 
insertion operation solver maintain set live trace graph nodes follows 
insert constraint solver condition point satisfied potentially invoked trace graph node marked live 
clearly modified algorithm runs time 
soundness show safety analysis sound term accepted safe 
show soundness respect strict call value applicative order reduction lazy call name normal order reduction semantics lambda calculus 
simplicity prove soundness safety analysis closed terms 
see strict lazy cases imply consider lambda terms 
applicative order reduction yields infinite loop normal reduction yields error 
contrast applicative order reduction second yields error normal reduction yields infinite loop 
soundness respect reduction strategies imply soundness respect 
err loop loop err err loop delta delta delta xx lambda terms 
semantics untyped lambda calculus natural semantics involving sequents inference rules 
proofs soundness structure follows 
soundness environment lookup proved induction structure derivation trees 
second soundness closure analysis term called formed environment proved structural induction 
third formedness environments occurring sequent derivation tree proved induction depth sequents 
lemmas soundness closure safety analysis easily follows 
give proofs safety analysis extended detection dead code 
result immediately implies soundness basic safety analysis 
strict semantics strict operational semantics explicitly deals constant misuse 
evaluation constants yields result wrong 
semantics uses environments values simultaneously defined 
entire soundness argument fixed lambda term bound variable distinct 
denotes arbitrary subterm need terminology 
solution car subterms ambiguously denote 
say sequent ae ae val active occurs derivation tree main occur trace 
main 
ae val ae 
ae ae 
ae ae ae delta ae ae wrong 
ae ae wrong closure 
ae wrong ae wrong 
ae 
ae succ ae succ succ 
ae ae succ wrong number 
delta ae val 
ae val delta ae val strict semantics 

environment delta ae environment iff ffl value ffl ae environment 
succ value called number ae value called closure iff ffl ae environment wrong value environments values 
graph node exists path main node conditions hold predicate abs defined constraint variable value 
intuitively abs means description precise requirement ffl succ fintg ffl 
ae fxg 
notice abs wrong holds 
formedness wf environments values defined 
intuitively states environment value may occur safe evaluation lemma ae wf environment ae val active wf abs 

wf delta ae wf iff ffl bound ffl wf ffl ae wf ffl delta ae val active abs 
succ wf ae wf iff ffl subterm ffl ae wf ffl wf value delta ae wf delta ae active ffl wf wrong ffl abs formedness 
proof proceed induction structure derivation ae val base case consider rule 

delta ae wf follows wf 
val active follows abs 
induction step consider rule 
delta ae wf follows ae wf 
delta ae val active follows ae val active 
apply induction hypothesis immediate 
lemma ae wf environment ae active wf wrong abs 
proof proceed induction structure base consider succ consider rule ae active ae val follows lemma 
second consider rule 
ae active constraint fintg satisfied abs 
immediate wf 
third consider rules succ rule applied immediate 
rule applied ae succ active conclude constraint succ fintg satisfied abs succ succ 
immediate succ wf 
induction step consider consider rule ae ae active constraint fxg satisfied abs ae 
prove ae wf apply induction hypothesis immediate 
second consider rules rule applied immediate 
rule applied ae active conclude ae ae ae active wrong 
applying induction hypothesis get ae wf abs ae abs 
abs ae get 
means delta ae active connecting constraints hold 
follows ae wf ae wf 
prove delta ae wf need prove delta ae val active abs 
abs unconditionally true abs 
ae wf get wf wrong abs 
remains shown abs 
follows 
lemma sequent root occurring derivation tree main active environment component wf 
proof derivation tree main suffices prove sequents distance root active environment components wf 
proceed induction base observe sequent distance root see rule 
expression sequent occurs root node trace graph sequent active 
environment component wf 
induction step consider rules 
case assume sequent active environment component wf 
prove holds hypothesis sequents 
consider cases excluding rule 
hypothesis sequent cases expression occurs trace graph node expression sequent 
hypothesis sequent active 
cases environment components hypothesis sequents identical particular hypothesis sequent wf 
case immediate environment component hypothesis sequent wf 
consider rule 
immediate hypotheses active environment components wf 
notice trace graph edge node containing node labeled condition 
lemma get ae wf abs 
condition implies third hypothesis active connecting constraint holds 
remains shown delta ae wf 
ae wf get ae wf 
need show delta ae val active abs 
abs unconditionally true abs 
show closure analysis sound 
theorem ae occurs derivation tree main abs 
proof lemma follows ae active ae wf 
follows lemma 
show safety analysis sound 
theorem sar solvable main wrong 
proof note solution sar solution car suppose main wrong 
semantics easy see wrong introduced rule rule 
suppose rule 
theorem applied ae succ gives fintg 
lemma gives ae wrong active local safety constraint lambda holds 
yields contradiction 
suppose rule 
theorem applied ae 
ae gives fxg 
lemma gives ae succ wrong active local safety constraint fintg holds 
yields contradiction 
lazy semantics lazy operational semantics explicitly deals constant misuse strict semantics 
rule number keep numbering consistent strict semantics 

res main 
ae val ae 
ae ae 
ae res ae 
ae delta ae ae 
ae res ae wrong closure rule 
omitted 
ae 
ae res succ ae succ succ 
ae res ae succ wrong number 
delta ae val 
ae val delta ae val 
ae ae res thunk 
ae ae ae res ae res lazy semantics 

environment delta ae environment iff ffl value ffl ae environment 
succ value called number ae value called closure iff ffl ae environment wrong value ae value called thunk iff ffl ae environment environments values 
semantics uses environments values simultaneously defined 
new sort value thunks defined case 
thunks capture evaluation arguments delayed resumed 
semantics thunks introduced rule eliminated rules 
rules may understood defining operation res evaluates lambda term non thunk value 
notice rules res operation 
soundness argument uses terminology strict case 
need slight modifications notion activeness predicate abs notion formedness follows 
sequent ae res may active way ae ae val predicate abs holds iff ffl succ fintg ffl 
ae fxg ffl ae 
third case added handle thunks 
furthermore formedness wf environments values needs modified see 
compared notion formedness strict case added case handle thunks 
note lemma holds unchanged proof 
need replacement lemma follows 
lemma suppose ae wf environment 
ae active wf wrong abs 
furthermore ae res active wf wrong abs 
proof proceed induction structure base consider succ case proved way base case lemma 
prove case consider rules 
rule applied follows case 
rule applied follows case ae 
wf delta ae wf iff ffl bound ffl wf ffl ae wf ffl delta ae val active ffl abs 

succ wf ae wf iff ffl subterm ffl ae wf ffl wf value delta ae wf delta ae active ffl wf wrong ffl abs ae wf iff ffl subterm occurs trace graph node exists path main node conditions hold ffl ae wf ffl ae res active ffl wf wrong ffl abs formedness 
wf abs ae 
ae res active wf wrong abs 
follows 
induction step consider consider case proved way lemma 
case proved way case base case 
second consider case rule applied 
rule applied immediate 
rule applied ae active conclude ae ae active 
applying induction hypothesis get ae wf abs ae 
get 
means 
ae delta ae val active connecting constraints hold 
follows ae wf ae wf 
prove 
ae delta ae wf need prove ae wf 
ae delta ae val ae active abs ae 
follows applying induction hypothesis case second follows unconditionally true 
ae wf get wf wrong abs 
remains shown abs 
follows 
case proved way case base case 
note lemma holds simple changes proof leave reader 
soundness closure analysis lazy case expressed follows 
theorem ae occurs derivation tree main abs 
furthermore ae res occurs derivation tree main abs 
proof lemma follows ae active ae wf 
follows lemma 
similar argument proves second case 
soundness safety analysis theorem holds lazy case 
proof mutatis mutandis 
comparison show safety analysis accepts strictly safe terms type inference simple types 
proving lambda term ti constraint system solvable sar constraint system solvable 
proof involves lemmas see 
main technical problem solved sar ti constraint systems different domains sets closures versus types schemes 
direct comparison hard 
overcome problem applying solvability preserving maps constraints common point domain 
ti ti usa sa sar oe constraints solvability constraints fixed term entire argument fixed lambda term sufficient prove ti constraint system solvable sa constraint system solvable 
main result follows sa solvable sar show possibly conditional constraints sa equivalent set unconditional constraints usa 
usa obtained sa repeated transformations 
set constraints described pair contains conditional constraints unconditional ones 
different transformations solvable holds minimal solution fc kg fkg 
case applicable 
process clearly terminates transformation removes conditional constraint 
note case applies unsolvable condition satisfied minimal solution lemma sa solvable iff usa solvable 
proof show transformation preserves solvability 
know solvable holds minimal solution solutions 
assume fc kg solution solution hold fkg solution conversely assume fkg solvable 
fc kg holds 
solvable clearly 
assume solvable condition holds minimal solution clearly inherit solution 
follows solvability preserved sequence transformations 
introduce particularly simple kind constraints call constraints 
variables range binary set intg constraints form int 
define function oe maps usa constraints constraints 
individual constraints mapped follows usa oe usa lambda fxg fintg int fintg int turns oe preserves solvability 
lemma usa solvable iff oe usa solvable 
proof assume solution usa 
construct solution oe usa assigning int fintg assigning 
conversely assume solution oe usa 
obtain non minimal solution usa assigning fintg int assigning lambda 
define closure ti smallest set contains ti closed symmetry reflexivity transitivity property ff fi ff fi ff ff fi fi hardly surprising closure preserves solvability 
lemma ti solvable iff ti solvable 
proof implication right left immediate 
assume ti solvable 
equality definition symmetric reflexive transitive 
additional property true solution 
ti inherits solutions ti 
define function maps ti constraints 
individual constraints mapped follows ti ti ff fi int int show preserves solvability direction 
lemma ti solvable ti 
proof assume solution ti 
construct solution ti assigning int int assigning 
show crucial connection type inference safety analysis 
lemma usa constraints contained ti constraints sense oe usa ti 
proof proceed induction number transformations performed sa 
base case consider sa configuration contains basic safety constraints 
sa yields constraint fintg oe mapped fintg 
ti yields constraint fintg mapped fintg 
similar argument applies constraints yielded succ possible initial constraints 
established induction base 
induction step assume oe ti 
transformation move result immediate 
assume apply transformation 
solvable condition established application minimal solution 
opens new connecting constraints 
show corresponding equalities hold ti 
way enable condition minimal solution chain constraints fxg delta delta delta definition oe applying induction hypothesis get ti delta delta delta ti constraints closure properties ti follows proof obligation 
established induction step 
usa obtained finite number transformations result follows 
allows complete final link chain 
lemma ti solvable usa 
proof assume ti solvable 
lemma follows ti 
lemma oe usa subset solvable 
lemma follows usa solvable 
conclude safety analysis powerful type inference simple types 
theorem lambda term accepted type inference simple types accepted basic extended safety analysis 
proof need bring lemmas indicated combine observation section sa constraint system lambda term solvable sar constraint system term 
show basic extended safety analyses accept strictly lambda terms type inference simple types 
theorem exists safe term accepted basic safety analysis rejected type inference simple types 
proof basic safety analysis accepts terms constants 
rejected type inference simple types example xx 

easy see safety analysis extended detection dead code accepts terms normal form safety errors outermost level 
type inference simple types rejects terms example 
contend naturally extra power safety analysis significant numerous useful functional programs 
proof sheds light safety analysis accepts safe terms type inference 
consider solution ti transformed solution sa strategy implied 
closure sets maximal set lambda 
fine grained distinction individual closures lost 
results valid allow recursive types calculus 
ti constraints exactly type schemes changed finite regular trees 
allows solutions constraints int 
lemma influenced proof carries virtually modifications 
type inference recursive types basic safety analysis accept terms constants 
accept example 
conclude section example terms simple types allow recursive types pure terms normal form 
term term accepted basic safety analysis extended safety analysis 
second term term accepted safety analysis 
see observe code term dead 
sufficient show sa constraint system term unsolvable 
consider subset constraint system ffg fyg fintg ff yg clearly solution satisfy fintg ff yg impossible sa constraint system unsolvable term accepted safety analysis 
new algorithm safety analysis deciding safety lambda terms 
proved sound strictly powerful type inference simple types 
result demonstrates global safety analysis precise local type inference 
safety analysis sound lazy strict semantics arbitrary reduction strategies 
example term accepted safety analysis cause error reduced 
conjecture basic form safety analysis detection dead code sound fi reduction 
algorithm safety analysis implemented cubic time slight modification ayers algorithm 
shows safety analysis realistically incorporated compiler untyped functional language 
type inference basis binding time analysis closure analysis 
hope techniques formally compare quality analyses 
type systems lambda calculus type inference possible 
particular think partial types simple intersection types 
encompasses constants form easy remedy 
hope extend proving containment results involving systems 

authors mitchell wand anonymous referees wealth helpful comments drafts 
andrew ayers 
efficient closure analysis reachability 
proc 
wsa analyse pages 
henk barendregt kees 
types lambda calculi programming languages 
proc 
esop european symposium programming pages 
springer verlag lncs 
anders bondorf 
automatic higher order recursive equations 
science computer programming december 
anders bondorf 
similix manual 
diku university copenhagen denmark april 
included similix distribution 
mario coppo paola giannini 
complete type inference algorithm simple intersection types 
proc 
caap pages 
springer verlag lncs 
luis damas robin milner 
principle type schemes functional programs 
ninth symposium principles programming languages pages 
acm press january 
despeyroux 
proof translation natural semantics 
lics symposium logic computer science pages june 
adele goldberg david robson 
smalltalk language implementation 
addison wesley 
carsten gomard neil jones 
partial evaluator untyped lambdacalculus 
journal functional programming 
roger hindley 
principal type scheme object combinatory logic 
transactions american society 
neil jones 
flow analysis lambda expressions 
proc 
eighth colloquium automata languages programming pages 
springer verlag lncs 
gilles kahn 
natural semantics 
proc 
stacs pages 
springer verlag lncs 
paris harry mairson john mitchell 
unification ml type reconstruction 

lassez plotkin editors computational logic essays honor alan robinson chapter 
mit press 
dexter kozen jens palsberg michael schwartzbach 
efficient inference partial types 
journal computer system sciences 
appear 
proc 
focs rd ieee symposium foundations computer science pages pittsburgh pennsylvania october 
harry mairson 
decidability ml typing complete deterministic exponential time 
seventeenth symposium principles programming languages pages 
acm press january 
robin milner 
theory type polymorphism programming 
journal computer system sciences 
patrick keefe mitchell wand 
type inference partial types decidable 
proc 
esop european symposium programming pages 
springerverlag lncs 
jens palsberg michael schwartzbach :10.1.1.136.9764
object oriented type inference 
proc 
oopsla acm sigplan sixth annual conference object oriented programming systems languages applications pages phoenix arizona october 
peter sestoft 
replacing function parameters global variables 
proc 
conference functional programming languages computer architecture pages 
olin shivers 
control flow analysis higher order languages 
phd thesis cmu may 
cmu cs 
satish thatte 
type inference partial types 
proc 
international colloquium automata languages programming pages 
springer verlag lncs 
mitchell wand 
simple algorithm proof type inference 
informaticae 

