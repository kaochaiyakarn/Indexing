minimum weight paths time dependent networks ariel orda raphael rom department electrical engineering technion israel institute technology haifa israel march revised may investigate minimum weight path problem networks link weights link delays functions time 
demonstrate general exist cases finite path optimal leading define infinite path naturally containing loops way minimum weight problem solution 
characterize structure infinite optimal path 
practical cases finite optimal paths exist 
formulate criterion guarantees existence finite optimal path develop algorithm find path 
special cases optimal paths discussed 
shortest path algorithms subject extensive research years resulting large number algorithms various conditions constraints 
vast majority deal fixed graphs fixed topology fixed link weights surprisingly dealt time dependent graphs 
quality path network affected factors 
traversal cost links termed link weight 
factor delay links time required traverse links 
special case shortest path problems minimum delay problem weight link equals delay 
generally time dependent network link weight depends departure time link 
turn depends arrival time node turns link delays affect quality path link weights directly related delays 
interesting property time dependent networks may preferable cases wait park node departing outgoing link order keep total weight low may happen link weight function decreases certain period 
hand parking node consumes resources 
third factor affects quality path cost parking node 
works addressed problem finding minimum delay paths networks time dependent link delays 
works addressing problem cooke dealt discrete delay functions domain range integers 
arbitrary functions link delays briefly treated dreyfus ling addressed limited cases 
halpern dealt general case waiting nodes may useful allowed certain times 
general problem addressed algorithms finding shortest path various waiting constraints investigated 
shown departure time source unrestricted delay functions continuous shortest path simple achieves delay short unrestricted strategy 
hand shown restricted transit exist cases minimum delay finite path achieves infinite 
brief treatment time dependent minimum weight path problems treated date 
problems interest link weight may account various important factors reliability transshipment cost buffer size case link delays factors may vary time way may predicted observed recorded 
motivation investigating problem 
noted minimum delay path problem complicated time dependent environment compared static case paths may contain loops infinite general concatenated see 
shown quite simple assumptions problem complexity reduces static 
case general minimum weight path problem 
direct relation delay weight delay optimal path length number hops may grow bounds 
need incorporate infinite paths analysis problem calling rigorous definition problem 
worthwhile identify conditions tractable solution finite delay length guaranteed 
rest organized follows section ii time dependent model formulated 
section iii concepts finite infinite paths defined shown minimum weight path problem solution form finite infinite path 
section iv deals cases finite path solution guaranteed algorithm solving problem validated special cases algorithm applicable discussed 
concluding remarks section ii 
model consider directed bidirectional network 
set nodes set links bidirectional implies sets link weights node parking weight densities link delays 
subsections dwell concepts weights delays detail 
link node weights ik set time dependent link weights costs ik nonnegative function time defined describing cost associated commodity leaving node link time order deal links unavailable epochs ik equal infinity countable union open nonoverlapping intervals time outside intervals ik regarding link weights holds infinite sequence lim lim ik exist finite ik lim lim ik 
assumption holds equality ik continuous 
piecewise continuous sufficient condition assumption hold ik defined point minimum limits directions ik min ik ik indicated may preferable wait park node departing outgoing link order keep total weight low 
account resources consumed incorporate model set node parking weight densities representing infinitesimal cost parking node infinitesimally small interval dt 
assume countable union open nonoverlapping intervals inside parking prohibited outside permitted 
parking permitted countable union closed nonoverlapping intervals plus possibly semi closed interval 
nonnegative integrable inside permitted intervals node equals infinity outside 
define node parking weight function tt belong permitted interval node dq properties evident tt nondecreasing respect nonincreasing respect 
infinite sequence lim lim exist finite lim lim 
infinite sequences lim lim exist finite lim lim lim 
infinite sequences lim lim exist finite lim lim properties shall proving claims follows 
link delays ik set time dependent link delays ik continuous strictly positive function time defined describes delay incurred commodity starts traversing link time leaving node time arrives node time ik 
note general non fifo behavior links possible commodities may arrive endpoint link order departed 
noted certain circumstances possible commodity traverse path consisting infinite number links arrive destination finite time 
lemma establishes conditions extreme scenarios avoided 
lemma ik link delay function strictly positive lower bound finite interval delay path infinite number links infinite 
proof consider infinite sequence nodes 
denote arrival time node departure time node 
denotes starting time moment journey starts 

prove lemma suffices show assuming contrary assumption ik follows contradiction 
delay functions continuous strictly positive fulfill condition lemma traversals finite delay achieved finite length paths 
iii 
minimum weight path problem aim formulate minimum weight problem seeks path nodes minimal total link node weight 
case static shortest path problems time dependent minimum delay path problems paths guaranteed finite length 
depicts situation minimum weight path nodes infinite 
assume depart node time 
easy verify traverse loop infinite number times depart link get total weight finite length path weight higher 
words get lower weights staying longer network 
order define minimum weight path problem necessary define concept infinite paths respective weights 
section find convenient deal limited unit time 
achieved loss generality transformation fictitious link added node delay ii ii 
new parking weight function defined easy verify new representation equivalent original 
example infinite minimum weight path finite infinite paths somewhat uncommon definition finite path suits better defining problem 
definition finite path finite path fp source node destination node starting time finite sequence ordered triplets fp 




departure time node arrival time node 

permitted interval node 
link available time note arrival time destination referred termination time denotes additional stay destination node travel concludes 
definition finite path describes sequence nodes traversed parking periods nodes delays links 
number triplets minus number edges hops finite path called path length 
definition weight finite path weight fp finite path fp 
defined fp note definition fp note minimize weight fp clearly choose extra stays destination 
allow paths extra stays order facilitate proofs 
assumption nodes network starting time exists finite path words times nodes reachable finite paths finite weights 
turn deal infinite paths 
intend define infinite path limit sequence finite paths start introducing path sequences follows 
fp fp sequence finite paths nodes starting time sequence elements form fp 
denotes path length th path sequence 
definition invariance suppose fp fp infinite sequence finite paths nodes starting time suppose paths fp increasing length 
suppose paths fp triplet jth position property holds fp said invariant 
sequence rule referred rule production specifying way construct elements sequence 
example consider 
seen additional traversals loop cause reduction total weight incurred 
consider sequence paths fp fp fp generated recursive way fp fp fp superscript denotes deletion triplet path denotes appending triplet path operations performed sequentially left right 
words fp fp evident fp invariant 
definition infinite path infinite path ip corresponding invariant sequence finite paths fp fp infinite sequence triplets resulting infinite application rule production fp 
note fp invariant triplets ip equal fp build prefix ip number triplets rule production fp 
considering sequence fp defined note corresponding ip stands infinite traversal loop departure link 
words ip denotes optimal way traverse node node starting time 
definition weight infinite path sequence defined fp 
weight infinite path ip corresponding fp ip lim inf fp limit broad sense included 
fp sequence bounded follows lim inf exists ip defined 
limit exists sub sequence fp fp lim fp ip limit broad sense 
infinitesimal calculus may delete elements fp get new sequence fp fp fp ip lim fp 
call sequence fp proper loss generality assume infinite paths correspond proper sequences finite paths 
definition general path general path just path nodes starting time finite infinite path denote set paths nodes starting time facilitate presentation section shall introduce terms meaning clear 
order keep definitions place 
passage reader skip subsection 
definition termination path path termination time node referred termination path definition hop distance length minimal hop path nodes denoted hd referred hop distance nodes 
definition earliest arrival time earliest possible arrival time node paths length denotes ea 
definition optimal termination path assume exist termination paths nodes minimum weight called optimal termination path weight denoted mw 
denote mh smallest number hops optimal termination paths time dependent minimum weight path problem formulation problem network source node destination node starting time find path 
words seek path weight minimal set 
referred minimum weight path weight referred minimum weight 
hidden formulation fact may infinite number elements restricted case parking prohibited number elements may countable 
demonstrate consider network 
parking prohibited path completely defined sequence nodes traversed starting time 
attach loop label loop label 
correspondence finite infinite paths finite infinite binary sequences example path composed sequence nodes corresponds composed cardinality set binary sequences equal continuum follows 
existence minimal path described problem proved rigorously 
example uncountable number paths theorem 
proof see appendix theorem follows problem defined 
theorem shows optimal path infinite build desired length rule production corresponding finite path sequence 
result conceptual impossible build algorithm finding rule general case 
section deal solution problem simpler practical case finite paths 
iv 
algorithm finite paths seen cases minimum weight path may infinite large class practical problems finite path solution priori known upper bound number edges guaranteed 
section concentrate class problems 
criterion guarantees existence finite solution demonstrate generality number practical examples 
finiteness criterion lemma tt holds ik tt link weights strictly positive lower bound ii lim cost parking grows bound increasing time parking finite path fp finite parking times nodes solves problem fp 
proof 
adding self loops transform network parking restricted single unit time explained section iii 
refer original links regular links newly added ones fictitious 
theorem path solves problem 
assume infinite 
delay functions continuous lemma holds follows arrival time destination path infinite 
follows lemma finite number triplets corresponding times greater consider infinite sequence triplets corresponding arrival times greater successive pair triplets stands traversal link traversal regular link time incurs weight follows number triplet pairs stands regular link traversals finite 
conclude infinite sequence triplets stand infinite successive traversal fictitious link 
take infinitely long traverse links original network means infinite parking node done finite cost 
finite 
finiteness criterion lemma applies large number practical problems 
restricted destination arrival time suppose bound arrival time destination interested paths arrival time weights smaller 
defining ik ik accommodate finiteness criterion case 
restricted length bounded parking suppose bounds length number triplets requested path maximal allowable parking time node 
link delays finite easy see special case finiteness criterion applied 
network transient epochs assume dynamic behavior network transient ik ik 
parking nodes benefit tt turns finiteness criterion holds case 
infinite excluded holds asymptotic convergence case ik ik important property network finiteness criterion holds time domain interest finite 
extent calculated way 
seen finiteness criterion gives upper bound length optimal paths 
upper bound parking times paths easily obtained 
fact delay functions bounded finite domains enables recursive calculation upper bounds arrival departure times optimal paths 
reasoning discussed formally 
arrival times destination paths triplets weight path starting time 
holds ik follows upper bound length optimal path 
lim denote value denote max ik 
obtain upper bound arrival time destination optimal path recursive procedure 


latest possible arrival time th node optimal path 
start trivial assignment having calculated calculate latest possible departure time th node adding maximal possible parking time obtain adding sum maximal possible delay link departure 
discussion concluded lemma 
lemma upper bound arrival time destination optimal path 
proof proof straightforward appears extended version 
finiteness criterion holds restrict attention domain 
subsection algorithm solving problem network satisfies criterion 
algorithm algorithm solve problem graph source node destination node starting time assumed upper bound arrivals precalculated explained previous subsection 
clear distinction algorithm shortest path algorithms static case case rely concatenation property shortest paths subpath shortest path shortest path time dependent case shortest path may non concatenated depicted delay functions identically parking functions equal si sl li ir starting time minimum weight path 
minimum weight paths timedependent case different concatenation property shall described section algorithm 
specification algorithm prove main properties 
brevity divide algorithm main called algorithm weight computes weight optimal path second simpler called algorithm path calculates path 
example path 
specification algorithm weight finds weight optimal path node node starting time restrict attention solution single starting time noted algorithm find minimum weight function destination node range done considering functions introduced algorithm see variable functions 
notably different typical algorithms algorithms operate functions assignment addition operation performed entire functions 
particular need able detect functions change execution algorithm step 
term just changed mean exists time instance function changed value operation performed function 
algorithm weight internal functions time defined follows node lowest known weight stage algorithm execution termination path starting time 
pair neighbors kl lowest known weight stage algorithm execution termination path starting time hop link arrival node time algorithm variable denote best known weight stage algorithm execution path starting time denote set neighbors node algorithm weight 
kl 
sl sl min sl 
min kl 
min lk lk min lk 
lk just changed go step 
explanation computation called 
step assume minimal weights infinite step calculate minimal weights direct paths neighbors 
step try improve values possibly better termination path neighbor step improved values improve value order try find better path neighbor steps minimization performed 
appendix shown corresponding minima exist operations valid 
note steps minimization set tt lk set empty smaller min lk values regard min operation returning continuity delay functions follows larger values set nonempty 
point computational complexity function operations algorithm weight clearly higher simple operations numbers 
reader referred discussion issue statement especially true regarding min operations 
case algorithms functions complexity operations depends heavily behaving nature functions considered 
having computed functions kl values algorithm path calculates corresponding path destination node finds path weight starting time algorithm path may destination node description operator signify concatenation prepending component sequence 
algorithm path 
choose 



find node time lk lk lk 
lk go step 
algorithm trivial 
builds path backwards starting empty sequence 
know arrival time destination optimal path 
time 
time path reaches node look step node serve predecessor required path departure time node step 
having identified prepend component lk path 
step assures termination addition component sequence 

validation observing execution algorithm weight note executes step steps repeatedly 
refer passage step iteration algorithm execution step initialization zeroth iteration 
structure algorithm weight clear stage execution time path 
weight equals 
words termination path starting time weight 
shortest paths static networks property subpath shortest path famous concatenation property 
lemma demonstrates existence similar property minimum weight path dynamic networks restricted sense 
lemma time node hd ea 
mm optimal termination path starting time paths length 
optimal termination path starting time paths length proof 
path contradicts lemma 


contradiction 
lemmas making nth iteration algorithm implicitly assumed iteration performed algorithm stops 
lemma iterations algorithm node hd time ea higher weight optimal path starting time termination paths length proof noting functions kl increase value iteration 
prove lemma induction claim clearly true 
assuming truth prove node hd time ea 

optimal path starting time termination paths length 
termination path length 
inductive assumption follows iterations 
executing step st iteration executing step th iteration completing inductive step 
lemma suppose ea mh th iteration mw prior iteration mw 
proof mh hd follows lemma th iteration mw 
hand corresponds termination path times mw 
conclude th iteration mw 
prove second part lemma induction inductive claim mh th iteration mw 
claim trivial 
assuming truth prove mh inductive assumption prior th iteration mw 
contradicting inductive claim suppose th iteration mw 
value corresponds termination path say 
mw 
denote 

obviously 
assigned mw th iteration path assigned value st iteration choose minimal length 
lemma follows optimal termination path paths having hops 
fact chosen minimal length lead mh 
hand mh optimal termination path weight strictly lower follows termination path weight strictly mw contradiction 
mh 
note st iteration mw hand mh mh contradicts inductive assumption 
theorem algorithm weight stops finite number iterations 
value minimum weight proof ik ik continuous ik upper bound length optimal termination path mh part lemma leads functions changing finite number iterations 
functions lk part theorem 
denote mh max mh consider node mh mh 
denote corresponding optimal termination path 
mh mh mh mh mh discussion proof lemma follows mh mh prove induction algorithm th iteration performed 
claim trivial 
assuming truth prove 
know th iteration performed know holds mh lemma follows th iteration changes value mw ik changes iteration 
algorithm th iteration st performed 
algorithm runs mh iterations fact mh iterations lemma stops mw 
arrival time optimal path second part theorem follows 
discussion previous subsection regarding algorithm path easy see algorithm weight stops find finite path theorem guarantees optimal solution problem running algorithm weight followed algorithm path 
special cases subsection discuss cases special interest solved algorithm 

optimal paths optimal paths finite may contain loops 
interesting question devise algorithm find optimal path minimum weight path contain loops algorithm efficient 
point state algorithm belong family investigated iterative algorithm finds iteration additional triplet requested path operations iteration 
shown reduction hamiltonian path problem known np complete 
optimal path number triplets total number iterations performed algorithm bounded polynomial network nodes hamiltonian path problem determine path passing nodes transform problem instance way ik ik ir easy verify hamiltonian path exists iff optimal path zero weight 
cases existence solution problem form path guaranteed 
case finiteness criterion satisfied addition homogeneous penalty delays network cost parking weights words parking costs identical nodes ik ik expensive spend time nodes links link penalty delay link 
easy verify case optimal path loop free number edges 
running algorithm weight iterations gives solution problem particular case solution optimal path problem 

minimum delay problem ik ik 
assigning proper values may define model various time dependent minimum delay problems investigated unrestricted waiting model similarly forbidden waiting model source waiting model see 
note unrestricted waiting problem special case homogeneous delay penalty problem discussed 
parking allowed model investigated 
note problems fulfill finiteness criterion 

dynamic location problem model algorithms building blocks solving dynamic network location problem facility located moment interval node network 
performance measure captures cost having facility located node time pair nodes switching cost function ik accounts cost moving facility interval 
dynamic location problem formulated optimal algorithm validated 
shown time dependent minimum weight path problem solution form finite path infinite 
optimal infinite paths invariance property build nicely infinite sequence finite paths increasing lengths 
believe generally hard identify rule producing sequence 
large class problems finite solution guaranteed algorithm solves problem finite number steps 
contrast algorithms similarly number operations performed algorithm depend network topology sets sets functions instance problem shown np hard exists algorithm number operations bounded polynomial words regarding problems infinite path solutions 
problems describe extreme situations pays stay longer network knows plan stay traveling optimal infinite path 
indicated general hard produce optimal infinite path 
algorithm section iv infinite domain time shown solutions obtained successive iterations form weights approach minimum weight asymptotically 
may get paths weights approach minimal infinitesimally 
algorithm gives indication distance solution obtained stage optimal know execution performed sufficiently long 
appendix proof theorem consider set empty follows inf inf exists finite 
infinite sequence lim inf finite inf finite sequence nn done required path 
assume infinite sequence 
finite path infinite corresponding proper invariant sequence fp fp lim fp 
define sequence finite paths fp fp rule finite fp infinite fp fp note fp necessarily invariant 
lim inf infinite lim fp follows lim fp inf shall generate infinite invariant subsequence fp pruning fp prove induction infinite subsequence fp fp 
obviously assume infinite sequence fp subsequence original lim fp inf finite number neighbors fp infinite neighbor infinitely throw fp paths equation hold left infinite sequence fp lim fp inf observe infinite sequences upper bounded 
follows facts 



continuous 
lim fp inf fp pruned resulting sequence remains infinite sequences upper bounded 
remaining infinite sequence pruned yield new infinite sequence finite limits exist lim lim lim lim denote lim follows 
continuous lim lim lim lim lim lim consider sequence fp fp identical fp lim exist finite follows lim exists finite 
lim fp lim fp lim fp lim lim lim lim 
lim lim 
lim lim 
lim lim follows lim fp lim fp inf lim fp inf replacing fp fp complete inductive step 
appendix appendix prove existence minima considered algorithm weight 
noted min operation returns value set considered empty 
restrict attention case corresponding set nonempty 
appendix notation lk lemma stage execution algorithm weight hold min lk exists holds lk lk 
min kl exists 
min exists 
proof add lemma auxiliary claims related stage execution converging sequence lim exists lim lim 
converging sequence lim kl exists kl lim lim kl 
claim prove claim claim serves prove claim 
prove claims induction iteration number 
affecting proof may assume step applied including 
step zeroth iteration executed claims trivially hold 
assuming hold th iteration prove hold th iteration performed 
prove proof follows immediately 
claim 
consider execution step th iteration consider 
hold kl claim time link trivially holds 
denote kl link node weight functions may equal infinity open intervals follows closed 
converging sequence lim kl inf kl 
denote lim closed definitions follows subset permitted interval parking continuous intervals follows lim lim inductive assumption claim holds kl kl lim kl 
combining kl lim kl inf kl proving inductive step claim 
consider claim 
denote value st th iterations respectively similar notations kl 
consider converging sequence lim lim exists 
assume claim holds st iteration may define sequences tt kl kl prune converges denote lim lim lim min kl min kl assume kl kl 
inductive assumption claim kl lim kl follows kl kl suppose get kl kl contradicting conclude denote minimizer kl inductive assumption claim exist 
conclude kl kl additivity get kl kl contradicting conclude relation contradicts fact conclude minimizes expression kl lim min min kl min kl min kl lim lim min lim kl lim min min kl lim proving inductive step claim case 
proof inductive step claims similar step considered assumption link weight functions 
prove inductive step claim 
inductive step follows trivially 
denote easy see closed stage execution rest proof similar claim 

deo pang shortest path algorithms taxonomy annotation networks pp 


determination shortest path network time dependent mathematische statistik pp 


cooke shortest route network time dependent transit times journal math 
analysis applications pp 


dreyfus appraisal shortest path algorithms operations research pp 


ling optimal path networks time varying traverse time expenses branches technological reports osaka university japan 

halpern shortest route time dependent length edges limited delay possibilities nodes zeitschrift fuer operations research pp 


orda rom shortest path minimum delay algorithms networks time dependent edge length journal acm pp 
july 

orda rom traveling waiting time dependent networks nphard 
march 

orda rom minimum weight paths time dependent networks networks pp 
may 

anderson nash class continuous network flow problems mathematics operations research pp 
november 

garey johnson computers intractability freeman san francisco 

orda rom location central nodes time varying computer networks pp 
proceedings ieee infocom ottawa canada april 

