lisp symbolic computation 
fl kluwer academic publishers boston 
manufactured netherlands 
semantics introspection reflective prototype language jacques malenfant iro umontreal ca epartement informatique recherche op universit de montr eal montr eal qu ebec canada christophe dony dony lirmm fr lirmm universit de montpellier rue ada montpellier cedex france pierre cointe cointe fr ecole des mines de nantes rue alfred la nantes cedex france 
malenfant described reflective model language lookup ffi apply reflective introspection protocol 
augment previous protocol converting handle continuations reified class objects 
class continuations provide control current computation introspection phase fired message sending possible change behavior program message entire computation 
provide introspection protocol formal semantics 
result obtained exhibiting mapping delta program configurations priority rewrite systems prs mapping message expressions ground order terms query prs 
advantages approach ensure termination introspection smallest set formally justified conditions provide clear declarative account reflective protocol 
prs appears meta level base language independent implementation derive fundamental clues obtain efficient language processor 
new model highlight link reflection object oriented languages originally proposed lisp object orientation provides reusability reflection making easier 
keywords procedural reflection object oriented programming reflective towers priority rewrite systems semantics 

reflection understood construction self aware systems persistent source challenge 
tremendous potential new applications ensure continuous quest understanding foundations 
goal propose minimal model behavioral reflection prototype language study depth provide formal semantics theory priority rewrite systems prs 
propose complete prototype language formal study restricted reflective protocol malenfant dony cointe results applied reflective object oriented programming languages provided similar reflective protocol 
object oriented programming dominated class metaclass approach provides highly satisfactory solution problem structural reflection complete reification data structures programs class entities 
problem behavioral reflection dealing reification objects execution established similar firm grounds 
main approach currently investigated represent behavioral properties objects meta objects problems open 
overcome potential infinite regression meta objects 

protocol connect behavioral meta objects evaluator self representation 

represent evaluator data structures execution 

relationship structural behavioral reflection 
behavioral meta object object structural class 
implement reflection prototype language order avoid unnecessary complexity classes postpone question fully understand behavioral reflection 
choose implement meta object behavioral reflection reify message passing lookup ffi apply reflective protocol 
extend existing ideas order push limit 
concentrate central issues proposal minimalist minimal prototype language proposed previous structural reflection provided minimal way just behavioral reflection properly 
goal behavioral reflection give user complete control current computation run time 
achieve goal augment reflective protocol handle continuations reified class objects 
new lookup ffi apply reflective protocol augmented reification continuations provides reflective programming model matches lisp reflective extensions scheme 
lookup apply methods able examine modify deal continuations run time 
outcome adapt language particular programs adapt programs behavior current execution state perform sorts self optimizations dynamically 
outline 
section reflective prototype language including sufficient structural reflection capabilities enable implementation behavioral reflection 
section give formal semantics reflective protocol 
section discuss object general behavior implementation resulting language status rewriting implementation 
section compares approach related 
conclude discuss 
behavioral reflection prototype language 
reflective prototypes 
minimal language proposed prototype language implemented basis principles prototype represented collection slots 
slot represent data value data slot method method slot 
message passing means activate prototype slot names selectors messages 
difference data slots method slots accessed message passing 
prototype constructed extension existing prototype parent implicit delegation links prototype called root root parent delegation hierarchies 
structure prototype immutable add retract slot object allow encapsulation objects implemented effectively preventing malicious users dynamically adding public accessors private information 
initform primitive function create new objects fixed set slots initial values primitive invoked message new initials initform receiver parent new object 
clone alternative primitive function create new prototypes copying existing ones primitive invoked message clone prototype copied 
reasons scope object root defined root implicit delegation hierarchies gets methods primitive functions language clone see details 
assume prototypes parent restriction relaxed multiple parents add study unnecessary complexity 

structural reflection class languages classes metaclasses class objects implementing structural reflection prototype languages classes deal structure objects alternative sought obtain similar capabilities 
fact prototypes easily amenable structural reflection 
link prototype describes structure goes principles prototype programming fundamental way 
prototypes provide simple object oriented model allows study behavioral reflection depth 
malenfant dony cointe studying behavioral reflection needs little structural reflection capabilities limited ones access structural information individual objects reification methods objects 
identified primitive access functions size get size prototype get name ith slot get content ith slot set content ith slot test ith slot method slot data slot 
primitive functions represented methods language reified objects sizep 
object root gets methods points method slots size name contents contents put method respectively 
note consider proposal definitive solution structural reflection 
simply working order proceed behavioral reflection 
simplicity objects responsible responding reflective messages 

behavioral reflection behavioral reflection model describe behavior objects objects provide method invocation protocol allows user intervene current execution order modify course events reflect 
describe behavior objects associate meta object 
meta object defines associated object reacts receives message 
object oriented model computation message passing usual message sending vantage point programs shift reflecting phase 
standard way achieve making visible main operations done evaluator message sent lookup application method 
traditional equation message sending viewed composition left right lookup apply message execution lookup ffi apply operations implemented methods reified objects language allowing user redefine order perform reflective computations 
message passing operation selector replaced reflective introspection phases find meta object receiver send lookup message selector selector receiving object yields method object sent apply message execute context receiving object message arguments 
coarsely speaking reflective introspection rule selector metaobject lookup selector apply behavioral reflection prototype language continuation captured evaluator representing rest computation time reflective introspection 
applying reflective introspection rule receiver arguments message may evaluated 
denote evaluation trailing 
address issue assume respective results evaluations class objects order reflective introspection rule properly 
put constraints way evaluator treats receiver selector mode uses evaluate arguments 
sake brevity drop trailing rest 
note operation reflective protocol lead potential infinite meta regression 
represented message sending introspection rule applied ad infinitum 
section devoted way language prevents happening 
data slots data slots method slots accessed messages protocol cope data methods 
cases lookup phase return object able respond apply message 
data slots contain values bridge gap values object expected reflective protocol 
representing data objects able respond apply messages appealing solution leads immediately infinite meta regression trying represent data 
decided force lookup phase return object message accesses data slot 
object created fly lazy fashion responds apply messages simply returning value corresponding data slot 
class continuations class continuations represent long tradition especially functional programming community lisp scheme ml 
continuations represent default computation point execution program 
scheme tradition continuations represented method objects closures language ml order data structures 
prefer deal explicitly issues give freedom possible implementors 
reason assumption way continuations represented way created 
simply assume objects invoked sending apply message apply cont continuation object object resulting previous expression 
malenfant dony cointe 
basic objects relationships 
parent bl root value parent meta size clone parent parent metaobject metaobject metaobject bmo ba parent metaobject ik parent metaobject parent metaobject bac ba lookup apply apply apply cont new initials name contents contents put method apply sizep kernel prototypes impact method invocation protocol summarized principles added prototype language object meta object able respond lookup messages meta objects shared objects 
meta objects respond lookup messages returning method objects able respond apply messages 
meta objects method invocation protocol raise fundamental problems infinite regression meta objects may arise meta link object meta object basic lookup method basic apply method basic method applying continuations behavioral reflection prototype language provided 
model solves problem potential infinite regression introducing basic meta object called metaobject defines standard behavior objects system 
circularity meta link closes meta regression similar way instance link closed class 
method invocation protocol metaobject system able respond lookup message 
fact defines standard behavior lookup method primitive lookup function reified method language call 
reifying primitive lookup function requires apply method respect method invocation protocol 
assume apply method primitive apply function reified method language call construct apply method 
way reifying continuations require primitive function apply reified language call construct apply method 
solutions add principles reflective prototype language kernel meta object system considers meta object 
kernel lookup method system represents primitive lookup function bl reified method object language 
kernel apply method system represents primitive apply function baf reified method object language 
kernel method system apply continuations represents primitive function apply continuations bac reified method object language 
kernel model constructed objects ik root see 
ik object playing role identity continuation holds basic methods continuations serve root continuation objects hierarchies 
illustrates kernel objects relationships 

formal semantics reflective introspection section recast model theory priority rewrite systems prs order give formal semantics lookup ffi apply reflective introspection protocol 
recall basics prs show map program configuration set objects prs delta shown sound complete 
malenfant dony cointe 
priority rewrite systems rewrite systems means compute reducing expressions set rewrite rules 
computation performs rewriting steps starting expression reduct expression rewriting step applied 
rewrite systems represent expressions order terms formally defined follows definition syntax set fn function symbols called finitary vocabulary signature denumerable set variable symbols set order terms smallest set containing fn called subterms respective subterms 
term viewed tree subterm located sequence integers specifying path root subterm call position term term obtained replacing subterm position term denoted context term hole position replacement takes place 
definition substitution replacement operation transforms term term mapping variables terms 
mapping written fx 
xm 
finitely variables mapped 
formally substitution function denoted oe extended function way oe oe oe terms term matches unifies term soe substitution oe called unifier general exist unifiers terms 
example terms match unifiers map term 
general unifier terms substitution oe unifiers exists substitution oe oe ffi oe composition oe oe definition rewrite relation binary relation set terms closed context application substitution 
rewrite relation specified set theta rewrite rules form specifies term rewritten term closeness context application substitution means implies toe soe terms contexts positions substitutions oe 
reduction step involves application rewrite rule current term done steps find redex position rewrite rule uoe substitution oe obtain new current term voe replacing subterm voe 
rewrite systems step reduction faced choices candidate redex reducible behavioral reflection prototype language expressions rewrite rules 
prs impose order priority rewrite rules apply highest priority rule reduction step definition labeled prs tuple defining set labeled rewrite rules set terms set labels partial total order defined set rewrite rules 
labels purposes allow convenient rules ease definition order 
example 
define addition natural numbers labeled prs 
model natural numbers traditional representation functor arity functors mean successor predecessor respectively fp sg 
functor plus plays role addition function 
definition variables fx yg set labels define set rewrite rules plus plus plus priority relation uses standard order give priority rules labels 
rule highest followed rules 
operational semantics reduction prs defined sequences rewrite steps called reductions 
definition term reducible rewrites reduces prs prs ffl contains ground subterm redex containing variables position proper subterm reducible ffl prs contains rule matches matching substitution oe soe result replacing toe toe reducible rule prs higher priority reduction strategy desirable properties decidable ensures closeness context application substitution innermost ground reduction strategy 
abbreviation rewrites prs reflective transitive closure rewriting noted say reduct 
mapping program configurations expressions basically mapping delta takes program configuration gives prs prs 
message current continuation mapped ground term reduced prs 
program configuration set objects including meta objects methods slot names continuations user malenfant dony cointe table 
syntactic identities 
base language syntax prs syntax metaobject lookup fl apply ff apply cont ffi objects comprise running program particular point execution 
perform reflective introspection phase map part information prs really needed rewriting process 
show represent message execution govern way rewrite rules laid concretely 
messages evaluated standard way interpreter eval arguments message current continuation message components receiver selector array arguments 
mimic eval function represent message continuation evaluated term functor eval arguments term representing receiver representing selector representing array arguments represents current continuation 
assume function objects terms message selector current continuation object mapped term eval rec sel cont rec sel selector equal respectively cont 
represent reflective introspection protocol rewrite rule 
protocol intensive selectors metaobject lookup apply apply cont 
prs compact easier read map selectors special functors fl ff ffi respectively 
lists arguments represented standard notation see table 
consider simplified formulation reflective introspection protocol metaobject lookup apply main inconvenience formulation intermediate continuations sequence messages don appear explicitly 
apply introspection rule second message lookup need reification continuation apply message 
formulate rewrite rule continuation passing style cps intermediate continuations immediately usable 
continuations explicitly created protocol 
waits meta object sends lookup message second waits method object sends apply message 
capture terms form sel args cont 
invoking object sends message selector sel arguments args result passed continuation cont 
leads reformulation introspection protocol rewrite rule lowest priority prs behavioral reflection prototype language table 
basic priority rewrite system 
ba bl root bac ik fl ff ffi nil fcg fm fh lg see eval bmo eval ffi bmo ik eval bl eval ffi bmo ik eval ba eval ffi bmo ik eval fl ffi eval fl eval ff ffi eval ff eval bmo fl fl bmo eval ffi bl ik eval bmo fl ff bl eval ffi ba ik eval bmo fl ff ba eval ffi ba ik eval ba ff baf eval ba ff bl bmo eval ffi blf ik blf eval eval eval eval fl ff ik eval eval fl ff ik faced infinite meta regression 
right hand side rewrite rule reduced rule 
informally means need meta object mo send message need mo find mo forces adopt important assumption meta objects fetched reflective introspection protocol 
prs object program configuration get meta object fetching rule form eval eval ffi mo ik mo mo meta object prs rules highest priority 
kernel objects fig gives rewrite rules table 
invocation continuation discard current continuation simplicity chose ik identity continuation 
deal terms representing application continuations exhibited right hand sides meta object fetching rewrite rules 
blindly reflective introspection rewrite rule lead meta regression introduces continuations apply existing ones 
introduce rules having higher priority reflective rule apply continuations constructed reduction 
concentrate kernel defined illustrated fig potential infinite meta regressions prevented order reflective malenfant dony cointe protocol properly 
recall applying reflective rewrite rule calls sending messages 
dealt meta object fetching messages 
examine lookup apply messages 
infinite meta regression may appear send lookup message basic meta object bmo order find lookup method 
reflective rewrite rule lead eval bmo fl fl bmo eval bmo fl fl bmo ff bmo fl bmo ik bmo metaobject reduction steps rules send exactly lookup message bmo 
introduce rules avoid similar problems find apply methods bl ba 
problem fix relate actions sending object ba apply message asking execution method object arguments continuation rock bottom implementation 
need way jump language level message sending reflective protocol realm basic functions implement language 
addition functions introduced rely function baf executes arguments continuation call function represented prs term baf jump message sending implementation introduces rule having higher priority reflective rule 
basic function perform lookup objects having bmo meta object 
baf execute bl take advantage function blf 
gives rule having higher priority bypass method executed bl 
assume rules define blf prs catch errors add rule lowest priority 
unfortunately rule may lead situations try send lookup messages apply rule 
assume case rewriting process term decision implemented rule 
token add rule catch errors messages sent non existing objects 
rule mimics meta object fetching rule lower priority fired receiver meta object happen receiver term represent existing object 
completes set rewrite rules necessary model essential features kernel 
need different priorities cope previous requirements 
table uses labels suggest lower medium higher priority respectively 
give simple example rewriting process current program configuration contains object method uses standard behavior implemented kernel 
behavioral reflection prototype language table 
complete reduction example 
rewriting step labeled rule number rewrite preceding term shorten process easier read combined steps consisting applying continuations possible 
part horizontal line lookup phase second part apply phase 
rewriting steps rules eval eval fl ff ik eval bmo fl ff ik eval bmo fl fl bmo ff bmo ff ik ik eval bmo fl fl bmo ff bmo ff ik ik eval bl ff bmo ff ik ik eval bl fl ff bl ff bl bmo ff ik ik ik eval bmo fl ff bl ff bl bmo ff ik ik ik eval ba ff bl bmo ff ik ik ik eval ff ik ffi blf ik eval ff ik ffi ik eval ff ik eval fl ff ff ik ik eval bmo fl ff ff ik ik eval bmo fl fl bmo ff bmo ff ff ik ik ik eval bmo fl fl bmo ff bmo ff ff ik ik ik eval bl ff bmo ff ff ik ik ik eval bl fl ff bl ff bl bmo ff ff ik ik ik ik eval bmo fl ff bl ff bl bmo ff ff ik ik ik ik eval ba ff bl bmo ff ff ik ik ik ik eval ff ik ik ffi blf ff ik eval ba ff ik ik baf example 
consider program configuration consisting kernel objects plus object slot named pointing method object argument 
assume bmo meta object ba apply method configuration mapped prs set rewrite rules contains fourteen rules kernel plus rules describing new objects 
eval eval ffi bmo ik eval eval ffi bmo ik blf ff ba blf table illustrates complete reduction process message current continuation evaluation message represented term eval 
malenfant dony cointe 
formal semantics termination 
sound complete priority rewrite systems operational semantics prs defined definition doesn ensure termination reductions 
formal semantics prs defined mapping logical theory set equational order formulas characterizes logical consequences computed prs 
prs sound iff reductions computes logical consequences corresponding theory complete iff logical consequences theory correspond reductions prs 
necessary conditions ensure soundness completeness prs notion definitional prs defined follows definition prs prs partition set functors function symbols defined functions functors appears outermost symbol left hand sides rewrite rules constructor ones 
constructor term functors corresponding defined functions appear 
prs definitional priority rewrite system left hand side rule form corresponds defined function definition tuple constructor terms 
soundness completeness prs ensure ground term unique constructor term reduct 
shown parts termination ground reduction reduction limited ground subterms see ground confluence reducibility non ground constructor term 
termination means infinite chain rewrites 
proving termination hardest problems rewriting systems 
proposition gives conditions ground confluence second requirement holds proposition proposition ground confluent conditions satisfied pair rules left hand sides unify general unifier oe holds ffl rules higher priority ffl oe instance left hand side rule higher priority ffl oe oe identical 
final requirement ground non constructor term reducible 
easiest way achieve condition provide catch rewrite rules defined functions functors defined functions provide rule left hand side form xn xn variables 
strategy easy implement disturbing requirements simply assigning catch rules lowest priority 
behavioral reflection prototype language 
mapping program configurations sound complete prs program configurations reflective language mapped sound complete prs 
proving assertion define mapping delta program configurations prs 
represent objects slot names terms prs 
basically program configuration set objects existing program certain point execution 
manipulate objects prs map arity terms 
proposition program configuration exists set arity terms function equal cardinality proof straightforward construction 
set set arity functors cardinality equals defined mapping readability convenient assume constructed disciplined way 
distinguish subsets set objects representing slot names cns contains remaining objects 
contain predefined functors set table 
objects represented completed functors respectively 
set arity functors set order terms prs 
maps bmo bl ba functors bmo bl ba selectors slot names metaobject lookup functors fl simply maps objects selectors terms form 
definition program configuration ffl set arity functors ffl set order terms defined cons fcg fm ffl function ae ffl set labels fh lg order relation ae define mapping delta 
isomorphic ae contains rules obtained 
meta object mo add rule eval eval ffi mo ik mo mo 

meta object bmo selectors blf method add rule blf method 
add rewrite rules defined table 
malenfant dony cointe 
program configuration example object specialized lookup method lmo method apply method ma 
bmo bl ba mo lmo ma value parent meta prs obtained mapping consistent 
mapping delta generates slightly rules generate metaobject fetching rule objects configuration rules left hand sides form blf kernel objects necessary example 
additional rules change fundamental properties resulting prs 
prs message mapped term query reduce rewriting definition message receiver selector arguments current continuation object mapped term eval rec sel cont defined def 
rec sel cont 
proposition program configuration respects principles prs delta sound complete 
proof follows immediately propositions appendix 
discussion interesting outcomes characterizing reflective protocol priority rewrite systems lie better understanding reflection implementation 

general object behavior general object levels meta objects meta object mo meta meta object bmo reached 
requested behavioral reflection prototype language reflective protocol meta objects lookup method 
purpose creating hierarchy meta objects specialized lookup methods 
similarly method object apply method ma apply method ba reached 
things concrete consider example object specialized lookup method executed apply method 
example part 
consider program configuration depicted 
table gives rewrite rules added table delta omit certain rules moment 
eval eval ffi mo ik eval mo eval ffi bmo ik eval lmo eval ffi bmo ik blf fl mo lmo blf ff lmo ba table illustrates reduction process lookup phase assuming message current continuation lookup phase split major parts sub parts 
part table twin lines reduction process finds lookup method associated mo done subparts 
meta object hierarchy finds bmo 
retrieves bl lookup method bmo 
applies bl mo order find lookup method lmo 
second part twin horizontal lines applies lmo order find method corresponding selector done subparts meta object hierarchy lmo bmo finds lookup method bl bmo applies bl lmo find apply method ba applies ba lmo 
ends reduct baf lmo mo ff ik 
contrary example rewrite system ignores semantics lmo 
example rewrite system able find appropriate method respond message semantics bl known 
reduction process ends term interpreted request language processor find method associated selector lookup method lmo 
reduct transformed back call function baf 
perform inverse mapping described definition task assume function gamma terms objects 
problem transform continuation ff ik built reduction continuation object 
hold problem moment come back shortly 
assume transform term call baf applying lmo finds method passed continuation ff ik sending message selector ffi apply cont argument message invokes rewriting system described malenfant dony cointe table 
complete reduction example lookup phase 
rewriting steps rules eval eval fl ff ik eval mo fl ff ik eval mo fl fl mo ff mo ff ik ik eval bmo fl fl mo ff mo ff ik ik eval bmo fl fl bmo ff bmo fl mo ff mo ff ik ik ik eval bmo fl fl bmo ff bmo fl mo ff mo ff ik ik ik eval bl ff bmo fl mo ff mo ff ik ik ik eval bl fl ff bl ff bl bmo fl mo ff mo ff ik ik ik ik eval bmo fl ff bl ff bl bmo fl mo ff mo ff ik ik ik ik eval ba ff bl bmo fl mo ff mo ff ik ik ik ik eval ff mo ff ik ik ffi blf fl mo ik eval lmo ff mo ff ik ik eval lmo fl ff lmo ff lmo mo ff ik ik ik eval bmo fl ff lmo ff lmo mo ff ik ik ik eval bmo fl fl bmo ff bmo ff lmo ff lmo mo ff ik ik ik ik eval bmo fl fl bmo ff bmo ff lmo ff lmo mo ff ik ik ik ik eval bl ff bmo ff lmo ff lmo mo ff ik ik ik ik eval bl fl ff bl ff bl bmo ff lmo ff lmo mo ff ik ik ik ik ik eval bmo fl ff bl ff bl bmo ff lmo ff lmo mo ff ik ik ik ik ik eval ba ff bl bmo ff lmo ff lmo mo ff ik ik ik ik ik eval ff lmo mo ff ik ik ik ffi blf ff lmo ik eval ba ff lmo mo ff ik ik ik baf lmo mo ff ik example part ii 
consider program configuration depicted 
rewrite rules added mapping delta application method omit rules reduction eval eval ffi bmo ik eval ma eval ffi bmo ik blf blf ff ma blf ff ma ba behavioral reflection prototype language table 
complete reduction example apply phase 
rewriting steps rules eval ff ik ffi ik eval ff ik eval fl ff ff ik ik eval bmo fl ff ff ik ik eval bmo fl fl bmo ff bmo ff ff ik ik ik eval bmo fl fl bmo ff bmo ff ff ik ik ik eval bl ff bmo ff ff ik ik ik eval bl fl ff bl ff bl bmo ff ff ik ik ik ik eval bmo fl ff bl ff bl bmo ff ff ik ik ik ik eval ba ff bl bmo ff ff ik ik ik ik eval ff ik ik ffi blf ff ik eval ma ff ik ik eval ma fl ff ma ff ma ik ik ik eval bmo fl ff ma ff ma ik ik ik eval bmo fl fl bmo ff bmo ff ma ff ma ik ik ik ik eval bmo fl fl bmo ff bmo ff ma ff ma ik ik ik ik eval bl ff bmo ff ma ff ma ik ik ik ik eval bl fl ff bl ff bl bmo ff ma ff ma ik ik ik ik ik eval bmo fl ff bl ff bl bmo ff ma ff ma ik ik ik ik ik eval ba ff bl bmo ff ma ff ma ik ik ik ik ik eval ff ma ik ik ik ffi blf ff ma ik eval ba ff ma ik ik ik baf ma ik table illustrates reduction process lookup phase method associated selector apply phase split parts 
part rewrite system finds ma apply method task launches short metaobject bmo lookup phase 
second part finds apply method ma turns ba 
part applies ba ma ends term baf ma ik represents call basic apply function 
execute rest program term transformed back call baf discussed lookup phase 
example just gives glimpse complexity arising systematic reflection 
instance assume lookup method lmo ba apply method called 
apply method ba result reduction process yields term baf lmo mo ff ik ik malenfant dony cointe term represents execution method lmo method 
acts local interpreter lmo executed mo find method associated selector kind behavior may happen apply phase general levels apply methods example 
assume instance apply method ma apply method ma apply method ma reached apply method ba 
result reduction process baf ma ma gamma ma ik ik ik reduct requires execution baf applies method ma object ma gamma ma apply method executes method ma gamma executes method ma gamma method executed field reflection recognize presence reflective tower smith tower evaluators nth level evaluator executes th level evaluator 
lisp expression current tower similar ll compare section appear reduce reduce reduce kn kn respectively environments continuations level 
lisp towers theoretically infinite behavior level doesn deviate standard level levels eliminated replaced basic evaluator 
implementation lisp detects eliminates soon possible level flat execution 
theory lisp rarely execute tower levels 
notice mentioned earlier similar flexibility lisp protocol obtained explicit continuations 

efficiency concerns major concern reflective languages efficiency 
briefly come back lookup apply phases identify potential sources inefficiency discuss implementation 
reflective introspection rule heart language language processor blindly 
gains efficiency generally call compiling message sending applying optimizations way kiczales suggested 
lookup phase computation essentially additive lookup method find 
easily optimized 
practice hierarchy meta objects object may change 
standard caching techniques keep current lookup method applying just need compute lookup methods associated object reception message changes behavioral reflection prototype language meta object hierarchy 
resulting efficiency equal current object oriented languages 
apply phase things little complicated reflective tower apply methods executing apply method ma executes process essentially multiplicative harder implement efficiently 
apply methods acts language processor defines semantics new language method written 
language processors defined compilers interpreters 
case method ma gamma compiled compiling apply method ma code compiled compiling apply method ma applying process times compile method code interpreted language processor directly baf kept method object 
kind behavior implied specification function method lambda clos mop 
main problem face approach provide users suitable way specifying compiling apply methods users driven performance interested approach looks complicated 
premises approach appear lamping 
alternative traditional approach interpreting apply methods essentially variants basic meta interpreter core language 
approach known inefficient naively implemented 
obtain level efficiency expected compiling apply methods sort background automatic compilation needed 
techniques partial evaluation semantics program transformations play role mastered especially object oriented imperative languages 
reflection infancy 
possible caching techniques track result transformations optimized code application method 

status rewriting system actual execution program message sending triggers rewriting process best case meta object receiver bmo apply method method applied ba yields term representing call basic apply function execute method corresponding message 
seen example rewriting process short ideal situation receiver specialized lookup method 
case rewriting proceed needs go back program order execute lookup method 
implementation concerns striking fundamental question point status rewriting systems versus current object world 
prove correctness lookup ffi apply protocol suggested part execution programs 
fact envision possible implementations investigated malenfant dony cointe appears edge absorb rewriting system evaluation process absorb evaluation application processes rewriting system keep evaluation process rewriting system independent 
alternatives simplify coordination method execution rewriting unifying single framework 
rewriting system composed fixed set rewriting rules simple rules encode meta object fetching general lookup process objects bmo meta object conceivable embody evaluation process companion apply 
approach appears amenable efficient implementation see comments apply methods draws traditional implementation technologies 
blur evaluation application rewriting complex language processor interesting characteristics rewriting system lost 
prs obviously faithful incomplete representation current program configuration 
fact prs declarative meta level introspection part object world sense formal semantics terms equational theory dealing operational semantics reflective protocol 
declarative reflection area little done model appears testbed research subject 
second implementation alternative builds language priority rewriting appealing especially provide formal account full language terms equational theory 
raises practical issues efficiency 
third alternative provide best worlds 
evaluation priority rewriting system introspection kept independent 
currently interpreter language implemented line 
major shortcoming approach cost alternating core language processor rewriting system happens method call 
coordination object world prs essential system coordination essentially called causal connection reflection 
immediate consequence preserving rewrite system class entity 
concrete outcomes terms efficiency 
causal connection avoid reconstruction prs time message executed time object created destroyed simply updating existing prs 
second rewriting rules implement optimizations 
cache lookup methods viewed set rewrite rules 
example optimizing rewrite rules form eval mo fl fl mo eval ffi lmo ik 
rules simply shortcuts bypass chain rewriting steps finite length 
priority rewrite systems suffice give higher priority conflicting rules avoid ambiguities 
chief advantage approach introduce optimizations obscuring implementation details expressed elegantly rewrite rules 
behavioral reflection prototype language 
related behavioral reflection object oriented programming popularized maes krs 
watanabe yonezawa studied metaobjects concurrent reflective language abcl initiated domain 
ferber suggested integration meta objects class model 
approach shares idea implementing reflection oop introducing reflective introspection protocol message passing 
maes ferber approaches potential infinite meta regression similar impose explicitly language basic cases fall back implementation language 
maes uses explicit calls implementation language form expressions essentially quote lisp expressions krs 
ferber uses execution modes reflect versus normal tests explicitly decide reflect 
approach proposes hard code tests language provide declarative knowledge priority rewrite system 
claim prove easier understand modify 
watanabe yonezawa actor reflection lisp create meta levels lazy fashion 
approach reflective computation fired explicit call meta level created demand 
meta level accessed won created stopping meta regression 
approach original idea reflection avoids put priori limit degree introspection number tower levels need run appears amenable efficient implementation 
pursued directions order able fairly compare emergence deeper understanding behavioral reflection 
believe sheds new light approaches 
reflective towers cornerstone behavioral reflection 
lisp explicit krs clos exhibits similar characteristic 
study explicit link object oriented reflection functional introduced lisp studied scheme 
main differences approach 
towers model appear method method fashion finite giving statically fixed degree introspection 
locality effects ensures methods particular tower affected execution corresponding degree introspection 
locality suggests optimizations may easier 

second don single threading assumption enabled meta continuations 
approaches authors assume level tower executing time concentrate operations potentially infinite towers 
prevents higher levels tower making side effects 
don assumption control model captured meta continuations 
malenfant dony cointe 
third reflective computations fired climbing tower reflective functions making changes apply methods 
claim dual lisp approach 
notice meta continuations driven goal giving formal account reflection denotational semantics 
played important role understanding reflection approach failed reflection impairs compositionality assumption denotational semantics 
needed achieve goal formalizing reflection rewriting systems play role attempt 
instance mendhekar friedman develop programming logic calculus language line lisp brown ir 
reification noted rewrite system defines language semantics reduces applicative context representation current context redex represented informally viewed reflective function passed representation current execution context 
coarsely speaking scheme rephrased functional programming style attaching apply function abstraction term 
neglecting issues order evaluation application preceded unfolding operation apply function extracted applied representation 
fr fr fr suitable representation function 
apply function abstraction unfolding provide basic apply function model 
unfolding process expressed prs rule unfolding higher priority unfolding basic apply function 
complete comparison systems generic functions implementation queinnec cointe pursued 

studied new model behavioral reflection meta objects prototype programming language 
new method invocation protocol standard equation message execution lookup ffi apply augmented class continuations cornerstone model 
formal semantics protocol theory priority rewrite systems 
discussed behavior objects language examining step step execution message 
study give fine grained understanding behavioral reflection model leads important concerning behavioral reflection oop 
study confirms reification lookup cause fundamental problems reasonably expect implement efficiently 
interesting applications practice part object oriented languages 
second reification apply methods leads behavioral reflection prototype language reflective towers la lisp confirms central role play behavioral reflection 
object orientation changes perspectives making towers local method model finite 
result suggests gain efficiency obtained deepening understanding reflective towers 
gains necessitate high level portable model compiling apply methods apply methods definitional interpreters application semantics program transformations techniques adapted reflective towers 
priority rewriting systems proved successful approach give formal account reflection oop provide declarative metalevel reified causally connected base language leading new dimension reflection 
priority rewrite systems highly successful providing better understanding reflection new framework efficient implementation object oriented reflective language 
points research directions 
need build libraries examples reflective facilities discussed developing methodology reflective software construction 
interpreter language available efficient implementations view main research direction near behavioral reflection effective tool 
remains obtain implementation cope ambitious requirement crucial reflective languages 
directions interest concern priority rewrite systems 
research agenda includes done give complete formal account reflection prs play role 
including rewriting meta level reflecting promises fruitful include optimization rules able reflect reflective protocol 
acknowledgments authors wish jean anonymous referees helpful comments previous versions 
marco jacques implemented interpreter language 
author wishes fcar qu ebec nserc canada support 
appendix proposition program configuration respects principles prs delta terminating 
proof proof proceeds induction number objects program configuration basic case consider program configuration corresponding kernel term reduced 
ground terms form malenfant dony cointe eval blf reduced 
terms form blf term representing method represents object term cases reduction possible 
terms form eval match rules delta general case reduced rule table eval fl ff ik 
object kernel definition meta object bmo def delta contains rule term eval fl ff ik ffi bmo ik 
applying successively rules table yields eval ff ik ffi blf ik 
def delta contains rule form blf represents method kernel reduces term eval ff ik ffi ik reduced eval ff ik rule 
rule applies yields eval fl ff ff ik ik represents kernel method def delta contains rule eval eval ffi bmo ik reduces term eval fl ff ff ik ik ffi bmo ik term reduced eval ff ik ik ffi blf ff ik rules table 
method kernel apply method ba def delta contains rule blf ff ba reduces term eval ff ik ik ffi ba ik 
reduces baf rules reduction possible 
prove proposition basic case 
induction step assume proposition true program configuration cn containing objects 
consider configuration cn adding th object cn delta delta isomorphism new rule form eval eval ffi mon ik possibly new rules form blf slots name mon bmo 
message selector arguments current continuation sent rule applies reduces term eval eval fl ff ik 
correspond existing object rule immediately reduce term reduct 
reduced metaobject fetching rule eval fl ff ik ffi mon ik 
induction hypothesis meta object mon lookup method method respond message exist sending messages yields terms reduced finite number reductions 
proposition program configuration respects principles prs delta ground confluent 
proof proof proceeds induction number objects program configuration basic case delta applied kernel produces prs rewrite rules rules table augmented meta object fetching rules rules left hand sides lhs form blf 
definitional defined behavioral reflection prototype language functions correspond functors eval blf lhs rewrite rules functors appear arguments 
prs ground confluent proposition pair rewrite rules labels lhs unify pairs rewrite rules lhs unify contain rule higher priority ffl rules label lhs unifying lhs rule lhs rule rules lower priority 
ffl rules lhs unify higher priority 
ffl rules lhs unify lhs rule rule lower priority 
ffl lhs rule unifies meta object fetching rules rule case conflicting rules don priority 
induction assume proposition true program configuration cn objects 
add th object cn obtain new configuration cn delta delta isomorphism adds meta object fetching rule rewrite rules lhs form blf metaobject bmo 
new rules don violate conditions delta definitional 
priority lhs unify lhs rules having lower priority 
proposition program configuration respects principles prs delta ground non constructor term reducible 
proof defined functions prs eval blf catch rules ensure reducibility non constructor term 
notes 
text scheme syntax code 
message sending expressions noted receiver 
selector 
arg 
argn subexpressions receiver arg argn 
reduces objects selector 
reduces symbol 

environment don want deal evaluation receiver arguments environment doesn need represented point 

standard representation list order term uses functor cons mimics cons arguments car cdr list 
arity functor nil denotes empty list 
text prolog syntax lists list cons cons cons nil written 

appel 
compiling continuations 
cambridge university press 

baeten bergstra klop 
term rewriting systems priorities 
rewriting techniques appl number lncs pages 
springer verlag 
malenfant dony cointe 
cointe 
metaclasses class model 
proc 
oopsla acm sigplan notices december 

danvy 
intensions extensions reflective tower 
proc 
acm symp 
lisp functional prog pages 

dershowitz 
jouannaud 
rewrite systems 
handbook theoretical computer science chapter pages 
elsevier science publishers 

des rivi eres 
secret tower clos 
informal proc 
workshop reflection metalevel architectures oop oopsla ecoop october 

des rivi eres smith 
implementation procedurally reflective languages 
proc 
acm symp 
lisp functional prog pages august 

dony malenfant cointe 
prototype languages new taxonomy constructive proposals validation 
proc 
oopsla acm sigplan notices october 

ferber 
computational reflection class object oriented languages 
proc 
oopsla acm sigplan notices october 

foote johnson 
reflective facilities smalltalk 
proc 
oopsla acm sigplan notices october 

holzle 
chang chambers ungar 
self manual version 
distributed self software release stanford university july 

ieee new york 
ieee standard scheme programming language ieee std edition 

jefferson friedman 
simple reflective interpreter 
pp 
issue 

kiczales 
making reflection safe real world users 
informal proc 
workshop reflection metalevel architectures oop oopsla ecoop october 

kiczales des rivi eres bobrow 
art metaobject protocol 
mit press 

lamping kiczales rodriguez ruf 
architecture open compiler 
pages 

maes 
concepts experiments computational reflection 
proc 
oopsla acm sigplan notices december 

malenfant cointe dony 
reflection prototype object oriented programming languages 
informal proc 
second workshop reflection metalevel architectures oop oopsla october 

malenfant dony cointe 
behavioral reflection prototype language 
pages 

mendhekar friedman 
theory reflective programming languages 
informal proc 
third workshop reflection metalevel architectures object oriented programming oopsla october 

mohan 
priority rewriting semantics confluence conditionals 
rewriting techniques applications number lncs pages 
springer verlag 

muller 
lisp representation independent dialect lisp reduction semantics 
acm toplas october 

queinnec cointe 
open ended data representation model eu lisp 
proc 
acm symp 
lisp functional prog pages 
june 

smith 
reflection semantics lisp 
proc 
th annual acm symposium principles programming languages pages january 

ungar smith 
self power simplicity 
proc 
oopsla acm sigplan notices december 

wand friedman 
mystery tower revealed description reflective tower 
lisp symbolic computation 

watanabe yonezawa 
reflection object oriented concurrent language 
proc 
oopsla acm sigplan notices november 

yonezawa smith editors 
proc 
international workshop new models software architecture reflection meta level architecture 
rise japan acm sigplan ipsj november 
