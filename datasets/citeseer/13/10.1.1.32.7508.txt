simply typed rewriting calculus loria nancy france email loria fr claude kirchner loria inria nancy france email claude kirchner loria fr rewriting calculus rule construction application framework 
embeds uniform way term rewriting lambda calculus 
rule application explicit object calculus allows handle set results explicitly 
simply typed version rewriting calculus 
choice type system show calculus type preserving terminating veri es subject reduction strong normalization properties 
rewriting calculus ck ck general framework handling explicitly notions rule formation rule application rule application result 
rule formation constructor denoted terms allows built rewrite rule 
applying previous rewrite rule top position sum performed application operator denoted abbreviation 
result application set fs handle sets results understood simply fact rewriting may fail give results 
example applying previous rewrite rule set results just empty set 
assume furthermore addition commutative rule application may lead terms fs called calculus objects terms built rule formation rule application sets priori restriction term formation 
course important provide typed version calculus order particular insure termination evaluation typed terms 
dealing combination term rewriting calculus rst result obtained oka 
calculus respect previous approaches consider calculus opposition situation frameworks calculus rewriting combined 
di erent situation rewriting normalization process treated level abstraction 
introduced studied ck untyped rewriting calculus simply typed version 
brie section calculus properties 
section de ne typed calculus 
show subject reduction property section strong normalization typed calculus section 
main ideas approach calculus main diculties consist correct handling matching process non determinism calculus 
allowed right de nition typing system careful handling term context sets proofs 
notations ck reader referred details examples untyped calculus application modeling rewrite rules strategies 
informal presentation calculus calculus de ned components syntax precise formation objects manipulated calculus description substitution application terms matching algorithm bind variables actual values evaluation rules describing way calculus operates strategy guiding application evaluation rules 
core object formation calculus relies rst order signature rewrite rules formation rule application sets results 
substitution application described meta level calculus explicit substitution frameworks 
description calculus give higher order substitutions grafting dhk application takes care variable bindings uses conversion 
general case consider higher order matching practical cases higher order pattern matching equational matching simply syntactic matching 
evaluation rules mainly describe way term applied term way sets handled 
depending strategy employed guiding evaluation rules obtain di erent versions di erent properties calculus 
rewriting calculus appears natural way express term rewriting terms evaluation 
beta redex term application rewrite rule term beta redex reduces fx corresponding redex reduces ffx fx represents cases higher order substitution application involving possible conversions 
calculus patterns pj direct representation calculus 
consider example term pair selects rst element pair application pair pair evaluates representation calculus rst term air air function symbol corresponds symbol pair application air air evaluates ffx fag 
building abstractions rewrite rules priori restriction 
application term rewriting rewrite rule term represented term evaluates fg may rewrite object rewrite rule application 
evaluates singleton ff case variable free rewrite rule bound rule 

generally object formation calculus unconstrained 
application rule rule term written expected evaluation mechanism produce rst fbg fcg 
allows explicit direct way nonterminating non con uent equational rewrite systems 
example application rule term terminates applied create new redex 
set terms allow represent non deterministic application set rules 
example term fa cg represents non deterministic application rules result evaluation set fb cg representing non deterministic choice results 
calculus term contains rewrite rule information needed evaluation 
case calculus quite di erent usual way term rewrite relations de ned 
rewrite relation generated rewrite system fl de ned smallest transitive relation stable context substitution containing 
example consider rewrite system fa relation contains says derivation generated calculus situation di erent evaluation reduce term rewriting information explicit 
customary say rewrite system terminating generates derivation 
calculus nite derivation explicitly built example iterator evalu ation information starting term term representation evaluation corresponds steps derivation big di erence way de ne rewrite derivations generated rewrite system representation calculus rst case derivation construction implicit left meta level case rewrite steps explicitly built 
summarize calculus abstraction handled arrow binary operator matching parameter passing mechanism substitution takes care variable bindings results sets handled explicitly 
calculus integrates matching power rewriting higher order functionality calculus handles explicitly non determinism sense sets results 
calculus con uent general case sets representing reduction results main cause non con uence 
con uence recovered evaluation rules calculus guided appropriate strategy cir handling properly propagation failure sets element 
calculus conceptually simple expressive 
allowed represent terms reductions calculus conditional rewriting 
appropriate de nitions term traversal operators xed point operator able apply repeatedly set rewrite rule consequently de ne term representing normalization set rewrite rules 
starting representation showed calculus ck cir give semantics elan bkk rules strategies 
applied frameworks including rewrite languages asf sdf deu ml mil maude cafeobj fn stratego vis production systems non deterministic transition systems 
context rewriting logic mes proof terms subset terms exist terms correspond proof rewriting logic 
extends classical representation proof terms terms logical frameworks representation terms permitting matching non determinism description tactics tacticals 
typed calculus classical notations de nitions inspired typed calculus hin hs 
detailed description elan elan loria fr 
syntax typed calculus consider set atomic types set types inductively de ned atomic type type types type arrow type de nitions associates right type form abbreviation 
atomic types intended denote particular set example naturals booleans 
compound types form intended denote set terms applied terms type giving result terms type call strategy term compound type 
de nition type typed variable denoted say variable type context set typed variables 
assignments context called variable type de nitions assignments 
de nition consider set variables fm set ranked rst order function symbols possibly annotated rank 
denote set rst order terms built variables denote atomic type syntax simply typed calculus de ned recursively context free grammar types contexts 
terms ft tg set containing elements fg denoted 
contexts 
represented 
context restricted set variables term denoted ej local context rewrite rule contain variables see local context typed rewrite rule contain exactly typed variables concerned abstraction free variables disambiguation purposes symbol function annotated rank clear context annotation omitted 
types denote fa set function symbols arguments type giving result term type function symbol belongs set denote fa overload function symbols consider symbol fa fb bn inclusions bn bn additionally ranks bn bn fa fb bn reason overloading apparent evaluation rule congruence function symbols name di erent ranks order obtain typed terms type preservation 
de nition set free variables term denoted fv de ned fv fxg ii fu fv fv iii fv fv iv fv fv fv fv fv fv 
bound variables rewrite rule free variables left hand side 
de nition say context consistent contain di erent variable type de nitions variable 
typing rules calculus typing rules calculus contexts supposed consistent 
de nition formula deduced typing rules calculus context say term typeable typed type context denote say term typeable context exists type type context term typeable exists context typeable 
rule op notice type term rst order head symbol depends rank symbol types arguments 
point typing rule op works constants ground rst order terms arguments fa rule set says set terms typed elements type 
empty set type 
typing rewrite rule typing rule rule consider fact free variables right hand side rule bound free variables left hand side 
due strong relationship variables name sides rewrite ar rule ej 
ej app op fa set ft empty type fig 

typing rules calculus rule context ej order give types variables 
furthermore calculus left hand side rewrite rule rst order term variables term exactly free variables bound variables rewrite rule 
context allowing type rewrite rule include typed variables ej precise types free variables free 
discussion typing rewrite rules notice de nition set free variables left hand side rewrite rule necessarily set typed variables context allowing type term context contain variables belong free variables global context typing rewrite rule 
typing rule rule restriction context set variables avoids elimination variables free bound rule context typing rewrite rule 
suppose example typing rule rule context ej replaced rule 
new rule infer 
fa obtain 
see application reduces calculus fyg obvious infer fyg types preserved reduction 
try simplify typing rule rule eliminate typed variables left hand side context rewrite rule typing rule rule case impose explicit condition context 
condition satis ed obtain bound variables right hand side rewrite rule type corresponding ones left hand side respective rewrite rule 
example consider typing rule rule infer obtain term obviously want type hand context 
restrictive condition allow type terms typed typing rules 
consider function symbol fb easily obtain term typed context due context 
term typed context say terms typed rules typed modulo conversion approach typing rule rule additionally rule rule context rewrite rule contains typed variables left hand side store variables typing rule rule initial typing rule rule slightly dicult handle prefered approach impose restrictions terms typed 
typed substitutions moment de ne typed substitutions way apply typed term 
typed substitutions de ned way untyped substitutions confused grafting rst order substitutions types variables domain substitution explicitly 
types typed substitution form fx typed terms 
domain substitution de ned usually dom fx de nition typed substitution fx welltyped context denote typed variables dom application typed substitution typed term de ned similarly untyped case condition domain substitution context term consistent lemma term typed substitution context dom 
dom 
consistent typed matching computing matching substitutions term term important parameter calculus 
purpose de ne matching problems de nition theory terms match equation formula form typed terms respective contexts typed substitution context solution match equation matching system conjunction match equations 
substitution solution matching system solution denote matching system solution 
de ne function solution matching system returning set matches previous de nition substitution solution match equation dom example empty syntactic matching substitution exists unique computed untyped case simple recursive algorithm example huet hue 
computed set rules symbol assumed associative commutative 
denote match substitution obtained matching term typed context term typed context proposition normal form regards matching rules set matching problem exists unique 
removing normal form duplicated match equation resulting system decomposition 



fig 

rules syntactic matching match match ii form substitution fx unique match match ffx variable obtain match 
notice remove trivial match equations form system check equality types variable sides corresponding contexts 
course integrate type constraints matching rules keeping separate allows set matching rules typed untyped approaches 
function solution typed syntactic case de ned solution match contexts terms clear omit abbreviate function solution solution 
evaluation rules typed calculus evaluation rules untyped calculus ck enriched typing information 
rules modi ed ones handling rewrite rules ire typed calculus calculus matching theory obtained similarly untyped calculus typing system technically involved considered 
type system dealing rewrite rules left hand side elaborated rst order term slightly complicated cir 
conjecture similar approach calculus equational matching theory satis es certain conditions 
ire rg rule applied context solution congruence ff congruence fail distrib fu batch fu fv fu fu um ff um lat fu fv um fu um fig 

evaluation rules typed calculus mentioned interpretation function symbols overloaded sense having ranks 
left hand side rule congruence rst rank bn second fa symbol right hand side evaluation rule rank fb bn arguments term built rst rewrite rules terms compound type applied arguments term built second overloading symbol obviously needed order correctly type applications 
congruence rules redundant respect ire 
notice application term term evaluates evaluation rules congruence congruence fail term application rewrite rule term formal way evaluation rule ire 
congruence rules represent expansion calculus de ned eta 
applied particular case constant leads mainly properties want prove typed calculus 
prove typed calculus preserves types reduction property usually called subject reduction 
second prove typed calculus nite reductions 
comparing proofs similar approaches calculus show handling non determinism represented sets terms done properly 
calculus singletons corresponding deterministic result calculus deal explicitly possible failure represented non deterministic results represented sets element 
property hold untyped calculus 
untyped calculus terms normal form example term 
reduces successively fx 

typed calculus types bound variables explicitly corresponding term typed independently type variable contexts left hand side rewrite rules 
follows immediately typing rule app needs hand type rst application hand type second obviously impossible variables right hand side rule type variable left hand side order type rewrite rule typing rule rule 
example consider symbol cons constructing lists nil symbol representing empty set 
building integer lists cons int nil 
symbols building boolean lists case cons nil 
supposition cons int bool nil 
typing rule op obtain cons nil similarly cons rue nil 
transform integer lists boolean lists rewrite rules alse rue rue typing rule rule type int bool empty context 
example list cons nil transformed applying term cons rue nil 
term cons int bool nil cons rue nil 
obtained cons rue nil type rewrite rule transforming integer list boolean list 
typing rule app type empty context application cons rue nil cons nil 
term eventually reduces rue nil type typing rules op set 
subject reduction show typed calculus subject reduction property 
theorem terms proof sketch inspect evaluation rules typed calculus show left hand side right hand side rule type context 
evaluation rule form lhs rhs show lhs rhs ire 
rg rule applied context solution typing rule app infer typing rule rule 

consistent 
solution hypothesis matching dom 
consistent dom 
consistent lemma typing rule set rg matching fails right hand side satis es property typing rule empty 
distrib fu 
fu typing rule app infer fu typing rule set applying typing rule app times obtain typing rule set leads lat fu fv um 
fu um fu fv um typing rule set fv typing rule set obtain nally typing rule set fu um proof rules similar 
pointed section congruence rules redundant respect ire 
obtain similar equivalence type level 
consider function symbol fa fb bn bn type term context op consider term context 
obtain op 


app 

op typing rule rule 
previous deductions conclude induced type term corresponding extended term context notice second term de ne explicitly context left hand side rewrite rule types bound variables rule 
shows choice type system reasonably consistent implicit extensionality rule 
strong normalization concentrate proof strong normalization typed terms 
property guarantees existence normal form calculus con uent conclude uniqueness normal forms 
de nition typed untyped term strongly normalizing sn respect reduction relation reductions starting nite 
term weakly normalizing reduces normal form 
surprising relationship calculus calculus proof strong normalization calculus inspired proof strong normalization calculus 
methods proving strong normalization calculus 
called internalization rst gandy gan 
usually called reducibility notions introduced tait tai 
technique generalized gir jo 
follows notations de nitions proof line hs variation tait method 
comparing method approach handle properly terms having rst order head symbol set terms 
context type terms clear omit case abbreviate de nition de ne strong computability sc term induction number occurrences type arrows type term atomic type sc sn term sc sc term term sc 
de nition extended typed substitutions say substitution form fx sc terms sc 
normalization proof done steps 
prove typeable term sc sn 
second show typeable terms sc conclude typeable terms sn 
lemma sc term sn type properties atom terms sn sc 
sc term type sn 
lemma contexts terms 
consider substitution solution 
terms sc term sc 
lemma typeable term sc typed term sc sc substitutions term sc dom 
dom 
proof sketch part special case identity substitution 
prove induction construction elaborate case deals rewrite rule 
case neglect changes bound variables 
due de nition substitution application prove sc terms term sc equivalently sc 
matching fails result property holds obviously 
easily prove syntactic matching considered sc terms substitution solution obtain sc 
consider solution hypothesis matching sc follows sc 
lemma 
dom induction hypothesis applied obtain sc lemma sc 
theorem typed calculus strongly normalizing 
proof result follows immediately lemma lemma 
shown right notion types contexts simply typed calculus type preserving normalizing 
con uence calculus obtained speci restrictions evaluation strategy ck shows despite increased expressive capabilities framework preserves main properties 
extended calculus theory equational decidable matching problem 
goals study elaborated type systems allowing particular object oriented polymorphism features 
untyped calculus give semantics language elan approach smoothly extended representation elan typed rewrite rules strategies bor typed calculus 
proposed new presentation calculus ckl allowing encode major object calculi ac fhm natural simple way 
approach untyped context exploring elaborated type system allowing particular type self applications 
ac abadi cardelli 
theory objects 
springer verlag 
bkk borovansk kirchner kirchner moreau ringeissen 
overview elan 
kirchner kirchner editors proceedings second international workshop rewriting logic applications volume pont france september 
electronic notes theoretical computer science 
bor borovansk le contr ole de la etude implantation un de strat 
th ese de doctorat universit universit henri poincar nancy france october 
clavel eker lincoln meseguer 
principles maude 
meseguer editor proceedings rst international workshop rewriting logic volume asilomar california september 
electronic notes theoretical computer science 
cir 
le rho calcul applications 
phd thesis henri poincar nancy 
appear 
ck kirchner 
combining higher order rst order computation calculus semantics elan 
gabbay de rijke editors frontiers combining systems research studies isbn pages 
wiley 
ck kirchner 
rewriting calculus 
research report rr inria december 
ckl kirchner 
matching power 
july 
submitted 
deu deursen 
overview asf sdf 
language prototyping pages 
world scienti 
isbn 
dhk dowek hardin kirchner 
higher order uni cation explicit substitutions 
information computation 
fhm fisher honsell mitchell 
lambda calculus objects method nordic journal computing 
fn futatsugi nakagawa 
overview cafe speci cation environment algebraic approach creating verifying maintaining formal speci cations networks 
proceedings st ieee int 
conference formal engineering methods 
gan gandy 
proof strong normalisation 
seldin hindley editors essays combinatory logic lambda calculus formalism 
academic press new york ny usa 
gallier breazu tannen 
polymorphic rewriting conserves algebraic strong normalization con uence 
th colloquium automata languages programming volume lecture notes computer science pages 
springer verlag 
gir 
girard 
interpr etation elimination des coupures de arithm etique ordre sup erieur 
phd thesis universit paris vii june 
hin hindley 
basic simple type theory volume cambridge tracts theoretical computer science 
cambridge university 
hs hindley seldin 
combinators lambdacalculus 
cambridge university 
hue huet 
esolution equations dans les langages ordre 
th ese de doctorat etat universit de paris france 
jo 
jouannaud okada 
data type systems 
theoretical computer science 
kirchner kirchner vittek 
implementing computational systems constraints 
kanellakis 
lassez saraswat editors proceedings rst workshop principles practice constraint programming providence usa pages 
brown university 
mes meseguer 
conditional rewriting logic uni ed model concurrency 
theoretical computer science 
mil milner 
proposal standard ml 
proceedings acm conference lisp functional programming 
oka okada 
strong combined system typed lambda calculus arbitrary convergent term rewrite system 
proceedings acm international symposium symbolic algebraic computation portland oregon pages 
acm press july 
report 
pj peyton jones 
implementation functional programming languages 
prentice hall 
tai tait 
intensional interpretation functionals nite type journal symbolic logic 
vis visser 
strategic pattern matching 
narendran rusinowitch editors rewriting techniques applications rta volume lecture notes computer science pages trento italy july 
springer verlag 

