lecture notes approximation algorithms volume rajeev motwani department computer science stanford university stanford ca 
part supported nsf ccr mitsubishi 
page lecture notes course cs dept computer science stanford university offered academic year 
notes correspond half course 
second half consists topics max snp cliques colorings specialized material covering topics geometric problems steiner trees multicommodity flows 
second half revised incorporate implications results approximation algorithms complexity approximation problems 
please know mailing list second half 
comments criticisms corrections welcome please send electronic mail rajeev cs stanford edu 
page contents preliminaries basic definitions 
absolute performance guarantees 
absolute approximation algorithms 
negative results absolute approximation relative performance guarantees 
multiprocessor scheduling 
bin packing 
traveling salesman problem 
negative results relative approximation 
discussion 
problems 
approximation schemes approximation scheme scheduling 
approximation scheme knapsack 
fully polynomial approximation schemes 
pseudo polynomial algorithms 
strong np completeness fpas 
contents page discussion 
problems 
bin packing asymptotic approximation scheme 
restricted bin packing 
eliminating small items 
linear grouping 
bin packing 
fully polynomial scheme 
fractional bin packing rounding 
bin packing 
near absolute approximation 
discussion 
problems 
vertex cover set cover approximating vertex cover 
approximating weighted vertex cover 
randomized approximation algorithm 
nemhauser trotter algorithm 
clarkson algorithm 
improved vertex cover approximations 
nemhauser trotter algorithm revisited 
local ratio theorem 
algorithm graphs small odd cycles 
algorithm 
contents page approximating set cover 
discussion 
problems 
contents page chapter summary notion approximation algorithm introduced motivation provided issues considered 
basic notation elementary concepts complexity theory 
measures goodness approximation algorithms contrasted absolute relative 
positive negative results described problems scheduling bin packing traveling salesman problem 
large number optimization problems required solved practice np hard 
complexity theory tells impossible find efficient algorithms problems np true 
obviate need solving problems 
observe np hardness means np find algorithms find exactly optimal solution instances problem time polynomial size input 
relax stringent requirement may possible solve problem reasonably 
possibilities relaxing requirements outlined consider problem solved practice ffl super polynomial time heuristics 
may longer require problem solved polynomial time 
chapter 
page cases algorithms just barely super polynomial run reasonably fast practice 
techniques heuristics branch bound dynamic programming useful point view 
example knapsack problem np complete considered easy pseudo polynomial time algorithm 
shall say chapter 
problem approach problems susceptible techniques np hard problems best algorithm know runs truly exponential time 
ffl probabilistic analysis heuristics 
possibility drop requirement solution problem cater equally input instances 
applications possible class input instances severely constrained instances efficient algorithm trick 
consider example problem finding hamiltonian cycles graphs 
np hard 
shown algorithm find hamiltonian cycle graph contains 
results usually derived probabilistic model constraints input instances 
shown certain heuristics solve problem high probability 
unfortunately usually easy justify choice particular input distribution 
lot cases analysis algorithms assumptions distributions intractable 
ffl approximation algorithms 
relax requirement find optimal solution 
practice usually hard tell difference optimal solution near optimal solution 
reasonable devise algorithms really efficient solving np hard problems cost providing solutions cases guaranteed slightly sub optimal situations relaxation requirements solving problem appears reasonable 
results notion 
preliminaries basic definitions page approximate solution optimization problem 
book attempt classify types hard optimization problems point view approximability 
problems extremely easy approximate knapsack scheduling bin packing 
problems hard finding poor approximations shown np hard graph coloring tsp clique 
class problems intermediate complexity vertex cover euclidean tsp steiner trees 
cases able demonstrate problem provably hard approximate error 

preliminaries basic definitions define np hard optimization problem explore notions approximation 
formal definition maximization problem minimization problem defined analogously 
definition optimization problem pi characterized components ffl instances set input instances 
ffl solutions set feasible solutions instance ffl value function assigns value solution 
maximization problem pi find solution oe opt oe oe opt oe refer value optimal solution opt opt delta oe opt 
chapter 
page abuse notation bit referring optimal solution opt 
meaning clear context 
example help flesh definitions 
bin packing bp informally collection items sizes 
required pack bins unit size minimize number bins 
minimization problem 
ffl instances fs 
ffl solutions collection subsets oe fb disjoint partition ae 
ffl value value solution number bins oe joej specify outset underlying assumption book optimization problems satisfy technical conditions 
particularly important complexity theoretic results 

range numbers integers 
note easily extend allow rational numbers represented pairs integers 
example bin packing problem assume item sizes rationals 

oe oe polynomially bounded size number appears hard see condition reasonable computer deal infinite precision real numbers 
second condition defer justification motivation chapter 
going concerned np complete optimization problems bin packing 
people may find concept 
preliminaries basic definitions page slightly puzzling normally notion np completeness applied languages decision problems 
example say bin packing np complete understood referring problem deciding instance solution value specified part input 
define notion np hardness optimization problems 
definition np hard decision problem pi polynomially reducible computing solution optimization problem pi pi np hard 
typically problem pi decision version problem pi words maximization problem pi pi form exist oe oe case 
fact definition uses general notion turing reducibility permits wider applicability term np hardness 
refer book garey johnson discussion issues 
np hard optimization problem pi clear find algorithm guaranteed compute optimal solution polynomial time input instances np 
relax requirement optimality ask approximation algorithm 
defined follows 
definition approximation algorithm optimization problem pi polynomial time algorithm input instance pi output oe 
denote value oe solution obtained couple remarks order 
note interested polynomial time algorithms built definition approximation algorithm 
abuse notation denote value solution solution 
consider example bin packing problem 
da dumb algorithm algorithm packs item bin 
chapter 
page clearly approximation algorithm problem bp 
course approximation algorithm sense number bins uses need close optimal number bins 
need way comparing approximation algorithms analyzing quality solutions produced 
measure goodness approximation algorithm relate optimal solution solution produced algorithm 
measures referred performance guarantees exact choice measure obvious priori 
explore think natural choice measure 
notions performance guarantees follows 

absolute performance guarantees know packing collection items smallest possible number bins impossible 
best solution obtain 
clearly solution uses extra bin compared optimal solution 
general desirable solution value differs optimal small constant 
formalized absolute performance measure 
definition absolute approximation algorithm polynomial time approximation algorithm pi constant ja gamma opt clearly best expect approximation algorithm np hard problem 
find algorithms 
give couple examples algorithms possible find 

absolute performance guarantees page 
absolute approximation algorithms consider problem coloring vertices graph adjacent vertices color 
goal minimize number colors 
decision version problem np hard restricted graphs planar 
show planar graph coloring problem absolute approximation algorithm 
theorem np hardness planar graph coloring 
theorem problem deciding planar graph colorable np complete 
known planar graph colorable 
fact famous color theorem planar maps tells planar graph colorable 
consider approximation algorithm planar coloring problem 
checks graph colorable bipartite computes coloring possible 
just computes know check graph bipartite 
obvious coloring polynomial time 
follows uses extra colors 
theorem planar graph performance approximation algorithm ja gamma opt 
consider related problem edge coloring 
color edges graph smallest possible number colors adjacent edges color 
theorem relates delta edge coloring number 
theorem graph needs delta delta colors color edges 
explicitly specify various components optimization problems rest book 
chapter 
page fact proof theorem gives polynomial time algorithm find coloring delta colors 
amazing special case edge coloring problem np hard described theorem 
theorem problem determining number colors needed regular planar graph np hard 
putting construct absolute approximation algorithm np hard optimization problem 
algorithm just colors input graph delta colors theorem 
theorem approximation algorithm performance guarantee ja gamma opt 

negative results absolute approximation may conclude preceding examples special type optimization problem absolute approximation algorithm 
problems value optimal solution easily pinned small range hardness problem lies determining exact value optimum solution range 
absolute approximation algorithm merely uses information give trivial solution 
remains open really interesting problem optimum value easily pinned absolute approximation algorithm 
possibly best candidate result bin packing problem 
algorithm bin packing 
go proving approximation impossible 
note np find exact optimum np complete problem 
hardness impossibility result predicated assumption np 
turns optimization problems hard approximate sense 
absolute performance guarantees page finding absolute approximation np hard 
examples help illustrate 
consider knapsack problem 
instance problem consists ffl items ng 
ffl sizes corresponding items 
ffl profits corresponding items 
ffl knapsack capacity feasible solution problem subset want maximize informally pack items differing sizes knapsack fixed capacity maximize payoffs obtained packing item 
problem np hard natural try absolute approximation algorithm 
unfortunately exists algorithm polynomial time algorithm find optimum solution 
theorem np approximation algorithm solve knapsack ja gamma opt fixed proof prove contradiction scaling argument 
assume exists algorithm performance guarantee positive integer 
show algorithm construct optimum solution instance knapsack establishing theorem 
suppose instance knapsack 
construct new instance words leave unchanged profits scaled factor 
easy see feasible solution feasible solution vice versa 
chapter 
page difference value solution times value solution run algorithm obtain solution 
gives solution oe clearly ja gamma opt oe gamma opt recall dealing integer values 
dividing get jf oe gamma opt jf oe gamma opt course means optimal solution oe 
key ingredient proof observation knapsack certain scaling property due linear dependence value function numbers input 
may possible problem involves numbers crucial sense 
example shows scaling arguments purely combinatorial problems numerical aspect 
relies notion graph products implicitly provides required scaling 
consider clique problem 
problem finding largest clique complete subgraph input graph np hard problem 
note problem essentially maximum independent set mis problem 
see mis clique related 
theorem establishes hardness approximating largest clique 
theorem np absolute approximation algorithm clique problem 
proof define power graph say follows 
take copies connect vertices lie different copies 
leave proof claim exercise 

relative performance guarantees page claim largest clique size ff largest clique size mff 
assume purposes contradiction approximation algorithm gives absolute error claim clique problem optimally solved strategy 
run largest clique size ff ja gamma opt ja gamma opt hard see clique size fi find clique size fi polynomial time 
find clique gamma opt jcj opt integer valued follows optimal clique 

relative performance guarantees preceding section clear absolute performance guarantees desirable ones quite give guarantees interesting class hard optimization problems 
reasonable relax requirement approximation algorithm 
start examining problem multiprocessor scheduling motivate definition relative performance guarantees 
interestingly field approximation algorithms roots graham problem scheduling 
fact scheduling problems probably developed body point view approximation algorithms 
book able cover results reader referred survey article lawler details 
chapter 
page 
multiprocessor scheduling consider simplest version multiprocessor scheduling problem 
input consists jobs job corresponding runtime assumed rational 
jobs scheduled identical machines processors minimize finish time 
finish time defined maximum processors total run time jobs assigned processor 
set feasible solutions consists partitions jobs subsets value solution maximum subsets total run time subset 
problem known np hard case 
consider algorithm due graham called list scheduling algorithm 
algorithm considers jobs assigning job machines online fashion 
rule assign current job processor point loaded processor 
note load processor total run time jobs assigned 
theorem denote list scheduling algorithm 
input instances opt gamma bound tight exists input instance opt gamma proof prove upper bound ratio 
assume loss generality jobs assigned machine highest load 
denote total run time jobs assigned denote job assigned machine 
claim machine total load gamma assigned loaded 
relative performance guarantees page processor load exactly gamma follows gamma case opt processor load scheduling process 
obtain opt gamma gamma gamma observing opt processor execute job obtain desired result 
see algorithm achieves ratio consider input instance gamma gamma jobs run time job easy see opt gamma 
gives desired lower bound ratio 
interesting thing note result measuring quality approximation algorithm terms ratio value solution optimal solution 
exactly mean relative performance measure 
definition formalizes notion 
definition approximation algorithm optimization problem pi 
performance ratio ra algorithm input instance defined ra opt case pi minimization problem 
hand pi maximization problem define performance ratio ra opt chapter 
page ratio defined differently maximization minimization problems uniform measure quality solution produced ratio algorithm produces better approximation ratio closer 
define worst case ratio algorithm definition absolute performance ratio ra approximation algorithm optimization problem pi ra ra dg applying definitions list scheduling algorithm ra gamma better approximation algorithm scheduling problem called lpt algorithm orders jobs decreasing value run times 
algorithm behaves exactly list scheduling algorithm 
graham proved result new algorithm 
leave proof exercise 
theorem lpt algorithm performance ratio lpt gamma problems absolute performance ratio best possible definition performance guarantee approximation algorithm 
may input instances value optimal solution small performance approximation algorithm differs slightly optimal value 
small value optimum solution ratio appear large 
unreasonable larger instances ratio bounded small constant 
see example problem section 
take care anomalies define asymptotic performance ratio 
definition asymptotic performance ratio approximation algorithm optimization problem pi ra pi opt 
relative performance guarantees page note difference absolute asymptotic performance ratios approximation algorithm scheduling 
due scaling property problem 
scaling property multiply run times large constant scaling value optimal solution really changing problem solved 
hand see approximative behavior bin packing problem changes dramatically move absolute asymptotic ratios 
np complete optimization problems scaling property 
start proving bounds performance ratios specific algorithms useful consider bound may derived general 
assume loss generality pi minimization problem 
proof upper bound ra algorithm broken parts 
part proof lower bound value opt terms parameters second stage show provide upper bound terms obtain bound ratio merely eliminate inequalities 
reasonably easy see identify parts proof theorem parts proof need case pi maximization problem proving lower bound ra 
bin packing recall bin packing problem defined earlier 
problem closely related scheduling problem duals 
surprising similar ideas crop devising approximation algorithms problems 
consider algorithm called fit ff 
algorithm goes list items fits item bin fit 
precisely number bins time item inserted 
trying pack item ff successively tries fit opened bins order 
open bin room current item opens new bin place item 
chapter 
page claim instances ff proof proof observation bin half empty entire packing process 
suppose case 
bins half empty item placed bin size 
item fit ff opened new bin conclude total size items half number bins ff 
total size items lower bound value optimal solution 
gives desired bound 
stronger bounds obtained fit algorithm johnson 
established result 
theorem ff precisely bounds 
ffl ff opt ffl ff opt gamma fairly easy see example ff opt 
consider instance items 
ffl denotes suitably small constant 
ffl items size ffl 
ffl items size ffl 
ffl items size ffl 
clear opt optimal packing puts item type bin 
hand ff distribute see better packing 
items follows 
ffl bins items size ffl 

relative performance guarantees page ffl bins items size ffl 
ffl bins item size ffl 
seemingly smarter heuristic called best fit bf 
puts item bin fits best 
words item fits bin open placed bin empty space left current item added minimized 
currently open bin accommodate current item new bin opened 
quite surprisingly johnson showed bf algorithm asymptotic performance ratio 
lower bound example ff poor performance due fact small items placed earlier list 
natural modification sort items decreasing order sizes run ff bf algorithm 
quite similar lpt modification list scheduling algorithm 
call resulting algorithms ffd fit decreasing best fit decreasing 
algorithms asymptotic ratio proof upper bound ffd involved pages long 
easy see bound achieved input instance items size ffl items size ffl items size ffl items size gamma ffl 
leave proof exercise 
comment difference absolute asymptotic performance ratios bin packing problem 
theorem proved input instance consisting items proof left exercise 
theorem ffd contrast result upper bound asymptotic ratio ffd 
gives example approximation algorithm different performance terms kinds ratios 
chapter 
page 
traveling salesman problem final example illustrate notion performance ratios consider famous problem tsp 
input instance tsp consists directed graph edge lengths vertices edge lengths may infinite assume graph complete loss generality 
feasible solution consists tour graph visits vertex exactly 
goal find tour minimum length 
consider symmetric version tsp 
may restrict case undirected graphs 
point interested special case problem called 
definition metric traveling salesman problem special case tsp input instances satisfy triangle inequality 
precisely vertices consider heuristic called nearest neighbor heuristic nn 
starting vertex construct hamiltonian path going nearest unvisited vertex step 
cycle completed returning starting vertex 
natural heuristic performance poor demonstrated result due rosenkrantz 
theorem denote number vertices instance 
nn theta log turns better complex ideas 
fact heuristics known achieve asymptotic ratio 
heuristics finding eulerian tour short cuts obtain hamiltonian tour 
start reviewing notion eulerian tour refer standard graph theory book details 

relative performance guarantees page definition multigraph 
eulerian tour walk visits vertex edge exactly 
note multigraph edge repeated arbitrarily 
theorem characterizes class graphs permit eulerian tour 
constructing tour polynomial time easy consequence proof theorem 
theorem multigraph eulerian tour connected vertices degree 
consider heuristic minimum spanning tree mst weighted graph 
mst heuristic starts finding polynomial time mst graph constructs eulerian tour edges edge exactly twice 
eulerian tour yields hamiltonian cycle follows 
starting vertex visit vertices order visited algorithm mst input graph distance function output hamiltonian tour 
find minimum spanning tree 
construct multigraph making copies edge 
find eulerian tour 
construct hamiltonian tour short circuiting eulerian tour 
starting vertex follow eulerian tour long new vertices visited 
point eulerian tour repeats vertex jump directly unvisited vertex 
complete cycle returning starting vertex 
chapter 
page theorem mst heuristic applied mst 
proof prove correctness suffices note graph eulerian connected degrees 
collection edges denote sum edge lengths edges claim opt 
hamiltonian cycle edge removed gives spanning tree 
obtain delta opt 
short cut procedure ensures 
gives upper bound ratio 
see 
leave construction instance ratio achieved easy exercise 
turns modification heuristic improves performance ratio substantially 
heuristic due christofides refer ch 
basic idea avoid doubling edges going mst eulerian graph 
really need add collection edges increase degree odd degree vertex mst exactly 
collection edges matching odd degree vertices 
matching exist 
recall matching collection vertices subset edges set points edges exactly vertex exactly edge matching incident 
complete exists matching set standard results minimum weight matching polynomial time 
relatively easy modify mst heuristic incorporate ideas 
obtain result christofides heuristic 
theorem ch proof minimum weight matching set odd degree vertices mst claim opt 
relative performance guarantees page see consider tour obtained short cuts optimal solution exclude vertices claim follows observations opt tour union matchings consider alternate edges tour 
matchings weight half entire tour 
eulerian tour constructed graph weight delta opt 
gives desired result 
usual leave exercise construction example show bound achieved 
heuristic best known 
note mst heuristic efficient runs linear time 
heuristic due christofides inefficient finding minimum weight matching requires time 
interesting open problem find simple construction class algorithms allows smooth trade running time performance ratio 
results vaidya exact approximate matching points euclidean plane give tradeoff better results possible 
course improving bound major breakthrough 
way looking euclidean tsp problem points plane embed hamiltonian cycle points minimize total length embedded cycle 
generalized embedding graph just hamiltonian cycle 
interesting approximation results type bern hansen 

negative results relative approximation seen problems permit approximation algorithms relative performance measure 
large number problems exhibit behavior 
example graph coloring clique tsp problems know algorithm provides performance chapter 
page tee substantially better number vertices graph 
desirable come explanation certain problems easy approximate intractable approximating versions optimization version 
unfortunately theory np completeness provide insight issue 
appears connection approximate version problems closely related optimization versions np complete problems 
example provided problems vertex cover vc maximum independent set mis 
graph vertex cover set edge point vc problem find minimum cardinality vertex cover input graph independent set set edges pair vertices mis problem find maximum cardinality independent set independent set exactly complement clique mis problem clique problem complement graph 
exercise show graph vertex cover independent set 
optimal solution vc optimal solution mis 
conclude approximating vc mis related problems 
case 
see chapter approximation algorithm vc ratio 
hand know approximation algorithm mis ratio significantly better jv see approximation vc help approximating mis graph optimal vc size gamma 
guaranteed vertex cover size gamma approximation algorithm 
unfortunately complement vertex cover gives independent set size opposed optimal independent set size 
np hardness reductions shed little light approximative behavior optimization problems turns 
relative performance guarantees page theory np completeness show certain kinds approximation algorithms exist np 
define best possible performance ratio optimization problem 
definition define rmin pi best achievable performance ratio optimization problem pi follows rmin pi poly time algorithm pi rg desirable situation rmin problem pi 
see chapters achieved problems knapsack bin packing 
problems easy approximate 
level problems show rmin bounded case 
really hard problems rmin unbounded 
rest chapter examine problems type 
consider general tsp problem triangle inequality 
theorem due sahni gonzalez shows really hard problem approximate 
note usual hardness approximation problem predicated np different 
theorem np rmin tsp 
proof assume algorithm constant proof idea construct polynomial time algorithm solve ham hamiltonian cycle problem 
ham np complete get contradiction np 
suppose instance ham undirected unweighted graph 
construct instance tsp follows 
complete graph vertex set length edge set length edges set kn cardinality claim easy prove 
chapter 
page claim hamiltonian opt opt gamma 
consider happens run algorithm hamiltonian kn 
opt gamma 
value solution tells hamiltonian 
effect polynomial time reduction ham approximate version tsp 
contradicts fact ham np complete np 
far seen results prove impossibility finding absolute approximation algorithms clique result shows tsp approximation algorithm bounded performance ratio 
possible devise algorithms performance lies kinds approximation algorithms 
example see shortly approximation algorithm bin packing ja gamma opt log opt 
example result lipton tarjan shown approximation algorithm finding maximum independent sets planar graphs ja gamma opt log log opt opt planar separator theorem 
notice results imply 
possibility intermediate performance guarantees interesting prove impossibility results approximation algorithms 
hard modify proof theorem obtain hardness result clique 
series results obtained kucera 
theorem constants ffl approximation algorithm clique problem ja gamma opt delta opt gammaffl 
relative performance guarantees page notice theorem rule possibility algorithm clique 
example obtain result similar obtained case planar graphs 
know possible clique believe extremely 
unfortunately know way showing asymptotic ratio achievable showing rmin np 
strictly stronger result 
assuming ratio achievable clique show constant ratio achievable 
consequence curious theorem 
basically result says problem approximated specific constant factor approximated constant factor 
example self reducibility result approximation optimization problem 
result usually interpreted saying clique hard approximate believe rmin 
theorem clique problem rmin clique rmin clique 
idea theorem notion graph product amplify size optimal clique 
definition product graphs defined graph ffl theta ffl edge 
write ffi define gamma ffi note product operation non commutative 
need lemma proof left exercise 
chapter 
page lemma opt denote size largest clique opt opt 
clique size find polynomial time clique size dc ready prove theorem 
proof assume rmin clique 
exists approximation algorithm clique problem constant fix ffl construct algorithm ffl ffl ffl 
imply desired result 
algorithm ffl chooses ffl 
runs algorithm clearly finds clique size opt opt preceding lemma construct clique size opt opt ffl see algorithm ffl runs polynomial time observe graph product computed polynomial time constant 

discussion notation garey johnson universally accepted 
book known theory np completeness 
provides great area approximation algorithms quite bit outdated respect 
refer standard textbooks combinatorial algorithms 
unfortunately date provide cursory description 
discussion page area 
survey articles approximation algorithms really old outdated 
article kannan korte useful 
problems fact planar graph vertex degree show planar graphs colorable 
find coloring polynomial time 
consider variant traveling salesman problem called bottleneck tsp problem 
goal find hamiltonian tour input graph minimize length longest edge tour 
assuming input graph satisfies triangular inequality show problem polynomial time approximation algorithm ratio 
consider generalization tsp called tsp defined fixed 
notice tsp problem exactly 
instance complete graph distance function 
satisfies triangle inequality 
feasible solutions collection subtour starts ends vertex occur exactly exactly 
goal objective minimize total length 
modify christofides heuristic solve problem approximately provide upper lower bounds performance ratio 
hint polynomial time algorithm find minimum spanning tree specific node specific degree chapter 
page define product graphs theta obtained replacing vertex copy putting possible edges copies correspond adjacent vertices 
graph defined recurrence relation theta prove claims 
ffl opt size largest clique opt opt ffl clique size construct polynomial time clique size dc hamiltonian walk graph closed walk visits vertex 
pi denote optimization problem finding minimum length hamiltonian walk 

show pi np complete 

say hardness approximating pi 

construct analyze best approximation algorithm pi 
edge disjoint cycle cover ecc problem find collection cycles edge disjoint include vertex 
comment relationship optimization version finding cover smallest number cycles hamiltonian walk problem 
analyze approximability ecc presenting positive negative results 
chapter approximation schemes summary concept approximation scheme defined illustrated presenting schemes multiprocessor scheduling knapsack problem 
definition strengthened fully polynomial approximation schemes illustrated knapsack problem 
observed existence schemes intimately related existence pseudo polynomial time algorithms 
notion strong np completeness connection existence approximation schemes pseudo polynomial time algorithms 
recall result clique states rmin rmin problem 
said hardness result 
viewed easiness result 
find bounded ratio approximation algorithm clique turned approximation algorithm ratio arbitrarily close 
reason viewing hardness result similar commonly held view np completeness result hardness result 
existence bounded ratio algorithm clique imply result true lack success solving problem far 
reason problems algorithms achieve ratio arbitrarily close 
try provide characterization problems part chapter 
approximation schemes page book 
start formalizing notion having algorithm achieve ratio arbitrarily close 
definition approximation scheme optimization problem pi algorithm takes input instance error bound ffl performance guarantee ra ffl ffl notice view algorithm family algorithms fa ffl ffl ra ffl ffl 
definition approximation scheme stronger requirement entire infinite family algorithms finite uniform representation 
solution hard optimization problem people consider problem solved practical purposes algorithm 
shall see impose stronger conditions approximate solution problem 
convention assume implicitly approximation algorithm run polynomial time 
sake tradition explicit definition 
definition polynomial approximation scheme pas approximation scheme fa ffl algorithm ffl runs time polynomial length input instance emphasize definitions terms absolute performance ratios asymptotic performance ratio 
see crucial difference 
provide examples problems permit pas viz 
scheduling knapsack 

approximation scheme scheduling page 
approximation scheme scheduling recall multiprocessor scheduling problem jobs runtimes scheduled machines processors minimize finish time 
seen approximation algorithms bounded ratios problem 
pas problem due graham 
assume run times arranged nonincreasing order implies 
note assumption easily fulfilled sorting jobs run times 
consider algorithm defined integer 
algorithm input runtimes jobs fp processor count output feasible schedule 

schedule jobs optimally 

starting partial schedule obtained previous step schedule remaining jobs greedily lpt rule 
recall lpt rule picks largest unscheduled job schedules processor load currently 
algorithm clearly runs polynomial time 
performance ratio result due graham 
theorem ra gamma proof denote finish time schedule step 
clearly algorithm optimal schedule chapter 
approximation schemes page done 
assume finish time total schedule strictly greater case job finished time 
implies processors busy time interval gamma job scheduled earlier 
notice processor idle remains idle till schedule 
total run time jobs 
processor get job idle 
conclude gamma jobs arranged non increasing order run times ma gamma gamma observing opt inequality 
opt gamma show large terms opt desired result 
may established follows 
consider largest jobs scheduled step 
optimal schedule processor assigned bk mc jobs 
run time large conclude opt kj opt combining equation desired result 
extract promised pas result 
ffl ffl algorithm chosen proof upper bound ra usually consists parts 
upper bound possibly terms opt parameter lower bound opt possibly terms eliminating inequalities gives upper bound 

approximation scheme knapsack page performance ratio ffl 
verify case provided gammaffl ffl left crucial detail description algorithm exactly step get implemented 
hard see brute force algorithm compute optimal schedule time jobs processors 
running time step polynomially bounded length sufficiently small values say constant established theorem 
exactly large making time super polynomial 
theorem fixed polynomial approximation scheme processor scheduling problem 
notice algorithm means practical algorithm relatively small value running time exponential ffl ask ratios arbitrarily close excessively increasing running time 
instructive compute running time ffl small values ffl 
example running time ffl 
point trade quality approximation obtained important feature approximation scheme 
general trade running time increase fast decrease performance ratio 
see feature approximation schemes sections 

approximation scheme knapsack knapsack problem required find subset specified items total size subset exceed knapsack capacity maximizing sum payoffs associated items 
formally instances set fu items item size profit associated 
capacity knapsack specified part input 
chapter 
approximation schemes page solutions subset value value solution total profit items packed knapsack 
goal maximize net profit 
usual assume numbers involved input instance non negative rationals 
loss generality requiring item size greedy algorithm ga obvious approximation algorithm knapsack 
idea consider items order decreasing profit size ratio 
item inserted knapsack adding cause set current items exceed knapsack capacity 
algorithm ga input knapsack size item sizes fs profits fp output subset items total size 
sort items non increasing order profit densities point 

gamma unfortunately natural greedy algorithm worst case 
example consider case items size profit second size payoff surprisingly simple modification ga substantially improves performance 
mga modified greedy algorithm picks better solutions provided ga best solution obtained packing just item item largest profit knapsack 
leave proof theorem easy exercise 

approximation scheme knapsack page theorem sahni came pas problem 
basic idea quite similar scheduling problem 
define algorithm follows 
algorithm chooses subset items knapsack initially 
runs algorithm ga remaining items 
process repeated possible choices set paradigm generally referred enumeration obvious reasons 
pas devised approach 
application idea knapsack gives result 
theorem performance ration ra runs time kn 
proof number subsets size kn 
subset amount done implying bound running time 
turn attention performance ratio shown bound performance ratio tight construction input instance left exercise 
fix attention optimal solution say jxj obvious find optimal solution done 
assume jxj items fv ae items largest profits remaining items fv smaller profits items assumed numbered order decreasing profit density algorithm try initial set point 
interested iteration algorithm 
initializing knapsack algorithm greedily try fit knapsack remaining items order profit densities 
define index item set placed knapsack algorithm items vm gamma placed knapsack 
chapter 
approximation schemes page reason item vm get placed knapsack remaining empty space point say smaller time vm rejected knapsack contains items items vm gamma items optimal set denote items placed knapsack far greedy stage ak 
items added knapsack point clear items total size delta gamma gamma gamma items profit density pm sm considered earlier vm greedy stage follows profit gamma delta pm write profit net profit optimal solution follows 
gamma profit profit gamma delta pm gamma gamma pm profit profit pm profit pm solution produced superset get opt gamma pm noting items higher profit pm viz 
items pm prof completes proof 
obtain pas knapsack ffl algorithm ffl profit size denote total profit size respectively items subset 
fully polynomial approximation corollary exists pas knapsack algorithm ffl runs time ffl 
fully polynomial approximation schemes consider running times algorithm ffl pas knapsack scheduling running times really enormous reasonable values ffl 
definition fully polynomial approximation schemes designed remedy shortcoming definition pas 
definition fully polynomial approximation scheme fpas approximation scheme fa ffl algorithm ffl runs time polynomial length input instance ffl 
assuming np existence fpas best hope case np complete problem 
surprisingly np complete problems permit fpas 
problem demonstrate scheme knapsack 
basic idea fpas knapsack prototypical fpas known 
pp algorithm exact solution knapsack runs time log sb max max imply np running time appears polynomial 
see 
construct approximation algorithm ak knapsack follows 
algorithm ak input knapsack instance profits sizes knapsack capacity output subset items total size chapter 
approximation schemes page 
construct input instance new profits bp kc leaving unchanged 

run algorithm pp instance obtain subset items total size exceeding 
return derive algorithm ffl ak setting ffl gives fpas knapsack proved theorem 
running time polynomial length input inverse ffl 
theorem algorithm ffl runs time log sb ffl ra ffl ffl 
proof running time easily obtained definitions 
performance ratio observe opt gamma delta opt kn implies opt gamma ak kn note opt derive desired bound follows ra ffl ffl kn ffl kn ffl kn opt gamma kn kn gamma kn ffl 
pseudo polynomial algorithms page basically fpas starts slow exact algorithm knapsack trades accuracy speed means scaling technique 
course specify algorithm pp dealt section 

pseudo polynomial algorithms algorithm pp promised section example pseudo polynomial algorithm 
class algorithms runs time polynomial size numbers involved input instance 
note usual definition length input depends logarithmically size numbers 
algorithms really polynomially bounded length input 
section brief notions 
refer book garey johnson thorough treatment concepts 
point connections algorithms construction fpas 
start defining notion number problem 
combinatorial optimization problem consists components combinatorial component numerical component 
refers structures purely combinatorial nature graphs set systems 
component thought structures atoms drawn bounded domains encoded vectors finite domain 
thought numbers drawn unbounded domain integers rationals 
define functions measure size encoding input instance assuming reasonable encoding scheme 
definition optimization problem pi reasonable encoding input instance pi define length presenting intuitive development reader refer formal treatment 
chapter 
approximation schemes page max functions map input instances positive integers 
length function measures combinatorial size input max function measures size largest number encoding 
example case knapsack problem length max sg 
formal definition polynomial time pseudo polynomial time algorithms 
definition polynomial time algorithm pi runs time polynomially bounded length log max input instance definition pseudo polynomial time algorithm pi runs time polynomially bounded length max input instance usual definition efficient algorithm refers class algorithms algorithm pp knapsack belongs class algorithms 
illustrate definition providing pseudo polynomial algorithm partition problem 
problem np complete defined follows 
input instance consists positive integers bag size feasible solution solution consists subset decision version problem closely related bin packing scheduling knapsack problems 
consider algorithm dp partition paradigm dynamic programming 
basic idea dp construct table entries table boolean values true exists table constructed row row fashion follows 

pseudo polynomial algorithms page algorithm dp input bag size item sizes fs output table 
true 

gammas simple induction proof establishes algorithm correctly compute table decide problem partition suffices check entry 
algorithm easily modified solve search problem computing set done storing set position note may unique see 
suffices store set position obtain theorem implies dp pseudo polynomial time algorithm partition 
theorem algorithm dp solves search version partition problem time 
show devise pseudo polynomial time algorithm pp knapsack ideas dp goal find subset total size maximize profit 
obvious modification dp store observe close relation partition knapsack 
set table entry just ensuring pick set maximum possible profit sets candidates unfortunately problems crop 
problem get running time depends exponentially length scaling argument previous section works permits running time algorithm pp depend exponentially length secondly clear chapter 
approximation schemes page picking set largest profit right choice partial solution 
may case lower profit subset extended optimal solution 
way fix problem columns correspondence profits sets sizes 
note maximum profit set np particular opt np definition boolean table consists entries np true exists set size profit definition entry tells subset items feasible solution knapsack value second problem mentioned easily handled fact 
proof obvious 
lemma profit profit size size 
case size size 
means candidate set extended optimal solution candidate set smallest size extended 
define sets follows 
definition consider entry table false denotes undefined 
true defined subset smallest size size profit exactly set exists value undefined 
fairly easy come strategy computing values inductively row row fashion 
algorithm pp 
pseudo polynomial algorithms page input knapsack capacity item sizes profits output tables 
true 
false 
true 

np gammap assigned set smallest size gammap fi 
defined choice forced undefined infeasible computed tables optimal solution knapsack read column highest index true entry 
proof correctness means simple induction omitted 
theorem results 
theorem algorithm pp solves knapsack exactly time log sb 
result due ibarra kim efficient fpas lawler 
chapter 
approximation schemes page 
strong np completeness fpas try better understand implications pseudo polynomial algorithms np complete problems 
existence algorithm imply np 
answer running time exponential log max length input assumed polynomial length log max define notion np completeness 
possible np complete problem pseudo polynomial time algorithm np 
hard see max polynomially bounded length instance pi existence pseudo polynomial algorithm implies existence polynomial time algorithm 
bound valid non number problem clique ham 
conclude impossible find pseudo polynomial algorithms problems np 
formalized follows 
definition optimization problem pi define problem pi poly problem pi restricted instances max polynomially bounded length 
definition optimization problem pi said strongly np complete pi poly np complete 
clear non number problems strongly np complete 
fairly easy see existence pseudo polynomial algorithms quite number problem strongly np complete 
theorem np strongly np complete problem pseudo polynomial algorithm 
examples strongly np complete number problems bin packing tsp scheduling 
standard np hardness proof knapsack uses really large numbers establish strong np completeness problem 
course 
strong np completeness fpas page believe np knapsack strongly np complete seen pseudo polynomial algorithm 
obvious may go establishing strong np completeness results 
reductions number problems involve really large numbers say hardness pi poly theorem proves helpful regard 
theorem pi strongly np hard pi np pseudo polynomial reduction pi pi pi strongly np complete 
pseudo polynomial reduction generalization usual notion polynomial reduction required length produced instance smaller original instance 
proof theorem fairly obvious 
problem apply theorem know strongly np complete number problem start 
non number problems trivially strongly np complete useful application theorem number problems reductions involve large numbers 
luckily number problem called partition known strongly np complete usually plays role satisfiability problem proving strong np completeness results 
urge reader refer book garey johnson comprehensive treatment ideas 
approximation issue 
turns known fpas derived application scaling technique pseudo polynomial algorithm just case knapsack 
plausible argue find fpas problem strongly np complete 
idea formalized result due garey johnson 
theorem pi optimization problem property instances opt polynomially bounded length max 
pi fpas pi pseudopolynomial algorithm 
chapter 
approximation schemes page proof deal problems numbers involved positive integers proof generalized case rationals 
ffl bound value opt guaranteed theorem 
ffl polynomially bounded length max 
suppose fpas pi assume loss generality pi minimization problem 
algorithm ffl finds solution instance pi ffl ffl op ffl gamma opt ffl delta opt inequality follows choice ffl 
numbers involved integers means ffl finds optimal solution 
ffl pseudo polynomial algorithm choice ffl 
corollary pi integer optimization problem opt polynomially bounded length max 
pi strongly np complete pi fpas 
notice accounts technical conditions imposed class optimization problems dealing book 
possible find optimization problems violate conditions corollary problems arise naturally practice 
point fairly complete characterization problems fpas 
interesting problems strongly np complete may forget constructing fpas 
possible construct pas problems saw scheduling 
know construct pas large class strongly np complete problems 
quite natural look negative results existence pas 
theorem garey johnson proves quite useful purpose proof trivial 

strong np completeness fpas page definition pi optimization problem 
decision problem pi problem deciding instance opt theorem pi integer optimization problem 
suppose decision problem pi np hard constant np pas pi particular exist approximation algorithm pi ra see theorem applies specific problems 
consider coloring problem finding vertex coloring graph minimum number colors 
known checking graph colorable np hard 
implies pas coloring algorithm guarantee ratio better 
similarly problem deciding instance bin packing solution bins np hard exactly partition problem 
implies bin packing pas algorithm guarantee ratio better 
point discerning reader may start protest contradiction seen algorithm bin packing ratio better 
note talking absolute performance ratios section approximation algorithms bin packing seen earlier ffd guaranteed asymptotic performance ratio 
fact people assumed strong np completeness implied asymptotic pas fpas devised problem np 
big shock vega lueker asymptotic pas bin packing 
shock compounded karp transformed result asymptotic fpas bin packing 
results topic discussion 
offer observations development 
consider scheduling problem 
scalable problem implies approximation algorithm case ra know pas asymptotic pas problem clear chapter 
approximation schemes page asymptotic fpas leading fpas pseudo polynomial algorithm scheduling 
contrast bin packing pas asymptotic fpas 

discussion sahni gives general techniques constructing pas fpas 
constructing pas technique enumeration applications demonstrated 
techniques fpas rounding scaling interval partitioning aspects seen demonstrated algorithms bin packing follow 
interesting result korte shows essentially way construct pas fpas means techniques 
result proved context independence systems appear reasonably powerful application 
problems consider knapsack problem defined class 
find subset items total size maximizes total value 

consider greedy algorithm ga 
sorts items decreasing order density considers items order greedily adds item current knapsack resulting size compares solution obtained maximum value item placed knapsack choosing better possible solutions 
show 

construct analyze pas polynomial time approximation scheme knapsack problem ga chapter bin packing summary approximation schemes bin packing including pas due vega lueker fpas due karp 
shown modified approximation algorithm absolute error bounded polylogarithmic function value optimal solution 
clear preceding discussion expect find approximation schemes bin packing np 
said hardness result bin packing preclude existence asymptotic approximation schemes 
sake completeness give formal definition schemes 
definition asymptotic pas family algorithms fa ffl ffl ffl runs time polynomial length input ffl ffl 
definition asymptotic fpas family algorithms fa ffl ffl ffl runs time polynomial length input ffl ffl ffl 
result due vega lueker 
provide bin packing runs linear time ffl ffl delta opt 
running time linear chapter 
bin packing page length turns severely exponential ffl 
note reason pas additive error term bound 
basic techniques result similar earlier problems knapsack 
may summarized follows ffl elimination small items 
ffl interval partitioning linear grouping 
ffl rounding fractional solutions 
modification result due karp led bin packing 
gave approximation scheme performance guarantee similar described running time improved log ffl fact variation ideas leads stronger result 
construction approximation algorithm fully polynomial performance guarantee opt log opt point reason believe devise asymptotic approximation algorithm runs polynomial time guarantees opt 
major open problem 
derive results described 
presentation combines ideas vega lueker karp considerable overlap basic tools 
basic approach results follows 
define restricted version problem items reasonably large size item sizes take distinct values 
version bin packing problem turns reasonably easy solve 
provide reduction original problem instance restricted problem instance steps 
step eliminate small items shown packing remaining items small items added increasing number bins significantly 
second step divide 
asymptotic approximation scheme page item sizes intervals replace items interval items size 
turns affects value optimal solution marginally 
sections consider ingredients turn show tied give 

asymptotic approximation scheme input bin packing problem consists set items size th item assume item size rational number interval 
definition instance fs size denote total size items opt denote minimum number unit size bins needed pack items 
give inequalities relating quantities 
proof lemma obvious 
second lemma follows result chapter showed fit algorithm find solution uses delta size bins 
constructive result linear time algorithm guarantees bound lemma 
lemma size opt jij lemma opt delta size 
represent instance ordered list items writing delta delta delta 
definition instances equal cardinality 
instance said dominate instance case chapter 
bin packing page lemma easily proved noting feasible packing gives feasible packing number bins 
lemma instances equal cardinality size size opt opt 
define restricted version bin packing problem follows 
suppose item sizes take distinct values 
instance represented multi set items drawn types items 
definition suppose distinct item sizes fv delta delta delta vm instance items sizes drawn represent multi set fn nm non negative integer denoting number items size follows jm size size opt opt 
define restricted version bin packing problem called rbp 
definition ffi positive integers problem rbp ffi defined bin packing problem restricted instances item sizes take distinct values item size large ffi 
section show approximately solve rbp linear programming formulation 

restricted bin packing assume ffi fixed independently input size input instance rbp ffi multiset fn 
asymptotic approximation scheme page nm delta delta delta vm ffi 
jm discussion assume underlying set fixed 
note trivial determine verify valid instance rbp ffi 
consider packing subset items unit size bin denote multiset fb number items size packed concisely having fixed denote packing vector non negative integers 
say bins packed items type corresponding packing vectors identical 
definition bin type vector tm nonnegative integers 
having fixed set collection possible bin types fully determined finite 
denote set legal bin see 
types respect number distinct types function ffi bound value follows 
lemma ffi ffi proof notice type vector property 
follows lower bound ffi values type vector corresponds way choosing non negative integers sum choosing nonnegative integers sum exactly number choices upper bound value standard counting argument gives desired bound 
consider feasible solution instance rbp ffi 
packed bin solution classified belonging chapter 
bin packing page ffi possible types packed bins 
solution specified completely providing number bins types 
definition feasible solution instance rbp ffi vector non negative integers say denotes number bins type notice vectors correspond feasible solution 
feasible solution guarantee exactly items size packed various copies bin types 
feasibility condition phrased series linear equations follows 
mg matrix theta matrix th row type vector nm denote multiplicities various item sizes input instance set equations concisely expressed number bins solution simply denotes ones vector 
fact proved lemma 
lemma optimal solution instance rbp ffi exactly solution integer linear program ilp minimize subject notice replaced equations inequalities affect validity lemma packing superset converted packing number 
asymptotic approximation scheme page bins 
worth noting matrix determined priori depends instance easy obtain integer program 
note number constraints ilp exponentially large terms ffi going assume ffi constants fixed independently length input obtaining ilp requires time linear instance cardinality solving ilp 
recall integer programming problem np complete general 
algorithm due lenstra solves integer linear program time linear number constraints provided number variables fixed 
exactly situation ilp number variables fixed independent number constraints solve ilp exactly time independent 
efficient algorithm approximately solving ilp described section 
theorem results 
ffi constant depends ffi theorem instance rbp ffi solved time ffi 

eliminating small items section second ingredient devised vega lueker 
shown packing items sizes bounded ffi possible obtain packing items worse bins 
summarized lemma rest section devoted proof lemma 
lemma fix constant ffi 
instance bin packing suppose items size greater ffi packed fi bins 
possible find linear time packing uses ffi delta opt bins 
chapter 
bin packing page proof basic idea start packing large items greedy algorithm fit pack small items empty space fi bins 
implementation scheme important 
example start numbering fi bins arbitrary fashion 
ff algorithm run usual ordering decide small item placed 
point small items fit currently available bins new bin initiated 
best case small items greedily packed fi bins open initially 
clearly lemma valid case 
suppose new bins required small items 
claim entire process bins packing ffi empty space possible exception bin 
see consider case bins ffi wasted space 
bins ordering defined ff 
case bins set fi bins available initially 
packed small item bin opening new bin contradicting assumption new bins required ff 
hand bins new bins packed items bin opened 
fi fi total number bins ff 
guaranteed bins gammaffi full 
implies size gamma ffi fi gamma 
know size opt implying fi gamma ffi opt ffi delta opt desired result 

asymptotic approximation scheme page 
linear grouping final ingredient needed called interval partitioning linear grouping 
technique converting instance bin packing instance rbp ffi appropriate choice ffi changing value optimal solution 
assume items size ffi choice ffi 
remains show obtain instance item sizes take different values 
fix parameter non negative integer specified 
show convert instance rbp ffi instance rbp ffi bn kc 
definition instance rbp ffi parameter bn kc 
define groups items gamma ik gm mk group contains largest items contains largest items 
fact easy consequence definitions 
fact delta delta delta gm group obtain new group items increasing size item largest item group 
fact obvious 
definition gamma largest item group group group jg items size words jh jg fact delta delta delta hm gm entire point definitions obtain instances rbp ffi optimal solutions bracket optimal solution instances defined follows 
chapter 
bin packing page definition instance lo hm hi hm note lo instance rbp ffi 
easy see hi properties instances 
lemma opt lo opt opt hi opt lo size size size ihi size proof observe lo gm gamma set items gm right hand side inequality subset gives opt lo opt size size lemma 
observe hi lo packing lo obtain packing hi uses extra bins 
just pack item separate bin 
implies opt hi opt lo size ihi size hi lemma get remaining part desired result 
worth noting result lemma constructive 
log time algorithm constructs instances lo hi optimal packing lo possi see find lo hi convert packing packing stated time bound 
ble construct packing meets guarantee lemma 

bin packing put ingredients obtain 
algorithm ffl ffl takes input instance bin packing consisting items 

asymptotic approximation scheme page algorithm ffl input instance consisting item sizes fs output packing unit sized bins 

ffi ffl 
set aside items size smaller ffi obtaining instance rbp ffi jj 
ffl 
perform linear grouping parameter jlo resulting instance rbp ffi jhi jlo jh 
pack jlo optimally lenstra algorithm ilp lo 

pack items bins 

obtain packing number bins steps replacing item jhi corresponding smaller item 
ff pack small items set aside step new bins necessary 
bins ffl worst case 
observe packed items jhi items opt lo bins 
consider value terms optimal solution 
items size ffl case size ffln 
implies ffl ffl delta size ffl delta opt lemma obtain packed number bins exceeding opt lo opt ffl delta opt ffl delta opt chapter 
bin packing page lemma implies packing small items step number bins exceeding maxf ffl delta opt ffl delta opt ffl delta opt opt opt 
obtained theorem 
theorem algorithm ffl finds packing ffl delta opt bins time ffl log ffl constant depending ffl 
running time note really expensive step algorithm solve ilp lenstra algorithm 
observed earlier requires time linear may severely exponential ffi functions ffl 

fully polynomial scheme goal convert preceding 
reason scheme fully polynomial algorithm integer linear programming requires time exponential ffl 
describe technique getting rid step construction fractional solution restricted bin packing problem rounding feasible solution far optimal 
ideas due karp 

fractional bin packing rounding consider problem rbp ffi 
preceding discussion instance problem formulated integer linear program ilp 
minimize subject 
fully polynomial scheme page notice equality constraint 
recall theta matrix vector vector 
bin types matrix determined instance consider linear programming relaxation ilp 
system lp exactly ilp relax requirement integer vector 
recall size total size items opt value optimal solution ilp smallest number bins items packed 
definition lin value optimal solution lp linear programming relaxation ilp 
non integer solution lp mean 
value real number denotes number bins type optimal packing 
may interpret saying items broken fractional parts fractional parts packed fractional bins 
general give solution value size keep mind constraints lp allow arbitrary 
constraints require fractional bin items packed fraction original items 
solution capture features original problem 
refer solution lp fractional bin packing 
analyze relationship fractional integral solutions instance basic facts theory linear programming 
reader referred standard text book complete treatment see book papadimitriou steiglitz 
consider system linear equations implicit constraint linear equations variables ignore non negativity constraints bear discussion 
chapter 
bin packing page larger overconstrained system equations 
assume rank easy modify analysis rank assume loss generality sure see handle case rank smaller 
rows form basis linearly independent 
standard observations linear programming theory 
definition basic feasible solution lp solution entries corresponding basis non zero 
words fact lp optimal solution basic feasible solution 
derive lemma relates lin size opt 
lemma instances rbp ffi size lin opt lin proof value solution lp easy see total number times item packed fractional solution exactly constraint implies inequality 
second inequality follows observation optimal solution ilp feasible solution lp 
see inequality fix basic feasible solution lp 
non zero entries uses different types bins 
rounding value component increase number bins yield solution ilp bound promised lemma slightly stronger may observed follows 
define vectors 
gamma 
fully polynomial scheme page vector integer part solution fractional part 
denote instance rbp ffi consists items packed integral solution specified vector gives fractional packing items bin types number times fraction 
easy see optimal fractional packing follows prove optimal fractional packing size lin lemma know opt delta size obvious opt rounding non zero gives feasible packing opt minfm delta size size minfm gamma size size size needed bound opt terms lin may done follows opt opt gamma opt size lin lin chapter 
bin packing page completes proof 
hard see constructive 
precisely solution lp construct linear time solution bound theorem met 
problem obvious solve linear program fully polynomial time exist polynomial time algorithms linear programming general problem integer programming 
reason number variables exponential ffl 
achieved longer need solve integer program 
karp showed get problem resorting ellipsoid method grotschel lov asz schrijver 
method possible solve linear program exponential number constraints time polynomial number variables number sizes separation oracle 
separation oracle takes proposed solution vector guarantees feasible solution provides constraint violated 
karp gave efficient construction separation oracle lp 
result polynomial time algorithm lp small number variables exponential number constraints 
unfortunately situation exactly reverse small number constraints exponential number variables 
possible get problem considering dual linear program lp 
desired features small number variables optimal solution corresponds exactly optimal solution lp 
important detail impossible solve lp exactly fully polynomial time 
solved additive error fully polynomial time 
implementation separation oracle approximation algorithm 
idea due gilmore observed case infeasible proposed solution violated constraint computed solution knapsack problem 
np complete resort approximation scheme 
fully polynomial scheme page knapsack 
due solution dual exact close approximation 
karp obtain approximate lower bound original problem optimal value 
having devised procedure efficiently computing approximate lower bound construct approximate solution 
algorithm formidable details omitted outside scope book 
theorem results 
theorem fully polynomial time algorithm solving instance rbp ffi lin 

bin packing ready bin packing 
need variant lemma 
proof left exercise 
lemma linear grouping scheme instance rbp ffi obtain instance lo rbp ffi group hi lo lin lin lin ihi lin basic idea karp similar 
eliminate small items apply linear grouping remaining items 
resulting instance rbp ffi formulated ilp solution corresponding relaxation lp computed ellipsoid method 
fractional solution rounded integer solution 
small items added resulting packing exactly 
algorithm ffl chapter 
bin packing page input instance consisting item sizes fs output packing unit sized bins 

ffi ffl 
set aside items size smaller ffi obtaining instance rbp ffi jj 
ffl 
perform linear grouping parameter jlo resulting instance rbp ffi jhi jlo jh 
pack items bins 

pack jlo ellipsoid method rounding resulting fractional solution 

obtain packing number bins jhi replacing item jhi corresponding smaller item 
ff pack small items set aside step new bins necessary 
theorem approximation scheme fa ffl ffl bin packing ffl ffl delta opt ffl proof running time dominated time required solve linear program guaranteed fully polynomial 
number bins pack items jlo easily seen lin jlo opt ffl 
near absolute approximation page preceding lemmas choice number bins pack items turn bounded follows observation opt size ffln 
ffl ffl delta opt ffl delta opt total number bins pack items exceed ffl delta opt ffl number bins addition small items bounded lemma 
gives desired result 

near absolute approximation conclude presenting technique karp gives approximation algorithm error bounded slowly increasing function opt 
result step devising absolute approximation algorithm bin packing 
fact johnson observed vega lueker scheme modified construct approximation algorithm performance bounded opt opt gammaffi positive constant ffi letting value ffl depend instance new technique leads performance bounded opt log opt new technique variant linear grouping called geometric grouping 
motivate try pinpoint exact sources sub optimality preceding 
scheme depends grouping parameter leads instance different item sizes main sources error scheme 
solution restricted bin packing problem rounding error depends number item sizes error due replacement original instance discretized instance consisting different item chapter 
bin packing page sizes 
error roughly value small items easily handled assume value size ffin 
choose value greater 
clear choosing ffi close ffl ffl get desired approximation 
way improve error reduce value closer constant 
value increase correspondingly gained 
key insight karp really necessary pay penalty error rounding fractional solution 
recall solution lp broken integral part fractional part packing items specified remaining items thought instance optimal fractional solution exactly solution specified error came brute force solution instance new idea iterate approximation algorithm instance natural idea problem implementing guaranteed iterated process terminate 
consider linear program defined optimal solutions exactly vector iterating process keep giving solution integral part zero 
reason karp introduced technique geometric grouping 
approach different grouping different parameter stage iteration 
exact form grouping heavily dependent distribution item sizes instance 
new grouping guaranteeing value decreases constant fraction 
imply speedy termination 
give formal intuitive description ideas 
fix instance bin packing consider definitions 
definition ffi size smallest item define delta log ffi definition denote instance bin packing 
near absolute approximation page consists items sizes lie interval delta 
geometric partitioning items sets items roughly size factor 
formal definition geometric grouping follows 
definition geometric grouping parameter obtained applying linear grouping instance parameter lo hi lo outcome linear groupings jg outcome geometric grouping consists instances lo hi lo defined follows 
lo lo hi hi notice defining hi lo hi lo 
done earlier arguments affecting analysis way 
lemma corresponds lemmas proved linear grouping 
lemma opt lo opt opt hi opt lo delta lin lin lin ihi lin delta size size size ihi size delta proof proof similar proof lemma 
easy show inequalities hold 
opt lo opt opt hi opt lo opt chapter 
bin packing page easily show similar series inequalities lin size 
notice consists items size 
clearly items packed bins 
obtain size lin opt summing implies size lin opt delta plugging bounds gives desired result 
lemma crucial shows number distinct item sizes geometric grouping size original input 
denote number distinct item sizes instance 
lemma delta size delta proof observe size ji lo gamma delta delta rearranging obtain lo delta size summed gives desired result 
ready describe algorithm 
algorithm parametrized values ffi specified 
algorithm ffi input instance consisting item sizes fs output packing unit sized bins 

near absolute approximation page 
discard items size smaller ffi obtaining instance rbp ffi jj 
size gamma ln ffi perform geometric grouping parameter get jlo jhi jlo pack delta bins putting item separate bin 
solve jlo lp formulation optimal basic feasible solution obtained 
define integral fractional parts respectively solution pack subset items jlo vector obtain packing corresponding items redefine items left items packing specified fractional part 
pack remaining items gamma ln ffi bins 

ff pack small items set aside step new bins necessary 
time algorithm take 
assume choose large constant 
th iteration start instance instance lemma know size 
know size fractional solution uses basic bin types 
easy see size gamma conclude number iterations bounded log size log 
iteration step runs fully polynomial time entire algorithm runs fully polynomial time 
overview analysis number bins reader referred original complete details 
note main source error brute force packing chapter 
bin packing page delta bins iteration 
number iterations bounded obtain total error packing delta log size 
suppose choose ffi size 
total error log size 
gives theorem 
theorem algorithm ffi ffi size take instance bin packing fully polynomial time produce solution opt log opt 
discussion variants bin packing problem np complete 
cases reasonably easy come bounded ratio approximations 
variants classified different headings 
ffl packings number items bin bounded ffl packings certain items packed bin ffl packings constraints partial orders way items packed ffl dynamic packings items may added deleted generalizations basic packing problem 
examples variable sized bins multi dimensional bin packing 
refer reader survey article coffman garey johnson details 
possible devise approximation schemes cases generally ideas described 
example approximation scheme case bins due 
open problems remain 
discussion page notably case line bin packing multi dimensional bin packing 
big gap upper lower bound achievable ratios multi dimensional bin packing exponential dimension 
problems consider vector packing problem multidimensional version bin packing problem 
instance list dimensional vectors component vector belongs interval 
feasible solution packing vectors bins bin hold collection vectors sum vectors dominated ones vectors component sum 
goal minimize number bins 
techniques vega lueker karp provide polynomial time algorithm performance ratio ffl 
notice case reduce result vega lueker 
chapter 
bin packing page chapter vertex cover set cover summary problems considered possible attain bounded ratio able rmin absolute asymptotic sense 
class covering problems vertex cover graphs hypergraphs 
unweighted vertex cover problem graphs algorithms described achieve ratio 
similar bounds obtained weighted version problem 
set cover problem turns harder approximate logarithmic performance ratio obtained 
seen problems approximated degree rmin absolute asymptotic sense 
turn attention problems attain bounded ratio able push ratio way 
cases exact value rmin hard pin precisely say bounded constant 
great find matching lower bounds value rmin bounds hard obtain 
vertex cover graph set vertices contains point edge 
seen earlier closely related cliques independent sets 
convenient view edge graph subset vertex set 
justified graph undirected 
enables unify treatment graphs chapter 
vertex cover set cover page hypergraphs 
vertex cover vc ffl instance graph 
ffl feasible solutions subset fu vg 
ffl value value solution size cover jcj goal minimize 
problem standard np complete problems 
matter fact problem remains np complete graph planar 
general versions problem allow hypergraph associate weights vertices 
weighted vertex cover ffl instance graph positive integer weight function vertices 
ffl feasible solutions subset fu vg 
ffl value value solution weight cover goal minimize 
set cover sc ffl instance set fv family sets fe mg ffl feasible solutions subset 
natural generalization weight function subset domain delta 
page ffl value value solution size cover jcj goal minimize 
notice problem exactly vertex covering problem hypergraph 
natural generalization set cover problem weighted set cover deal problem book 
obvious generalizations vc np complete 
observations vertex cover graph 
posed exercise chapter 
second follows observation edge matching covered distinct vertex fact set vertex cover graph complement set gamma independent set vertices graph minimum vertex cover maximum independent set vertices fact matching independent set edges contain vertex cover size smaller jm notation regard input graph 
ffl jv jej 
ffl gamma delta fu vg denote set neighbors vertex ffl delta gamma denote degree vertex ffl delta denote maximum degree graph ffl set induced graph consist vertices edges incident vertices chapter 
vertex cover set cover page refer instance problem denotes weight function 
referred instance choice weight function clear context graph unweighted 
definition instance denote optimal solution problem 
abbreviated weight function known context graph fixed context 
value optimal solution denoted 
sections approximation algorithms problems 
considering nearly algorithms distinct idea 
reason overly extensive coverage various algorithms ideas appear extremely novel may problems 
see small improvement best known approximation ratio vc profound implications 
curious different algorithms achieve ratio asymptotically appears way improving ratio time 

approximating vertex cover suggest reader spend time trying devise heuristic algorithms vertex cover problem reading 
probable come simple natural heuristics described 
natural heuristic greedy algorithm repeatedly picks edge covered places endpoints current covering set call algorithm 
think 
achieve bounded ratio 
instance unweighted vertex cover problem 
algorithm 
approximating vertex cover page input unweighted graph 
output vertex cover 

pick edge choose point fe 
return leave exercise show algorithm outputs vertex cover 
claim algorithm achieve bounded ratio 
see consider bipartite graph depicted fig 

vertex set consists vertices 
vertex set sub divided sets called vertex edge vertices vertices common neighbor jr br ic 
possible vertices neighbor particular follows vertex degree vertex degree total number vertices theta log 
consider behavior greedy algorithm graph suppose sheer bad luck algorithm considers edges choosing point vertex placed cover 
picks edges gamma choosing points cover 
vertex cover chosen vertex cover graph bipartite 
follows ratio achieved algorithm vertex cover problem easier bipartite graph 
better jrj jlj omega gamma 
achieve better ratio 
try obvious strategy modifying algorithm arbitrary choice vertices included cover 
natural modification chapter 
vertex cover set cover page graph 
sets shown remaining sets consist vertex 
repeatedly choose vertices incident largest number currently uncovered edges call algorithm 
algorithm input unweighted graph 
output vertex cover 

pick vertex maximum degree current graph fe 
approximating vertex cover page 
return consider behavior algorithm graph 
easy see output vertex cover 
choose vertices stage 
choose vertices gamma general choose highest degree vertices stage 
surprising seemingly intelligent heuristic better simple minded heuristic 
see algorithm totally useless 
shown achieves ratio log general problem set cover vertex cover 
describe different heuristic achieves bounded ratio vertex cover problem 
basic idea modify placing points uncovered edge people find fact algorithm performs better counter intuitive 
surprisingly performance may help consider behavior algorithm graph 
algorithm better understood considering alternate description 
pick maximal matching graph 
place points edge cover 
call algorithm mm note matching maximal contained larger matching 
computed greedily repeatedly choose edge incident currently matched vertex 
algorithm mm input unweighted graph 
output vertex cover 
pick maximal matching 
matched 
return chapter 
vertex cover set cover page try see algorithm contrary intuition 
recall fact gives lower bound size optimal vertex cover terms size matching 
algorithm mm viewed finding lower bound optimal solution constructing solution provably small constant factor lower bound 
really goal approximation algorithm exactly find solution lower bound proof simultaneously 
counter intuitive behavior approximation algorithms explained observation trying prove near optimality 
analyze performance mm result due 
theorem algorithm mm computes vertex cover input graph rmm 
proof fact maximal matching implies edges nm points matched edge added provide larger matching contradicting assumption maximal 
implies edge point matched vertex cover 
see ratio consider edges cover edges need jm vertices share vertex 
implies optimal vertex cover size jm cover contains exactly delta jm vertices 
exercise show exist input graphs performance mm better ratio 
exercise show maximum matching maximal matching improve worst case performance mm algorithm achieves ratio problem due savage 
algorithm call dfs simple 
approximating vertex cover page outlined 
basic idea find depth search tree graph cover set non leaf nodes tree 
leave analysis algorithm exercise 
exercise show dfs algorithm finds vertex cover performance ratio 
asymptotically best upper bound rmin 
course entirely possible find approximation scheme vc considered 
provide evidence 
conclude describing simple randomized algorithm due pitt achieves ratio vc albeit expected sense 
reason studying algorithm easily generalized case weighted vertex cover yield simple approximation algorithm expected performance ratio 
suggest reader spend time trying think randomized heuristics vertex cover problem 
natural heuristic consider vertices random order placing vertex cover incident currently uncovered edge 
unfortunately performs poorly 
see consider performance heuristic star graph viz 
graph vertex degree gamma connected gamma vertices degree 
reasonable heuristic randomized version 
idea choosing maximum degree vertex residual graph pick vertex random probability particular vertex chosen proportional number uncovered edges incident 
leave exercise show heuristic guarantee expected ratio bounded 
hint consider performance old friend graph 
generalize notion performance ratio randomized algorithms obvious manner 
expected ratio randomized approximation algorithm ra fixed input defined delta exp ra opt exp ra denotes expected value ra output 
expected performance ratio pi defined exactly case deterministic algorithms 
chapter 
vertex cover set cover page quite surprisingly simple modification turns right algorithm 
idea consider edges arbitrary fixed order 
edge currently consideration covered pick points uniformly random add cover 
refer new randomized algorithm algorithm ra 
algorithm ra input unweighted graph 
output vertex cover 
order edges arbitrarily 
pick edge fu vg flip fair coin choose uniformly fu vg fe 
return formally analyze algorithm worthwhile try understand intuitive level algorithm perform 
observe algorithm added arbitrary point cover algorithm mm added points cover 
expect randomized algorithm intermediate performance turns mm expected sense 
reason avoids making wrong choice endpoint uncovered edge algorithm 
higher compare behavior ra 
degree vertex chances chosen random coin flip 
theorem algorithm ra outputs vertex cover 

approximating weighted vertex cover page proof easy verify algorithm output vertex cover 
prove fix input graph order edges examined optimal cover suppose algorithm outputs cover vertices 
clearly algorithm examines exactly edges flips coins course execution 
define outcome coin flip causes vertex enter cover note edge point coin flip probability half 
number coin flips exceed jc vertices edge covered total number coin flips stochastically dominated number unbiased coin flips needed obtain coin flips 
follows expected number coin flips needed delta implies desired bound expected value performance ratio 

approximating weighted vertex cover turn attention weighted version vertex cover problem 
start considering obvious heuristics problem usual readers urged try think heuristics proceeding 
consider simple greedy heuristic considers vertices increasing order weights placing vertex cover incident edge currently uncovered 
heuristic identical algorithm restricted case unweighted graphs 
surprising poor performance ratio 
fact performance worse illustrated example 
consider star graph vertex degree gamma weight degree chapter 
vertex cover set cover page vertices weight 
easy see cover chosen heuristic weight gamma opposed optimal cover weight 
obvious heuristic simple generalization algorithm previous section 
basic idea choose stage vertex smallest possible ratio weight current degree 
refer algorithm wg 
algorithm wg input graph weight function output vertex cover 

pick minimizes dv respect current graph fe 
return easy see generalization weighted case heuristic previous section 
expected performance ratio better log 
natural heuristic merit 
fact shown achieves ratio better general problem weighted hypergraph covering weighted set covering 
sections different approximation algorithms achieve ratio 
simple randomized algorithm due pitt 
subsequent sections 
approximating weighted vertex cover page describe deterministic approximation algorithms 
simple intuitive algorithm efficient achieves efficiency cost 
amount history order point 
approximation algorithm implicit nemhauser trotter 
algorithm explicit hochbaum 
hochbaum devised approximation algorithm set cover problem performance ratio equal size largest set 
implied factor approximation vertex cover 
results extensive linear programming formulation 
purely combinatorial analysis due bar yehuda followed algorithm clarkson 
algorithms essentially performance ratio asymptotically equal 
algorithms due hochbaum achieve performance ratio gamma decreasing function best algorithm due bar yehuda monien achieves ratio gamma log log log marginal improvement turns quite crucial leads strong results graph coloring 
deterministic algorithm derived nemhauser trotter second due clarkson 
describe algorithm bar yehuda show encompasses algorithms mentioned 

randomized approximation algorithm section generalize randomized algorithm ra described earlier weighted case 
basic idea remains difference bias coin flip stage 
choose point edge consideration probability inversely proportional weight 
notice algorithm exactly algorithm ra restricted unweighted graphs 
algorithm chapter 
vertex cover set cover page input graph weight function output vertex cover 
order edges arbitrarily 
pick edge fu vg choose randomly fu vg prob gamma 
return notice algorithm captures advantages algorithm wg allowing possibility consistently choosing wrong point stage 
particular high degree vertices higher chance chosen stage coin flip biased favor lower weight vertex 
ratio weight current degree determines chances vertex selected stage 
theorem due pitt 
theorem exp delta bound tight 
rest section devoted proof theorem 
fix input instance order edges examined optimal weighted vertex cover suppose execute algorithm obtain cover random subset distribution totally determined prior execution algorithm 
definition vertex define random variable follows 

approximating weighted vertex cover page exp denote expected value 
denote actual expected contributions vertex cover distribution value totally determined prior execution algorithm 
value output expected value expressed follows 
exp goal appropriately generalize analysis algorithm ra 
idea consider vertices show vertices formed significant fraction vertices similar argument 
definition denote vertices optimal cover chosen 
fixed prior execution algorithm clear exp follows exp lemma show expected weight output twice expected weight combined inequality implies result theorem 
lemma exp delta exp proof proof best described terms game played input graph 
suppose vertex dollars initial capital 
capital fixed prior execution algorithm 
total money supply graph initially exactly expected weight algorithm output 
chapter 
vertex cover set cover page assume exists global strategy vertex distribute capital incident edges edge gets exactly amount money endpoints 
having collected money points edge returns partitions equally points belong optimal cover points belong edge just returns amount received hand point belonged gets back twice amount money initially handed edge 
hard see transactions vertex doubled fortune vertex bankrupt 
follows total money supply twice initial money supply control vertices recalling vertex started sum money equal interpret delta equivalent statement lemma 
thing left show global strategy distributing capital edges exists 
strategy exist 
consider vertex vertex cover incident edges chooses place 
expected contribution vertex cover weight contributions due incident edges selecting cover 
edge contributes equal amount point choice bias coin flips 
preceding argument merely uses distribution strategy relate weight cover optimal cover obvious manner 
formalize distribution strategy follows 
call edge critical covered time algorithm considers 
critical edges cause coin flip addition vertex say vertex chosen coin flip critical edge fu vg coin flip causes added definition vertex gamma define ran 
approximating weighted vertex cover page dom variable chosen due critical edge fu vg notice edge fu vg exactly non zero 
vertex incident edges choose 
gamma conclude exp gamma exp non zero expectations non zero expectation taken possible random choices 
claim exp exp edges fu vg 
claim implies existence desired distribution strategy 
vertex give give sum money equal exp edge fu vg edge receive amount money points 
validate claim observe choice bias coin flip ensures symmetry expected contribution critical edges points 
formally exp theta prob fu vg critical chooses theta prob fu vg critical theta theta prob fu vg critical theta theta prob fu vg critical chooses exp chapter 
vertex cover set cover page 
nemhauser trotter algorithm nemhauser trotter considered integer programming formulation problem 
variable vertex takes values edge creates constraint variables associated points sum 
feasible solution set constraints corresponds naturally vertex cover graph 
objective function simply weighted sum variables weights exactly weights corresponding vertices 
showed optimal solution lp relaxation problem semi integral property 
words basic feasible optimal solution corresponding linear programming relaxation assign values variables drawn set 
linear program optimal solution interpreted fractional vertex cover value variable denoted fraction corresponding vertex placed cover 
constraints require edge total fraction points fractional cover exceed 
follows semi integral solution obtain approximation optimal integral cover placing vertex cover corresponding variable non zero 
hard see linear program solved maximum flow computation unweighted case solved maximum matching algorithm 
combinatorial interpretation process obtain approximation algorithm refer linear programming formulation 
results nemhauser trotter general bearing approximation problem 
definition cover graph multiset edge je sj 
essentially cover multiset vertices edge points copies point multiset 
may assume loss generality 
approximating weighted vertex cover page vertex occurs twice cover throw away copies vertex destroying property cover 
observe doubling value variable solution linear program yield cover 
relation covers vertex covers explicit fact proof left exercise 
definition denote set underlying multiset set obtained retaining exactly copy element fact cover vertex cover define weight cover obvious way sum weights vertices cover weight multiplied multiplicity corresponding vertex 
optimal cover cover minimum weight 
notice optimal cover copies vertex 
set underlying cover total weight half cover 
vertex cover making copies vertex cover yield cover twice weight 
proved lemma 
lemma weight optimal cover twice weight optimal vertex cover 
find approximation optimal weighted vertex cover suffices find optimal weighted cover turns optimal cover polynomial time 
basic idea consider bipartite version input graph 
bipartite graph copies vertex weight 
side bipartition 
edge creates edges bipartite graph 
definition graph weight function vertices 
define bipartite graph bg chapter 
vertex cover set cover page ffl fv ffl fv ffl ffv fv fv ffl set vertices denote copies vertices copies vertices corresponding set vertices denoted sg lg rg lemma vertex cover bg converted cover equal weight 
proof vertex cover bg construct multiset replacing vertex copy corresponding vertex note underlying set exactly cg edge placed edges edges point implies points copies points follows cover weight trivially equal weight lemma proves converse lemma 
lemma cover converted vertex cover bg equal weight 
proof recall considering covers copies vertex 
denote set underlying multiset define nc set vertices occur twice 
consist vertices correspond vertices vertices 
approximating weighted vertex cover page correspond vertices clearly sets equal weights 
show vertex cover bg consider edge fu vg edges corresponding covered assume loss generality occurs twice means edges corresponding covered 
lemmas shown finding optimal cover equivalent finding optimal vertex cover bg show done polynomial time summarize nemhauser trotter algorithm follows 
algorithm nt input graph weight function output vertex cover 
compute graph input 
compute optimal weighted vertex cover 
return fv preceding lemmas imply vertex cover graph weight twice optimal weighted vertex cover theorem 
show bound theorem tight 
theorem briefly sketch algorithm finding optimal weighted vertex cover bipartite graph 
problem restricted bipartite graphs polynomially solvable reduction maximum chapter 
vertex cover set cover page flow problem 
works constructing directed network bg introduce source bg edge going vertex capacity equal weight vertex 
similarly introduce sink edge coming vertex capacity equal weight vertex 
direct edge capacity infinite 
minimum cut resulting network computed maximum flow computation 
minimum cut finite net flow source finite 
edge cross cut 
words case edge lies side side set vertices lying side set vertices lying side forms vertex cover bg capacity cut exactly equal weight vertex cover 
similarly fairly easy see vertex cover implies cut capacity equal weight vertex cover 
vertex cover determined min cut minimum weight vertex cover 

clarkson algorithm consider greedy algorithm wg proposed earlier problem 
basic idea algorithm keep track ratio weight current degree vertex stage selected vertex smallest value ratio 
right thing intuitive level minimize average increase weight vertex cover edge covered 
unfortunately algorithm achieve bounded ratio 
intuitively attractive heuristic 
answer exactly algorithm proposed clarkson 
modified greedy algorithm mga follows basically approach weights vertices modified algorithm progresses 
recall algorithm wg modifying degrees vertices account edges covered 
description algorithm mga ignore edge cost function 
approximating weighted vertex cover page ec merely artifact algorithm analysis 
denote current weight degree vertex point execution 
algorithm mga input graph weight function output vertex cover 


ec 

pick vertex minimized gamma edges fu vg gamma gamma gamma ec 
return algorithm differs wg time vertex placed cover neighbors weight reduced amount equal ratio selected vertex current weight degree 
exactly cost covering edge vertices value ec reflects cost 
note value chapter 
vertex cover set cover page ec algorithm 
may counter intuitive increasing likelihood picking vertex neighbor just included cover 
approximation algorithm trying pick optimal solution 
tries pick solution provably far optimum reduction weights neighbors viewed attempt ensure error algorithm small 
fact reduction weights exactly enable argue algorithm output far optimal 
argument proceeds follows 
edge cost ec viewed cost covering edge algorithm assigns costs edges manner guarantees vertex cover partitions weight incident edges edge gets assigned weight points 
weight cover produced twice net cost edges 
choice edge cost function easily seen optimal cover weight large total edge costs 
clear counter intuitive part algorithm device ensuring cover produced stray far optimal cover 
discussion point refer article gusfield pitt 
fact vertices edges ec times execution algorithm 
proof second inequality obvious modification edge costs addition positive value 
inequality notice current weight vertex reduced vertex fact neighbor selected 
implies selected vertex smaller weight degree ratio result subtraction non negative 

approximating weighted vertex cover page fact easy verify description algorithm 
fact vertices gamma ec times execution algorithm 
fact follows description algorithm fact 
fact algorithm execution gamma ec gamma ec facts conclude lemma relates weight mga output book keeping variables edge costs 
lemma delta ec proof observe equation gamma ec edge counted twice expression implying desired result 
step relate edge costs value optimal solution 
lemma ec chapter 
vertex cover set cover page proof observe ec gamma ec second expression count edge vertex cover 
fact desired result 
putting lemmas result weight twice optimal 
fairly easy see entire algorithm efficiently implemented standard data structures 
theorem showing bound performance ratio best possible left exercise 
theorem algorithm mga runs time log time 

improved vertex cover approximations section algorithms marginally improve approximation ratio vc 
algorithms achieve ratio better asymptotic sense 
performance ratios type gamma decreasing function function delta delta maximum degree input graph 
best result due bar yehuda monien achieve ratio gamma log log log 
improvement may minor leads significant improvement approximation ratio graph coloring problem considered subsequent chapter 
example graphs vertices ratio achieved 
version result due bar yehuda 
sections develop main ideas result parts 
return algorithm show allows restrict 
improved vertex cover approximations page approximating graphs optimal solution large weight 
local ratio theorem allows strip certain kind subgraph input graph adversely affecting approximability remaining graph 
show graph small odd cycles vertex cover approximated provided optimum solution large weight 
removal odd cycles performed theorem 

nemhauser trotter algorithm revisited take fresh look nemhauser trotter algorithm section conclude suffices able approximate instances value optimal solution 
recall optimal weighted vertex cover computed polynomial time 
contain vertices optimal cover vertices optimal cover 
delta fv delta fv theorem re statement results nemhauser trotter provide different proof theirs 
parts theorem referred local optimality conditions 
theorem sets produced algorithm nt properties 

vertex cover vertex cover 
exists optimal cover chapter 
vertex cover set cover page 
optimal solution weight half total weight vertices proof 
know vertex cover fact exactly vertex cover produced algorithm nt set covers edges point vertex cover clear covers edges 
consider edge fx yg type edge create problem 
choice implies contained assume loss generality contained edge fy covered having case implies covers edge fx yg done 

optimal cover claim optimal cover validate second part theorem observe vertex cover previous part theorem vertex cover see optimality observe cb vertex cover consider edge fx covered cb assume conditions met 
cover covered edges fx fy containing case gives contradiction edge fx yg covered vertex cover cb vertex cover follows weight 
improved vertex cover approximations page optimal cover cb delta gamma gamma implies optimal cover contains 
optimal cover 
part theorem vertex cover follows vertex cover weight large optimal cover exactly delta 
delta delta implies delta 
try understand implications theorem 
shows compute single max flow computation subset vertices compute optimal vertex cover compute optimal vertex cover graph fact optimal vertex cover set provided algorithm nt course merely get sure see parts theorem imply claims 
approximation ratio optimal cover combined gives approximation ratio entire graph established corollary 
corollary instance 
algorithm nt computes subsets approximation optimal weighted vertex cover approximation optimal weighted vertex cover optimal solution value half large 
chapter 
vertex cover set cover page corollary need worry finding approximation algorithm instances value optimal solution half total weight vertices 
notice trivial approximation simply set vertices graph gives approximation algorithm ratio 
algorithm exactly algorithm nemhauser trotter 

local ratio theorem going describe new technique obtaining approximation algorithm due bar yehuda 
show partition weight function gives instances optimal solutions yield optimal solution original instance 
lemma graph weight functions vertex set optimal weighted vertex covers instances proof 
improved vertex cover approximations page inequality follows observation vertex cover weight respect weight function smaller weight optimal cover respect weight function 
apply lemma follows 
vh eh fixed graph 
suppose find induced subgraph isomorphic determine weight function non zero vertices subgraph weight function obtained subtracting lemma finding optimal solutions respect new instances gives optimal solution original instance 
fact show suitable choice strong claims approximative behavior 
algorithm approximation algorithm 
approach run algorithm instance handle instance separately 
formalize decomposition algorithm parametrized choice algorithm local input graph weights assumed fixed advance 
output vertex cover 
find set vertices induced subgraph isomorphic 
ffi min 
choose weight function follows gamma ffi 
run algorithm instance obtain vertex cover chapter 
vertex cover set cover page 
return point questions may arise readers mind 
choose algorithm 
defer answers questions 
show choice quality approximation produced algorithm local characterized 
notice worrying instance corresponding ffi subtracted 
merely studying ratio optimal cover produced invocation algorithm instance 
observe ffi really instance vc vertex weights identically ffi 
definition fixed graph jv nh size optimal unweighted vertex cover define local ratio nh example graph cycle vertices nh gamma theorem bounds approximative ratio cover produced algorithm local 
theorem ra proof larger ra 
denote value optimal solution instance 
jc jv nh ffin ra delta ffir delta ffic delta inequality obtained preceding lemma follows 
observe value optimal solution ffi simply 
improved vertex cover approximations page ffi times size optimal unweighted vertex cover ffic claim weight optimal solution instance gamma non zero vertices optimal cover obtained augmenting optimal unweighted cover vertices weight 
follows satisfy premise lemma 
theorem referred local ratio theorem 
hard see idea generalized class graphs just graph denote family graphs 
define hg 
new algorithm called 
basic idea enumerate induced subgraphs isomorphic graph apply operation reducing weights exactly algorithm local 
vertices weight set aside algorithm applied remaining graph 
algorithm input graph weights assumed fixed advance 
output vertex cover 

isomorphic ffi ug vertices gamma ffi 
fv 
chapter 
vertex cover set cover page 
run algorithm instance obtain vertex cover 
return exact implementation step deliberately left unspecified 
intent iterations applied enumeration induced subgraphs isomorphic graphs exact ordering enumeration irrelevant chosen algorithm efficient 
way enumerate sets ju hg check isomorphic graph done polynomial time provided number vertices graphs fixed independent jv see structured class graphs relax requirement 
step case induced subgraph isomorphic graph vertex weight equal 
means subgraph vertex conclude remaining graph subgraph isomorphic graph clear algorithm useful appropriate choice easier guarantee near optimal cover easily 
words algorithm perform inputs subgraphs isomorphic graphs notice ways constrained choice enumeration step easy perform 
quality approximation produced algorithm result called local ratio corollary 
proof simple induction number iterations step local ratio theorem iteration 
leave proof exercise 
corollary family approximation algorithm ffl ra 
improved vertex cover approximations page ffl subgraphs isomorphic graphs applications result 
consider case family contains graph simply edge 
case 
applying corollary show local 
graph empty induced subgraphs isomorphic edge 
need algorithm case 
equivalent description resulting algorithm 
exactly linear time approximation algorithm ratio devised bar yehuda 
algorithm edge input graph weight function output vertex cover 
points non zero weight pick edge fu vg points non zero weight ffi gamma ffi gamma ffi 
return fv 
amazingly approximation algorithm algorithm nt viewed version 
example consider algorithm mga described previous section 
thought generalization edge picks copies graph edge simultaneously sharing common vertex 
choice common vertex possible subtract equal chapter 
vertex cover set cover page amount weight edges making new weights negative 
clearly merely implementation detail bearing ratio achieved 
application local ratio theorem improving performance ratio algorithm devised hochbaum 
algorithm novel idea 
run algorithm nt obtain instance optimal solution weight half 
suppose color input graph colors 
color class largest weight 
output gamma vertex cover 
clear vertex cover color class independent set complement independent set vertex cover 
choice implies gamma gamma graph colored delta colors follows prove graph delta colorable 
obtained approximation algorithm performance ratio gamma delta special case planar graphs improve ratio noting planar graph colored 
observe approximate graph coloring algorithm wigderson see chapter color graph colors provided triangle free 
helps improving algorithm hochbaum conjunction local ratio corollary 
idea choose containing graph viz 
triangle graph 
run input graph obtain triangle free graph 
run algorithm nt obtain graph triangle free optimal solution value half total weight graph 
point run wigderson algorithm obtain coloring colors 
implies approximation ratio gamma details analysis fairly straightforward 

improved vertex cover approximations page 
algorithm graphs small odd cycles seen algorithm nt obtain approximation algorithms performance ratios gamma 
bar yehuda improved previously known performance ratios combining algorithms particular fashion 
basic idea eliminate odd cycles small length 
algorithm nt guarantee graph large optimal vertex cover 
simple algorithm obtain approximation resulting graph 
algorithm 
definition instance said proper conditions satisfied 
ffl gamma ffl odd cycles length smaller gamma 
ffl denote distance 
sets represent collection vertices distance determined linear time performing breadth search starting algorithm finds approximation instance proper 
basic idea fix vertex find sets contain vertices distance vertices distance 
clear pair vertices length path joining adjacent creating odd cycle length gamma 
possible obtain independent set 
note gamma contains vertices distance claim covers edges point algorithm chooses value guaranteed chapter 
vertex cover set cover page weight small fraction 
done choosing smallest value gamma gamma 
problem required weight large weight subsequent keeps increasing factor gamma follows exhaust vertices graph time set removed graph ensure placed cover 
process repeated till vertices removed 
algorithm input graph weight function proper 
output vertex cover 


pick vertex max fw ig gamma minft gamma gamma gamma 
return obvious algorithm implemented run time polynomial size input 
obtain result output algorithm 

improved vertex cover approximations page theorem set produced algorithm vertex cover rc gamma proof claim see note 
gamma gamma implies 
gamma gamma 
gamma jv delta implying contradiction 
claim gamma independent set 
vertices gamma adjacent 
distance odd definition implies existence odd cycle containing length gamma possible proper 
consider edge point incident gamma points gamma covers edge gamma independent set 
hand endpoint lies gamma lie point distance lie gamma follows edge incident gamma covered conclude vertex cover remains bound weight vertex cover 
definition gamma gamma gamma gamma iteration set added cover sets gamma deleted graph 
clear gamma 

algorithm vertex cover algorithm specified terms algorithms nt algorithm chapter 
vertex cover set cover page takes input instance 
thought algorithm algorithm slightly different manner 
denote graph consists cycle vertices 
algorithm input graph weight function output vertex cover 
smallest integer gamma 
fc gamma 
run algorithm obtain residual instance 
run algorithm nt obtain sets 
run algorithm obtain cover 
return fairly easy see entire algorithm runs polynomial time provided implemented polynomial time 
try compute possible odd cycles length upto gamma running time super polynomial 
strategy enumerating small number odd cycles vertex cycle weight reduced odd cycles length gamma contains vertices positive weight 
clearly valid implementation 
enumerate odd cycles pick node non zero weight construct breadth tree rooted node 
odd cycle length containing adjacent vertices distance implies pair nodes level 
approximating set cover page tree adjacent 
adjacent pair nodes level determine odd cycle containing length 
exists pair adjacent vertices level gamma compute odd cycle length determined tree vertices 
reduce weights specified 
odd cycle containing eliminate contention iteration 
repeat process outlined 
claim iteration vertex eliminated consideration root breadth tree vertex weight reduced eliminated 
follows number iterations iterations graph contain odd cycles length gamma vertices weight 
running time entire algorithm polynomial size input 
fact running time dominated algorithm nt uses max flow computation 
clear algorithm performance ratio gamma formally verified results proved previous sections algorithms nt note choice log log log result 
theorem algorithm computes vertex cover polynomial time ra gamma log log log 
approximating set cover hypergraph representing instance unweighted set covering problem 
generalize notion degree vertex hypergraph 
definition number edges contain maximum degree hypergraph chapter 
vertex cover set cover page usual cover collection vertices hypergraph edge contains vertex definition size minimum cover hypergraph known constant factor approximation minimum cover hypergraph 
fact evidence effect approximation impossible find polynomial time 
best known approximation algorithm performance ratio log independently discovered johnson lovasz 
similar result achieved case weighted hypergraphs 
result unweighted hypergraphs 
algorithm essentially greedy algorithm generalized hypergraphs 
refer generalized algorithm 
algorithm input hypergraph 
output set cover 

pick vertex maximum degree current hypergraph fe 
return 
approximating set cover page presentation lovasz 
need notation course analyzing 
fractional cover hypergraph essentially feasible solution lp relaxation integer programming formulation covering problem 
choice fraction vertex edge total fraction vertices selected 
definition fractional cover hypergraph weight function 
edges definition denote size optimal fractional cover min matching hypergraph natural generalization matching graph collection independent edges 
generalize notion matching follows 
definition matching hypergraph subset vertex contained edges words sub hypergraph degree definition denote size number edges maximum matching hypergraph sake brevity omit dependence input hypergraph assuming input fixed 
elementary relations quantities 
follows observation cover fractional cover 
fact chapter 
vertex cover set cover page fact follows linear programming duality provide elementary proof 
fact proof maximum cardinality matching jm consider optimal fractional cover know edge edge total weight jm left hand side inequality vertex occurs times 
delta noting desired result 
ready show algorithm performance ratio log 
suppose algorithm chooses vertices order produce cover size lemma bounds value terms matching numbers pay particular attention term series 
lemma delta delta delta delta delta delta gamma gamma delta proof note maximum degree degree jej 
observe number new edges covered successive non increasing function refer number new edges covered covering degree 
number times algorithm selects vertex covering degree course execution 

approximating set cover page covering degree gamma covering degree gamma 
conclude gamma delta delta delta jej dt gamma gamma delta delta delta denote hypergraph defined collection uncovered edges gamma delta delta delta vertices selected 
clearly maximum degree hypergraph implies matching je notice edges covered gamma delta delta delta iterations 
gives equation jm je gamma gamma delta delta delta jt suitable algebraic manipulation yields inequality stated lemma 
ready prove main theorem 
theorem rg log proof facts combining previous lemma obtain gamma 
log chapter 
vertex cover set cover page words 
log opt implying desired result 
exercise show bound performance ratio best possible 

discussion algorithms described perform operations counter intuitive 
example mga reduces weights neighbors vertices cover increasing likelihood neighbors selected cover 
see gusfield pitt partial explanation algorithms perform better intuitive algorithms 
gives unified view algorithms considered 
hochbaum gives bounded ratio approximation algorithms related problems viz 
independent sets coloring bounded degree graphs planar graphs 
result cover approximation algorithm weighted set cover due 
algorithm generalization greedy algorithm described set cover 
result case set cover may viewed bounding ratio optimal integral cover fractional cover hypergraphs 
see erdos linial general version result study ratio optimal fractional integral solutions class integer programs 
different version set cover studied johnson 
objective find collection vertices cover edges value cover defined sum degrees vertices cover size cover 
results obtained similar described set cover problem 

discussion page problems recall result proved earlier chapter showed absolute approximation algorithm clique assuming np 
prove similar result set cover 
consider algorithm mga weighted vertex covering due clarkson 
prove variation result class 
unweighted graph maximum degree delta optimal vertex cover size gamma delta gamma seen greedy algorithm lovasz guarantees log factor approximation set cover problem 
prove best bound possible exist instances bound achieved greedy algorithm 
prove similar result greedy algorithm weighted vertex cover 
consider problem called rectangle covering rc 
instance collection rectangles fr plane rectangle aligned axes sides horizontal perpendicular 
note rectangles may overlap 
feasible solution collection points fp pm rectangle contains point goal minimize jp provide best approximation algorithm problem 
say hardness approximating problem 
chapter 
vertex cover set cover page bibliography erdos linial optima dual integer programs combinatorica pp 

appel haken planar map colorable part discharging illinois journal mathematics pp 

appel haken koch planar map colorable part ii reducibility illinois journal mathematics pp 

bar yehuda linear time approximation algorithm weighted vertex cover problem journal algorithms pp 

bar yehuda approximating vertex cover planar graphs proceedings th annual acm symposium theory computing pp 

bar yehuda local ratio theorem approximating weighted vertex cover problem annals discrete mathematics pp 

bern karloff raghavan schieber fast geometric approximation techniques geometric embedding problems proceedings fifth annual symposium computational geometry pp 

bondy murty graph theory applications north holland 
christofides worst case analysis new heuristic travelling salesman problem technical report graduate school bibliography page industrial administration carnegie mellon university pittsburgh pa 
greedy heuristic set covering problem mathematics operations research pp 

clarkson modification greedy algorithm vertex cover information processing letters pp 

coffman garey johnson approximation algorithms bin packing updated survey algorithm design computer system design ed 
ausiello serafini springer verlag 
garey johnson approximation algorithms combinatorial problems annotated bibliography algorithms complexity new directions results ed 
traub academic press 
garey johnson strong np completeness results motivations examples implications journal acm pp 

garey johnson computers intractability guide theory np completeness freeman 
cited page 
gilmore linear programming approach cutting stock problem operations research pp 

graham bounds certain multiprocessing anomalies bell systems technical journal pp 

grotschel lov asz schrijver ellipsoid method consequences combinatorial optimization combinatorica pp 

grotschel lov asz schrijver geometric algorithms combinatorial optimization springer verlag 
guibas personal communication 
bibliography page gusfield pitt understanding approximations node cover subset selection algorithms technical report yaleu dcs tr department computer science yale university 
hansen approximation algorithms geometric embeddings plane applications parallel processing problems proceedings th annual symposium foundations computer science pp 

hochbaum approximation algorithms set covering vertex cover problems siam journal computing pp 

hochbaum efficient bounds stable set vertex cover set packing problems discrete applied mathematics pp 

np completeness edge coloring siam journal computing pp 

horowitz sahni fundamentals computer algorithms computer science press 
ibarra kim fast approximation algorithms knapsack sum subset problems journal acm pp 

johnson np completeness column ongoing guide journal algorithms pp 

johnson approximation algorithms combinatorial problems journal computer system sciences pp 

johnson demers ullman garey graham worst case performance bounds simple onedimensional packing algorithms siam journal computing pp 

kannan korte approximative combinatorial algorithms mathematical programming ed 
korte pp 

bibliography page new polynomial time algorithm linear programming combinatorica pp 

karp efficient approximation scheme dimensional bin packing problem proceedings rd annual symposium foundations computer science pp 

karp fast approximate solution hard combinatorial problems proceedings th southeastern conference combinatorics graph theory computing mathematics pp 

korte existence fast approximation schemes nonlinear programming pp 

kucera complexity clique finding algorithms unpublished manuscript 
lawler combinatorial optimization networks matroids holt rinehart winston 
lawler fast approximation algorithms knapsack problems proceedings th annual symposium foundations computer science pp 

lawler lenstra rinnooy kan shmoys sequencing scheduling algorithms complexity handbooks operations research management science vol 
logistics production inventory 
lenstra integer programming fixed number variables mathematics operations research pp 

lipton tarjan applications planar separator theorem proceedings th annual symposium foundations computer science pp 

lov asz ratio optimal integral fractional covers discrete mathematics pp 

bibliography page monien ramsey numbers approximation algorithm vertex cover problem acta informatica pp 

efficient approximation scheme bin packing siam journal computing pp 

nemhauser trotter jr vertex packing structural properties algorithms mathematical programming pp 

complexity approximate solution combinatorial problems soviet mathematical doklady pp 

papadimitriou steiglitz combinatorial optimization algorithms complexity prentice hall 
th 
theorem approximation set cover vertex cover appear eleventh conference foundations software technology theoretical computer new delhi india 
pitt simple probabilistic approximation algorithm vertex cover technical report yaleu dcs tr department computer science yale university 
rosenkrantz stearns lewis analysis heuristics traveling salesman problem siam journal computing pp 

savage depth search vertex cover problem information processing letters 
sahni approximate algorithms knapsack problem journal acm pp 

sahni general techniques combinatorial approximation operations research pp 

sahni gonzalez complete approximation problems journal acm pp 

bibliography page schrijver theory linear integer programming john wiley sons 
vaidya geometry helps matching siam journal computing pp 

vaidya approximate minimum weight matching points dimensional space algorithmica 
fernandez de la vega lueker bin packing solved ffl linear time combinatorica pp 

wigderson improving performance guarantee approximate graph coloring journal acm pp 

