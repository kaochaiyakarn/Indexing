agreeing processor group membership timed asynchronous distributed systems cristian computer science engineering university california san diego la jolla ca gamma frank schmuck ibm almaden research center harry road san jose ca gamma introduce timed asynchronous distributed system model describe existing asynchronous distributed systems subject unbounded processing communication delays failures recoveries 
describe increasingly strong specifications processor group membership services timed asynchronous systems subject partitioning 
propose distributed protocols implement specifications despite arbitrary numbers crash performance processor failures omission performance communication failures prove correctness 
show protocols adapted implement highly available processor leadership service ensures existence leader point real time 
keywords agreement asynchronous system distributed system failure detection fault tolerance leader election mutual exclusion network partition processor membership replicated data 
partially supported air force office scientific research sun microsystems microelectronics innovation computer research opportunities california 
ucsd technical report cse published distributed algorithms described terms fixed group active processes communicate messages achieve certain goal 
real systems groups dynamic shrinking failures occur growing communication services processes recover 
earlier cri specified proposed solutions processor group membership problem synchronous distributed systems atomic broadcast guarantees timely communication pair correct processors 
communication certainty achieved real time executives bound communication delays massive redundancy avoid physical partitioning 
shown process group membership service implemented top processor group membership service 
investigates specify solve processor group membership asynchronous distributed systems unbounded delays partition occurrences communication uncertain 
deal problem implementing process group membership service top processor group membership service solution discussed cri adapted asynchronous communication environment straightforward way 
objective specifying solving membership problem presence communication uncertainty problem complex synchronous case studied cri 
processes distinguish peer processor failures communication failures correct processes lose communication may take conflicting actions assumes failure illustrated membership protocol car 
tandem protocol loss delay successive am alive messages processors cause adopt diverging membership views turn lead conflicting actions promotion servers primary backup process group role primary 
resulting system behavior known split brains behavior tandem terminology car result total system crashes 
defining mean asynchronous system failures 
asynchronous system model theory community flp notion time system model assumes processors local clocks allow measure passage time 
avoid confusion refer system model flp time free asynchronous system model call model timed asynchronous system model 
existing distributed systems non real time operating systems communication services unix udp timed asynchronous captured definition 
timed asynchronous system model comparison asynchronous system model discussed flp key contributions 
proceed presenting sequence increasingly strong specifications processor membership timed asynchronous systems comment related practice different higher level applications 
sequence membership specifications discussion relating requirements placed membership service higher level applications second major contribution 
key contribution description suite protocols implementing specified services description services solve highly available leadership problem cri 
necessarily ambiguous english protocol descriptions complemented unambiguous formal protocol code appendix 
appendix contains proofs protocols satisfy respective specifications solutions solving highly available leadership problem correct 
related membership problem defined synchronous systems cri 
problem subject intense investigation asynchronous systems 
types asynchronous membership services described primary partition membership rb kt mps hs nei partitionable membership ems 
membership services explicitly assume time free underlying system model rb mps hs entirely clear underlying system model time free variant timed system model 
primary partition services intended systems subject partitions systems allow group membership change physical network partition called primary partition 
primary partition membership services attempt ensure existence single group point time similar round round majority membership protocols guarantee existence completed majority group point time 
main difference primary partition approaches published far assume partitioning possible quite natural especially presence network congestion long lasting physical failures numeric majority criterion ensure uniqueness distinguished group time assuming operator designated primary physical partition 
contrast primary partition membership services partitionable membership services allow existence multiple parallel groups point real time 
services allow groups split smaller groups consequence failure occurrences enable smaller groups merge bigger groups timely communication restored 
partitionable membership services resemble round round partition detection membership services 
timed asynchronous system model pointed widely cited papers rb dms attempt give formal specifications primary partition partitionable asynchronous membership services updated versions ric rb dms contain specification faults rb ric rb flaws logical formalism allow undesirable executions specification dms dms satisfied trivial useless protocols 
shows protocols rb allow certain executions violate safety liveness requirements specified authors 
existence faults widely cited research articles taken indication difficult problem specifying implementing asynchronous membership services really hope specifications protocols suffer shortcomings partly assume timed asynchronous system model 
pointed useful membership service implemented time free asynchronous system model subproblem common services provably solved time free model 
timed asynchronous system model consider system consisting set processors linked datagram communication service 
specifications processor communication services timed prescribe state transitions outputs occur response input events clock ticks message arrivals real time intervals state transitions outputs occur 
processors share storage gain information sending receiving messages measuring passage time 
assume processors access private hardware clocks drift rate bounded 
current technologies bound order gamma gamma seconds second 
errors introduced small drift measuring timeout durations discussed insignificant ignore simplicity 
assume total order set processor names 
denote processors assume processor access private stable storage service 
processors crash performance failure semantics cri 
performance failures include processor slow clock running slow fast 
crashes partial amnesia crashes restart state stable storage crash state volatile storage reinitialized 
follows say processor fails mean suffers crash performance failure 
correct processor non crashed timely 
assumption physical network topology 
arbitrary point point topology broadcast topology local area network wide area network 
assume existence datagram communication service allows processor send messages processor 
message routing forwarding performed timed asynchronous system model datagram service layer underlying physical network fully connected 
error detecting codes detect message corruption datagram service omission performance failure semantics 
say unqualified communication failure occurs mean omission performance failure 
omission failures occur physical message corruption buffer overflows performance failures occur actual delay experienced message exceeds timeout delay ffi specified datagram service 
assume way timeout value ffi endto delay includes operating system overhead sending receiving processor including interrupt scheduling delays message processing delays 
furthermore delay ffi chosen minimize likelihood false communication failure detections acceptably low risk level 
reduce probability false alarms common practice re send message timed finite number times giving 
number retries determined empirically attempts message known arrived destination sending times significantly increase likelihood sent successfully 
follows assume timeout delay ffi membership protocols large accommodate lower level retries 
re sending messages times giving prevent lost late datagram service interface mention lower level retries 
call system processors communication services satisfies hypotheses listed timed asynchronous system 
existing distributed systems nonreal time operating systems communication services unix udp timed asynchronous 
previous publications cri cri cri cm called systems simply asynchronous opposed synchronous system model investigated cri cri 
unfortunately caused confusion authors flp term asynchronous system different meaning 
difference comes fact processor communication services interest timed processor communication services investigated flp time free 
service specifications considered flp independent notion time specify state input state output produced imposing constraint real time take state transition output occur 
time free processor definition correct take arbitrary amount time days centuries react actual input 
weak definition correctness impossible distinguish crashed merely slow correct processors 
time free asynchronous system sense want detect crash failures logically talk performance failures 
order able detect commonly observable failures practical system services timed previous papers true services encountered practice incomplete vague specifications timed asynchronous system model interested timed systems refer timed asynchronous systems simply asynchronous follows 
due low processor communication failure rates achievable current technologies reasonable expect correct processors asynchronous system achieve timely communication time 
due congestion adverse phenomena processors may temporarily disconnected 
model assume point time communication processors states connected disconnected partially connected 
states directly observable system imply correctness messages sent connected time interval correct non crashed timely message sent ffi delivered processed ffi time units 
disconnected time interval crashed crashed messages sent delivered partially connected processor correctness message delivery states introduced allow person reasons protocol properties predict happens messages sent allow evaluate communication mode certain instant evaluation impossible processors predict 
call distributed system stable time interval processor fails recovers messages delivered delivered ffi time units sending pairs processors connected disconnected connected relation processors constant transitive 
call set processors pairwise connected physical partition stable system consist disjoint physical partitions 
low processor communication failure recovery rates observed practice tuned asynchronous system alternate long stability periods comparatively short instability intervals 
stability condition similar global stabilization requirement dls proven sufficient solving consensus 
global stabilization requires certain global system stabilization time system experience omission performance communication failures stability condition weaker property assumes absence failures certain pairs processors finite time intervals 
way add synchrony time free system augment failure detectors cht 
find timed model difficult compare explicitly mention response time promises true services timed higher level abstraction depends worst case human user fixes timeout delay deciding failure 
history dependent approach communication time free model augmented failure detectors 
example open question failure detectors implementable timed model 
far proven perfect failure detector implementable timed system fc 
difference models system design philosophy 
failure detectors aim hiding higher levels abstraction time related aspects fault tolerant distributed computation detection failures higher levels timeouts 
idea certainly appealing glance believe works practical systems usually levels abstraction 
multi layer systems know employ timeouts abstraction level level depends cri level able detect mask means possible failures lower level 
general timeouts different levels different higher level larger timeout 
example connection service tcp ip timeouts orders minutes retransmit unacknowledged messages mailing service depends connection service typically uses timeouts orders hours re transmit unacknowledged mail 
timed model allows timers abstraction level course allows kind programming done naturally 
programming possible time free model augmented failure detectors timers unavailable failure detector layer 
measurements done dependable systems lab ucsd cf confirm timed asynchronous system model introduced captures going existing distributed systems built networked workstations 
history dependent approach communication implement highly available distributed services processors structured teams 
processor team mean set processors capable implementing certain service 
example implement highly available file service want replicas file reside distinct processors processors structured member team 
service provided servers residing processors team inherently distributed communication messages correct team members essential prerequisite provision service 
example replicated file service distributed majority team members required performing update communication replica manager managers impossible manager provide update service 
exist principle approaches managing communication team members implement distributed service 
history independent approach team member interprets service request requires communicate members attempts communicate members irrespective success detecting system changes past communicating 
known example history independent approach voting gif 
service update request replicated implementation voting attempt communicate consecutive attempts communicating unsuccessful 
second history dependent approach team members adapt changing communication conditions attempting communicate group team members communicate successfully past 
idea team members history successful communication form dynamic communication working groups 
communication processor lost processor eliminated current group communication re established processor admitted new current group 
provide service team members obey rule limiting communication cooperation members current group 
group communication approach avoids useless attempts communicating members shut failed disconnected long time intervals 
example replicated file service case suppose successful communication past members group contain receives update request 
history dependent approach attempt communicate perform update saving cost sending message waiting timeout expiration message 
general group communication service implementations characterized lower message traffic better response times 
main complication introduced history dependent approach need group membership service 
addition improving performance service achieve agreement history groups exist time membership group cri 
allows users order failure recoveries occur time contributes simplify programming higher level applications see example synchronous asynchronous availability management services described cri cm respectively 
remainder propose possible group membership service specifications asynchronous distributed systems comment adequacy various higher level distributed services 
detecting system changes group membership management protocol thought consisting components protocol detecting changes system failures recoveries protocol reporting information consistently correct processors 
various membership protocols propose differ membership information updated failure recovery essentially techniques detecting events 
section discuss methods detecting failures recoveries 
detecting system changes detecting failures fault tolerant asynchronous protocols especially difficult design understand fact timed asynchronous distributed system impossible processor distinguish crash processor communication failure causes disconnected long period time transient communication failure causes message small number messages lost late 
cases simply observes communicate ffi time units 
minimum membership protocol provide processor disconnected processor system stable sufficiently long time interval correct interval detect disconnected periods system unstable correct processor able distinguish scenarios crashed suffers performance failure messages get lost late messages get lost delayed correct may receive messages main goal server groups mask processor failures cri communicate adopt decision allow mask real failure proceed failed 
decide failed expected receive message bounded time interval fact receive message interval 
consider system processors want ensure detects real failure bounded time disconnected sufficient processors periodically exchange messages 
ways doing 
processor send alive message time units learns alive 
failure lead absence answer message ffi time units 

processor send am alive message time units 
failure result receiving new am alive message ffi time units receiving message second approach requires fewer messages leads faster failure detection 
approach earlier synchronous membership protocols cri protocols 
detecting system changes consider system processors 
processor sent processor am alive message time units total gamma messages sent time units 
message traffic reduced observing necessary processors independently detect failure processor 
message economical way doing attendance list neighbor surveillance protocol cri 
attendance list protocol adopt algorithms works follows 
assume system currently stable consider physical partition processor 
define cyclic order assigns left right neighbor processor total order assumed processor identifiers ids follows left right neighbor processor processors lower higher id respectively special case processors lowest highest id defined right left neighbors 
check failure processor occurs processors agree say lowest identifier initiate circulation attendance list message time units 
message relayed processors right neighbor cyclic order described arrives back originator time processors know failed 
processor detects attendance list lost late may failed 
failure detection method reduces number am alive messages sent time units gamma cri proven minimum number messages exchanged detect member failures group members 
detecting recoveries detecting recoveries simpler detecting failures 
processor restarts crash simply send message processors letting know event 
messages get lost transient communication failures processors disconnected longer periods time probe messages fact sent periodically 
general sufficient processor group example lowest id periodically send probe messages 
optimization limit probe sending minority groups groups containing half processors members 
advantage normal situations processors members majority group probes sent recovery detection protocol algorithms 
denote period probe messages sent 
majority minority need necessarily defined simple numerical majority 
requirement majority groups defined member common 
independent assessment membership protocol notice mechanisms detecting failures recoveries independent rest membership protocol depend form agreement current membership 
example attendance list protocol assumes agreement processors neighbors false failures may detected optimizations sending probe messages depend agreement processor responsible sending messages 
independent assessment membership protocol minimum requirement membership service processor know system stabilizes processors connected ones 
denote members set mapping records processor local view current processor membership members yields set processors believes correct connected membership service satisfy timeliness requirements bounded join delays 
exists time constant jd processors connected jd system stable included members members respectively 
tpd bounded partition detection delays 
exists time constant pd processors disconnected pd system stable stays correct excluded members main difference timeliness properties required synchronous membership protocols described cri synchronous protocols required detect failures joins bounded delay independently system stable 
addition membership service report false failures recoveries 
mean system stable time elapsed protocol report previous failures recoveries max jd pd failures recoveries reported long system remains stable 
expressed safety requirement sld stability local views 
system stable correct processor members change max jd pd 
notation set stands set subsets set independent assessment membership protocol assume connected relationship transitive system stable periods stability set processors divided disjoint subsets physical partitions processors connected belong physical partition 
allows express requirements stated equivalent simpler form tcd view convergence 
exists time constant system stable correct processor members interval physical partition belongs straight forward see tcd implies sld tpd choose jd pd contains processors connected implies processors disconnected implies tpd 
conversely choose max jd pd apply tpd interval follows time members follows time members follows tpd 
apply sld interval follows members constant members 
fact sld implies members constant members equal 
requirements satisfied simple protocol processor starts initializes members fpg begins send am alive messages processor time units 
processor receives message adds members measures ffi time units received message subtracts members 
words am alive messages play double role probe messages detecting recoveries am alive messages detecting failures 
call protocol independent assessment protocol processor performs periodically independent assessment processors correct connected 
protocol satisfies requirements tpd 
determine jd delay consider connected processors system stabilizes time units send periodic am alive messages ffi time units messages received respectively 
jd ffi 
consider determination partition detection delay pd worst case scenario begins crash immediately sends am alive message system stabilized 
correct processor members am alive message may take long ffi arrive moment monitor receives am alive message ffi time units 
follows take pd ffi time units exclude members crashes 
max jd pd time units system stabilizes connected processors reach agreement identity processors connected sense variables members members equal contain round protocol identity processors connected recall connected relation transitive stability periods store forward networks corresponds stabilization routing tables correct state network perturbed failure recovery 
system remains stable correct processors continue receiving am alive messages processor connected receive messages processors disconnected 
max jd pd time units system stabilizes members change long system remains stable 
requirement sld satisfied 
problem protocol behavior periods system instability 
periods different processors disagree processors connected 
example assume availability managers cm responsible enforcing primary back availability policy group database managers fd running processors respectively 
consider stable state plays role primary plays role back followed period instability am alive message arrives late detecting looks failure promote rank primary 
violate safety condition characteristic primary back availability policy point real time primaries 
precisely tandem membership protocol described car independent assessment protocol subject split brain behavior described 
round protocol system message delays random processor communication failures occur random times unknown advance clocks drift real time actual rates unknown processors realistic require connected processors agree membership real time exact synchronization processors precluded 
agreement impossible form agreement processors connected required programming applications availability manager example discussed previously 
notion processor group introduced means grouping active processors communicate successfully past agree limit communication group members 
aiming achieving impossible goal simultaneous agreement real time require processors join group possibly different real times agree identity members group 
point real time allow processor joined group 
unambiguously designate different processor groups exist time require group membership protocol identify groups unique processor group identifier denote set possible processor group round protocol identifiers provided protocol 
furthermore require group membership protocol define total order exist times processor joined group example moment leaves group moment joins group 
denote joined ftrue falseg total predicate processor true joined group false joined group 
processor joined group take part coordinated group activity 
denote group partial mapping records group processor joined joined joined true group yields identifier group joined previous section members set denotes partial mapping records processor view membership group joined joined joined true members yields view membership group 
value mappings varies fact time higher order mappings time set ftrue falseg 
keep presentation simple mention time domain explicitly follows 
say processor joined group joined true group say joins leaves earliest latest real times respectively joined requirements avoid kind behaviors exhibited protocol instability periods require group membership service satisfy safety properties times group membership protocol described section processor joined group joined true 
case protocols 
introduce joined predicate terminology rest 
round protocol sa agreement group membership 
processors joined group necessarily time processors view membership group time joined group members time joined group members implies 
sr reflexivity 
processor joined members 
sm monotonicity groups 
groups processor joins times respectively 
requirement implies group id uniquely determines membership group 
simply write members mean members member second requirement says processor join groups member 
third requirement demands groups joined temporal order consistent order group ids 
consequence processors join groups join order 
explain section requirement sm crucial membership service useful applications availability manager 
requirements analogous tpd sld properties introduced independent assessment protocol tj bounded join delays 
exists time constant processors connected system stable common group joined time joined time necessarily time 
td bounded partition detection delays 
exists time constant processors disconnected system stable stays correct group members joined time 
sl stability local views 
system stable processor leave group max 
case independent assessment protocol requirements expressed equivalent simpler form tc view convergence 
exists time constant system stable correct processors physical partition joined group interval membership members equal round protocol consider group members proposed response instability detection processor 
system stable possible joins proposed group message lost additional failure causes new group created joins 
call incomplete 
general say group incomplete processor members joins incomplete groups avoided useful requires cooperation members done 
requirements tj td ensure incomplete groups system remains stable max time units 
require bound time correct processor joined incomplete group system unstable ti bounded inconsistency detection delays 
exists time constant time joined group members stays correct time joins leaves 
requirement implies processor joined group leaves example detects system instability correct members leave group time units 
time correct processor believes joined group processor fact joined bounded 
define somewhat stronger version requirement ti requires processor example leave common group join group timely fashion time disconnected sufficiently long time ti fail awareness 
exists time constant time joined group members stays correct disconnected leaves 
unfortunately satisfying ti require exchanging am alive messages pair processors 
communication may transitive instability 
particular possible processors correct connected correct disconnected 
exchange messages membership protocol able detect disconnected 
cost regularly sending messages prohibitive reasonable large include ti formal requirements processor membership protocol 
note periods system stable ti td imply ti 
assume system stable time dropping requirement ti favor ti severe limitation 
practice property close ti achieved communication subsystem includes acknowledgment protocol ability signal membership round protocol protocol messages acknowledged timely fashion 
fact processors disconnected detected membership protocol soon message sent 
practical purposes protocol equivalent messages satisfy ti state disconnected observable system messages sent 
protocol describe intuition round protocol propose satisfy requirements sa sr sm sl tj td ti introduced previous section 
describe action processor joined group take response occurrence single failure recovery event processor fails recovers disconnect connected processor 
detects event timeout arrival probe message updating local membership view independent assessment protocol propose creation new group id join broadcast membership members new group message processors join 
processor say joins sets members members 
property sa satisfied provided group identifier chosen different group ids generated processor 
order ensure global uniqueness group identifiers composed integer sequence number chosen processor created group processor identifier id group creator 
denote sequence number processor id fields group id define total order group ids follows processor constructs new group id id group currently joined incrementing group sequence number appending processor id 
ensures monotonicity requirement sm satisfied differs group id processor generate 
processor may detect failure recovery processor may receive new group proposals time 
way needed decide competing group proposals join 
adopt rule letting join new group id current group 
behavior satisfy requirement sm ensure new group message broadcast processors eventually converge join group id assuming additional failures recoveries occur 
round protocol protocol behavior somewhat complex multiple failures recoveries occur 
example processor joined group may receive new group proposal processor knows previously unreachable members 
join new group mistake simply ignored information new group message evidence reachable 
furthermore message may contain information failure recovery events detected processor communicated 
needs way extract new information may contained new group message 
indicate information included new group message adopt solution requiring originator include message set timestamps processor indicating information status processor sends message includes local timestamp vector message 
processor maintains timestamp vector containing timestamp known sent processor 
vector updated time am alive message received new group message received explained 
new group message includes sender timestamp complete timestamp vector representing message known sent processor 
rule processing new group messages follows 
processor joined group membership members having timestamp vector time receives processor new group message carrying proposed group membership members timestamp vector time 
processor combine knowledge system state information coming state merge group join rules processor examines view state represented members agrees state represented members 
disagree state processor examines timestamp vector values determine information information cases disagree joins 
information cases disagree simply ignores stays joined cases creates new group id greater membership constructed including exactly processors information joins broadcasts corresponding new group message processors 
cases updates knowledge latest am alive timestamp knows processors assigning maximum values 
describe round protocol entirety 
detailed code protocol correctness proof appendix processor starts time joins singleton group membership group id stored stable storage 
restarts failure joins round protocol similar singleton group id group id stored stable storage failure 
start initializes timestamps processors 
joining group follows procedures described section detecting failure recovery events joined group member group leader processor lowest id group issues attendance list message time units monitors timely return 
processors join group just monitor timely periodic passage attendance list message 
leader minority group see section sends probe messages time units 
probe message includes current group id members view mapping nat records knowledge latest timestamp sent joined group state members processor detect events left neighbor probably failed new group message arrives probe message arrives 
detects possible failure left neighbor creates new group sends new group message arguments members processors members members gammaq 
receives new group message arguments members follows state merge rules described 
order reduce number messages involved processing probe messages group leader respond messages leader receives probe message processed way new group message group members ignore probe messages 
advantages drawbacks round protocol round protocol efficient handling case single processor failure recovery processor detect failure recovery create new group broadcast new group message members join new group receive message 
single processor failure recovery results new group creation single round messages point point network 
show section protocol useful implementing service needed avoid split brain behavior mentioned earlier highly available leadership service cri 
despite efficiency handling single failures recoveries possible avoiding split brain behavior power solve highly available leadership problem round protocol major disadvantages 
multiple failures recoveries message losses protocol may take long time stabilize 
reflected relatively large value constant protocol highly available leadership problem max ffi ffi gamma ffi see appendix 
notice value contains term order ffi furthermore membership timestamp vector information included new group messages allow processor stays correct find failures recoveries happen system 
may particularly vexing problem goal build availability management service cm enforce specified service availability policies failures recoveries occur system 
example processor group members fp fails recovers quickly processor crashed earlier recovers possible processor successively join groups members fp members fp unaware failed recovered 
protocols subsequent sections address issues 
highly available leadership problem mentioned round protocol useful implementing highly available leadership service cri 
adapt requirements proposed service cri asynchronous environment follows 
su uniqueness leader 
point time leader 
te bounded election delays 
exists time constant system stable majority processors connected leader synchronous system highly available leadership protocol derived straightforward way membership protocol adding rule choosing leader members group example leader processor highest id group members cri 
processors joined group agree membership agree leader group asynchronous systems problem complicated different processors leave join groups different times due communication failures group exist time 
ensure leader restrict groups produce leaders majority groups 
communication failures multiple different groups form time groups elect leader 
unfortunately simple majority group rule suggested allowing leader exist strong guarantee processors believe highly available leadership problem leaders point real time 
example consider case am alive message current leader majority group lost 
leads creation new majority group members processor highest id members promoted leader 
possible time joins learns play role leader joined leaves believe leaders 
property ti page limits time stays joined old group provided stays correct 
wait time units leader ensure left relinquished role leader 
suffers performance failure may take arbitrary amount time leaves fact leadership problem unsolvable timed asynchronous model additional assumption processor detect suffers performance failure disconnected impossible processors distinguish suffering prolonged performance failure crashed correct 
impossible correct protocol elect new leader bounded time case system remains stable initially disconnected 
noted solving leader election problem guaranteeing processors believe leader point real time useful actions leader may take guaranteed complete bounded time 
example leader election protocol control access shared storage device dual ported disk operating system guarantee operation device complete bounded time 
processor may leader action initiated may interfere operation newly elected leader operation initiated old leader delayed arbitrarily may overwrite data written new leader 
observation reasonable assume system leader election useful processor detect suffers performance failure assumption waiting time units new majority group formed new leader safe time old leader left old majority group suffered crash detected performance failure 
unfortunately sufficient prevent multiple leaders time 
reason requirements membership service far allow multiple majority groups created roughly time 
fact happen round protocol messages lost 
minimum requirement processor able determine suffered performance failure time initiates action requires leader 
done example keeping track time membership protocol handle certain events time am alive message needs sent checking time current hardware clock time initiating leader action 
note assumes hardware clock reliable slow 
round protocol partition detection waiting period leader fact sufficient guarantee leader uniqueness real time 
intuition follows 
suppose failures occur processor leader majority group failures lead parallel creation majority groups members members 
waiting duration ensures process highest id attempt leader learns step 
second sufficient process highest id know process leader learned incomplete process left rigorous proof waiting period guarantees uniqueness real time appendix tj requirement page waiting rule follows system stable leader exist 
section show bound leader election delay improved service satisfies somewhat stronger ordering requirements round protocol see page 
round protocol partition detection reasons round membership protocol may take long time stabilize possibility spurious timeout occurrences system stable 
timeouts caused current failures consequence earlier failures occurred system unstable 
illustrate spurious timeout consider processor joined group expects receive am alive attendance list message right neighbor due earlier failures may joined group left neighbor send am alive messages incorrectly conclude crashed disconnected create new group excluding opposite problem processor believing alive connected fact possible attendance list protocol 
problems avoided rule obeyed new group creations processor attempts create new group check members alive disconnected members join creation new group round process 
round group creator broadcasts proposal create new group second round processors learn proposal send replies 
third round includes members processors replied proposal sends join message containing members 
stabilizing faster multiple failures recoveries approach advantages explain detail approach gives faster solutions leader election problem allows processors detect events missed soon join new group 
round protocol partition detection requirements logical partition notification multiple failures recoveries round membership protocol outlined stabilizes faster round protocol processor included respectively excluded new group group creator direct evidence processor alive respectively failed connected 
state property precisely introduce notion predecessor group 
pred theta partial mapping domain jp members defined follows pred maxf joined 
joined group define pred 
call pred predecessor group respect member members pred yields previous group joined note definition require effectively join member definition require round protocol satisfy safety requirements addition introduced previous section sd legitimacy processor deletions 
processor joins group time members member previous group pred joined exist processor members crashed connected time time left predecessor group pred 
sj legitimacy processor additions 
processor joins group time members member previous group pred joined exist processor members correct disconnected time time left predecessor group pred 
requiring round protocol satisfy sd sj protocol stabilize faster round protocol 
reason introducing requirements explained section 
advantage rounds group creation allows sequencing joining leaving groups way members new group group id smaller real group id created execution membership protocol 
thought initial group processor implicitly joined enters system 
round protocol partition detection left previous group joined member joins expressed requirement ss join synchronization 
processor joins group time member joined group membership protocol satisfies additional property highly available leadership protocol waiting delay built protocol lines suggested previous section 
join synchronization property time units leader majority group knows leader existed left group rigorous proof waiting rule correct appendix round protocol provides basis faster implementation highly available leadership service 
proposal phase group creator opportunity collect information previous history new group members 
exploited solve missing events problem mentioned previous section gave example processor joins group membership fp followed group membership fp unaware processor crashed recovered 
systems example isis kb solve problem associating incarnation number member group 
number incremented time processor recovers crash 
processor observe incarnation numbers different conclude crashed recovered 
approach generalize case processor crashing briefly disconnected processors joins singleton group member new group 
incarnation numbers allow members detect fact incarnation number change 
incarnation numbers require multi round membership protocol notify members newly created group predecessor groups members 
sp logical partition notification 
processor joins group join time membership protocol know predecessor groups pred members 
additional requirement able detect logically partitioned joining pred pred 
say members group logically partitioned joining predecessor groups different pred pred 
logical partitions occur asynchronous systems existence hard physical partitions simply messages get lost arrive late 
example local area networks round protocol partition detection logical partitions caused transient overloads message losses 
processors detect logically partitioned disagree events happened system time common group 
events lead diverging group states distinct groups 
rejoin common group may agree new state state merge function determines new group state derived states respectively 
state service implemented team represented instance data type commutative operations simple union 
example operations implemented team members inserts set union sets 
operations commutative example inserts deletes allowed conflict detection resolution rule described considered defining merge function note logical partition notification mechanism useful membership protocol create new groups necessary 
example imagine protocol processor joins singleton group containing member detecting failure recovery merging real group reflects current connected relation 
protocol pred different pred words processors joining common group believe logically partitioned making predecessor information introduced earlier useless 
exclude trivial protocols introduced requirements sd sj 
protocol round protocol changed new protocol round protocol partition detection 
addition safety properties sa sr sm sl timeliness properties tj td ti pages protocol satisfies safety requirements sd sj ss sp introduced previous section 
round protocol groups identified unique ids consisting stable sequence number processor id similar round protocol failures detected attendance list protocol joins detected periodic probes 
group creator checks membership proposed group timestamp vectors somewhat cumbersome state merge group join rule round protocol longer needed 
detailed code protocol appendix sketch main features 
processor group detects failure recovery simply sending new group message orders members join new group send invitation know willing join 
processor receives invitation group reply accept message round protocol partition detection know attempt creating competing group 
knows competing group forwards new group message replying accept message 
processor attempts create group turn invited join competing group processor rule accepting invitations ensures property connected processors try create competing groups succeed 
system stable successful group maximal sense contain processors connected successful group creator 
satisfy requirement sp accept message processor carries parameter predecessor group left learned new group proposal 
waiting ffi time units processor attempts create group go ahead creation learn mean time attempt create competing group higher id case computes membership new group set processors knows accepted join joins sends members join message containing members pred pred predecessor information gathered received accept messages 
receiving message processor joins adopts members view membership learns pred highest group id knows 
handle situation proposer new group fails processor accepts join sets timer ffi time units timer expires attempts turn create new group obvious failure proposer connected processors 
advantages drawbacks new properties added round protocol partition detection give advantages round protocol 
due sd sj page protocol creates fewer transient groups groups exist short time stabilizes faster multiple failures recoveries round protocol 
appendix derive maximum join partition detection time constants protocol ffi max ffi 
property ss page leads faster solution highly available leadership problem 
partition notification requirement sp page allows members new group detect inconsistencies 
applications properties round membership protocol strong 
consider problem implementing availability management policy lines processor fails available processor takes responsibility failed available processor defined processor lowest id taken additional responsibilities 
example processor fails take services previously provided round protocol partition detection fails processor take line notice policy depends agreeing failed 
example believed failed attempt take services believing handle services asynchronous system impossible determine exactly real time processor failed decide exact order failures occurred real time happen close 
fortunately availability management policy outlined necessary know order failures real time long processors responsible enforcing availability management policy agree order 
unfortunately properties membership services far strong solve problem 
example illustrates 
assume initially processors joined group membership fp round protocol partition detection allows behavior occur 
ffl due lost am alive message processor detects failure initiates creation group sending new group message processors 
processors reply sending accept message back reply lost 
result computes membership fp sends join message members due message loss receives join message processors join ffl assume detects loss join message initiates creation group sending new group message processors 
processors reply time accept message lost 
result computes membership fp join messages lost time receives join message joined ffl crash 
processors detects join message lost initiates creation new group 
time messages lost 
result surviving processors join group membership fp consider sequence groups joined example fp fp fp fp fp fp protocol behavior consistent membership service requirements far cause disagree order processors failed appears failed believe majority group membership protocols failed 
note behavior possible correct connected 
requirements especially sm page ensure groups joined processors join order guarantee processors join set groups members groups created example 
partition notification mechanism allows inconsistencies detected example join pred pred detect joined different groups joining 
round protocol partition detection prevent occurrence inconsistencies 
sections explore membership protocols address problem 
majority group membership protocols force agreement order failures recoveries occur team cri proposed build protocols guarantee correct processors join identical sequences histories groups 
processors agree membership group agree unique history easily agree differences memberships successive groups history 
synchronous membership protocols proposed cri satisfy property named agreement group histories 
unfortunately asynchronous system correct processors join groups simply may times correct disconnected 
example previous section shows requirements group membership services far possible processors observe different group histories correct connected 
asynchronous system achieve form agreement group histories nearly strong synchronous case consider majority group histories groups contain majority processors members definition majority groups intersecting memberships 
section membership protocols achieve agreement majority groups round protocol achieves agreement linear history majority groups cheaper round protocol achieves slightly weaker agreement linear history completed majority groups group completed joined members 
applications real done completed groups cheaper round protocol needed 
majority group membership protocols requirements majority group membership protocols previous section example illustrated execution round protocol partition detection processors observe different group histories leading contradictory order failures processors histories contained majority groups ended final group containing different intermediate groups 
explained requirement sp page allows detect inconsistency join strengthen sp requiring inconsistencies resolved group creation component membership protocol detectable 
mean majority group created membership protocol decide official majority group precedes way membership protocol tell failed vice versa 
natural decision group chose official predecessor order group ids 
candidates official predecessor group choose previous majority group having highest group id pred majority group members joined member joined majority group define pred 
strengthen requirement sp membership service inform new majority group members predecessor current group defined sp predecessor notification majority groups 
processor joins majority group join time require membership protocol know majority group predecessor pred addition individual predecessor groups pred members 
example page predecessor predecessor predecessor words example pred relationship yields linear order groups 
case general 
modify example slightly assuming join messages group lost processor joins predecessor definition member joined pred member members joined case pred predecessor 
see definition pred page 
majority group membership protocols pred defines unique majority group predecessor majority group majority group may successor 
pred relation general define simple linear history majority groups allows branches 
call group ancestor history branch 
words ancestor group pred ancestor pred 
definition group ancestor majority groups 
reason restrict definition pred relation majority groups doing limit disagreements branches team history short lived incomplete majority groups 
example incomplete joins joins 
incomplete group temporarily see failure joins completed group learn official team history failed agreement order failures joins essential correctness application members know joined completed majority groups act membership change information 
note requirement ti page limits time processor joined incomplete group delay action membership changes caused incomplete groups significant 
formalize requirement disagreement majority group histories limited transient incomplete groups follows linear history completed majority groups 
completed majority groups majority groups joined members 
ancestor pred relation 
requirement forbids existence completed majority groups parallel branches history majority groups may exist time 
property useful applications servers take actions learn joined complete majority group 
example higher level application needs membership service satisfying consider atomic broadcast service maintains consistent copies state team servers train broadcast protocol described cri 
round train protocol works follows message called group train circulates group members manner similar attendance list discussed earlier 
processor wants broadcast update applied team state waits train message appends train removes train second time train comes 
processors applies local copy team state knows group members know sees coming train second time 
way updates applied transient incomplete groups branches group history harmful lead diverging local views team state round train protocol achieves strict consistency cri local copies team state team members time prefixes history team updates applied far 
majority group membership protocols alternative stronger specification majority group membership service allow branching histories avoid inconsistency members majority groups linear history majority groups 
majority groups 
ancestor pred relation 
reason version weaker useful implemented efficient protocol 
round protocol majority groups requirement sp page satisfied straightforward modification round membership protocol described previous section processor replies new group message creator new group addition sending id group currently joined sends id majority group joined 
group creator compute pred information useful detecting logical partitions see requirement sp pred information highest majority group predecessor id receives 
creator includes value pred addition pred join message sends new members 
detailed code protocol appendix difficult see unchanged round membership protocol satisfies requirement sp 
obvious protocol satisfies page 
intuition 
completed majority group majority group member joined accepted join definition predecessor id equal larger majority group joined accepting join follows pred 
consider distinct completed majority groups loss generality assume satisfy shown ancestor argument pred 
equal pred pred 
case ancestor second case repeat argument show pred pred 
general shown induction ancestor id smaller ancestor impossible ancestor rigorous proof see appendix round protocol protocol satisfying page derived round protocol adding additional rounds message exchanges majority groups created 
majority group membership protocols rounds message exchanges correspond commit protocol similar phase commit 
commit protocol necessary ensure agreement team history maintained member 
detailed description protocol appendix just sketch main features strongest protocol family 
processors join minority groups round protocol 
rounds message exchanges creating majority groups 
illustrate protocol works situations assume majority processors connected processor attempts create new group round protocol broadcasts new group message collects accept messages replies members sending join message immediately broadcasts prepare message group members having received prepared message reply members send join message group members 
history majority groups maintained processor consists stable history proposed extensions 
group part stable history processor majority processors learned group received prepare message containing id membership group 
response new group message member accepts member group sends knows stable history proposed extensions history stable stable histories receives prefixes exist disagreement proposed extensions histories collects 
histories receives processor picks group highest group id new history sent prepare message information group id group membership members accepting processor new history adopted processor members 
time member joins majority groups history member joined 
member replies prepared message receives prepared messages processors members knows agree proposed history majority groups sends final join message notifies effectively join appendix show round membership protocol satisfies 
advantages drawbacks restricting groups majority groups round round protocols provide stronger ordering guarantees observed history group membership changes previous protocols 
round protocol guarantees linear history majority groups completed majority groups round protocol guarantees processors observe history majority groups 
hand round protocol requires rounds messages create majority group round protocol requires messages previous round protocol partition notification 
discussed possible specifications membership services timed asynchronous distributed systems simplest nearly trivial independent assessment service strongest agreement unique history majority groups service 
different services identified suitable supporting distributed applications increasingly strong requirements increasing costs complexity message traffic 
service protocol implements described proven correct 
independent assessment protocol protocol frequently implemented real systems car simplicity 
unfortunately protocol exhibits split brain behavior serious consequences system availability 
round protocol avoids split brain behavior handles efficiently single failures recoveries solve continuous leadership problem just messages group creation 
major drawbacks slowness stabilize multiple failures recoveries promoting new leaders possibility different processors see different failure recovery event histories 
protocol cause processors certain events interest disagree order events occur round protocol suitable sophisticated applications system availability management cri cm 
round protocol partition notification stabilizes faster multiple failures recoveries provides faster promotion time continuous leadership problem expense messages group creation 
providing members newly formed group predecessor group information enables processors easily detect potential local state conflicts due logical partitioning 
possibility processors disagree order failures recoveries occur correct connected exists 
solve problem introduced round protocol majority groups imposes unique ordering events observed members completed majority groups extra message cost group creation 
believe protocol useful provides cost performance compromise implementing higher level services asynchronous atomic broadcast availability management 
round protocol ensures processors agree unique history events observed successive majority groups exist system 
cost messages create new majority groups practical applications may prohibitively high 
acknowledgments timed asynchronous system model specifications code protocols developed authors worked ibm almaden research center 
author move university california san diego caused year delay resumption 
correctness proofs final text finished june 
second phase elaboration author acknowledge support provided air force office scientific research sun microsystems microelectronics innovation computer research opportunities california 
charron bost toueg 
formal specification group membership services 
technical report computer science department cornell university ithaca new york august 
amir dolev kramer malki 
membership algorithms broadcast domains 
technical report cs computer science department hebrew university jerusalem israel 
babaoglu baker 
communication infrastructure constructing reliable applications 
technical report cs laboratory computer science university bologna 
car carr 
tandem global update protocol 
tandem systems review jun 
car carr 
split brain syndrome 
private communication 
cristian strong dolev 
atomic broadcast simple message diffusion byzantine agreement 
proceedings fifteenth international symposium fault tolerant computing pages ann arbor mi jun 
cf cristian fetzer 
timed asynchronous system model 
technical report cs ucsd jan 
cht chandra hadzilacos toueg 
unreliable failure detectors reliable distributed systems 
journal acm 
chandra hadzilacos toueg charron bost 
impossibility group membership 
th acm symposium principles distributed computing pages may 
cm cristian mishra 
automatic service availability management asynchronous distributed systems 
proc 
int 
workshop configurable distributed systems pittsburgh pa march 
cri cristian 
probabilistic clock synchronization 
distributed computing 
cri cristian 
asynchronous atomic broadcast 
ibm technical disclosure bulletin feb 
ieee workshop management replicated data houston tx nov 
cri cristian 
reaching agreement processor group membership synchronous distributed systems 
distributed computing 
early version ftcs kyoto 
cri cristian 
understanding fault tolerant distributed systems 
communications acm feb 
cri cristian 
automatic reconfiguration presence failures 
software engineering journal pages mar 
dolev halpern strong 
possibility impossibility achieving clock synchronization 
journal computer system science 
dls dwork lynch 
consensus presence partial synchrony 
journal acm 
dms dolev malki strong 
asynchronous membership protocol tolerates partitions 
technical report cs computer science department hebrew university jerusalem israel 
dms dolev malki strong 
framework membership services 
technical report cs computer science department hebrew university jerusalem israel 
ems macedo shrivastava 
newtop fault tolerant group communication protocol 
proceedings th international conference distributed systems vancouver canada may 
fc fetzer cristian 
fail aware failure detectors 
proceedings th symposium reliable distributed systems niagara lake canada oct 
flp fischer lynch paterson 
impossibility distributed consensus faulty process 
journal acm apr 
gif gifford 
weighted voting replicated data 
proceedings seventh symposium operating systems principles pages pacific grove ca dec 
hs schlichting 
properties membership services 
proc 
int 
symp 
autonomous decentralized systems az apr 
jahanian rajkumar 
processor group membership protocols specification design implementation 
proc 
th symposium reliable distributed systems oct 
kb stevenson birman schiper 
lightweight causal atomic group multicast 
acm transactions computer systems august 
kt kaashoek tanenbaum 
group communication amoeba distributed system 
proc 
th int 
conf 
distributed computing systems pages may 
schiper wilhelm 
phoenix toolkit building fault tolerant distributed large scale networks 
proc 
ieee workshop parallel distributed platforms industrial products san antonio tx oct 
mps mishra peterson schlichting 
membership protocol partial order 
meyer schlichting editors dependable computing critical applications pages 
springer verlag wien 
melliar smith moser agrawala 
processor membership asynchronous distributed systems 
ieee trans 
parallel distributed systems may 
nei 
new look membership services 
th acm symposium principles distributed computing pages may 
rb ricciardi birman 
process groups implement failure detection asynchronous environments 
th acm symposium principles distributed computing montreal canada aug 
rb ricciardi birman 
process membership asynchronous environments 
technical report computer science cornell university 
available anonymous ftp ftp sc cornell edu pub team ps ric ricciardi 
group membership problem asynchronous systems 
phd thesis department computer science cornell university 
strong skeen cristian 
handshake protocols 
proceedings seventh international conference distributed computing systems pages berlin sep 
van renesse birman 
horus flexible group communication system 
cacm april 
appendix protocol code appendix protocol code appendix contains detailed pascal pseudo code protocols 
independent assessment protocol omitted simplicity 
assume existence subroutine libraries support higher level data structures sets lists queues primitives sending message set processors setting timeouts 
messages specified string label identifying type message parameters containing message data 
timeouts specified variables type timer supports operations set schedules timeout event generated seconds cancel cancels previously scheduled timeout 
protocols event driven programs reacting message events message received timer events timeout occurred 
syntax wait list events process event select event receive 

timeout 
select code fragment wait arrival message type timeout timer variable whichever happens 
message type received parameters message data assigned local variables 
identity sender assigned local variable pseudo code uses functions operate group membership sets ffl leader returns processor lowest id ffl return left right neighbor processor ffl rank returns integer jmj indicating position cyclic neighbor relation leader highest rank 
ffl majority boolean function returns true set contains majority processors predicate assumed satisfy requirement majority majority fg 
round protocol round protocol describe round protocol single main task containing event loop handles messages timeout events 
main task calls subsequently defined procedures handle processing new group messages probe messages missing neighbor timeouts 
const type integer record const ffi persistent var currentgid initially myid var members set timestamps map timer msg new group set map am alive probe set map round protocol task main var gid members set timestamps map timestamps myid gamma timestamps currentgid currentgid myid members set loop select event timeout time send am alive message right neighbor myid members send am alive currentgid set timeout am alive message left neighbor missing members members gamma myid members currentgid timeout time send probe message timestamps myid send probe currentgid members timestamps gamma members note probes sent group leaders minority groups procedure join timer set processor leader minority group set receive new group gid members timestamps gid members timestamps receive am alive gid gid currentgid timestamps set rank myid members ffi myid leader members myid members send am alive currentgid receive probe gid members timestamps gid members timestamps select loop round protocol procedure gid members set timestamps map var boolean initially true boolean initially true merge knowledge state system new information members members timestamps timestamps members members fpg false false members members timestamps timestamps myid members members gamma fpg false false timestamps max timestamps timestamps currentgid gid join gid gid currentgid gid ignore currentgid round protocol procedure var newid newid myid timestamps myid send new group newid members timestamps gamma join newid procedure join newid update current group id currentgid newid cancel timers cancel cancel cancel set new timers leader members myid majority members set leader members myid set gamma ffi set rank myid members ffi round protocols round protocols round majority groups protocol superset partition detection describe 
code derived simply removing majority group predecessors variables pred code 
protocol structured concurrent tasks responsible handling different set related events 
including explicit synchronization tasks simply assume non preemptable 
global protocol variables shared tasks updated task time just protocol written single task large event loop 
const type integer record const ffi persistent var currentgid initially initially initially var joined boolean members set timer msg new group accept join set map probe am alive task main join initial group myid member join currentgid myid myid start tasks handle protocol events start start start round protocols task var newid timer set initially initially pred map initially myid currentgid propose new group newid max currentgid myid newid myid send new group newid myid gamma collect replies set ffi loop select event receive accept gid gid newid fpg max pred cancel exit loop timeout exit loop select loop am winner tell members join newid join newid pred send join currentgid pred gamma round protocols task var timer loop select event receive new group newid newid newid send accept newid currentgid set ffi newid send new group receive join newid memb pred pred newid cancel join newid memb pred pred timeout start select loop round protocols task loop select event receive probe gid joined leader members myid majority members gid currentgid start timeout send probe currentgid gamma members note probes sent group leaders minority groups procedure join timer set processor leader minority group set select loop task loop select event timeout send am alive currentgid myid members set receive am alive currentgid set rank myid members ffi leader members myid myid members send am alive currentgid timeout start select loop round protocols procedure join set pred pred notify interested parties group change signal join notification pred pred user update group id related state majority members currentgid currentgid members joined true set new timers leader members myid majority members set leader members myid set gamma ffi set rank myid members ffi procedure joined notify interested parties group change signal leave notification user update state joined joined false cancel timers cancel cancel cancel round protocol round protocol majority group history maintained round protocol represented pseudo code variable hist declared queue records containing group id membership groups majority group history 
assume data type queue supports operations append appends new element queue remove removes element front queue returns element appended queue alter content queue 
returns number append operations applied queue equal number elements currently queue plus number elements removed queue 
peek returns th element appended queue assuming element removed index equal alter content queue 
initial value history queue hist set contain initial group processor implicitly joined enters system 
new majority groups formed appended history queue groups known joined members removed front queue 
addition processor maintains variable named stable indicates groups history known majority processors 
majority group history divided sections completed majority groups groups known joined members removed history queue 
stable majority groups groups known part history queue majority processors proposed extensions history may seen majority processors 
variable stable contains index group history queue known stable stable groups groups including hist peek stable 
group stable majority processors received processed prepare message containing group 
removing completed majority groups history queue necessary correctness prevents histories growing indefinitely 
fastest way prune histories extra round acknowledgments joining majority group 
alternative rely bounded inconsistency detection delay td 
property implies processor remains joined group period length assume members joined group 
approach requires fewer messages joining majority group processor sets timer go seconds 
processor joined timer goes prune history contain single group round protocol const type integer record const ffi type record gid memb set persistent var currentgid initially initially hist initially stable integer initially var joined boolean members set timer msg new group accept integer prepare integer prepared join majority join minority set probe am alive task main join initial group myid member currentgid myid start tasks handle protocol events start start start start round protocol task var newid timer memb set integer replies set integer propose new group newid max currentgid myid newid myid memb hist stable send new group newid myid gamma collect replies set ffi loop select event receive accept newid memb memb fpg remember history highest id id id remember highest quit loop replied memb cancel exit loop timeout exit loop select loop newid return round protocol majority memb newid memb send join minority newid memb memb gamma return append new group history append newid memb send prepare message new members prepare newid send prepare newid memb gamma set ffi replies loop select event receive prepared gid replies replies fpg replies memb gamma cancel exit loop timeout start return select loop newid return send join message newid send join majority newid memb gamma round protocol task var newid integer memb set timer loop select event receive new group newid newid newid send accept newid hist stable set ffi newid send new group receive join minority newid memb newid cancel newid memb receive prepare newid newid cancel prepare newid send prepared newid set ffi receive join majority newid newid cancel newid timeout start select loop round protocol task loop select event receive probe gid joined leader members myid majority members gid currentgid start timeout send probe currentgid gamma members note probes sent group leaders minority groups procedure join timer set processor leader minority group set select loop task loop select event timeout send am alive currentgid myid members set receive am alive currentgid set rank myid members ffi leader members myid myid members send am alive currentgid timeout start select loop round protocol task loop select event timeout prune history removing element hist hist select loop procedure set notify interested parties group change update group id related state currentgid members joined true set new timers leader members myid send probe gamma set leader members myid set gamma ffi set rank myid members ffi round protocol procedure prepare newid integer var integer join new stable majority group hist stable hist peek myid signal join notification user stable currentgid id id members memb set new timers leader members myid send probe gamma set leader members myid set gamma ffi set rank myid members ffi round protocol procedure var integer join new stable majority group stable hist hist peek myid signal join notification user update group id related state stable hist joined true set timer go members known joined set procedure joined signal leave notification user joined false cancel cancel cancel cancel appendix correctness proofs appendix correctness proofs easier follow correctness proofs concise summary assumptions definitions requirements protocol properties 
system model terminology system consists set processors linked communication network 
absence failures messages processors delivered ffi time units 
processor local clock stable storage 
failure assumptions ffl crash performance processor failures 
ffl omission performance communication failures 
def point time communication processors states connected disconnected partially connected 
states imply correctness messages sent ffl connected time interval correct message sent ffi delivered processed ffi time units 
ffl disconnected time interval crashed crashed messages sent delivered ffl partially connected processor correctness message delivery def system called stable processor fails recovers messages delivered delivered ffi time units sending pairs processors connected disconnected connected relation processors constant transitive 
groups group ids appendix correctness proofs members set processors believes currently correct connected 
set group ids ordered 
joined true processor currently joined group 
group returns id group currently joined undefined joined false 
members members joined 
undefined joined false 
membership service requirements minimal requirements bounded join delays 
exists time constant jd processors connected jd system stable included members members respectively 
tpd bounded partition detection delays 
exists time constant pd processors disconnected pd system stable stays correct excluded members 
sld stability local views 
system stable correct processor members change max jd pd 
minimum requirements group membership service sa agreement group membership 
processors joined group necessarily time processors view membership group time joined group members time joined group members implies 
sr reflexivity 
processor joined members 
sm monotonicity groups 
groups processor joins times respectively 

tj bounded join delays 
exists time constant processors connected system stable common group joined time joined time necessarily time 
td bounded partition detection delays 
exists time constant processors disconnected system stable stays correct group members joined time appendix correctness proofs sl stability local views 
system stable processor leave group max 
ti bounded inconsistency detection delays 
exists time constant time joined group members stays correct time joins leaves 
membership service partition notification def members define pred maxf joined 
joined group define pred 
sa sr sm tj td sl ti see 
sd legitimacy processor deletions 
processor joins group time members member previous group pred joined exist processor members crashed connected time time left predecessor group pred 
sj legitimacy processor additions 
processor joins group time members member previous group pred joined exist processor members correct disconnected time time left predecessor group pred 
ss join synchronization 
processor joins group time member joined group 
sp logical partition notification 
processor joins group join time membership protocol know predecessor groups pred members 
majority group membership service weak agreement def define pred majority group members joined 
member joined majority group define pred 
def group called completed iff members joined 
sa sr sm tj td sl ti sd sj ss see 
sp predecessor notification majority groups 
processor joins majority group join time require membership protocol know majority group predecessor pred addition individual predecessor groups pred members 
appendix correctness proofs linear history completed majority groups 
completed majority groups majority groups joined members 
ancestor pred relation 
majority group membership service strong agreement sa sr sm tj td sl ti sd sj ss sp see 
linear history majority groups 
majority groups 
ancestor pred relation 
leader election problem su uniqueness leader 
point time leader 
te bounded election delays 
exists time constant system stable majority processors connected leader protocols properties parameters period exchanging am alive messages period sending probe messages independent assessment protocol satisfies tpd jd ffi pd ffi round protocol satisfies sa sr sm tj td sl ti max ffi max ffi gamma ffi round protocols satisfies sa sr sm tj td sl ti sd sj ss sp sp max ffi ffi appendix correctness proofs max ffi ffi round protocol satisfies sa sr sm tj td sl ti sd sj ss sp max ffi ffi max ffi ffi ffi leader election protocols round membership protocol round protocol concludes summary protocol properties requirements 
remainder appendix section prove protocols satisfy requirements listed 
appendix correctness proofs common protocol properties non trivial protocols features common example way group ids created order defined way failures recoveries detected attendance list probe messages 
section proofs protocol properties depend common features apply protocols 
common safety properties sa agreement group membership protocols group ids consist processor id id group creator monotonically increasing counter 
groups created different processors different group ids 
protocols processor joins new group created group received message members group creator processors join group received message containing membership set members 
processors join adopt membership 
sr reflexivity round protocols round protocol join messages sent group members 
members join group 
round protocol join messages new group messages sent processor 
processor receives new group message specifically checks membership list received includes 
join new group 
sm monotonicity groups protocols processor joins group higher id group currently joined 
sequence group ids joined processor strictly increasing 
processors join groups join order order group ids 
sl stability local views assume number failures recoveries system stabilized time pair processors connected disconnected connected relation transitive 
means processors crashed form communication cliques physical partitions 
furthermore system stable late messages arrive protocol satisfies bounded join partition detection delay requirements tj td processors partition see procedure statement 
myid loop variable set false case false processor join group 
appendix correctness proofs joined common group membership equal time max 
reasons member leave group system remains stable max 
member receives message containing higher group id message sent processor physical partition processors eventually join system stable messages delivered ffi 

member times waiting am alive message neighbor 
protocols timer timers set members join group ffi time units system stable am alive messages sent arrive recipient timer run 
possible group created time system unstable 
case timeout occurs time happen soon see consider happens time leader sends new am alive message time system stable message reach th member ffi time units time member reset timer run am alive message group leader reach processor 
timeouts occur happen am alive message sent reached members case new groups may created processors physical partition joined common group argued happen limited time system stable max time units processors joined common group leave group long system remains stable 
course complete proof show requirements tj td satisfied 
protocol individually subsequent sections 
common timeliness properties ti bounded inconsistency detection delays claim protocols satisfy requirement ti ffi number processors system 
prove claim show equivalent statement true processor joined group time interval length member members joined time reason interval length ffi received am alive messages left group receive am alive messages appendix correctness proofs received forwarded members leader left sending second am alive message 
member joined time properties round protocol previous sections showed protocols satisfy safety requirements sa sr sm sl timeliness requirement ti 
prove waiting rule electing leader majority group correct protocol specific tj td requirements hold 
proof waiting rule correct contradiction 
assume time leaders joined majority groups 
waiting rule joined respectively interval 
loss generality suppose majority groups membership intersect members members 
processor joined time ti processor crashed detected performance failure left similarly joined time failed left follows joined joined sm contradicts working hypothesis proceed prove tj td requirements 
assume system stabilizes time show system remains stable sufficiently long time processors physical partition eventually join common group membership equal set processors partition 
tj td satisfied 
intuitively reason properties hold follows 
system stabilizes messages broadcast processors decide create new groups 
recall rules protocol messages broadcast processors group membership 
message collective note argument assumes leader send new am alive message received copy previous am alive message left neighbor 
assumption implies smaller ffi 
protocol remain correct chosen smaller improve bound 
fact inconsistency detection delay worse 
example chosen just smaller ffi receives am alive message infer am alive received members 
leader sends second am alive timer previous am alive message runs 
choice processor need wait am alive messages sure member joined lead bound ffi 
smaller term ffi decreases factor front increases needs wait am alive messages 
net effect larger bound 
appendix correctness proofs knowledge processors state system increases processor receives message combines previously recorded knowledge information receives message 
unfortunately matters complicated possibility spurious timeout occurrences see section 
define notion precisely 
assume processors physical partition joined group members 
furthermore assume left neighbor expects receive iam alive messages possible due failures occurred system stabilized joined different group sends am alive messages processor processor time waiting am alive messages conclude crashed disconnected 
say spurious timeout occurs system stabilized processor creates group excluding processor physical partition 
spurious timeouts may decrease collective knowledge create new group excluding send new group messages may convince processors partition crashed disconnected 
prove number lemmas show spurious timeouts occur bounded time system stabilizes 
ffi 
note broadcast message delivered sent late messages delivered stable system 
broadcast sent processor delivered recipients provided system remains stable ffi time units broadcast sent 
group highest id groups joined processors time set processors joined group second highest id groups joined processors time set processors joined exists processors joined define empty set 
lemma max ffi ffi 
system stable time processors joined members members group created proof case members processor left neighbor case receives am alive message group id joined appendix correctness proofs received broadcast message created case condition lemma satisfied case receive am alive message group id time waiting am alive message create new group time ffi case condition lemma satisfied 
case members case condition lemma satisfied 
case members members processor left neighbor 
case times waiting am alive message create new group ffi 
processor receive new group message ffi 
member receiving message create new group learned new information alive 
case condition lemma satisfied 
case joins received broadcast message 
created processor receive new group message ffi 
member receiving message create new group learned new information alive 
condition lemma satisfied 
case members members 
possible disjoint 
minority group 
case leader joined time 
leader minority group send probe message time 
message received leader group ffi 
time leader create new group case leader joins group time 
analogous case 
case condition lemma satisfied 
cases condition satisfied 
condition lemma satisfied timeliness conditions satisfied done 
need consider case condition satisfied 
follows assume group created id high group joined processor appendix correctness proofs lemma ffi 
processors joined group created proof received new group message group joined receives message 
created case joined group created join create join new group higher id lemma spurious timeouts proof assume learns connected 
group joined detects failure 
lemma group created received new group message ffi time units possible reasons send am alive message expects 
join joined group received new group message lemma created received new group message timer ran 
detected connected 
joined left joined different group timer ran 
created received new group message timer ran 
lemma processor creates joins group member group created member 
proof assume group groups created contain member 
lemma implies processors joined group containing reasons create join group containing 
times waiting am alive message lemma possible 
receives new group probe message group excludes assumption created new group message appendix correctness proofs reached time ffi probe message reached time ffi ffi 
ffi ffi possible 
lemma ffi 
processors joined group membership superset proof assume time joined group containing lemma implies group created contain groups highest value timestamps 
processor receive new group message time ffi time create new group containing higher value ticks 
time ffi processor receive new group message point create join group excluding 
times waiting am alive message lemma possible 

receives new group probe message group containing value timestamps greater equal associated 
processor increments ticks possible 
corollary phase protocol satisfies condition bounded join delays gamma max ffi ffi 
lemma gamma ffi 
processor joined group membership equal proof gamma processors takes gamma timeout periods plus new group creations detected disconnected group membership equal created 
corollary phase protocol satisfies condition bounded partition detection delays gamma max ffi ffi gamma ffi 
appendix correctness proofs properties round protocols common safety properties sd sj legitimacy processor deletions additions round protocols membership proposed group determined group creator sends new group message processors includes members processors reply ffi time units 
processor disconnected time interval included members 
similarly processor connected included members abort creation group aborted processor joins 
see consider connected receives new group message highest group proposal seen far smaller replies positively invitation insert members 
higher processor attempts create group id learned proposal replies newgroup message relaying new group message 
connected message received timer expires abort creation requirements sd sj satisfied choosing processor creator 
ss join synchronization round protocol creator group joins having received accept messages members leave previous groups receive new group message member joined group lower id time member joins correctness waiting rule unique leadership proof contradiction 
assume time leaders joined majority groups majority group leader loss generality assume waiting rule joined respectively gamma 
member accepted join received new group message replied accept join 
round protocol process accepts group accept join groups higher id join 
joined earlier left 
follows joined 
crashed detected performance failure property ti left safety properties round protocol partition notification sp partition notification round protocol partition notification satis appendix correctness proofs fies requirement member group includes predecessor group pred accept message sends group creator group creator includes collected values join message sends members safety properties round majority protocol sp predecessor notification majority groups processor joining majority group saves id group stable variable pred 
new majority group creator receives accepts new majority group computes pred maximum pred members sends pred join message members requirement sp satisfied 
linear history completed majority groups need prove distinct completed majority groups ancestor 
loss generality assume show ancestor technical lemma 
lemma majority group joined member 
pred 
proof pred members memb 
joined member members including accepted join 
majority group joined accepted join 
candidates creator chose pred 
definition pred pred 
member complete joined assumed joined accepting join 

imply pred 
proceed prove claim contradiction assume ancestor derive contradiction 
lemma ancestor ancestor proof induction distance graph pred relation ffl induction base distance pred 
lemma hypothesis ancestor follows ffl induction step distance 
pred gamma appendix correctness proofs ancestor distance graph pred relation 
induction hypotheses claim holds 
pred 
lemma ancestor equal initial group id definition ancestor majority groups including lemma follows 

impossible conclude assumption ancestor false ancestor timeliness properties round protocol tj td bounded join partition detection delay assume number failures system stabilized time show system remains stable sufficiently long time processors physical partition eventually join common group membership equal set processors partition 
tj td satisfied 
prove claim steps 
show system stabilized processors physical partition belong common group membership equal new group created lemma 
prove group successfully created system stabilized membership equal lemma 
show groups joined members 
ffi 
group highest id groups joined processors time set processors joined group second highest id groups joined processors time set processors joined exists processors joined define empty set 
lemma max ffi ffi 
system stable time processors joined members members group created proof case members processor left neighbor appendix correctness proofs case receives am alive message joined system stable ffi time units elapse decision create group moment member receives join message group 
joins created gamma ffi greater case condition lemma satisfied case receive am alive message time initiate creation new group ffi 
case condition lemma satisfied 
case members case condition lemma satisfied 
case members members processor left neighbor 
case times waiting am alive message initiate creation new group 
condition lemma satisfied 
processor creates group ffi happen member receiving newgroup message accepting forward newgroup message processor receive forwarded message time ffi 
time abort creation send accept message creator members receive join message time ffi timer expire create group case condition lemma satisfied 
case joins system stable ffi time units elapse decision create group moment member receives join message created processor time gamma ffi ffi 
processor received newgroup message processor received newgroup message received message receiving newgroup message accepting forwarded newgroup message aborted creation 
created ffi time units 
created condition lemma satisfied case condition lemma satisfied 
appendix correctness proofs case members members 
possible disjoint 
minority group 
case leader joined time 
leader minority group send probe message time 
message received leader group ffi 
time leader create new group case leader joins group time 
analogous case 
case condition lemma satisfied 
cases condition satisfied 
condition lemma satisfied timeliness conditions satisfied done 
need consider case condition satisfied 
follows assume group created id high group joined processor show group include member processor joins group 
lemma group created processor physical partition processor joins system stable ffi time units decided create group members proof system stable ffi time units processor receive newgroup message receive reply processor timer expires 
furthermore processor outside receive reply newgroup message 
processors reply accept message membership computed processors reply relaying newgroup message group id greater abort group creation processor join show groups created certain time joined members 
group largest id created processor created time 
time ffi processors received newgroup message time processor joined group id left group processor joined group time joined group created ffi group id greater created 
timeouts occur ffi ffi 
appendix correctness proofs probe messages causing new groups created ffi probe messages sent group members lemma processors members groups created new groups created ffi ffi 
group largest id known processors time ffi 
group created ffi 
processors received newgroup message time ffi 
new groups created ffi ffi group largest id time 
processor accept join 
takes ffi time units creator received accept messages sends join messages 
time ffi processor received join message joined group 
conclude processors joined common group membership equal time ffi ffi ffi ffi max ffi 
round protocols satisfy requirements tj td ffi max ffi 
properties round protocol common safety timeliness properties round protocol essentially structure round protocols difference majority group created additional round prepare messages sent group creator collected accept messages members creator waits prepared replies members sending join messages 
fact express similarity clearly terminology 
say newly created majority group preliminary group creator collected accept messages begins sending prepare messages say processor joins preliminary group creator just sending prepare message member just received prepare message call group committed creator joined group collecting prepared replies members sending join messages members 
preliminary groups round protocol behaves exactly round protocols 
follows common safety timeliness properties fact reason protocol calls processor start group related timers appendix correctness proofs round protocols apply directly preliminary groups created round protocol 
observation straightforward see properties hold committed groups created round protocol additional term ffi added time constants take account time required extra rounds messages preliminary group committed group 
remains show round protocol achieves agreement unique history majority groups property distinguishes round protocol round protocol majority groups 
agreement group history examine version protocol relies infinite storage keep history majority groups 
observation processors joined preliminary majority group local history value local variable hist identical join preliminary majority group 
proof processor updates local history variable hist sends receives prepare message new majority group definition exactly time joins preliminary group value variable hist change long processor joined preliminary group 
furthermore time processor joins preliminary group sends receives prepare message replaces local history contained prepare message 
processors joined preliminary group value hist 
observation processor joins new preliminary majority group updates local history history containing group element 
proof definition joins majority group receives prepare message creator time replaces local history history sent timer soon receives prepare message new majority group waiting join message time joins preliminary group see procedure prepare pseudo code 
appendix correctness proofs creator prepare message 
creator constructed appending history 
lemma 
local history processor time value variable hist processor time 
preliminary majority groups predecessor definition pred round majority protocol applied preliminary groups formed execution round protocol 
proof round protocol way histories grow group creation creator new group appends histories received accept messages members new group observation history receives accept message element majority group sender message joined received newgroup message histories picks history largest element 
satisfies definition predecessor group creator adds new group history adds history predecessor lemma stable group history prefix stable group history vice versa 
proof proof contradiction assume stable histories processors identical stable history continues group stable history continues groups part stable history processor receives join message prepare message new group time groups history stable 
group id contained join message caused part stable history 
time history looked 

possibly necessarily equal similarly time part stable history received join message group history looked 

lemma group predecessor group immediately right appendix correctness proofs 
definition group predecessor 
contains exactly ancestors similarly contains ancestors follows predecessor predecessor remember processor received join message creator implies creator received prepared messages members means members received prepare message creator definition preliminary groups means member joined preliminary group 
similarly member joined preliminary group 
apply property round protocol linear history completed majority groups preliminary groups follows ancestor contradicts previous observation ancestors 
conclude original assumption false stable histories diverge 
processor joins majority group part stable history follows committed majority groups part linearly ordered history 
protocol satisfies requirement 
version round protocol analyzed requires infinite storage groups added history removed 
avoid problem histories periodically pruned removing groups history shown pseudo code 
group removed known joined members change affect correctness protocol 
