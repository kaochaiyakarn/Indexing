universitat augsburg ideal stream algebra bernhard moller report institut ur informatik augsburg copyright fl bernhard moller institut fur informatik universitat augsburg augsburg germany www informatik uni augsburg de rights reserved ideal stream algebra bernhard moller institut fur informatik universitat augsburg augsburg germany mail moeller uni augsburg de 
provide mathematical properties behaviours systems individual elements behaviour modeled ideals suitable partial order 
known associated ideal completion provides simple way constructing algebraic cpos 
ideal viewed set consistent finite compact approximations object may infinite 
special case domain streams finite approximations finite prefixes stream 
introduce special way characterising behaviours sets relevant approximations 
generalisation technique earlier case streams 
set partial order define ide fq fx yg downward closure ide set ideals spanned directed subsets prove number distributivity monotonicity laws ide related operators 
basis correct refinement specifications implementations 
various small examples illustrate operators lead concise quite clear specifications 
give characterization safety liveness generalize alpern schneider decomposition lemma arbitrary domains 
extended example concerns specification transformational development asynchronous bounded queue 
part origin goals context deductive program design implementations derived specifications semantics preserving deduction rules 
examples paradigm transformational program development see refinement calculus see 
growing conviction paradigm efficient algebraic purely logical frameworks 
sequential programs demonstrated 
aim revised version appear moller tucker eds prospects hardware foundations 
springer lncs preparation 
research partially sponsored esprit working group nada new hardware design methods program specification calculation concise perspicuous compacting logic algebra possible 
parallel case extent reported viewed falling algebraic realm purely algebraic approaches 
presents particular approach streams see survey 
centers order theoretic view streams semantic objects denotational semantics 
addition order theory suitable algebra formal languages reasoning streams 
streams ideals basic tool approach prefix order words considered system traces 
trace language directed order iff totally ordered 
ideals prefix closed directed sets traces suitable representation finite infinite streams 
known space streams prefix ordering isomorphic ideal completion set finite streams 
ideals just particular trace languages operations formal languages manipulation 
large extent covered conventional regular algebra 
apply tools developed quite different purposes number papers algebraic calculation graph pointer sorting algorithms see 
need additional mechanisms dealing fairness fairness explicit generating expressions trace languages 
regular expressions automata transition systems gives considerable gain conciseness clarity specification calculation 
long known field syntax analysis approaches specification concurrency stay fairly detailed level automata leading cumbersome expressions 
approaches logical formulas describing sets traces involved 
extracting important concepts coming closed expressions express things structured concise form 
done regular regular expressions strong algebraic properties 
approach nicely tied temporal modal operators see 
advantage approach simple set theoretic notions avoiding overhead domain theory 
approach completely orthogonal nesting data structures admits streams functions streams sets sets streams streams streams problems 
simple soda machine show style approach order better motivate technicalities come give number examples informal explanations 
precise definitions sections 
start description simple soda machine 
accepts half dollars quarters emits soda having received half dollar worth coins 
denote events receiving half dollar quarter respectively event emitting soda 
behaviour machine described regular expression ffl ffl ffl concatenation denotes infinite repetition 
expression kind denotes set finite infinite streams case soda machine streams infinite 
expression iterated subexpression states safety properties customer insert correct amount money allowed insert money delivery 
infinite repetition combines safety liveness aspects expresses correct order insert deliver cycles safety property expresses temporal aspect eventuality see guarantees insertion sufficient amount money eventually delivered machine ready accept orders 
prefer leave states implicit long possible frequently regular expressions clearer concise corresponding descriptions accepting automata buchi automata case infinite repetition see :10.1.1.38.8643
fairness eventuality properties expressed kleene finite repetition operators exemplify describe scheduler unboundedly fair merging input channels 
modelled infinite stream alphabet denotes choice left choice right input channel merge module 
fact choice left followed eventually choice right expressed regular expression ffl 
adding symmetric requirement infinite repetition drive single cycles get description set streams model behaviour fair scheduler sched def ffl ffl local eventuality expressed finiteness infinite repetition adds liveness global eventuality 
arbitrary possibly non fair merge obtained replacing scheduler reason fairness cause problems approach fairness constraints expressed star operation simple recursive definition fixpoints inclusion ordering sets streams continuity problems extensions prefix order sets streams 
due fact prefix order operational traits unbounded fairness operationally feasible inclusion ordering purely descriptive face problem 
adequate proving properties sets streams comes implementation course operationally feasible descendants 
prefer state fairness assumptions explicitly gives greater flexibility building underlying semantic framework 
channels aspect fairness eventuality exhibited description channels protocol specifications 
channels faulty fair sense unbounded finite number faulty transmissions transmit correctly 
describe behaviour streams functions model individual transmissions 
id identity function models correct transmission fail function transforms message error element skip function transforming message empty output 
sequel stand sub superscript unbounded finite repetition bounded repetition 
specifications express unbounded bounded fairness respectively 
possibly corrupting fair channel described def fail ffl id possibly lossy fair channel def skip ffl id possibly lossy corrupting fair channel def skip fail ffl id unfair corrupting channel def fail id kind channel descriptions concise algebraic correctness proof alternating bit protocol 
stream models systems modules stream processing functions stream processing function spf function tuples input streams tuples output streams see 
case synchronous systems may equivalently replaced function stream input tuples stream output tuples 
spf view module described spf 
advantage model allows easy definitions various composition operations modules lends modular structuring large systems 
disadvantage description asynchronous systems separation input output streams loses causal information viz 
input triggered output 
gives rise famous merge anomaly fixed re introducing time information streams 
expressed elements stream considered belong time interval 
done explicit time ticks streams sequences sequence lists elements belonging time interval 
trace models trace view system described structure traces possible system actions interleaving semantics 
view stream complete record system run channel activities interleaved 
view ccs csp process algebra 
simplest case trace structure set traces see 
view fits directly notion behaviour 
csp view alphabet theta set channel names set values transmitted channels 
streams complete records system runs channel activities interleaved 
advantage view keeps track causality input output merge anomaly arise 
disadvantage lack immediate modularity system described 
modularisation re introduced restricting attention subsets channels 
part ii mathematical background order theoretic preliminaries section repeat basic notions theory partial orders state new algebraic properties 
proofs section 
partially ordered set define proper improper downward closure def fy xg def fy xg list useful properties operations lemma consider 
distributivity 

set maximal elements defined maxn def nnn give useful properties lemma consider 
maxn nn 
maxn maxn 
maxp maxn 
maxn max maxn max nn extend order relation subsets def half egli milner preorder 
particular useful properties lemma consider 



max maxp generally preorder sets interested induced equivalence relation def lemma consider proof immediate lemma 
subset cone downward closed cones coincide particular partial order cones 
cone intersection cones cone set cones forms complete lattice inclusion 
isomorphic hoare power domain 
going domain 
pointwise extension sequel define functions single points lift subsets pointwise extension setting def ff ng pointwise extended functions distribute arbitrary unions monotonic inclusion strict 
mechanism lift functions level sets subsets pointwise extensions inherit linear laws 
laws form equational laws variables occur exactly sides equality sign 
examples laws neutrality associativity commutativity 
implications element relations atoms variables occur exactly sides implication sign 
inherited form element relations turn inclusions 
example ffl lifts ffl directed sets subset directed finite subset upper bound equivalently directed elements common upper bound elements set consistent approximate common element 
denote dir set directed subsets note operation dir monotonic inclusion 
study directedness behaves union intersection 
lemma consider 
dir dir 
dir dir dir 

dir dir 
dir dir 
dir fk dir fk dir proof 
assume directedness done 
transitivity 
claim trivial 
consider suppose assume directedness follows nnp arbitrary shown second disjunct immediate 
immediate setting 
assume directed transitivity 

show reverse inclusion immediate 
consider dir 
def def know dir 
dir 
shows claim 
ideal completion tie approach domain theoretic notions recall ideal completion cf 

consider ordered set 
ideal directed cone 
set ideals denoted 
partial order called delta complete iff directed set supremum upper bound element finite compact iff directed set td equivalently finite iff ideal ti 
algebraic iff element supremum directed set finite elements 
non finite element algebraic set called limit point infinite element 
notions theorem 
set ordered set inclusion delta complete algebraic finite elements principal ideals mapping 
embedding 

monotonic mapping delta complete set unique continuous mapping extending 
directed ordered set called ideal completion 
set def 
ideal non compact iff doesn maximal greatest element 
part iii algebra ideals streams ideals notion streams precise 
assume alphabet atomic actions states 
usual set finite words denote empty word concatenation denoted ffl 
subset called formal language 
word prefix word written iff word ffl known defines partial order words founded 
element order 
corresponding strict order denoted 
cone prefix closed language 
note non empty cone contains 
properties shall ffl ffl ffl ffl called local linearity 
informally stream finite infinite sequence elements basis approach observation stream completely characterized set finite prefixes 
set downward closed cone 
directed partial order local linearity directed sets characterised way lemma directed iff totally ordered iff elements ideal totally prefix closed non empty language 
note ideal contains 
ideal set words increasing length growing right 
set may finite infinite 
simple example infinite ideal ffl ffl ffl ffl ffl ffl identify stream set finite prefixes 
set ideal 
call elements streams noted compact elements correspond elements countable set countable basis finite elements countably algebraic 
length stream denoted jsj coincides cardinality minus 
give infinite streams lemma stream infinite iff maxs 
proof linearity prefix order stream foundedness infinite stream maximal element 
lemma reverse implication 
compact elements correspond elements non compact elements precisely infinite ideals 
correspond infinite sequences set def fj max resume previous example ideal ffl ffl ffl ffl ffl ffl limit supremum set finite ideals ffa ng ing corresponding increasing set fa ing finite words 
may viewed representation infinite stream 
observation main motivation approach allows infinite streams manipulating sets finite approximations ideal completion finite infinite element identified set finite approximations 
allows carrying laws algebra formal languages streams 
course fact set finite infinite streams isomorphic ideal completion set finite streams known new direct calculation ideals underlying algebra 
approach motivated particular case streams perform mathematical development far possible general ideal completions 
setting non interleaving semantics illustrate approach different setting sketch partial order semantics allowing true concurrency setting 
set events 
history partial order finite set order models temporal causal dependence 
events related considered parallel concurrent 
set histories define approximation ordering def theta appropriate generalization prefix relation words histories 
means embedded cone may add events 
straightforward check defines partial order 
element 
chronicle ideal infinite chronicles generalize infinite streams 
case streams retrieved considers histories linearly ordered case corresponds directly shall pursue example 
behaviours refinement application ideals description systems 
model non determinacy define behaviour set ideals 
noted sets ideals behaviours allows semantics distinction internal external 
algebraic reflection concatenation sequencing operation distributes union left right 
algebraic approaches ccs systems see holds 
results models tree objects reflect non deterministic branching structure time 
detailed record lost admitting just 
set finite prefixes behaviour pref def clearly pref distributes union monotonic 
refinement relation choose inclusion behaviour refines behaviour instance property set ide ideals satisfying behaviour 
allow correct local refinements ensure monotonicity operations inclusion 
example resume example section show bounded fairness refines unbounded fairness operators involved monotonic inclusion obtain ffl ffl ffl ffl ffl sched describing behaviours properties want characterise ideals certain sets relevant finite approximations 
set subset partially ordered set called property connection 
particular case streams finite approximations snapshots form finite words assume set admissible snapshots 
stream contains snapshots subset directed 
may arbitrary gaps snapshots reconstruct stream fill details snapshots 
done prefix closure define set streams behaviour spanned snapshot set str def fd dir ug set streams interpolate consistent snapshots related notion occurs connection precise section 
generalize arbitrary partial orders ideal completions 
partial order finite approximations 
property define ide def fd dir pg set ideals spanned directed subsets note ide 
note ide monotonic inclusion 
different characterisation ide lemma statements equivalent 
ide 

proof equivalence obvious monotonicity downward closedness 
suppose dir assumption monotonicity assumption directed lemma directed claim follows 
distributivity property ide lemma consider ide ide ide proof ide lemma distributivity lemma directedness lemma lemma lemma ide ide reverse inclusion follows monotonicity ide proof lemma 
shows monotonicity ide corollary ide ide proof inclusion right left part theorem 
noted ide distributes finite unions continuous 
instance see example 
properties concerning downward closure lemma 
ide 
pref ide 
ide ide reverse inclusion valid 

ide ide ide 
proof 
assume dir 
monotonicity idempotence get 
straightforward implies dir 
inclusion straightforward 
reverse consider ide 
immediate monotonicity ide counterexample reverse inclusion see example 
immediate 
maximal infinite ideals maximal ideals frequently interested processes continue long possible 
modeled ideals maximal equivalently inclusion 
give characterisation maximal ideals 
behaviour denote subset maximal ideals max agrees definition section laws apply 
lemma suppose 
max 
max infinite 

maxn max ide max 
proof 
need show inclusion follows downward closure suppose directedness maximality implies max assumption maxx lemma lemma nx lemma maxx fxg 
non empty finite set maximal element 

suppose max say max ide get maxn ide theorem contradiction max ide infinite ideals motivated define behaviour set infinite ideals inf def fi max general domains bit misnomer may infinite ideals maximal elements 
single particular class domains occur terminology justified 
clearly inf distributes arbitrary union intersection inf inf inf inf lemma restated maxn max ide inf ide reverse inclusion generally valid 
counterexample choose usual ordering consider ideal 
max max call partial order max determined inf max refinement laws clarify relation inf ide max ide investigate monotonicity distributivity max ide inf ide max inf operations important refinement 
note lemma 
inf ide inf ide inf ide particular inf ide monotonic inclusion 

saf inf ide inf ide inf ide proof 
immediate lemma equation 

immediate lemma equation 
concerning maximal ideals lemma max determined 

inf ide ide max max ide 
max ide inf ide ide maxn 
maxn inf ide ide max max ide 
inf ide inf ide inf ide particular inf ide monotonic inclusion 

saf inf ide inf ide inf ide 
maxn max ide max ide 
maxn maxp max ide max ide max ide 
cones maxn maxp max max ide max ide max ide proof 
inf ide definition ide max max determined ide max lemma ide max ide 
suppose max ide max inf ide definition 
max singleton say max fxg follows ide maximality shows maxn ide maxn 
inf ide max ide shown 
suppose ide maxn say maxn ide say dir consider directedness maxn get altogether max ide 
assume maxn 
lemma shows max ide inf ide equalities follow 
max ide ide max assumption monotonicity ide ide max max ide 
aim application lemma 
suppose max ide ide ae max 
ide ae ide ae contradiction maximality max ide ide ae 
symmetry max ide ide ae 
claim immediate lemma 

follows 
assume max ide max ide max 
need show ide 
cones get showing claim 
lemma allows simplification defining property behaviour 
lemma consider max ide max ide ide ide proof ide ide lemma max ide ide max ide lemma max ide max ide claim holds trivially ide 
assume 
need called maximal principle see assume partial order non empty chain upper bound 
element maximal element 
apply partial order ide 
satisfies assumption ide closed directed unions particular unions chains 
consider ide ide 
maximal principle max ide max ide additional assumptions simplify assertion lemma assume dir max ide max ide proof apply lemma show dir implies ide ide assume ide ide say dir lemma get 
ide dir lemma ide counterexample directed see example connection corollary 
recalling equivalence associated preorder obtain previous lemmata corollary consider 
ide ide max ide max ide 
dir max ide max ide alternative characterization infinite ideals conclude section alternative characterization set inf ide property define lim def fi dir max generalizes corresponding definition infinite words streams cite just 
notations lim literature ffi show lemma 
inf ide lim 
max determined reverse inclusion holds 
proof note inf ide definition ide max lemma max equality max lemma max prove claims follows 
lemma dir max definition lim 
max determined assume lim remains show monotonicity downward closure lemma obtain max max max max max remains investigate conditions partial order max determined 
introduce auxiliary notions 
function dir ide say maxima set maximal element 
addition functions mentioned shall ne def fc chai def fc non empty lemma chai maxima ne maxima 
proof assume maxd 
construct chain follows choose arbitrarily 
assume 
maxd def fx ing maxc contradiction 
corollary chai maxima dir maxima 
proof directed set non empty 
say separates ideals intersection chai maxima 
connection max theorem max determined iff separates ideals 
proof suppose chai maxc 
ideal maxc 
max max ide downward closedness follows contradiction 
assume max max ide separates ideals corollary dir maxima 
particular max contradiction 
surprising consequence corollary max determined 
elements compact 
proof previous theorem separates ideals 
show ti 
assume ti set def maximal directedness greatest element ti contradiction 
consider ti downward closedness get compact 
reverse implication valid example shows consider 

ffl ffl ffl ffl ffl ffl elements compact 
def max ae def maximal 
concerning separation ideals doesn maximal element 
interesting find manageable characterisations max 
part iv particular case streams specialise particular partial order 
shall represent streams sets finite traces 
finite words alphabet atomic actions ordered prefix relation 
streams properties set streams satisfying property str def ide note adequate set str called adherence see str reason prefix closure infinite substreams may cone results language mutually incomparable words represent systems finite behaviour 
example language def ffl represents behaviour arbitrarily long finite sequences terminated explicit endmarker 
words mutually incomparable directed subsets singletons downward closures principal ideals finite 
str consists finite ideals 
prefix closure contains infinite ideal representing infinite stream 
str str konig lemma show finite infinite cone contains infinite stream 
general definition ide omits undesired streams 
ide erratic non determinacy 
example consider recursive definition ffi dc ffi denotes stream concatenation see section precise definition dc denotes non deterministic choice 
interpretation dc eventually terminating branch chosen equal str example 
erratic interpretation dc hand guarantee terminating branch chosen equal str example 
want show str ide distribute general union example take str ing str ing 
maximal infinite streams mentioned maximal ideals model processes go long possible 
streams pleasant situation general ideals lemma max determined 
proof assume ide max consider ide lemma downward closure suffices show consider max jjxjj jjujj denotes length word directedness linearity follows jjxjj allows laws section streams 
point convenient give counterexample simplified version corollary example set def ffl def 
max str max str max str max str 
concerning infinite streams note lemma inf ide fi ide establish relation show lemma lim fi proof lim definition dir max lemma max show linearly ordered infinite maxl immediate 
suppose maxl 
linearity jlj jjxjj contradiction 
non empty finite set maximal element 
section write specializations laws case streams bounded buffer example corollary inf str inf str directed inf str inf str directed proof immediate lemma lemma corollary 
example inf str ffl ffl inf str ffl stream concatenation prerequisite defining infinite repetition need stream concatenation streams defined ffi def max ffl explain definition 
finite maxs singleton 
part behaviour prefixed traces represent concatenated behaviour 
infinite maxs strictness ffi get ffi intuitively expected 
max ffi max ffl max straightforward show ffi stream ffi monoid 
shorthand notation shall allow words argument ffi 
precise setting ffi def ffi ffl ffi extended pointwise behaviours case shorthand languages 
infinite repetition give usual greatest fixpoint definition set streams result infinite repetition words language ffi ffi knaster tarski fixpoint theorem defined monotonicity ffi 
note definition 
reason usually considered noted ju nontrivial solutions ffi properly example consider behaviour ffi eventually periodic streams 
tie str operation quote lim ffi lim lemma max inf str ffi inf str strictness ffi immediate inf str inf str sufficient condition establish premise lemma satisfies fano condition words mutually incomparable inf str proof fano condition directed subsets singletons :10.1.1.100.9674
str fu ug consists finite streams 
note satisfies fano condition iff case equation doesn hold inf str :10.1.1.100.9674
mentioned satisfies fano condition iff see happens fano condition satisfied consider example fa bg def fa ffl ing dir directed 
str infinite inf str represents followed infinitely bs behaviour clearly arise repeated concatenation words fact simply considering directed subsets throws away structural information :10.1.1.100.9674
allow characterization languages satisfy fano condition artificially enforce attaching special endmarker words remove infinite streams 
new letter consider streams extended alphabet 
denote 
word results removing occurrences extend operation 
pointwise languages behaviours 
lemma def 
inf str ffl somewhat tedious proof see 
streams str ffl correspond finite infinite sequences result concatenating arbitrary elements separator 
operation max selects prefix maximal ones precisely infinite words resulting repeatedly concatenating words separators record construction history streams thrown away filter 
way subsets directed accident ignored 
similar mechanism defining iteration employed finite case infinite case 
streams functions assumptions alphabet may set functions 
streams model components time dependent behaviour 
seen examples description various faulty channels section 
stream arguments fed stream functions 
definition 
def 
def ffl 
ffl def ffl 
operation extended pointwise languages behaviours 
index notation 
provided min jf jg 
example finite stream ffl 

ffl 
reflects unbounded guarantee correct transmission occurs elements may may transmitted correctly 
bound assumptions gets precise information example ffl 
ffl ffl channel fairness bound transmit correctly receives copies feedback state systems feedback operation essential operation feedback outputs inputs 
assume spf theta theta feedback illustration see 
semantics recursive declaration usual fixpoint 
version feedback operator hides feedback stream 
visible simply copies feeds copy back transmitted outside 
state systems automata operation streams functions allows convenient concise description state systems 
assume set states input alphabet output alphabet time dependent automaton stream theta theta may feed automaton starting state stream input values produce stream output values stream states entered processing input constructed feedback hidden outside 
described auto ffl 
placing various restrictions entities involved distinguish hierarchy automata fig 

feedback operation restrictions obtain timed state dependent automaton 
require jqj timed state independent automaton 
take theta theta obtain timeless state dependent automaton 
take require jqj timeless state independent automaton 
fo example easy proof induction structure finite words shows lemma jqj auto 

illustrate general case example give description place asynchronous buffer 
example taken fom 
consider set data 
input alphabet def input means stored buffer means request current contents buffer 
time point buffer may accept reject input shown boolean value 
addition buffer output data accepts request signal 
choose output alphabet def theta ib models case proper output 
set states choose def models state empty models state containing value define transition functions acc rej theta theta model acceptance rejection input 
acc acc rej false behaviour fair buffer rejects inputs finitely times eventually accepting specified auto rej ffl acc particular avoid variables see style 
processes synchronised parallel composition previous sections appropriate spf view distributed systems define operators adequate trace view cf 
section 
particular definitions draw strongly corresponding ones 
assume alphabet streams 
process pair alphabet process behaviour 
set ff def fi def operation projection words alphabet defined inductively follows def ffl def ae ffl projection extended pointwise languages behaviours 
projection stream stream 
projection characterize processes way pair process iff need lift notion refinement processes 
allow process refined internal actions 
refinement amounts inclusion projection behaviour abuse notation write refinement relation def ffp ffq fip ffq case say refines easily checked partial order processes 
behaviours loose allow arbitrary actions interesting ones model synchronised parallel composition simply intersection see 
general behaviours works arbitrary actions proper ones taken 
intersection allows traces actions interesting partners occur sequence acceptable partners allowed behaviours private actions partner constrained partner 
processes define parallel composition jjq setting ff jjq def ffp ffq fi jjq def ff jjq ffp fip ffq note particular jj commutative associative idempotent 
jjq ffp ffq fi jjq fip 
parallel composition operator extended example section vi 
part safety liveness informally discussed safety liveness see 
want show notions expressed algebraically 
subsequent papers property set infinite sequences states 
appropriate counterpart setting set streams generally ideals behaviour 
safety definition topological properties behaviour infinite streams called safe holds ffi means stream behaviour decisive finite prefix went wrong continuation bring computation back path 
want simplify formal definition moving logic algebra 
contraposition formula transformed ffi recalling definition pref section ffi pref safety condition reduces pref set theory pref prefix closedness pref lemma str pref defining def str pref simplified form involves order theoretic notions generalizes easily arbitrary ideal completions 
consider partial order behaviour call safe iff def ide pref monotonicity pref ide monotonic 
note behaviour safe iff lemma 
safe behaviours closed arbitrary intersections finite unions 

idempotent 

safe behaviour containing proof 
assume family safe behaviours 
monotonicity safety safe 
union calculate definition distributivity pref pref pref boolean algebra pref pref set def pref def pref directed lemma downward closedness lemma boolean algebra definition get safety 
definitions fj pref bg principal ideals pref pref definitions 
safe monotonicity safety safe 
properties safe behaviours coincide closed sets topology cf 
topological closure operator 
safety snapshot sets study safety reflected snapshot sets 
words want know behaviour ide safe 
calculate ide definition ide pref ide lemma ide lemma ide safe ide ide dir hand altogether shown lemma behaviour ide safe iff iff downward closed 
reason call snapshot set safety property iff downward closed 
corollary safety property ide proof immediate lemma 
safety property behaviour ide closed unions suprema ascending chains streams 
special case streams safety properties simply prefix closed subsets continual satisfaction general case connection safety issues interested set objects satisfy property finite approximations 
property define property saf saf def fx pg set saf termed prefix kernel 
lemma 
saf 
saf iff safety property 

saf greatest safety property contained 
saf monotonic strict 

saf saf saf 
ide saf proof 
saf definition 
assumption saf definition assumption definition saf saf reverse inclusion shown 
obvious saf safety property 
safety property definition saf 
immediate definition 

saf definition infimum property intersection definition saf saf 
ide saf lemma saf saf saf downward closedness saf saf downward closedness note saf distribute union 
state distributivity property ide lemma consider saf ide ide ide proof need show reverse inclusion follows monotonicity ide assume ide ide say dir dir lemma lemma get shows get directed dir 
shows ide 
deriving recursion saf particular case streams want derive grammar representation safety properties form saf induction words involved 
induction base calculate saf definition induction step arbitrary ffl saf definition ffl ffl set theory ffl ffl assume form automaton recursion 
systematic way passing recursion saf suppose satisfies ffl function 

words assume recursive call depends symbol word analysed 
assumption means galois connection cffl assumption continue follows ffl assumption definition saf note bi implication linear results 
sum shown lemma suppose property satisfies ffl saf ffl saf saf assume properties seek recursion saf saf saf 
result immediate lemma lemma lemma suppose satisfy ffl ffl saf ffl saf saf corresponds construction product automaton 
liveness definition topological properties call behaviour streams live iff ffi reduce pref pref set compact elements easily generalize arbitrary ideal completions 
consider partial order behaviour call called live iff pref show see lemma live iff topologically dense iff proof pref transitivity inclusion principal ideals pref pref corollary definition set theory set theory obtain lemma behaviour intersection live safe behaviour 
proof copy proof respective theorem verbatim proceeds purely topological terms 
give simpler proof avoids topological reasoning 
assume bn bnb definition denotes complement de morgan double complement safe claim shown live 
calculate monotonic extensive definition complement done lemma 
inspection proof leads abstraction 
consider boolean algebra greatest element 
call function pre closure extensive satisfies monotonic 
say dense 
corollary element meet image dense element viz 
way replacing topological proof lemma proof boolean algebras 
proof simpler 
liveness snapshot sets case safety investigate property spans live behaviour 
calculate ide live definition pref ide lemma definition call liveness property iff spanning infinite behaviours snapshot sets define part snapshot set relevant infinite streams 
call set lively iff maxq 
lemma 
lively inf ide 
lively inf ide 

lively iff inf inf proof 
construct chain follows 
choose def assume chosen 
maxq construction def fx ing dir def ide max maxk inf ide 
immediate 
immediate 
connection results property 
allow easier liveness proofs 
note particularly relevant case streams set compact elements lively 
define live part liv def lp lp def fq operation enjoys properties lemma 
liv 
max liv 

lively iff liv 
liv monotonic 

liv liv liv 
liv inf ide 

lp inf ide 

inf ide inf ide liv 
pref inf ide liv proof 
clear definition 

assume max liv liv lp maxq contradiction 

implication clear 
converse maxp max liv 
lp lq lp lq 
liv liv liv converse calculate lively definition liv liv lively definition lp liv monotonicity definition liv liv liv liv 
max liv 
lemma monotonicity inf ide operation get inf ide liv inf ide 
note lp lp iff lp 
apply 
monotonicity inf ide get assume conversely inf ide dir directed 
maxd max 
lp liv dir liv inf str liv 

pref inf ide definitions fd dir maxd distributivity fd dir maxd definition lp definition liv liv assume conversely liv lp inf ide inf ide particular liv kernel operator 
show snapshot set spans infinite ideals suffices exhibit lively qs frequently constructed induction 
part vi extended example buffers queues specification bounded buffer example constructs give specification bounded buffer queue modules 
particular domain finite infinite streams set atomic actions 
example uses trace view cf 
section streams 
motivated asynchronous bounded queue implementation collection ifip wg benchmark problems hardware verification 
buffer module input output port 
describing modules choose letters action inputting outputting set def fa bg 
boundedness module enforced requiring number input actions exceed number output actions capacity device 
denote number occurrences formally def ffl def ffi ac ffi kronecker symbol defined ffi xy def ae generalising informal description slightly define zz set ex ab def fs ng snapshots 
ex ab max pronounced exceeds 
specification loose balance bs struck word 
instance ffl ex ab restriction may violated prefixes established 
bounded devices possible 
need stronger specification 
strengthen snapshot set safety property ab def saf ex ab ide ab set finite infinite streams satisfy ex ab prefixes 
interested devices unbounded time 
specified considering behaviour device set ab def inf str ab consisting infinite admissible streams 
buffer device number outputs exceed number inputs 
define bf ab def ba note reversal arguments superscript 
finitary property ba spells required 
describes unbounded buffer 
bounded buffer capacity described ab def bf ab ab specifies set infinite streams finite prefixes number outputs exceed number inputs inputs adjacent outputs 
transformation automaton form consider buffer example 
recall family properties ex ab def fs ng zz fa bg 
predicative implicit definition want calculate explicit description corresponding generating grammar accepting automaton 
done simple unfold fold transformation induction words induction basis calculate ex ab definition ex definition count arithmetic induction step consider arbitrary ffl ex ab definition ex ffl ffl definition count ffi ca ffi cb arithmetic ffi cb gamma ffi ca definition ex ex ab ffi cb gammaffi ca note recursion relations linear bi implications 
obtain ex ab ffl ex ab ex ab ffi cb gammaffi ca corresponds infinite grammar nonterminals ex ab infinite automaton states ex ab zz 
counting resumed want similar representation ab def saf ex ab done quite systematically lemma 
obtain ab ffl ab ab bg ffl ab gamma ab gamma ffl ab ab simplifies ab ffl ab ab bg ffl ab gamma ab gamma ffl ab ab particular ab 
consider bounded buffer behaviour 
calculate ab definition bf ab ab definition ba ab definition inf str ba inf str ab lemma sets specified safety properties inf str ba ab problem reduced finding explicit representation ba ab simple product automaton construction 
special case automaton def ba ab decomposition define buffer process setting bb ab def fa bg ab parallel composition state nice decomposition properties lemma 
ex ab ex bc ex ac 
ab bc ac 
fa bg ab fb cg bc fa cg ac 
bb ab jj bb bc bb ac proof 
ex ab ex bc definition transitivity monotonicity definition ex ac 
immediate lemma lemma 
immediate 
immediate 
allows decomposing buffer capacity parallel composition buffers capacity 
course needs shown intersections parallel compositions non empty 
follows results section easy show ffl ex ab inf str ffl ab get inf str ffl ffl fi bb ab jj bb bc ffl ffl lively inf str ffl ffl bb ab jj bb bc non empty 
place buffer special case bb ab true ffl ffl false true ffl false ffl corresponds state accepting automaton bounded buffer property sufficient purposes implementation 
seen regular grammar system equations languages 
desired calculate regular expression bb ab twice arden rule ffl ffl gives bb ab ffl ffl ffl ffl ffl corollary obtain ab inf str ffl fact language ffl singleton trivially satisfies fano condition lemma gives ab ffl expected 
buffers queues far talked relative order input output events 
queues relative order input output values relevant 
refined alphabet theta set channel names set values 
element denoted 
shorthand introduce word define word channels activity occurred word vals values transmitted inductive definitions read ffl ffl vals vals ffl ae ffl vals vals operations extended pointwise languages behaviours 
operations may specify behaviour faithful component component re order lose messages transmitting channel channel fa ab def fs vals vals bounded queue specified faithful bounded buffer bq ab def fa ab ab ab understood abbreviation 
decomposition properties buffers carry queues queue capacity refined parallel composition queues capacity 
similar calculation arden rule yields refinement bq ab ffl part vii introduced algebraic operators laws specification derivation systems 
abstracting domain streams notions coined originally obtained rich set laws hold wide variety domains 
order theoretic approach lends algebraic treatment 
point free formulation eases specifications proofs basic properties actual derivations 
research lines search similar algebraic characterisations important notions systems explore algebraic properties 
concerning underlying theory domain notions tied closely topological view see 
stream domain obviously close connection temporal operators str related intermittent assertions formula eventually temporal logic saf corresponds holds initial subintervals 
connections precise carried arbitrary domains 
resulting modal algebra ideal stream algebra developed need tried larger realistic case studies deductive design parallel systems 

alpern schneider defining liveness 
information processing letters 
back calculus refinements program derivations 
acta informatica 
baeten process algebra 
cambridge tracts theoretical computer science 
cambridge cambridge university press 
bauer moller pepper formal program construction transformations computer aided intuition guided programming 
ieee transactions software engineering 
birkhoff lattice theory rd edition 
american mathematical society colloquium publications vol 

providence ams 
bird lectures constructive functional programming 
broy ed constructive methods computing science 
nato asi series 
series computer systems sciences 
berlin springer 
bird de moor algebra programming 
prentice hall 
brock ackerman scenarios model non determinate computation 
diaz ramos ed formalization programming concepts 
lecture notes computer science 
berlin springer 
broy specification refinement buffer length 
broy ed deductive program design 
nato asi series series computer systems sciences 
berlin springer 
broy functional specification time sensitive communicating systems 
broy ed programming mathematical method 
nato asi series series computer systems sciences 
berlin springer 
broy fuchs weber design distributed systems focus 
revised version 
institut fur informatik der tu munchen report tum sfb bericht nr 

broy stefanescu algebra stream processing functions 
institut fur informatik tu munchen report tum 
broy specification refinement finite dataflow networks relational approach 
langmaack 
de roever eds formal techniques real time fault tolerant computing 
lecture notes computer science 
berlin springer 
burstall program proving hand simulation little induction 
proc 
ifip congress 
amsterdam north holland 
burstall darlington transformation system developing recursive programs 
acm 
chandy misra parallel program design foundation 
reading mass addison wesley 
conway regular algebra finite machines 
london chapman hall 
davey priestley lattices order 
cambridge cambridge university press 
davis infinitary games perfect information 
shapley tucker eds advances game theory 
princeton princeton university press 
weber safety liveness methodological point view 
information processing letters 
emerson temporal modal logic 
van leeuwen ed handbook theoretical computer science 
volume formal models semantics 
amsterdam elsevier 
feather survey classification program transformation approaches techniques 
meertens ed proc 
ifip tc working conference program specification transformation bad april 
amsterdam north holland 
glance alpern schneider characterization safety liveness concurrent executions 
information processing letters 
hoare communicating sequential processes 
london prentice hall 
hoare conjunction concurrency 

specification verification 
borger ed specification validation methods 
oxford clarendon press 
ifip wg benchmark circuits fors hardware verification 
available ira uka de benchmarks html 
jonsson fully trace model dataflow asynchronous networks 
distributed computing 
kahn semantics simple language parallel processing 
rosenfeld ed information processing 
proc 
ifip congress 
amsterdam northholland 
von karger hoare sequential calculus 
information processing letters 
lamport proving correctness multiprocess programs 
ieee trans 
software eng 
se 
lamport specifying concurrent program modules 
acm toplas 
meertens algorithmics programming mathematical activity 
de bakker 
eds proc 
cwi symposium mathematics computer science 
cwi monographs vol 
amsterdam north holland 
milner communication concurrency 
london prentice hall 
moller relations program development language 

moller ed constructing programs specifications 
proc 
ifip tc wg working conference constructing programs specifications pacific grove ca usa may 
amsterdam north holland 
moller derivation graph pointer algorithms 
moller eds formal program development 
lecture notes computer science 
berlin springer 
moller algebraic calculation graph sorting algorithms 
bjrner broy eds formal methods programming applications 
lecture notes computer science 
berlin springer 
moller shorter paths graph algorithms 
bird morgan woodcock eds mathematics program construction 
lecture notes computer science 
berlin springer 
science computer programming 
moller ideal streams 

olderog ed programming concepts methods calculi 
ifip transactions 
amsterdam north holland 
moller refining ideal behaviours 
institut fur mathematik der universitat augsburg report nr 

moller temporal operators partial orders 
proc 
rd domain workshop munich may 
ludwig universitat munchen appear 
moller modal temporal operators partial orders 
ed programmiersprachen und grundlagen der programmierung 
institut fur informatik und praktische mathematik universitat kiel appear 
extended version institut fur informatik der universitat augsburg report 
morgan programming specifications 
prentice hall 

morris theoretical basis stepwise refinement programming calculus 
science computer programming 
moszkowski compositional temporal properties 

olderog ed programming concepts methods calculi 
ifip transactions 
amsterdam north holland 
nivat behaviors processes synchronized systems processes 
broy schmidt eds theoretical foundations programming methodology 
dordrecht reidel 

olderog nets terms formulas 
cambridge cambridge university press 

olderog hoare specification oriented semantics communicating processes 
acta informatica 
park semantics fair parallelism 
bjrner ed software specifications 
lecture notes computer science 
berlin springer 
specification transformation programs formal approach software development 
berlin springer 
plotkin powerdomain construction 
siam computing 
infinite word languages continuous mappings 
theoretical computer science 
relational calculus design distributed algorithms 
dissertation university utrecht 
sharp principles protocol design 
london prentice hall 
smyth power domains 
computer syst 
sciences 
smyth topology 
abramsky gabbay maibaum eds handbook logic computer science 
vol 
background mathematical structures 
oxford clarendon press 
staiger research theory languages 
inf 
process 
cybern 
eik 
staiger languages 
rozenberg salomaa eds handbook formal languages 
vol 
words 
berlin springer 
stephens survey stream processing 
acta informatica 
thomas automata infinite objects 
van leeuwen ed handbook theoretical computer science 
vol 
formal models semantics 
amsterdam elsevier 
thomas languages automata logic 
rozenberg salomaa eds handbook formal languages 
vol 
words 
berlin springer 
compositionality concurrency partial correctness 
lecture notes computer science 
berlin springer 
