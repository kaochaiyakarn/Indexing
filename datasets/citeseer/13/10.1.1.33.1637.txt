composing specifications mart abadi leslie lamport digital equipment rigorous modular specification method requires proof rule asserting component behaves correctly isolation behaves correctly concert components 
rule subtle component need behave correctly environment component part environments 
examine precise distinction system environment provide requisite proof rule modules specified safety liveness properties 
categories subject descriptors software engineering program verification correctness proofs logics meanings programs specifying verifying reasoning programs specification techniques general terms theory verification additional key words phrases compositionality concurrent programming liveness properties modular specification safety properties 
transition axiom method concurrent systems specified combining programs temporal logic 
method permits hierarchical approach composition lower level specifications proved implement higher level specification 
described prove specification implements 
examine compose specifications 
semantic level independent particular specification language logic 
results applied number approaches method example lam shankar method projections automata lynch tuttle 
composition sense systems interact environments 
system behave properly environment 
pascal program may behave quite improperly read statement receives system value allowed type circuit may exhibit bizarre behavior input line provides input line improper voltage level 
proper specification interactive system pi asserts system guarantees property assumption environment satisfies property fundamental problem composing specifications prove composite system satisfies specification components satisfy specifications 
authors address systems research center digital equipment lytton avenue palo alto ca 
permission copy fee part material granted provided copies distributed direct commercial advantage acm copyright notice title publication date appear notice copying permission association computing machinery 
copy republish requires fee specific permission 
acm acm transactions programming languages systems vol january pages 
martn abadi leslie lamport consider system pi composition systems pi 
pi prove pi guarantees property environment assumption assuming pi satisfies property environment assumption observe expect pi guarantee properties guaranteed components 
able infer pi guarantees assumption pi guarantees 
component pi guarantees assumption environment satisfies pi environment consists pi environment components pi able infer environment assumption component guarantees observations lead principle 
composition principle pi composition pi 
pi conditions hold 
pi guarantees component pi guarantees 
environment assumption component pi satisfied environment pi satisfies pi satisfies 
component pi guarantees environment assumption pi guarantees environment assumption reasoning embodied composition principle circular 
prove holds assume holds holds assumption holds 
surprising principle valid 
show principle valid suitably weak hypotheses provides satisfactory rule composing specifications 
embarking rigorous development composition principle consider examples 
partial correctness specifications sequential programs 
hoare triple pi viewed assertion pi guarantees environment assumption asserts pi terminates true asserts pi started action environment true 
composition principle valid specifications basis standard composition rules hoare logic 
example consider rule pi sequential composition pi pi pi pi pi pi pi hypotheses rule imply conditions composition principle pi guarantees pi guarantees 
environment pi satisfies environment assumption pi satisfied 
pi guarantees environment assumption pi satisfied 
pi pi guarantees environment assumption acm transactions programming languages systems vol january 
composing specifications gamma gamma composition gamma gamma fig 

composing systems principle pi satisfies environment assumption pi proof rule 
consider reactive systems 
interaction reactive system environment expressed simply pre postconditions 
example suppose environment passes values system register reading writing atomic operations system environment obey protocol insure correct passing values 
environment obey protocol system read written obtain completely arbitrary values example values incorrect types 
system expected guarantee property assumption environment obeys communication protocol protocol specified simply terms precondition 
try extend composition principle simple partial correctness properties find validity depends precise nature properties guaranteed assumed 
consider situation depicted split wire indicates value sent di erent destinations 
suppose pi pi specifications 
pi guarantees sends assuming environment sends 
pi guarantees sends assuming environment sends 
system pi guarantee sends output wire implies pi assumption environment sends 
similarly pi acm transactions programming languages systems vol january 
martn abadi leslie lamport guarantee implies pi environment assumption condition composition principle holds 
deduce principle component pi guarantees assumption composition pi guarantees property sends sends 
environment assumption pi inputs behavior independent environment 
deduction valid 
example suppose pi receives sends pi behaves symmetrically 
pi guarantees assumption composite system pi guarantees consider happens modify specifications replacing eventually obtaining pi guarantees eventually sends assuming environment eventually sends 
pi guarantees eventually sends assuming environment eventually sends 
property guaranteed pi implies environment assumption satisfied 
time composition principle leads pi guarantees eventually send eventually send 
invalid 
systems described send appropriate output receiving appropriate input satisfy modified specifications 
composition fulfill guarantee implied composition principle 
replacing eventually changed guarantees environment assumptions safety properties liveness properties 
intuitively safety property asserts bad happen liveness property asserts eventually happen 
safety liveness defined formally section 
methods describing composing systems composition principle valid guarantees assumptions safety properties 
various special cases result appeared di erent guises 
familiar incarnation inference rules partial correctness specifications guarantees assumptions specifications safety properties 
composition principle safety properties embodied proof rule misra chandy processes communicating means csp primitives 
specifications involve safety properties satisfying safety property satisfied system 
liveness properties added rule trivial implementations 
pnueli considering di erent class programs gave general proof rule misra chandy 
pnueli rule handles liveness properties composition principle requires explicit induction step 
stark proposed general proof rule 
stark method handles liveness properties cost requiring discovery set auxiliary assertions explicitly break circularity composition principle 
main result theorem section provides formal statement composition principle 
main hypothesis environment assumptions safety properties 
properties guaranteed system components need safety properties include liveness 
theorem section shows specification satisfying certain reasonable hypothesis equivalent acm transactions programming languages systems vol january 
composing specifications specification environment assumption safety property 
theorems fruit detailed examination distinction system environment sections 
composition principle extremely general 
assume particular language logic writing specifications 
applies equally specifications ada programs microcode digital circuits 
formalizing result generality requires concepts may odd readers accustomed models computation 
rest section introduces concepts relates approaches readers may find familiar 
precise definitions appear section 
glossary notation conventions appears 
states versus actions popular approaches specification states actions 
state approach execution system viewed sequence states state assignment values set components 
action approach views execution sequence actions 
di erent approaches sense equivalent 
action modeled state change state modeled equivalence class sequences actions 
approaches traditionally taken di erent formal directions 
statebased approaches rooted logic specification formula logical system 
action approaches tended algebra specification object manipulated algebraically 
milner ccs classic example algebraic formalism 
state action approaches tend di er practice 
specify keyboard input action approach typing single character represented single action 
state approach represented separate state changes key depressed released 
action representation appears simpler pressing key action state changes 
simplicity deceptive 
specification typing character single action provide real situation second key depressed released 
reason expect actions simpler states accurately describing real systems 
state approach forces close examination real system represented model helping avoid oversimplification 
hand circumstances oversimplified models useful 
adopt state approach term action informally mean state change 
system versus environment view specification formal description interface system environment 
state completely describes state interface instant 
necessary distinguish actions performed system ones performed environment 
example consider specification clock circuit output increasing sequence values circuit change clock value environment acknowledged reading 
specification acm transactions programming languages systems vol january 
martn abadi leslie lamport include state components clock ack correct behavior consisting sequence actions alternately increment clock complement ack 
consider anti clock circuit assumes environment rest circuit provides clock 
anti clock issues acknowledgments expects environment change clock 
clock anti clock display sequence states sequence clock ack values obviously di erent systems 
distinguish specify state changes may occur state changes performed system environment 
action formalism simply partition actions system environment actions 
formalisms joint system environment actions require subtle distinctions internal external nondeterminism operators csp 
state formalism easiest way distinguish system actions environment actions partition state components input output components require values input output component change 
declare changes output components performed system changes input components performed environment 
method partitioning state components flexible 
example want specify individual assignment statement system environment rest program appears 
modified parts program input output component system 
general want allow module boundaries orthogonal process boundaries modules need communicate means simple input output variables 
partitioning state components assume state change performed agent partition set agents environment agents system agents 
system execution modeled behavior sequence alternating states agents agent responsible change state 
specifying system environment specification system pi asserts pi guarantees property assumption environment satisfies property formally define property set behaviors execution pi satisfies property behavior sequence states agents represents execution element specification pi property set behaviors behavior satisfies specification satisfies fails satisfy system pi satisfies specification behaviors representing executions pi elements important realize assumption environment constraint placed 
environment constrained controlled system 
system prevent user depressing keys time 
include assumption user press keys means system guarantees behave properly user presses key time 
specification requires user press keys implemented system control acm transactions programming languages systems vol january 
composing specifications user fingers 
distinction assumption requirement central results addressed formally section 
definition property set behaviors means determine system satisfies specification examining possible system execution having examine set possible executions 
example specify system average response time millisecond execution containing requests average responses single execution 
specify average response time average responses possible executions 
composition proof modular specification method proves composition lower level systems implements higher level 
section explains method described prove specification form implements higher level specification form 
approach composition conjunction 
composition systems specifications satisfies conjunction 
prove composition implements specification composition principle show satisfies specification method described prove implements theorem formal statement composition principle proposition section allow conclude implies environment assumption implies environment assumption composition systems satisfying system satisfying circularity deduction observed examples 
examples identically true composition principle permitted deduce theorem proposition imply apparently absurd deduction valid major hypothesis safety properties 
theorem section shows reasonable hypothesis 
composition principle applies cases excludes behaviors allowed specifications deduced logically properties principle sound excluded behaviors correspond executions produced components satisfying example behaviors environment chooses violate component violated composition principle valid despite apparent logical circularity 
semantics versus logic transition axiom method specification logical formula describes set behaviors 
stating results particular temporal logic transition axioms take general semantic view specification set behaviors 
relation logic semantics indicated list logical formulas corresponding semantic acm transactions programming languages systems vol january 
martn abadi leslie lamport objects 
symbols denote formulas logical view corresponding sets behaviors semantic view denotes set behaviors 
logic semantics logic semantics semantic model described section 

semantic model define semantic concepts results 
concepts appeared described briefly reader consult cited sources complete discussions 
states 
state element nonempty set states 
stated assume fixed 
state predicate called predicate subset set states 
think element representing state instant relevant universe interfaces systems consideration 
specification describe externally visible elements represent state interfaces internal mechanisms 
agents 
assume nonempty set agents 
set agents denotes set agents 
agent set subset empty 
terminology may confusing arbitrary set agents agent set 
empty set agents full set agents turn anomalous uninteresting technical reasons unobtrusively exclude anomalous cases considering agent sets 
think elements entities responsible changing state 
specification describes means set agents form correctly operating system words means behavior correct agents considered form system agents considered form environment 
describing system particular agent performs action important matters agent belongs system environment 
dealing single specification assume just agents system agent environment agent done barringer kuiper pnueli 
composing specifications needs general sets agents introduced agents called actions 
may help reader think agents elementary circuit components individual machine language instructions 
actual identity individual agents matters 
behaviors 
behavior prefix sequence 
state agent sequence infinite ends state 
behavior infinite behavior prefix 
behavior prefix denotes denotes acm transactions programming languages systems vol january 
composing specifications behavior denote finite prefix mth state 
term behavior indicate states behavior elements behavior represents possible complete history relevant universe starting appropriate time 
usual state approaches adopt interleaving semantics evolution universe broken atomic actions state changes concurrent actions considered happen arbitrary order 
step behavior denotes action agent changes state universe steps formalism correspond actions action formalisms 
stuttering equivalence 
set agents stuttering step sequence behavior prefix defined behavior prefix obtained replacing maximal finite infinite sequence 
stuttering steps single state behavior prefixes said stuttering equivalent written equals write stuttering equivalent stuttering equivalent 
finite behavior prefix defined arbitrary behavior 
precise choice involves choosing agents perform infinite number stuttering steps added matter 
state describes state entire relevant universe stuttering step change state stuttering step observable ect 
behaviors stuttering equivalent indistinguishable 
useful way think stuttering imagine state describes observable parts universe unobservable internal state components various objects universe 
stuttering step represents step object changes internal state 
explained considering stuttering equivalent behaviors equivalent allows hierarchical decomposition specifications refining grain atomicity 
finite behavior prefix obtained adding infinite number stuttering steps 
behavior represents history universe externally observable activity ceases finite number steps 
example computer halted continues take stuttering steps internal clock keeps 
properties 
property set behaviors closed meaning behaviors call property indicate set behaviors 
state predicate considered property properties define property denotes complementation set behaviors 
formulas lower precedence denotes property safety property satisfies condition behavior 
property liveness property finite behavior prefix prefix behavior standard topology set behaviors property safety property closed liveness property dense 
follows elementary results topology acm transactions programming languages systems vol january 
martn abadi leslie lamport property conjunction safety property liveness property 
closure property topology written smallest safety property containing property safety property behavior finite prefix safety property finitely refutable 
state predicate property depends initial state safety property 
property liveness property finite behavior prefix completed behavior liveness property finitely refutable 
alpern schneider discussed definitions detail 
properties define set behaviors 
safety property asserting false 
follows definition properties specification system property consisting behaviors histories relevant universe system considered perform correctly 
abstractness 
set agents behaviors equivalent set behaviors behaviors equivalent behaviors equivalent replaced agent single agent agent di erent single agent 
reasonable specification system describe agent performs action action performed system environment agent 
set system agents specification distinguish equivalent behaviors property 

realizability specification system property consisting behaviors system performs correctly 
behavior allowed specification may depend environment actions system actions 
dependence environment unavoidable system expected perform prescribed fashion environment behave correctly 
ability specify environment system gives ability write specifications constrain environment allowed 
specification require system control predict environment environment precisely part universe system control 
specification assert system performs properly environment assert environment performs properly 
example assume environment supposed decrement state component specification property asserting environment decrement implementable system possible universe containing system behavior environment decrements system satisfy specification acm transactions programming languages systems vol january 
composing specifications specification system allow behaviors environment decrements specification constrains environment actions called unrealizable 
specification may reasons concern example requires system compute noncomputable function 
define precisely realizability means explore implications specifications 
definitions identical ones 
safety properties safety property finitely refutable behavior satisfy property tell took step violated 
precisely safety property behavior number smallest number say violated agent performed mth step assuming 
safety property defined constrain system property violated system agents 
formalize definition 
property behavior equal smallest nonnegative integer 
leave undefined 
agent set safety property constrains behaviors realizability arbitrary properties definitions 
understand general concept realizability helps think behavior outcome person infinite game played system environment 
environment chooses initial state environment system alternate moves produce behavior environment move 
environment move consists adding finite number steps performed environment agents possibly zero steps system move consists doing adding step performed system agent 
similar class games studied morton davis 
system wins game resulting behavior prefix satisfies specification finite 
informal discussion simplified considering system win games finite outcomes correspond infinite behaviors formalism 
specification said realizable system winning strategy system win matter moves environment 
specification realizable behaviors system win environment plays 
specification may contain behaviors outcomes games environment chance win played badly lost 
correct implementation allow behaviors occur count environment playing badly 
realizable part specification defined consist behaviors environment chance win 
implementation satisfies specification produce behaviors realizable part 
specifications implementations realizable parts 
specifications said 
replace specification changing class real systems acm transactions programming languages systems vol january 
martn abadi leslie lamport specified 
formal definitions concepts definition strategy rule system determines move 
precisely strategy partial function determines system step function behavior point 
su ces consider deterministic strategies set behaviors result nondeterministic strategy union sets behaviors produced set deterministic strategies 
definitions arbitrary agent set 
strategy partial function set finite behavior prefixes 
intuitively means system gets move play produced adds undefined system chooses move 
outcome strategy behavior am 
outcome fair am domain infinitely values 
outcome moves produced strategy fair obtained giving system infinite number chances move 
strategy set fair outcomes realizable part set behaviors denoted union sets strategy 
intuitively set fair outcomes produced correct implementations show proposition property property realizable nonempty 
realizable property correct implementation 
properties 
properties correct implementations 
property receptive 
receptive property includes behaviors produced correct implementations 
stark studied generalization called local consistency thesis 
special case corresponding definition considered thesis appear unpublished thesis proposal 
dill independently developed notion introduced name 
concept realizability defined included outcomes just fair ones 
eliminating unfair outcomes preventing environment game infinite number steps single move 
allowing infinite move environment prevents system step produce game correspond kind autonomous system concerned 
concept realizability similar identical fair realizability defined 
di erence concepts described 
discussion definitions 
set general property contain behavior contain behavior stuttering equivalent 
strategy chooses specific agents set 
definitions insure preserves invariance stuttering abstractness 
acm transactions programming languages systems vol january 
composing specifications proposition 
agent set property property 
proofs results appear appendix 
definition strategies allows depend presence absence stuttering 
words strategy di erent stuttering equivalent prefixes contradict assertion stuttering equivalent behaviors indistinguishable 
think stuttering step representing externally unobservable step object system certainly able detect stuttering actions performed environment 
define invariant stuttering implies finite behavior prefixes natural add definition strategy requirement invariant stuttering 
proposition shows restrict strategies add requirement strategies total functions 
proposition 
agent set property subset consisting union sets contained total strategy invariant stuttering 
behavior stuttering equivalent behavior 
define closure stuttering equivalence 
closure necessary conditions totality invariance stuttering dropped definition 
convenient allow arbitrary strategies definition 
restrict strategies invariant stuttering requiring strategies invariant stuttering definition fair realizability materially change definitions 
result stark unpublished thesis proposal suggests restriction change definition realizability example shows alter definition 
property consisting behaviors containing infinitely steps 
definitions equals realizable part 
definition fairly realizable part consist behaviors containing infinitely steps 
example demonstrates conjecture broy false 
system stuttering steps represent ones system changes internal state allowing strategy depend stuttering steps equivalent allowing strategy depend system internal state 
precisely suppose state includes variable property depend 
adding requirement strategy invariant stuttering change definition 
proved showing strategy invariant stuttering modify obtain equivalent strategy invariant stuttering takes step changes extra variable takes stuttering step 
allowing strategy depend stuttering steps obviate need rely internal state definitions 
acm transactions programming languages systems vol january 
martn abadi leslie lamport basic propositions 
state results realizability 
asserts monotonic 
proposition 
properties agent set 
proposition asserts realizable part property receptive 
proposition 
property agent set 
result provides useful representation realizable part property 
proposition 
property agent set result indicates constrains essentially safety properties 
proposition 
nonempty safety property agent set property constrains receptive 
proposition asserts realizable part property receptive 
proposition implies nonempty safety property constrains result generalizes case safety property 
proposition 
agent set realizable property constrains general realizable part property expressible terms simpler operations properties 
proposition describes simple case equals true true equal proposition generalizes part proposition 
proposition 
agent set state predicate safety property constrains safety property constrains equals 
form specification composition principle applies specifications form safety property 
section explain specifications written way 
considering general specifications examine particular class specifications programs 
program specification su ciently detailed system satisfies generated automatically 
typically system satisfying specification generated compiling program executing resulting code computer 
form complete program start considering complete programs 
formal models complete programs environment actions system actions 
input occurs initial values variables executing nondeterministic input statement program 
input statement nondeterministic program text execution program point determine input value 
acm transactions programming languages systems vol january 
composing specifications complete program specification agent system agent 
want specification matter agents perform steps behavior ignore agents consider behavior sequence states 
parts complete program 
complete program defined things set states 
state provides instantaneous picture execution status program 
determined things values variables loci control processes messages transit details depending programming language 
initial predicate 
initial predicate state predicate specifies set valid starting states program 
recall predicate set states interpreted property consisting behaviors starting state state relation 
state relation set pairs states describes state transitions allowed program executing step program starting state produce new state described explicitly program text assumptions actions considered atomic 
state relation determines property ta defined ta 
words ta set behaviors step allowed state relation progress property 
state relation specifies state changes may occur require state changes occur 
progress property specifies occur 
common type progress property asserting state change allowed state relation state change occur 
formally program property ta note ta ta safety properties 
assertional methods reasoning concurrent programs description program terms set states initial predicate state relation 
methods familiar need discuss parts program 
progress properties understood merit consideration 
progress property 
assertional methods deal liveness properties need way specifying program progress property 
requirement program executable practice constrains type progress property allowed 
initial state computer instructions executed program derived program code specifies state relation 
progress property constrain eventual scheduling instructions instructions executed 
program executable practice state transitions may perform determined initial state state relation constrained progress property 
example consider simple state relation pictured program state consists value single variable assume acm transactions programming languages systems vol january 
martn abadi leslie lamport fig 

simple state relation 
initial predicate asserts equals 
property asserting holds time execution usually written liveness property 
program satisfy property state transition allowed state relation 
program progress property compiler deduce transition permitted state relation occur 
condition progress property constrain initial state state relation expressed formally conditions equivalent 
finite behavior prefix ta exists behavior ta prefix 
ta ta safety property ta ta condition asserts safety properties satisfied program completely determined initial predicate state relation words progress property add safety properties 
define pair properties machine closed 
term machine closed introduced 
machine closure means imply safety properties implied progress property expect pair ta ta machine closed 
condition satisfied informally write progress property program machine closed 
knowledge progress assumptions proposed programs machine closed 
program progress property usually called fairness condition 
attempts give general definition fairness 
manna pnueli define class fairness properties independent state relation provide justification terminology 
apt francez katz discuss fairness criteria machine closure call feasibility 
progress properties proposed stated fairness conditions program actions example condition certain state acm transactions programming languages systems vol january 
composing specifications transitions enabled forever occurring 
progress properties generally considered fairness properties 
particular property asserting entire program stops step executed machine closed multiprocess programs satisfying progress assumption generally called unfair 
believe machine closure provides proper definition progress property distinction fairness properties progress properties probably language dependent fundamental 
form partial program partial program part larger program 
may single process csp program single assignment statement pascal program 
possible implement partial program independently rest program constitutes environment 
implementation ine cient example assignment statement pascal program compiled independently knowing types variables possible 
actions may taken partial program rest program constitutes partial program environment 
parts partial program 
modifications parts define program needed handle partial programs 
set states 
complete state determined text partial program 
example way knowing variables introduced parts complete program 
ways define set states partial program 
set states defined complete program 
complete program known known meaning partial program depends fixed unknown set states 
includes possible program variables state components 
meaning partial program defined terms known set states large set states accommodate possible complete programs 
approaches lead equivalent formalisms 
find assumption convenient take unknown set states larger program 
partial program modifies components state explicitly mentioned environment modify part state 
agent set 
agents distinguish actions performed partial program ones performed environment 
program steps taken agents environment steps agents don care agents take steps su ces distinguish steps steps 
initial predicate 
realization game environment chooses initial state 
initial condition part environment specification disappears program 
state relation 
state relation constrains state transitions performed program ones performed environment 
describes property ta defined ta implies 
state acm transactions programming languages systems vol january 
martn abadi leslie lamport relation defined way part state explicitly mentioned left unchanged 
leaves question appropriate modification condition progress properties 
recall machine closure derived requirement complete program implementable practice 
ignoring initial predicate machine closure asserts finite execution satisfying state relation completed execution satisfying state relation progress property 
similarly require partial program implementable practice additional requirement implementable knowing environment 
words implementation regardless environment 
require finite behavior prefix program actions satisfy state relation strategy program play point win produce behavior satisfying state relation progress property 
formal expression condition statement proposition ta substituted statement useful variant reformulation terms topology 
proposition 
agent set safety property arbitrary property conditions equivalent finite behavior exist strategy behavior prefix 
finite behavior exist strategy behavior stuttering equivalent prefix 
pair machine closed receptive 
define pair properties machine realizable receptive 
generalization partial programs condition progress property pair ta ta machine realizable program state relation 
case say informally machine realizable 
illustrate di erence progress properties partial complete programs la property asserting program action infinitely enabled action occur infinitely 
formally subset state relation define enabled state exists state define la property la enabled state finitely values infinitely values property la usual strong fairness requirement action strong fairness reasonable progress property complete program machine closed 
suppose la progress property partial program 
playing realization game environment play infinitely moves adds states enabled followed enabled 
environment moves legal partial program safety property ta allows steps environment 
program chance take step gets play move acm transactions programming languages systems vol january 
composing specifications enabled 
resulting outcome satisfy property la la machine realizable progress property 
fact realizable 
losing outcome corresponds physical situation environment changes state fast stays enabled long program react time perform action 
obtain machine realizable progress property state relation asserting disabled 
formally enabled enabled property ta asserts environment disables progress property ta la machine realizable 
realization game environment loses disables doing ensures ta false making ta la true 
program win game step gets move enabled 
hiding internal state 
important concept introduced considering partial programs hiding 
variables state components local partial program hidden meaning modified program conflict similarly named components environment 
approach hiding ected existential quantification state components 
existential quantification 
existential quantification defined formally follows 
denote set values denote projection functions respectively abbreviation extend mapping behaviors behaviors letting behavior property define property exists behavior 
intuitively set states externally observable component component internal program 
property obtained hiding component 
notation hiding operator obeys logical rules existential quantification properties expressed formulas appropriate logic 
usual binds weakly operators 
hiding existential quantification 
state relation program progress property 
internal state component set pairs elements words subset property 
formally program property ta property asserting component state correct initial value changed environment 
correct initial value state component specified initial predicate 
remember initial value component described environment specification 
assertion environment leaves component unchanged ta ux ux state relation consisting pairs program property ta ux ta want program machine realizable natural ask acm transactions programming languages systems vol january 
martn abadi leslie lamport conditions specification machine realizable 
machine realizability defined pair properties program safety property complete specification case equals 
expect safety property ta ux ta safety property turns safety property ordinary specifications written reasonable way meaning state relation internal state component encode progress properties 
precise condition safety property see proposition 
su cient condition machine realizable result 
proposition 
agent set projection function predicate state relation property 
equal equal 
assume exists 
pair ta ta ta ux machine realizable 
safety property 
machine realizable 
proposition remains valid hypothesis ta replaced ta ux ta equals ux ta proposition 
normal form specification specification system written property form asserting system guarantees property assumption environment satisfies property transition axiom approach written partial programs state relations progress properties 
environment move realization game initial predicate included program initial predicate internal hidden state 
intuitively assuming system control initial values internal state externally visible state 
write specification canonical form es el ms ml initial predicate es safety property constraining ms safety property constraining system property written executable program expect pair ms ms ml machine realizable 
program meant specify system allowed 
requiring program executable practice capable transformed executable code real compiler restrictive leading overly complex overly restrictive specifications 
clear requiring program executable principle machine realizable restrictive 
ms ms ml allows behaviors achieved practice 
specifications seen machine realizable 
allowing unachievable acm transactions programming languages systems vol january 
composing specifications behaviors causes harm long specification realizable 
allowing unachievable behaviors may yield simpler specification 
example simplicity specification serializable database results machine closed machine realizable 
little experience writing specifications know example anomaly arise 
assume machine realizability pair ms ms ml 
situation di erent environment property progress assumptions environment unusual 
specification usually requires system eventually environment taken action seldom assume environment take action 
el generally identically true pair es es machine realizable es constrains transition axiom specification es form ta constrain specification include nontrivial progress assumption el environment believe may reasonable require pair es es el machine realizable 
intent specification system win realization game making true making false 
machine realizability condition means long environment maintains es ensure es el true system win forcing false 
specification es es el machine realizable incorrect sense capture intent author 
environment assumption machine realizable need environment progress assumption property el incorporated system progress property 
stated formally theorem 
theorem 
state predicate es es el machine realizable ms safety property ml property es el ms ml es ms el ml 
programs describing system environment may contain hidden internal state components case specification involves existential quantification 
consider theorem applied presence quantification 
environment specifications tend simple suspect variables internal environment usually confined es allowing written es el theorem applied 
case approach eliminate existential quantification laws ordinary predicate logic imply free equivalent turn valid valid 
similar reasoning quantification state components allows replace require implementation 
implementation discussed section existential quantification system description handled generalization theorem predicate el identified acm transactions programming languages systems vol january 
martn abadi leslie lamport predicate el 
corollary agent set projection function predicate es es el machine realizable pair properties ms ml sx properties ms safety property 
es el ms ml es ms el ml 
overly normal form theorem permits take specification form move environment progress property right implication 
write specification form place 
answer don need left hand side implication 
propositions imply realizable part realizable property written ms ml ms safety property constrains 
just take ms ml fact choose pair ms ms ml machine realizable 
machine realizability follows propositions 
go finding representation realizable part property 
shown safety property constrains written form ta ux ta initial predicate satisfying hypothesis proposition state relation 
result simple generalization proposition 
realizable part property written form ms ml ms form ta ux ta pair ms ms ml machine realizable 
ability write specification form imply need write explicit assumption environment 
write specification form simply write 
answer separating environment assumption guarantee allows take advantage composition principle 
answer lies practical matter specification looks 
eliminate explicit environment assumption assumption appears implicitly property describing system 
describing behavior system environment behaves correctly allow arbitrary behavior environment behaves incorrectly 
eliminating complicated practical alternative writing specifications form useful specification understandable 
theorems assert existence specification certain form practical interest prove specification exists understandable 
hand result theorem provides simple way rewrite acm transactions programming languages systems vol january 
composing specifications gamma inp mid gamma mid composition gamma gamma inp mid fig 

composition systems 
existing specification practical interest rewritten specification understandable original impractical general write explicit environment assumption practical safety property 
case proposition shows equivalent system guarantee fact precisely form specification develop composition principles safety properties 

composing specifications main result formal statement composition principle stated informally 
stating result explain specifications composed means specification implement 
convenience restrict attention composition systems 
generalization arbitrary number systems straightforward described statement main theorem 
composition specifications consider systems pi pi composition shown schematically 
wires inp mid denote state components systems agent sets 
specifications systems specification composition 
property consisting histories universe behaviors component functions correctly 
history universe components function correctly specification composition systems simply simple semantics composition intersection rests basic assumptions discussed pi pi refer states disjoint 
assumptions states 
composing systems pi pi combined wires labeled mid single wire 
specifications written logical formulas state component variable mid appears formulas considered represent state component 
situations names identify state components systems natural example systems assignment statements mid inp mid situations may connection names specifications renaming necessary 
example systems circuits pi wire labeled mid labeled acm transactions programming languages systems vol january 
martn abadi leslie lamport pi wire labeled mid labeled inp 
case specification composite system mid inp mid mid obtained substituting mid formula kind renaming allows single operator composing properties having multitude di erent composition operators 
example programming language statements combined parallel composition sequential composition 
simple intersection specifications provides parallel composition sequential composition obtained renaming components control states way control statement intersection resulting specifications 
proper choice state component names write composition intersection properties set states looking systems separately expect state component pi inp state component pi specifications modified set states 
done expanding state include component modifying prohibit agents changing allowing agents change freely making analogous change 
simplicity representing forms composition intersection somewhat illusory 
need renaming state expansion 
adopting approach mentioned section having single universal set states state expansion avoided expense additional renaming 
want state components composed system hidden example component mid 
requires existential quantification described section 
feel ability reduce composition understood operation intersection corresponding logical view conjunction significant benefit approach 
assumptions agents 
drawing subtle assumption agent sets suppose want compose copies pi renaming inp state components copies identified inp wires connected mid state components 
discussion far lead write resulting specification obviously wrong equals simple intersection renaming yields specification system pi composition separate copies pi property specifies means particular agent set perform correctly 
making separate copy means replacing di erent agent set 
denote property obtained substituting formula describing property specifies system agent sets behave agent set specification words system separate copy original system drawing separate nonoverlapping boxes pi pi tacitly assumed agent sets disjoint 
seen extreme case equals intersection represent expected composition separate systems empty set agents 
acm transactions programming languages systems vol january 
composing specifications implementing specification definition 
system specification describes set behaviors system considered behave correctly 
system specified satisfy specification behavior allows system specified satisfies specification eliminating phrase system specified say specification implements su cient condition stronger strictly necessary implement view prescription building implementation say implements real system built specification satisfies necessary behavior just behavior generated real implementation set behaviors generated real implementation included realizable part define implements mean expect implements transitive meaning implements implements implements proving transitivity requires showing imply implication valid propositions implies 
return composition systems 
specifications systems agent sets respectively 
real implementation satisfies satisfy combining implementation implementation produces system set behaviors contained 
prove composition system specified specified implements specification su ces prove holds proposition allows infer stronger result 
proposition 
disjoint pair agent sets properties property receptive 
proposition implies 
turn implies condition weaker prove show implements hypothesis disjoint necessary proposition 
particular hold intersection receptive properties necessarily receptive 
proving specification implements 
comment briefly prove practice specification form implements specification form receptive equal realizable part deriving explicit formula di cult 
easy written place 
apply general theorem theorem section prove implements prove specification environment assumption environment assumption system specified satisfy specification assuming environment satisfies equal acm transactions programming languages systems vol january 
martn abadi leslie lamport weaker implies implementation satisfies satisfies su ces prove 
elementary set theory equivalent consists behaviors system behaves correctly face arbitrary environment behavior consists behaviors environment system behave correctly 
transition axiom approach partial program describing environment partial program describing system defines complete program obtained composing partial programs 
similarly describes complete program 
proving requires proving complete program implements 
proving program implements problem addressed extensively earlier 
basic transition axiom approach described formal basis completeness result 
briefly sketch approach 
specification written form ta ne ta nm initial predicate ne nm state relations describing environment system actions respectively progress property set states 
consists system internal state components observed section environment internal variables visible 
write logical formula state variables ne nm relations old new state values formula temporal logic 
similarly written form ta ta set internal states ne essentially relations depending externally visible state including environment internal state components 
prove implements construct refinement mapping satisfies conditions 
preserves component 
words 
practice set states defined collection state components 

denote components defining element tuple 

xn 
denote similar components defining specify refinement mapping define functions 
fn 
fn 
described formulas having components free variables 
example formula denotes function 
takes initial states initial states 
formal condition explain condition means practice definition 
formula free variables 

xn define formula obtained substituting equivalence pointed amir pnueli 
acm transactions programming languages systems vol january 
composing specifications 
defines formula free variables 

semantic condition expressed logical framework formula implementation 
cases condition easy check 
maps steps nm steps stuttering steps 
formally require state reachable state sequence steps implies nm 
practice verifying condition involves finding sy predicate left invariant meaning imply proves old nm old formula asserting true state step identity relation 
finding invariant proving invariance exactly proof owicki gries method method proving condition generalizes standard method proving invariance properties concurrent programs 
maps behaviors satisfy ta ta behaviors satisfy formal condition ta ta translated logical framework formula verified ta ta 
formula asserts program described ta ta satisfies property generally liveness property 
verification condition tantamount proving program satisfies liveness property done method expressed temporal logic formulas 
condition weaker ways corresponding condition definition refinement mapping 
condition applies steps condition applies steps 
weaker condition su cient steps taken environment essentially 
formalism include agents distinction system environment steps 
second condition applies steps taken reachable state applies steps taken state 
weaker condition needed history variables eliminate unreachable states 
theorem asserts existence refinement mapping certain reasonable assumptions specifications providing completeness theorem proof method 
general obtaining refinement mapping may require adding auxiliary variables lower level specification history variable record past actions variable predict ones 
limited experience indicates variables needed condition history variables seldom needed 
experience method verifying concurrent systems limited reason believe mappings constructed practice refinement mappings essentially abstraction functions kind years prove data type implements 
acm transactions programming languages systems vol january 
martn abadi leslie lamport main theorem precise statement composition principle 
having discussed composition implementation come problem proving composition specifications implements specification observed section prove attempt prove refinement mapping method section 
expect construct realizable part specification prove stronger result implements form form refinement mapping method proves specification form implements form 
simple refinement mapping won need composition principle 
restate composition principle case terms formal definitions 
principle premises system pi composition systems pi pi specification pi specification pi indicated safety properties 
needed additional assumptions natural consequences method writing specifications assumptions disregard add hypotheses theorem discuss 
hypotheses principle consist conditions pi guarantees component pi guarantees formally condition asserts satisfied automatically simplify composition principle eliminating letting assert pi satisfies show pi satisfies specification proves implements refinement mapping method described section 
environment assumption component pi satisfied environment pi satisfies pi satisfies condition asserts assertions combined 
component pi guarantees environment assumption condition simply asserts component pi satisfies specification composition principle asserts pi satisfies specification 
remember replaced principle formulated terms specifications systems condition disappears states composition components specifications implements system specification 
composition principle proof rule unfortunately rule valid 
obtain valid rule replace hypothesis stronger 
rule appears unreasonably circular allows assume proving environment assumption necessary component pi acm transactions programming languages systems vol january 
composing specifications guarantee suggests strengthen hypothesis disallowing proving obtaining rule rule valid 
wrong attribute invalidity simple circularity 
rule circular incorrect additional assumptions ignoring 
example suppose take safety property hypotheses reduce tautology identically true specification satisfied system 
rule yield composition systems satisfies specification valid despite circularity stronger valid rule looks just circular 
way strengthen suggested closer examination hypotheses 
hypothesis asserts imply property assumed safety property safety property implied implied expect imply 
similarly imply 
proposition shows inference rules valid certain natural assumptions 
replace closures hypotheses 

hypothesis assume proving words rule valid hypothesis replace assume proving assumption necessary pi guarantee state precise results 
hypotheses proposition theorem discussed 
proposition asserts rule second rule obtained obvious substitutions 
theorem strengthened proof rule replacing realizable part 
proposition 
agent sets properties state predicate 
safety property constrains 
safety property 
property 
rule inference sound 
acm transactions programming languages systems vol january 
martn abadi leslie lamport theorem 
agent sets properties state predicates 
safety properties constrain respectively 
constrain respectively 
rule inference sound 
theorem handles composition systems 
obvious generalization composition systems 

mn 
en 
en mn 
mn rule derived theorem proposition 
hypotheses theorem proposition 
discuss theorem numbered hypotheses imply hypotheses proposition proposition fourth hypothesis 
hard show safety property written state predicate safety property constrains set agents 
specifies environment system agent set equal hypothesis satisfied environment assumptions safety properties 
theorem allows rewrite specification environment assumption safety property 
observe system implemented components agent sets agent set 
higher level specification ultimately trying verify may written terms agent set case perform renaming operation substituting applying theorem 
transition axiom approach form ta ux ta expect equal ta ux ta case hypothesis satisfied 
mentioned section hypothesis means components distinct 
need distinct current level abstraction implementations contain common parts 
example components specify distinct program procedures implementations invoke common subprocedure 
consider subprocedure acm transactions programming languages systems vol january 
composing specifications executed di erent agents depending procedure invoked 
alternatively generalize notion implementation allow renaming agents 
practice hypothesis petty nuisance formalism real concern 
write directly program sort logical formula individual agents mentioned 
agents symbol automatically 
hypotheses proof rule 
show verifies hypothesis theorem proof rule systems pi pi generic example 
wires inp mid associated protocol systems ends expected obey 
wire initial condition wire property asserting agent set correctly executes protocol system left side wire corresponding property right side wire 
example suppose state component mid consists register booleans rdy ack popular hardware protocol pass values sender left receiver right 
initially values rdy ack equal 
send loop receive loop await rdy ack await rdy ack write read rdy rdy ack ack loop loop send receive state relations sender receiver programs 
protocol mid initial predicate rdy ack property mid equals ta send mid equals ta receive 
data properly transferred pi pi mid behavior satisfying property mid mid mid assume particular protocols inp mid ignore liveness properties protocols require properties appear environment assumptions 
assume safety properties wire addition specifying mechanism values sent wire protocol properties specify values sent 
reasonable suppose protocol properties include assumptions system environment 
system environment assumption asserts environment obeys side protocol wire system environment communicate 
initial conditions wires part environment assumption environment responsible initial values externally visible components 
composition get environment assumptions 
inp inp mid mid mid mid inp inp mid ta mid acm transactions programming languages systems vol january 
martn abadi leslie lamport included assumption composite system environment ect mid prove hypothesis theorem knowing pi pi wires 
assumptions justifications listed 

wire agent sets ta uw ta uw property asserts agents obey left side protocol wire actions ect wire protocol 
agents obey protocol agents ect agents obey protocol 
part derived formally assumptions equals property obtained substituting ii constrains iii depends component state 
part similar justification 

ta ta inp assumes pi ect pi ect inp 
formally assumptions ta ta inp imply ta ta inp safety properties 

mid mid composite system properly pi pi cooperate guarantee protocol condition mid mid satisfied 
subset mid mid mid mid safety property expect contain contains expectation logical necessity 
deduce mid mid proof rule valid 
assumptions verify hypothesis theorem proof rule 
prove subset proving subset similar 
conjunction properties inclusions verify 

inp proof definition implies subset inp 
inp proof proved sequence steps 

ta inp proof 

inp proof definition 
inp proof substituting hypothesis disjoint implies 
mid proof definition 
mid acm transactions programming languages systems vol january 
composing specifications 
mid proof 

ta mid proof definition 
mid proof substituting disjointness completes justification hypothesis composition 
assumptions derived assumptions pi pi supposed 
example quite general mid represents state components involved communication pi pi inp represent state components pi pi interact rest environments 
real assumption implicit composite system environment modify state component accessed pi pi removing assumption means communication mid involves party protocol requiring additional property mid satisfied third party 
represented pictorially adding third wire mid connected 
correct transfer data wire mid requires mid mid mid hold 
argument modified handle general case 

concluding remarks approached problem composing specifications purely semantic point view 
formal specification method language logic semantics 
theorem appear proof rule logic 
touched lightly logical issues discussion mentioning form logical formulas take 
concluding remarks language logic order 
semantic form specifications suggests general style specification language 
safety properties expressed describing state relation progress properties expressed directly form temporal logic fairness conditions translated temporal logic 
obvious desiderata specification language expressive readable concise precise attributes specification logic 
clearly want sets behaviors expressed properties meaning closed stuttering equivalence 
simple attribute logic explicitness meaning behavior satisfies formula depends values assumed behavior state components free variables explicitness necessary existential quantification expected meaning poses surprisingly serious constraint specifications written 
example consider formula specifies assignment statement 
formula assert executing assignment statement change explicitness requires variable changed free variables practical language allow write formula free variable appear text 
acm transactions programming languages systems vol january 
martn abadi leslie lamport closure stuttering equivalence explicitness may esoteric readers accustomed popular simple semantics programs 
typical semantics formula specifying program satisfied behaviors step corresponds execution program action example natural way write semantics time temporal operator 
composition conjunction semantics 
example consider completely programs separate sets variables described formulas behavior composition obtained interleaving actions programs 
interleaved behavior satisfy contains steps represent actions program satisfy composition programs described formula closure stuttering equivalence explicitness needed composition conjunction trivial case programs 
styles specification proposed ranging axioms specific logic programs specific language 
styles adapted semantics results 
specification styles usually particular semantic theory underlying theory modified 
specify properties csp programs traditional failure set semantics csp revisited 
investigating transition axiom method temporal logic actions 
appendix proofs appendix contains proofs propositions theorems stated 
included lemmas proofs mentioned main text 
proofs carried level detail hierarchical style explained 
reader may feel long tedious proofs obvious assertions 
seen equally obvious assertions discovered wrong trying write similarly long tedious proofs 
believe strongly reasoning carried level detail avoid mistakes 
detailed proofs little confidence correctness results 
proofs employ definitions notations 
functions total defining equal domain finite behavior prefix agent state behavior prefix obtained concatenating 
length finite behavior prefix denoted defined 
sm extend definition previously defined behavior obvious way finite behavior prefix 
prefix length consisting single state 
finite behavior prefix state defined equal agent defined equal 
mapping behavior prefixes behavior prefixes monotone behavior prefixes prefix prefix 
observe monotone limm exists behavior 
strategy finite behavior prefix said acm transactions programming languages systems vol january 
composing specifications ii iii 
note behavior outcome finite prefix ends strategy finite behavior prefix said partial outcome prefix including ends proofs written hierarchical style 
structured proof consists preamble followed sequence statements proof 
proof uses case split separate proof case 
preamble describes assumptions desired implies result proved 
may contain informal description proof 
proof statement statements assert preamble desired indicated boxed statement numbers 
preamble omitted assumptions obvious 
su ciently simple proof structured written customary paragraph style 
proof statements serve definitions require proof 
lemma 
agent set strategy ii iii exists strategy iv behavior stuttering equivalent behavior 
proof lemma assume agent set strategy construct required define tries produce possible tries act means switch trying produce acting environment causes behavior diverge formal definition driven need switch smoothly 
define mapping behavior prefixes maps prefixes prefixes stuttering equivalent behavior prefix 
define equal prefix 
finite behavior prefix define finite behavior prefix inductively follows 
prefix smallest prefix stuttering equivalent 
finite behavior prefix prefix ak sk smallest natural number prefix proof simple induction 
behavior define follows 
limm behavior 
proof behavior implies limm exists infinite 

behavior proof result follows hypothesis 
imply ak sk ak sk prefix 
result follows implies 
finite behavior prefix define follows 
ak ak sk acm transactions programming languages systems vol january 
martn abadi leslie lamport prefix strategy 
proof follows hypothesis strategy 

proof follows definition outcome fair outcome ak implies finitely actions undefined infinitely prefixes 
fair outcome fair outcome proof fair outcome hypothesis 
assume fair outcome prove fair outcome 
choose largest natural number equal 
ak sk ak sk ii proof existence follows hypothesis case follows induction 
case ii follows step 


proof 

finite prefix ends proof natural number 
show ends proof split cases 
case 
case 
prefix equals definition turn prefix 
ends assumption 
case 
result trivial sequence length ends assume implies implies 
am result trivial 
su ces prove am intuitively holds environment behavior diverge formally assume am prove contradicts definition 

am ak proof assumption 
ak sk proof assumptions am outcome 
ak sk proof definition prefix implies defined 

proof 
case 

ak sk proof applying twice substituting 

proof substituted hypothesis implies 

ends acm transactions programming languages systems vol january 
composing specifications proof hypothesis outcome 
fair outcome proof outcome show fair 
infinitely actions 
undefined infinitely prefixes undefined infinitely prefixes fair assumed fair outcome 
behavior stuttering equivalent behavior 
proof 
proof lemma lemma 
agent set strategy ii iii equivalent exists strategy iv behavior equivalent behavior 
proof lemma proof identical lemma replaced equivalence 
definition step prefix prefix length proof bit simpler equals step 
omit details 
proof lemma proposition 
agent set property property 
proof proposition part proposition property property follows immediately lemma definitions 
second part follows lemma 
proof proposition lemma 
agent set strategy ii exists behavior total strategy invariant stuttering iii iv behavior stuttering equivalent behavior 
proof lemma assume strategy construct required directly technical reasons construct new behavior step adding infinite number stuttering steps lemma obtain strategy produces 
behavior obtained step replacing stuttering steps stuttering steps 
construct step tries produce failing simulate total define stutter undefined 
requires interpret stuttering steps produced way stuttering steps interpretation performed mapping defined step 
behavior prefix obtained replacing stuttering steps stuttering steps lead prefix stuttering steps produced undefined 
invariant stuttering define terms mapping obtained removing stuttering steps applying 

choose behavior contains infinitely stuttering steps choose strategy behavior stuttering equivalent behavior 
acm transactions programming languages systems vol january 
martn abadi leslie lamport proof existence follows assumption agent set nonempty 
existence follows lemma 
choose agents proof agent set nonempty 

finite behavior prefix define follows 
sk sk ak behavior define equal limm 
proof mapping monotone finite behavior prefixes limit exists 

behavior prefix 

proof definition follows definition induction length finite behavior prefix 
equals limm implies behavior 
finite behavior prefix define follows 
sk sk ak total strategy invariant stuttering 
proof strategy follows strategy 
definitions step imply invariant stuttering 
definition total function 

behavior 
proof assume prove 
simpler prove stuttering steps 
prove step observe proof equals 
proof intricate exercise verifying definitions properly 

behavior prefix 
proof assume finite 
simple induction shows length preserving 
definition implies 
case infinite follows finite case limits 

finite behavior prefix equal 
am sm sm sm sm sm am ii holds 
proof assume prove 

finite ii proof 

am sm 
proof implies 

acm transactions programming languages systems vol january 
composing specifications proof definition implies 
sm sm case ii sm sm iii am proof assume iii iv sm sm obtain contradiction 
equal equals sm iv 
applying substituted infer assumption yields am iii contradicts assumption 
sm sm 
proof assume sm sm ii obtain contradiction 
equals 
definition see ii hypothesis imply contradicts hypothesis equals 
finite behavior prefix ends ends proof assume ends prove ends trivial su ces assume prove 
equal 

proof hypothesis ends 
proof 

proof assume obtain contradiction 
substituting shows sm 
imply sm sm 
substituting infer shows imply required contradiction 


proof 

am infinitely values 
proof part follows hypothesis total function 
implies behavior 
invariant stuttering outcome behavior fair outcome implies contains infinitely actions 

outcome proof definition implies prefix monotonicity prefix equals finite prefix result follows 

proof denote su ces prove am infinitely values may assume 

natural number proof asserts limm 

choose prefix 
proof existence follows hypothesis 
acm transactions programming languages systems vol january 
martn abadi leslie lamport 
am am 
proof substituting yields 




am 
implies prefix 
am 
implies am 
am implies am 
result follows implies 

am infinitely values proof preserves actions 
am infinitely values proof am bm holds infinitely values am holds infinitely values bm holds infinitely values 
proof definition idempotence 
behavior exists behavior proof implies 
exists behavior 

transitivity yields 

exists behavior 
proof construct replacing stuttering steps stuttering steps 
proof outcome matter checking definitions fairness follow having chosen infinitely stuttering steps 

define follows 
sk sk ak sk sk ak ak ak 

proof definition stuttering steps 


proof proof induction result obvious 
assume true prove 
consider cases case 
ak ak 
ak ak sk sk 
proof definition assumption ak ak 

sk sk 
proof definition sm sm 
proof induction hypothesis definition 
case 
ak ak assume obtain contradiction 

ak 
proof induction hypothesis implies sk sk acm transactions programming languages systems vol january 
composing specifications assumption definition 

ak 
proof hypothesis ak ak induction hypothesis 
contradiction 
proof hypothesis outcome 

proof definition 

proof definition imply 
step asserts 
follows transitivity 

proof contains infinite number stuttering steps definition implies am infinitely values show su ces assume am prove am sm 
consider cases 
case 
am am 
am sm sm am proof definition 

am sm 
proof implies sm sm sm sm definition case 
am am 
am sm proof am assumed outcome 
proof definition am hypothesis 

am sm proof assumption am am 
proof lemma proposition 
agent set property subset consisting union sets contained total strategy invariant stuttering 
behavior behavior 
proof proposition immediate consequence lemma 
proof proposition proposition 
properties agent set 
proof proposition assume prove 

choose strategy proof existence follows definition 

proof hypothesis 
proof definition 
proof proposition acm transactions programming languages systems vol january 
martn abadi leslie lamport proposition 
property agent set 
proof proposition assume property agent set prove 
set consists outcomes winning strategies system trying produce outcome strategy winning strategy system trying produce outcome equal 
formal proof follows 

proof proposition 
proof assume prove 

choose strategy proof exists definition 

proof definition 

proof definition 
proof proposition proposition 
property agent set proof proposition 
proof included definition closure definition 

proof assume prove 
definition su ces prove exists strategy construct choose sequence behaviors having limit strategies produce define tries produce 
acting su ciently large longer produce continues act 
choose behavior prefix proof exist definition closure 
choose strategy prefix fair outcome proof exist strategies 

define strategy follows 
smallest integer proof strategy 

proof am am sm 
outcome furthermore implies undefined am fair 

proof assume 
smallest integer show 
acm transactions programming languages systems vol january 
composing specifications 

proof definition result follows definition 

outcome proof show 
split proof cases 
case 

proof hypothesis definition 
proof hypotheses outcome 
prefix proof hypothesis 
proof assumption imply result follows asserts partial outcome 
proof 
case 
hypotheses imply 

fair outcome proof asserts outcome fairness follows assumption fair outcome 
proof assume prove immediate hypothesis 
follows 
proof proposition proposition 
nonempty safety property agent set property constrains 
proof proposition assume nonempty safety property agent set 
definition su ces prove constrains 
constrains 
proof assume behavior construct strategy define tries produce outcome longer possible 
safety property doing violate 
finite behavior prefix define am am sm strategy 
proof obviously strategy 

proof immediate definition outcome fair outcome am implies 

acm transactions programming languages systems vol january 
martn abadi leslie lamport proof assume arbitrary behavior derive contradiction 

smallest integer proof exists safety property hypothesis 
am proof hypothesis constrains 
am sm proof hypothesis outcome 
am sm am sm proof definition 

proof definition implies domain prefix 

proof 

proof hypotheses safety property 
contradiction 
proof 
constrains proof assume constrain prove exists behavior 
behavior environment taken step violated chose 
behavior produced winning strategy 
choose ii am proof exists assumption constrain 

proof assume prove 
proof involves showing initial state system loses winning strategy 

behavior proof hypothesis imply implies implies safety property 

state strategy exists behavior proof state agent define inductively letting domain 

proof imply exists strategy 

proof assume 
strategy 
prove exists behavior take outcome produced environment adds am sm 

agent behavior domain 
acm transactions programming languages systems vol january 
composing specifications 
proof prove outcome show 
follows outcome hypothesis 
follows am assumption 
follows immediately definition fairness follows definition 
proof choice definition safety property implies 
exists behavior 
proof follows 
follows hypothesis nonempty 
proof proposition proposition 
agent set realizable property constrains proof proposition 
property safety property safety property 
proof proposition conjunction safety properties safety property safety properties closed sets safety property 


proof definition 

proof monotonicity property 
proof proposition 

closed set 
proof 

proof definition smallest closed set containing 

constrains proof proposition hypothesis realizable nonempty 
proof proposition lemma 
agent set properties state predicate 
safety property constrains 
constrains behavior proof lemma proof assume prove 
acm transactions programming languages systems vol january 
martn abadi leslie lamport proof assumption hypothesis constrains definition constrains 

proof assume obtain contradiction 
construct behavior equals steps follows strategy puts stuttering steps strategy undefined 
construct changing stuttering steps stuttering steps 
violates jth step steps violate 
lead contradiction 
choose behavior ak implies sk sk 
choose strategy 
proof exists assumption definition 
choose define ak sk ak sk sk proof exists assumption agent set implies nonempty 

proof definition 

proof show outcome show ends 
follows 
follows 
outcome fair implies strategy undefined ak 
proof choice 

ak implies sk sk proof definition asserts strategy 

choose behavior ak 
choose define sk sk sk sk ak ak ak proof exists assumption agent set nonempty 

proof 

proof obtained changing agents stuttering steps 

ak proof definition 
acm transactions programming languages systems vol january 
composing specifications 

proof assumption 
proof hypotheses state predicate 
proof hypotheses constrains 
proof hypothesis 


proof assumption 
proof safety property 

proof 
proof 

proof hypothesis properties 

contradiction 
proof 

proof smallest natural number hypothesis implies consider cases 
case 

proof definition safety property 

proof assumption 
proof 
case 

proof definition assumption 

proof assumption hypothesis constrains 
proof assumption 
proof hypothesis constrains proof lemma proposition 
agent set state predicate safety property constrains safety property constrains equals acm transactions programming languages systems vol january 
martn abadi leslie lamport proof proposition 
proof assume exists behavior obtain contradiction 

smallest integer 
proof exists hypothesis definition 
proof 

proof implies safety property equals 
contradiction 
proof hypothesis lemma substituting 


proof definition 
proof proposition 

constrains proof safety property definition constrains hypothesis safety property containing constrains 
nonempty 
proof nonempty hypothesis constrains subset 
proof proposition 

proof 
proof proposition proposition 
agent set safety property arbitrary property conditions equivalent finite behavior exist strategy behavior prefix 
finite behavior exist strategy behavior stuttering equivalent prefix 
pair machine closed receptive 
proof proposition obvious implies 
prove implies implies 
assume holds prove 

proof assume prove 
definition topology su ces assume prove exists behavior 
proof closed hypothesis definition topology 

choose strategy behavior acm transactions programming languages systems vol january 
composing specifications proof substituting 

proof implies definition 
pair machine closed 
proof prove 

proof monotonicity closure 

proof hypothesis safety property 

proof 

proof property closure monotone 

proof 
receptive 
proof definition prove 

proof 

proof 

proof proposition 

proof 
assume holds prove 
finite behavior find strategy behavior prefix 

choose prefix 
proof exists machine closure hypothesis 

proof hypothesis receptive 

exists strategy proof definition 
proof proposition proposition 
agent set projection function ix predicate state relation property 
equal equal 
assume exists ix 
pair ta ta ix ta ux machine realizable 
safety property 
machine realizable 
proof proposition part proposition su ces assume finite behavior prefix ix ta ux ta construct strategy subset ix ta ux ta behavior construct choose strategy outcomes lie acm transactions programming languages systems vol january 
martn abadi leslie lamport ta ix ta ux behavior produced projection prefix 
define inverse projection behaviors behaviors image contains define composed projection 

choose ix ta ux ta 
proof existence follows hypothesis ix ta ux ta definition existential quantification 

choose 
proof exists asserts 

choose strategy ta ix ta ux partial outcome proof hypothesis definition machine realizability part proposition substituted 

choose behavior ix ta ux ta 
define inductively follows element 
proof construction partial outcome definition implies outcome 
fair outcome 

ix ta ux ta proof ta ix ta ux 
su ces prove ix ta ux means proving ix ii implies 
holds ix 
condition ii follows 
ii follows immediately definition 
choose monotone mapping behavior prefixes state space behavior prefixes state space finite behavior prefix ii ix iii ux 
iv agent state 
limm behavior 

proof define finite behavior prefix induction follows 
ix note case chosen clause exists hypothesis proposition 
take definition behaviors 
monotonicity acm transactions programming languages systems vol january 
composing specifications immediate definition limit exists 
property ii follows case definition 
properties iii iv follow definition induction 
proof induction follows immediately definition 
induction step assume prove follows definition 
follows definition ta ux 

finite behavior prefix states define equal extended mapping obvious way 
strategy implies 

finite behavior prefix 
proof definition 
strategy 
proof strategy 

finite behavior prefix ends ends proof follows 
follows iv 


proof assume 
outcome implies outcome fairness implies fair 

ix ta ux ta proof ta ix ta ux 
ii iii ix ta ux 

ix ta ux ta proof definition existential quantification su ces prove behavior exists behavior ix ta ux ta 
equal 




proof definition 


proof 
implies 
definition equals equal 
desired result follows 

proof outcome asserts fair outcome fairness follows imply defined 
proof asserts definition 
proof proposition theorem 
state predicate es es el machine realizable ms safety property ml property es el ms ml es ms el ml 
acm transactions programming languages systems vol january 
martn abadi leslie lamport proof theorem assume state predicate es es el machine realizable ms safety property ml property prove es el ms ml es ms el ml 
es ms el ml es el ms ml proof proposition es ms el ml es el ms ml propositional reasoning 

es el ms ml es ms el ml proof strategy es el ms ml prove es ms el ml 
assume prove es ms el ml 
assuming es ms el ml obtaining contradiction 
proof rests observation hypotheses imply es ms el ms safety property violate finite point possible environment satisfy el contradiction obtained playing strategy point violates ms environment strategy constructed step achieves es el producing behavior step 
technical reasons replace argument behavior total strategy obtained lemma 

choose total strategy behavior behavior stuttering equivalent behavior 
proof exist lemma 

es ms el 
es ms el ml proof definition es ms el ml hypothesis properties definition closed 

es el ms ml proof es el ms ml es el ms ml hypothesis properties closed stuttering equivalence 

es ms el proof propositional reasoning 

choose ms proof exists ms safety property hypothesis ms 

choose strategy behavior es el proof existence follows hypothesis es es el machine realizable proposition 

choose behavior proof define odd undefined 
behavior proof total 
acm transactions programming languages systems vol january 
composing specifications 
proof definition 

outcome proof prove 
holds 
holds definition asserts strategy 

proof outcome 
fair definition infinitely steps form steps strategy 

outcome proof prove 
holds definition 
holds definition asserts strategy 

proof outcome 
fair definition undefined infinitely infinite number steps form steps asserts strategy 

ms proof ms ms safety property hypothesis 

es el ms ml proof asserts implies stuttering equivalent element 
es el ms ml es el ms ml hypothesis properties closed 

es el proof state predicate hypothesis 
es el es el 

contradiction 
proof imply ms ml contradicts 
proof theorem corollary agent set projection function predicate es es el machine realizable pair properties ms ml properties ms safety property 
es el ms ml es ms el ml 
proof corollary substituting ms ms ms ml ml theorem shows es el ms ml es ms el ms ml acm transactions programming languages systems vol january 
martn abadi leslie lamport 
el depend component follows definition existential quantification simple logical deduction ms el ms ml equals ms el ml 
proof corollary proposition 
disjoint pair agent sets properties property receptive 
proof proposition definition su ces assume strategies construct strategy 
define strategy begins trying generate longer possible performs step alternating 

finite behavior prefix define follows max equals 
max ak strategy 
proof strategy strategy 

proof immediate definition outcome 
proof assume prove 
hypothesis may assume 

outcome proof su ces assume prove 
cases 
case 
case desired result follows hypothesis 
case 
outcome hypothesis implies su ces prove 
desired equality follows assumption hypothesis disjoint 

proof asserts outcome need prove fair outcome 
assume finitely steps prove undefined infinitely values 
case 
finitely 
case hypothesis implies undefined infinitely prefix undefined undefined 
undefined infinitely assumption imply undefined infinitely values case 
infinitely 

choose ii implies acm transactions programming languages systems vol january 
composing specifications max ak 
proof choose satisfying assumptions finitely steps infinitely 
choose large holds 


proof assume 
strategy infer 
definition prefix implies implies 
implies 

undefined infinitely proof undefined hypothesis infinitely proof proposition proposition 
agent sets properties state predicate 
safety property constrains 
safety property 
property 
rule inference sound 
proof proposition proof assume prove assuming existence behavior obtaining contradiction 
obtain contradiction constructing behavior construct behavior continuing point violates safety property modify replacing agents agents obtain behavior steps violate 
choose proof safety property exists safety properties safety property 
assumption implies 
choose behavior proof exists asserts definition closure 

choose behavior sk sk ak ak ak ak equivalent 
proof agents replaced agent disjoint hypothesis equivalent 
acm transactions programming languages systems vol january 
martn abadi leslie lamport 
proof implies 

proof imply state predicate hypothesis 


ak proof 

proof 
proof hypothesis asserts constrains 

proof equivalent hypothesis 

proof equals 
proof imply safety property hypothesis 
contradiction 
proof hypothesis proof proposition theorem 
agent sets properties state predicates 
safety properties constrain respectively 
constrain respectively 
rule inference sound 
proof theorem proof assume hypotheses theorem prove soundness inference rule assuming hypothesis deducing 


proof assume obtain contradiction 


choose proof assumption implies 
proof assumption definition 
acm transactions programming languages systems vol january 
composing specifications proof 

proof 

smallest natural number proof exists hypothesis implies safety property 

proof assumption hypothesis inference rule holds 

proof assumption implies safety property 

proof 

proof exists hypotheses theorem assumption allow apply lemma substituting conclude 
contradiction 
proof choice 
proof proposition proposition apply hypothesis 
proof theorem glossary ith agent behavior 
strategies section refinement mapping 
inp mid state components example 
ith state behavior 
states 
internal state components 
set agents 
environment assumption property 
es el safety liveness parts section 
state predicate 
initial condition internal state component identity state relation 
progress property 
system guarantee property 
ms ml safety liveness parts section 
state relation 
ne nm state relations environment system 
set behaviors generated strategy sets behaviors usually properties 
realizable part acm transactions programming languages systems vol january 
martn abadi leslie lamport specification 
set states 
ta property defined state relation complete program 
ta property asserting step satisfies state relation ux state relation asserting state component unchanged 
step number step behavior violates property sets internal states 
agents 
agent set agents usually agent set 
behavior prefixes usually finite 
behavior prefixes usually infinite 
behavior prefix finite infinite 
mappings behavior prefixes 
pi system formally defined concept 
projection mapping external states 
projection mapping internal states 
existential quantification state component step performed agent 
closure smallest safety property containing 
property consisting behaviors property asserting holds long 
result substituting formula 
finite behavior prefix obtained adding 
agent 
state 
length 
behavior obtained extending finite behavior prefix stuttering steps 
finite behavior prefix consisting steps 
behavior prefix obtained removing stuttering steps 
stuttering equivalence 
stuttering equivalence 
pi hoare triple 
asserts domain acknowledgments greg nelson cynthia hibbard provided useful comments original version article 
eugene stark sent thesis proposal pointed correspondence definitions ones thesis 
acm transactions programming languages systems vol january 
composing specifications abadi lamport existence refinement mappings 
theor 
comput 
science may 
abadi lamport wolper realizable unrealizable specifications reactive systems 
automata languages programming july ausiello rocca eds vol 
lecture notes computer science springer verlag pp 

alpern schneider defining liveness 
inf 
process 
lett 
oct 
apt francez katz fairness languages distributed programming 
distributed comput 

barringer kuiper pnueli really concurrent model temporal logic 
thirteenth annual acm symposium principles programming languages jan acm pp 

broy weber characterizing behaviour reactive systems trace sets 
rd workshop concurrency compositionality saint augustin germany best rozenberg eds vol 
gmd studien gmd pp 

extended 
davis infinite games perfect information 
advances game theory shapley tucker eds vol 
annals mathematics studies 
princeton university press princeton pp 

dill trace theory automatic hierarchical verification speed independent circuits 
ph 
thesis carnegie mellon university feb 
harel pnueli development reactive systems 
logics models concurrent systems apt ed vol 
nato asi series springer verlag pp 

hoare proof correctness data representations 
acta inf 

hoare communicating sequential processes 
series computer science 
prenticehall international london 
lam shankar protocol verification projections 
ieee trans 
softw 
eng 
se july 
lamport specifying concurrent program modules 
acm trans 
program 
lang 
syst 
apr 
lamport temporal logic 
information processing proceedings ifip th world congress paris sept mason ed ifip north holland pp 

lamport solved problems unsolved problems concurrency 
proceedings third annual acm symposium principles distributed computing new york aug misra ed acm pp 

invited address symposium 
lamport simple approach specifying concurrent systems 
commun 
acm jan 
lamport temporal logic actions 
research report digital equipment systems research center dec 
lamport schneider hoare logic csp 
acm trans 
program 
lang 
syst 
apr 
lynch tuttle hierarchical correctness proofs distributed algorithms 
proceedings sixth symposium principles distributed computing aug acm pp 

manna pnueli hierarchy temporal properties 
tech 
rep stan cs department computer science stanford university oct 
milner calculus communicating systems vol 
lecture notes computer science 
springer verlag new york 
misra chandy proofs networks processes 
ieee trans 
softw 
eng 
se july 
owicki gries verifying properties parallel programs axiomatic approach 
commun 
acm may 
acm transactions programming languages systems vol january 
martn abadi leslie lamport owicki lamport proving liveness properties concurrent programs 
acm trans 
program 
lang 
syst 
july 
pnueli transition global modular temporal reasoning programs 
logics models concurrent systems oct apt ed nato asi series springer verlag pp 

stark foundations theory specification distributed systems 
ph 
thesis aug 
stark proof technique rely guarantee properties 
foundations software technology theoretical computer science berlin maheshwari ed vol 
lecture notes computer science springer verlag pp 

received october revised july accepted december 
acm transactions programming languages systems vol january 
