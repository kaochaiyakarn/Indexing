suffix trees applications string algorithms roberto grossi giuseppe italiano dipartimento di sistemi informatica dipartimento di matematica ed informatica universit di firenze universit ca di venezia firenze italy venezia italy keywords pattern matching string algorithms suffix tree 
suffix tree compacted trie stores suffixes text string 
data structure intensively employed pattern matching strings trees wide range applications molecular biology data processing text editing term rewriting interpreter design information retrieval data types 
survey applications suffix trees algorithmic techniques construction 
special emphasis developments area parallel algorithms suffix tree construction generalizations suffix trees higher dimensions important multidimensional pattern matching 
partially supported esprit bra alcom ii contract italian murst project di informative 
part done author visiting bell laboratories 
email grossi di unipi supported part commission european communities esprit ltr project alcom italian murst project di progetto di informative research university venice ca 
part done university 
email italiano dsi 
url www dsi italiano 
contents suffix tree applications generalizations suffix trees sequential construction suffix tree algorithm chen 
algorithm mccreight 
extension mccreight construction set strings 
parallel construction suffix tree karp miller rosenberg naming technique 
algorithm apostolico 
algorithm vishkin 
algorithm 
lsuffix tree sequential construction lsuffix tree parallel construction lsuffix tree suffix tree powerful versatile data structure applications string algorithms 
basically compacted trie storing suffixes string possible substrings string represented unique path descending root 
power suffix tree lies mainly ability encode suffixes string linear space 
succinct encoding enables retrieve large amount information index instance diagram state transitions automaton recognizes substrings string 
importance suffix tree underlined fact rediscovered times scientific literature disguised different names studied numerous variations 
just mention appearances suffix tree cite compacted bi tree prefix tree pat tree position tree repetition finder subword tree 
ability suffix tree represent substrings linear space inspired variations 
suffix array cactus suffix array dynamic suffix array pat array sb tree examples arrays trees containing suffixes string lexicographic order obtained visiting leaves corresponding suffix tree 
directed acyclic word graph dawg minimal suffix factor automata labeled graphs automata recognizing substrings string suffixes nodes related suffix tree built reversed string 
complete inverted file compacted dawg augmented extra information nodes equivalently obtained suffix tree string merging edge isomorphic subtrees deleting part resulting structure 
known literature implicit definition suffix tree morrison patricia trees 
weiner introduce explicitly suffix tree original name compacted bi tree 
pioneering weiner linear time space constructions mccreight pratt chen algorithms reviewed 
constructions advantage line assumption input string read character time right left 
left right line linear time construction described reiser bayer 
line linear time algorithm ukkonen real time construction kosaraju 
constructions strings drawn large alphabet price logarithmic slow time complexity size alphabet 
parallel algorithm building suffix tree landau vishkin 
apostolico efficient parallel construction optimal large alphabet 
vishkin farach muthukrishnan devised parallel constructions optimal small alphabet 
statistical behavior suffix trees studied general mild probabilistic frameworks apostolico szpankowski blumer devroye grassberger jacquet szpankowski shields szpankowski 
main properties suffix tree asymptotic expected depth logarithmic length string may linear worst case 
connor snider related complexity measure random strings cryptology called maximum order complexity statistical properties suffix trees 
notion suffix tree extended square matrices gonnet giancarlo giancarlo grossi 
data structure efficiently deployed pattern matching algorithms higher dimensions area gaining growing interest due applications low level image processing image compression visual databases multimedia systems 
problem building tree data structure representing submatrices matrix shown computationally harder problem building tree data structure representing square submatrices considered 
somewhat relaxed definition suffix tree labeled trees storing node root paths tree strings compacted trie introduced kosaraju tree pattern matching purposes 
interesting generalization suffix tree parameterized strings strings introduced baker find program fragments software system identical systematic change parameters 
suffix trees find wide variety applications different areas related string processing string matching approximate string matching finding longest repeated substrings finding squares repetitions string computing statistics non overlapping occurrences finding longest match ordered suffix prefix pairs set strings finding longest substring appears strings computing characteristic strings matching string arbitrary path unrooted labeled tree performing efficient dictionary matching data compression schemes searching longest run motif molecular sequences metric distance strings complexity measure random strings cryptology inverted indices analyzing genetic sequences finding duplication programming code generating names programs assembly tasks testing unique set words detecting similarities polygon pattern recognition forth :10.1.1.118.8921:10.1.1.9.8541
surveys applications suffix trees algorithmic techniques construction ubiquitous data structure 
special emphasis developments area parallel algorithms suffix tree construction generalizations suffix trees higher dimensions important multidimensional pattern matching 
remainder organized follows 
section define suffix tree data structure describing applications generalizations section 
algorithms sequential parallel construction described sections respectively 
generalization suffix tree square matrix sequential parallel construction sections 
section contains concluding remarks 
suffix tree string characters drawn ordered alphabet sigma 
denote 
special character matching character sigma 
suffix tree trie digital search tree containing suffixes 
character right endmarker goal separate suffix suffix prefix 
results existence leaf suffix suffixes eventually go separate ways consequently leaf labeled distinct integer path root leaf labeled corresponds suffix 
furthermore path root internal node corresponds substring number different substrings encoded quite large 
strings distinct characters omega gamma different substrings 
example sigma distinct substrings including empty substring 
compact equivalent representations suffix tree nodes ones defined weiner mccreight pratt 
obvious way compact suffix tree compacted trie omitting internal nodes degree called unary nodes 
size obtained representation leaves suffix tree internal unary nodes number internal nodes bounded number leaves 
note advantage having nodes crucial applications instance string piece dna sequence contain characters suffix tree need memory cells represent possible substrings 
formally constraints placed able limit size 
arc may store nonempty substring represented pair integers indicate starting position length inside 
internal node outgoing arcs 
substrings represented sibling arcs different characters 
suffix tree node string obtained concatenating sequence labels encountered path root node 
note constraints guarantee suffix tree node named unambiguously 
say node locus string equal extension string string prefix 
extended locus locus smallest extension inclusive having locus defined 
locus defined locus extended locus coincide 
illustrate definition suffix tree example 
suffix tree string represented fig 

string suffixes abab bab ab numbered 
suffix tree check string substring 
instance aba substring extended locus exists ba ba ab ba 
suffix tree string compact representation 
node suffix tree starts aba leaf 
string substring character match indicated aba extended locus 
fig 
shown compact representation suffix tree string replaced pair integers number starting position length substring 
easily verified fig 
suffix tree obeys constraints 
furthermore clear leaf locus exactly suffix obtained associated leaf 
consequence constraints suffix tree properties node existence leaf suffix internal node possibly empty substring ya yb substrings sigma completeness string sigma substring extended locus substring prefix suffix common prefix suffixes share prefix say share path leading extended locus properties capture essence suffix tree algorithmic implications discussed 
applications generalizations suffix trees discuss applications suffix tree 
suffix tree intensively employed pattern matching problems strings matrices trees 
typical pattern matching problem consists locating occurrences string matrix tree called pattern substructure string matrix tree called text 
pattern matching problems wide range applications molecular biology data processing text editing term rewriting interpreter design information retrieval data types 
classical example string matching consists finding occurrences pattern substring text see survey aho 
crochemore suffix tree built pattern speed linear time algorithms string matching practice average 
suffix tree defined dynamic set strings single string amir obtain dynamic version static aho corasick dictionary automaton 
aho corasick automaton finds multiple occurrences set fy patterns simultaneously text applications text oxford english dictionary dna sequence fixed static string matching query repeated line different patterns times 
better build suffix tree shown 
assume occurs completeness common prefix properties guarantee correspondence occurrences leaves descending extended locus example fig 
occurrences ba text represented leaves numbered 
pattern occur text spelled fig 
pattern occur text match spelled aba 
cases computing suffix tree enables find easily efficiently occurrences pattern preprocessed text similar reasoning possible find longest prefix occurring time proportional length prefix 
furthermore associating number descending leaves node frequency number occurrences known accessing leaves explicitly 
queries typical complete inverted files see 
common situations text editors text retrieval systems sect preprocessed text may undergo changes 
line research studies handle dynamic case building suffix tree scratch time 
cases pattern occurrences text may approximate allow class errors transformations pattern word misspelling dna mutation 
approximate string matching character mismatches insertions deletions considered finding pattern occurrences 
researchers independently discovered dynamic programming table solving approximate string matching problem see sankoff kruskal book galil giancarlo survey list literature 
best knowledge open problem build suffix tree data structure allows approximate queries performed line preprocessed text requiring provably worst case bounds far elegant solutions expected sublinear time queries proposed chang lawler meyers nice approach avoids cases recomputation equal portions dynamic programming table suffix trees ukkonen 
suffix trees turn useful speed dynamic programming computation solving approximate string matching see :10.1.1.9.8541
basic technique common string algorithms employed time landau vishkin 
uses suffix tree compute constant time longest common prefix suffixes common prefix property longest common prefix suffixes locus common ancestor lca corresponding leaves computed constant time linear time preprocessing answer lca queries 
technique chang lawler uses suffix tree pattern compute matching statistics text linear time position find longest prefix occurring substring corresponding extended locus suffix tree alternative solution matching statistics applying external matching problem file transmission building suffix tree time strings separator taken jxj jyj overlapping substrings size jyj technique line built suffix tree shown employ matching statistics obtain expected sublinear time approximate queries 
alternative forms pattern matching properly called pattern matching combinatorics statistics require detect substructures text satisfy certain properties repetitions palindromes 
problem finding palindromes maximal length string easily solved linear time suffix trees constant sized alphabet 
build suffix tree string distinct separator occurring reversed string preprocess answer lca queries apply aforementioned technique finding longest common prefix suffixes 
position want find maximal palindrome having center maximum gamma gamma gamma gamma gamma condition palindromes length odd length 
suffices find constant time length longest common prefix suffixes starting positions jxj gamma positions jxj gamma respectively 
example finding longest repeated substrings substring repeated appears twice naive approach require quadratic time find longest repeated substrings 
node existence property suffix tree substring repeated extended locus internal node particular strings having locus internal nodes candidates longest repeated substrings total number strings upper bounded number internal nodes jxj 
suffices take longest ones simple visit linear time 
fashion coding theory suffix trees find shortest prefix suffix occur follows 
suffix take having locus parent leaf append jyj th character say prefix occurs twice ya prefix occurs 
problems kind data compression schemes compressing assembly code searching longest run motif molecular sequences 
suffix trees help design elegant algorithms finding squares repetitions string computing statistics non overlapping occurrences finding longest match ordered suffix prefix pairs set strings finding longest substring appears strings computing characteristic strings matching string arbitrary path unrooted labeled tree performing efficient dictionary matching 
interesting applications described excellent survey apostolico 
pattern matching suffix trees applied problems metric distance strings complexity measure random strings cryptology inverted indices analyzing genetic sequences finding duplication programming code generating names programs assembly tasks testing unique set words 
suffix trees detecting similarities polygon pattern recognition polygon structure graph purpose 
polygon edges delta delta delta xm sequence internal angles edge lengths read clockwise order string delta delta delta xm mx delta delta delta xm gamma gamma pieces contour similar equal substrings string 
observation leads efficient algorithms finding rotational symmetries performing contour matching called matching similarity scaling deleting lengths string 
analogous trick partition set polygons equivalence classes similar polygons detect similarity polygons see 
mention generalization suffix tree parameterized pattern matching baker gives important application software maintenance 
problem consists finding duplications code large software systems tracking matches different sections code 
looking exact matches parameterized matches short matches 
matches occur sections code may match renaming parameters identifiers constants 
important detect kind duplications undesirable possible association bugs 
exact matches suffix trees plain fashion described 
find parameterized matches requires augment notion suffix tree order take account parameters follows 
parameterized strings strings short strings contain ordinary characters drawn alphabet sigma parameter characters drawn finite alphabet pi 
assume sigma pi disjoint ordering defined alphabets characters compared constant time 
strings yield match transformed applying function renames parameter characters 
example sigma fa bg pi fx zg match renaming simultaneously string 
handle matches baker defines parameterized suffix tree suffix tree generalizes notion suffix tree 
crucial idea suffix tree chain occurrences parameter matching parameters correspond matching chains 
chains encoded suffix tree 
particular chain occurrences parameter associating non negative integers parameters follows 
parameter leftmost occurrence represented successive occurrence represented difference position previous occurrence 
integer representing difference position called parameter pointer 
instance represent chain parameters string ab ab 
refer prev 
note prev prev 
easily shown string yield match prev prev 
string length th character 
th suffix prev 
definition character prev corresponds different value parameter pointer pointing position note property holds matching strings matches position prev prefix 
value th character easily computed looking corresponding character gamma prev 
define function parameter pointer larger gamma ready definition suffix tree 
suffix tree string compacted trie stores suffixes 
analogously case suffix tree arc represents non empty substring suffix internal node outgoing arcs substrings represented sibling arcs different characters 
consequence previous definitions leaf gives distinct suffix string length suffix tree size 
property matching search occurrences string string accomplished analogously case suffix trees strings 
follow path spelled successive characters prev going downward root suffix tree search requires jpj log sigmaj pij time balanced search trees organize adjacency lists suffix tree 
suffix trees matches calculated descending leaves 
find duplication code apply substring statistics discussed earlier ordinary suffix trees suffix tree 
summary testing string match substring string done time jpj log sigmaj pij space jsj suffix trees 
positions match reported time jpj log sigmaj pij total number matches sequential construction suffix tree section describe efficient algorithms construction suffix tree string 
assume string alphabet sigma endmarker 
describe simplified version weiner construction chen scans input string right left 
algorithm mccreight left right scanning 
sketch method amir extending mccreight construction handle dynamic set strings 
algorithm chen chen basically simplified version weiner algorithm maintains auxiliary structures 
sake presentation nodes identified substrings represent 
node character sigma define types links 
link node locus shortest extension substring za 
called link second link node locus shortest extension substring az 
called link third link prefix parent 
called prefix link mentioned associate node pair positions locates occurrence corresponding substring 
main goal suffix tree construct prefix extension links build shortcut links efficiency issues construction 
note prefix links just reverses extension links need specify build 
algorithm works right left 
suffix tree trivially consists nodes obviously built constant time 
build suffix tree az assume inductively built suffix tree pointers root leaf tree 
show build suffix tree az starting suffix tree 
note new substrings represented prefixes az 
longest prefix az substring build new tree install az new extension starting problem locate suffix tree 
note necessarily node suffix tree case install 
find starting root follows 
root extension root case ffl 
root extension find tracing az extension links root az departs substrings tree 
strings accumulate time install suffixes 

second suffix av claim node suffix tree 
prove claim properties follow definition contain endmarker time prefix az substring 
character az note defined 
yb prefix az follows vb substring 
second yb substring longest prefix az substring 
substring contain character possibly yc substring 
exists vc substring 
summary exist vb vc substrings node suffix tree node existence property 
trace prefix links looking node note easily recognized node shortcut 
follow shortcut leads av node shortest extension node 
case install new node prefix parent set shortcut links departing equal ones 
shortcut links arriving new node directed nodes prefix path node having shortcut link prefix parent node av 
installed install new node az extension shortcut links az directed nodes prefix path node having shortcut link note prefix parent node node 
notice shortcut links directed case installed require traversal path shows time required build suffix tree az suffix tree proportional number nodes path observation compute total time required build suffix tree string 
bound time amortization argument show length path amortized reduction depth az 
go prefix path go az step 
path root path root av 
note av node node recall path 
fact av node means av av occur az distinct characters implies occur 
node path root larger path root 
az installed extension reduction depth az compensate time spent path small additive constant 
greatest possible increase depth tree constant iteration total depth reduction total running time algorithm linear 
algorithm mccreight give high level description suffix tree construction mccreight 
sake presentation nodes identified substrings represent root represents empty string 
types links 
extension prefix links defined 
third link called suffix link defined follows node az root sigma sigma suffix link connects node az node note link basically reverse shortcut link az chen algorithm 
root safely assume suffix link points root 
main goal suffix tree build prefix extension links suffix links efficiency issues 
algorithm works left right steps 
step th suffix installed gamma assuming gamma compacted trie built gamma suffixes 
initially tree trivially composed nodes computed constant time 
produce locate gamma extended locus largest prefix 
prefix called head node necessarily gamma leaf installed child head find head starting root accumulate time install suffixes 
algorithm mccreight cleverly computes location head gamma help head gamma gamma suffix links 
relation head gamma head follows lemma mccreight 
second suffix head gamma prefix head second suffix head gamma head gamma empty string empty string 
notice definition head gamma exists path gamma corresponding extended locus gamma 
think suffix link head gamma reach node follow path head note head gamma gamma 
unfortunately locus string guaranteed exist gamma extended locus exist 
suffix link head gamma gamma defined 
show suffix links nodes defined 
suffix link root defined points root 
az node gamma root head gamma exist substrings prefixes gamma suffixes sigma sigma zb zc distinct prefixes gamma suffixes implying node gamma inductive argument follows suffix link az defined 
show locate extended locus head gamma easy task create node head gamma leaf suffix link head gamma point correct location 
way tree correctly produced 
locate head substeps carried suffix link head gamma defined set node reached head gamma suffix link go substep skipping 
phase locates extended locus string gamma installing node 
parent node head gamma tree gamma node reached suffix link 
string descending including 
reached branching recursively gamma way 
current node initially set character ua prefix 
branch initial character equal follow reach child length substring gamma gamma lemma set apply recursively branching 
length substring equal gamma gamma set length substring greater gamma gamma install node case character different unique child substep node unary 
cases suffix link head gamma correctly set surely node 
scanning phase locate possibly install head starting node reached substep 
major difference scanning length known lemma scanning length head known advance 
substring starting examining character time left right spell going deeper deeper tree 
install head node install new suffix child head shown mccreight number suffix links traversed nodes substep characters scanned substep accumulates 
time analysis holds alphabet sigma constant size follow link labeled certain character node 
case size sigmaj alphabet constant adjacency lists nodes organized means balanced search trees 
adds log min sigmaj factor linear bound 
theorem mccreight pratt 
sigma ordered alphabet string characters sigma 
suffix tree computed time log min sigmaj 
building suffix tree implicitly gives ordering characters suffix tree construction faster sorting characters extension mccreight construction set strings interesting modification mccreight construction dictionary strings updated adding removing strings part algorithms solving dynamic dictionary matching pairs suffix prefix problem 
briefly construction suffix tree string delta delta delta distinct simulated introducing log overhead due distinct 
sum lengths strings 
main ideas amir summarized follows ffl suffix tree delta delta delta isomorphic compacted trie suffixes suffixes simulated single character match 
requires storing number suffixes having locus leaf 
ffl add new string jx log min sigmaj time simply start root go step mccreight algorithm 
second suffix head inserted suffix lemma empty string 
ffl remove jx log min sigmaj time notice permuted strings delta delta delta gamma gamma delta delta delta delta delta delta gamma gamma delta delta delta yield isomorphic suffix trees 
remove leaves corresponding suffixes taken decreasing length 
guaranteed removing unary node parent leaves suffix link pointing formal description proof correctness 
parallel construction suffix tree section describe algorithms parallel construction suffix tree 
describing general naming technique karp start algorithm apostolico describe latest efficient parallel constructions vishkin 
fast las vegas randomized algorithm having optimal logarithmic time devised farach muthukrishnan 
results arbitrary concurrent read concurrent write crcw pram model see 
model number processors allowed read write memory location simultaneously case writing conflict processor arbitrarily succeeds 
karp miller rosenberg naming technique doubling technique introduced karp sequential algorithms generalized parallel algorithms 
goal label substrings length power belonging string 
labels integers called names equal substrings get name 
sigma alphabet assume sigma ng 
case characters sorted consistently numbered log time processors 
way character sigma stored memory cell characters compared time 
loss generality suppose log integer 
computation algorithm uses processors initially processor allocated ith character theta matrix bb called bulletin board common processors initialized 
access bb ruled follows 
different processors attempt write location bb arbitrarily succeeds call winner append characters 
sake presentation new string obtained denoted 
note add explicitly gamma assume implicitly algorithm builds arrays name log entries contain integers names 
entry name records name gamma log goal set name name gamma gamma 
note algorithm safely assume name name substring 
arrays name built possible check constant time equality substrings lengths powers 
compute names doubling technique substring gamma seen concatenation prefix gamma gamma suffix gamma gamma length gamma 
observation implies value name depends pair name gamma name gamma gamma 
suggests compute name recursively computing name gamma name gamma gamma 
assign equal names equal pairs corresponding equal substrings bulletin board bb 
algorithm consists log steps 
step log outlined follows processor sets name parallel 
recall allocated integer 
assume name gamma correctly computed name gamma name gamma gamma names assigned substrings gamma gamma gamma gamma respectively 
parallel processor attempts write index cell bb 
index winner name substring gamma 
sets name bb 
difficult see naming correctly performed repeating steps log requires log time processors crcw pram 
computation point crucial bb assign equal integers equal pairs time 
extended assign equal integers equal tuples integers time linear number processors 
useful generalize karp technique square matrices size theta inductive fashion 
consider submatrix size theta contains single character name 
assume names correctly submatrices size gamma theta gamma partition submatrices size gamma theta gamma names say exist inductive hypothesis 
assign equal integers equal quadruples time linear storing entries bb 
way obtain name accessing entry bb containing integer quadruple 
final observed space bulletin board bb reduced ffl fixed ffl ffl slow factor time 
algorithm apostolico parallel algorithm apostolico building suffix tree string works phases 
follow description aj 
phase called naming algorithm applies technique karp described section 
second phase called refining algorithm produces sequence log refinement trees log log gamma approximate precisely suffix tree initial tree log consists root children suffix root represents empty string leaves labeled suffixes leaves numbered leaf labeled suffix implicit leaf participate refinement phase corresponds suffixes 
refinement phase consists initial step log built log refinement steps refinement step tree transformed tree gamma tree log arcs directed children parent nodes labeled substrings opposed suffix tree arcs labeled 
recall substring labeling node compactly represented pair gamma component gives starting position inside second component gives length final tree suffix tree direction arcs reversed labels moved nodes arcs 
substrings refiner integer characters substrings equal prefix length common 
tree log meets condition call condition leaves unary nodes nodes child 
ii internal node labeled substring 
iii pair substrings labeling sibling nodes admits refiner 
iv leaf labeled distinct suffix stored leaf observe condition log trivially met initial tree log refinement phase condition guarantees fulfills definition suffix tree provided arcs reversed labels moved nodes arcs 
key operation transform gamma call refinement step 
outlining step need terminology 
children node referred nest 
say nodes nest equivalent strings labeling refiner gamma share common prefix length gamma detection elimination gamma inside nests heart refinement step gamma gamma split labels nodes split label node labeled substring gamma gamma pair arbitrarily chosen processor index assigned nest containing name prefix gamma gamma length gamma nodes considered equivalent split label nodes belong nest labels share refiner gamma equivalent nodes correspond substrings containing common prefix length gamma locus common prefix new node introduced gamma refinement steps consists substeps partition nodes nest equivalence classes split label 
bulletin board bb assign name equal pairs 
equivalence class nest jcj new node created 
label prefix length gamma common substrings represented labels nodes parent nodes nest parent new node turn parent nodes labels nodes consistently updated 
substep performs final check remove unary nodes 
tree resulting execution substep 
node children unary nodes ones nest partitioned equivalence class 
nest resulted equivalence class substep remove newly created child tree child parent shown removal apply simultaneously parent 
labels updated accordingly 
possible show satisfies condition tree gamma obtained synchronous application substeps satisfies condition gamma 
omit proof details implementation processor allocation referring interested reader 
theorem apostolico 
suffix tree string length built log time processors log arbitrary crcw pram 
required space ffl fixed ffl 
algorithm vishkin give brief description optimal parallel construction suffix tree string sigmaj devised vishkin 
takes doubly logarithmic time linear crcw pram required space superlinear algorithm apostolico 
main bottleneck algorithm apostolico karp naming technique described section 
recall technique requires assign names gamma substrings having length log vishkin observe naming assignment accumulates log difficult consistent selection overlapping substrings substrings look alike difficult choose ones needed suffix tree construction 
trying apply karp technique subset substrings difficult sense produces rigid recursive partition substrings smaller substrings take account similarities equal substrings partitioned differently 
break symmetries substrings vishkin apply successfully deterministic coin tossing technique see producing recursive partition substrings rigid driven characters way obtain basic algorithm builds suffix tree log time log log sigmaj poly 
bound basic algorithm reduced optimal sigmaj 
basic algorithm assuming sigma ng 
main stages 
stage requires log time log 
symmetries broken attaching labels substrings follows 
sequence log strings produced 
symbols called characters 
length obtained shrinking gamma log time log js gamma gamma precisely gamma partitioned sets contiguous gamma characters set character 
characters identified integers called labels equal characters receive label 
character naturally induces substring called substring list rules partition gamma 
roughly speaking rules determining sets partition gamma applied order 
gamma character forms singleton partition corresponding gamma substring longer call long gamma character 
consider gamma characters 
largest run consecutive equal gamma characters set partition called repeated substring 
consider remaining gamma characters 
note preceded followed gamma character equal 
largest run consecutive gamma characters forms set partition called changing substring removal gamma character gamma characters 
notice changing substring contains consecutive equal gamma characters 
need partition changing substrings length sets gamma characters 
deterministic coin tossing 
jth gamma character changing substring labeled integer tag position significative bit differs binary representations jth th gamma characters changing substring respectively 
break symmetry apply deterministic coin tossing technique sequence tag tag changing substring parallel dealing properly local maxima minima see procedure content 
changing substrings partitioned smaller sets size having length greater changing substring replace jth gamma character tag apply recursively procedure terminate log steps 
final adjustment done singleton sets resulting partition gamma order guarantee js singleton initial set gamma merged right neighbor set partition merged left neighbor set neighbor repeated substring exactly equal gamma characters 
size sets gamma computed log time linear 
sets transformed characters shrinking gamma assigning labels bulletin board bb see section sect 
done time observing sets composed distinct elements equal elements cases represent tuples constant size 
partition labeling satisfy important properties 
partition consistency substrings gamma partitioned way possibly log gamma characters label consistency sets partition gamma characters equal receive label 
second stage basic algorithm requires log log time log 
sequence log strings produced 
obtained recursively jc js characters called cores introduced motivation 
partition consistency property margins partitioned differently certain point suffix tree construction detect similarities different partition margins idea cores add properly left right extension character obtained relaxed partition gamma sets may overlapping way margins log gamma characters covered core suffix tree construction 
formally defined recursively terms gamma recall 
jth character jth core spans substring obtained substring corresponding extending left right rules 
need definitions 
gamma characters form set gamma originating character stage 
left vicinity defined log gamma characters gammalog gamma gamma symmetrically right vicinity log induction know gamma cores called spanned gamma characters rules applied order define 
originated singleton containing long character concatenation overlaps string left gamma cores resulting string concatenated overlaps string right left right log length determined follows 
gamma character left vicinity gammalog gamma gamma long left concatenation overlaps gamma cores gammalog gamma gamma le rightmost long gamma character left vicinity note le originated stage gammal characters singleton gamma 
take left concatenation overlaps cores corresponding rightmost gammal characters gamma substrings induced le gamma symmetrical definition holds right right vicinity observed core visualized double staircase recursion left right vicinity 
step staircase contains consecutive substrings cores satisfy important properties allow assign efficiently names cores bulletin board bb 
core consistency substrings core core 
receive equal names 
middle core identity suppose character originated gamma characters gamma log 
gamma cores equal names log ones 
note core consistency property stronger partition consistency 
properties results give strong characterization core terms log different names recursively computed 
induction assigning names cores requires log time log bulletin board bb 
third stage basic algorithm requires log time log log 
suffix tree built reversing iterations done second stage 
suffix tree build string 
compute assuming correctly computed initial tree easy build constant size 
reach obtain suffix tree 
transformation performed improving resolution 
replace core dense set cores contained substrings 
say case covers cores 
shown cores covered core represented string log pairs pair contains name core integer denoting number repetitions 
precisely tree obtained intermediate versions tree obtained replacing cores label arcs departing strings cores cover 
remaining cores replaced similarly avoiding duplication caused overlaps cores produced cores labeling consecutive arcs path recall cores give partition overlaps 
note suffix implicitly mapped suffix suffix corresponding suffix may different suffix corresponding suffix obtained replacement 
due fact left extension character may contain long characters cf 
second stage 
suffixes stored implicitly may different 
sibling arcs may share common prefix cores prefix longer core core consistency property fact sibling arcs start different characters 
refine fact core represented string log pairs done bulletin board bb parallel integer sorting 
preprocess answer lca queries obtain preorder visit leaves euler tour 
produce define tail core sequence names cores starting inclusive rightmost core covered full core right informally tails represent sort synchronization cores suffixes stored shown tail represented string log pairs 
divide cores equivalence classes equal tails 
equivalence class root linked distinct child labeling arc tail representing class 
build compacted tries descending children observe obtained contraction lca queries order leaves euler tour 
need refine tails labeling arcs departing root applying method similar described completes description basic algorithm builds suffix tree log time log log sigmaj poly 
note log log dominated parallel integer sorting 
basic algorithm reduced optimal sigmaj applying accelerating cascades method see ad hoc techniques 
refer interested reader 
theorem vishkin 
suffix tree built log time log log crcw pram sigmaj poly 
reduced sigmaj 
required space ffl fixed ffl 
algorithm describe build suffix tree binary string polylogarithmic time linear space crcw pram algorithm 
construction works weaker crew pram bounds extended case sigma arbitrary alphabet sigma characters sorted alphabet coding character sigma binary sequence log sigmaj length 
compared algorithm apostolico algorithm exploits useful combinatorial properties strings periodicity repetitive nature suffix tree 
main ideas outlined referring interested reader deeper insight 
assume 
suffix tree st compacted trie built substrings length suffixes length excluding suffix 
st suffix tree goal construction sequence trees st st st st dlog ne log smallest integer 
denote st algorithm consists stages th building initial stage tree constructed concurrent version mccreight algorithm log log time 
stage steps 
step approximate version built log time 
tree leaves store substrings length smaller equal 
second step processed obtain log time 
leaves removed jf jf suffix possibly created unary nodes removed 
challenging task perform step log time 
string partitioned substrings length possibly jx 
adjacent strings overlap exactly characters tree built compacted trie suffixes string build processor allocated string having task inserting suffixes left right sequential algorithm mccreight 
unfortunately main problems arising concurrent execution mccreight algorithm common data structure 

processors simultaneously try break arc installing arbitrarily long path nodes cf 
steps section 

node installed suffix link parent set 
link required place analysis mccreight algorithm 
problems solved assuming algorithm divided time steps 
time step corresponds step mccreight algorithm scanning step step 
globally time steps requiring time 
second problem circumvented simply waiting node suffix link followed set 
waiting time measured terms wasted time steps processor sets link 
cause large delay number time steps necessary insert suffixes clever amortized analysis shows processor assigned string takes time steps 
problem solved organizing processors lists follows 
define current string length processor assigned string integer gamma position rightmost scanned character position installed suffix node lists processors maintained ordered processors current string length 
list contains processors node may perform scanning step 
second list contains processors waiting node suffix link set 
link set empty 
note order implies processors want simultaneously break arc transform path nodes sorted point want break arc time step lists nodes reorganized log time 
stages initial stage log charge producing easily performed log time log follows 
leaf leaf stores string gamma string denoted 
leaf indicate positions fj leaf set positions occurs substring 
suppose correctly produced gamma preprocessed log time answer lca queries constant time 
way compute longest common prefix substrings length see section compare lexicographically substrings operations constant 
suffices show obtain gamma log time log 
comparisons specified sort substrings having length log time log 
bucket containing substrings having length starting positions positions gamma associated leaf gamma suffix note substrings share prefix length gamma 
sorting equal substrings bucket form equivalence class representative string class chosen 
fix ordered list representative strings 
recall longest common prefix consecutive strings computed constant mentioned 
result farach muthukrishnan allowing compacted trie built lexicographically ordered list strings logarithmic time linear know longest common prefix contiguous strings list 
construct compacted trie merge root compacted trie longer node obtaining major points reducing log computation retaining space increasing time bound log log 
fix stage point obtain leaf gamma sorting explicitly representative strings buckets 
second point answer lca queries doing preprocessing gamma scratch stage points algorithm compacted tries installed gamma obtain built jt gamma logarithmic time 
simulate lca preprocessing second point shown maintaining suitable data structure 
discuss point produce gamma rest section 
list produced defined substrings starting positions positions gamma taken length delta gamma delta gamma delta gamma 
length say depends leaf delta gamma easily obtained linear longest common prefix consecutive strings list ranking 
focus build ordered lists gamma describe initial computation log time 
finds origin leaves describe computation deployed computing lists log time log gamma jt gamma stage 
need preliminary definitions 
indicates set leaves distinct substrings length suffixes length 
define links links links called 
leaf link points occur consecutive positions second suffix prefix character 
similar definition applies links links 
links play crucial role naturally induce sparse digraph denoted describe initial computation origin leaves form subset vertices graph set links goal produce sequence subgraphs forest rooted trees dlog ne height roots defined origin leaves obtained removing links leaf gamma leaf positions fi index precisely gamma gamma gamma complemented 
called fi index occur occurs fewer times occurs times gamma 
technical reasons fi index 
fi indices corresponding nodes determined time looking vertices having indegree see lemma 
second obtained removing edge cycle connected components rooted trees 
third obtained splitting trees unique edge incident vertex distance multiple dlog ne root removed 
connected components rooted trees dlog ne height 
roots trees chosen origin leaves describe stage composed main parts 
part stage subset special leaves called sources selected gamma origin leaves purpose consider ordered set positions leaf origin leaf 
shown partition maximal contiguous subsequences property subsequence say verifies leaf leaf delta delta delta leaf fi index exists getting detail special positions called ff fl ffi indices selected subsequences ff indices correspond singleton subsequences ffi indices ones non singleton subsequences fl indices taken theta log positions differ multiple suitable period non singleton subsequences 
combinatorial properties upper bound called bifurcation number choice dlog ne crucially show number ff fi fl ffi indices log 
subsequence induces periodic substring gamma periodic period length gamma gamma delta delta delta gamma gamma dlog ne 
define leaf gamma source leaf gamma satisfying link incident gamma fi index link incident gamma ff index fl index ffi index gamma gamma 
important notice log sources positions leaf gamma ff fi fl ffi indices 
list source leaves built log time log implicit remove edges gamma similarly edge removal obtain sources gamma roots resulting trees log height 
source leaf rep strings substrings length delta gamma start positions positions gamma recall length string gamma 
second part stage obtained source leaves gamma give brief sketch 
cases 
source leaf satisfying conditions means positions gamma positions gamma contains ff indices fi indices fl indices rep strings having period length larger dlog ne 
number log 
obtain lists explicitly sort rep strings lca queries log 
source leaf satisfying condition periodic period length dlog ne 
take ffi index positions gamma consider positions subsequence called family 
shown subset strings rep strings distinct strings starting positions consecutive portion family ffi index sorted total number accumulates jt gamma gamma 
exploiting relationship periodicities position associated ffi index lexicographic order strings rep strings shown lists associated ffi index globally sorted 
lists computed log jt gamma gamma result cleverly merging ordered lists available ffi index third part stage produced leaves gamma computation parts repetitive nature suffix tree 
repetitive mean informally 
consider generic node suffix tree 
suffix link incident say node subtree rooted isomorphic rooted assuming leaves gamma order list induced 
incident suffix links recall sigmaj say subtree rooted obtained merging subtrees rooted assuming leaves gamma order list induced obtained merging 
notation done 
link graph gamma said frozen incident source leaf leads leaf gamma gamma leaf gamma fi index 
consider graph gamma obtained gamma removing frozen links 
connected components rooted trees height dlog ne having source root lemma computed list non source leaf define ordered list composed representative substrings length delta gamma gamma dlog ne distance root connected component 
implies delta gamma gamma delta gamma visit rooted trees breadth starting roots 
computation gamma log jt gamma jt gamma stage time log 
refer interested reader details correctness algorithm 
theorem 
sigma sorted alphabet string length suffix tree built log time log sigmaj log sigmaj space crew pram 
notice main open problem find deterministic parallel algorithm builds suffix tree optimal log min sigmaj log time fast apostolico having space sequential bound theorem 
best knowledge bounds achieved las vegas randomized algorithm devised farach muthukrishnan 
lsuffix tree section generalize notion suffix tree square matrices 
theta square matrix entries drawn ordered alphabet sigma build compacted trie similar suffix tree string 
square submatrix path trie corresponds submatrix 
idea compact index square matrix introduced pat trees 
shaded region th suffix matrix th prefix shaded submatrix rd prefix th suffix bold boundaries illustrated bold square shaded submatrix nd prefix nd suffix gonnet submatrices represented semi infinite spirals called 
construction requires worst case time log average time sigmaj 
efficient worst case solution different linear representation called developed giancarlo lsuffix trees requiring log worst case time 
notion suffix tree generalized square matrices giancarlo grossi wide class linear representations square matrices giving rise definition exponential number families indices including pat trees lsuffix trees 
construction works uniformly index requiring log worst case time average time sigmaj 
sake brevity describe lsuffix trees 
extend square matrices concepts defined strings 
square submatrix th suffix square submatrix th prefix see 

note square submatrix upper left corner lies main diagonal described prefix suffix see fig 

number diagonal necessarily main elements gamma jdj square submatrix main diagonal th diagonal square submatrix described prefix suffix diagonal submatrix jdj see fig 

adopt linear representation square matrix called 
divide shaped characters th composed row gamma column see fig 

shaped characters called 
write dimension order top appearance see fig 

way get representation terms string called 
need notion chunk analog notion substring strings 
informally obtain 
matrix divided shading linear representations chunk composed nd rd 
chunk write dimension order top appearance starting row row see fig 
represent matrices chunks represent shaped pieces matrices 
describe generalize notion suffix trees 
need terminology 
square matrix corresponding la la obtained concatenation strings la gamma length gamma see 

string seen 
denote chunk th th la 
length la number 
th la denoted la corresponding th prefix easy obtain la take write 
notice lb la square matrix corresponding lb equal prefix see fig 

th lsuffix la denoted la corresponding th suffix notice la la 
lb lsuffix la square matrix corresponding lb equal suffix see fig 

la corresponding diagonal submatrix jdj definition prefix suffix square matrix square submatrix prefix suffix diagonal submatrix correspondence la implies square submatrix corresponds lsuffix la lsuffix tree represent la diagonal jdj lsuffix la path root leaf spelling lsuffix 
guarantee completeness property 
common prefix property guaranteed fact matrices common prefixes yield common 
lsuffix tree corresponding square matrix suffix tree string 
just character string required unique ordinary suffix trees require unique lsuffix trees 
necessary add extra containing 
denote 
matrix la corresponding shown second prefix third suffix 
special 
addition lsuffix lsuffix 
appended theta matrix matrix augmented bottom row rightmost column see fig 

purposes need define lsuffix tree set 
set corresponding diagonal submatrices jdj fla jdj ng 
lsuffix tree matrix compacted trie built set defined alphabet sigma satisfies constraints lt arc may store nonempty chunk 
lt internal node outgoing arcs 
lt chunks represented sibling arcs start different length strings sigma concatenation chunks represented labels path root leaf gives exactly lsuffix set see fig 

notice analogy properties lt lt ordinary suffix trees described section 
size lsuffix tree leaves lsuffix unary nodes 
possible represent chunks labeling arcs compact way see fig 

chunk la represented quadruple lsuffix la corresponding leaf represented pair considered quadruple 
refer types quadruples descriptors 
square matrix possible locate constant time chunk corresponding descriptor vice versa 
implies 
lsuffix tree corresponding main diagonal matrix fig 
representation descriptors 
triples quadruples 
built explicitly submatrices jdj sake definition 
point node outdegree lsuffix tree reduced sigmaj transforming compacted trie sigma 
allows log searching time theta pattern matrix reduced log sigmaj time 
sequential construction lsuffix tree section describe algorithm giancarlo computes lsuffix tree square matrix 
algorithm nontrivial generalization algorithm mccreight set strings described sections 
algorithm inserts la jdj loss generality focus inserting say la 
analogously algorithm mccreight suffixes la inserted longest shortest tree initially nodes 
denote lt tree th iteration 
words lt compacted trie alphabet sigma built set la denote lhead corresponding longest prefix prefix lhead longest la la note lhead locus lt definition necessarily locus lt gamma analogy section tree lt composed nodes obtain lt lt gamma follows 
find contracted locus lhead lt gamma locus longest lhead defined 
needed create locus lhead install new leaf representing la child new locus 
section accomplished scanning phase 
main obstacle generalization mccreight algorithm suffix links crucially rely property distinct right context string longest common prefix suffixes length longest common prefix suffixes length gamma 
property extend matrices 
lb lc lb lc imply happens strings 
phase major difference algorithm mccreight strings try define suffix link node lt gamma analogy definition section guaranteed existence lt gamma node suffix link point 
implies lv locus lt gamma guaranteed second suffix lv locus path corresponding 
circumvent problem relaxed notion suffix links defined function sl gamma follows 
root lt gamma sl gamma locus lv sl gamma contracted locus lv 
case strings sl gamma lhead gamma defined 
sl gamma defined nodes 
contracted loci may change due insertion new nodes suffix links just defined change dynamically lt gamma lt due dynamic nature store sl gamma help dynamic trees sleator tarjan 
sl gamma move efficiently locus lhead gamma contracted locus lhead gamma rest lhead scanning phase similarly scanning phase mccreight algorithm 
need primitives manage constant time done building ordinary suffix trees rows columns computing longest common prefix similarly 
outline insert lsuffix tree th iteration function sl gamma defined lhead gamma set node pointed sl gamma lhead gamma skip 
lt gamma locus lhead gamma lt gamma sl gamma find contracted locus lhead gamma 
node located leaf descending locus lhead gamma locus gamma la 
ancestor node pointed sl gamma defined induction 
scanning start node skip remains lhead gamma surely match 
contracted locus lhead examining follow lhead gamma la go deeper deeper tree 
needed create locus lhead install new leaf representing child new locus 
transform sl gamma sl omit remaining details construction extension set giving theorem 
theorem giancarlo 
theta matrix lsuffix tree built log log sigmaj time 
parallel construction lsuffix tree describe algorithm giancarlo grossi parallel construction lsuffix tree takes log time log arbitrary crcw pram 
algorithm high level organization similar algorithm apostolico described section referred 
notions tools generalize chunks need new notions algorithm 
particular order perform refinement step implicitly uses properties string positional independence substrings gamma gamma admit refiner min name name names assigned prefixes length compared independently position inside name splitting name substring gamma divided pair names prefix gamma gamma suffix gamma gamma respectively 
name split existing names name gamma name gamma gamma test refiner gamma substring inheritance set substrings length power respectively taken suffixes substrings inherited sufficient compute names substrings turn algorithm parallel construction lsuffix tree square matrix size assume power padded 
algorithm main phases naming refining 
phase gives names square submatrices size theta log described section 
second phase produce sequence refinement trees ld log 
refinement step hinges notion refiner refiner labels nest integer gamma gamma 
chunks la la equal 
arcs tree ld directed upwards labels nodes arcs 
initial tree ld log composed root leaves lsuffix la jdj leaves labeled descriptors la jdj final tree ld lsuffix tree direction arcs reversed 
tree ld log satisfies conditions satisfied lsuffix tree section lt replaced lt labels nodes nest admit refiner labels number matrix elements shape 
analogy transform ld ld gamma partitioning nodes nest equivalence classes 
need new notion equivalence positional independence property strings hold la 
chunks la la length comparable chunk composed number gammai characters sigma different number gammaj characters chunk 
definition equivalence classes nests account constraint chunks class comparable shape length straightforward generalization suggest 
getting details mention possible manage new constraint equivalence classes condition lt 
need assign names chunks compare split names efficiently 
ideas ideas name splitting substring inheritance properties strings generalize matrices resp 
split lsuffix chunk shaped part 
chunk successively split chunks 
matrices theta distinct elements give rise omega gamma log distinct chunks length power versus log submatrices names side power names chunks computed log 
proceed demand names chunks needed algorithm 
chunk ff compute integer name ff demand equal chunks equal names names efficiently split 
descriptor ff ff corresponds portion submatrix gamma gamma obtained removing submatrix gamma gamma 
submatrix smallest submatrix containing ff 
call submatrix matrices crucial task assigning names chunks demand ff fi chunks length composed initial labeling nodes nest ff fi corresponding submatrices 
chunks equal submatrices equal 
ff fi ff fi see 
strong property shows label name ff ff computed assigning unique integer ff bulletin board bb names overlapping submatrices side power cover ff 
ff side power submatrices equal ff recall names submatrices computed phase algorithm 
way splitting comparing names chunks demand reduced constant time computation matrices 
note name ff thin slim chunk ff decomposed omega gamma submatrices names side power 
possible define split label node tree ld index chosen processor nest containing name ff chunk ff composed gamma labeling split labels possible partition nests equivalence classes similarly omit details processor allocation analysis construction 
theorem giancarlo grossi 
lsuffix tree square matrix size built log time processors arbitrary crcw pram 
required space ffl fixed ffl 
interesting problem find log sigmaj parallel construction lsuffix tree 
improve theorems 
surveyed suffix tree ubiquitous data structure appears different fields related string processing 
applications different areas described main algorithmic techniques sequential parallel construction 
particular emphasis newest developments related suffix trees parallel algorithms suffix tree construction generalizations suffix trees higher dimensions important multidimensional pattern matching 
acknowledgments indebted useful comments giegerich sending gaston gonnet pointing 
aho algorithms finding patterns strings handbook theoretical computer science vol 
van leeuwen ed mit press cambridge ma 
aho corasick efficient string matching aid bibliographic search comm 
acm 
aho hopcroft ullman design analysis computer algorithms addison wesley reading ma 
linear time pattern matching algorithm string tree combinatorial pattern matching 
amir farach dimensional dictionary matching information processing letters 
amir farach galil giancarlo park dynamic dictionary matching journal computer system science 
amir farach matias efficient randomized dictionary matching algorithms combinatorial pattern matching 
apostolico myriad virtues subword trees combinatorial algorithms words apostolico galil eds springer verlag berlin 
apostolico landau schieber vishkin parallel construction suffix tree applications algorithmica 
apostolico preparata optimal line detection repetitions string theoret 
comp 
sci 

apostolico preparata structural properties string statistics problem journal comput 
syst 
sci 
apostolico szpankowski self alignment words applications algorithms 
baker theory parameterized pattern matching algorithms applications proc 
th symp 
theory computing 
perry technique designing computer access selecting terminology proc 
rocky mountains conference artificial intelligence international boulder colorado 
bhatt hagerup prasad saxena improved deterministic parallel integer sorting information computation 
blumer blumer haussler ehrenfeucht chen smallest automaton recognizing subwords text theoret 
comput 
sci 
blumer blumer haussler mcconnell ehrenfeucht complete inverted files efficient text retrieval analysis acm 
blumer ehrenfeucht haussler average size suffix trees discrete appl 
math 

booth lexicographically circular substrings information processing letters 
boyer moore fast string searching algorithm comm 
acm 
dictionary matching unbounded alphabets uniform length dictionaries combinatorial pattern matching 
analysis performance inverted data base structures comm 
acm 
chang lawler sublinear approximate string matching biological applications algorithmica 
chen efficient elegant subword tree construction combinatorial algorithms words apostolico galil eds springerverlag berlin 
haussler mcconnell schneider stormo sequences landscapes nucleic acids research 
cole parallel merge sort siam comput 
cole vishkin deterministic coin tossing application parallel list ranking information control 
crochemore transducers repetitions theoretical computer science 
crochemore rytter speeding string matching algorithms algorithmica 
crochemore rytter parallel construction minimal suffix factor automata inf 
proc 


crochemore rytter usefulness karp miller rosenberg algorithm parallel computations strings arrays theoretical computer science 
devroye szpankowski note height suffix trees siam comput 
galil faster tree pattern matching acm 
ehrenfeucht haussler new distance metric strings computable linear time disc 
applied math 
farach muthukrishnan private communication 
ferragina incremental text editing new data structure proc 
european symposium algorithms 
ferragina grossi fast incremental text editing proc 
acm siam symposium discrete algorithms 
ferragina grossi fully dynamic data structure external substring search proc 
acm symposium theory computing 
greene data compression finite windows comm 
acm 
fraser wendt myers analyzing compressing assembly code proc 
sigplan symp 
compiler construction 
galil giancarlo data structures algorithms approximate string matching complexity 
galil park improved algorithm approximate string matching siam comput 
giancarlo suffix tree square matrix applications proc 
th acm siam symp 
discrete algorithms 
appear siam comput 
giancarlo index data structure matrices applications fast dimensional pattern matching proc 
workshop algorithms data structures 
giancarlo grossi parallel construction query suffix trees dimensional matrices proc 
acm symp 
parallel algorithms architectures 
giancarlo grossi construction classes suffix trees square matrices algorithms applications proc 
international colloquium automata languages programming 
giegerich kurtz ukkonen mccreight weiner unifying view linear time suffix tree construction technical report universitat bielefeld technische fakultat germany 
gonnet efficient searching text pictures 
technical report oed university waterloo 
gonnet baeza yates handbook algorithms data structures 
addison wesley 
gonnet baeza yates snider new indices text pat trees pat arrays 
information retrieval data structures algorithms frakes baeza yates eds prentice hall 
grassberger estimating information content symbol sequences efficient codes ieee trans 
information theory 
gu farach beigel efficient algorithm dynamic text indexing proc 
acm siam symposium discrete algorithms 
guibas odlyzko periods strings combinatorial theory ser 
guibas odlyzko string overlaps pattern matching games combinatorial theory ser 
gusfield landau schieber efficient algorithm pairs suffix prefix problem information processing letters 
harel tarjan fast algorithms finding nearest common ancestors siam journal computing 
optimal parallel suffix tree construction proc 
th symp 
theory computing 
hui color set size problem applications string matching combinatorial pattern matching 
ito shimizu nakanishi hashimoto polynomial time algorithms computing characteristic strings combinatorial pattern matching 
jacquet szpankowski autocorrelation words application analysis suffix trees string ruler approach combinatorial theory ser 
aj parallel algorithms addison wesley reading ma 
jain workshop report visual information systems tech 
rep national science foundations 
suffix cactus cross suffix tree suffix array proc 
combinatorial pattern matching 
karp miller rosenberg rapid identification repeated patterns strings trees arrays proc 
th annual acm symp 
theory comput 
bayer time optimal left right construction position trees acta informatica 
kosaraju fast pattern matching trees proc 
th ieee symp 

computer science 
kosaraju real time pattern matching quasi real time construction suffix trees proc 
th symp 
theory computing 
kosaraju computation squares string combinatorial pattern matching 
knuth morris pratt fast pattern matching strings siam comput 
landau vishkin introducing efficient parallelism approximate string matching proc 
th symp 
theory computing 
landau vishkin fast string matching differences journal computer system science 
landau vishkin fast parallel serial approximate string matching algorithms 
lempel ziv complexity finite sequences ieee trans 
information theory 
opez ortiz linear pattern matching repeated substrings sigact news 
reiser efficient line construction correction position trees siam comput 
manber myers suffix arrays new method line string searches proc 
st acm siam symp 
discrete algorithms 
mccreight space economical suffix tree construction algorithm acm 
morrison patricia practical algorithm retrieve information coded alphanumeric acm 
myers nd difference algorithm variations algorithmica 
myers sublinear algorithm approximate keyword searching algorithmica 
connor snider suffix trees string complexity advances cryptology proc 
eurocrypt lncs 
pratt improvements applications weiner repetition finder unpublished manuscript 
rodeh fast test unique suffix trees ieee trans 
information theory 
rodeh pratt linear algorithm data compression string matching acm 
rosenfeld kak digital picture processing academic press 
vishkin symmetry breaking suffix tree construction proc 
th symp 
theory computing 
sankoff kruskal eds time warps string edits macromolecules theory practice sequence comparison addison wesley reading ma 
schieber vishkin finding lowest common ancestor simplification parallelization siam comp 
shields entropy prefixes annals probability 
fast canonization circular strings algorithms 
sleator tarjan data structure dynamic trees journal computer system science 
detection periodicities string matching real time journal soviet mathematics 
storer private communication 
szpankowski generalized suffix tree un expected asymptotic behaviors siam comp 
szpankowski asymptotic properties data compression suffix trees ieee trans 
information theory 
tanimoto method detecting structure polygons pattern recognition 
principles text processing wiley sons 
ukkonen approximate string matching suffix trees combinatorial pattern matching 
ukkonen line construction suffix trees tech 
report department computer science university helsinki finland 
waterman ed mathematical methods dna sequences crc press boca raton fl 
weiner linear pattern matching algorithm proc 
th ieee symp 
switching automata theory 
wyner ziv asymptotic properties entropy stationary ergodic data source applications data compression ieee trans 
information theory 
ziv lempel universal algorithm sequential data compression ieee trans 
information theory 

