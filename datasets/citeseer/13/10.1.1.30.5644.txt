lazy vs strict philip wadler university glasgow glasgow qq scotland wadler dcs glasgow ac uk www dcs glasgow ac uk lazy call need languages schedule dynamically building closures shun side effects strict call value languages avoid overhead closures may exploit side effects 
style complementary advantages complimentary 
gap lazy strict camps dimensions shall name style models 
developments suggest dimensions gap shrinking 
list commercial applications kind language examine dimension difference turn 
applications commercial applications demonstrate utility laziness demonstrates utility strictness 
icad market leader area cad systems 
systems represent design program constructs tree graph parts may displayed 
overview requires tree constructed root limited depth close requires portion tree evaluated greater depth 
lazy evaluation essential performance minimises portion tree constructed 
years ago written lazy evaluation icad trade secret 
natural expert expert system shell marketed software ag interfaces database system called natural 
users write shell programs language similar haskell 
lazy evaluation essential manage interaction database returns potentially enormous data structures 
commercial applications developed natural expert including invoices services flight passing airport paris 
erlang strict functional language ericsson program telecommunications switches 
erlang fuses ideas functional concurrent languages 
functional side provides ease allocating traversing deallocating complex structures concurrent side provides processes appear acm computing surveys june 
message passing distribution 
synergy arises messages passed complex structures instance functional pattern matching may determine concurrent message receive 
strictness essential easy predict order concurrent operations occur 
hundreds thousands lines erlang code appear ericsson products superior number projects 
narrowing style gap advantages lazy strict languages appear fundamentally 
laziness advantage precisely difficult predict required order evaluation advance strictness advantage precisely allows prediction 
years lazy functional programmers hit way incorporate features require specified order evaluation including exception handling assignment input output concurrency 
moggi discovered operations modelled denotationally applying notion category theory called monad 
functional languages far removed denotational semantics proved straightforward adapt moggi approach structure functional programs incorporate side effects 
uses monads advanced number researchers surveyed 
strict language may embedded lazy known decades results reynolds plotkin concerning continuation passing style cps 
direct cps purpose tried earlier hope haskell success monads may regarded mild generalisation cps 
surprising degree monads surpassed cps popularity technique embedding strict behaviour lazy language 
known lazy language embedded strict variant cps closures 
applications fit monad framework tentative explorations monads structure sml erlang programs met success 
surprising pleasing lazy strict strict lazy embeddings treated monad framework 
popularity monads lazy community brings new hope strict lazy communities may come closer 
narrowing model gap approximation lazy call name languages modelled church calculus strict call value languages modelled plotkin calculus 
simply typed calculus complete equation true models provable 
example write letx abbreviation equation holds lazy strict languages 
provable unprovable hand calculus provides reasonable model evaluation 
example suggests cost evaluating term approximately cost evaluating plus cost addition suggests cost approximately cost addition plus twice cost evaluating resolution difficulties choose simple accurate models 
construction models remarkably turn surprisingly similar 
church calculus may improved replacing call calculus discovered ariola felleisen odersky wadler 
calculus provides reasonable model evaluation 
observationally equivalent calculus retains completeness properties 
plotkin calculus may improved moggi calculus proposed sabry wadler 
calculus moggi monads sound complete monad models 
contains subset remains reasonable model evaluation 
improved calculi nearly identical 
odersky turner wadler studied variants call value need callby need differ exactly law gamma 
free absent 
similarity appears hold range formulations sabry wadler conjecture augmenting law turns model call value call need 
long lazy strict camps 
rearrangement may united 
ariola felleisen odersky wadler call lambda calculus nd acm symposium principles programming languages san francisco california january 
armstrong virding williams concurrent programming erlang nd edition prentice hall 
hutchison schmidt hall natural expert commercial functional programming environment journal functional programming appear 
odersky turner wadler call name callby value call need linear lambda calculus th international conference mathematical foundations programming semantics new orleans louisiana march 
moggi notions computation monads information computation 
sabry wadler reflection call value st acm international conference functional programming philadelphia pennsylvania may 
wadler essence functional programming 
th acm symposium principles programming languages albuquerque new mexico january 
wadler declare imperative 
international logic programming symposium portland oregon mit press december 

