unifying concurrency control recovery transactions semantically rich operations hasse ye department computer science university kentucky lexington ky usa email yuri cs engr edu yuri breitbart 
schek institute information systems eth zentrum ch zurich switzerland email ye schek inf ethz ch classical theory transaction management contains different aspects concurrency control recovery ensure serializability atomicity transaction executions respectively 
concurrency control recovery independent criteria aspects developed orthogonally result cases criteria incompatible 
unified theory concurrency control recovery databases read write operations introduced ava allows reasoning serializability atomicity framework 
ava class schedules introduced called prefix reducible guarantees serializability atomicity failure prone environment read write operations 
protocols developed generate schedules database concurrency control mechanism 
unified transaction model databases arbitrary set semantically rich operations 
investigate constructive characterization class prefix reducible schedules semantically rich operations 
turns databases read write operations exact characterization prefix reducible schedules databases arbitrary operations infeasible 
propose sufficiently rich subclasses prefix reducible schedules design concurrency control protocols guarantee serializability atomicity schedules classes 
transaction management database systems arbitrary set operations mgg mgg wei hh wei hh br rks rks increasingly important 
develop transaction management model transactions arbitrary finite set department computer science eth zurich ch switzerland 
material part supported nsf iri iri iri hewlett packard 
performed breitbart year sabbatical visiting database research group eth zurich 
operations 
model semantic high level commutativity relation defined pair operations 
operations different transactions commute transaction manager free execute operations order 
operations different transactions commute call operations conflicting transaction manager ensures semantic serializability serializability respect semantic commutativity relation 
approach assumption operation invocation undo backward operation 
sole purpose undo operation erase database observable effects corresponding operation invocation 
order unify concurrency control recovery commutativity defined undo operations 
able develop unified theory semantic serializability respect commutativity relation encompasses regular forward operations undo operations 
model able reason uniform manner transaction concurrency recovery standard non standard transaction concurrency recoverability models workflows transactions compensation recoverability 
practical implementation assume transaction manager supplied conflict detection method invoked operations decides operations commute 
having method facilitates extensible approach unifying serializability atomicity notions enables design transaction managers ensure serializability atomicity single algorithm 
ava similar unified model transaction management read write operations discussed 
particular authors introduced class prefix reducible schedules pred argued transaction manager generate pred schedules guarantee serializability atomicity user transactions 
papers authors concentrated traditional notion transactions issues recovery dealt issuing undo operations write operations limits transaction log kept transaction manager 
restricting model classical read write transaction model authors able provide uniform correctness criteria schedules contained explicit recovery actions aborted transactions 
generalize previous ava expanding notion transaction 
previous consider transactions arbitrary finite set operations 
approach expands traditional transaction notion including transactions defined data objects different data types adt 
develop unified approach deal concurrency failure atomicity explicitly including transaction recovery actions case include compensating operations 
transaction schedule 
ava provide constructive characterizations classes schedules serializability guarantees consistency atomicity 
started assumed generalizing results ava arbitrary set operations straightforward 
unfortunately proved simple 
turns distinguish case undo compensating operations conflict behaviour forward operations case hold 
practical consequence protocol proposed ava guarantees serializability schedules include recovery actions exploited new model 
obtain practically feasible protocols explore approaches restrict class called prefix reducible schedules ava subclass safe schedules 
discuss properties schedules argue safe schedules practically feasible allow uniform treatment serializability atomicity transaction models arbitrary set operations 
second impose restrictions commutativity relations enable constructively characterize prefix reducible schedules 
definition commutativity closely relates definitions wei wei 
wei wei definition commutativity considers effects undo related operations addition effects forward operations 
moss griffith graham mgg mgg introduced notion revokable schedules handle transaction atomicity 
show class revokable serializable schedules proper subclass reducible schedules introduced 
rastogi korth silberschatz rks rks develop theory strict schedules 
introduced notion safe schedules general notion strict schedules introduced rks rks 
extends preliminary results considering additional schedule classes providing complete proofs results announced addition designing protocols generate schedules classes schedules classes 
rest organized follows 
section introduce transaction model 
section contains main theoretical results 
section contains characterization reducible schedules introduced previous section 
section contains algorithm recognize prefix reducible schedules 
section introduces class safe schedules 
section defines restrictions commutativity relation class prefix reducible schedules constructively characterized similarly ava 
section define protocols generating safe schedules prove correctness 
section concludes 
model description section describe transaction model 
main purpose model unify concepts serializability failure atomicity concurrently executed transactions defined arbitrary finite set operations 
similarly model basic principles ffl operations defined arbitrary data types operation define undo operation undoes effects corresponding operation :10.1.1.32.8317
ffl recovery related operations undo operations explicitly transactions consequently schedule represents execution regular operations 
ffl serializability respect commutativity relation undo operations reason correctness schedules including recovery operations especially interference recovery related undo regular operations schedule 
formalize ideas discuss section notion operations defined data objects data type undo operations sole purpose recover effects corresponding operation 
model possible database states sequences allowed adt operations return values avoid explicit definition database states 
define notion effect free sequences operations notion effect free sequences undo operations 
introduce section richer notion commutativity valid simple read write operations valid arbitrary adt operations 
semantic richer notion commutativity backbone extension traditional read write model model general operations 
classical definition conflict preserving csr notion commutativity limited simple read write operations 
new richer notion commutativity classical criterion csr immediately applicable semantically rich operations 
section reconsider definitions transactions schedules criterion csr 
section complete model description expanded schedules recovery actions explicitly defined adding undo operation operation aborted transaction schedule 
consequently expanded schedule consists undo operations argue scheduler guarantees serializability expanded schedule guarantees serializability recoverability set users transactions 
furthermore consider eliminations undo pairs schedule execution operation followed corresponding undo operation leaves effect detected operations 
intuitions captured criteria reducibility prefix reducibility 
operations database db consists set data objects data type set operations called sequel forward operations 
operation invocation wei wei operation data objects input 
operation invoked executed result execution value called return value returned caller invoked operation 
wei wei operation invocation event followed operation execution event delivering return value 
generally transaction manager may interleave operations invocations executions events 
simplicity assume operations invocation execution events operations may interleave 
follows talk operation understand operation invocation 
assume addition operations special termination operations abort denoted commit denoted 
operation special operations commit abort introduce undo backward operation gamma gamma set undo operations defined operations require operation gamma gives return value back 
return values data objects reflect database state 
database states inspected return values allowed operations gamma details operation return values important model assume return value operation function changes operation performed database 
example read write model return value read value return value write value overwritten 
return values embedded sql operations insert select delete update include entire area 
return values abstraction concrete database states consider states detected return values 
operation sequences means generate detect database state 
operation sequence ff means sequence contains operations operations executed order appears sequence 
need operation invocations operation type operation sequence different labels fi write write contains write operations 
operation sequences gamma denoted oe ff fi 
particular operation sequence ff oe fi means operation sequence ff executes oe oe fi 
backward operation invoked related forward operation 
say sequence operations ff set gamma formed undo operation gamma ff preceded corresponding forward operation intuitive meaning backward operation gamma recognizable changes database backed executing corresponding operation gamma changes database caused detected operations return values undone executing gamma formalize requirement backward operations introducing definition effect free sequences 
definition call sequence operations oe effect free possible sequences operations ff fi sequences operations ff oe fi ff fi formed return values operations fi sequence ff oe fi return values operations fi sequence ff fi 
notion effect free sequences formalize requirement backward operations operation invocation corresponding backward operation invocation gamma gamma require sequence gamma effect free sequence 
requirement operation inverse operation gamma gamma sequence gamma effect free impact application designers designs forward operation provide undo operation gamma knows semantics knows undo 
note requirement implies backward operations dependent forward operation 
forward operation return value passed corresponding undo operation input parameters undo operation invoked 
example read write model write operation value overwritten write operation input parameter corresponding backward operation write gamma special case effect free sequence sequence contains operation example read operation read write model 
operation changes database 
corresponding undo operation gamma need 
backward operation effect free forward operation called null operation denoted mentioned earlier main purpose undo operations undo recognizable effects corresponding forward operations 
viewpoint undo operation successfully complete 
addition undo operations undoing forward operations forward operations reasonable assume return value undo operation 
assume return value undo operation gamma constant 
gamma return value reserved constant null 
commutativity consider formed sequence operations ff fi operation gamma permuting operations change return values return values operations fi say commute 
possible cases lead alternative definitions commutativity ffl permuting change return values regardless operation sequence ff precedes 
ffl permuting change return values ff 
define notions commutativity follows definition say operations gamma state independently commute possible operational sequences ff fi gamma ff fi ff fi formed return values operations fi return values ff fi ff fi 
definition say operations gamma state dependently commute respect operational sequence ff gamma sequence operations fi gamma ff fi ff fi formed return values operations fi return values ff fi ff fi 
say state dependently commute may mean database states permuted database states permuted 
hand saying state dependently commute means regardless database state permuted 
note sequence ff corresponds existence database state mgg mgg rks rks operations commute 
examples illustrate concepts 
commutativity matrix represent commutativity pair set operations 
examples assume operations invoked different objects commute 
matrix shows operations object commute 
note general case sql operations conflict test consider input parameters operation invocations ssw 
read write read gamma write gamma read write read gamma write gamma state independent commutativity relation example reconsider read write operations 
description operations restated ffl read return value current value object ffl write changes value object returns value overwritten 
ffl read gamma operation returning null 
ffl write gamma writes original value object back 
returns constant 
commutativity relation shown indicates operations commute gamma indicates operations commute 
illustration consider case 
indices operation sequence distinguish operation invocations type 
ffl write commute 
consider sequences oe oe 
assume value object values different 
return value sequence oe return value sequence oe obvious write commute 
commutativity relation represented special property operations commute combinations operations gamma gamma gamma gamma commute operations commute combinations operations gamma gamma gamma gamma commute 
property called introduce formally section 
property impact unified theory show 
consider simple deposit example example semantically rich operations 
symmetric property 
deposit deposit gamma gamma deposit deposit gamma gamma state independent commutativity relation example consider operations defined bank accounts 
assume account unlimited amount money amount negative ffl deposit returns constant amount money account incremented ffl withdraw returns constant amount money account decremented ffl deposit gamma returns constant performing operation withdraw 
ffl withdraw gamma returns constant performing operation deposit 
commutativity operations shown 
easy verify operations commute introduced definition commutativity 
note undo operation deposit gamma operation deposit implemented corresponding input parameters similarly undo operation gamma operation implemented deposit 
examples symmetric property commutativity relation 
example shows exist semantically rich operations necessarily property example database consist single set operations defined elements ffl insert inserts element set set operation 
returns constant inserted operation 
operation returns constant 
ffl insert gamma value inserted corresponding forward operation corresponding forward operation insert assume transaction manager maintains log able determine argument passed backward operation 
insert gamma deletes element set 
returns constant 
insert delete test insert gamma delete gamma test gamma insert delete test insert gamma delete gamma test gamma state independent commutativity relation ffl delete deletes element set set operation 
returns constant deleted operation 
operation returns constant 
ffl delete gamma value deleted corresponding forward operation corresponding forward operation delete 
delete gamma inserts element set 
returns constant 
ffl test returns constant element set returns constant 
ffl test gamma operation returning null 
shows state independent commutativity relation operations defined 
illustrate cases ffl insert state independently commute 
easy verify return values sequences delete insert insert indices distinguish different invocations operation sequence delete insert insert 
time operations state dependently commute respect sequence ff insert 
ffl insert gamma state independently commutes 
consider sequence operations ff insert gamma insert gamma fi 
insert gamma change database 
consequently return values operations fi regardless insert gamma executed followed insert gamma vice versa 
important mention commutativity operations symmetric property 
example operation insert commute backward operations insert gamma insert gamma commute 
case delete 
note operations effect free operations 
note state independent commutativity consider state dependent commutativity easily show pair operations state dependently commute insert delete 
sequences ff fi definition commutativity contain forward backward operations opposed wei wei 
give example shows important aspect 
example consider operations example 
definitions operations remain example insert 
modify definition operation insert call modified operation si ffl si inserts element set 
set operation 
returns constant 
ffl si gamma insert gamma 

consider operations si delete est example 
easy show si operations commute state dependently state independently traditional definition commutativity wei wei 

consider operations si si gamma insert insert gamma delete gamma est est gamma si si commute state independently 
operation test returns sequence delete si si si gamma est sequence delete si si si gamma est 
results valid notions commutativity 
simplify presentation rest assume state independent commutativity 
transactions database users access database transactions 
transaction partial order operations commit abort maximal element schedule set transactions partial order operations transactions transaction subset say operation executed operation schedule allow operation delta delta delta delta delta delta transaction set operation called group abort indicates abort executed transaction order aborts irrelevant 
note transaction said committed aborted contains operation 
transaction active committed aborted committed projection schedule obtained deleting operations belong committed transactions complete schedule schedule transactions terminated committed aborted 
definition operations state dependently state independently conflict state dependently state independently commute belong different transactions 
schedule set transactions require conflicting operations different transactions schedule ordered 
schedules conflict equivalent defined set transactions operations set pairs conflicting operations committed transactions 
schedule conflict serializable csr committed projection conflict equivalent serial schedule 
expanded schedules criterion conflict defined committed projection capture aborted transactions 
order handle aborted transactions explicitly schedule replace transaction abort statement sequence transaction undo operations eliminate partial effects aborted transaction call resulting schedule expanded 
scheduler produces serializable expanded schedule transaction operations adjacent gamma eliminated consideration effect schedule issues serializability atomicity treated scheduler uniform way 
assume scheduler produced far schedule 
assume point system failure occurred 
system recovered effects transactions active aborted eliminated database effects transactions committed restored database 
consequently order generate schedule contains recovery actions explicitly assume action aborted active transactions original schedule undone submitting corresponding undo operation 
formalizing ideas ava schedule define expanded schedule follows 
definition ava schedule set operations partial order operations 
expansion expanded schedule tuple 
set operations derived way transaction abort operation 
active transactions treated aborted transactions adding group abort maximal element active transactions 
aborted transaction operation exists backward operation gamma abort operation changed operation replaced sequence 
partial order determined follows operations 
transactions abort aborts ordered conflicting undo operations transactions reverse order corresponding forward operations forward operations ordered undo operations arbitrary order 
undo operations transaction commit follow transaction original operations precede 
undo operation gamma fi conflicts gamma 
gamma conflicts gamma gamma gamma say schedule reducible red exists expanded schedule transformed serializable schedule applying rules :10.1.1.32.8317
commutativity rule operations different transactions commutes order replaced 
undo rule gamma operations gamma gamma removed illustrate consider schedule delete insert est expansion delete insert est est gamma delete gamma reducible 
hand schedule delete insert est expansion delete insert est est gamma reducible 
goal obtain expanded schedule schedule design transaction manager way generates schedules expanded explicitly backward operations remains serializable application commutativity undo rules 
scheduler generate reducible schedule enable treat schedule serializability failure recovery uniform manner 
transaction manager dynamically generates schedule executed transactions 
means time schedule may contain operations active transactions 
transaction manager ensure serializability committed transactions require prefix schedule serializable sure transaction commit 
means property schedule reducibility prefix closed schedule reducible prefix reducible 
unfortunately class reducible schedules prefix closed online scheduling transactions :10.1.1.32.8317
resolve requiring schedule prefix reducible definition schedule prefix reducible pred prefix reducible 
example schedule reducible prefix reducible schedule delete insert est prefix reducible 
similarly consider class prefix reducible schedules class schedules allow unify notions transaction serializability atomicity :10.1.1.32.8317
unified transaction theory section main theoretical results 
goal provide constructive characterization prefix reducible schedules models semantically rich operations easily lead construction schedulers 
section identify conditions generalization characterization ava exact 
general case able provide constructive graph characterization prefix reducible schedules 
complexity high polynomial practical design schedulers 
define subclasses prefix reducible schedules possessing simpler characterizations amenable protocol construction 
reducible schedules characterization definition reducible schedules previous section constructive 
section provide constructive procedure decide schedule reducible 
consider pair operations gamma expanded schedule operations gamma pair eliminated undo rule 
assume operations gamma operations gamma conflicts gamma conflicts conflicts gamma eliminate pair gamma need break chain operations eliminating operation sequence undo commutativity rules 
operation sequence belongs committed transaction eliminated operation committed transaction eliminated schedule case reducible 
order reducible need know pair gamma removed schedule 
schedule expansion 
characterize reducibility schedule construct reducibility graph rg follows nodes graph operations precedes conflicts rg contains edge 
lemma operations gamma moved commutativity rule path gamma rg 
proof clearly exists path pairwise conflicting operations gamma gamma moved commutativity rule 
hand assume path 
consider operations paths coming node operations maximal preceding gamma moved gamma commutativity rule 
process applied operations conflicting gamma easily moved gamma commutativity rule 
lemma decide expanded schedule reducible procedure defined 
construct rg 

find pair nodes gamma rg path 

pair exist contains backward operations declare schedule non reducible exit 
pair exist contain backward operations exit 

pair exist remove rg edges incidental nodes remove pair 
go step 
result procedure obtain serializable schedule forward operations reducible 
reducible 
illustrate consider examples example consider schedule insert delete insert expansion insert delete insert insert gamma delete gamma insert gamma operation insert conflicts delete delete conflicts insert insert conflicts insert gamma insert gamma conflicts delete gamma delete gamma conflicts insert gamma 
reducibility graph contains path insert delete insert insert gamma delete gamma insert gamma additional edges 
path forward operation corresponding backward operation 
consequently reducible 
example consider schedule delete delete delete expansion delete delete delete delete gamma delete gamma delete gamma operation delete conflicts delete delete conflicts delete delete conflicts delete gamma 
reducibility graph contain path delete delete gamma delete gamma operation commutes 
consequently delete delete gamma eliminated graph 
remaining pairs delete delete gamma delete delete gamma eliminated graph similar way 
reducible 
construction reducibility graph requires operations number operations testing path gamma done steps 
test needs done pairs 
procedure steps repeated worst case times pairs eliminated 
complexity procedure number operations 
relatively costly procedure practical 
section consider complicated procedures allow generate relatively rich subclasses reducible schedules 
conclude section comparing class reducible schedules class revokable schedules introduced moss griffith graham mgg mgg 
definition model restated follows 
definition mgg mgg schedule revokable rv iff transactions operations precede gamma conflict aborts aborts schedule insert insert revokable reducible 
reducible schedule revokable 
schedule insert insert revokable reducible 
furthermore revokable schedule reducible 
schedule insert insert insert insert revokable reducible serializable 
appears revokable non serializable schedules reducible 
theorem revokable serializable schedule reducible 
proof prove auxiliary lemma lemma revokable schedule 
operations transactions non committed completely eliminated finitely applications commutativity undo rules 
proof lemma consider arbitrary pair forward backward operations gamma show gamma eliminated assume gamma minimal backward operation case repeat elimination minimal backward operations gamma minimal 
show pair gamma eliminated gamma minimal proceed induction number operations gamma case trivial 
assume claim true need establish consider gamma predecessor clearly backward operation assumed gamma minimal 
forward operation 
commutes gamma operations swapped induction hypothesis 
hand conflicts gamma obtain aborts consequently definition expanded schedules follows gamma gamma contradicts minimality gamma lemma proven 
continue proof theorem 
lemma operations aborted transactions eliminated commutativity undo rules 
contain eliminations operations transactions committed assumed serializable serializable consequently reducible 
schedule insert est reducible prefix reducible revokable 
containment proper 
prefix reducible schedules ava characterized class prefix reducible schedules read write model 
appears straightforward generalization result transaction model demonstrate 
redefine class schedules serializable ordered termination sot defined ava semantically rich set operations definition schedule serializable ordered termination sot serializable transactions operations precede conflict gamma conflict conditions hold 
commits commits 
gamma gamma conflict aborts aborts condition implies commit operations transactions performed order conflicting operations 
condition schedule insert insert prefix reducible 
consider insert insert prefix expansion insert insert insert gamma reduced operations insert insert gamma insert insert swapped 
second condition implies abort operations conflicting transactions performed order opposite execution conflicting operations 
condition schedule insert delete reducible prefix reducible 
conditions required schedule prefix reducible 
read write model conditions sufficient ava 
show conditions necessary ensure prefix reducibility arbitrary set operations prove prefix reducible schedule sot schedule 
theorem prefix reducible schedule serializable ordered termination 
proof assume contrary exists pred gamma sot consider cases 
consider pred condition definition sot violated 
pair operations satisfying assumptions sot definition 
assume commits case definition expanded schedules derive gamma con gamma con belongs committed transaction reducible contradicts initial assumption pred 
second case consider prefix containing applying arguments similar case derive contradiction pred 

consider pred second condition definition sot violated 
operations satisfying assumptions sot definition 
assume gamma gamma con aborts abort consider case definition expanded schedules follows gamma gamma holds con gamma con gamma gamma con reducible contradicts initial assumption pred 
assume abort commits assumptions aborts violate condition sot definition considered 
active treated implicitly aborted schedule 
arguments case apply 
containment stated theorem proper example demonstrates example database consist positive integers operations defined incr increments returns 
returns 
incr gamma return value corresponding forward operation decrements 
returns 
reset resets 
returns old value reset gamma sets value return value corresponding forward operation 
returns 
retrieve returns current value retrieve gamma operation returns empty sequence 
decr decrements returns 
decr gamma increments returns 
previous examples assume operations invoked different arguments commute limit commutativity considerations operations invoked identical arguments 
indicates placing operation pairs commute 
illustrate cases ffl operation incr commutes 
consider arbitrary operation sequences ff fi 
executing ff incr operations mutual ordering consequently return values sequences ff incr incr ff incr incr 
value remains sequences fi distinguish sequences 
case executing ff similar 
ffl operation incr commute incr gamma 
assuming verify operation retrieve returns sequence incr reset incr gamma incr retrieve returns incr reset incr incr gamma retrieve 
ffl operation incr commute decr 
assuming initially verify operation incr returns incr decr returns sequence decr incr 
ffl operation decr commutes incr gamma 
consider arbitrary sequences ff fi 
due wellformedness ff contain incr sequences ff decr incr gamma fi ff incr gamma decr fi 
sequences decr decrements returns 
assume value executing ff 
return value incr incr gamma decrements returns 
value gamma sequences fi distinguish sequences 
case return value incr established similar way 
consider schedule incr decr incr expansion incr decr incr incr gamma operation incr conflicts decr decr conflicts incr incr conflicts incr gamma 
reducibility graph contains path incr decr incr incr gamma consequently reducible 
schedule satisfies sot conditions incr gamma conflict decr incr conflict incr 
requirement schedule sot sufficient ensure prefix reducibility 
know way check schedule pred 
check prefix method described section 
process expensive highly impractical 
eliminate complexity ways followed restrict class prefix reducible schedules impose restrictions commutativity relation 
section study approach section study second approach 
incr reset retrieve incr gamma reset gamma retrieve gamma decr decr gamma incr reset retrieve incr gamma reset gamma retrieve gamma decr decr gamma commutativity relation safe schedules order show schedule prefix reducible necessary eliminate forward backward operation pairs belonging aborted transactions commutativity undo rules 
doing possible combine movements forward operations backward operations backward operations forward operations 
degree freedom fact forward operation backward operation commute different sets operations contribute difficulties pred constructive characterization 
restrict pred class class effectively handled scheduler recovery manager consider detail happens backward operation scheduled 
purpose backward operation stated earlier undo visible effects corresponding forward operation 
consider situation executing operations gamma executed 
undo effects guarantee consistency resulting schedule scheduler scheduling gamma assure operation sequence affected scheduling gamma achieved ways ffl operations conflict visible effects affected return value safely moved gamma operations subsequently eliminated undo rule 
ffl operation gamma commutes operation sequence gamma safely moved operations subsequently eliminated undo rule 
cases formalized definition definition schedule forward safe fsf backward safe bsf transactions operations abort gamma conflict conditions hold 
commits commits 
aborts gamma aborts exist forward safe schedules backward safe vice versa example demonstrates example consider schedule incr decr decr conflicts incr incr gamma commutes decr schedule backward safe forward safe 
hand schedule incr incr forward safe backward safe incr commutes incr gamma 
schedule incr decr incr incr prefix reducible forward backward safe 
recall guarantee forward safeness consider conflicting pairs forward operations 
alternatively consider conflicting pairs forward backward operations guarantee backward safeness 
assume example case transaction issues select statements transaction subsequently performs conflicting update statements 
transaction aborts commit guarantee backward safeness 
guarantee forward safeness aborted 
hand suppose example forward operations transaction followed forward operations transaction commute forward operations backward operations conflict forward operations may issue single incr operation example 
transaction aborts transaction commit guarantee forward safeness 
guarantee backward safeness aborted 
ordering commit operations backward safe schedules reflects conflicts forward backward operations forward operations backward safe schedule necessarily serializable 
example schedule incr decr incr decr backward safe serializable 
forward safe schedule serializable subclass commit ordered bs schedules turn subclass serializable schedules bs raz 
rigorous rg schedule forward safe 
hand schedule incr decr forward safe rigorous 
compare class forward backward safe schedules revokable schedules mgg mgg need revokable property prefix closed 
introduce class prefix revokable schedules follows definition schedule prefix revokable iff transactions operations precede gamma conflict true 
commits commits 
aborts aborts turns class backward safe schedules broader class prefix revokable schedules 
schedules prefix revokable backward safe 
example consider schedule insert est schedule backward safe prefix revokable 
hand prefix revokable schedules forward safe forward safe schedules prefix revokable 
class strict schedules defined rks rks schedules operations gamma conflict transaction terminates class strict schedules subclass prefix revokable consequently backward safe schedules 
hand prefix revokable schedules strict 
consider example schedule insert delete easy see strict prefix revokable 
opposed read write model relationship strict serializable rigorous schedules model semantically rich operations exist strict schedules rigorous prefix revokable serializable strict serializable backward safe serializable forward safe prefix reducible serializable ordered termination commit ordered relationship classes rigorous vice versa 
consider schedule incr decr schedule strict serializable rigorous 
similarly schedule incr incr rigorous strict 
classes forward safe serializable backward safe schedules proper subclasses prefix reducible schedules theorems show theorem forward safe schedule prefix reducible 
proof auxiliary lemma proven lemma forward safe schedule 
operations transactions non committed completely eliminated finitely applications commutativity undo rules 
proof lemma structure proof identical proof lemma 
show inductive step 
consider pair operations gamma gamma minimal operations gamma show pair eliminated immediate successor commutes swap operations induction hypothesis 
hand commute forward safeness follows committed gamma gamma gamma gamma contradicts assumption gamma minimal 
consequently gamma commutes operations gamma eliminated induction hypothesis 
completes proof lemma 
continue proof theorem 
arbitrary prefix show reducible 
forward safeness prefix closed property operations transactions non committed eliminated lemma 
forward safe commit ordered serializable raz 
remaining operations operations transactions committed serializable consequently reducible 
prefix reducible 
theorem backward safe serializable schedule prefix reducible 
proof auxiliary proven lemma backward safe schedule 
operations transactions non committed completely eliminated finitely applications commutativity undo rules 
proof lemma structure proof identical proof lemma 
show inductive step 
consider pair operations gamma gamma minimal operations gamma show pair eliminated immediate predecessor gamma commutes gamma swap operations induction hypothesis 
hand commute gamma backward safeness follows committed gamma gamma gamma gamma contradicts assumption gamma minimal 
consequently gamma commutes operations gamma eliminated induction hypothesis 
rest proof theorem proof theorem 
containments proved theorems proper example demonstrates 
relationship schedule classes discussed far shown 
normal perfect commutativity relations subsection investigate restrictions commutativity relation lead simple characterization prefix reducible schedules 
major problem deal consequence non symmetric commutativity behavior forward operation related backward operation 
section study regularity requirements commutativity behavior forward backward operations necessary simple characterization prefix reducible schedules 
definition call commutativity relation normal operations condition holds commute gamma gamma commute addition gamma gamma commute gamma consider set operations example exclusion operations decr decr gamma restricted commutativity relation example normal 
show theorem holds theorem commutativity relation normal 
schedule prefix reducible serializable ordered termination 
proof theorem proven prefix reducible schedule sot 
remains show sot schedule prefix reducible 
prove auxiliary lemma lemma serializable ordered termination schedule commutativity relation normal 
operations transactions non committed completely eliminated finitely applications commutativity undo rules 
proof lemma structure proof identical proof lemma 
show inductive step 
consider pair operations gamma gamma minimal operations gamma show pair eliminated immediate successor commutes swap operations induction hypothesis 
consider case commute gamma gamma trivially eliminated hand gamma normality commutativity obtain gamma con gamma gamma con sot commit consequently expanded schedules gamma gamma contradicts minimality gamma lemma proven 
rest proof follows precisely arguments proof theorem 
shown pred sot lemma commutativity relation normal class rigorous schedules subset class strict serializable schedules 
proof follows directly definitions rigorous strict rks schedules normality commutativity relation 
commutativity relation normal con follows gamma con gamma gamma con seen commutativity relation example normal 
difficult prove classes sot pred schedules coincide set operations defined 
theorem provide necessary condition commutativity relation guarantee classes sot pred schedules coincide 
relationship classes introduced far normal commutativity relation derived assuming pred sot class rigorous schedules subset strict serializable schedules 
obvious consequence normal commutativity relations protocols defined ava applied generate prefix reducible schedules models semantically rich operations possessing normal commutativity relation 
note condition normal commutativity relation class schedules serializable ordered termination schedules proper superset class backward safe serializable schedules bsf sr example demonstrates 
example consider schedule incr incr incr gamma incr gamma 
easy see commutativity relation example exclusion operation decr backward operation normal 
sot incr commutes incr 
hand schedule backward safe incr conflicts incr gamma incr gamma precedes incr gamma schedule 
special case normal commutativity perfect commutativity 
contrast normality requires combination backward forward operations commute combinations backward forward operations commute 
formally definition say commutativity relation perfect operations ff commutes fi possible combinations ff fi gamma fl commute ffi prefix revokable serializable strict serializable prefix reducible serializable ordered termination backward safe serializable rigorous forward safe commit ordered relationship classes perfect model possible combinations fl ffi gamma exception backward operation commuting 
guaranteed read write model undo write operation write 
shown general model property satisfied priori 
instance commutativity relation example normal perfect 
operation insert commute backward operation insert gamma commute 
seen restricted commutativity relation example normal perfect operation incr commutes operations incr incr gamma commute 
main appeal models perfect commutativity relation lies isomorphism read write model 
classes sot bsf sr schedules coincide theorem states 
theorem commutativity relation perfect 
classes serializable ordered termination backward safe serializable schedules coincide 
proof equivalence claimed theorem follows directly definitions commutativity relation 
commutativity relation perfect gamma con follows con gamma gamma con consequence commutativity relation class forward safe schedules proper subset class backward safe serializable schedules turn equal sot pred 
schedule example schedule backward safe serializable forward safe 
similarly read write model class rigorous schedules proper subset strict serializable schedules 
schedule gives example strict serializable schedule rigorous 
class strict serializable schedules remains proper subset prefix revokable schedules turn remains proper subset backward safe serializable schedules 
class strict serializable schedules remains incomparable class forward safe schedules 
schedule strict serializable forward safe schedule forward safe strict serializable 
relationship classes assumption perfect commutativity relation depicted 
shown assume general state independent commutativity relation perfect 
show obvious property holds state dependent commutativity model 
lemma operations state dependently commute respect sequence ff gamma gamma state dependently commute respect sequences ff ff respectively 
furthermore gamma gamma state dependently commute respect sequence ff proof show state dependently commutes respect sequence ff cases hold ffl operation gamma state dependently commutes respect ff claim trivially holds gamma consider case gamma state dependently commute respect sequence ff know return values sequence ff fi sequence ff fi possible sequences fi 
consider ff ff gamma effect free return values fi ff gamma fi ff fi 
state dependently commute obtain return values ff gamma fi ff gamma fi 
gamma effect free obtain return value sequences fi ff gamma fi ff fi 
addition gamma returns constant value derive return values gamma fi sequences ff gamma fi ff gamma fi claim holds 
cases arguments similar omitted 
note sequences operations ff ff ff naturally arise formedness requires previous execution talk commutativity gamma gamma protocols section protocols generating forward safe backward safe serializable schedules 
scheduler execute commutative operations concurrently 
order design scheduler conflict detection method con provided 
con return true operation invocations conflict false 
concurrency control state dependent commutativity general allow concurrency 
mechanism con decide operation invocations conflicting con know prior history 
cases possible design concurrency control mechanism 
example ad operations state dependently commute allowed run concurrently provided executed certain contexts 
conflict detection method works operation invocations independent state may require sophisticated implementation 
example con applied sql operation invocations determine read write sets predicates disjoint examples sufficient determine operation parameters equal 

operation different commit abort submitted 
insert appropriate edges nodes serialization graph 
graph contains cycle rejected submitted 
submit execution 

submitted 
predecessors serialization graph put commit queue 
submit execution 
gets executed remove serialization graph test commit queue transactions committed 

submitted 
transaction aborted 
find set transaction nodes reachable serialization graph submit execution 
executed transactions removed serialization graph commit queue 
forward safe pessimistic graph testing protocol note practical purposes require con detect conflicting pairs correctly 
need operations conflict con detect 
con may decide operations conflict definition sacrificing inter operation concurrency 
rest assume conflict detection method operation invocations imported transaction manager 
recall scheduler design point view backward safeness guarantee serializability 
backward safe protocol keep track test acyclic dependency conflicts serializability gamma conflicts backward safeness 
forward safe protocol hand needs keep track conflicts 
protocol guaranteeing serializability easily extended additional rules ordering transaction termination operations generate forward safe schedules 
forward safe protocols section describe detail forward safe pessimistic graph testing protocol show protocols generating forward safe schedules constructed 
forward safe pessimistic graph testing protocol uses serialization graph generate schedules 
ordering commit operations obey order graph ordering abort operations obey reverse order graph easily guaranteed performing group abort 
protocol shown 
illustrate forward safe pessimistic graph testing protocol consider scheduler receives sequence operations insert insert insert insert receiving prefix insert insert insert insert serialization graph contains edges 
operation received transaction put commit queue active 
time received transaction commits node edge removed serialization graph 
commit predecessor terminated 
received aborted submitting 
show protocol generates forward safe schedules suffices show operations satisfying assumptions definition holds commits aborts parallel single group abort 
operations satisfy assumptions definition active serialization graph contains edge 
committed edge removed 
consequently commit due point protocol active held commit queue terminates 
similarly aborts aborted case removed serialization graph aborts single group abort due point protocol 
removal nodes corresponding committed transactions point protocol lead non serializable schedules sinks serialization graph removed pap 
nodes removed graph point protocol correspond aborted transactions irrelevant serializability maintenance 
forward safe pessimistic graph testing protocol generates forward safe schedules 
protocol delays transactions necessary show lead deadlocks 
transaction waits predecessors serialization graph order commit serialization graph guaranteed acyclic times deadlock impossible 
transaction remains commit queue predecessors commit case commits aborts case aborted 
different protocols different paradigms constructed 
firstly difficult see optimistic version forward safe serialization graph testing protocol easily obtained performing acyclicity test serialization graph lazily point point protocol 
similarly non blocking version protocol obtained modification point protocol exists predecessor serialization graph putting commit queue reject submit 
possible extend existing protocol phase locking timestamp ordering rules protocol generate forward safe schedules 
combination blocking caused waiting lock blocking caused waiting execute commit point protocol lead deadlocks 
transaction waits transaction release lock data item serialization graph contains edge 
similarly transaction waits transaction commit serialization graph contains edge 
cycle wait graph cycle serialization graph 
reader probably noticed point protocol may lead cascading aborts abort transaction may necessitate abort transactions order guarantee forward safeness schedule 
turns class rigorous schedules maximal subclass forward safe schedules avoiding cascading aborts 
theorem class rigorous schedules maximal subclass class forward safe schedules avoiding cascading aborts 
proof clearly scheduler generating forward safe schedules abort transactions reachable aborting transaction serialization graph forward safeness violated 
serialization graph contains isolated nodes times schedule rigorous cascading aborts 
time violation leads cascading aborts transaction abort time 
class rigorous schedules maximal subclass forward safe schedules avoiding cascading aborts 
cascading aborts price paid increased concurrency forward safe schedules respect rigorous schedules 
reasonable ask possible limit number transactions aborted consequence aborting single transaction retaining relatively high degree concurrency 
possible way limit number cascading aborts bound length path serialization graph constant transactions aborted time 
operation different commit abort submitted 
perform phase locking test 
fails rejected submitted 
delayed waiting lock trigger appropriate deadlock detection method 
add node termination graph 
exists operation non aborted transaction gamma conflict add edge termination graph 

submitted 
test edges incident termination graph obey timestamp order source edge smaller timestamp sink 
reject submit 
test edges coming reject submit 
submit execution 

submitted 
transaction aborted 
find set transaction nodes reachable serialization graph submit execution 
executed transactions removed serialization graph commit queue 
backward safe hybrid protocol consequence abort transaction modification required protocol point path longer appear serialization graph consequence scheduling operation point protocol transaction delayed deadlock detection initiated aborted 
setting reduces class schedules recognized modified protocol class rigorous schedules 
grows degree concurrency grows large class schedules recognized modified protocol approximates class forward safe schedules 
number transactions may need aborted result abort transaction recovery costs grow way limiting number cascading aborts decrease conflict rate forward operations state dependent commutativity liberal state independent commutativity 
backward safe protocols backward safeness guarantee serializability backward safe protocols guarantee backward safeness serializability 
serializability guaranteed maintaining acyclic serialization graph 
addition protocol maintain termination graph order commit abort operations 
define termination graph follows nodes graph non aborted transactions operations abort gamma conflict add oriented edge clearly graph contains edge commit abort parallel single group abort 
implies committed projection termination graph acyclic times contained cycle backward safeness derive contradiction 
acyclicity serialization termination graphs maintained possible combination pessimistic optimistic blocking non blocking graph testing phase locking timestamp ordering protocols 
illustration show backward safe protocol pessimistic blocking phase locking guarantee serializability optimistic non blocking timestamp ordering guarantee backward safeness 
illustrate protocol assume scheduler receives sequence operations incr incr incr incr assume timestamps transactions order ts ts ts 
assume transaction releases locks submits commit abort operation phase locking serializability test admits prefix incr incr incr incr conflicts forward operations 
point termination graph contains edges 
operation received gets submitted execution ts ts edges coming node termination graph 
edge node removed termination graph executed 
received rejected submitted edge coming node termination graph 
expanded abort additional transactions followers termination graph 
immediately scheduled execution termination graph contains time single node similarly forward safe pessimistic graph testing protocol protocol lead cascading aborts 
turns strict schedules maximal subclass backward safe schedules avoiding cascading aborts theorem class strict schedules maximal subclass class backward safe schedules avoiding cascading aborts 
proof similar theorem 
methods limiting number cascading aborts mentioned context forward safe protocols applied 
way introduced backward operations section implies backward operation depends corresponding forward operation depend operations executed forward backward operation 
done simplify way recovery system performs undo remembering old values corresponding forward operation changed 
willing pay extra price complexity backward operations 
conflicts consequently cascading aborts disappear 
illustrate consider example example consider different implementation backward operation operation insert example 
assume backward operation depends corresponding forward operation operations invoked object set forward operation 
assume backward operation passed return values non aborted insert delete operations invoked set forward operation 
backward operation perform update database provided insert delete executed forward backward operation effects forward operation 
operation backward operation undoes effects corresponding forward operation forward operations previously deferred 
implementation backward operation commutes insert delete 
commute est 
cascading aborts transactions invoked est forward operation issued 
discussed unified correctness criterion class prefix reducible schedules guarantees transaction serializability atomicity framework general model semantically rich operations 
demonstrated class schedules serializable ordered termination introduced ava characterize prefix reducible schedules general case 
complexity exact characterization prefix reducible schedules model semantically rich operations stems arbitrary commutativity behavior operations undo operations 
identified conditions model characterization exact 
shown normal commutativity relations class schedules serializable ordered termination schedules sot class prefix reducible schedules coincide perfect commutativity relations general model isomorphic read write model 
general case argued practically feasible classes schedules allow uniform treatment atomicity serializability classes forward safe schedules serializable backward safe schedules 
believe cases unified treatment transaction atomicity serializability models semantically rich operations important distributed database environments transaction considered partial order different local sub transactions 
sub transaction turn considered operation 
prove correctness execution transactions failure prone distributed database environment formal model transactions developed 
model multilevel transactions bbg wei widely accepted modeling operations data types correctly executed requiring serializability read write operations 
shown wei correctness entire multilevel schedule certain restrictions reduced guaranteeing correctness level respect operations level 
operations general read write accesses pages postulates need investigation single level models arbitrary set operations 
acknowledgment authors gerhard weikum numerous inspiring discussions valuable comments observations anonymous referee remarks led significant improvement presentation 
ad jean 
unified approach distributed concurrency control 
won kim lochovsky editors object oriented concepts databases applications acm press 
addison wesley publishing 
ava alonso agrawal breitbart abbadi 
schek weikum 
unifying concurrency control recovery transactions 
information systems 
bbg beeri bernstein goodman 
model nested transactions systems 
journal acm 
breitbart georgakopoulos rusinkiewicz silberschatz 
rigorous transaction scheduling 
ieee transactions software engineering 
br badrinath ramamritham 
semantics concurrency control commutativity 
acm transactions database systems march 
bs breitbart silberschatz 
strong recoverability multidatabase environments 
proceedings ride ieee 

schek weikum 
semantics multilevel transaction management federated systems 
proc 
th int 
conf 
data engineering houston texas 
hh hadzilacos hadzilacos 
transaction synchronization object bases 
proc 
acm principles database systems 
hh hadzilacos hadzilacos 
transaction synchronization object bases 
journal computer system sciences 
lynch merritt weihl fekete 
atomic transactions 
kaufmann san mateo ca 
mgg moss graham 
abstraction concurrency control recovery management revised 
tech 
rept 
coins technical report university massachusetts amherst march 
mgg moss graham 
abstraction recovery management 
acm sigmod conference 
pap papadimitriou 
theory database concurrency control 
computer science press 
raz raz 
principle commitment ordering guaranteeing serializability heterogeneous manager atomic commitment 
proc 
th international conference large data bases 
rks rastogi korth silberschatz 
strict histories object database systems 
technical report matsushita information technology laboratory 
rks rastogi korth silberschatz 
strict histories object database systems 
symposium principles database systems 
ssw 
schek weikum 
implementation performance multi level transaction management multidatabase environment 
proc 

int 
workshop research issues data eng distributed object management taipei taiwan 
:10.1.1.32.8317
schek weikum ye 
unified theory concurrency control recovery 
proc 
acm principles database systems 
ye breitbart 
schek 
unified transaction model semantically rich operations 
database theory icdt lncs 

weikum 
schek 
open nested transactions federated database systems 
ieee data engineering bulletin 
wei weihl 
commutativity concurrency control data types 
ieee transactions computers 
wei weihl 
impact recovery concurrency control 
proc 
acm principles database systems 
wei weikum 
principles realization strategies multilevel transaction management 
acm transactions database systems 

