nordic journal computing constraint inter procedural analysis parallel programs helmut seidl fb iv informatik universit trier trier germany seidl uni trier de bernhard ste en lehrstuhl ur universit dortmund stra dortmund germany bernhard steffen cs uni dortmund de 
provide uniform framework analysis programs procedures explicit unbounded fork join parallelism covering bitvector problems reaching de nitions live variables non bitvector problems strong copy constant propagation 
due structural similarity sequential case resulting algorithms ecient widely accepted sequential counterparts easily integrated existing program analysis environments pag 
convinced method soon nd way industrial scale computer systems 
keywords inter procedural program analysis explicit parallelism bitvector problems strong copy constant propagation coincidence theorems 

analysis parallel programs known notoriously hard problem 
procedures bounded parallelism analysis typically su ers called state explosion problem general required control structures grow exponentially number parallel components 
bitvector analyses dominant practical compilers escape problem context fork join parallelism simple pre process sucient adapt sequential intra procedural bitvector analyses directly parallel ow graphs concisely explicitly represent program parallelism 
key adaptation change property analysis directly associating program points properties ect analysis associating program points property transformer resembling ect preceding program fragment 
simplicity adaption results fact bitvector analyses second order analysis terminology 
received december 
conceptually sliced separate analyses individual requires consideration point transformer domain 
setting allowed elegantly solve central problems inherent analysis parallel programs interference parallel components treated checking existence gen kill terminology parallel components trivially linear task 
synchronization join nodes reduces simple operation de ned individual ects involved parallel components 
order handle procedures unbounded parallelism esparza knoop observed described problem pro le admits automata theoretic treatment 
observation carefully developed esparza podelski 
come back approach second part discuss merits re ned program analysis 
perspective classical program analysis constructions impractical 
require involved automata constructions return desired results indirect way determining values program points directly reachability analysis rst computes descriptions sets called process trees corresponding particular property program point 
bit component analysis tree automata construction required linear product size program size automaton describing reachable process trees 
automaton grow linearly size program implying analysis component quadratic program size 
direct framework inter procedural analysis fork join parallel programs 
propose constraint approach naturally arises algebraic reformulation intraprocedural method 
approach closely resembles classical understanding bitvector analysis complexity linear program size admits elegant algebraic proofs 
summarizing contribute state art providing uniform characterization captured analysis pro le simultaneously addresses involved program entities program variables live variable analysis program expressions availability expressions 
pro le goes pure bitvector analyses captures strong copy constant propagation 
basing development constraint characterization valid parallel execution paths 
constraint system actual analyses simply results interpretation characterization 
presenting framework supports algebraic reasoning 
particular proof prop 
resembling central main lemma straightforwardly evolves pro le characterization 
guaranteeing essentially performance purely interprocedural bitvector analyses exploiting results generalized possible interference analysis 
consequence framework tightly tailored intended application area 
directly associates program points required information classical constraint solving worklist xpoint iteration 
exploited obtain simple implementations current program analysis generators dfa opt pag provide required xpoint iteration machinery 
constraint systems discussed control structure oriented implies joins control ow typically impose loss information 
common classical program optimization scenario guarantees control program size optimized program 
motivated task eliminate partial redundancies impossible signi cantly altering control structure proposed property oriented approach intra procedural program analysis totally avoids loss information join nodes cost node splitting 
central problem property oriented expansion potential code size explosion case partial redundancy elimination worst case exponential 
practice optimization behave better 
perspective automata theoretic approach regarded step property oriented inter procedural program analysis optimization fork join parallel programs re nes control structure oriented analysis separating scenarios single program locations basis considered program property 
re ned information terms called process trees classical structure oriented optimization may steer unfolding recursion order increase optimization potential 
second part elaborates idea presenting constraint system execution trees 
execution trees considered re nement process trees tailored capture required information inter procedural program analysis fork join parallel programs 
turns approach ecient automata theoretic approach sense able proof complexity bound proved constructions 
organized follows 
formally introducing explicitly parallel programs procedures section de ne notion parallel execution paths section specify analysis problem section 
section presents precise ect analysis procedures basis precise inter procedural reachability analysis section 
section discusses possible extensions formal development 
section considers re nements analysis questions consideration 
introduces concepts partial execution trees process trees main jj fig 
example control ow graph 
provides ecient algorithms construct regular constraint systems result 
section gives perspectives 

programs control ow graphs assume programs annotated control ow graphs cfg short 
edge cfg call single procedure parallel call procedures basic computation step 
example cfg gure 
visualized annotation call parallel call edges 
observe cfg introduces unbounded number instances procedure running parallel 
formally control ow graph program procedures explicit parallelism consists nite set proc procedures collection proc disjoint intra procedural control ow graphs 
assume special procedure main program execution starts 
intra procedural control ow graph procedure consists set program points special entry point special return point set edges subset call edges call denotes edge calls procedure nally subset parallel call edges call jj denotes edge calls procedures parallel 
edges contained called basic edges 
practical just convenience allow binary parallelism programs 
methods easily adapted procedures called parallel parallel loops 
note consider synchronization parallel threads barriers semaphores 
constructs limit amount possible execution paths 
ignoring may get possible execution paths precise safe analysis results 

parallel execution paths semantics parallel program determined set parallel execution paths 
going formalize interleaving semantics executable threads 
need auxiliary de nitions 
denote nite set edges 
word fi ng subset positions restriction wj interleaving subsets de ned fw wj wj denotes disjoint union sets 
consists possible interleavings sequences furthermore pre denote set pre xes words pre fu uv mg consider sets possible execution paths proc set execution paths program point procedure set paths starting entry point reaching level path returned subsequently entered procedure 
procedure set paths starting call main reaching call program point set paths starting call main reaching program point sets solutions constraint systems variables simplicity denoted 
start de ning constraint system sets level execution paths 
return point entry point procedure 
feg basic edge 
calls 
calls jj binary operator 
denotes concatenation sequences extended sets sequences 
lines standard lines determine sets execution paths known inter procedural analysis sequential programs 
line says set execution paths procedure set level paths reaching return point line says level execution path reaches entry point procedure 
line says basic edge set level execution paths reaching program point subsumes level execution paths extended line says edge calling procedure set level execution paths reaching program point subsumes level execution paths reaching extended execution path procedure line parallel call jj form line 
level execution paths program point call extended interleavings execution paths order specify sets introduce auxiliary sets program point procedure give sets execution paths reaching call auxiliary sets de ned solution system constraints program point procedure 
calls 
calls jj line pre 
intuition de nition follows 
line says program point procedure set execution paths subsumes level execution paths line says edge body procedure procedure called set execution paths subsumes computation paths consisting level execution path program point followed execution path line considers edge body parallel call append level execution paths interleavings execution paths pre xes level execution paths parallel procedure 
de ne values solution main program point edge calls jj jj assume sets execution paths non empty 
section explain assumption removed 

semantics denote complete lattice subset monotonic functions contains 
constant function identity closed composition upper bounds 
meant specify set properties describes possible ways properties may transformed passing program point 
additional assumption distributive au btc auc holds height ascending chain elements length set consists functions form aux tb distributive functions distributive mention demanded nite 
projection height lattice height 
prominent class problems satisfy restrictions bitvector problems available expressions reaching de nitions life variables busy expressions 
cases may choose 
analysis problems meet assumptions bitvector problems 
case strong copy constant propagation 
strong copy constant propagation tries determine constant assigned variable remains unchanged 
application may choose set program variables lattice possible values program variables 
value represents assignment program variables values 
particular height 
note furthermore strong copy constant propagation functions operate value program variable separately 
component wise transfer function special form consider assignment statement program variable 
component wise transfer functions corresponding edge control ow graph 
conclude ascending chains functions strong copy constant propagation length 
denote set edges denote assignment functions edges 
extend sequences sets natural way mg especially 
element functions called ect sequence set respectively 
rest assume assignment basic edge input program 
program analysis tries compute approximations values ects procedures procedure ect denotes ect set level execution paths reachability start value program point procedure reach reach denote upper bounds values reaching execution paths main upper bound values reaching calls respectively 
system values called merge paths solution abbreviated mop solution analysis problem 
respective sets execution paths typically nite clear solution computed ectively 
standard approach proposed data ow analysis interpretation consists putting set constraints values interested 
constraints chosen way solution guaranteed represent safe approximation values 
quite frequently solution equals mop solution :10.1.1.54.7108
speak coincidence solutions meaning precisely characterizes mop 
application constraint system solution represents sets execution paths evaluated 
inspecting constraint system naturally try obtain constraint systems ect analysis reachability just abstracting lattice sets paths lattice ordering set inclusion sets paths mapped ordering set union concatenation mapped upper bounds composition functions 
abstraction mapping properties proposition 
holds 
non empty 
proposition suggests direct translation constraint system sets execution paths constraint system aiming 
obstacles direct translation interleaving operator simplicity denoted way deal pre xes 
lattices problems turn surprisingly simple solutions 
de ne interleaving proposition 
holds non empty subsets proof proposition see appendix particular statement proposition interpreted considering possible interleavings parallel components suces consider possibilities sequential compositions 

ect analysis prerequisites constraint system ect analysis 
solution constraint system de nes values ect procedures values ects level execution paths reaching program point return point entry point basic edge calls calls jj lines lines determine ects procedures known inter procedural analysis sequential programs 
line says ect procedure ect accumulated return point line says accumulation ects starts entry points procedures identity function line says contribution basic edge value value extended application function associated edge 
line says contribution edge calling procedure determined analogously di erence function line replaced ect called procedure 
line parallel call form 
order determine combined ect executed procedures rely interleaving operator 
constraint system ect analysis direct abstraction corresponding constraint system level reaching paths section 
obtain distributivity involved operators theorem 
solution ect constraint system precisely describes ect procedures ect ect procedure program point values computed time 
height complete lattice size program 

constraint system reachability ect analysis mimic xpoint de nition sets reaching execution paths corresponding constraint system observe de ning constraint system reaching execution paths section quadratic size 
clearly improve possible sacri cing precision 
consider set pre pre xes non empty set key observation proposition 
em denote edges occurring elements em pre fb em intersections disappeared 
remains upper bound values proof proposition appendix accumulating ects topdown fashion necessary precise de nition reaching execution paths prefer bottom accumulation strategy commonly inter procedural analysis sequential programs 
accumulation directly starts main program successively proceeds called procedures 
program point denote upper bound basic edges possibly executed parallel value called possible interference furthermore auxiliary values procedure calculate upper bound basic edges possibly executed evaluation values determined solution constraint system basic edge procedure procedure calls jj jj program point calls procedure calls jj calls jj system computing values linear size uses operation right hand sides 
kind problems known pure merge problems solved linear time 
construct constraint system inter procedural reachability analysis sequential programs program point additionally take possible interference account 
consider values program point procedure determined solution constraint system main program point procedure calls jj jj line di erence corresponding constraint system reachability sequential programs 
intuition constraint system follows 
line says initially value reaching main subsume initial value line says value reaching program point subsume possible interference 
line says program point procedure reaching value subsume intra procedural ect applied value reaching line nally says value reaching procedure subsume value program point call possibly parallel call possible 
constraint system di ers considerably constraint system sets reaching execution paths 
able prove theorem 
constraint system computes precise reachability information reach reach program points procedures values computed time 
height complete lattice size program 
proof see appendix theorem implies programs procedures parallelism harder analyze programs procedures parallelism 

extensions section discuss issues important practical applicability results 
claim section contains new ideas constructions 
want emphasize constructions known inter procedural analysis sequential programs extended parallel programs straight forward way 
non reachable program points far assumed program point reachable execution path 
order show assumption vital abandon assumption 
denote sets possibly terminating procedures reachable program points respectively 
order compute sets instantiate generic analysis basic edge function initial value equals 
functions occurring analysis functions strict preserve element 
obtain proposition 
procedure program point holds 
particular 
conclude sets computed linear time 
non reachable program point uence program point 
modify cfg removing edges starting program points edge removal sets reaching execution paths changed 
call resulting cfg normalized 
obtain theorem 
assume cfg normalized 
program point procedure ect ect reach reach 
conclude preprocessing step normalization constraint systems compute safe approximation precise 
practical normalization cfg may remove edges constraints constraint systems analysis 
omitting normalization may result precise safe analysis 
backward analysis discussed far called forward analysis 
examples forward analysis problems reaching de nitions available expressions strong copy constant propagation 
important analyses determine value program point possible set reverses execution paths possibly visit examples live variables busy expressions 
analyses called backward analyses 
case forward reachable program point backward reachable lies execution path start point return point main reduce backward analysis forward analysis simply normalizing cfg followed reversal edge orientations exchange entry return points procedures 
local global state consider edge cfg calls terminating procedure treatment terminating parallel call procedures completely analogous 
far complete information program point passed entry point adequate analyzing global properties availability expressions depend global variables 
immediately applicable presence local variables visible caller hidden callee meaning survive call unchanged :10.1.1.54.7108
things precise assume describe local global properties respectively 
assume global part current state passed parameter returned result call local part program point call passed call transformer recall form cartesian product implies independently operate local states global states respectively 
obviously independence hold general inter procedural analyses 
speci consequence special form transfer functions consideration 
due independence separate analysis phases 
rst phase considers just global values local state need preserved call original call edge 
second phase purely intra procedural deals lattice call edge ect local state simply change basic edge 
re ning analyses concentrating safe approximations capturing values reaching certain program point certain position argument program code 
re ned analysis going section avoids collapse weaken information belonging program point qualifying computed information characterizations relevant context 
seen generalization property oriented expansion approach 
loss information join nodes avoided node splitting meet operation lead proper loss information target node split order able maintain full information separately di erent contexts 
power approach apparent looking partial redundancy elimination automatically approach leads elimination partial redundancies 
elaborating idea setting inter procedural analysis fork join parallel programs 
setting longer possible characterize relevant contexts simply means separating versions considered program points 
characterizations additionally keep track nesting procedure calls state concurrent computations 
technically extra information program con guration value may occur represented tree 
convenient way representing possibly nite sets trees provided nite tree automata regular constraint systems 
regular constraint systems ensure ecient algorithms basic problems determining set constraint variables corresponding sets solution non empty contain speci tree contained regular set non empty intersection regular set 
re ned reachability considered interested determining program points values sets process trees possibly reaching corresponding program executions result values bounded process trees tree generalizations call stacks describing set currently active parallel processes 
generalization property oriented expansion requires precise context information 
program points values compute set program executions reaching resulting values bounded execution trees process trees program execution paths de ned section capture information nesting procedure calls state parallel executions 
insucient provide basis re ned analysis 
consider enriched structure execution trees designed capture required information 
example execution tree program shown 
intuitively executions represented tree left right depths rst pre order tree traversals 
basic execution steps represented nodes predecessor 
binary nodes introduced procedure calls 
rst subtree node represents execution call second subtree gives execution called procedure 
example tree execution procedure main starts leftmost leaf basic edge followed call procedure edge 
consequently right subtree represents execution execution starts leftmost leaf corresponding subtree basic edge followed parallel call procedures edge 
fig 
represents full execution considered example program 
structure easily adapted capture notion main jj fig 
execution tree main 
program point certain context 
accordingly trees describing program executions reach certain program point 
example tree 
idea introduce extra binary nodes barred nodes calls evaluation started completed reaching program point question 
resulting tree called partial execution tree 
program point reached partial execution tree program point reach inside procedure process currently focus 
convention procedures entered process focus identi ed leftmost leaf 
call main jj fig 
partial execution tree reaching node 
procedure main entered followed calls procedure current program point endpoint edge 
parallel second call call procedure spawned 
corresponding subtree empty tree conclude represented scenario far edge traversed inside advantage tree representations apparent nesting structure calls explicit able restore parts current local state completed call 
formal treatment interpret set edges ranked alphabet basic edges call edges ranks respectively 
furthermore need nullary symbols denoting empty tree empty partial tree respectively binary symbol jj written notation call edge new symbol rank denoting call entered completed 
formal parallel execution trees partial trees represented expression trees follows jj jj jj jj partial execution tree represents set possible parallel execution sequences 

jj mapping extended sets partial trees fi xg procedures program points consider sets trees sets parallel execution trees respectively sets partial parallel execution trees reaching respectively 
sets de ned solutions constraint systems 
return point entry point procedure basic edge calls jj calls jj line says set execution trees procedure set execution trees return point line says empty tree execution tree entry point procedure 
line says basic edge set execution trees program point subsumes execution trees extended line says edge calling procedure set execution trees program point subsumes execution trees extended execution tree procedure line says edge calling procedures parallel set execution trees program point subsumes execution trees extended pair execution trees respectively 
accordingly sets reaching partial execution trees solution calls jj jj main program point calls jj jj calls jj entry node basic edge calls jj calls jj program point calls jj calls jj lines reduce sets partial reaching execution trees sets partial execution trees reaching relative procedure lines explain sets relative partial execution trees determined 
constraints auxiliary groups sets program point procedure 
sets de ned lines 
represent partial execution trees reaching relative procedure sets de ned lines represent pre xes computations running parallel process currently consideration 
xpoint induction verify proposition 
procedures program points proposition semantics programs execution paths understood abstraction semantics execution trees 
main jj fig 
process tree corresponding fig 

turn concept process trees 
internal nodes process trees denote entered completed calls splittings current process sub processes sequence leaves form snapshot currently running processes 
process tree corresponding partial execution tree shown 
note process trees consider edges unary tree symbols 
intuitively process tree corresponding partial execution tree obtained removing un barred nodes 
just barred nodes retained correspond entered nished calls 
jj nodes combine trees active processes running parallel 
furthermore current program point process focus represented program points reached parallel recorded leaves 
example program point reached parallel far edge traversed inside entry point describe concepts formally 
process trees parallel program represented expressions form jj jj jj denotes program point current process denotes possibly parallel call edge program point procedure called parallel omitted barring edges 
formally de ne extraction process trees partial computation trees basic edge call edge calls jj jj calls jj jj jj calls jj entry point transformation seen deterministic topdown linear tree transduction partial execution trees process trees 
extend transformation sets partial trees fc tg program point denote set process trees possibly occurring brevity henceforth state assertions just program points omit corresponding assertions procedures 
constraint system seen regular tree grammar nite state tree automaton constraint variables nonterminals states 
call constraint system regular 
technically constraint system sets trees regular right hand sides constraints built constraint variables constant sets trees application tree constructors 
conclude sets regular tree languages 
known regular tree languages closed application nite state linear tree transductions 
consequently sets regular 
formalizing re ned reachability analysis consider domain set transfer functions form aux tb section 
assume analysis initial value mapping basic basic edges transfer functions 
additionally assume lattice nite 
basic re ned reachability question consists determining program points values sets ft dg partial execution trees possibly reaching corresponding interleavings result values bounded information perfect control possible history guaranteeing certain value 
related analysis problem esparza certain sense ambitious asks sets fc dg process trees possibly reaching corresponding interleavings result values bounded applicable lattices 
order relate re ned analysis problems partial execution trees process trees respectively observe proposition 
program point 
due basic observation rst solve re ned analysis problem partial execution trees derive regular constraint system sets 
regular constraint systems sets obtained just application linear transduction 
order construct regular constraint system sets de ne evaluation mapping partial execution trees upper bound ects corresponding execution paths 
mapping basic edge call edge jj obviously proposition 
partial execution tree 
evaluation function seen bottom deterministic nite tree automaton set states regular tree languages closed intersection 
constraint system reaching partial execution trees allows construct regular constraint system partial execution trees reaching program points states bounded gives main theorem theorem 
program point value sets regular 
regular constraint systems sets computed time 

jf size program number occurring procedures 
particular jf obtain quadratic algorithm 
note obtain explicit upper complexity bounds tight sense match sizes produced output structures 

shown extend intra procedural method uniformly eciently capture inter procedural bitvector analyses fork join parallel programs 
method comprises analysis problems available expressions live variables strong copy constant propagation passes test practicality behaves widely accepted algorithms sequential inter procedural program analysis 
precision proved fork join parallelism algorithm may computing safe approximations languages arbitrary synchronization statements 
due structural similarity sequential case easily integrated program analysis environments pag contain necessary xpoint machinery 
showed go classical program analysis characterized structure argument program 
contrast re ned analysis regarded generalization intra procedural approach property oriented setting procedures fork join parallelism 
focus structure argument program 
provides information tailored establish appropriate program structure considered optimization goal 
technically classical results regular tree languages speci properties derived program point value representation sets partial execution trees sets process trees yielding values bounded convinced gained precision basis numerous program optimization techniques 
martin alt florian martin 
generation ecient interprocedural analyzers pag 
proceedings nd static analysis symposium sas pages 
lncs springer verlag 
patrick cousot 
semantic foundations program analysis 
steven muchnick neil jones editors program flow analysis theory applications chapter pages 
prentice hall englewood cli new jersey 
patrick cousot radhia cousot 
interpretation uni ed lattice model static analysis programs construction approximation fixpoints 
proceedings th acm symposium principles programming languages popl pages 
acm press 
patrick cousot radhia cousot 
static determination dynamic properties recursive programs 
neuhold editor formal descriptions programming concepts pages 
north holland publishing 
esparza knoop 
automata theoretic approach interprocedural data ow analysis 
fossacs volume lecture notes computer science lncs pages 
springer verlag 
esparza podelski 
ecient algorithms pre post interprocedural parallel flow graphs 
acm international conference programming languages popl pages 
hecht 
flow analysis computer programs 
computer science library 
north holland new york 
knoop 
parallel constant propagation 
th european conference parallel processing euro par volume lecture notes computer science lncs pages 
springer verlag 
knoop ste en 
tool kit automatic generation interprocedural data flow analyses 
journal programming languages december 
chapman hall london uk 
knoop ste en 
interprocedural coincidence theorem 
th international conference compiler construction cc volume lecture notes computer science lncs pages 
springer verlag 
knoop ste en 
parallelism free ecient optimal bitvector analyses parallel programs 
acm transactions programming languages systems 
morel renvoise 
global optimization suppression partial redundancies 
communications acm cacm 
seidl 
interprocedural analyses comparison 
journal logic programming jlp 
ste en 
property oriented expansion 
proceedings nd static analysis symposium sas pages 
lncs springer verlag 
appendix proof proposition consider functions calculate giving statement 
accordingly statement proof statement non empty subsets statement 

remains prove reverse inequality 
consider disjoint index sets mg wj claim clearly claim implies statement proposition 
order prove claim ux tb ux tb de nition am consider value de nition am show am assume case completely analogous fj fj kg 
am jr implies assertion 
appendix proof proposition em denote set elements occurring furthermore fb em rst show pre pre 
proceed induction length 
consequently assume 
induction hypothesis completes proof 
proof reverse inclusion rst observe pre pre 
furthermore em nd pre pre 
consequently pre em pre completes proof 
appendix proof theorem start simple useful observation proposition 


reformulate constraint system reachability follows 
introduce new values program point procedure collect upper bounds directly reaching values ignoring possible interleavings execution paths possibly executed parallel 
values determined solution constraint system main program point procedure calls jj jj standard xpoint induction nd proposition 
program points procedures order understand nature values consider sets edges possibly executed parallel program points determined solution constraint system feg basic edge procedure procedure calls jj jj program point calls procedure calls jj comparison constraint system de nition values section obtain proposition 
procedure program point 
proposition 
procedure pre order simplify proof theorem assume calls parallel calls jj assumption incur restriction ordinary call procedure easily simulated call jj procedure just single program point edges 
furthermore suces prove assertion theorem just program points assertion procedures immediate consequence 
want prove program point value safe approximation value reach reach 
de nition reach main main 
program points um execution paths wm execution paths procedures indices um calls jj program point main program point pre fw 
fw fw 
fw 
fw 


proposition pre 
proposition 






conclude 
wanted prove 
remains prove reverse inequality reach reach 
rst consider inequality 
value upper bound values exit program points um execution paths wm procedures indices um calls jj program point main program point wm induction nd wm wm main reach wanted prove 
consider inequality 
proposition 
suces prove edge reach 
exist program points um execution paths wm procedures indices index mg execution path um calls jj program point main program point pre 
conclude wm 
de nition wmw case main wmw main conclude wmw wmw reach completes proof 

