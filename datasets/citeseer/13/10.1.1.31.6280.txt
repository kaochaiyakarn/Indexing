argumentation theoretic proof procedures default reasoning october dung division computer science asian institute technology po box thailand dung cs ait ac th kowalski toni department computing imperial college queen gate london sw bz uk ftg doc ic ac uk de ne proof procedure default reasoning 
proof procedure applies logic default reasoning de ned argumentation theoretic framework 
framework includes default logic logic programming autoepistemic logic non monotonic modal logic certain instances circumscription special cases 
framework understood generalisation theorist default reasoning general understood extending theory formulated monotonic logic defeasible set assumptions 
assumption defeated attacked contrary proved possibly aid con icting assumptions 
standard stable semantics logics default reasoning understood sanctioning set assumptions extension theory set assumptions attack attacks assumption set 
focus proof procedures admissibility semantics liberal stable semantics 
sanctions set assumptions attack defends attacking set assumptions attacks 
de ne proof procedure admissibility form logic program derive speci cation expressed logical form means standard logic program transformation techniques 
derivation guarantees correctness proof procedure 
show proof procedure complete 
consider concrete instances proof procedure logic pro gramming case prove existing proof procedure logic programming derived proof procedure means standard logic program transformation techniques 
discuss implementation related issues 
shown logics default reasoning understood special cases single framework argumentation theoretic interpretation semantics logic programming abstractions extending theorist 
particular shown standard stable semantics logics default reasoning understood sanctioning set assumptions extension theory formulated monotonic logic set assumptions attack attacks assumption set 
terms assumption attacked contrary proved possibly aid con icting assumptions 
call semantics stable semantics generalises stable expansion semantics autoepistemic logic stable model semantics logic programming 
proposed new semantics logics default reasoning liberal stable semantics generalising admissibility semantics logic programming 
terms set assumptions admissible extension theory formulated underlying monotonic logic attack defends attacks attacking sets assumptions attack 
admissibility semantics general stable semantics sense set assumptions sanctioned stable semantics maximal respect set inclusion set assumptions sanctioned admissibility semantics 
maximal admissible set assumptions stable 
global character stable semantics renders computationally unfeasible general 
show sentence justi ed stable semantics necessary construct stable set assumptions initially theory monotonically implies sentence 
purpose necessary perform global search assumptions language determine assumption contrary derived independently sentence justi ed 
despite computational number proof procedures computation stable semantics proposed concrete formalisms mainly logic programming default logic 
proof procedures de ned highly restricted cases propositional nite theories undermines practical applications 
recognition problem survey non monotonic reasoning brewka dix konolige state 
research eld put emphasis computational aspects eld non monotonic reasoning general default reasoning particular lasting impact ai computer science general provide useful tools helping people better handle real world problems page 
di erently stable semantics admissibility semantics requires local search rst construct set assumptions monotonically implies sentence justi ed augment set assumptions defend constructed set attacks 
locality admissibility semantics computationally feasible stable semantics 
de ne proof procedures computing admissibility semantics 
second proof procedure computationally ecient re nement rst 
procedures proof procedure originally intended computing stable semantics logic programming 
original proof procedure proved correct locally strati ed logic programs shown incorrect stable semantics general 
subsequent evaluation proof procedure suggested semantics proof procedure fault :10.1.1.13.7065
proof procedure correct admissibility semantics 
proof procedures formulated logic programs derived formal speci cation applying standard logic program transformation techniques 
derivation guarantees correctness proof procedures 
show proof procedures complete 
proof procedures lend applications eld default reasoning general eld practical human argumentation encountered legal settings 
proof procedures formalise informal strategy suggested number texts argumentation claims supported reason reason defended counter attacks see critical thinking rational enquiry reasoning problem single views contrasting views challenge views answer challenges see legal reasoning lawyers anticipate challenges opponents attack see 
produce concrete instance ecient proof procedure logic programming case derive existing proof procedure expressed logic program obtained means standard logic program transformation techniques 
derivation shows existing proof procedure amounts interleaved prolog style left right execution ecient proof procedure 
prototype implementation indicate interleaved execution ecient prolog style execution 
rest structure section describes framework concrete instances stable semantics terms 
section discusses illustrates computational problems associated stable semantics 
section describes admissibility semantics 
section introduces top level rst proof procedure admissibility semantics 
section introduces top level ecient proof procedure 
section de nes lower level predicates 
section shows version existing proof procedure logic program formally derived ecient proof procedure section 
section compares proposed proof procedures existing proof procedures 
section discusses implementations sicstus prolog ecient proof procedure procedure concludes 
revised extended version 
concentrates program transformation techniques develop proof procedures emphasises signi cance proof procedures default reasoning 
section part section sections new implementations discusses section 
continues earlier described framework applications detail 
presents examples complementing 
earlier papers provide motivating examples focus technical details proof procedures implementation 
assumption frameworks stable semantics section describe form stable semantics show deductive system monotonic logic extended non monotonic logic default reasoning 
deductive system pair formal language consisting countably sentences set inference rules form 
inference rule axiom 
set sentences called theory 
deduction theory sequence exists means deduction element th set deductive systems monotonic sense implies th th 
compact sense implies nite subset deductive system assumption framework respect tuple ht ab ab ab fg mapping ab called contrary theory viewed set beliefs ab set candidate assumptions extend extension theory theory th 

ab 
informally refer extension simply 

theorist understood framework ht ab ab arbitrary sets sentences rst order logic contrary assumption just negation 
circumscription understood similarly set candidate assumptions set negations variable free atomic sentences predicates minimised variable free atomic sentences negations predicates xed :10.1.1.50.5796
logic programs viewed frameworks ht ab set clauses logic programming form set candidate assumptions ab set negations variable free atomic sentences contrary assumption default logic case monotonic logic rst order logic augmented domain speci inference rules form rst order sentences 
rst order theory ab consists expressions form sentence rst order logic 
contrary assumption autoepistemic logic language language modal logic modal operator inference rules classical logic 
assumptions form contrary contrary non monotonic modal logic similar inference rules modal logic assumptions form having considered 
de nition set assumptions 
ab closed 
ab 
assumption framework set assumptions 
ab closed 
frameworks logic programming default logic 
informally speaking frameworks ones explicit assumptions 
imply hidden assumptions 
de nition set assumptions 
stable 
closed 
assumption 
th 

assumption 
th 

closed 
ab th 
stable extensions correspond scenaria theorist minimal models cases circumscription extensions default logic stable expansions autoepistemic logic xed points non monotonic modal logic stable models logic programming :10.1.1.50.5796
circumscription sceptical sense sanctions formula default consequence theory formula belongs stable extensions theory logics neutral sceptical manner case circumscription credulous manner sanction formula default consequence theory formula belongs stable extension theory 
section discuss problems inherent computation stable semantics 
examples drawn logic programming simplicity 
examples expressed formalisms see 
computation stable semantics complexity computing stable semantics high due fact assumption necessary determine contrary belong extension 
framework lpg auto epistemic non monotonic modal logic example non framework 
empty set assumption implies hidden assumption lp 
example problem detecting credulous sceptical default consequences complete complete respectively default logic autoepistemic logic non monotonic modal logics np complete np complete respectively logic programming 
example consider problem determining stable model semantics atom innocent father mary default consequence logic program innocent accused guilty accused father mary necessary determine assumption nite set ab fnot innocent father mary guilty father mary ji belongs stable set 
assumption guilty father mary relevant innocent father mary sense theory derives innocent father mary 
guilty father mary belongs unique stable set fnot guilty father mary ji existing proof procedures stable semantics consider relevant assumptions see guaranteeing belong stable set 
general sucient perform local search relevant assumptions illustrated example 
example consider problem determining stable semantics atom innocent father mary default consequence logic program innocent accused guilty accused father mary accused mary accused mary clause seen bug program 
sucient restrict attention set assumptions 
fnot guilty father mary program implies atom innocent father mary 
necessary nd superset 
contains accused mary program represents principle person accused crime burden proof show accused guilty defence show 
accused assumed innocent default proved guilty 
derives accused mary innocent father mary completely unrelated assumption accused mary 

fnot accused mary accused mary exists subset 
consequently exists stable extension innocent father mary hold stable semantics 
consequence behaviour examples stable semantics computationally expensive unfeasible general case 
despite computational overheads number proof procedures de ned compute stable semantics cases 
best knowledge proof procedures developed restricted cases logic programming default logic circumscription 
satoh iwayama de ne proof procedure logic programming computing credulous stable semantics range restricted programs admit stable model 
proof procedure applied program example 
successfully terminates example generates relevant assumption needed example 
chen warren de ne proof procedure computing stable semantics nite propositional programs 
proof procedure compute credulous default consequences non propositional programs partial stable model semantics 
example innocent father mary entailed partial stable model semantics proof procedure gives positive answer innocent father mary generating relevant assumption needed example 
chen warren discuss possible adaptations stable model semantics concrete proof procedure 
niemel simmons de ne proof procedures computing credulous sceptical stable semantics consequences range restricted function free logic programs 
restrictions proof procedures applied examples 
satoh adapts credulous proof procedure determine consequences respect semantics extensions default logic 
proof procedure applies consistent default theories default rules expressed clausal form 
procedure de ned propositional case claimed applicable non propositional case appropriately instantiating variables 
see section partial stable models correspond maximal admissible extensions 
niemel de nes proof procedures computation extensions default logic 
procedures de ned propositional case decidable fragment rst order logic 
lobo de ne proof procedure computation stable extensions detection credulous stable semantics consequence default logic 
proof procedure sound complete nite semi normal default theories subset guaranteed admit extension 
existing proof procedures circumscription de ned theories model herbrand model additional restrictions 
example przymusinski restricts propositional case ginsberg baker ginsberg restrict theories function symbols 
best knowledge existing proof procedure computing credulous sceptical stable semantics consequences formalism applies general 
believe general procedure de ned due global nature semantics 
propose proof procedures computing credulous consequences admissibility semantics 
semantics section 
semantics proof procedures de ned assumption frameworks appropriately instantiated di erent logics outlined section 
admissibility semantics admissibility semantics applies assumption framework ht ab de nition set assumptions ab attacks assumption ab corresponding deduction said argument supported attacks set assumptions 
ab attacks assumption 
corresponding deduction said argument 
supported easy see stable semantics reformulated terms follows set assumptions 
stable 
closed 
attack 
attacks assumption 

closed 
set assumptions attack 
note totality requirement stable semantics global character forces 
take stand assumption matter relevant candidate consequence 
admissibility semantics hand requires 
takes stand relevant assumptions participate closed attack 
de nition set assumptions 
admissible 
closed 
attack 
closed set assumptions ab attacks 

attacks admissible extensions correspond admissible scenaria logic programming 
maximally admissible extensions correspond preferred extensions partial stable models logic programming 
admissibility semantics logics default reasoning obtained appropriately instantiating admissibility semantics instances framework 
stable extension maximal admissible maximal admissible extension stable 
instance example maximal admissible extension containing guilty father mary extension stable 
cases order consistent assumption frameworks see maximal admissible extensions stable 
focus computation consequences credulous admissibility semantics 
demonstration sentence credulous admissibility semantics consequence theory requires local search rst nd argument sentence show support defend counter attacking attacks attacking 
example innocent father mary credulous sceptical admissibility semantics consequence program 
demonstration innocent father mary need consider irrelevant assumption accused mary 
similarly example innocent father mary credulous sceptical admissibility semantics consequence program 
demonstration need consider irrelevant assumptions innocent mary innocent father father mary 
guilty mary guilty father father mary 
note admissible extension contained maximal admissible extension 
consequence cases maximal admissible extension stable example generally strati ed order consistent assumption frameworks admissibility semantics consequences stable semantics consequences 
cases proof procedures admissibility semantics stable semantics 
simple important theorem provides alternative characterisation admissibility 
virtue theorem condition admissible set assumptions 
attack need checked explicitly 
shown hold implicitly closed attacks 
restrict attention counter attacks assumptions 
restriction additional computational advantage reducing number candidate counter attacks need considered 
theorem set assumptions 
ab admissible 
closed 
closed set assumptions ab attacks 

attacks 
proof result appendix proof procedure admissibility semantics section de ne proof procedure computing admissible sets assumptions assumption framework 
proof procedure form metalevel logic program consisting top level clauses de ning predicate adm 


admissible superset 
lower level clauses de ning predicates defends 
defends 
attacking closed attacks 
closed 

closed set assumptions set theoretic constructs 
section focus top level program 
sections give part lower level 
top level program derived logical speci cations predicates adm defends 
speci cations play role semantics proof procedure 
method obtaining proof procedure logic program derived speci cation assumption lowlevel predicates program meet speci cations renders proof soundness proof procedure trivial 
speci cation ht ab assumption framework 
sets assumptions 

ab adm 


admissible 
remainder speci cation adm de nition admissibility referred spec adm goal proof procedure set 
generate 
adm 

holds 
typically 

sentence proof procedure compute credulous admissibility semantics consequences 
instance examples innocent father mary 
fnot guilty father mary 
speci cation ht ab assumption framework 
sets assumptions 
ab defends 
ab attacks 
closed attacks 
closed means closed speci ed de nition 
say defends 
remainder speci cation predicate defends auxiliary speci cations attack closed de nitions respectively appropriate de nitions set theoretic constructs referred spec lower corollary follows directly theorem gives de nition adm equivalent spec adm terms defends speci ed spec lower corollary spec adm spec lower adm 


defends 
closed 
top level proof procedure logic program rog adm adm 
defends 
closed 
adm 
defends 
closed 
adm 

note choice defence test set 
closed performed independently 
test fails di erent defence needs chosen 
ecient procedure construct closedness condition satis ed 
achieved replacing second clause rog adm adm 
defends 
closure 
adm closure 


th 
ab closure 

holds 
smallest closed set assumptions containing 
case assumption frameworks set assumptions closed case rog adm simpli es adm 
defends 
adm 
defends 
adm 

logic program rog lower implementing defends closed settheoretic constructs apply sld sldnf resolution rog adm rog lower prolog style left right selection rule query adm 

case proof procedure understood algorithmic terms repeatedly adding initially set assumptions 
need added 
set obtained adding defence previous accumulated set assumptions closed 
precisely current set assumptions 
initially 
proof procedure repeatedly nds set assumptions defends 

closed replaces 


returns 
assigning 
note step non deterministic set assumptions defending current 

closed 
proof procedure potentially needs explore search tree alternatives nd branch terminates set defends closed 
algorithmic interpretation theory example similarly theory example 
fnot guilty father mary possible execution goal adm 
instantiated fnot guilty father mary rst clause program subgoal defends fnot guilty father mary fnot guilty father mary executed defends fnot guilty father mary fnot guilty father mary holds substitution fnot guilty father mary returned output 
algorithmic interpretations obtained employing execution strategies 
particular execution subgoals second clause interleaved executed left right 
interleaved execution normally give rise ecient proof procedure discussed sections 
soundness rog adm expressed corollary direct consequence theorem proof results section appendix theorem spec adm spec lower rog adm corollary 

ab rog adm spec lower adm 

spec adm spec lower adm 

execution program generates 
output 
input 


admissible 
procedure rog adm complete sense theorem 

ab spec adm spec lower adm 

rog adm spec lower adm 

speci cation 


admissible program generate 
output 
input 
full proof procedure obtained adding rog adm program rog lower computing defends closed set theoretic constructs program rog lower sound respect speci cation spec lower rog adm rog lower sound respect spec adm spec lower formally theorem rog lower 
ab rog lower defends 
spec lower defends 
rog lower closed 
spec lower closed 
rog lower 

spec lower 



ab rog adm rog lower adm 

spec adm spec lower adm 

program rog lower complete wrt speci cation spec lower rog adm rog lower complete respect spec adm spec lower formally theorem rog lower 
ab spec lower defends 
rog lower defends 
spec lower closed 
rog lower closed 
spec lower 

rog lower 



ab spec adm spec lower adm 

rog adm rog lower adm 

ecient proof procedure proof procedure program rog adm rog lower performs great deal redundant computation 
suppose example computed defence currently accumulated set assumptions 
defends 
successfully executed suppose 
closed 
invocation procedure 
new accumulated set assumptions 
set defending 
redundantly defends 
matters worse redundantly computed defence unnecessarily di erent unnecessary defence gives rise ineciency defended turn 
illustrated example 
example consider program hold defends fnot rg fnot pg defends fg fnot rg defends fnot sg fnot pg defends fnot ug fnot sg defends fnot sg fnot rg defends fnot rg fnot rg defends fnot rg fnot rg 
fnot pg possible computation goal adm 
fnot rg computed defends 
holds 
subgoal adm 
executed 
fnot sg computed defends 
holds 
subgoal adm 
executed 
fnot rg computed defends 
holds 
computation redundantly defends defended addition 
necessitates computation defend sucient terminate 
fnot rg 
avoid redundancies suces distinguish new set assumptions 
assumptions 
just defended 
new assumptions just added 
require defence 
purpose employ variant adm 

predicate adm 

speci cation ht ab assumption framework 
sets assumptions 

ab adm 



defends 

closed 

admissible 
refer speci cation de nition admissibility spec adm relationship adm adm lemma sets assumptions 


spec adm spec lower adm fg 

closed 
spec adm spec lower adm 


spec adm spec lower adm 

spec adm spec lower adm fg 

top level procedure computes predicate adm logic program rog adm adm 
fg 
adm 

defends 
closed 
adm 


defends variant predicate defends speci ed follows speci cation ht ab assumption framework 
sets assumptions 
ab defends 
ab attacks closed 
attacks 

proof results section appendix defends new part currently accumulated set assumptions 
counter attacking assumptions attack 
refer speci cation de nitions attack closed set theoretic constructs spec lower rog adm rog adm ecient replacing second clause adm 

defends 
closure 
adm 


closure speci ed section 
furthermore rog adm assumption framework rog adm simpli ed eliminating calls predicate closed 
adopting di erent execution strategies obtain di erent proof procedures 
apply sld sldnf resolution prolog style left right selection rule query adm fg 

proof procedure understood algorithmic terms follows 
fg 
empty repeatedly non deterministically nd defends 
holds 
closed replace 



return 
proof procedure theory example 
fnot pg possible execution goal adm fg 
fnot rg computed defends fg 
holds 
subgoal adm 
fg executed 
fg computed defends 
holds 
subgoal adm 
executed 

fnot rg returned 
case rog adm program ecient interleaving steps defend new assumptions soon generated waiting generated 
resulting proof procedure abstraction proof procedure logic programs eshghi kowalski 
soundness rog adm corollary follows directly lemma theorem theorem spec adm spec lower rog adm corollary 

ab rog adm spec lower adm fg 

closed 
spec adm spec lower adm 

execution program generates 
output closed set assumptions 
input 


admissible 
completeness rog adm theorem 
theorem 

ab spec adm spec lower adm 

rog adm spec lower adm fg 

full proof procedure obtained adding rog adm program rog lower computing defends closed set theoretic constructs section give top level generalised logic program computing defends sound complete 
computing ecient implementation proof procedures described previous section depends ecient computation defends speci cation defends 
requires 
attack closed attacks general case number attacks nite superset attack attack 
theorem shows possible restrict considerably number attacks need considered limiting attention closure minimal attacks 
de nition set assumptions ab minimal closed attack set assumptions 
ab closed attack 
exists closed attack 
note case assumption frameworks attacks automatically closed minimal attacks respect set inclusion automatically minimal closed attacks 
theorem set assumptions 
ab admissible 
closed 
set assumptions ab minimal closed attack 

attacks 
proof theorem appendix minimal closed attacks hard compute due minimality condition 
sucient proof procedure consider superset set minimal closed attacks 
remainder section assume lean attacks speci cation speci cation ht ab assumption framework 
sets assumptions 
ab lean attacks 
attacks 
minimal closed attack 
ab lean attacks refer speci cation de nitions attack minimal closed attack spec lean attacks directly theorem speci cation defends expressed eciently corollary sets assumptions 
spec lower defends 
ab lean attacks 
attacks 
generalised logic program computes defends rog defends defends 
fd lean attacks lean attacks 
proof procedure rog adm rog defends needs extended program rog rest de ning lean attacks closed set theoretic constructs 
program di erent di erent instances assumption framework 
see section logic programming case 
note theory possible rog rest lean attacks 
nite rog defends rog rest defends 
nite 
practice concrete implementations proof procedure rog adm rog defends rog rest generate nite sets 
implementation incomplete illustrated example 
example ht ab assumption framework corresponding logic program fp language contains constant 
set assumptions admissible 
fnot ji ng consider set 
fnot exists admissible set 
program rog adm generates nite set defence nite set nite set 
generated nite computation 
proof procedures logic programming concrete rog rest proof procedure rog adm rog defends rog rest inecient accumulated sets assumptions subtracted newly computed sets generated 
remainder section modi cation rog adm rog defends logic programming performing subtraction sets generated 
modi cation derive version existing proof procedure logic programming corrected version referred simply ek 
ek derived standard logic program transformation techniques 
obvious see holds respect speci cation defends 
defends 
assumption frameworks logic program rog adm replaced equivalent logic program adm 
fg 
adm 

defends 
adm 
version program considering assumptions separately rog adm adm 
fg 
adm 

defends 
adm 

represents disjoint union predicate defends speci ed terms predicate defends follows defends 
defends 

fg predicate defends may computed generalised logic program defends 
fd lean attacks 
lean attacks 
predicate lean attacks speci ed terms predicate lean attacks 
follows lean attacks 
lean attacks 

fg logic programming case predicate lean attacks de ned logic program rog lp lean attacks lean attacks 
sld 
predicate sld speci cation sld 


sld 
fg de ned logic program rog sld sld fg 
true sld fg 

sld fnot pg 

sld 
sld 
sld 
sld 
sld 
note rog sld modi cation vanilla meta interpreter logic programming accommodate assumptions 
assume clauses atom literals represented true hypotheses represented unit clauses true understood new atom 
easy see theorem ht ab logic programming 
ab rog lp lean attacks rog sld rog set lean attacks 

fg spec lean attacks lean attacks 
fnot pg 
rog lp lean attacks rog sld sound 
complete compute nite sets see example 
unfolding rst atom predicate lean attacks generalised logic program defends earlier obtain generalised logic program defends 
fd sld 
lean attacks 
logic program executed means execution strategy 
generalised logic program defends corresponds interleaved execution original generalised logic program rog defends defends 
defends 
defends fg 
fg defends 
fp xg fb tg defends 
defends 
fnot xg 
lean attacks 
defends 
defends 
fnot xg defends 
fxg third argument predicate defends holds set potential lean attacks give rise fully unfolding atoms lean attacks 
new assumption selected potential lean attack immediately potential lean attack removed set 
lean attacks originate selected potential lean attack guaranteed 
note prolog style execution proof procedure rog rog adm rog defends rog lp lean attacks rog sld rog set rog set de ning set theoretic constructs corresponds interleaved execution original proof procedure rog rog adm rog defends rog rest rog rest de ning lean attacks logic programming set theoretic constructs 
generation lean attacks interleaved generation lean attacks rog rog version rog restricted execution strategy 
result soundness rog lp lean attacks rog sld rog sound 
complete rog lp lean attacks rog sld complete 
ek expressed logic program rog ek abd 
true 
abd 


abd 


cons 
fnot pg fpg 
abd 

abd 

abd 

abd 

abd 

cons 
fg 
cons 
fp xg 
fb xj tg cons 
cons 
fnot xg 

abd 

cons 

cons 
fnot xg 
cons 
fxg 
predicates abd cons correspond abductive consistency phases respectively ek 
abductive phase computes set assumptions object level program monotonically derives conjunction literals 
new assumption set abductive phase activates consistency phase potential lean attack assumption selecting assumption attack activating abductive phase contrary 
appendix show rog ek systematically derived rog clauses abd 



sld 
adm 

cons 



defends 
adm 

mentioned section ek adopts interleaved prolog style execution original logic program rog rog version ek ways restricted logic programming case restricted execution strategy 
experimental results see section show rog ek ecient rog surprising rog lean attacks need fully constructed rog ek soon assumption belonging identi ed 
comparisons toni kakas develop argumentation theoretic proof procedures computing admissibility weak stability acceptability semantics case instantiation special cases considered 
proof procedure computing admissibility corresponds proof procedure section formulated terms derivations trees nodes sets assumptions logic program 
shown proof procedures logic programming form derived systematically logical speci cations 
proof procedure aims compute credulous default consequences relative admissibility semantics basis computing credulous sceptical default consequences relative semantics 
particular admissible extension contained maximal admissible extension proof procedure sound respect credulous maximal admissible extension semantics partial stable model preferred extension semantics logic programming case 
thielscher de nes proof procedure sound sceptical consequences relative partial stable model semantics logic programming 
proof procedure formulated imperative style reformulated generalised logic program rog pref pref sld 
fg adm fg 

ab lean attacks 
adm fg 

ab adm fg 
sld fg 
rog adm rog defends rog sld rog set earlier sound rog lp lean attacks intuitively sentence conjunction literals sceptical default consequence logic program preferred extension semantics holds admissible set assumptions 
built existing explanation 
admissible set assumptions 
superset lean attack 
holds respect admissible superset 

proof procedure sound sense rog pref rog adm rog defends rog lp lean attacks rog sld rog set pref th 
maximal admissible sets assumptions 
proof soundness appendix procedures computing stable semantics literature obtained appropriately instantiating executing ecient versions procedure stable 

attacks 
stable 

expand 


stable 

attacks 
stands 
attacks 
predicates de ned follows 
ab ab 
ab 
attacks 


attacks 
attacks 
stands 
attacks 
di erent de nitions predicate expand give rise di erent proof procedures 
example expand 

adm 

alternatively expand 


lfp def 
lfp stands xed point operator def 
set assumptions 
de ned follows assumption framework ht ab ab def 

def 
def defends credulous version proof procedure logic programming employs version second de nition expand 
semantics default reasoning proposed complete extension semantics set assumptions 
complete 
closed 
def 
complete extensions correspond complete scenaria stationary expansions logic programming 
note 
complete 
closed 
defends 
def 

contains assumption defends 
def 

complete 
admissible 
contains assumption defends 
founded semantics logic programming understood sceptical semantics corresponding complete extensions 
proof procedures employed give proof procedures compute credulous default consequences complete extension semantics example cpl 
complete 
cpl 

adm 

defends 
fag cpl 
fag 
complete 
stands 
complete 
proof procedures credulous admissibility semantics argumentation framework 
proof procedures applicable instances framework including logic programming default logic autoepistemic logic non monotonic modal logic 
sketched possible instance logic programming 
compared proof procedures existing state art proof procedures analysed proof procedures kernel proof procedures compute semantics notably stable semantics 
concentrated logic underlying proof procedures considered implementation related issues 
developed prototype implementation rog ecient version proof procedure logic programming case rog ek version form logic program ek proof procedure logic programming 
implementations sicstus prolog rely lists represent sets 
implementations reported appendix object level logic program goal lm li atom li literal holds lm succeeds 
fnot ang omit implementation support predicates manipulation lists 
full implementation www lp doc ic ac uk staff ft ft html 
exists 

lm th 
rog adm fg 

holds ek lm succeeds 
fnot ang exists 

lm th 
rog adm fg 

rog ek abd fg lm 
cases th 

admissible 
implementations write standard output number clauses examined computation admissible set 
example program example holds ek 
number clauses examined number clauses examined means exactly admissible sets assumptions containing sets fnot ug fnot rg 
implementation needs examine clauses respectively detect sets 
holds ek 
means admissible set assumptions ensuring holds 
similarly holds 
implementations handle goals programs variables function symbols 
example program example holds ek innocent father mary 
number clauses examined guilty father mary holds ek innocent 
number clauses examined guilty father mary father mary implementation suitable testing applications eld practical argumentation legal reasoning legal expert systems discussed 
implementation give analogous runtime results examining tens clauses rog ek ecient general illustrated table clauses rog rog ek sec sec sec sec sec sec sec sec sec sec sec means proof procedure failed terminate reasonable time 
implementation handle loops loop checking 
includes ecient implementation logic programming special instances framework possibly exploiting techniques 
research supported fujitsu research laboratories eec activity kit 
appendix alternative characterisation admissibility proof theorem closed attack 
need prove 
attacks 

admissible 
attacks 
attacks 

attacks contradicting hypothesis 
admissible 
need prove 
attack 
suppose 
attacks 

attacks 
fg 
de nition attack set attack fg 
soundness completeness rog adm proof theorem prove theorem deriving program rog adm speci cation 
letting 

spec adm formulated corollary adm 


defends 
closed 
immediately obtain rst clause program 
obtain second clause 

half spec adm formulated corollary observe 

implies 

obtaining adm 


defends 
closed 
applying half spec adm transitivity obtain adm 

adm 

implies adm 

closed 
defends 
adm 

renaming 



obtain second clause program 
proof theorem assume spec adm spec lower adm 

spec lower 

defends 
closed 
rst clause rog adm rog adm spec lower adm 
cases 



rst case rog adm spec lower adm 

immediately 
second case defence set 
defends subset 
spec lower defends 
closed 
rog adm spec lower adm 
defends 
closed 

rog adm spec lower adm 

defends 
closed 

second clause rog adm rog adm spec lower adm 

proof theorem assume rog adm rog lower adm 

rog lower sound respect spec lower rog adm spec lower adm 

directly corollary spec adm spec lower adm 

proof theorem assume spec adm spec lower adm 

directly theorem rog adm spec lower adm 

completeness rog lower rog adm rog lower adm 

soundness completeness rog adm proof lemma 
note adm fg 

closed 
implies 

defends 
fg closed 

admissible closed 
spec lower trivially implies defends 
fg 


closed 

admissible closed 
spec adm implies adm 


adm 

implies 

admissible trivially implies 

closed 
defends 
fg 
admissible spec adm implies adm fg 

proof theorem prove theorem deriving program rog adm speci cation exploiting corollary follows directly theorem corollary spec adm spec lower adm 



defends 
closed 

admissible 
letting fg 
spec adm adm 


defends 

closed 

admissible obtain adm 
fg 
defends 
closed 
admissible equivalent rst clause rog adm corollary 
obtain second clause rst replace predicate adm second clause program equivalent speci cation terms defends corollary obtaining 

defends 
closed 

admissible defends 
closed 

defends 


closed 
admissible 



obvious need prove admissible defends 
closed 
defends 
closed 
defends 


closed 
admissible follows immediately lemma defends 
defends 
defends 



proof lemma assume defends 
ii defends 

assume ab attacks 
need show 
attacks 

attacks ii 
attacks 

attacks 

attacks 
suces show 
attack suppose contrary 
attacks ii 
attacks 

fg 
possible attacks fg 
proof theorem assume spec adm spec lower adm 

spec lower 

defends 
closed 
spec lower 

defends 
fg 
closed 
spec lower 

defends 
fg 
defends 
fg 

spec lower defends 
fg 

similarly spec lower 

defends 
fg 
defends 


ii spec lower defends 


show rog adm spec lower adm fg 

instance second clause program adm fg 

defends fg 
closed 
adm 



rst condition provable spec lower second condition provable spec lower 


closed 
prove third condition instance second clause program adm 


defends 

closed 
adm 

rst condition provable spec lower ii second condition provable spec lower 
closed 
third condition provable rst clause rog adm rog adm spec lower adm fg 

computing defends proof theorem theorem follows directly sets assumptions 




ab closed attack 

attacks 

ab minimal closed attack 

attacks 
minimal closed attack set closed attack set 
non minimal closed attack contains minimal closed attack set attacks rst set attacks superset second set 
soundness rog pref soundness proof procedure rog pref rog adm rog lp lean attacks rog sld rog set sanctioned theorem reformulation theorem 
theorem assumption framework ht ab sentence th 
maximal admissible 
ab 
th 
admissible set assumptions 
ab 
set assumptions 
ab 
admissible 
attacks 
th 
set assumptions 
ab 


admissible 
proof half trivial 
half proved contradiction suppose exists set assumptions 

preferred th 

set assumptions provided part 
fg th th 
contradicting hypothesis th 

fg 

attack 
admissible contradicting hypothesis 
preferred maximal admissible 

attacks 

attacks 
ii 
attacks 
case 
attack 
attacks 
part 
preferred th 
contradicting hypothesis 
case ii 
admissible 
attacks 

attack 
attacks 

admissible 
attacks 
part 
preferred th 
contradicting hypothesis 
derivation ek rog adm rog defends rog lp lean attacks rog sld fc derive rog ek generating sequence programs rog ek derived applying equivalence preserving transformation technique 
easy prove properties rop adm 

adm 

adm 

rop adm 



derive sub program rog ek de ning abd 
unfolding subgoal sld 
body get fc clauses abd 
true 
abd 


abd 


adm 
fnot pg 
abd 



sld 
adm 

abd 



sld 
sld 
adm 

rop rop hold goal replacement rule clause abd replaced simplifying clause abd 



sld 
adm 



sld 
adm 

resulting program 
folding clauses abd replaced clauses abd 

abd 

abd 

abd 

abd 

resulting program 
unfolding subgoal adm third clause abd obtain clause abd 


defends 
fnot pg fpg adm 
fnot pg 
replacing third clause abd clause 
folding clause new clause abd replaced clause abd 


cons 
fnot pg fpg 
resulting program 
note sub program de ning abd coincides sub program rog ek de ning abd 
derive subprogram de ning cons 
unfolding subgoal defends 
obtain fc clauses cons 
fg 
cons 
fp xg 


fb tg defends 
adm 

cons 
fnot xg 



lean attacks 
defends 
adm 

cons 
fnot xg 


defends 
fxg adm 

folding clause second fourth clauses cons replaced respectively clauses cons 
fp xg 
fb tg cons 
cons 
fnot xg 
cons 
fxg 
resulting program 
rop rop hold goal replacement rule third clause cons replaced simplifying equivalent clause cons 
fnot xg 


lean attacks 
adm 



defends 
adm 

resulting program 
folding clause new clause cons replaced clause cons 
fnot xg 


lean attacks 
adm 

cons 

resulting program 
unfolding subgoal lean attacks new clause replaced clause cons 
fnot xg 


sld 
adm 

cons 

resulting program 
folding clause replace new clause cons 
fnot xg 
abd 

cons 

resulting program 
rog ek program obtained dropping clauses adm defends lean attacks sld implementations implementation rog holds goal delta demo goal delta adm delta delta write number clauses examined write 
adm delta delta 
adm delta delta defends delta append delta deltad adm deltad delta 
defends delta append delta deltad findall lean attack sum nl deltad nc nl nc 

deltad sub deltad 
sub 
sub deltad minus list deltad lean attack minus list deltad append sub deltad 
specific logic programming demo goal delta sld goal delta 
lean attack delta member delta sld 
sld goal delta sld acc goal delta 
sld acc 
sld acc true 
sld acc member 
sld acc member 
sld acc delta rule rule represents object level clause rule atom list literals true final element negative literal represented atom sld acc delta 
sld acc delta sld acc sld acc delta 
support predicates 
implementation rog ek holds ek goal delta abd goal delta write number clauses examined write 
abd delta delta 
abd delta true delta 
abd delta delta member delta 
abd delta delta member delta append delta cons delta 
abd delta delta rule abd delta delta 
abd delta delta abd delta abd delta 
cons delta delta 
cons delta delta true findall rule append count append cons delta delta 
cons delta delta member delta abd delta cons delta 
cons delta delta append cons delta delta 
support predicates 
baker ginsberg theorem prover prioritised circumscription 
proc 
ijcai morgan kaufmann pages lobo resolution procedure default theories extensions 
proc 
non monotonic extensions logic programs theory applications dix pereira przymusinski eds 
springer verlag lnai pages bondarenko dung kowalski toni argumentation theoretic framework default reasoning 
arti cial intelligence pages bondarenko toni kowalski assumption framework non monotonic reasoning 
proc 
nd international workshop logic programming non monotonic reasoning nerode pereira eds 
mit press pages brewka dix 
konolige nonmonotonic reasoning overview 
lecture notes standford california chen warren computation stable models integration logical query processing 
available ftp ftp ms edu pub lpnmr chen ps singleton ii practical guide legal writing legal method 

dimopoulos kakas logic programming negation failure 
proc 
ilps mit press dung argumentation theoretic foundation logic programming logic programming dung acceptability arguments fundamental role nonmonotonic reasoning logic programming person game arti cial intelligence dung kowalski toni synthesis proof procedures default reasoning 
proc 
springer verlag lncs eshghi kowalski abduction deduction 
imperial college technical report eshghi kowalski abduction compared negation failure 
proc 
iclp mit press gelfond lifschitz stable model semantics logic programming 
proc 
icslp mit press gilbert win argument 
wiley sons 
ginsberg circumscriptive theorem prover 
arti cial intelligence pages howard barton thinking 
kakas kowalski toni abductive logic programming 
journal logic computation pages kakas kowalski toni role abduction logic programming 
handbook logic arti cial intelligence logic programming pages oxford university press kakas mancarella stable theories logic programs 
proc 
mit press kakas mancarella dung acceptability semantics logic programs 
proc 
iclp mit press pages kowalski toni argumentation 
journal arti cial intelligence law pages special issue logical models argumentation kluwer academic publishers marek truszczynski nonmonotonic logic context dependent reasoning 
springer verlag mccarthy circumscription form non monotonic reasoning :10.1.1.50.5796
arti cial intelligence pages mcdermott nonmonotonic logic ii non monotonic modal theories 
jacm moore semantical considerations non monotonic logic 
arti cial intelligence morgenstern inheritance comes age applying nonmonotonic techniques problems industry 
arti cial intelligence pages niemel ecient default reasoning 
proc 
ijcai morgan kaufman pages niemel simons ecient implementation founded stable model semantics 
proc 
jicslp mit press pages 
transformation logic programs foundations techniques 
journal logic programming pages jumps logic law 
journal arti cial intelligence law pages special issue logical models argumentation kluwer academic publishers poole logical framework default reasoning 
arti cial intelligence przymusinski algorithm compute circumscription 
arti cial intelligence pages przymusinski semantics disjunctive logic programs deductive databases 
proc 
dood reiter logic default reasoning 
arti cial intelligence sacc zaniolo stable models non determinism logic programs negation 
proc 
acm sigmod sigact symposium principles database systems satoh iwayama 
correct top proof procedure general logic programs integrity constraints 
proc 
rd international workshop extensions logic programming lamma mello eds springer verlag lnai pages satoh top proof procedure default logic abduction 
proc 
ecai thielscher nonmonotonic semantics proof procedure logic programs 
jicslp mit press pages toni kakas computing acceptability semantics 
proc 
rd international workshop logic programming non monotonic reasoning marek nerode truszczynski eds 
springer verlag lnai pages toulmin uses arguments 
cambridge university press van gelder ross schlipf unfounded sets founded semantics general logic programs 
proc 
acm sigmod sigact symposium principles database systems weston arguments 
publishing 

