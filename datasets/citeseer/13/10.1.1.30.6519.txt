retargetable debugger norman ramsey dissertation faculty princeton university degree doctor philosophy recommended acceptance department computer science january fl copyright norman ramsey rights reserved debuggers specific machines operating systems languages support 
debugger re implemented new machine debuggers variety machines operating systems get unwieldy 
improvements debuggers may lost re implemented users move new machines 
retargeting debuggers easier improvements valuable 
thesis describes design implementation ldb prototype retargetable debugger 
dealing symbol table formats machine dependent aspects debuggers 
ldb eliminates machine dependence format machines 
format language dialect postscript extensible represent procedures 
ldb reduces retargeting effort associated variations run time support controlling target process debug nub small piece object code linked target program 
debugger job undo compiler done compiler run time 
example print value variable debugger undo compiler mapping source level data machine level 
evaluate expression debugger check syntactically semantically correct translate executable form 
ldb compiler possible 
compiler emits postscript ldb uses print values 
variant compiler runs debug time compiles expressions postscript ldb uses evaluate expressions 
debugging tasks breakpoints walking call stack analogs compiler 
ldb reduces retargeting effort tasks layers abstraction minimize machine dependent code confined innermost layers 
techniques produce debugger little machine dependent code 
ldb total code size lines modula needs lines machine dependent code targets 
iii iv acknowledgments pleasure education dave hanson 
master careful engineering learned example 
left 
pleasure thesis readers 
anne rogers helped extract ideas mass detail dropped doing help plan manuscript 
despite gives excellent advice 
john ellis reviewed astonishing attention detail valuable suggestions enabled strengthen 
example showed remove lines vax nub formalization breakpoint commands mentioned section idea 
david redell kind review chapters difficult circumstances comments especially useful substantial experience debugging 
years enriched david dobkin perspective research education computing 
suggested debugging fault took suggestion seriously 
mary fernandez colleague enjoyed discussions 
wrote implementation pattern language appendix reviewed early drafts chapters 
mark weiser mike spreitzer invited xerox parc ideas matured arrived artifact left understanding 
mike spreitzer helped build understanding independently moving early version ldb sparc 
people helped princeton fun place 
extra jim plank granularity norbert office fine place 
ldb funded fannie john hertz fellowship bell laboratories fellowship summer research internship xerox parc computer science laboratory nsf number cda 
special wife cory love support finished 
treated dr behaved hyde 
vi contents iii acknowledgments related 
modula terminology conventions 
organization 
debugging ldb memories kinds memories 
implementing memories 
trapped memories 
combining memories 
discussion 
postscript symbol tables representing debugging information postscript 
postscript symbol tables 
representing symbols types modula 
printing values 
performance enhancements 
generating postscript symbol tables 
discussion 
expression evaluation debugger expression server 
evaluating printing compiled expressions 
vii making lcc act expression server 
reconstructing lcc symbol type data 
delaying assignment machine dependent data 
postscript back 
discussion 
debug nub debugger view nub 
implementing nub protocol 
illustrating nub protocol 
implementing nub 
procedure call 
process context 
discussion 
breakpoints events example 
events 
user level breakpoints 
traps 
low level breakpoints 
procedure calls 
discussion 
stack walking machine independent layers 
generic layer 
preserved registers 
frame top stack 
machine dependent layer 
discussion 
ldb postscript implementation 
safe fast lexical analysis 
compact specifications operator implementations 
performance tuning 
discussion 
viii retargeting ldb nub 
postscript 
debugger code breakpoints stack walking 
compiler 
discussion 
evaluation postscript 
strengths 
weaknesses 
comparison dbx gdb 
compatibility retargeting costs 
recommendations 


formal model breakpoints modeling program counter execution 
counting events 
implementing breakpoint 
completing model 
mips instruction specification instruction specification 
computing follow sets 
ix list tables debugger operations need symbol table information 
locations method definitions implementations 
register classifications ldb 
xi xii list figures traditional debugging overview 
ldb overview 
example program 
summary ldb commands 
structure memory mips 
implementation memory stack frame 
memory 
vax memory 
procedure fib stopping points 
tree structure fib symbol table 
anchor symbols 
top level dictionary fib 
linker table program fib 
printing procedure arrays 
building lazy version fib top level dictionary 
types values associated key cache symbol type dictionary 
communication paths ldb expression server 
steps evaluating expression 
code evaluate atan sin cos 
code evaluate argv argv 
layers implementing debug nub protocol 
messages exchanged processing event 
parts debug nub 
nub implementation procedure call 
source file fib 
user level breakpoint set 
layers stack frame abstraction 
generic implementation method 
xiii fib stack frame mips 
generic procedure creating top frame stack 
hierarchy interpreter types 
machine dependent parts ldb 
mips configuration module 
mips configuration interface 
opcode tables mips architecture manual 
xiv chapter programmers don debugger gramlich 
debuggers reliable better user interfaces 
trying improve debugger learns debuggers specific machines operating systems languages support 
debugger re implemented new machine debuggers variety machines operating systems languages get unwieldy 
example gnu gdb stallman pesch lines lines machine dependent 
retargeting debuggers hard improvements debuggers may lost re implemented users move new machines 
retargeting debuggers easier improvements valuable 
thesis describes techniques building retargetable debuggers 
techniques design implementation ldb prototype retargetable debugger 
ldb source level debugger gdb dbx linton 
programs compiled lcc fraser hanson retargetable compiler generates code mips motorola sparc vax architectures 
gdb dbx ldb lets users set remove breakpoints start programs evaluate expressions assignments variables 
total code size lines needs lines machinedependent code target 
retargeting debugger complex debugger interacts different aspects machine operating system 
considered axes retargeting necessary 
compiler chooses mapping source level data structures machine data structures 
choices fairly simple usually limited sizes alignments basic types layout bit fields structures 
languages choices example representations open arrays objects modula nelson representation closures standard ml appel 
chapter 
debugger relies information compiler linker types locations variables 
just contents format information vary target target 
information provided procedures program debugger function correctly absence 
debugger choose target process debug 
able choose stopped running process just processes started special debug mode 
able choose process machine machine different architecture debugger runs 
features especially important debugging long running servers debugging programs embedded computers may screens keyboards needed run debugger 
cross architecture debugging possible develop operating systems compilers new machine running debugger reliable machine 
debugger means manipulating target process debugged 
systems enable debugger run address space target provide support debugging separate process machine 
nature support vary machine operating system 
language run time system provides source variation debugger may want user level threads intercept exceptions example 
debugger entire call stack 
know calling sequence infer machine state control returns procedure middle stack example able recover local variables kept registers 
support expression evaluation able call procedures target process may require information calling sequence 
debugger programs written language 
language rules resolving names representing values evaluating expressions support different languages may require re implementation debugger 
debugger able set breakpoints step execution program 
doing may require information target instruction set example compute controlflow information 
ldb solves problems 
supports different representations source level data different calling sequences breakpoints different instruction sets 
representations debugging information existing compilers linkers ldb defines machineindependent representation lcc compiler modified emit 
similarly ldb existing operating system support debugging implements retargeted machine 
ldb techniques support programming language prototype works ansi ansi 
figures illustrate retargeting problems related operating system support representation information compiler expression evaluation source language 
includes interpreter kernel target program compiler table symbol dbx traditional debugging overview 
network symbol table debug nub target program expression server compiler ldb ldb overview 
shows traditional unix debugger dbx debugging target process 
dbx uses kernel support typically ptrace system call control target 
meaning usage ptrace differ different versions unix adams muchnick 
dbx gets symbol table information object file target program stored machine dependent language dependent format 
dbx organization requires different implementations compiler debugger 
corresponding picture ldb 
kernel interface replaced network connection debug nub small piece object code linked target program 
nub manipulates target process response messages sent debugger described chapter 
message protocol machines 
ldb uses generalpurpose programming language postscript adobe represent symbol table information 
representation machine independent language independent 
postscript possible put code just data symbol table 
ldb uses technique hide debugger machine dependent mapping source level machine level data described chapter 
debugger implementation relies standalone implementation runs address space expression evaluation server 
organization possible re compiler implementation described chapter 
expression evaluation server code symbol table debugger proper independent easier add support languages 
chapter 
debugger job undo compiler done compiler run time 
example print value variable debugger map machine level data structures back source level 
evaluate expression debugger check syntactically semantically correct turn executed 
ldb compiler kind possible 
postscript provides means compiler debugger 
compiler decides values printed tells debugger emitting postscript code debugger interpret 
compiler transformed expression evaluation server expression evaluation compiling expressions postscript procedures 
changes needed postscript language supports debugging imaging 
changes implementation techniques add debugging support described chapter 
ldb relies help compiler require major changes compiler 
changes limited abstractions defined code generation interface front back ends compiler fraser hanson 
ldb models contents target memory registers memory debugger uses memories fetch store scalar values lcc code generation interface 
postscript flexible easily matched lcc execution model described chapter simple postorder traversal lcc intermediate code generate postscript expression evaluation 
breakpoints walking call stack debugging tasks analogs compiler 
ldb reduces retargeting effort tasks layers abstraction minimize isolate machine dependent code 
ldb written modula uses modula subtyping define layers 
machine dependent code confined leaves type hierarchy 
bulk implementation methods supertypes machine independent 
similar technique implementations streams nelson 
chapters describe hierarchies implement breakpoints stack walking 
debug nub eliminates need special debug mode nub linked target program target debugged 
target faults unexpectedly nub waits network connection debugger 
user running target connect ldb target stopped typing unix quit character unix kill command 
debugging session debugger disconnected target resumed interruption occurred 
connection machine running debugger fail debugger connected nub recovers waits connection instance debugger 
targets retargetable tools chosen tools built 
example lcc cross compile target architecture fixed lcc compiled user program compiled 
ldb contrast fix target architecture user selects target 
related program 
ldb stores machine dependent code data modula objects architecture fixed choosing object conditional compilation 
choice indifferent architecture ldb runs ldb run kind machine debugging target program running kind machine 
ldb treats debugging cross architecture debugging uses extra mechanism debugging architectures 
related strategies getting information compilers linkers vary 
experimental systems compiler debugger tightly coupled 
dec src debugger executes address space compiler sharing annotated syntax trees 
dice debugger cooperates incremental compiler part integrated environment fritzson 
compiler debugger separate debugger may run address space linker sharing data structures schaffer 
debuggers vax debug dbx linton completely separate tools communicate compiler linker symbol table information 
information placed object file machine dependent format 
ldb debuggers eliminates retargeting effort postscript symbol tables 
gdb stallman pesch supports different target machines different versions unix lines noted documentation machine dependent 
lines deal machine dependent object code formats 
long delay availability mips machines availability gdb suggests substantial effort needed retarget gdb 
dbx ported target machines single version different proprietary versions different behavior different machines 
ldb memories resemble hardware 
contrast cedar debugger uses approach manipulates cedar machine basic operations resemble cedar programming language swinehart section 
machine interface cedar data programs debugger including user interface tool lets users manipulate fields including procedures records chosen dynamically 
similar abstraction built top ldb postscript symbol tables memories expression server need detailed knowledge contents symbol tables isolated details ldb nub interface derived topaz protocol redell 
topaz provides completely reliable available debugging support section compares ldb 
approaches debugging support include system calls adams muchnick depicted controlling processes file system killian running target debugger chapter 
address space schaffer 
relative merits approaches discussed chapter 
performance debuggers sequential programs focussed breakpoints 
kinds breakpoint implementations common 
traps single stepping black patching code target program digital 
kessler describes fast implementation code breakpoints wahbe describes simulations implementations data breakpoints 
authors suggest best performance obtained code patching 
performance critical debugging parallel programs perturbing execution single processor may change behavior entire program 
parallel programming environment debugging offloaded second processor schaffer 
alternatively monitoring logging done special purpose coprocessor 
approaches branch coprocessor instructions transfer control target debugging code kernel intervention avoiding overhead trap handling context switching 
authors working implementations describe performance improvements orders magnitude 
current research debugging investigates extensions kind basic debugging features provided ldb 
extensions include better user interfaces event debugging debugging optimized code time travel replay debugging debugging parallel distributed programs 
user interface focuses mouse bitmapped display example possible plant remove breakpoints direct manipulation source code target program russell 
possibilities display draw pictures data structures target program myers visualize execution target program miller mcdowell session 
related displays considered programmable user interfaces simplifying manipulation exploration target events olsson crawford ho target data hanson 
problem debugging optimized code addressed viewpoints 
holds possible debugger appear user debugger computer executing original unoptimized program property called expected behavior 
debugger provide expected behavior fails carry user debugging request 
hennessy discusses problem recovering values variables original program 
discusses local global optimizations giving algorithms usually identify variables values correspond original program 
recover values variables 
zellweger describes effect optimizations presents implementation provide expected behavior presence cross jumping procedure inlining optimizations merge duplicate object code sequences associated particular source code sequences 
johnson combine 
modula terminology conventions context oriented debugging technique restrictions optimization guarantee expected behavior debugging session users tell debugging optimized programs 
brooks hansen simmons take opposite approach 
making appear computer executing original program debugger shows actual behavior target program including effects optimization 
debugger highlights source executed levels granularity including expressions statements blocks loops functions 
time travel debugging enables user explore state target program point execution 
time travel implies users move earlier states feature called replay reverse execution 
implementation technique source code transformation program log state changes 
early debugger technique ran program completion worked log give illusion interactive debugging time travel balzer 
logging cost reduced periodic checkpoints time travel implemented executing forward previous checkpoint 
compiler may transform source generate appropriate checkpointing code tolmach appel checkpointing may done run time system virtual memory operations feldman brown 
addition checkpointing internal state program may log significant external events input 
parallel distributed debugging emphasizes program visualization event matching time travel miller leblanc miller mcdowell 
event techniques bates wileden olsson crawford ho particularly suited implementation ldb 
ldb debug multiple architectures simultaneously process events pieces client server applications execute different hardware 
modula terminology conventions ldb implementation uses standard modula conventions thesis uses modula terminology refer implementation 
section explains important terms conventions describes code shown thesis edited clarity 
modula interface provides certain abstraction memory exports abstraction 
ldb follows modula convention naming interface abstraction exported interface 
abstraction type name chosen type memory exported memory interface full name type memory parts program memory import memory interface clients 
clients different users client part program 
chapter 
modula object oriented language objects fields methods subtypes inherit fields methods supertypes 
modula provides discriminated union type unions implemented subtyping explicit dynamic type checking typecase distinguish variants 
ldb uses technique postscript interpreter distinguish different kinds postscript values 
modula provides concurrency form multiple threads 
threads synchronized mutexes condition variables birrell 
lampson redell describe similar model concurrency 
connected target program ldb uses threads responds commands typed user responds events delivered debug nub 
modula procedures typically indicate errors raising exceptions returning special error values 
ldb uses exceptions signal mistakes user part misspelled variable names failures losing connection debug nub 
exceptions usually handled user interface prints messages describing problem 
modula common define types methods implemented example thread closure birrell section 
correct programs create instances types create instances proper subtypes implement methods 
standard term refer supertypes define subtypes create objects 
necessary refer supertypes supertypes 
modula code shown thesis differs code implementation brands raises clauses omitted qualified names exclusively 
qualified names definitions types procedures legal modula 
example definition memory shown form type memory legal form type 
organization second chapters chapter thesis begins pages introductory material ends discussion 
reading introductory part chapter gives overview entire discussions results 
chapter presents contrived example debugging session ldb 
session illustrates capabilities ldb problems solve 
examples chapters refer session example program 
memories ldb best read part chapter tackling chapters 
second part code needed understand detailed examples appear chapters 

organization reader interested ldb interaction compiler directed chapters describe postscript symbol tables expression evaluation server 
parts ldb compiler machine dependent 
chapter stands chapter assumes understanding ideas chapter especially section 
reader interested machine dependent parts ldb directed chapters describe debug nub breakpoints events stack walking 
parts ldb information compiler machine dependent done debugger 
chapters read independently chapters 
chapter explains ldb uses interpreted language language postscript 
presents interesting details ldb implementation postscript 
reader interested cost retargeting ldb directed chapter describes sizes part system target characterizes done retarget debugger proper debug nub machine dependent postscript 
different parts system difficult implement targets chapter explains differences 
chapter contains details accessible read chapters 
chapter identifies bad aspects ldb design suggestions designing related tools discusses techniques suggests directions research 
reader familiar earlier version ldb ramsey hanson directed especially sections describe ldb calls procedures target chapter describes general breakpoints chapter describes model stack frame layout eliminate machine dependent stack walking code 
chapter 
chapter debugging ldb chapter shows user view ldb capabilities means example debugging session 
overview capabilities provides overview problems solved chapters 
example serves framework define commonly terms 
ldb source level debugger 
users refer variables procedures name locations program source coordinate file name line number column 
debugger prints values sense terms source programming language terms representation particular machine 
users evaluate expressions assignments variables writing valid expressions assignments source language 
ldb user interface simple terminal oriented user interface 
programmable 
frequently commands letter abbreviations spelled full 
complete list commands appears chapter 
program chapter computes prints fibonacci numbers 
source file fib shown 
compile fib option lcc generate debugging information ldb include special startup code 
startup code gives control debug nub calling main giving nub chance initialize data structures install signal handlers described chapter 
nub looks program argument represent instruction nub 
example argument pause nub prints message stops target waits debugger connection calling main 
orchard lcc fib fib orchard fib pause 
debug nub debug ldb target fib connect orchard message contains command typed window starts debugger connects target program 
chapter 
debugging ldb void fib short static int int int printf printf main int argc char argv argc fib atoi argv fib return example program 
superscripts show stopping points 
fib compiled run orchard big endian sparc 
run ldb little endian mips 
message ldb target fib connect orchard holds commands start debugger choose target program connect instance 
target fib command identifies fib target program reads postscript describing fib 
ldb ldb target fib loading symbols fib 
checking linker table 
linker table ok ldb fib disconnected postscript comes compiler linker 
message linker table ok means consistent 
postscript provides information ldb needs identify names locations types procedures variables described chapter 
identifies fib sparc program enabling ldb select sparc dependent code data 
new prompt ldb fib disconnected indicates target fib selected ldb connected instance fib 
step connect identifies particular instance fib debug 
connecting target ldb displays event target wait debugger 
case initial pause requested argument pause 
events targets wait include faults invalid pointer signals user interrupts 
ldb fib disconnected connect orchard 
void int arg ldb fib stopped displaying event ldb prints current focus initially procedure activation executing event occurred 
special procedure target wait debugger 
establishing connection printing current focus involve interactions debug nub 
messages exchanged nub machine independent protocol matter host target machines different byte orders 
nub protocol described chapter 
typical ldb target connect commands combined executed sweep mouse ldb target fib connect orchard loading symbols fib 
checking linker table 
linker table ok 
void int arg ldb fib stopped debugger refer locations target program execution stopped stopped 
ldb expects compiler define set stopping points 
lcc places stopping points statements points statements control flow diverge 
compilers debuggers stopping points placed coarser finer granularities numbers linton expressions brooks hansen simmons 
shows fib stopping points 
procedure stopping points numbered order increasing object code location 
order differs source code order example compiling loops lcc puts termination test bottom loop 
ldb refers stopping points procedure name number fib 
ldb offers different kinds breakpoints 
simple breakpoints set single location specified stopping point source location 
user requests breakpoint source location ldb finds closest stopping point location sets breakpoint 
source locations referred file name line number optional column number 
ldb fib stopped fib fib break fib fib break fib fib fib 
ldb fib stopped kind breakpoint displayed differently 
set stopping point fib displays stopping point source location line column file fib second set line file fib displays source location requested actual source location stopping point breakpoint set column line stopping point 
compiler supplies ldb source object code locations stopping point described chapter 
chapter 
debugging ldb refer locations object code ldb raw addresses reports object code distance closest stopping point preceding location 
locations displayed angle brackets distinguish source locations displayed parentheses 
ldb breakpoint commands rely machine dependent low level breakpoints set single object code location 
implementations low level breakpoints described chapter 
breakpoint set source location corresponding object code location computed 
relation object code source locations stored postscript symbol table information emitted compiler linker described chapter 
continuing execution fib run hits breakpoint 
event occurs ldb prints event new focus 
ldb fib stopped 
break fib fib fib 
fib void fib short ldb fib stopped default ldb shows object code source locations stopped plus procedure arguments 
command shows focus detail including values local variables 
ldb fib stopped fib 
fib void fib short int int ldb fib stopped location stopping point line local variables visible 
shown fib variables declared nested scopes described chapter ldb uses tree structure represent nesting compute variables visible location 
ldb change focus walking target call stack 
caller fib main 
ldb fib stopped main 
fib int main int argc char argv xf ldb indicates control return main object location main stopping points main main 
chapter describes code needed walk stack find control return 
debug nub strips special arguments pause visible user program see looking argv 
ldb fib stopped argv char argv xf fib ldb fib stopped argv char argv xf ldb fib stopped argv char argv null ldb fib stopped command prints result evaluating expression 
expressions evaluated sending text expression evaluation server asks symbol table information describing free variables argv 
server compiles expressions postscript procedures ldb interprets get values described chapter 
ldb display available information symbol comes compiler 
variable information includes stored defined 
display command seldom long mnemonic name single letter name 
ldb fib stopped argv argv variable char argv defined fib ldb fib stopped argv register ldb fetch register get value 
time fib stops register holds argv local variable fib register holding argv saved stack fib called 
focus changes main ldb appear register holds argv 
memory locations stack appear registers 
postscript code emitted compiler expression server manipulate memory machine real memory registers 
ldb command shows entire call stack 
current focus marked star 
ldb fib stopped fib 
fib void fib short main 
fib int main int argc char argv xf main 
int main int argc char argv xf char xf start 
start symbol table information ldb fib stopped main procedure debug nub set nub data structures pause target calling main 
start system startup procedure 
arguments shown compiled lcc ldb symbol table information start 
ldb chapter 
debugging ldb walk stack information requires extra retargeting effort described chapter 
avoid stopping execution fib breakpoint conditional breakpoint ldb loop ldb fib stopped break fib fib break fib fib fib 
ldb fib stopped take break fib fib ldb fib stopped take command uses expression evaluation server compile expression context location fib current focus main compiled expression evaluated ldb hits breakpoint fib 
execution fib continued target hits fib times expression evaluates zero ldb continues silently 
target hits fib ldb stops target 
values computed 
ldb fib stopped 
break fib fib fib 
fib void fib short ldb fib stopped fib 
fib void fib short int int ldb fib stopped continuing execution stops second breakpoint line 
ldb fib stopped 
break fib fib fib 
fib 
fib void fib short ldb fib stopped ldb breakpoint commands addition finish continues execution current focus returns 
activations procedure finish ldb continues waiting current focus finish 
ldb fib stopped finish 
finish fib fff main 
fib int main int argc char argv xf ldb fib stopped number brackets fib identifies activation finished 
fib finishes prints newline fibonacci numbers appear standard output orchard window shows orchard fib pause 
debug nub debug ldb target fib connect orchard addition finish ldb offers breakpoint commands 
steps stopping point current activation machine instruction 
implemented mips sparc 
ldb breakpoint commands simple breakpoints conditional breakpoints finish source instruction level single stepping implemented single machine independent mechanism 
mechanism relies low level breakpoints generate breakpoint events 
event occurs ldb may evaluate expression print message check procedure activation take arbitrary action target tell continue 
chapter describes event action mechanism implement different breakpoint commands 
finishing execution fib ldb stopped stopping points main 
line shows call fib top level expression may clear code executed call 
ldb decode sparc instructions investigate having ldb disassemble display object code 
ldb fib stopped assembly main main ld main call atoi nop main xc call fib nop main ba main nop ldb fib stopped display shows code branch clause lines return main 
instructions shown pairs 
ldb encounters branch instruction delay slot treats pair single word instruction 
instruction decoding require considerable machine dependent code 
ldb uses special specification language reduce amount code language works best risc machines ldb decode mips sparc instructions vax instructions 
appendix shows specification mips 
chapter 
debugging ldb main finish possible call fib ldb 
executing call fib hits breakpoint 
ldb fib stopped fib 
break fib fib fib 
fib void fib short ldb fib stopped 
double arrow prompt indicates ldb debugging suspended procedure call evaluation fib stopped 
impossible profitable continue example event indicates unrecoverable error suspended call abandoned unwind reverts previous focus 
ldb fib stopped 
fib 
fib void fib short int int ldb fib stopped 
unwind ldb fib stopped main 
fib int main int argc char argv xf ldb fib stopped unwinding execution fib finishes means call produce output 
possible undo breakpoints temporarily order continue executing call 
command undoes breakpoints 
ldb fib stopped fib 
break fib fib fib 
fib void fib short ldb fib stopped 
undone break fib fib undone break fib fib fib 
ldb fib stopped 
void fib void ldb fib stopped continuing execution main 
lets target program finish 
ldb fib stopped main 
fib int main int argc char argv xf ldb fib stopped 
target terminated ldb fib disconnected orchard window fib ran shows output third calls ran completion 
orchard fib pause 
debug nub debug ldb target fib connect orchard orchard breakpoints retained session 
ldb command re activates undone breakpoint 
redone breakpoints automatically planted ldb connects instance target ldb fib disconnected break fib fib break fib fib fib 
ldb fib disconnected example shows ldb features walking call stack printing values evaluating expressions interacting target process 
chapters follow describe implementations features show implementations retargeted machine 
summarizes ldb commands 
commands synonyms default arguments show synonyms variations 
chapter 
debugging ldb print available information symbol 
assembly show disassembled object code 
plant breakpoint list breakpoints 
continue execution target 
call evaluate expression discard result 
cd change ldb working directory 
connect connect instance target program 
delete breakpoint 
disc disconnect target program may continue wait debugger exit 
eval evaluate expression discard result 
event print event caused target 
print current focus 
print current focus detail 
finish continue execution target designated activation finishes 
pass text directly postscript interpreter 
continue execution target reaching stopping point designated activation 
exit debugger target program 
redo undone breakpoint see 
run fork new target process child ldb connect 
step machine instruction 
trace call stack 
trace call stack showing detail 
take breakpoint conditional skip hits 
undo breakpoint 
redone see 
unwind debugging suspended procedure call return previous context 
whatis print information symbol 
move current focus frame 
move current focus frame 
move current focus frame summary ldb commands 
chapter memories memory provides machine independent model target memory registers 
postscript code generated compiler expression evaluation server includes fetches stores operate memories 
example chapter ldb prints focus fib 
fib void fib short value fetched register memory 
commands chapter stopped targets including setting breakpoints walking call stack printing assembly code memories 
memory collection spaces denoted lower case letters data space registers locations space determined integer offset 
ldb provides addressing modes refer locations including immediate mode 
modes locations general simple addresses example refer register contents values located indirection respect registers 
memory location ldb fetch store sizes integers bits sizes floating point values bits 
memories locations postscript values modula values fetching storing easy postscript modula 
ldb assumes machine code data spaces may refer locations different locations depending target architecture 
spaces added needed provide model particular architecture example provide separate space register set 
shows spaces ldb uses mips locations space represents integer registers floating point registers extra registers 
extra registers program counter virtual frame pointer putting memory easily accessible postscript 
mips actual frame pointer postscript code generated lcc uses virtual frame pointer stack pointer address local variables 
mips code data spaces refer locations chapter 
memories names types values sizes floats integers floating point registers integer registers code segment data segment extra registers structure memory mips 
treated slightly differently 
example storing value code space flushes instruction cache 
memory shown ldb prints values evaluates expressions executing machine dependent modula code postscript emitted compiler expression evaluation server machine dependent 
debugger machinedependent part problem construct memory 
memory associated stack frame memories constructed stack walking code described chapter 
simplify job ldb defines different kinds memories implement different spaces combined 
combined way targets machine independent code 
code uses machine dependent specifications names sizes spaces memory shown section 
creating full memory simple reusable pieces retargeting easier memories implemented scratch target 
section explains different kinds memories combined form full memory shown 
section shows values locations memories defined modula material needed understand detailed examples register restoring code chapter 

kinds memories kinds memories debug nub provides foundation memories 
machines provides access code data spaces shown right 
left full memory middle instances kinds memories 
fetch store requests flow left right replies right left 
debug nub far right changes target memory directly 
nub written modula implements abstraction instances 
dashed line separates debugger process target process 
nub runs target process ldb access memory process 
wire kind memory holds connection nub forwards fetch store requests nub executes returns results 
part constructing memory identifying locations registers saved making locations appear registers 
registers saved stack process context area memory holds state stopped program 
debug nub creates process context time target stops 
alias memory translates requests locations register spaces requests locations data space process context call stack 
example mips process context holds integer registers offset floating point registers offset 
context located address alias memory translates request integer register request word offset theta context word 
aliases mips extra registers refer locations stack immediate locations 
immediate location immediate operand machine instruction holds value correspond location target data space 
ldb create new immediate locations 
mips virtual frame pointer example represented location target memory debugger computes virtual frame pointer adding frame size stack pointer putting result immediate location 
compiler puts value register register saved memory resulting representation may different compiler simply put variable memory directly 
example character put register register saved memory address character may address saved register depending byte order target 
character variable allocated register saved previous paragraph may 
impossible fetch byte representing directly memory target byte order known 
value recovered knowing byte order composing operations fetch full bit word address narrow result bits masking xff 
register memory hides need size conversions transforms fetch fetch widen store narrow store 
register memory changes sizes chapter 
memories context immediate locations joined memory register memory alias memory wire nub debug nub debugger implementation memory stack frame 
types values converts integer floating point value vice versa 
conversions described machine dependent specification gives sizes registers hold size type value 
default bit machines specifies bits hold integers sizes number bits hold floating point value number bits value 
original type transformed type bit integer bit integer bit integer bit integer bit integer bit integer bit float bit float bit float bit float bit float bit float register memories byte order irrelevant enabling ldb execute code debugging program little endian big endian mips example 
register memory wire provide spaces shown 
joined memory combines forming memory containing necessary spaces 
memory associated stack frame joined memory 
joined memory passes fetch store requests appropriate underlying memory travel graph shown 
shows sequence requests fetch value order print fib 
fib void fib short 
implementing memories type short corresponds low level type bit integer indicated 
stored integer register postscript code fetches integer type offset space joined memory identifies space served register memory fetches register memory 
register memory fetches corresponding full bit word alias memory 
register alias location data space bytes context alias memory fetches wire location 
wire sends message nub fetches word target byte order sends value back debugger little endian order gets returned call chain 
register memory narrows value returning low order bits value returned joined memory 
requests fetch values data code spaces bypass register alias memories joined memory fetches directly wire 
implementing memories section shows memories implemented modula 
code important primarily understanding detailed examples chapters 
definitions needed memories appear memory location interfaces 
target holds integer floating point values represented debugger memory integer memory real 
memory value acts union type allocation modula objects expensive debugger pair object types represent disjoint union integer real 
memory type requests identify type size value 
type memory integer integer memory real memory type memory value record memory real memory integer integer true implementation assumes integer big hold target integer similarly 
assumption hamper ldb retargetability machine widest types wide hold value machine 
cross debugging difficult ldb run bit host debug bit target 
chapter 
memories memory interface memories locations data types operations defined fetch store 
type memory memory location displayed procedure memory fetch memory memory location type memory type memory value procedure memory store memory memory location memory value type memory type fetch store raise exceptions invalid addresses 
operator denotes subtype relation 
type opaque postscript object chapter memory subtype values type memory manipulated directly postscript interpreter 
displayed subtype print method user interface memory location subtype displayed implement print method giving suitable output syntax 
example output syntax location denoting register 
implementation command prints calling print method location ldb fib stopped variable int defined fib ldb fib stopped location interface provides ways constructing locations reveal representation 
location memory somewhat operand specifier cisc machine 
basic locations specify immediate value offset space 
space lower case letter offset type memory address 
integer assumed large hold address target space 
type memory space memory address integer procedure location absolute offset memory address space memory space memory location procedure location immediate memory value memory location page shows location absolute chapter shows examples postscript 
procedure page shows examples location immediate including creation immediate location mips virtual frame pointer 

implementing memories location constructed shifting adding integer constant offset existing location changing space 
shifting immediate location nonsensical 
procedure location shifted offset memory address base memory location memory location location indirect offset fetched base location 
procedure location indirect offset memory address space memory space base memory location type memory type memory location locations local variables lcc puts stack indirect respect frame pointer 
memory shifted indirect location simplified absolute location 
section shows ldb implementations postscript operators procedures memory location interfaces 
postscript code emitted compiler expression evaluation server uses locations stylized ways 
absolute locations refer variables allocated registers fixed locations data space locations code 
indirect locations refer variables allocated stack indirect respect frame pointer argument pointer 
shifted locations refer elements arrays structures unions offsets recorded compiler 
immediate locations represent integer constants read values results expression evaluation 
fetching immediate location register memory may require size conversion 
memory interface defines procedure conversions 
procedure memory source memory value type memory type memory value procedure change size value raises exception asked convert integer floating point data 
procedures location interface allocate modula object type memory location hold results 
memory interface provides shortcut cases absolute location created fetched shortcut avoids allocation 
procedure memory memory offset memory address space memory space type memory type memory value equivalent fetch location absolute 
memory analogous 
memory supertype type instantiated directly 
kind memory defines different subtype memory fetch store procedures subtype independent code resolve complex locations absolute immediate ones chapter 
memories fetch immediate locations 
fetching storing absolute locations implemented different methods supplied different subtypes 
code creates instance subtype indicate spaces valid arguments instance fetch store methods subtype independent code guarantees methods called spaces 
described ldb uses joined memory combine different memories recognize different spaces 
procedure memory join creates memory 
procedure memory join memory memory necessary identify subtype memory implements joined memory 
set spaces valid joined memory union sets valid components 
absolute fetch store methods whichever underlying memory contains space question conflict 
joined memory subtype implemented memory module subtypes defined interfaces implemented corresponding modules 
alias memories create new spaces example alias memory creates spaces figures 
locations spaces aliases locations existing underlying memory connection debug nub 
spaces contain aliases requests passed unchanged underlying memory 
subtype implements alias memories special methods create query aliases 
alias memory created specifying underlying memory names spaces contain aliases sizes spaces 
declaration indicates subtype memory additional methods shown procedure new underlying memory readonly spaces array memory space readonly sizes array integer type memory object methods bind offset integer space memory space memory location binding offset integer space memory space memory location bound offset integer space memory space boolean created memory contains aliases raise exceptions 
bind method creates alias location memory underlying passed new 
bound binding methods tell location alias return alias associated location 
methods raise exceptions offset bounds space memory created 
binding method raises exception alias exists location requested 
page shows examples methods 
alias memory creates bindings locations registers saved stack 
register memory uses alias memory underlying memory guarantees operations underlying memory complete saved registers parts thereof 
alias 
implementing memories memory register memory creates new spaces changes treatment existing spaces 
register memory created specifying underlying memory set spaces conversions conversions desired 
specification conversions maps type request type underlying memory 
bit targets default specification bits maps integer requests bit requests leaves floating point requests unchanged 
clarity repeat definition memory type showing unqualified name type 
type type specification array type type const bits specification type type type type type type procedure new underlying memory spaces set memory space readonly spec bits memory new memory join returns anonymous subtype memory register memory uses machine dependent specification type conversions fetch store methods machine independent 
memory conversions 
example implementation absolute fetch method 
procedure fetch offset integer space memory space type memory type memory value space return memory underlying offset space spec type type return underlying offset space type fetch trapped memories memories provided nub wire complicated shown 
understand digression breakpoints necessary 
implement breakpoints debugger replaces original instructions target program new instructions traps branches cause control transferred target debugger 
debugger remember original instructions restore deletes undoes breakpoint 
debugger crashes original instructions lost breakpoints deleted 
standard unix debuggers problem subsumed greater problem standard unix debugger crashes ability debug target lost 
chapter 
memories remote debugging possible unacceptable lose access target program just debugger machine crashes user able connect second instance debugger target 
second instance undo breakpoints planted instance information original instructions saved target debugger 
storing information responsibility trapped memory implemented debug nub 
called trapped memory ldb uses traps branches implement breakpoints 
trapped memory machine independent uses information target instruction set 
needs store integers code space undo effects stores plant suspend methods 
caller plant method responsible appropriate type bit pattern describe trap instructions 
traps change contents memory seen fetch store methods 
type memory memory type memory type memory object methods plant pc memory address memory integer type memory suspend pc memory address traps ref array memory address plant method store method space known code space value known integer 
memory subrange memory type describes integer types 
traps method needed second instance debugger identify locate traps planted instance 
combining memories combined memories shown assembled ldb generic code described section 
parameter generic code machine dependent configuration interface 
interface constants hold machine dependent details needed create constituent parts 
constants mips const array array integer set bits describe memory shown 
specifies mips memory spaces addition basic spaces shows 
implementing memories locations spaces contain 
indicate spaces require type transformation register memory specifies transformation 
mips spaces represent integer floating point registers space holds values program counter virtual frame pointer 
uses default treatment bit machines shown full 
change size floating point requests necessary include 
generic code creates combines memories specification procedure 
memory var new aliases return memory join new represents wire connecting debugger nub 
code create memories vax shown figures 
register sets hardware plus extra hold program counter 
memory specifications const array array integer set specification memory type memory type default register memory specification floatingpoint registers bits wide 
vax single register set includes program counter 
specifications array array integer set bits creating aliases registers requires detailed information registers saved stack process context 
reason alias creation discussed stack walking code section 
chapter 
memories names sizes floating point registers address registers code segment data segment data registers extra registers memory 
names sizes registers code segment data segment vax memory 
discussion structures memories differ architecture architecture 
retargeting straightforward complex memories created combining simple ones 
shown machine dependent aspects simple memories specified just lines 
earlier version memories richer set types modeled basic types 
example different bit integer types signed integer unsigned integer pointer 
fetch store method handles type reducing number types simplified implementation kind memory 
simpler implementations easier understand maintain 
cost change slight postscript procedures shown section sign extend integer values 
ldb locations similar simpler provided dec src debugger modula detreville 
include length location bit level byte level granularity 
extra complexity confers advantages example possible refer bit field single locative ldb triple location word containing field field size field offset word 
ldb manipulate bit fields directly interpreting postscript emitted compiler 
compiler generate code refers locations bit level expect location associated length adding features simplify implementation compiler expression server debugger 

discussion locations unnecessarily restrictive implemented just idioms general mechanism difficult implement 
languages may require different idioms 
example location field modula object computed indirection shifting respect location object dec src compiler uses indirection representation objects 
assumption integer debugger big hold integer target explicit memory interface assumption pervades ldb 
example postscript code emitted expression evaluation server uses standard postscript operators implement arithmetic target integers 
eliminating assumption require arbitrary number debugger words represent target word appropriate changes arithmetic 
modula provides way implement changes easily operator overloading 
abstraction hide representation target data resulting implementation efficient available modula compiler inline procedure calls 
extra overhead acceptable demonstrated need cross debugging common case run debugger machine word size architecture target 
sizes differ machine large words debug machine small words converse example bit workstation debug program running bit pocket computer 
ldb handle scenarios machines various word sizes change representation target integers 
ldb debug core files 
doing require creating memory corresponds core file 
machine dependent code needed get data space registers core file code space corresponding executable file 
programs debugged ldb normally create core files debug nub intercepts signals lead core file creation 
core file created internal error nub 
chapter 
memories chapter postscript symbol tables ldb needs information compiler 
users refer variables procedures name debugger find meanings names 
names defined nested scopes name mean different things different locations program 
nested scopes described tree provided symbol parent previously declared symbol current enclosing scope 
ldb uses stopping points refer locations described chapter 
stopping point associated symbol meaning name stopping point determined starting associated symbol walking tree finding symbol name 
shows procedure fib chapter 
shows tree containing fib local symbols box right shows symbol associated stopping point 
example stopping point fib associated entry symbol visible 
command chapter uses tree print values visible local variables ancestors 
ldb fib stopped fib 
fib void fib int int int local scopes symbols linear search tree works 
ldb puts top level symbols hash tables faster lookup 
top level symbols declared extern put single hash table shared compilation units 
top level symbols declared static put separate compilation hash tables symbols private compilation unit 
ldb associates meaningful name symbol symbol type 
ways symbols types determine ldb needs know 
debugging chapter 
postscript symbol tables void fib int static int int int printf printf procedure fib stopping points 
stopping points loci fib formals tree structure fib symbol table 
symbols types primarily print values variables requires name location type variable 
symbols procedures contain information stopping points procedure way finding procedure formal parameters shown 
symbols provide locations values types determine printed 
debuggers define fixed set type constructors provide fixed set printing procedures constructor 
ldb uses novel technique compiler supplies printing procedure type symbol table 
technique described section enables ldb print values knowing layout run time data structures avoiding source machine dependence 
ldb independent type system target programming language 
information symbols types evaluate expressions 
described chapter ldb uses modified instance compiler evaluate expressions 
symbols types ldb contain information possible reconstruct compiler representation 
information needed ldb created compiler linker 
lcc determines symbol type information locations automatic register variables unix linker determines locations procedures stopping points global static variables 
ldb encapsulates information linker linker state object methods provide location external symbol address procedure containing program counter value address procedure procedure symbol table linked program 

representing debugging information postscript representing debugging information postscript ldb uses postscript adobe represent symbol table information 
postscript language printers linguistic support printing imaging general purpose stack programming language similar spirit forth moore 
printing imaging support comes extensive collection built operators 
software graphics workstations analogous hardware provides special operations support graphics linguistic support graphics 
graphics programs ordinary programs call library procedures graphics hardware sgi 
printing ldb postscript operators play role library procedures applications different sets operators 
forth postscript scalar composite types types operations checked run time 
postscript integers reals booleans arrays dictionaries names strings procedures 
postscript dictionaries hash tables associate keys values 
predefined dictionary associates names operators invoked names 
procedures operators find arguments return results postscript operand stack usually called just stack 
dictionaries arrays built applying special bracketing operators shown contents operand stack 
dictionary stack associate names values including operators dictionaries stack play role nested scopes resolve operator names 
postscript procedures change dictionary stack run time changing meanings names 
symbol table information comes compiler linker ldb organizes levels 
compiler provides top level dictionary compilation unit 
top level dictionary provides access symbols types ways array procedures defined unit dictionary associating names global symbols symbol table entries 
top level dictionaries different units combined debug time ldb uses single top level dictionary describes program 
information determined link time stored linker table incorporates top level dictionary compilation unit program 
ldb uses information linker table implement linker state 
rest section describes ldb representation symbol table information working symbols types top level dictionaries linker tables 
symbol table entry postscript dictionary describing source language identifier variable procedure type constant 
compiler generates names refer symbols types 
symbol table entry line sample program shown associated generated name 
name type fib kind variable chapter 
postscript symbol tables absolute uplink 
def slashes precede literal names parenthesis delimit literal strings 
brackets delta delta delta 
surround code constructs dictionaries dictionary names preceded slashes associated values follow 
name type kind uplink appear symbol table entries appears entries variables procedures 
value associated represents location computed symbol table interpreted 
absolute postscript operator calls modula procedure location absolute described section 
absolute evaluates offset space memory integer register 
code fetches type dictionary lcc predefined types int 
dictionary 
decl int printer pi 
def ldb loads predefined type dictionaries target architecture selected different architectures different definitions 
single copy predefined types avoids repeating definitions symbol table 
ldb proper expects source level type dictionaries contain keys decl associated string declare variables type printer associated postscript procedure print values type 
printing procedure access just memory location type dictionary 
lcc uses single procedure pi print values signed integer types char 
ellipsis stands information ldb proper printing procedure postscript code supports expression evaluation 
implementation pi described section expression evaluation chapter 
symbol table entries key uplink associated entry symbol parent 
uplink value symbol table entry line associated generated name 
excerpt fib symbol table shows uplink keys form tree shown 

name uplink null 
def 
name uplink 
def 
name uplink 
def 
name uplink 
def 
representing debugging information postscript assembly code 
align word main word fib word word word word word word word word word word 
normal object code data oe address main address fib address main address main address main address main address main address main address address fib address fib address fib 
contents memory addresses stopping points statics anchor symbols 
fib declared static location determined link time 
linkers provide location information relocating symbol table entries stored machine dependent format object files 
postscript avoids retargeting burden generating reading formats impossible standard linker symbol relocation ability provide locations 
linker modified generate appropriate postscript transform postscript emitted compiler retargetable linker modification repeated new target 
alternative linker relocates top level symbols appear memory 
modified lcc place labels variables assembly language output distinguished symbol called anchor symbol 
programs larger 
locations anchor symbols known locations indirection respect appropriate anchor symbol 
shows anchor symbol find location static variable line 
name anchor symbol address stored th word anchor symbol 
chapter 
postscript symbol tables symbol table entry associated shows postscript defines location relative anchor symbol 
type dictionary associated 


decl int name printer array type 
fib 
def kind variable uplink 
def associated procedure interpreted debug time computes location calling 
gets location anchor symbol ldb linker state fetches address th word location shown 
symbol table entry procedure holds source object code locations associated symbols stopping points procedure 
holds entry procedure formal parameter formal parameters reached uplink keys 
procedure null uplink top level symbol uplink look local symbols 
stopping point information associated key loci formal associated key formals 
fib symbol table entry associated ls object code def 
name fib uplink null loci ls formals 
def square brackets delta delta delta delimit postscript arrays 
performance reasons stopping point information stored array elements 
element shown array containing symbols associated stopping points 
associations shown example fib associated symbol table entry second element shown section contains source object code locations stopping points 
symbol table entry procedure contains register save information described section 
access symbols types provided top level dictionaries describe single compilation unit combination compilation units including entire program 
top level dictionary contains array symbol table entries procedures dictionary associating external symbol names symbol table entries dictionary associating file names arrays symbol table entries procedures defined files array names anchor symbols 
anchor symbol names compared anchor symbol names linker 
postscript symbol tables hcode build full top level procs 
main fib 
fib anchors architecture sparc top level dictionary fib 

fib main 
symtab level linker table program fib 
table see ensure top level dictionary matches object code 
top level dictionary contains name architecture program compiled 
ldb uses name look modula object containing machine dependent code data 
assuming represent symbol table entries procedures main fib top level dictionary fib built code shown 
linker table contains program top level dictionary dictionary associating names anchor symbols addresses array address name pairs procedure program 
fib linker table shown 
provides information needed look locations anchor symbols name 
binary search find procedures program counter value 
symtab program top level dictionary returned ldb requests symbol table 
modify linkers generate postscript arranged lcc compiler driver build linker tables 
linking program driver uses unix program nm find locations anchor symbols procedures 
anchor symbols identified names 
procedures text segment sufficient include locations symbols text segment 
superfluous symbols matter long occur middle procedures 
postscript symbol tables contents structure linker tables top level dictionaries determined ldb information 
debugging information voluminous typical debugging session uses small part 
performance best read needed 
ldb chapter 
postscript symbol tables operation steps ldb implementation find current stopping point program counter procedure address procedure address symbol table entry binary search list stopping points resolve name follow parent pointers current stopping point locals search table names private current compilation search table global names show user stopped source source location current stopping point set breakpoint source location source file name array procedures enumerate stopping points sort source coordinate find nearest stopping point binary search set breakpoint stopping point object code location find locations bound linker compiler plants memory near distinguished symbols post link pass locates distinguished symbols locations fetched relative distinguished symbols sources information linker table top level dictionary procedure symbol table entry stopping point table debugger operations need symbol table information 
builds internal data structures lazily working compilation unit source file procedure symbol time 
table shows debugger operations need information compiler linker 
right hand side summarizes ldb implementation operations indicating parts postscript symbol table step 
indicates linker table top level dictionary symbol table entry procedure single stopping point 
ldb uses binary searches find stopping point corresponds current program counter 
searches linker table address procedure containing stopping point 
procedure address look symbol table entry hash table 
ldb builds table top level dictionary procs lists symbol table entries procedures top level dictionary 
entry contains address 
having procedure ldb searches stopping points find nearest program counter 
single level search require addresses stopping points mean touching procedure symbol table entry 
level search means procedure symbol table entry needed 
reduces size global table large factor fib small procedure stopping points 
debuggers similar level search techniques linton russell 
ldb name resolution algorithm discussed 
current stopping point provides access local symbols visible point current procedure provides access 
representing symbols types modula symbols private compilation unit 
global symbols looked top level dictionary 
array stopping points defines relation source object code locations 
object code location ldb find corresponding source location quickly linker table symbol table entries contain arrays procedures stopping points sorted object code location 
postscript tables provide support inverse problem expensive solve 
search stages 
stage identifies array procedures contain code source file question 
information provided directly top level dictionary requires hash table lookup 
preparing second stage expensive ldb examines stopping points procedures file building list points sorted source coordinate 
source file lines process take second 
list prepared saved re searches ldb finds stopping point interest binary search 
initial delay reduced associating procedures just file name range source locations file resulting implementation complicated 
debuggers different strategies example dbx keeps tables files line numbers sorted object code location linear searches tables linton 
ups identifies function containing source location linear search set line numbers russell 
ldb uses anchor symbol technique find locations bound linker steps summarized table 
locations anchor symbols provided linker table postscript procedures compute locations appear symbol table entries 
debuggers symbol tables machine dependent formats appear object files linkers relocate symbol tables 
representing symbols types modula internally ldb uses modula objects represent symbols types 
objects provide information postscript representations quicker access 
access postscript object requires run time type check access modula objects requires compile time type check 
ldb performs run time type check converting symbol type postscript modula representation 
symbols represented internally objects type symbol different subtypes represent procedures variables types constants 
symbol converted postscript dictionary symbol symbol needed 
conversion done result saved back postscript dictionary associated key cache 
saving result avoids having repeat conversion time ldb needs internal form chapter 
postscript symbol tables dictionary 
association possible symbol defined subtype postscript object 
symbols contain locations represented postscript directly objects type memory location procedures anchor symbol technique 
converting location postscript modula ldb interprets postscript object represents 
simple postscript object memory location executed pushing operand stack procedures anchor symbol technique compute location leave stack case result location winds stack ldb pops saves modula representation 
ldb uses location overwrite postscript object original symbol table entry postscript procedures symbol need repeat computation 
locations procedures including locations stopping points assumed code space 
ldb modula representation full memory location locations uses just offset code space 
representation uses memory speeds searches integer offsets compared quickly full memory locations 
ldb assumes symbol table entry procedure program satisfy assumption builds dummy entries procedures compiled lcc 
dummy entries lack information stopping points local variables 
targets machinedependent stack walking code adds machine dependent data register save information described section 
contents type dictionary determined ldb needs source language types values 
described chapter ldb relies server expression evaluation thing debugger source language values print 
mentioned printing requires location printing procedure 
locations values supplied compiler constants variables expression evaluation server values results expressions 
compiler supplies printing procedures types 
useful print type variable expression value shown chapter 
fib 
fib void fib short print short just ldb uses string supplied type stored type dictionary compiler 
printing values postscript printing procedure called finds stack memory containing value location value memory type dictionary describing value type 
compiler writer type dictionary store extra information printing procedure 
technique poor man object oriented postscript simplify 
printing values compiler writer job 
example lcc define different printing procedure type defines procedure type constructor 
lcc puts information type dictionaries print methods distinguish different types constructor distinguish array integers array doubles 
lcc need generate specialized procedures fly uses predefined printing procedures specializes information type dictionaries 
information type dictionary helps basic types share print methods 
lcc front supports basic types float double unsigned unsigned short unsigned char int short char basic print methods 
memory type stored compiler fetch value memory 
methods differ way values printed decimal hexadecimal character literal 
printing floating point types unsigned types char respectively 
fourth method signed integer types char sign extends value printing decimal 
lcc emits call pf print values floating point types 
pf uses value type dictionary key mtype associated memory type fetch value 
pf pf mtype get memory fetch put def get gets memory type stack holds memory location memory type arguments needed memory fetch 
put writes value standard output 
printing procedures unsigned integers characters similar 
printing signed integers requires second access type dictionary key associated number bits integer sign extension 
pi dup roll mtype get memory fetch exch get put def dup roll saves copy type dictionary extracting mtype fetching value 
procedure implemented standard postscript operators bit manipulations 
dictionary usable pi describes predefined type int sparc 

decl int printer pi mtype memory type 
def type constructors nullary 
printing procedures non nullary constructors call print procedures associated key printer type dictionaries 
example chapter 
postscript symbol tables array dict type exch def loc exch def exch def type type get def type size get def size get def limit mul def put sub dup ne put break dup limit ge 
put pop exit loc roll shifted dup printer get exec put def printing procedure arrays 
procedure prints arrays expects find element type dictionary associated key type array type dictionary 
lcc associates size type key size type dictionary 
size array type divided size element type determine number elements 
representations types sizes type dictionaries chosen match lcc representations simplify printing procedures 
matching representations postscript lcc easier re lcc expression evaluation server described section 
print arrays lcc emits calls postscript procedure array shown 
begins line creating temporary dictionary hold local variables 
type associated array type dictionary loc location array memory 
associated element type dictionary discussed section 
associated size array size element 
ldb print elements large arrays prints elements 
initially changed user debug time 
limit associated offset limit element line stops printing elements limit element reached 
reproduced chapter sample output array prints elements array braces separated commas 
int 
printing values placement elements page computed supplied modula library kalsow muller 
procedures available postscript operators printing procedures operators print text 
calls operators specify points text may split lines fragments text grouped level indentation 
example line break permitted element array elements grouped forcing element indented level element 
oppen describes similar operators 
lines contain calls printing 
lines print opening closing braces 
cause grouping array elements argument specifies relative indentation elements respect 
loop lines loops offsets elements array 
line prints comma element 
break line tells line break possible comma subsequent lines indented respect line 
line checks see limit element reached prints ellipsis exits element printing loop 
line prints element 
offset element stack loc roll stack holds memory location array offset 
shifted postscript version location shifted described section converts location offset new location 
puts element type dictionary stack dup printer get exec fetches printing procedure dictionary executes 
array printed line pops dictionary stack removing dictionary holding local variables 
array example shows policies determine appearance structured data embodied calls 
policy array elements packed line fit structure members appear separate lines entire structure fits line 
policy implemented having structure printing procedure call member array calls break element 
printing policies changed changing implementations printing procedures 
printing procedures array values postscript variables alter behavior 
default ldb prints elements arrays characters strings 
users change values dynamically redefining postscript variables 
default ldb dereference pointers printing 
users dereference pointers setting postscript variable 
larger values cause printing procedure follow chains non null pointers length 
types special printing procedures 
char printed string literal pointer character 
function pointer procedure prints name function address 
expression server uses special procedure print character arrays string chapter 
postscript symbol tables literals convenient synthesize tiny type dictionary containing procedure construct general type dictionary array characters 
performance enhancements expensive interpret postscript builds top level dictionary 
example takes seconds build top level dictionary lcc lexical analysis module lines includes non blank lines header files 
building top level dictionary mips version lcc lines header files takes seconds 
ldb uses lazy evaluation defer interpretation postscript reduce delays seen users 
lazy reading postscript files defers reading postscript builds top level dictionary dictionary 
lazy transformation type symbol dictionaries defers lexical analysis interpretation postscript associated symbol type dictionaries dictionaries 
techniques complicate representation top level dictionaries symbols types 
lazy version top level dictionary defer reading interpreting postscript builds full top level dictionary 
ldb builds lazy version lcc top level dictionary seconds 
place usual information provided top level dictionary lazy version provides pathname file holds full information 
table operations top level dictionary provide marked look external symbol name look procedure address map source file name array procedures 
lazy version symbol table entry external symbol key lazy associated pathname file read build full top level dictionary containing external symbol 
lazy version procedure symbol table entry appearing top level dictionary procs array additional key compute procedure location usual way 
location needed procedure looked address part finding current stopping point shown table 
cases symbol table entry identified lazy version presence key lazy 
quite true top level dictionary maps source file name array procedures 
support lazy reading postscript files maps source file name meta array 
element meta array array procedures indicating full version pathname indicating lazy version 
shows code builds lazy version fib top level dictionary 
pathname read file compiled dictionary appears operand stack 
single symbol table entry re lazy versions identical 

performance enhancements hcode build lazy top level architecture sparc dict exch def 
lazy 
def anchors architecture sparc 
main fib procs 
lazy 
lazy 

fib temporary dict architecture sparc building lazy version fib top level dictionary 
procedure procs lazy symbol table entry procedure different location 
ldb encounters lazy key symbol table entry pathname meta array reads named file builds new top level dictionary merges top level dictionary entire program 
stores new versions symbol table entries external symbols top level dictionary overwriting lazy versions 
stores new procedure entries internal hash table lookup address 
new source map merged appending new meta array existing meta array replacing occurrences pathname empty arrays 
merging done postscript code storing procedures internal hash table 
lcc cuts clutter writing single postscript file ldb build lazy full top level dictionary 
read file ldb sets variable lazy true false depending lazy full dictionary desired 
puts file pathname stack inserted lazy dictionaries necessary interprets file 
chapter 
postscript symbol tables postscript file written lcc form lazy hcode build lazy top level exec hcode build full top level lazy false code build lazy top level dictionary skipped quickly string 
string executed file closed preventing ldb reading postscript 
lazy evaluation technique defer computation needed build single symbol table entry type dictionary 
values symbol table entry simple immutable integers strings locations 
values appear postscript literals 
literals keys associated put string need interpreted values needed 
string associated key cache dictionary 
technique reduces time ldb needs build top level dictionaries 
symbol table entry program fib value uplink hidden string 

uplink cache type name fib kind variable absolute 
def type hidden predefined type int 
version conversion cache appears page 
ldb perform transformations symbol type dictionary 
interpret string associated cache inserting resulting key value pairs dictionary convert dictionary symbol expression type 
avoid repeating conversion key cache associated result conversion 
postscript code needs dictionary converted 
interprets string associated cache stores results dictionary 
avoid repeating step associates dictionary cache 
postscript function job finding stack dictionary information may hidden cache string leaving 
generating postscript symbol tables string dictionary symbol expression type types values associated key cache symbol type dictionary 
version dictionary information associated directly appropriate keys 
shows possible states symbol type dictionary type value associated cache 
information source object code locations stopping points kept string leading part representation described section 
locations fib stopping points represented follows object code fib fib 
source locations described file name line column object code locations computed anchor symbol technique 
generating postscript symbol tables production versions lcc generate symbol table dbx gdb 
stab generation isolated function interface internal lcc front 
lcc generates postscript ldb different implementations functions minimizing changes rest lcc 
interface extended support ldb code supporting dbx code supporting ldb implement overlapping subsets functions 
field added lcc symbol type represent trees described section 
lcc sets fields maintaining scope pointer declared symbol scope 
compilation field global scope provides access global symbols extern static 
lcc saves information compilation emit postscript entire program compiled 
strategy easy write single postscript file contains lazy full top level dictionaries temporary files 
chapter 
postscript symbol tables stopping points provide access local symbols 
stopping point source object code locations location associated symbol 
items known simultaneously pairs 
lcc passes function 
associated symbols computed pass object code locations second 
lcc pass parses type checks build intermediate representation 
time encounters stopping point appends list point source location declared symbol 
function parsed list record relationship stopping point symbol 
second pass calls back generate assembly code 
code generation stopping points associated labels compute object code locations anchor symbol technique 
association computed symbol table code front 
compilation finished symbol table code combines lists stopping point information making possible emit point source object code locations associated symbol 
stopping points code comparisons 
addition information stopping points symbol table code records register save information function 
emit postscript symbol table needs top level symbols 
front supplies declared top level symbol linked uplink fields 
local symbols accessible symbols associated stopping points 
lcc begins emitting definitions symbols types defined compilation unit 
lcc type symbol data form directed graph representations recursive types create cycles graph 
lcc traverses graph emits postscript single pass 
code emits postscript need consider meanings cycles choose order define dictionaries identify arcs point earlier dictionaries 
arcs added graph symbol type dictionaries nodes defined 
added adding appropriate key value pairs existing dictionaries 
example code adds arc defined symbol put emitting definitions symbol type dictionaries forward arcs lcc emits postscript code builds top level dictionary 
code shown 
dbx suggests debugging information redundant 
source redundancy header files debugging symbols header file appear compilation unit includes file 
lcc reduces duplication omitting definitions symbols defined compilation unit 
passed se flag includes definitions making symbol table larger 
flag useful users want examine variables call procedures defined library code compiled lcc 
increase symbol table size varies widely program 
table lcc large program uses library procedures larger external symbols 
discussion included 
table agrep line string matcher wu manber larger 
table line macro processor ramsey times larger 
lcc standard implementation symbol table functions supports dbx lines support ldb lines 
source difference interface designed support dbx standard implementations simply emit information return 
front making sure functions called right times 
ldb implementations contrast accumulate information linked data structures emit postscript compilation 
lcc supported ldb rest front simplified eliminating support dbx 
lcc store information postscript enable expression evaluation server reconstruct lcc data structures described chapter 
store extra information symbol type node postscript represent links nodes form graph containing cycles 
representing cyclic structures postscript lcc symbol table functions complex 
changes outside symbol table generation modest 
front required lines changes maintain tree symbols associate symbols stopping points 
changes stab interface affected lines 
lines added back provide register save information lines include code targets 
discussion linking decisions may postponed run time 
example environments dynamic linker links programs single address space swinehart 
versions unix support shared libraries locations library procedures determined procedures called sun 
ldb support linkers basing linker state linker dependent run time information static linker table uses 
ambitious linkers take done compiler example determining locations variables link time wall 
supporting linkers require extensions existing linker state just re implementation existing implementation linker modified generate linker table toplevel dictionary 
similar technique support debugging environment linker dynamically generates synthetic file containing dbx debugging symbols represent state dynamically linked program weiser demers hauser 
ldb symbol tables change linker modified 
possibility put debugging information file object code current unix linkers dbx 
scheme virtue simplicity object code debugging information guaranteed match debugging information easily misplaced 
scheme important disadvantage debugging information voluminous reading relocating slows linker 
chapter 
postscript symbol tables ldb compiled dbx relocation debugging symbols occupy twice space object code 
reliable configuration management available chase debugging information safely stored separate files 
despite current practice debugging information put object code requiring special support linker 
linkers relocate memory necessary define second entity debugging symbols relocated 
large address spaces available today debugging information put target address space initialized data 
separate section reserved information allocated single contiguous fragment address space fragment need mapped physical memory program debugged 
ldb get information running process efficient get executable file 
executable file sufficient debugging information read 
machine independent linker access done machine dependent code fraser hanson 
standard machine dependent formats gain efficiency warrant extra retargeting effort 
potential benefit putting special support linker debugging information encoded compactly 
example linker store distance stopping points addresses stopping points reducing amount storage required factor 
ldb current implementation benefit linker generated linker tables directly eliminating post link pass find procedure anchor symbols 
linker emit machine dependent data included procedures symbol table entries 
technique eliminate mips run time procedure table see section get procedures frame sizes 
ldb assumes locations variables change execution program 
earlier version provided motion variable registers memory 
technique indirection location field variable symbol location postscript object executed produce location 
object executed time variable location desired compiler moved variables emitted procedure fetched program counter compute location 
code exercised lcc move variables indirection removed 
removal changed dozen lines code design easier explain ldb uses level indirection compute location 
indirection anchor symbol technique possible 
ldb compilers move variables code reinstated 
moving variables necessary best caller save registers variables may appear different registers memory depending value program counter chow hennessy 
changing locations computed easily 
discussion postscript procedures provided program counter included memory available postscript 
state seen debugger consistent source code lcc prevent instruction scheduling moving instructions stopping points 
restriction reduces number opportunities filling delay slots 
result code size increases delay slots filled ops 
average increase 
penalty avoided debugger effects interleaving instructions different statements 
brooks hansen simmons describe design debugger 
ldb classification symbols types variables procedures constants suffice languages 
clear accommodate modula interfaces standard ml functors example 
hand existing classification complex needed variables constants treated nearly identically distinction eliminated changing code 
symbol table format machine independent extensible compact possible read quickly incrementally 
postscript symbol tables machine independent extensible consume lots disk space take long time build 
lcc compiles sparc compiles files totalling lines compilation includes lines header files 
generates mb postscript mb dbx linker symbols 
adds kb initialized data hold locations anchor symbols 
relative cost postscript lower ldb compiled lines 
ldb symbols take mb dbx symbols take mb 
comparing raw sizes slightly unfair postscript encoded ascii compact binary encoding 
compressing postscript files gives plausible estimate space require binary encoding postscript file compressed unix compress welch lcc files occupy twice size dbx 
savings realized library includes compression 
factor reduced reorganizing representation reduce redundancy example organizing stopping points source file name name need repeated stopping point 
postscript symbol tables contain information data needed reconstruct compiler symbol type representation 
extra information possible re compiler debug time implementing interpreter debuggers 
postscript symbol tables cost generate dbx 
sparc generating postscript symbol tables lcc triples compilation time generating dbx increases compilation time 
accounts added time 
overhead higher lcc lcc uses large header file containing type definitions appear symbol table 
lcc compiles noweb line literate programming tool ramsey compilation time chapter 
postscript symbol tables increases corresponding increase 
accounts added time 
mips overhead lower compilation takes times longer lcc longer noweb accounts added time 
relatively time spent mips assembler sparc assembler accounts part lower overhead mips 
mips lcc generate dbx symbol table information times compared dbx 
lcc faster compilers fraser hanson relative costs generating postscript symbol tables lower different compiler 
savings realized lazy top level dictionaries varies size program 
savings proportionally larger large programs table shows startup times ldb full lazy top level dictionaries 
times dbx gdb shown lazy dictionaries ldb takes longer start debuggers 
targets shown top debuggers left ldb lcc noweb target ldb full dictionaries ldb lazy dictionaries dbx gdb times elapsed times seconds measured dec model 
targets measurements vary widely size ldb lines lcc lines noweb lines 
lazy dictionaries save factor largest target factor smallest 
difficult assess precisely cost postscript cost varies target program drawn anyway 
ascii encoding postscript offers poor performance files take space costs generation output input lexical analysis significant 
postscript linear interpreter reads interprets token time 
difficult read postscript incrementally 
lazy evaluation techniques described section help put greater burden compiler writer clear get better performance similar techniques 
full generality postscript useful expression evaluation printing values needed represent symbol tables 
performance improved data format represent symbol tables 
data format structure ldb top level dictionary symbol table entries encoded compactly way read incrementally way required allocation symbol table entry 
encoding managed compiler write information function time having wait compilation writing 
features current representation worth preserving 
represent arbitrary postscript objects especially procedures 
symbol table entries extensible compiler debugger insert 
discussion information convenient sizes alignments types frame sizes procedures 
representation manipulated postscript example support expression evaluation 
data format compact binary encoding top level dictionaries disk space provide fast incremental access debugger random access 
representation treated interpreter ordinary postscript dictionary possible existing postscript representation development understanding debugging important switch compact format production 
similar scheme debugger treating symbol postscript dictionary eliminate conversion postscript modula representations 
ordinary postscript continue support printing expression evaluation performance critical 
multipass program earlier passes transmit information passes 
information transmitted efficiently somewhat machine language set instructions pass pass special purpose interpretive routine earlier pass special purpose compiler 
philosophy multipass operation may characterized telling pass possible simply presenting lot facts asking 
don knuth page chapter 
postscript symbol tables chapter expression evaluation debugger evaluate expressions include variables target program assignments variables 
problem compilation debuggers structure compiler solve 
common approach write front scans parses expression turning intermediate form interpret intermediate form 
debugging symbols emitted original compiler provide symbol table information 
dbx gdb ups approach 
debuggers implements expression evaluation scratch 
drawback debugger compiler implement different languages 
dbx implements subset example omits assignment operators adams muchnick 
ups documentation lists details ansi gets wrong example ups correctly call procedures return floating point structured values 
approach expression evaluation uses original compiler translate expression machine code places code target address space executes fritzson 
approach guarantees debugger compiler implement language avoids interpretation 
requires closer integration debugger compiler target run time system previous approach run time system allocate space generated code compiler generate machine code assembly code generated code may relocated 
incremental compiler similar requirements 
ldb uses intermediate approach expression evaluation 
uses structure approach re uses existing compiler code yielding benefits second approach additional demands compiler run time system 
ldb uses server lcc front new back generates postscript 
front symbol table code modified get information debugger encounters unknown symbol 
design shown debugger provides text expression plus symbols types compiler returns postscript 
ldb postscript symbol tables simplify chapter 
expression evaluation oe expression server argv modula code result context postscript interpreter postscript type symbol info symbol table postscript back ldb parse typecheck expressions communication paths ldb expression server 
re compiler front target program compiled compiler emits postscript dictionary reconstruct data structures program debugged 
expression evaluation server implements expressions including assignment operators procedure calls expressions nontrivial control flow conditional expressions boolean operators 
illustrates ldb implementation design 
expression evaluation server executes separate address space original compiler input output memory allocation components incompatible modula run time system ldb 
ldb communicates server byte streams unix pipes 
expression evaluation takes place steps shown 
step compilation requires interaction expression evaluation server 
compile expression ldb sends server 
server attempts parse type check expression produce intermediate code 
fails find identifier argv symbol table print error message symbol table code modified send postscript argv lookup back ldb 
postscript procedure lookup interpreted ldb finds postscript dictionary representing argv symbol table entry sends information dictionary back expression server 
server modified symbol table code uses information reconstruct argv symbol table entry fly returns newly created entry parser just entry 
lower arrows show server postscript request debugger reply 
parser built intermediate code code passed postscript back sends ldb postscript procedure type dictionary 
results step subsequent steps 
second step evaluation procedure 
debugger expression server expression text expression compile expression value expression eval result text print steps evaluating expression 
interpreted producing location value expression 
type dictionary third step printing described section 
chapter describes implementation step expression evaluation including modifications possible variant lcc expression evaluation server 
debugger expression server ldb takes view expression evaluation 
object type expression compiler step turns text expression object type expression expression evaluation server implement step hidden debugger 
section describes expression compiler level level needed understand implementation 
ldb internal representation compiled expression modula object type expression depicted debugger contribution compilation step provide symbols requested name 
supplying object type scope maps name ldb internal representation symbol symbol type scope displayed object methods lookup name text symbol lookup method raises exception symbol 
debugger treats expression server black box 
type type expression compiler object methods compile source text scope scope interp interp expression expression contains postscript procedure ldb supplies postscript interpreter type interp expression compiler construct procedure 
chapter 
expression evaluation sample invocation expression compiler target compiler compile argv focus visible target interp target holds global information target including expression compiler postscript interpreter focus current focus 
focus visible returns scope look names described chapter lookup procedure walks tree local symbols searches hash tables top level symbols 
implementation expression compiler uses postscript interpreter talk expression server 
scope symbol subtypes displayed type postscript object manipulated directly postscript interpreter 
debugger interaction simple 
begins sending text expression suitably delimited server example argv 
colon server compile expression postscript requests print parts internal state 
sending expression debugger puts scope streams server postscript operand stack interprets postscript procedure serve 
serve creates names scope output stream server postscript procedures refer name 
applying stopped stream server reads interprets postscript sent server running server sends 
serve scope exch def wr exch def stopped expression server eof interp error def scope bound name scope duration interaction server 
server send evaluation expression 
pipe closed example server crashes serve raises exception 
having server send postscript evaluated simplifies debugger need ensure symbol type information accessible postscript code sent server rest job 
evaluating printing compiled expressions described section printing value requires memory containing value location value type dictionary containing appropriate printing procedure postscript interpreter 
ldb internal representation value expression value modula object containing information uses internal representation type 
making lcc act expression server type dictionary 
print step shown sets postscript stack interprets print extracts interprets printing procedure type dictionary print dup printer get exec def described section contents type dictionary accessible 
middle step evaluating compiled expression produce value implemented modula procedure expression eval 
compiled expression contains type memory contains postscript procedure location 
caller expression eval supply memory expression eval puts postscript operand stack interpreting procedure 
interpreted postscript procedure returns operand stack location result expression 
procedure may side effects state target storing memory calling procedures target 
side effects arise assignment operators procedure calls original expression 
making lcc act expression server kinds changes possible lcc expression server 
server reconstruct symbol type data information sent debugger 
specify certain machine dependent data sizes basic types run time compiled 
generate postscript suitable ldb 
addition major changes minor changes needed 
server main procedure compiling entire program loops handling requests debugger 
program permissible call function declared 
function assumed compilation unit linker detects error 
expression server permit calls functions 
access symbols entire program symbol function called 
reconstructing lcc symbol type data lcc lexical analyzer encounters identifier attempts look symbol table 
lcc acting expression server lookup operation may require sending message debugger asking identifier 
reading expression containing unresolved identifier switch different input stream read information coming back debugger 
convenient expression server receive information debugger stream tokens stream bytes state lexical analysis suspended input switched alternate stream restored input returned original stream 
chapter 
expression evaluation lcc input lexical analysis modules keep state global variables 
stacks save restore variables making possible switch alternate input stream losing state associated original stream 
possible save current input state input stack restore current input state stack swap current input state state top stack 
input state includes input buffer pointers locations buffer source file name coordinates file descriptor 
existing function initializes current input state read file descriptor 
stack save restore state lexical analyzer 
state lexical analyzer includes token read source location symbols values strings associated 
expression server need keep state reading alternate input stream swap operation needed 
stack support adds lines input module lines lexical analyzer 
lcc uses function lookup find symbol associated name 
normally lookup returns symbol associated name expression server calls asks debugger name 
debugger looks name described section sends corresponding symbol back server 
process representations symbols types 
symbols types created lcc original compilation lcc internal representation 
compilation lcc writes postscript representation symbols types symbol table 
debug time ldb reads postscript user evaluates expression sends symbols types byte stream third representation 
expression server receives byte stream representation reconstructs lcc original internal representation 
compiler writer controls internal transmitted representations 
postscript representation somewhat constrained symbols types represented dictionaries dictionaries contain certain keys shown chapter 
compiler writer add information adding keys dictionaries 
compiler writer chooses postscript transmitted representations easy reconstruct symbols types server 
changes compiler possible recover symbols types total lines type module 
transmission symbol type information ldb server straightforward 
problems solutions obvious communicating type information server back ldb handling circularity graph symbols types 
rest section describes solutions detail 

making lcc act expression server sent ldb expression server symbol represented stream tokens described grammar nonterminals capitalized shown italics terminals capitalized literals shown typewriter font symbol 
kind type value kind constant variable procedure type value integer constant ffl grammar type describes types appears 
question mark indicates symbol associated name 
server reconstructs symbol kind 
constant creates symbol representing enumeration literal assigns integer value 
enumeration identifiers categorized constants 
variables values declared constant assigned appropriate type const int type const int 
treats variables procedures declared storage class extern local scope 
extern storage class enables expression server back distinguish target program variables compiler generated temporaries appear back variables storage class auto 
treats types declared locally typedef 
representation defined grammar omits fields lcc representation symbols fraser hanson 
recreate symbols calls front functions lcc calls parsing declarations 
functions initialize fields omitted representation defined grammar 
installing symbol functions call lookup sure symbol scope name 
called name undefined lookup find symbol name calls ask debugger name 
implemented naively send message debugger receive reply try install new symbol resulting infinite recursion 
avoids infinite recursion global variable keep track activations 
active recursive calls return asking debugger information 
support symbol recovery takes lines communication ldb lines empty symbol tables expressions 
lcc internal representation types representation postscript representation stream similar 
type operator corresponds basic type int char constructor array pointer 
type operand type operand types meaningful constructors arrays element types pointers referent types functions return types 
cases operand types zero 
lcc records size alignment type associates additional data chapter 
expression evaluation function prototypes fields structures unions 
parts types represented directly postscript 
symbols transmitted debugger expression server types flow directions 
debugger tell server types identifiers server tell debugger types expressions 
server debugger maintain parallel type caches associate small integers types 
debugger determines types added caches initialized predefined types 
debugger identifies type cache called known type presence index key dictionary 
debugger server assign indices order 
type cache easy server generate postscript code refers type code uses type index fetch type dictionary debugger type cache postscript array 
type cache incidentally improves expression evaluation performance type transmitted 
performance benefits noticeable modula programs modula compiler generates deeply nested structure types 
example requires types describe structure ldb uses represent target program 
ldb debug takes seconds transmit types expression server 
transmitted types expressions perceptible delay 
debugger needs send known type server sends type index 
send unknown type sends operand type fields operator size alignment 
sending unknown type assigns unused index type known 
algorithm terminates operand types form cycles cycles caused recursive types created field structure union 
debugger breaks recursion sending information structures unions information fields expression server send explicit request fields creating type 
scheme analogous filling fields incomplete structure declaration expression server existing code handles incomplete structure declarations manipulates type representation directly 
ldb sends type server stream tokens described grammar 
type index type index op size align index op size align integer constants 
index represents zero pointer 
legal declare structure type listing fields struct node 
necessary fields defined giving full declaration type 

making lcc act expression server contain function prototype part function type contain tag structure union enumeration type 
representation index known type tag structure union enum typedef function prototype typedef typelist function prototype typelist type typelist ffl tag string constant terminal symbols integer constants 
part lcc internal representation structure union types indicate structure union contains fields declared constant volatile 
ldb evaluates expression argv argv symbol type transmitted server form 
variable argv variable rest string type char 
initial index type cache refers predefined type char 
sequence numbers brackets introduces new type number operator pointer size alignment bytes null type number char 
type number number operand number number making number type char type argv 
separate procedure handle fields structure union types 
passes type symbol 
type operand type incomplete structure union type sends request debugger names types fields 
representation sent back fields name type offset fields ffl name string constant terminal symbols integer constants 
offset offset field structure union identify position bit field word offset 
fields structure may structures pointers structures calls type field 
needed handle recursive type typedef struct list void struct list link list chapter 
expression evaluation user evaluates expression containing list ldb transmits representation list type list type identifies list name defined typedef 
indicates operand type null pointer 
new type number 
operator struct bytes long aligned byte boundary 
structure tag list structure contains constant volatile fields 
type number pointer type case struct list 
identifies type incomplete structure type sends debugger 
postscript procedure sends reply link type predefined type void offset link type struct list offset 
values fields indicating bit fields 
structure type transmitted types fields type struct list cache time comes identify type link field struct list 
maintain consistency type caches server add type cache debugger 
server may create types go cache example compiling expression integer server may need create pointer type int 
lcc type creation function modified distinguish types sent debugger types created front 
expression server need code recognizes grammars debugger needs postscript code emits sentences described grammars 
postscript procedure lookup called directly expression server uses send symbol type 
uses send fields structures unions 
differences lcc standard type module version communicates ldb lines 
lines diagnostic functions printing state type cache 
delaying assignment machine dependent data lcc normally requires machine dependent information specified compile compile time fraser hanson section 
examples include sizes alignments metrics predefined types byte order target machine 
desirable possible avoid having different version expression server target expression server gets information run time 
startup predefined types type cache server calls postscript procedure send size alignment 
making lcc act expression server type cache 
calls postscript procedure tells structures passed functions making copies passing pointers copies 
calls sending postscript ldb information returned applies target machine machine ldb expression server run 
lcc handles bit fields entirely front transforming bit field accesses full word accesses composed shifting masking operations 
machine independent handling bit fields required change lcc front 
bit fields assigned positions starting significant significant word depending byte order target machine 
original version lcc assigned fields positions machine independent way positions machine dependent meanings 
bit meant significant bit little endian targets significant bit big endian targets 
front machine dependent macros compute shifts masks needed get access bit fields 
example declaration struct flags unsigned defined parsed defined noted position machine dependent code determined shift shift needed fetch field 
new version lcc bit means significant bit 
front machine dependent computation assigns fields positions defined assigned position position depending byte order target 
transformation bit field accesses machine independent accessing field position requires right shift followed masking 
change lcc changes time machine dependent computation required time expressions converted intermediate code time declarations processed 
declarations parsed original compilation machine dependent compiler 
intermediate code generated debug time expression server machine independent result change 
alternative provide expression server target byte order 
handling bit fields postscript back option bit field accesses eliminated front 
postscript back expression server back uses lcc code generation interface fraser hanson interacts front nonstandard ways code generates follow exactly pattern usual assembly code 
front dummy function arguments result time compiles expression expression body dummy function calls back generate code 
chapter 
expression evaluation back emits postscript procedure effect evaluating expression placing location result postscript stack 
compile time switch configures expression server generate trees dags 
change simplifies back code emitted postorder traversal trees call postscript procedure emitted node 
postscript procedures procedure finds arguments corresponding values computed node children postscript operand stack places result 
lcc back uses integer floating point types pointer type 
integer floating point types subset types values memory expression server uses postscript integers reals represent 
pointers represented locations memory 
lcc front creates temporary variables 
temporaries may hold string floating point literals intermediate results structures returned functions 
expression server may need pass address temporary procedure target evaluate strcmp locations target data space reserved hold front temporaries 
debug nub reserves global area purpose supplies pointer variable 
compiler generated variables go global area simplest put compiler generated variables 
simplicity cost performance shown section 
expression server determines size global area looking walking type structure find size referent 
result size global area changed simply recompiling nub change expression server needed 
global area divided sections compiler generated static variables compiler generated automatic variables procedure arguments 
sections correspond local variable argument build sections stack frames standard back ends 
section holds string constants floating point constants allocated globally lcc normal back ends postscript back allocated expression basis 
different expressions may different compiler generated statics undesirable fill global area statics long running debugging session definitions states emitted compile time standard lcc 
part procedure stores statics global area 
back forces front emit constants right time 
ldb uses lines postscript implement procedures back emits calls 
procedures correspond nodes lcc dag language language operators postscript analogs 
operators emit constants address variables postscript analogs back emits appropriate numeric literals code directly 
dag nodes hold values returned return statements 
making lcc act expression server postscript analogs need implemented return appear expression 
postscript implementations standard postscript operators plus ldb extensions memories 
require special extensions postscript interpreter 
example standard postscript supply relational arithmetic operators operate unsigned integers bit floating point values 
single new postscript operator needed implement differently typed variants procedure call operator sends message debug nub asking call see section hides events breakpoints occur call return described section 
lcc front un nests procedure calls postscript arguments relatively simple copies arguments sequentially argument build section nub global area 
postscript procedure generated server uses expression closure postscript dictionary holds locations free variables expression 
example postscript code computes location argv exp closure argv get line gets location argv expression closure second fetches pointer location 
expression closure computed code 
argv dup extern 
extern executed computes location argv dictionary associates key argv location target variable argv 
extern looks variable symbol table entry scope provided server gets location key extern scope exch scope lookup get def emitted compiler may associated location anchor symbol procedure scope lookup guarantees associated location 
lcc front un nests calls may announce calls back results calls 
example expression atan sin cos result sin immediately argument atan argument build area needed call cos 
calls announced results postscript code generated back puts result temporary postscript variable leaving postscript operand stack 
variable result needed 
result stored simple variable front allocates temporary space hold non scalar results 
shows code generated example inserted comments describing calls 
temporary variables names exp result 
indicates double argument size alignment bytes 
immediate applied final chapter 
expression evaluation exp closure sin get exp result exch def sin exp closure cos get exp result exch def cos exp result exp result exp closure atan get exp result fc exch def atan exp result fc immediate code evaluate atan sin cos 
result produce location printing procedures locations values values 
examples shown far omit technique handle nontrivial control flow 
expression server uses indirection postscript evaluate expression stored expression closure 
indirection best introduced expression simple control flow argv 
procedure evaluates expression associated key eval expression closure 
procedure sent back debugger exp closure def dup exp exch def exp eval machine procedure left stack associated key exp procedure exp eval looks expression closure postscript code evaluates expression 
expression closure computed dynamically stored code emitted argv exp closure null def dup exp exch def exp eval procedure dup 
argv dup extern eval exp gp extern def exp ap exp gp shifted def exp closure argv get evaluation code 
put save closure procedure 
making lcc act expression server procedure appears null place expression closure 
uses exp eval evaluate procedure closure 
remaining code builds closure stores procedure closure procedure associated eval evaluates expression 
lines exp gp exp gp define location global area argument build section global area respectively 
simple expression 
rest procedure code shown earlier put location argv operand stack 
expression requires nontrivial control flow expression closure contains single procedure extended basic block 
exp eval executes basic block expression evaluated 
procedure corresponds extended basic block associated key eval 
blocks labeled expression closure associates names labels procedures implementing blocks 
example expression argv argv requires conditional branch avoid evaluating argv argv zero 
corresponding postscript code shown extended basic blocks 
answer goes compiler generated temporary exp gp 
argv argv zero test fails branching assigns temporary tests succeed code assigns temporary 
fetch converts pointer integer equ compares integers assigns transfers control 
postscript stopped operators form catch throw transfer control basic blocks jump label puts procedure associated postscript operand stack executes 
caught new procedure executed 
implementation argument name label exp closure exch get def exp eval catches executes procedure stack 
procedure exp eval exits 
exp eval begins executing extended basic block associated name eval 
exp eval exp closure eval get stopped exit loop def technique general handle control flow function just control flow expressions 
expression server back lines supporting postscript lines 
lines modula needed implement special operators implement postscript counting procedure call complex 
chapter 
expression evaluation exp closure null def dup exp exch def exp eval dup 
argv dup extern eval exp gp extern def exp ap exp gp shifted def exp closure argv get equ int argv goto exp closure argv get equ int argv goto exp gp tmp exp gp tmp fall exp gp location result tmp 
put save closure proc code evaluate argv argv 

discussion discussion re compiler limitation debugger provide extended language debugging 
extended language useful defining debugging functions check print values linked data structures 
language polymorphic functions data structures different types 
extended language include operations control debugger removing breakpoints stopping dialog user crawford 
extended language implemented ldb expression server 
ldb expression server implements minor extension line change lexical analyzer treats letter invalid character 
ldb machine dependent postscript code defines names registers see section 
names dollar sign clash names target program expressions 
techniques implement expressions postscript implement statements 
control flow presents problems thought required handle declarations compound statement 
existing code handles automatic variables static variables require changes postscript currently generated discards variables evaluation expression 
ldb re variety compiler implementations puts expression server separate address space 
compiler debugger need written language need support data types need agree manage storage share input output 
cost flexibility compiler writer devise postscript procedures take symbol table data send expression server byte stream procedures server receive data 
lcc front easily shared address space ldb ldb procedure calls expression server code sending messages processes 
compiler debugger built difficult compatible share address space debugging added afterthought expression server approach useful 
expression server re code original compiler reconstruct symbol type structures originally compiler re establish internal compiler invariants involving structures 
invariants undocumented re original compiler writer plans 
planning took place design lcc retrofitted expression server 
demonstrates effort required compiler expression server small 
multiple expression servers ldb support multiple programming languages associating server procedure 
supports ansi language implemented expression server name resolution implemented debugger lookup method type scope current name resolution algorithm assumes chapter 
expression evaluation name denotation limits ldb languages support operator overloading 
existing algorithm handle languages nested procedures pascal modula 
name resolution algorithm resolved names sets symbols require additional support postscript symbol tables suitable languages support overloading ada 
chapter debug nub early debuggers ran address space targets digital 
debuggers direct access target memory registers ordinary machine instructions 
similarly control transferred debugger target simple branch instructions 
simplicity offers performance schaffer kessler presents problems 
debugger target compete resources debugger small order fit space large applications 
may difficult protect debugger faulty program bits randomly memory 
debugger may able debug preventing old reliable version debugger debug new unreliable version 
problems solved letting debugger target run separate processes strategy introduces new set problems 
operating system provide support manipulating target processes 
debugger able select target process start manipulate address space cpu state 
operating systems provide additional support support breakpoints 
process model commonly engineering workstations 
debuggers personal computers process model personal computers provide single process world swap techniques possible process model process system redell 
standard unix systems run time support enables debugger manipulate child process 
debugger starts stops child reads writes memory registers calling ptrace 
ptrace provides support intercepting signals delivered target process 
vendors necessary improve ptrace adams muchnick 
extension possible debugger refer registers knowing locations kernel data structures somewhat memory 
possible debug processes running machine debugger just child processes debugger 
chapter 
debug nub topaz protocol ttd shows approach run time debugging support redell 
topaz kernel includes servers debugging user processes kernel 
debugger selects target process kernel manipulates sending special packets network 
network driver recognizes packets routes appropriate debug server 
ttd treats debugging remote debugging need optimize case debugger target run machine 
topaz kernel provides threads addition standard services ttd provides primitives manipulating threads 
significant advantages ttd reliability availability possible debug lowest level software broken debugger debug machine send network packets 
useful application remote debugging debugger running old reliable version operating system debug machine running new unreliable version 
third approach uses special files support debugging 
files running process usually appear directory called proc debugger opens file uses normal file system operations control process killian 
typically file read written manipulate target address space operations performed ioctl system call 
plan operating system provides similar support uses collection files control ioctl operations single file pike 
plan mount files remotely form remote debugging facility 
ldb existing run time support debugging accidental differences support machines vendors introduce unnecessary retargeting effort 
adding machine independent support existing kernels burdensome 
compromise ldb uses debug nub runs user mode target address space 
debugger nub kernel services establish bidirectional byte stream connection 
model debugging ttd nub analog ttd server 
compromise possible explore retargeting effort affected set services implemented nub 
byte streams simpler abstraction debugging support better chance implementations different operating systems similar 
example ldb works different versions unix different vendors provide byte stream abstraction sockets 
principle guiding design nub keep small compromising reliability retargetability 
nub loaded program cost programs debugged small 
simple nub easier retarget reliable 
adding services nub justified implementing services debugger system significantly reliable difficult retarget 
significant performance improvements justify adding services nub provided improvements affected users 

debugger view nub debugger view nub debugger point view target states running stopped disconnected 
disconnected target may fact running stopped debugger attempt keep track 
target running nub provides services debugger target stops nub sends debugger message describing event caused 
target stopped nub provides sets services act trapped memory section call procedure restart disconnect target 
target disconnected run exit wait connection new instance debugger 
debugger sees nub modula object type wire wire subtype trapped memory memory methods plant suspend remove traps 
wire methods support nub features notified event nub call call procedure resume execution break connection 
wire subtype memory postscript object 
type wire object methods wire event call entry integer memory type integer order wire order close wire order continue disconnect exit unwind wire event record sig code integer val memory value close method recover resources open file descriptors associated particular implementation wire protocol governs order debugger may call methods wire target disconnected debugger may call close 
get target disconnected debugger connect new running target create new wire target running debugger may call 
target stops returns event disconnected raises exception 
termination target process treated disconnection 
event contains unix signal number code address process context area target data space containing state processor event occurred 
format process context machine dependent includes program counter registers 
unix signal nub uses encode special events return procedure unwinding suspended call 
val field event meaningful procedure return events case contains chapter 
debug nub value returned procedure 
value may meaningful example void procedure 
target stopped debugger may call trapped memory methods fetch store values plant suspend list traps 
methods leaves target stopped 
debugger may call 
orders continue unwind leave target running 
unwind synchronous operation target restarted unwind order immediately stops unwound event convenient treat asynchronous unnecessary nub distinguish procedure call unwound simply returns 
orders disconnect exit tell nub disconnect debugger 
disconnection nub continues execution target terminates process waits connection debugger 
stopped debugger may invoke call 
call restarts target runs event occurs 
usually event procedure returns value ldb handles events described section 
implementing nub protocol shown debugger nub layers abstraction build bidirectional byte stream protocol described 
byte stream established ways 
common nub create socket accept connections advertise socket printing host name port number ldb connection connect system call 
sophisticated mechanism advertise registering connection network wide service 
ldb fork target program child process nub fork debugger child process cases byte stream pair unix pipes 
marshalling code writes integers floating point values memory values byte stream 
format integers machine independent integers transmitted byte time significant byte nub debugger run big endian machines 
transmitting floating point values problematic primarily different floating point formats support different non numeric values 
floating point values converted bits transmission cast pair bit words 
words transmitted integers significant word 
scheme works correctly ldb target running architecture 
support cross debugging provided host target floating point format 
need byte order 
mips sparc ieee floating point format cross debugging works correctly architectures 
user running architectures attempts cross debug vax target floating point values wrong 
possible solutions problem discussed chapter 
marshalling layer nub debugger exchange typed messages 
level operation request reply protocol 
debugger may send fetch store plant 
implementing nub protocol oe oe oe oe bytes integers memory values codes typed messages methods wire oe debug nub protocol socket marshal socket put get marshalling message sending decoding deliver trapped memory procedure call debugger nub layers implementing debug nub protocol 
suspend traps order call 
nub may send event value stored address fail called 
messages include appropriate data example fetch message includes location type 
standard implementation wire combines layers protocol layer assembles messages layer uses messages implement wire methods 
nub uses functions deliver ensure sends receives messages accordance nub protocol 
handles changes state caused events orders deliver handlers requests debugger leave target stopped 
response requests deliver calls nub implementations trapped memory procedure call methods 
debugger side interface ensures methods wire called orders permitted protocol 
implements methods wire exported rest debugger 
methods track state target method raises exception called forbidden state calls corresponding method underlying wire method different called target stopped raise exception blocks target state changes 
blocking possible debugger separate listener thread calls repeatedly see section 
contains lock protect target state 
lock prevents race conditions nub caused different threads trying fetch time example 
chapter 
debug nub message level nub protocol described promela specification holzmann 
promela tools validate protocol making sure side sends message expecting 
illustrating nub protocol debugger interaction nub illustrates nub protocol 
program startup nub installs unix signal handler gets control target process faults encounters breakpoint 
single signal handler suffices events catches different signals 
nub startup code sees pause calls causes trap signal delivered nub 
trap signal delivered handler handler calls nub connect function prints message waits socket connection established 
orchard fib pause 
debug nub debug ldb target fib connect orchard debugger connect command establishes network connection uses create running forks listener thread starts calling method wire 
fork debugger running threads user interface thread responds user input listener thread responds target events 
principle ldb handle multiple targets simultaneously forking listener thread target current user interface manipulate target time 
nub connect function returns signal handler soon network connection established subsequent calls connect long connection remains open 
signal handler calls calls deliver sends event message debugger 
message contains signal trap code address process context 
message shown top shows exchange messages described section 
target running debugger listener thread block 
reads message nub method returns event marking target stopped 
listener thread delivers event user interface prints ldb fib disconnected connect orchard 

nw void int arg ldb fib stopped delivering event listener thread calls 
time call blocks target stopped 
listener thread stays blocked user interface thread starts target running 

illustrating nub protocol debugger nub oe oe oe plant 
stored 
order continue event 
fetch 
value 
messages exchanged processing event 
user interface thread prints current focus 
printing involves fetches memory fetch ends implementation sends message nub waits response 
nub deliver function having delivered event waiting request 
decodes request calls appropriate function nub case 
sends reply includes value fetched debugger deliver loops waiting request 
debugger command different kind request plant breakpoint 
ldb fib stopped fib fib break fib fib break fib fib fib 
ldb fib stopped request decoded deliver calls 
nub continues execute deliver long target stays stopped 
eventually user continues execution target 
command results user interface thread calling wire method continue order sends message nub telling continue execution 
protected wire recognizes order tells nub transition stopped running unblocks listener thread await event 
message received nub deliver function decodes returns request 
changes state target deliver target stopped 
identifies order continue returns signal handler returns restoring registers returning execution user program 
control return nub event activates nub signal handler starting similar sequence interactions 
chapter 
debug nub number lines protocol layers trapped memory establishing connection signal handling contexts procedure call percentage total size parts debug nub 
implementing nub quarter code nub devoted marshalling message top layers protocol 
trapped memory methods take procedure call shown 
signal handling establishing connection debugger account remainder going initialization inclusion header files declarations prototypes system functions 
implement trapped memory nub keep record trap 
record includes original instruction trap written memory type write trap 
records stored hash table separate chaining keyed address 
records allocated statically possible call dynamic allocator process debugged 
implementations trapped memory methods maintain table send messages debugger manipulate target memory 
example breakpoint set debugger sends nub message asking plant trap 
debugger supplies address type bits 
nub looks address trap table creates new record hold original contents address 
fetches contents saves record stores trap address sends message back debugger indicating trap planted 
nub runs records finds pre existing record address sends message indicating failed plant trap 
fetch code space example print assembly code check address fetch trap table 
address table fetch returns original bits stored trap record trap instruction memory 
way traps hidden memory 
stores code space check trap table modifying bits trap record 
trap fetching storing methods functions fetch store manipulate memory 
storing code space store invokes machine dependent 
implementing nub macro defined invalidate appropriate line instruction cache 
targets undefined mips define char icache address invalidated number bytes stored 
user cause debugger try fetch store invalid address example evaluating expression dereferences invalid pointer 
appropriate deliver memory fault event debugger refers invalid address nub simply replies debugger request message indicating fetch store failed 
installs special signal handler catches invalid memory buffer set implementations fetch store trap methods setjmp detect failure notify debugger 
setjmp longjmp unix implementations catch throw 
special handler installed control enters nub 
original handler restored control returns user code 
connect function establishes connection debugger chooses creates file descriptors send messages receive messages debugger 
target process child debugger indicated special argument program starts nub chooses descriptors arranged debugger 
calls needs establish connection 
creates socket prints number waits debugger connect 
forks debugger child process creating pipes communicate 
connection lost example debugger crashes nub treats resulting read write error message debugger telling nub disconnect wait instance debugger 
procedure call nub capable just calling procedure handling faults events execution procedure 
fault occurs execution procedure debugger may ask continue execution procedure unwind stack past suspended call resume debugging context procedure called shown example session page 
nub uses setjmp call longjmp unwind suspended call 
shows code nub uses implement procedure call 
left call context includes signal code process context old signal handlers global area expression server section unwind holds context unwind previous call 
call context saved local variable local variable new global area allocation done stack 
transferring control requested procedure nub restores signal handlers original state invalid memory handled normally call example 
event chapter 
debug nub void call 
register unsigned local variable call context signal handlers setjmp unwind buf unwound returned val signal call context assert dummy nub implementation procedure call 
marks call delivered debugger unwound returned returned event includes value returned procedure 
points process context re call unwound returns 
information supplied nub call function passed call method wire debugger supplies procedure address block containing arguments information result word machine dependent data 
machine dependent data mips targets describes types arguments 
mips passes arguments different registers depending types 
postscript generated expression server puts procedure arguments argument build area 
nub call function copies area argument build area may put arguments registers 
postscript procedure call operator produces simple scalar result 
integer floating point results returned different ways targets nub knows sequence debugger provides memory type describes result 
procedure returns structure expression server allocates temporary space hold 
procedure returns structure result result debugger provides meaningless memory type ignores scalar returned nub 
parameters call entry address procedure pointer arguments number bytes arguments type type value returned procedure nonzero address temporary space allocated hold structure result word machine dependent data 

implementing nub implementation call puts arguments right places branches procedure saves value returned 
implementation procedure call machinedependent nub call function uses machine independent template shown right side invokes machine dependent macros 
fifth macro call shown 
sure call argument build area big hold arguments 
point argument build area loop copies arguments argument build area 
puts pointer result right place 
necessary satisfies machine dependent constraints putting arguments registers 
macro invocations surrounded braces definitions may contain assembly code braces ensure lcc treats statements 
part machine dependent putting arguments registers finding value returned done machine dependent code compiler generates nub compiled 
source machine dependent call mention explicitly arguments passed registers val integer type val int entry val double entry val nub representation debugger memory value section 
statement assigns val integer result type integer type 
machinedependent macro lists arguments passed registers 
definitions machine dependent macros best explained considering involved setting making call 
step ensure space argument build area hold arguments call 
necessary sufficient area large temporary area expression server expression server places arguments temporary area 
default ensures call frame contains sufficiently large argument build area passing large structure dummy procedure 
call executed right side compiler reserve space anyway deduce compile time call executed 
sparc passing structure reserves word structures passed indirection 
definition default define dummy char sizeof dummy chapter 
debug nub macro allocates space stack argument build area effectively enlarging argument build area 
second step point argument build area 
mips argument build area located bottom frame pointed stack pointer 
define asm move sp asm refers register containing variable 
nonzero function called returns structure address space allocated hold result 
mips pointer argument function define res res prepare call mips requires arguments passed floating point registers floating types kane page 
encodes types arguments 
prepare call takes lines asm 
decode put arguments right registers 
register args list arguments passed registers 
mips normally puts words arguments integer registers define mips puts arguments floating point registers corresponding integer registers unused safe put arguments 
procedure call macros complex handle different calling sequences macros defined targets defaults apply target 
example uses stack pointer point argument build area handles functions returning structures passing pointer address register passes arguments registers define asm movl sp define res asm movl res define notation res ansi preprocessor emit string literal containing name variable passed preprocessor concatenates literals form argument asm 
vax uses register structure results 
sparc argument build area middle stack frame pointer structure results immediately precedes arguments arguments passed registers 
shown macros 
implementing nub define asm add sp define res res define process context signal delivered nub handler handler capture processor state program counter register contents store process context 
mips sparc struct operating system passes signal handler register information ldb reconstruct stack frame process context 
vax struct insufficient operating system saves registers stack include struct 
vax handlers machine dependent assembly code store registers context 
context built nub passes unix signal number code context manages rest interaction debugger described 
defined process context holds program counter data address floating point registers 
long words needed hold floating point register floating point registers saved extended format typedef struct context int data int address int pc int context extern context signal handled context saved global variable 
defines macro indicates machine independent part nub nub handler execute special assembly language procedure saves restores registers 
handler invokes save program counter included replaces program counter address returns 
effect branch saves remaining registers 
technique nub independent undocumented format kernel uses save registers user stack cormack 
definition define pc pc pc implementation uses instruction save data address registers save floating point registers 
calls recovers signal code context calls described section 
chapter 
debug nub implementation fp fp fp fp movl sp rts return debugger instructed nub continue execution point registers restored context program branches saved program counter pushing stack executing rts effect branch 
rts require register hold destination address 
vax uses technique minor differences different instruction set saves registers stack copies context indirect addressing mode enables jump saved program counter single instruction 
discussion existing operating system support debugging ldb nub interface resembles topaz protocol ttd derived redell 
virtues ttd sacrificed avoid kernel changes improve retargetability 
ttd server kernel provide access process target machine nub provides access process running 
nub uses unix kernel services establish connection nub runs user space 
topaz kernel implements threads ttd server client thread implementation thread provides state analogous ldb process context 
ldb support threads 
ttd ldb different data models ttd reads writes arrays bytes values 
debugger efficiently cache copies target memory ttd model easier debugger independent target byte order ldb model 
ttd server plants suspends enumerates breakpoints traps 
difference server debugger handles details resuming execution breakpoint ttd server ldb nub hide presence breakpoints traps fetch store operations 
ttd provides instruction single step operation 
original implementation vax trace mode implementation mips simulated single stepping software described section 
ldb nub protocol provides advantages ttd 
ttd debugging remote debugging responsibility debugging particular target passed user different workstation changing target 
ttd ldb 
discussion provides availability nub linked target program catch unexpected faults wait connection ldb 
target program need child debugger run machine 
ldb attempts provide reliability ttd 
failure ldb machine network running prevents debugging fresh debugger started connected target 
exceptions occur ldb fails way sends garbage nub failure may put nub state recover 
ttd susceptible problems ttd works packets byte streams discard ill formed packets 
nub discard ill formed messages ldb detect message boundaries 
problem inherent ldb design lowest level protocol implementation changed packets nub check validity ttd 
packets implemented retargetable way simulated reserving character separate messages byte stream 
ttd ldb vulnerable failure target process nub runs user space sufficiently faulty program destroy nub data structures making impossible debug target 
problem eliminated having nub virtual memory primitives protect code data memory protection require machine dependent code 
nub fail user process runs stack space ttd server fail case runs kernel 
ttd supports debugging levels system software including lowest level kernel code 
providing servers high level server debug user programs low level server debug kernel 
ldb nub analogous high level server suitable debugging kernel 
debug kernel nub fewer kernel services example better accept packets directly network device driver high level abstraction reliable byte streams redell 
nub protocol precludes kernel debugging 
ldb nub complex ttd supports procedure call 
topaz procedure call implemented entirely debugger simulates manipulating registers memory compiler actions setting frame call 
nub provides services minimum described chapter trapped memory procedure call implemented purely debugger fetch store 
implementing trapped memory nub improves reliability debugger disconnected machine network failure internal user error information nub instance debugger continue execution target 
implementing procedure call nub improves retargetability 
code compiled nub compiler set stack frame called procedure recover return value help argument passing 
nub setjmp longjmp unwind suspended procedure calls 
procedure call implemented debugger effort required retarget procedure calls debugger re implement machine dependent chapter 
debug nub functions target 
procedure call implemented nub compiler provides assistance retargeting easy shown lines machine dependent code needed targets 
target program installs signal handlers nub catch signals 
problem solved including nub re implementation library procedure installs signal handlers making sure nub handler gets control 
moving nub kernel result simplifications better reliability 
extra programming required recover process context kernel able recover process contexts 
handling invalid memory simpler kernel access memory map 
nub handler need user stack space 
conflicts users signal handlers eliminated 
implementing call entirely kernel mean losing compiler assistance call go kernel space user space 
better solution keep call user space having kernel call call calling user procedure directly 
kernel supports signal handlers invoke procedure known type invoking nub call complex 
system calls poor way debugger interact nub kernel interface preclude remote debugging 
ttd demonstrated datagram oriented network interface suitable 
interface representing processes files suitable provided files mounted remotely computers plan pike 
cost interacting nub measured having ldb interpret postscript procedure fetches location times fetch requires request reply 
cost depends connection takes msec pipes msec network connection machine ldb runs msec different machine 
experimental error measurements msec 
difficult comparable measurements gdb dbx section contains comparative measurements cost breakpoints 
floating point data complicates cross debugging 
obvious problem different representations numbers ldb machine target machine 
solved machine independent representation transmit floating point numbers example integers representing sign base exponent significand floating point number 
ascii representation numbers converted binary ascii representations loss information clinger steele white 
floating point values numbers serious problem example clear relationship vax reserved operand ieee nan number 
sun xdr protocol transmit floating point values representable ieee format sun suitable debug nub 
machines different representations may differ semantics floating point operations 
possible solution problems extend nub protocol floating point operations target 

discussion global floating point state ieee rounding mode presents problems single processor debugging state change dynamically 
user compiler ensure procedure changes floating point state saves restores caller floating point state 
location saved state specified calling sequence debugger find 
user doing floating point computations debugger evaluating expression guarantee effect target target program executed result rounded differently target 
problem affects debuggers just ldb solving requires eliminating floating point state compiler save restore state just compiler saves restores registers 
chapter 
debug nub chapter breakpoints events breakpoints target program user probe state 
simple breakpoints planted single location target control reaches location 
shown chapter take command adds condition simple breakpoint making target condition true 
counter may attached breakpoint counter value target stops st time control reaches location 
simple breakpoint automatically restart target user start target explicitly command 
ldb offers complex breakpoint commands plant breakpoints restart target remove breakpoints target hits 
finish shown chapter uses technique execute target current activation finishes 
executes target reaches stopping point current activation executes target reaches machine instruction 
implementations breakpoint commands able react events occur order necessarily order expected 
example user types finish event expected target hit breakpoint marks activation target may fault hit breakpoint current activation 
implementation finish prepared unexpected events delaying action activation finishes 
implementations breakpoint commands steps 
step debugger plants breakpoints installs handler waits target hit breakpoints 
second step execute handler target hits breakpoints handler may take action 
ldb uses mechanisms implement scheme 
low level breakpoint instruction causes target deliver low level event ldb 
event handler matches low level event breakpoint action implements breakpoint command 
possible action notify user interesting happened done delivering user level event event continuation associated user interface 
chapter 
breakpoints events mechanism simple job 
low level breakpoint event handler cooperate set breakpoint single instruction 
breakpoint actions implement different breakpoint commands different actions relying low level breakpoints 
decide control kept debugger returned target 
event continuations combine results breakpoint actions 
user level events describe events high level delivered user interface printed 
active mechanisms divide event system levels 
event handlers identify events indicating target hit breakpoint invoke breakpoint actions 
actions decisions take actions 
example evaluate conditions decide target deliver user level events event continuations 
event continuations combine events delivered decisions breakpoint actions target action decided 
low level events delivered lower levels event handlers breakpoint actions user level events delivered highest level event continuations 
example brief discussion events chapter explains breakpoint command implemented user level breakpoint combines set low level breakpoints breakpoint action user level event 
describes traps abstraction underlying lowlevel breakpoints describing low level breakpoints 
implementations low level breakpoints may require machine dependent code traps implemented machine dependent data higher levels machine independent 
debugger asks debug nub call procedure deal kinds events breakpoint commands 
expected event procedure executes successfully returns value events possible example procedure may fail hit breakpoint 
procedure calls discussed chapter ldb manages event handling mechanisms uses implement breakpoint commands 
example abbreviated debugging session example program chapter provides concrete framework discuss implementation breakpoints 
example program source code shown 
plant breakpoints chapter ldb target fib connect orchard 
void int arg ldb fib stopped fib fib break fib fib break fib fib fib 
ldb fib stopped 
delta delta delta brackets user level event 

events continuing execution hits breakpoint ldb fib stopped 
break fib fib fib 
fib void fib short ldb fib stopped ldb take 
skipping command skip iterations loop ldb fib stopped int ldb fib stopped take skipping break fib fib skip ldb fib stopped 
break fib fib fib 
fib void fib short ldb fib stopped int ldb fib stopped target hits breakpoint iterations debugger restarts counter associated breakpoint greater zero user level event delivered user interface 
command single steps iteration ldb fib stopped 
fib fff fib 
fib void fib short ldb fib stopped 
fib fff fib 
fib void fib short ldb fib stopped 
fib fff break fib fib fib 
fib void fib short ldb fib stopped event announces program arrived stopping point fff identifies frame 
ldb single steps fib user level events delivered user interface associated original breakpoint fib 
events low level events machine dependent describe events machine level hitting trap 
user level events machine independent describe events user level stepping stopping point 
chapter 
breakpoints events void fib short static int int int printf printf main int argc char argv argc fib atoi argv fib return source file fib superscripts show stopping points 
low level events delivered debug nub 
described chapter events carry unix signal number code context recover state program time event occurred 
low level event delivered event handler registers interest 
handlers register interest events restrict interests basis events signal number code 
example event handlers associated breakpoints register interest signal code indicate breakpoint trap 
event delivered handler ignore take action may include delivering user level event event continuation 
example breakpoint handler breakpoint fib ignores trap events indicating traps locations fib fib trap fib deliver break fib event user interface 
user level events machine independent correspond breakpoint commands errors target program 
examples section include hitting breakpoint stepping stopping point page shows event associated finish 
default event continuation remembers user level events delivered single interaction target notifies user interface events 
shown section single low level event hitting breakpoint may result delivery events user interface 
event warrants keeping control debugger default continuation returns control target 
low level event type event low delivered handler calling handler matches method 
event low contains wire event section plus program counter handle 
user level breakpoints reach target call stack 
matches method returns boolean indicating handler recognizes event type event handler object methods matches event low cont event continuation boolean recognition automatic 
example handler breakpoint fib recognizes trap events fib 
handler recognize event fib 
user level event delivered continuation calling continuation throw method type event continuation object methods throw event boolean represents event tells continuation occurrence event warrants keeping control debugger 
breakpoints example keep control debugger trace points 
events event continuations supplied code outside event mechanism 
ldb uses event continuation accumulates events delivers user interface 
user level breakpoints precise set breakpoint commands ldb provides details implementations important fact implemented single technique 
breakpoint command implemented user level breakpoint plants set low level breakpoints 
low level breakpoint planted exactly object code location specified value program counter 
associated breakpoint action specified planted breakpoint action executed target hits breakpoint 
object type represent user level breakpoints subtype type user level events 
user level breakpoint type user level event breakpoint action deliver breakpoint user interface 
section explains user level breakpoints implemented combining actions low level breakpoints section explains implementation low level breakpoints 
ldb offers simple user level breakpoints set object code location set source location 
breakpoint set object code location associated exactly low level breakpoint breakpoint set source location may associated arbitrary number low level breakpoints preprocessor may cause code source location compiled object code locations 
breakpoints specify action point duplication occur include include code 
programmer way instantiating generic code 
chapter 
breakpoints events type user level event delivered user interface 
kinds breakpoints different print methods enable users distinguish 
ldb fib stopped fib fib break fib fib break fib fib fib 
object code breakpoint print method shows object code location corresponding source location fib line column file fib source breakpoint print method shows source location requested source location corresponds nearest stopping point breakpoint planted fib line column file fib finish command halts target particular procedure activation finishes executing 
associated single low level breakpoint planted address control return calling frame 
address obtained walking stack described chapter 
breakpoint created saves location calling frame modula object representing breakpoint action procedure question may recursive ldb target activation executes instruction return address 
taken breakpoint action verifies current frame matches saved delivers breakpoint continuation deactivates finish breakpoint temporary breakpoint taken 
frame match action waiting time control reaches address 
finish breakpoint may taken target program longjmp unwinds stack past activation finished 
stack unwinding common programs languages exceptions modula 
debuggers languages detect stack unwinding setting breakpoints run time exception mechanism 
ldb implements source level single stepping creating user level breakpoint plants lowlevel breakpoint stopping point current procedure stopping point executed 
action taken action taken finish breakpoint frame saved action object frame single stepping takes place calling frame 
user level breakpoint member breakpoint set 
breakpoint set associated target process 
breakpoint sets serve purposes 
provide way enumerate breakpoints associated target example listing command undoing command 
hold low level breakpoint implementation contains machinedependent data code needed create low level breakpoints 
simple breakpoints stay sets removed user temporary breakpoints finish remove sets part actions 
shows breakpoint set program fib 
user level breakpoints breakpoint set fib fib fib fib fib fib fib fib user level breakpoint set user level low level breakpoints 
single stepping 
user level breakpoints appear boxes labeled commands create 
ovals bottom row low level breakpoints labeled object code locations 
breakpoint set implements event handler handles low level events known breakpoint trap events 
event arrives breakpoint set handler distributes low level breakpoint associated user level breakpoint set 
distribution sense virtue modula subtyping low level breakpoint doubles event handler section 
event handlers shown ovals handlers recognize trap fib drawn double ovals 
actions deliver associated userlevel breakpoints user level events event continuation 
low level handler recognizes trap event delivered breakpoint set breakpoint set inconsistent bug ldb 
fields common user level breakpoints 
user level breakpoint contains condition tells take breakpoint counter tells times debugger take breakpoint stopping 
default condition true default counter zero 
conditions counters changed take command shown section chapter 
ldb breakpoints serve trace points difference debugger encounters trace point 
user level breakpoint contains boolean true point breakpoint print methods print break trace depending value 
action associated simple breakpoints uses condition counter boolean condition truei pt dec pt cont throw pt pt chapter 
breakpoints events cont throw delivers user level breakpoint trace point event user interface 
user level breakpoint boolean suspended field true breakpoint inactive 
user low level breakpoints supply undo redo methods change state breakpoint active inactive back 
user level breakpoints share single undo method turn calls undo methods associated low level breakpoints likewise redo methods 
ldb commands call undo redo methods user level breakpoints 
traps low level breakpoints implemented traps 
suspending trap inverse removes trap restores original instruction overwritten trap planted 
traps may planted suspended event handlers breakpoint actions users commands 
constraints order traps planted suspended trap planted suspended 
constraints caller plant suspend procedures cooperate callers 
constraints caller act independently 
plant suspend implemented naively saving overwritten instruction local storage order execution constrained 
example sequence leave memory unchanged leave trap 
plant trap save trap 

plant trap save trap trap 

suspend trap restore memory 

suspend trap restore trap memory 
words plant operations commute planted location suspend operations 
solution centralize state associated planted traps ldb trap set type 
implementation associates count program counter value trap increments count suspending decrements 
underlying memory manipulated count changes zero nonzero vice versa 
result plant operations commute regardless location suspend operations 
described section safe store information overwritten instructions debugger debugger machine crash information needed suspend traps lost 
solution keep information debug nub 
nub implements 
traps trapped memory plant suspend traps methods shown section 
keep nub simple debugger may ask nub plant trap location 
obey restriction debugger associate count program counter value 
debugger keeps information trap set 
trap set associated target process stored user level breakpoint set target 
debugger connects new target process traps method trapped memory add traps trap set 
trap set implementation upcalls userlevel breakpoint implementation creating new object code breakpoint associated previously unknown trap 
making upcalls ldb maintains invariant trap known nub corresponds active user level breakpoint known debugger 
example shows breakpoints ldb creates connecting process containing traps 
disconnecting fib breakpoints planted leaves traps process ldb fib stopped break fib fib break fib fib fib 
ldb fib stopped disc wait ldb fib disconnected quit fresh debugger target program empty breakpoint set ldb target fib ldb fib disconnected ldb fib disconnected original instance fib shows event stopped breakpoint fib ldb fib disconnected connect orchard 
old breakpoint fib fib 
fib void fib short ldb fib stopped reconnection mechanism added object code breakpoints correspond traps newly reconnected instance fib ldb fib stopped break fib fib break fib fib reconnection mechanism distinguish different flavors breakpoints second breakpoint object code breakpoint originally created source code breakpoint 
loss information inconvenient planted large number low level breakpoints just loss communication reconnection breakpoints deleted individually 
ttd solved problem associating set flavors trap chapter 
breakpoints events enabling users delete breakpoints flavor redell 
doing ldb require extending trapped memory methods nub keep track flavors traps addresses 
presence trap instructions target memory effect memory exported nub 
nub trap memory implementations cooperate ensure fetches trapped locations return original instructions traps 
debugger decode instructions regard presence absence traps 
debuggers solve problem undoing breakpoints time target program stops linton 
ldb implementation traps uses machine dependent code needs machine dependent data sizes bit patterns trap instructions target 
low level breakpoints problem low level breakpoint instruction divided parts 
debugger get control target program attempts execute second execution resumed executed subsequent attempts execute return control debugger 
get control instruction debugger overwrite trap instruction handle resulting trap black overwrite instruction branches debugging code digital 
resume execution wider range choices 
debugger return overwritten instruction memory execute single stepping target machine re plant breakpoint black 
single stepping avoided transforming overwritten instruction correctly executed line digital kessler 
debugger simulate effect overwritten instruction resume execution succeeding instruction 
machines special hardware supports resumption break instruction 
single stepping implementation breakpoint handle unexpected events 
machine single stepped debugger expects target execute instruction notify debugger execution 
possible instruction execute successfully example instruction single stepped refers invalid address divides zero 
debugger associate appropriate event handler possible outcome 
ldb implements breakpoints trap instructions 
unix signal delivered process attempts execute trap instruction 
debug nub signal handler deals errors dereferencing nil pointer traps implement breakpoints 
resume execution breakpoint ldb uses single stepping restricted form simulation depending target architecture 
ldb creates low level breakpoint instruction trap creating event handler possible resume execution immediately trapping second 
low level breakpoints time 
virtue modula subtyping single object acts low level breakpoint event handler interested trap events 
type breakpoint event handler object pc integer action breakpoint action suspended true traps trap set methods undo redo breakpoint action object methods take event low cont event continuation ldb uses subtypes breakpoint provide different implementations breakpoints subtypes implement undo redo matches event handler methods 
undo redo methods possible users temporarily breakpoints suspended field tracks state 
matches method takes breakpoint action determines target hit breakpoint 
implementations breakpoint offer different trade offs machine independence functionality 
follow sets ops 
follow set breakpoint temporarily suspends trap single steps target machine execute re plants trap 
single stepping means arranging target machine trap immediately executing processors trace mode causes machine trap instruction possible implement single stepping mode provided tell instructions executed immediately instructions constitute follow set 
ldb computes follow sets simple model 
instruction inline successor instruction instruction stream 
branch instruction branch target 
conditional branches follow sets containing instructions follow sets containing 
computed branch ldb needs memory date register contents compute follow set 
follow set breakpoint plants trap creates handler recognizing traps follow set 
handler sees trap plants traps follow set suspends trap takes action associated breakpoint 
sees trap follow set suspends traps follow set re plants trap takes action 
dave redell pointed model applies machines delayed branches provided branch instruction delay slot considered single word instruction 
chapter 
breakpoints events computed branch handler recomputes follow set time trap recognized 
time register contents guaranteed date 
appendix gives formal model implementation follow set breakpoints 
model shows implementation described incorrect presence multiple threads execution 
ldb support targets multiple threads active concurrently ways ldb change threads 
expression evaluation requires procedure call new thread created target address space call executes new thread 
previous thread suspended call 
ldb change threads changing targets 
ldb changes threads traps planted follow set ldb breakpoint appendix shows 
change occurs procedure unwound hitting breakpoint example 
problem solved delaying suspending trap traps follow set event handled described ldb waits resume execution thread hit trap 
solution complete ldb breakpoint attempt execute fails user changes threads 
situation natural response failing instruction try debug re execute instruction thread 
fails user change threads user reset breakpoint undoing redoing 
computing follow set instruction requires machine dependent code decodes determines branch instruction computes target branch 
decoding instructions straightforward code tedious error prone voluminous 
simplify problem designed little language describing instruction encodings 
language possible name different fields instruction specify patterns values different fields 
reduce likelihood errors patterns specified forms tables opcodes architecture manuals 
patterns combined avoid duplicating code treats different instructions similar ways 
appendix describes specification language detail gives example follow set computation complete instruction specification mips 
help special specification language computing follow sets ldb risc targets requires lines machine dependent code target 
code eliminated op breakpoints ldb simulate effect instruction breakpoint resume execution instruction 
simulation tractable insisting breakpoints planted op instructions reduces simulation advancing program counter 
scheme relies compiler support useful lcc places op instruction stopping point 
lcc places labels stopping points support requires extra implementation effort compiler 
ops increase number instructions depending target 
ldb implementation op breakpoints 
procedure calls machine independent requires machine dependent data size bit pattern op instruction prevent ldb trap location containing op 
ldb uses follow set breakpoints mips sparc op breakpoints vax 
procedure calls asking nub call procedure presents problem asking nub resume executing target program different events occur 
adopted solution breakpoints postscript code needed call procedure create event handlers completion failure procedure associate actions handlers 
postscript code calls procedures generated expression evaluation server solution tantamount requiring expression server continuation passing style appel complicate implementation 
ldb hides necessary event handlers making postscript procedure call operator look operator complete execution normally returning value fail raising exception 
appropriate debugger complex order simplify expression server support multiple languages ldb multiple expression servers 
target process hits breakpoint executing procedure call behalf ldb procedure call just fail user able debug shown page 
user wants debug procedure call postscript interpreter busy waiting result operator user interface busy waiting completion expression evaluation 
second user interface postscript interpreter available handle interrupted procedure call 
second user interface distinguishes 
prompt 
prompt original user interface interpreter suspended awaiting outcome call may normal termination unwinding 
call completes control reverts original user interface interpreter 
ldb handle arbitrary number suspended procedure calls 
fail fatal error nil pointer user revert previous original program unwind command 
gdb dbx debug failing procedure calls return previous context debugging call 
understanding debugger procedure call implementation requires understanding concurrency 
described chapter debugger uses user interface thread read commands listener thread respond low level events target 
target stops listener thread receives message reconstructs event delivers appropriate event handlers blocks waiting target start running 
listener thread uses event continuation prints user level events changes user interface current focus 
chapter 
breakpoints events single lock synchronize threads lock protects current focus state associated target including current user interface postscript interpreter 
user interface thread goes sleep call call completes listener thread awakens sleeping thread 
call fails listener thread creates new interpreter new user interface debug suspended call 
listener thread destroys new interpreter user interface receives event indicating call returned unwound 
ldb represents user interface modula object accept delivery event asked create new user interface result unexpected event arriving procedure call asked destroy longer needed 
creation destruction methods hide details forking destroying user interface thread read commands 
procedure calls user threads listener thread procedure call event handling procedure called evaluate condition associated conditional breakpoint 
listener thread go sleep asking nub call thread listening reply 
listener thread asks nub call waits event 
event return procedure call operator returns normally user thread continues evaluate condition 
event occurs listener thread attempt create user interface handle event simpler ask nub unwind call 
call unwound procedure call operator raises exception indicating failure occurred event handling 
failure occurs evaluation breakpoint condition breakpoint taken additional user level event generated indicating failure occurred 
discussion create new kind user level breakpoint write procedure determines plant low level breakpoints actions associated breakpoints 
possibilities sophisticated users want program user level breakpoints 
scheme useful part programmable user interface 
postscript operators higher level operators ldb postscript example plant low level breakpoint line file main better current store value object code location ldb uses event continuation accumulates events delivers user interface 
ldb support event debugging schemes different event continuations 
example ldb user level events correspond primitive events input dataflow machine olsson crawford ho 
useful formalize semantics ldb breakpoint commands language designed describe debugging crawford 
formal definition provide basis 
discussion judge correctness implementations commands 
example conditional breakpoints efficient code test condition run target process debugger 
formalization help clarify commands presence exceptions non local gotos 
ldb take skipping command provides convenient way measure performance ldb nub 
set breakpoint loop measured long took skip breakpoints 
breakpoint takes msec ldb uses pipes debug child process msec uses network connection machine msec uses network connection different machine 
experimental error msec 
gdb debugging child process ptrace takes msec 
measurements elapsed time dec model contains mips processor 
comparable measurement dbx provide command skips breakpoints way estimate cost interaction target program 
time ldb handles breakpoint goes cycles trap suspending trap resuming execution 
dbx takes seconds step machine instructions 
mips compiler generates ordinary instructions branch instruction loop 
branch instruction dbx plant suspend traps cost cycle msec 
ldb takes msec cycle 
debuggers conditional breakpoints faster ldb takes gdb msec take breakpoint evaluate condition 
dbx takes msec 
ldb takes msec depending connection mechanism 
reason ldb mechanism slower stores result expression nub global area fetched test 
ldb fetch address global area ldb unnecessary fetches unnecessary store 
eliminate unnecessary interactions nub expression server postscript variables hold temporaries possible 
follow set implementation low level breakpoints usually explained terms single stepping 
explanation misleadingly suggests breakpoints implemented simple sequential code 
fact implementation written kind continuationpassing style event handlers match continuations events 
thinking terms traps follow sets easier understand real implementation 
clarifies relationship implementation uses traps uses hardware trace mode suspending traps follow set equivalent setting clearing trace bit program status word 
ldb vax trace mode implement vax breakpoints simply overlooked possibility able change program status word non privileged program 
implementation vax trace mode verify model chapter handle machines hardware support single stepping 
chapter 
breakpoints events follow sets useful just implementing low level breakpoints 
example ldb command uses follow sets plant low level breakpoints 
follow sets implement source level single stepping command stepped called procedures dbx step command 
follow sets compute control flow graph procedure reduce number breakpoints planted source level command 
cost savings measurable single stepping heavily recursive procedure 
statement contained computed branch ldb able implement source level single stepping low level breakpoints stopping points stopping point 
number breakpoints hit called activations reduced reducing message traffic nub debugger 
chosen require follow sets ldb payoff high require extra implementation effort target 
chapter stack walking ldb users debug active procedure selecting appropriate stack frame current focus 
stack frame provides context commands particular scope name resolution memory print variables evaluate expressions 
implementing stack frames machine independent symbol table build scope stopping point 
walk stack find control stopped restore registers stack build memory ldb needs know target calling sequence location saved registers frame relationships frames caller frames machine dependent 
modula subtyping helps decompose problem machine independent machine dependent parts isolating machine dependent code methods 
stack frame abstraction implemented layers shown 
layers defined subtyping arrows point subtypes supertypes 
upper layers machineindependent 
model frame linkage general cover different calling sequences different targets 
middle layer class defines precisely done machine dependent layers 
frame boxed data structures hidden layers 
bottom layers machine dependent 
lowest contains machine dependent code contains machine independent code parameterized machinedependent data 
modula generics perform parameterization code referred generic code chapter 
frame objects ldb machine dependent types bottom layer virtue subtyping types belong upper layers 
layers shown contribute retargetability restrict visibility 
exception frame layer visible layers hidden layers frame hidden code 
target frame public exist reveal limited information user interface rest debugger 
user interface sees top layer rest debugger top layers 
table shows chapter 
stack walking target frame public class frame mc frame layers stack frame abstraction 
parts debugger import layer data fields defined layer 
line separates machine independent machine dependent layers 
table shows methods defined implemented 
modula method defined upper layer implemented lower layer 
client may call method method definition visible implementation need visible 
brevity machine independent methods defined target implemented frame omitted 
frame objects come bottom layer contain method implementations defined layer inherit implementations supplied layers 
machine independent layers top layer stack frame abstraction target exposed user interface sees methods shown table 
caller callee methods provide access adjacent frames 
visible provides scope context name resolution expressions compiled see section 
eval evaluates compiled expressions memory associated frame 
locus returns locus control return re enters frame 
locus stopping point 
example procedure call return locus middle expression stopping point 
example 
machine independent layers layer imported fields methods defined implemented displayed user interface print target user interface caller callee visible eval locus frame public rest debugger hp ra proc class lower layers init frame shown print caller callee visible eval locus init machine dependent layer machine dependent table locations method definitions implementations 
call fib returns locus main stopping points 
user interface layer provide direct access memory associated frame association hidden user interface manipulate memories directly 
shown target subtype displayed suggested table 
user interface print frame print method 
single print method machines implemented frame event stops target delivered chapter 
stack walking user interface frame top stack 
repeated applications print caller methods user interface produce stack trace ldb fib stopped fib 
fib void fib short main 
fib int main int argc char argv main 
int main int argc char argv char start 
start symbol table information ldb fib stopped user interface supplies frame numbers star marking current focus print method rest 
similar trace appears page chapter fib running mips sparc chapter 
source code fib appears page 
second layer frame public represents frames clients debugger level user interface 
exposes ldb model frame linkage 
model assumes frame identified single pointer called heavy pointer value remains unchanged lifetime frame 
ldb targets conform model realizing heavy pointer frame pointer stack pointer 
term heavy pointer frame stack pointer frame stack pointers different ways different architectures 
stack frame pair hp ra hp heavy pointer ra address control return frame re activated locus control described 
ra determines procedure proc procedure activation 
frame public ra hp proc fields values described model 
defines method provides memory frame 
registers memory describe values machine registers control returns frame 
implementations commands finish target run returns current frame section hp field identify frame 
modula object representing frame ldb discards object continuing execution target builds new target stops 
class defines interface machine dependent machine independent layers 
exposed code implements machine dependent layers debugger 
heavy pointer return address machine methods exposed user interface implemented machine dependent code exception methods find adjacent frames 
stack traversed top computation 
machine independent layers needed find caller frames frame keeps pointer callee frame 
machine dependent code needed tasks 

create object representing top frame stack fib example 
object contain return address heavy pointer procedure memory 
implementation procedure creates object machine dependent subtype frame subtype supplies methods perform tasks 

frame create object representing calling frame containing return address heavy pointer procedure necessarily memory 
example fib calling frame main 

construct memory frame memory specified time created main 
ldb uses different methods compute calling frames memories necessary compute memory frame 
users skip frames specifying number frame current focus ldb fib stopped fib 
fib void fib short ldb fib stopped start 
start symbol table information memories frames contain registers needed frame ldb need compute 
machine dependent methods defined class defines method initialize hidden fields frame type class frame public object methods init callee frame memory nil frame frame memory init method callee frame exists memory optional 
method raises exception calling frame bottom stack 
top frame problem constructing memory separated problem finding caller frame 
standard reconstruction memory correct way refer frame activation fib convenient refer frame procedure name 
procedure activation example ambiguity 
chapter 
stack walking preserved 
saved 
writable 
ldb action saved callee callee frame recovers frame written re uses callee version saved caller caller frame scratch unrecoverable linkage varies varies computes table register classifications ldb 
frame main uses information callee frame fib 
problems combined top frame init called initialize top frame memory lest standard reconstruction try get information nonexistent callee frame 
fourth layer frame abstraction frame implements machine independent methods print 
method uses machine dependent symbol table information frame procedure plus memory frame print names values arguments procedure 
depending flavor requested user interface print may print values local variables registers 
print method calls machine independent methods 
methods frame layer caller may call machine dependent methods 
machine independent methods lazy evaluation machine dependent methods called results needed results saved machine dependent methods called frame 
definition frame includes fields save results 
init method implemented frame layer initializes fields 
frame private frame module exposed part debugger 
generic layer machine dependent code target top frame creation procedure methods 
creation procedure method job restoring registers implemented generic machine independent code 
ldb classifies registers treatment calls 
linkage registers stylized ways enforce particular calling conventions typically include stack pointer frame pointer 
preserved registers general purpose registers values preserved procedure calls 
subdivide groups depending callee saves restores simply write 
preserved registers called callee save registers different term ldb distinguish registers saved restored written 
general purpose register preserved saved restored caller scratch register 
table shows register class states ldb recovers registers class 
ldb recovers registers creating memory 

generic layer ldb targets calling sequence determines registers linkage registers preserved preserved choices procedure 
example mips integer registers preserved floating point registers 
procedure compiler may preserved registers saved callee written 
example mips lcc compiles fib save integer registers 
register holds local variables depending live 
register holds return address 
fib leaves preserved registers untouched 
call site compiler may non preserved registers saved caller scratch 
official calling sequences ldb targets prescribe treatment registers saved callers 
lcc may spill temporary registers calls fraser hanson places source level variables registers ldb complete source level view stack frame restoring 
register classifications subdivide machine dependent parts stack walking 
creating top frame subdivided problems get return address heavy pointer process context combine memories shown section create aliases registers process context create aliases linkage registers 
subproblem requires machine dependent code 
creating caller frame uses current frame compute return address heavy pointer requires machine dependent code 
creating full memory frame subdivides problems combine smaller memories find information describing registers saved callee restore preserved registers restore linkage registers 
second fourth subproblems require machine dependent code 
subproblems solved generic machine independent code require machinedependent code 
ldb uses generic code recover preserved registers 
linkage registers registers require special treatment recovered machine dependent methods 
shows divided generic machine dependent code 
type frame object memory aliases methods integer integer represents underlying memory containing frame connection debug nub frame 
frame distinct aliases memory holds statement quite apply mips principle select register frame pointer virtual frame pointer 
practice mips frames fixed size procedures virtual frame pointer equal frame size plus value stack pointer 
chapter 
stack walking register aliases frame 
create aliases linkage registers registers restored generic code 
called generic procedure creates frame top stack generic method restores registers frames middle stack 
needs address process context may need restore registers context 
need address targets single procedure implement methods signatures compatible 
machine dependent method may recover register save information procedures compiled lcc 
example vax stores register save mask memory mips stores run time procedure table mips page 
machine dependent methods default procedures 
useful leave default methods place stages retargeting ldb 
defaults place ldb works restore registers possible 
machine dependent implemented ldb able recover local variables procedure calls procedure compiled lcc 
example program fib interrupted fib call printf ldb unable recover value local variable register register save information printf way tell register saved stack left untouched 
machine dependent implemented linkage registers appear memory 
local automatic variables addressed indirection respect linkage registers omitting impossible postscript code fetch values variables 
ldb implements targets implement 
finding register save information entail searching instruction stream move multiple instructions 
contributes retargetability making possible stack walking generic machine independent code requires parameter machine dependent configuration interface containing dozen lines machine dependent data 
primary task generic code build memories contain proper aliases registers 
frames middle stack main registers recovered callee frame fib 
frame top stack fib registers recovered process context 
rest section explains detail generic code handles cases 
generic code uses machine dependent data examples data shown 
mips run time procedure table data structure target memory created linker contains machine dependent data describing procedure program including register save information frame sizes information registers hold return addresses 
run time procedure table intended enable language run time systems walk stack implement exceptions 

generic layer preserved registers lcc divides registers register sets 
division orthogonal division linkage preserved preserved reflects structure underlying hardware 
vax single register set sparc mips integer floating point registers 
sets data address floating point registers 
register set corresponds space memory 
list spaces specifications construct memories shown section 
possible debugger add spaces correspond register sets known compiler 
specification mips array spaces correspond register sets known lcc space provides access program counter virtual frame pointer postscript 
restore preserved registers ldb know registers saved 
postscript ldb uses masks represent sets registers 
modula uses type set integers 
ldb know registers saved 
generic code assumes single contiguous part stack frame reserved registers saved callee registers saved order increasing decreasing gaps registers saved 
ldb targets calling sequences satisfy assumption 
amount space needed register order specified constant configuration interface const array integer preserved array element applies corresponding space similarly constant arrays configuration interface 
specify callee saves integer floating point registers bytes apart higher numbered registers larger addresses 
opposite order specified 
constant indicates registers saved frame recovered machine dependent means method 
preserved shows registers set preserved 
generic implementation actual restoring 
section shows part implementation creates memory shows full implementation including code creates aliases memory 
generic frames middle stack callee procedure computed line 
called create memory main callee frame ldb support machines satisfy assumption methods machines able current generic machine independent code 
chapter 
stack walking procedure frame memory var new frame callee narrow frame callee hif necessary find register save info set callee proc callee proc regs regs callee proc regs preserved preserved space hif preserved regs 
saved callee hold bindings reg reg regs saved bind reg space location absolute callee hp regs base count regs saved reg elsif reg preserved bound reg space bind reg space binding reg space frame aliases eval frame return memory join new frame generic implementation method 
fib 
lcc supplies callee procedure register save mask offset heavy pointer lowest numbered register saved 
information appears set regs saved integer regs base defined line lines 
combined size information configuration interface enables ldb compute location saved register 
registers main restored fib frame shown 
fib register save mask marks integer registers base integer registers showing generic code find registers respect fib heavy pointer 
fib frame contains space argument build area fib calls printf 
lines loop register sets lines loop registers set 
line loops known register sets register save 
generic layer argument build area saved saved heavy pointer virtual frame pointer fib stack frame mips 
information available 
register save information available callee proc regs empty code lines executed 
register saved callee line lines create alias appropriate location memory 
regs base added heavy pointer find location lowest numbered register register save area 
count returns number registers numbered lower reg saved 
number multiplied yields offset reg register save area 
code lines may restore non preserved registers vax procedures save non preserved registers 
register saved preserved register callee may change value alias callee frame re provided exists 
set line holds alias memory callee frame 
register preserved line tests existence alias exists copy created line 
lines aliased memory methods definitions shown section 
bind creates new alias bound tests see alias exists binding returns underlying location existing alias 
loop lines creates aliases saved preserved registers 
create aliases linkage registers calls machine dependent method line 
method finds alias memory aliases field frame line 
aliases created generic method assembles returns full memory lines just section 
example branch lines taken integer registers aliases created registers refer locations fib frame 
example register alias offset data space fib frame 
branch line taken preserved registers aliases created registers copies aliases fib frame refer locations process context 
example register alias examples signed arithmetic clarity 
actual arithmetic involving return addresses heavy pointers unsigned 
chapter 
stack walking offset ec data space process context 
non preserved registers restored 
mips creates aliases linkage registers return address heavy pointer stack pointer special registers virtual frame pointer register zero 
register zero zero 
mips dependent implements methods procedure frame 
frame aliases bind location immediate memory value frame ra frame aliases bind location immediate memory value frame hp frame aliases bind location immediate memory value frame hp frame attributes frame aliases bind location immediate memory value return frame locations created location immediate hold values arguments correspond real locations memory 
bind method frame aliases registers aliases immediate locations example register alias heavy pointer 
frame uses mips run time procedure table necessary add machine dependent data postscript dictionary associated current procedure 
data includes size frame compute virtual frame pointer 
ldb frame registers command prints frame includes values registers 
registers restore printed double dashes ldb fib stopped frame registers main 
fib int main int argc char argv pc sp line registers shows registers program counter virtual frame pointer sp heavy pointer 
registers zero stack pointer restored generic code method 
omitted display floating point registers 

generic layer frame top stack ldb uses generic code implement procedure creates top frame stack fib 
frame creation procedure restore registers find heavy pointer program counter process context 
description process context identifying names fields offsets context appears configuration interface 
mips process context system struct described type context mask pc regs cause const offsets array context integer description context shown page section type context data address pc const offsets array context integer descriptions generated automatically postscript program reads symbol table entry context defined debug nub 
process context located target data space 
address known locations various fields calculated 
interface defines object represents integer stored process context 
address context specified order read write integer type integer object methods get memory integer integer put memory integer val integer configuration interface defines variables pc hp enable generic frame creation procedure find program counter heavy pointer process context 
var pc hp integer generic code provides subtype denote integer known type known offset known field 
field value type context configuration interface config type integer integer object type memory type offset integer field config context chapter 
stack walking procedure new target target integer frame var target new process context create register aliases pc config pc get hp config hp get return new ra pc hp hp aliases proc target pc target target init nil memory join new new generic procedure creating top frame stack 
generic code instantiated objects instantiated type represent pc hp 
mips program counter pc field heavy pointer register located regs field pc new integer field context pc type memory type hp new integer field context regs type memory type offset generic instantiation mips 
shows generic frame creation procedure 
argument type target contains global state associated target including connection debug nub target target linker table top level dictionary 
memory created technique shown section code appears lines 
line shows init method implemented frame type argument nil indicates callee frame second argument memory newly created frame 
lines show pc hp configuration interface fetch program counter heavy pointer process context 
lines create frame 
type frame specified configuration interface type creating frame just compute return address heavy pointer procedure required frame public definition 
creating procedure initialize data defined layers frame abstraction including aliases defined generic layer target defined top layer private data frame layer initialized init method 
uses linker table find procedure containing program counter pc described section 

generic layer registers top frame restored differently registers frames middle stack 
callee frame holding saved registers registers saved process context 
register save masks register sets assumed saved wholesale registers process context 
assumption holds machine sparc sparc machine dependent method restore ordinary registers linkage special registers 
constants configuration interface specify context register sets saved arranged 
mips integer floating point registers stored regs fields process context 
stored bytes apart higher numbered registers higher addresses array array context context regs context context pc array integer repeated definition clear information applies register set 
shift indicates registers saved context created machine dependent method called line 
mips single procedure serves methods mips implementation shown 
generic code uses restore registers top frame simpler analogous code method process context create register aliases base bind location shifted base produces location field process context address context 
chapter 
stack walking fib frame generic code restores integer registers just preserved registers 
method creates aliases registers register values known ldb fib stopped frame registers fib 
fib void fib short pc sp registers preserved registers values fib frame main frame 
machine dependent layer lowest layer frame abstraction machine dependent layer different subtype target subtype specifies implementations methods 
described implemented generic machine independent code parameterized configuration interface implemented machine dependent procedures 
mips implementation appears implementation simpler binding linkage registers procedure frame 
frame aliases bind location immediate memory value frame ra frame aliases bind location immediate memory value frame hp return frame callee procedure compiled lcc register save information provided compiler 
may possible get information calling machine dependent method hif necessary find register save info set callee proc callee proc regs nil callee 
machine dependent layer machine dependent method called procedure information supplied compiler 
implementation vax simplest low order bits word procedure register save mask 
code uses memory specify offset space directly avoiding allocation modula object implied call location absolute 
procedure frame var proc frame proc memory frame proc entry memory type saved word extract proc regs new ref array proc regs saved saved proc regs base implementation mips slightly complicated get information run time procedure table 
sparc register windows keep implementation simple optimized leaf routines save registers save registers starting frame pointer 
sparc operating system flushes register windows stack delivers signal nub 
ldb provide machine dependent method noted doing entail searching instruction stream move multiple instructions 
default method returns empty regs array code lines executed aliases registers created 
part stack walking problem finding caller frames frame hp ra compute hp ra 
example fib frame compute main frame 
identified common machine independent part job cost low machine dependent implementations methods lines modula 
mips heavy pointer stack pointer procedures varying size frames 
procedures heavy pointer frame register 
pc register holds return address vary 
procedures register procedure bottom stack uses register 
run time procedure table identifies pc register frame register frame size procedure 
pc register linkage register treated preserved register leaf routines write routines save initial value frames 
information run time procedure table needed compute caller frame ra pc register may saved frame hp hp proc fail ra attempt compute caller frame fails ldb reaches bottom stack caller frame method raises exception 
example exception chapter 
stack walking raised machine independent code calls method object representing start frame 
sparc choice heavy pointer arbitrary stack pointer 
non leaf routines hp hp gamma ra hp gamma fail ra indicates value word stored data space offset register window mechanism saves registers heavy pointer return address registers 
sparc leaf routines caller frame hp hp ra register fail ra heavy pointer frame pointer ra hp hp hp fail hp ra vax heavy pointer frame pointer ra hp hp hp fail ra mapping ra proc machine independent computed shown 
top frame procedure method initialize frame creates 
complexity varies target 
implementation simplest 
procedure frame mc frame frame var ra fp integer frame hp ra memory frame frame hp memory type fp memory frame frame hp memory type ra return new mc frame ra ra hp fp frame proc ra init frame raise error error uc 
discussion new frame created top frame lines initialized differently callee frame supplied memory 
memories frames top computed demand shown computation initializes aliases field need initialized method 
discussion ldb handle caller save registers 
restriction prevent working lcc lcc puts source level variables caller save registers 
ldb current approach generalized handle caller save registers 
generalization require changes just generic code postscript symbol tables compiler provide register save information call site basis 
current interface compiler debugger refer call sites stopping points call site stopping point 
problem handled having compiler call site stopping point 
generalizing ldb current approach mistake current approach assumes registers saved restored call 
caller save registers effective saves restores eliminated splitting live ranges variables chow hennessy 
example variable may moved register memory stay memory span calls 
variable restored need restored register occupied call 
view clear problem restoring caller save registers finding values variables 
problem solved having debugger restore registers having compiler tell debugger locations variables change time described section 
solution advantage machine independent require change stack walking code 
design frame abstraction illustrates engineering trade simplicity specification simplicity implementation 
earlier version ldb machine dependent frame type implemented class directly omitting layer 
implementation task simply specified machine dependent code implement methods creation procedure easily described job 
implementation complex 
restoration registers done machine dependent code implementation combined reconstruction register save information 
similarly creation topmost stack frame combined restoration registers process context 
cases combined problems solved somewhat differently targets 
chapter 
stack walking current model additional layer complex identifies subproblems machine dependent code subproblems solved generic code 
noted creating top frame subdivided problems get return address heavy pointer process context build framework memories create aliases registers process context create aliases linkage registers 
subproblem requires machine dependent code 
similarly problem restoring registers frame subdivided problems find information describing registers saved callee restore preserved registers restore linkage registers 
third subproblems require machine dependent code 
decomposition provides better path retargeting subproblem solved information provided compiler function compiled lcc 
model frame linkage chapter assumes procedures called atomically 
fact targets vax process atomic 
program counter changes new frame allocated registers saved 
sparc sequence takes instructions take mips register saved time 
target stopped intermediate state change program counter registers saved ldb aliases registers reflect actual locations registers 
target stopped stack frame allocated ldb walks stack incorrectly 
problem severe ldb normally see targets intermediate state 
happen target interrupted state user ldb ability step forward instruction faulty program branches invalid address 
similar intermediate states exist exit sequences atomic cause similar problems 
better retargetable implementation stack walking having compiler identify program counter values correspond intermediate states 
lcc front assumes procedure call atomic operation changes back 
topmost procedure stack compiled lcc full generality necessary write machine dependent code examine instruction stream determine target intermediate state 
error commonly puts target program intermediate state indirect call function pointer zero program counter changes frame allocated registers saved 
ldb detects case correctly recovers top frame process context 
refuses requests walk stack program counter valid procedure 
ldb extended handle common case handled correctly help compiler 
ldb worse debuggers 
sparc gdb fails walk stack 
sun dbx walks stack correctly program compiled dbx style 
discussion debugging symbols crashes 
mips gdb dec dbx walk stack debugging symbols 
intermediate state problem affects debuggers just ldb 
proper solution requires restrictions entry exit sequences easy identify transitions states 
restrictions apply ordinary leaf non leaf procedures frames appear stack frames bottom stack support signal handlers 
restricted calling sequences need degrade performance dec calling sequence meets requirements affecting performance digital section 
sparc keeps information saved registers stack register windows 
general sparc process context includes state number register windows number operating system delivers signal 
practice operating system flushes register windows stack interrupt occurs process context contains register windows 
exception occurs operating system unable write stack problem typically caused stack overflow 
case nub signal handler go stack impossible debug anyway 
nub arrange handler executed signal stack scheme creates new problems operating system detect overflow signal stack impossible call procedures reliably stack 
ldb worse sun dbx debug process stack overflowed 
handle general case ldb sparc dependent stack walking code simply verifies register windows flushed stack 
chapter 
stack walking chapter ldb postscript postscript necessarily mean language printing graphics 
postscript simple strongly typed postfix language usually delivered large subroutine library set operators printing 
ldb retains core language uses different subroutine library suited debugging 
ldb uses postscript interpreter jobs reading symbol tables transferring information compiler expression evaluation server evaluating expressions printing values 
jobs require lines supporting postscript code addition postscript symbol tables generated compiler compiler expression server rely lines divided equally tasks printing values section transmitting symbols types expression server section implementing lcc intermediate language section 
code depends just lcc lines rewritten support compiler structure value printing procedures similar 
remaining postscript code manipulates symbol tables section provides machine dependent code data section language compiler independent 
debugger source code devoted implementing postscript 
implementation effort justified postscript confers benefits conferred modula including support expression evaluation readable representation symbol tables ability change printing procedures debug time fast turnaround debugging expression server compiler 
explain interpreted language preferable simple interpreter intermediate code syntax trees postscript preferable languages 
ldb implementation postscript uses techniques may interest implementors safe fast lexical analysis modula compact specifications operator implementations 
techniques described measures took improve performance postscript interpreter 
chapter 
ldb postscript ldb deviates published semantics postscript adobe chapter ways 
features changed language better modula 
features omitted expensive implement useful debugging 
features added support debugging expression evaluation 
modula uses type text represent strings strings immutable 
modula supports garbage collected memory uses exceptions indicate errors uses different types represent files reading writing 
features reflected ldb postscript 
ldb postscript omits substrings subarrays 
strings immutable substrings useful indistinguishable copies 
subarrays worth implementation cost 
subarrays expensive modula safe subset modula subarray construct subarrays dynamically allocated arrays create pointers subarrays store objects 
standard postscript substrings subarrays primarily part idiomatic storage allocation strategy 
standard string array operators allocate space results string array provided hold results 
space provided may needed operators return substrings subarrays 
ldb postscript similar operators allocate space results interpreter relies garbage collection reclaim space longer needed 
ldb postscript access control 
access control necessary state postscript interpreter resides printer shared users postscript interpreter user ldb 
ldb postscript omits imaging types operators 
dozen types operators added support debugging operators support expression evaluation 
new types include memories locations symbols shown 
ldb postscript character type literal syntax refer spaces memories 
implementation ldb postscript interpreter parts 
code lines modula implements basic abstractions postscript 
include hierarchy object types recognized interpreter structure interpreter code needed interpreter execute postscript objects 
lines implements lexical analysis operator implementations account remaining lines 
ldb implements postscript object types save 
types modula subtypes object 
shows part subtype hierarchy describes interpreter types unqualified names appear interface 
operations 
implementation object char number boolean string name operator mark null array dictionary reader writer integer real type memory displayed target event frame symbol memory location break hierarchy interpreter types 
subtypes shown 
storing value dictionary array operand stack type object subtypes 
interpreter distinguishes subtypes object integer real example objects subtypes printed differently 
type provides means introducing new types support debugging 
type declared subtype inherits ability manipulated interpreter code written 
new types stored postscript data structures manipulated postscript code 
memory manipulated postscript operators memory fetch 
implement operator requires standard modula mechanism run time type checking typecase require extra support interpreter 
type checking code generated automatically adding new operator requires short specification shown section 
techniques postscript interpreter useful minimizing marginal effort required add new types operators 
ldb represents postscript interpreter modula object having dictionary operand execution stacks distinguished dictionaries 
interpreter object possible active simultaneously 
possible clone active interpreter making new interpreter operand dictionary stacks empty execution stack 
ldb uses feature create new interpreter error procedure call suspends current interpreter middle evaluating expression section 
new interpreters created cloning master interpreter contains bindings predefined operators 
rest debugger interacts interpreters modula procedures push pop operand stack interpret postscript objects 
convenience procedures interpret text files implementation converts modula object corresponding postscript object interpret postscript object 
postscript object interpreted placing execution stack operand stack depending type executability chapter 
ldb postscript attribute 
interpreter executes object top execution stack execution stack emptied 
semantics executing individual object depends type adobe section 
rest basic code implements postscript dictionaries including looking name dictionaries dictionary stack 
safe fast lexical analysis ldb lexical analysis bottleneck accounting time required read large postscript file 
standard techniques exist implementing fast lexical analysis techniques unsafe language features waite 
modula offers buffered stream abstraction safe fast 
abstraction implementations provide input different sources including files strings 
developed related abstraction useful properties supports implementation fast lexical analyzers isolates unsafe features works implementations existing input stream abstraction 
modula reader input stream abstraction models sequence characters current position pointer characters read nelson chapter 
ldb adds remembered position may may set 
characters current position remembered position guaranteed buffered single procedure call 
intended lexical analyzer set remembered position token scan current position forward token 
procedure search provides fast scanning shown inner loop analyzer described waite adequate speed implementation uses unsafe features modula pointer arithmetic 
interface improves speed techniques fast search 
avoids making procedure call character eliminates unnecessary allocations avoids copying characters necessary waite 
reduces synchronization overhead clients explicitly acquire lock calling procedures interface having procedure acquire release lock readers 
feature technically unsafe simultaneous unsynchronized calls search lead unchecked run time error 
risk acceptable improves performance lock acquired released token character 
synchronization costly reading large postscript files ldb spends time acquiring releasing locks addition spent lexical analysis 
lock required modula reader abstraction eliminating mean system calls directly read files writing special code read strings 

implementation compact specifications operator implementations code implements postscript operator find operands stack check types convert postscript types modula types example integer integer 
code generated automatically compact specifications notations section postscript language manual adobe 
generated code times larger specifications 
example specifications operators language manual pop stack exchange top elements copy top element 
pop 
exch 
dup 
left arrow names associated values operands stack 
right equals sign names associated positions stack results operator implementations assign names 
underscores refer unnamed operands results 
right equals sign modula code implements operator 
code generated specifications checks stack underflow overflow binds names values designators adjusts stack pointer implementation executed 
modula implementation needed pop stack manipulation implements pop full semantics 
generator infers types operands names 
denote operands type 
int denotes integer operand treated integer modula code implementation index int index 
int int sp interp error interp stack sp int operand index integer generated code indicates typecheck error 
shown modula code follow separate lines equals sign 
sp stack predefined identifiers refer interpreter stack pointer operand stack respectively 
interp refers interpreter 
operators polymorphic 
operators specifies different implementation valid combination operand types 
generated code places appropriate implementations leaves nest typecase statements 
specification add operator int int add 
sum sum int int int real add 
sum sum new real float int real real int add 
sum sum new real real float int real real add 
sum sum new real real real chapter 
ldb postscript possible infer type operand name 
example possible specify memory operators follows val type memory store 
type memory fetch 
val 
types operands explicitly notation name type 
memory location types specified name subtypes 
memory memory location val type 
memory store 
memory memory location type 
memory fetch 
val 
types memory value memory type subtypes referred name val type 
val handled integer real memory value 
new subtype needed represent type 
notation type memory type type creates subtype field type containing memory type 
new subtype private module referred type 
complete correct specification memory operators type memory type type memory memory location val integer type type memory store 
memory store memory value integer true val type memory memory location val real type type memory store 
memory store memory value integer false val type memory memory location type type memory fetch 
val memory type val memory fetch type val new real memory fetch type types named explicitly specify postscript operators create locations procedures described section 
offset integer space char absolute 
validate space location absolute offset space base memory location offset integer shifted 
location shifted offset base base memory location offset integer space char indirect 
validate space location indirect offset space base int immediate 
location immediate memory value int real immediate 
location immediate memory value integer false real validate space ensures space lower case letter just character 
example uses operators absolute shifted appear chapter 

discussion performance tuning original implementation ldb postscript interpreter spent time garbage collecting lexical analysis 
techniques improve performance 
lexical analysis uses token streams character streams described 
lazy transformation symbol type dictionaries defers lexical analysis reducing time required read large tables section 
unique string table ensures string allocated reducing execution time 
lexical analyzer avoids allocating modula texts intermediate stage tokens unique strings reducing execution time 
small integers preallocated integers ldb postscript fall range gamma larger symbol tables hitting slightly higher percentages 
earlier versions lcc packed line column numbers single integer lcc uses separate integers integers preallocated combined integer 
reduced garbage collection time altering garbage collector distributed src modula handle rapid heap growth 
new version increases heap proportion amount live data previously increase fixed size 
proportion adjusted dynamically trade speed space usage appel reducing execution time 
adjustments combine ldb current interpreter read large symbol tables times faster original 
measurements taken program counter sampling indicate spends time garbage collection lexical analysis 
spends acquiring releasing locks charged lexical analysis lock acquired released token scanned 
thirds time spent token stream implementation search 
scanner called times elapsed time measurements practical attempts measurements increased running time program 
discussion noted ldb uses postscript interpreter jobs reading symbol tables transferring information compiler expression evaluation server evaluating expressions printing values 
jobs done modula code case advantages interpreted language 
debugging formats predefine fixed set source language types debugger implements printing procedure type 
set types code debugger extended support new languages 
users control values printed adjusting couple parameters integers printed decimal hexadecimal notation 
interpreted language means compiler writer create new types chapter 
ldb postscript new printing procedures touching debugger proper 
users create new printing procedures debug time example specifying certain pointer treated pointer null terminated array 
interpretation provides fast turnaround useful writing value printing code 
expression server code converts types symbols representation stream tokens 
ldb postscript interpreter interactively debug code experimenting producing stream tokens expected 
ldb uses print values oppen 
uses backtracking algorithm produce output difficult predict output appearance 
recompiling re linking restarting debugger change procedures unacceptably slow 
interpretation possible change printing procedures ldb connected target re print offending value 
facility helpful user trying write specialized printing procedure complex linked data structure example 
fast turnaround provided interpretation equally helpful data displayed method example drawing pictures screen myers 
picture drawing procedures put postscript compact operator specifications shown standalone postscript interpreter interactively experiment ways displaying data 
suitable methods developed replace existing printing procedures providing alternative way displaying data 
evaluating expressions requires debugger capable generating machine code target address space form interpretation 
alternatives compiling expressions general purpose language interpreting syntax gdb compiling special intermediate code ups russell interpreting existing compiler intermediate code 
interpreting lcc intermediate code probably simplest alternative postscript simplest 
lcc dag language type suffixes type specific operators variant generic operators 
ldb postscript standard data types plus dozen subtypes 
operators including special operators support debugging 
examples section show cost adding types operators small new types subtypes operator implementations require lines code 
postscript control operators structured data types array dictionary difficult implement dag language goto atomic data types 
costs implement execute postscript lexical analysis cost implement execute code recover lcc dags byte stream chosen carefully direct representation dags harder debug 
intermediate code ups compares lcc intermediate code having operators signed unsigned variants basic types 
ups ansi interpreter including front ldb current user interface support creating new printing procedures postscript interpreter directly understand ldb conventions 

discussion back ends lines russell 
postscript probably simpler implement interpreter syntax handle control operators data types source language 
really convincing demonstration postscript utility expression evaluation different language compiler motivation general purpose language postscript particular easy different languages minimizing changes needed compilers 
having symbol table information form easily manipulated general purpose interpreted language possibilities debugging 
ldb machine dependent description structure context debug nub generated automatically nub symbol table 
written set postscript printing procedures printing values print modula declarations corresponding types 
procedures part tool translate header files modula interfaces 
fast turnaround helped develop procedures quickly easily 
factors influenced choice postscript 
advantage interpreted language provides representation easy people read tools manipulate bytecode machine code inappropriate 
designing new language best avoided considered postscript scheme clinger rees forth moore tcl ousterhout 
offer data types 
benefits postscript obtained scheme number reasons prefer postscript 
compiler expression server generate code debugger postscript designed generated programs adobe 
postfix notation easy generate interpret experience confirms 
example code rewrites dag node postscript lines kinds dag nodes 
postfix language easy implement scheme requires higher order functions continuations 
postscript dictionaries provide convenient notation symbol table entries 
dictionaries easily extended machine dependent data adding entries ldb mips adding information frame size return register 
ldb ignores information machine dependent stack walking code 
postscript object attribute tells explicitly object literal executable distinction need inferred context 
attempts execute literal object put object stack procedures interpreted replaced results 
ldb uses technique fetching addresses relative anchor symbols see section 
chapter 
ldb postscript postscript syntax possible defer interpretation lexical analysis quoting code parentheses 
described section technique reduces time required read large symbol table 
savings lexical analysis interpretation 
chapter retargeting ldb chapters describe ldb major machine dependent parts debug nub breakpoints stack walking 
part factored machine independent small machinedependent subparts 
shows code needed implement subpart target bars represent targets 
striped parts bars represent modula code debugger 
parts representing configuration stack walking left separated representing instruction decoding right instruction decoding implemented targets code implemented 
dark solid parts bars represent assembly code nub white parts represent postscript 
table bottom shows sizes major parts including machine dependent machine independent code 
ldb generates instruction decoding implementations postscript operators compact specifications table measures size specifications generated code 
bottom table shows sizes generators transform instruction specifications postscript operator specifications modula code described appendix section 
generators written icon griswold griswold 
reveals different costs debugging different targets 
stack walking expensive mips 
mips calling sequence uses frame pointer impossible walk stack frame size procedure known 
program may contain procedures compiled lcc information may postscript symbol table 
mips uses line module get information run time procedure table table placed target memory mips linker 
mips stack walking code contains lines call module 
run time procedure table supplies register save information procedures compiled lcc 
mips nub postscript larger sparc comparable machine largely mips rules passing arguments procedures complex requiring chapter 
retargeting ldb number lines mips sparc vax configuration stack walking run time procedure table debug nub postscript instruction set specification follow sets disassembler percentage total size ldb mips sparc vax shared total debugger instruction decoding instruction decoding patterns debug nub assembly postscript pattern transformer icon operator transformer icon total machine dependent parts ldb 
integer floating point registers depending types arguments 
calling sequences exhibit comparable complexity 
large nub uses assembly language build process contexts manipulate bit floating point values vax uses assembly language build process contexts 
ldb uses instruction set specifications implement follow sets symbolic disassembly mips sparc shown right halves top bars 
follow sets implement low level breakpoints instruction single stepping described chapter 
disassembly show machine code users 
instructions including synthetic instructions disassembly code long difficult write parallels instruction set specification 
instruction set specification sparc 
nub complex mips reflecting greater complexity sparc instruction encoding sparc instruction formats mips 
effort required retarget ldb minimal 
ports vax architectures took week 
colleague independently retargeted earlier version sparc stack walking configuration code spent weeks working half time 
detailed examples ldb machine dependent code appear chapters appendix chapter provides detailed comprehensive overview needed move part system new machine 
nub postscript debugger proper compiler discussed separately 
nub nub require lines machine dependent code full machinedependent details 
require lines code 
details include defining signal handlers proper type getting nub pause startup possibly invalidating instruction cache possibly supporting special data formats coping machine dependent idiosyncrasies 
isolate details nub uses preprocessor machine independent code invokes machinedependent macros 
macros conditional compilation nub smaller code easier understand 
control flow obscured directives usually possible assign machine independent meaning flush instruction cache macro definition machine dependent 
effort retargeting nub devoted details capturing process context supporting procedure call 
minimum process context include values registers program counter 
changes values stored context affect actual machine state execution resumed 
mips struct properties serves process context 
ldb uses struct sparc sunos supply values registers supply build stack frame 
supply register optimized leaf routines hold return address ldb encounters routine user examine shared stack frame perspective routine caller 
vax struct supply information registers acquired assembly code example shown section 
code plus definition process context lines assembly code lines vax 
section explains nub implements procedure calls machine independent template invokes machine dependent macros handle argument passing 
writing macros requires thorough understanding argument passing rules macros large lines vax sparc mips 
chapter 
retargeting ldb targets support sizes integers float double supports bit extended floating point values 
defines macro plus functions nub calls fetch store bit floating point values 
undefined attempts fetch store bit floating point values fail 
functions written assembly language manipulate bit floating point values implementations take lines 
manipulate bit values memory arguments results bit doubles 
extra bits discarded 
similar losses precision may occur target program floating point values occupy bits stored registers bits stored memory 
debugger fetches stores bit floating point values floating point registers saved stack process context 
extra bits needed application different machine dependent code written ldb debug nub protocol changed handle floating point values larger long words 
targets required data types accessible handled similarly 
addition process context procedure call extra data formats nub handle idiosyncrasies individual machines 
mips idiosyncratic needing lines assembly code handle problems analogs machines 
example big endian mips floating point values stored significant word kernel saves floating point registers struct stores significant word 
recover registers correctly nub save location floating point registers process context code fetches stores saved floating point registers swap words fetching storing locations 
code uses machine dependent macro swap mips op targets 
retargeting task associated nub 
give nub initial control system dependent startup code modified call nub main 
easily modified editing object code replacing main main 
method dirty easier modifying assembly code call targets assembly code available 
postscript ldb uses machine dependent postscript address automatic variables describe target registers help support procedure calls 
lcc assigns offset automatic variable 
targets variables addressed indirect respect frame pointer 
vax positive offsets arguments indirect respect argument pointer negative offsets locals indirect respect frame pointer 
vax uses separate 
debugger code breakpoints stack walking argument pointer arguments need passed stack 
lcc emits postscript code computes location automatic variable applying local procedure offset 
local dup ge ap fp exch indirect def vax local fp exch indirect def fp location frame pointer defined differently machine 
ap location argument pointer defined vax 
ldb defines names local fp postscript dictionary target architecture 
dictionary associates machine dependent names definitions 
architecture selected postscript procedure architecture set call appears symbol tables emitted compiler 
called architecture set places appropriate machine dependent postscript dictionary dictionary stack making definitions visible 
architecture changes architecture set subsequent calls 
ldb uses machine dependent postscript code print register values associated stack frame easily done postscript modula 
machine dependent dictionary defines names locations types registers machine 
register names expressions 
example discover size fib frame subtracting frame pointer stack pointer 
sparc words hex bytes ldb fib stopped fp sp unsigned int fp sp mips nub mentioned know types arguments procedure order put arguments proper registers 
mips dictionary redefines postscript procedures store arguments argument build area 
new versions addition storing arguments encode types arguments word machine dependent data 
word eventually passed macro described section 
debugger code breakpoints stack walking debugger proper ldb uses object type architecture hold machinedependent code data particular target architecture 
code data describe breakpoints instructions stack walking 
architecture fields 
name name architecture ldb associates particular object type architecture architecture name postscript ldb uses machine dependent code data associated object 
break low level breakpoint implementation usually defaulted specification recognize breakpoint trap events 
pc object provides access program counter process context 
follow procedure computes chapter 
retargeting ldb pc new integer field context pc type memory type hp new integer field context regs type memory type offset architecture add new architecture name mips break implementation follow trap specification memory type pc pc follow follow disassemble disassemble new mips configuration module 
follow set instruction section disassemble procedure computes textual representation machine instruction 
procedure process context returns object representing frame top process stack 
architecture architecture created configuration module shown 
low level breakpoint implementation encapsulates strategies ldb uses implement low level breakpoints hiding strategy machine dependent data code needed implement section 
breakpoint implementation object plant method user level breakpoints create low level breakpoints plus trap specification section 
different plant methods available configuration code supply specification describing op instructions procedure computes follow sets 
mips ldb uses follow set procedure follow shown line 
follow disassemble rely instruction set specification shown appendix sizes parts shown right 
follow course specify follow set breakpoints 
ldb uses follow implement command uses procedures implement assembly command shown chapter 
default versions follow disassemble vax raise exceptions making ldb print error message user attempts command uses 
procedure hides details getting information process context building memories walking stack 
creates top frame stack memory 
frame machine dependent methods find frames stack build memories containing saved registers 
procedure stack walking implemented generic code described section 
parameter generic code machine dependent configuration interface 
shows complete configuration 
debugger code breakpoints stack walking type context mask pc regs cause const offsets array context integer var pc hp integer const array array integer bits set array context context regs context context pc array integer array integer preserved array mips configuration interface 
interface mips pieces explained sections 
line identifies subtype frame mips type defines machine dependent implementations machine dependent methods described section 
lines describe structure process context line declares variables fetch program counter heavy pointer context 
lines describe structure mips memories 
lines tell find registers process context lines tell restore preserved registers stack walking 
module implements mips configuration interface 
instantiation generic stack walking code mips configuration interface parameter 
integer type provides access fields process context new procedure uses process context create topmost stack frame 
implements follow set computation symbolic disassembly described appendix lines define locations program counter heavy pointer process context lines create install architecture describes mips 
lines breakpoint implementation created machine independent code requires specification traps procedure computes follow sets section 
configuration labels parts bars measure sizes configuration modules interfaces figures plus lines needed instantiate generic stack walking code different targets 
chapter 
retargeting ldb compiler lcc retargeted new machine 
retargeting back scope thesis fraser hanson 
compiler symbol table code emits postscript symbol tables puts labels anchor symbols compiler assembly language output retargeted defining machine dependent macros 
compiler puts name target architecture symbol table 
lcc uses small integers represent register sets string associate register set numbers lower case letters name spaces memories 
letters determined array configuration interface register set associated element 
compiler emits label possibly assembly code stopping point 
macros mips define architecture mips define rf define set nl set reorder indicates register set corresponds space integer registers set space floating point registers 
set commands prevent assembler instruction scheduler moving instructions stopping points 
uses op breakpoints different collection register sets 
register sets correspond spaces address data floating point registers define architecture mc define arf define nop discussion ldb machine dependent code covers axes mentioned chapter instruction set calling sequence run time support 
describing instruction set possible compute follow set instruction possible implement breakpoints planted branch delay slot 
pattern language described appendix describes mips sparc architectures concisely 
language suited describing vax provide means describing instructions vary size writing patterns match sequences opcode followed operands 
instruction decoding follow set computation implemented entirely hand implementation tedious error prone possibly efficient machine generated 
better extend pattern language handle cisc instruction sets 

discussion instruction set decoding symbolic disassembly account large fraction number lines machine dependent code mips sparc 
intellectual effort required proportional size code 
instruction set descriptions descriptions appear manuals symbolic disassembly code requires print statement group instructions having similar syntax 
real effort expended design pattern language re different tasks different machines 
general breakpoints planted op instructions implemented describing instruction sets 
ldb uses breakpoints vax 
utility depends cooperation compiler targets inserts op stopping point 
op breakpoints implemented just lines machine dependent data describes op trap instructions 
general follow set breakpoints necessary op breakpoints provide useful implementation path 
stage retargeting debugger functional restricted breakpoints 
second stage general breakpoints implemented 
calling sequences affect retargeting areas stack walking procedure call support 
ldb choice abstractions problem stack walking stated simply identify frames return address heavy pointer build memory representing frame register contents 
targets memory structure shown page generic code restore registers little retargeting effort associated memories 
shown specify spaces memory treatment saved registers locations registers process context identities preserved registers 
choice spaces memory correspond compiler choice register sets correspond hardware 
targets may useful add extra space hold values accessible normal registers mips program counter virtual frame pointer 
contrast writing code identifies stack frames difficult parts retargeting 
difficult calling sequence documents available written stack walking mind 
calling sequence inferred description return instruction vax assembly code generated compiler 
mips sparc architecture manuals specify calling sequences detail write conforming procedures 
documents specify structures frames stack example omit descriptions signal handler frames bottom frame stack 
coping special frames represent significant retargeting effort linton 
ldb attempt reverse engineer undocumented stack frames example mips mistakenly identifies signal handler frames bottom stack 
chapter 
retargeting ldb calling sequences specified stack walking easy digital 
specifications characteristics identify kind frame appear stack place restrictions entry exit sequences intermediate states discussed section easily identified 
restrictions degrade performance typical restriction registers saved callee saved register written 
implementors debuggers ones benefit careful specification calling sequences 
stack walking implement exception handling languages ellis stroustrup ada dod modula permit active procedure handle exception 
method generalizes handler table method described liskov snyder exception raised run time system walks stack looking return address scope appropriate handler 
method requires execution time overhead normal case 
despite small size nub difficult part ldb retarget 
acquiring process context may require unfamiliar assembly language supporting procedure call requires detailed knowledge calling sequence undocumented surprises need swap words floating point registers big endian mips real problem 
keeping nub small surprises 
nub support procedure call assumes positions arguments types determine registers arguments passed 
mips violates assumption arguments floating point types case register assignment determined type position 
registers arguments passed affected 
violation accounts extra retargeting effort required support procedure call mips 
machine calling sequence assignment arguments registers depended positions types arguments retargeting nub complex 
debugger code depends data structure defined nub necessary specify structure process context program counter heavy pointer generalpurpose registers recovered context 
shown specifications just lines 
specification context generated automatically nub symbol table 
alternative reduces debugger dependence nub data structures provide abstraction giving access registers way independent data structures adams muchnick 
extra layer abstraction sense ldb nub purpose support debugging reason debugger independent data structures 
trade retargeting effort functionality 
retargeting effort ldb provide support machine level debugging 
code needed implement general breakpoints provides instruction level single stepping 
implemented extra 
discussion effort needed provide symbolic disassembly low 
supporting compilers requires retargeting effort 
programs contained procedures compiled lcc code reads mips run time procedure table eliminated code recovers register save information vax sparc 
difficult recompile library code extra retargeting effort required compiler justified necessary 
debuggers ldb retargeted handle variety executable file debugging symbol formats 
implementors xerox parc debugger dec debugger indicated handling different formats required substantial implementation effort 
ups gdb devote roughly source code formats 
lines ups source conditionally compiled code reads symbol tables 
gdb devotes lines debugging symbol formats sunos lines corresponding executable file formats 
ldb single machineindependent symbol table format eliminates kind retargeting effort making symbol table cheapest fastest part ldb retarget 
cheapest fastest reliable parts computer system aren 
gordon bell bentley page chapter 
retargeting ldb chapter evaluation single insight easy implement debugger success determined cumulative effect engineering decisions 
chapter reviews decisions judge 
unusual decision basing debugger postscript worth exploring 
retargeting cost affected decisions just implement implement decisions compatibility 
engineering purpose produce artifacts 
way judge ldb works artifact compare dbx gdb nearest competitors 
research project experiment 
experiment ldb uncovers problems experiments address discussed 
lessons learned building ldb applied 
chapter suggests techniques ldb affect debuggers related tools closes short list imperatives implementors 
postscript handling variety machine dependent formats debugging information imposes substantial retargeting costs debuggers dbx gdb 
formats variations dbx original format 
reason variations extensions required support new programming languages format name type constructors languages debugger supports 
target debugger associate names machine dependent information representations types 
postscript ldb eliminates retargeting costs associated debugging information 
obvious benefit postscript represent debugging information single machine independent format 
postscript promotes retargetability obvious way 
chapter 
evaluation providing extensible representations symbols types including procedures data eliminates need identify types name 
isolates ldb machine dependent information needed evaluate expressions print values compiler representation symbols types machine representation source level data 
information emitted compiler stored debugger 
example ldb need know sizes alignments basic types target 
ldb simplified uses information indirectly interpreting postscript 
compiler expression evaluation server simplified mutually convenient representation information 
format debugger need extended accommodate new programming language postscript procedures dictionaries provide necessary extensibility 
postscript easy read understand change data code manipulated standard text editor 
properties invaluable ldb development representation symbols types changed frequently example proposed change editor tested compiler changed emit new representation 
similarly useful development expression evaluation server 
postscript server emits assembly language see section especially figures debugging server debugging compiler emits assembly language debugging compiler emits object code 
server print output screen send ldb server output debugged picking pieces postscript mouse interpreting 
postscript symbol tables impose substantial performance cost ldb 
aside extensibility dictionaries postscript poor data format 
executed sequentially requires lexical analysis voluminous 
compression reduce volume standard binary encoding reduces volume eliminates lexical analysis adobe section technique removes limitation sequential access 
performance improved representing debugging information compactly encoded form designed incremental reading random access 
postscript values atomic elements data structure retain advantages postscript readability 
proposed chapter possible current readable slow representation ldb moved new compiler machine switch fast representation retargeting complete 
ldb implementation postscript provide programmability applications 
attraction low cost adding types operators typically lines overhead operator chapter 
cost low type checking code generated compact specifications interpreter compiled 
postscript basis loosely integrated environment tools just compiler debugger communicate sending postscript evaluated remotely 

strengths useful debugger send editor command displays particular source location example 
similar role proposed tcl ousterhout tcl data type string 
tcl awkward quoting conventions dual roles programming language interactive command language 
postscript richer set types postfix syntax easy programs generate 
tcl advantage syntax shell making comfortable interactive command language 
strengths ldb engineering effort devoted pushing machine dependence small corners system 
machine dependent subproblem sufficiently small isolated standard techniques solve 
printing values expression evaluation op breakpoints stack walking machine independent manipulation machine dependent data 
breakpoints generation machine dependent code compact specifications 
debug nub stack walking small sets machine dependent procedures macros methods 
memories provide simple universal model target memory registers usable debugger 
memories provide means uniform treatment target variables located registers memory 
associating memory procedure possible simple postscript code emitted compiler memory represents state machine particular procedure active 
modest machine dependent support memories describe core files running processes 
symbolic disassembly breakpoints unrelated problems share subproblem computing follow sets finding inline successor instruction finding target branch 
follow sets implement instruction level single stepping 
subproblem machine dependent part ldb follow set breakpoint implementation 
symbolic disassembly second machine dependent subproblem computing textual representations instructions 
ldb solutions problems rely compact specifications instruction sets mips specification appendix follow set breakpoints implemented symbolic disassembly instruction level single stepping added low cost respectively 
ldb gets leverage compiler 
re lcc expression evaluation server saves substantial implementation effort debugger provides greater confidence debugger compiler implement language 
support re compiler support re creation symbols modified translate expressions postscript 
lcc code re creates symbols similar code handles extern symbols 
languages separate compilation code analogous code imports symbols compilation units 
compilers generate different machine assembly codes chapter 
evaluation single intermediate form adding postscript pose problems 
single target compilers able generate postscript trees dags quadruples intermediate forms 
ldb gets leverage compiler debug nub support procedure call 
debugger reproduce compiler actions setting arguments calling procedure compiler generates code links target address space nub 
debugger job reduced accumulating arguments argument build area done postscript expression server emits 
retargeting simplified machine dependent aspects procedure call handled automatically compiling nub right machine dependent compiler aspects concern argument placement handled lines machine dependent code 
ldb ability change architectures dynamically unforeseen benefits 
simplifies configuration target architecture chosen ldb built instance ldb host host target pair 
ldb debugging necessary build debugger host 
tools architectures chosen build time possible small machine dependent changes conditional compilation 
great discipline exercised changes proliferate making difficult identify machine dependent parts program 
changing architectures dynamically means code data architectures imposing discipline easier identify isolate machine dependent code 
weaknesses mistakes ldb design 
planned replace ldb user interface graphical user interface programmable command language combination 
simplify replacement limited user interface access rest debugger 
mistakenly gathering user interface needed know rest debugger single modula interface target 
compounded mistake hiding information possible revealing information user interface needed 
results large unwieldy target procedures call procedures interfaces unnecessary subtypes 
subtypes led extra layers abstractions example top layer stack frame abstraction shown page 
improvement changing user interface depend debugger interfaces just target helped eliminate redundant code 
similar problems remain code user interface calls plant breakpoints 
identified structure enable ldb change user interfaces smoothly 
clear example hiding information user interface serves purpose 

comparison dbx gdb ldb provides useful information programs containing procedures compiled lcc 
mips sparc provides instruction single stepping symbolic disassembly useful procedures outside nub compiled lcc 
words ldb machine level debugger 
mistake planned machine level debugging mistake affected user interface entire design 
user interface poor support examining machine level data best user dereferencing integers cast pointers 
design separate machine level debugging source level debugging making impossible estimate cost source level debugging try approaches 
redesign separate source machine levels possible build version ldb source level features 
results chapters show existing compiler support ldb modest changes expert compiler needed 
flaw lcc support code emits postscript symbol tables parts useful compiler separated parts useful lcc 
flaw generating postscript slows compiler 
compiler existing interface symbol table generation mixed benefit 
fewer changes compiler difficult identify alternative interfaces compiler simplify implementation offer better performance 
ldb stack walking code assumes process context located target data space 
design complicates access context offset data space passed stack walking methods 
better design allocate separate memory space hold process context 
existing nub design require new kind memory map new space part data space 
nub support moved user space kernel process context better kept kernel data structures user space 
proposed design easily adapt change current design 
comparison dbx gdb ldb practical debugger competitive dbx gdb 
debugging programs lines including lcc expression server experimental linker fernandez fraser hanson 
debug 
features users best abilities connect running process continue debugging process debugger fails chapter 
features new ldb dbx gdb provide 
ldb omits features dbx gdb including printing source code debugging core files temporary breakpoints stepping function calls support signals 
chapter 
evaluation easy argue favor features ldb primary objective provide basic debugging retargetable way 
feature users source code display debuggers successful implementing display 
ldb performance worse dbx gdb primarily reading postscript symbol tables slow 
described section ldb takes seconds start programs lines 
debugging delays seconds occur new compilation units lines touched 
logged slowest commands debugging sessions 
sessions commands took longer seconds execute 
averaging sessions commands took tenth second 
averaging long sessions commands issued commands took tenth second 
ldb interacts target processes speed dbx gdb 
described section ldb breakpoint implementation faster gdb debug child process 
ldb peer process machine performance gdb debugging child process 
ldb process different machine twice slow gdb debugging child process 
dbx breakpoint performance difficult measure directly indirect measurements suggest gdb 
implementing conditional breakpoints ldb loses relative advantage expression server effort minimize interactions debug nub 
ldb conditional breakpoints slower dbx gdb debug child processes 
ldb reliable dbx gdb 
dbx resolves names elaborate lookup scheme involves static scope call stack local variables compilation units linton page 
purpose scheme possible examine variables ordinarily visible version supplied ultrix errors common fail identify active local variables 
user asks dbx plant breakpoint procedure dbx plants location determined 
error occurs user run nm find address procedure dbx command plant breakpoint address 
user calls procedure ldb procedure faults ldb debug fault recover dbx recover gdb debug fault 
ldb user recover debugger errors starting new debugger 
ldb greatest advantages lie implementation provides small retargetable basis debugging 
retargetability implies just tool works target effort needed retarget tool effort needed rewrite 
retargetable implementation separates machine dependent machine independent parts 
identifying machine dependent parts possible apply techniques reduce retargeting effort generating code compact specifications 
separating parts code new target introduce bugs affecting targets 
gdb machine dependent parts 
compatibility retargeting costs impossible identify precisely support targets uses machine dependent modules totalling lines average lines target 
ldb uses lines specifications modula implement instruction decoding lines modula postscript implement machine dependent functions uses lines total mips sparc machines parts implemented 
compatibility retargeting costs tool useful compatible existing systems compatibility introduce unnecessary retargeting effort 
drawback compatibility implements solution studying problem solved 
ldb compatible existing systems compatibility judged valuable requires modest retargeting effort 
criterion rules debugging information generated standard compilers linkers 
conversations implementors debuggers corroborated examination gdb ups suggest substantial retargeting effort expended coping multiplicity executable file symbol table formats 
postscript machines 
ldb incompatible existing operating system support debugging retargeting effort involved problem worth studying 
judged necessary ldb compatible existing calling sequences users debug code linked existing libraries 
primary criterion compatibility ldb give accurate incomplete information procedure call stack postscript debugging information available active procedures 
particular able walk past procedures unable restore registers saved procedures 
common find procedures stack library procedures compiled lcc 
meeting criterion requires extra retargeting effort mips ldb needs lines machine dependent code find frame sizes procedures compiled lcc 
lines needed frame sizes stored memory procedures register save masks vax 
assembler place sizes code adding cost call 
ldb fully compatible existing calling sequences procedure calls atomic vax 
described chapter procedure called steps change program counter allocate stack frame save registers 
dbx ldb gives wrong answers target stops intermediate state steps program counter changed registers saved 
stops rare occur program interrupted branches invalid address user mistake instruction level single stepping 
retargeting costs identifying steps high 
debugger scan machine code determine function prolog epilog stack frame created chapter 
evaluation registers saved 
calling sequences poorly documented difficult determine instruction sequences constitute legal identify steps 
instruction scheduling complicates problem example mips assembler may move instructions body procedure entry sequence 
best movement difficult identify steps 
worst introduce new intermediate states values preserved registers stack values stack 
difficult estimate retargeting effort required handle intermediate states procedure calls 
scanning machine code presupposes instruction decoding kind implement follow sets disassembly mips sparc 
expect intellectual effort required greater required implement follow sets disassembly expect code required disassembly 
reasonable solution problem intermediate states procedure calls restrict calling sequences instruction scheduling easy identify steps digital 
restrictions need adverse impact performance 
retargeting cost reduced having compilers emit labels identifying steps 
implementation follow strategy ldb uses register save information 
represent information machineindependent form compiler provide possible 
compiler provide machine dependent method procedure get information machinedependent way scanning machine code translate information obtained machine independent form compiler provided 
technique isolates necessarily machine dependent code gets information separating possibly machine independent code uses information 
unusual retargeting costs unreasonable due poor specifications 
example extra cost supporting procedure call mips inherent calling sequence registers arguments passed depend positions arguments types 
arrangement speeds procedures pass floating point arguments reduces movement floating point integer registers 
purpose justifies modest extra effort required debugger 
luckily calling sequence permits argument passed integer floating point register nub supporting code complicated 
different retargeting costs associated different instruction sets 
specification sparc instruction set longer mips sparc instruction set regular formats 
comparison vax awaits extension ldb specification language better handle instructions vary size 
complexity instruction set determines difficulty implementing breakpoints 
discussed chapter instruction set specification needed settles breakpoints stopping points 
cost implementing follow set breakpoints high relative cost implementing 
recommendations ldb machine dependent parts low absolute terms lines specification modula 
machines provide hardware support single stepping results suggest hardware assistance debugging better solve problems implementing intel section 
recommendations designers language run time environments operating systems implementing retargeting debuggers easier 
better specifications calling sequences needed 
specification calling sequence describe frames appear stack including bottom frame interrupt frames contain machine state delivery signal linton 
argued specification restrict entry exit sequences easy identify intermediate steps calling procedure 
operating system level ldb confirms treating debugging remote debugging practical efficient operating system mediate interactions debugger target redell 
techniques efficient running debugger target address space 
ldb suggests implementing procedure call user space target process debugger reduces retargeting effort 
duplicate implementation traditional system kernel provides debugging support require mechanisms deliver signals target process nub call function playing role signal handler 
ldb targets operating system give signal handlers access entire state machine 
operating systems save state user space accessible signal handlers 
identify technical reason 
access simplify ldb debug nub applications need state user level threads cormack 
addition postscript interpreter techniques ldb applications debugging 
interpreter profit compact specifications generate code performs run time type limit checks 
ldb support fast lexical analysis standard unsafe techniques available safe way modula 
instruction decoding encoding closely related ldb instruction specification language useful writing assemblers disassemblers 
techniques choose target architecture dynamically particularly machine dependent subtypes machine independent types retargetable tools 
chapter 
evaluation ldb implements basic debugging retargetable way 
basis improving way debugging done 
improvements proposed debugging considered part ldb user interface including direct manipulation interfaces russell programmability support events olsson crawford ho 
ldb designed debug process simultaneously current user interface manipulate time 
single threaded operating system network connections manipulate target processes advantages multi process debugger facilities exist reading set connections 
program computes different answers run different machines possible run versions control single debugger asking debugger run parallel states diverge 
means versions program presence conditional compilation research question 
instruction cycle level simulators study problems architecture larus rogers li process debugger execute program versions simulator simulator hardware explore differences executions 
ldb debug distributed applications file systems run networks heterogeneous computers 
events basis debugging distributed sequential programs bates wileden olsson crawford ho 
described chapter ldb uses event matching mechanisms translates machine dependent events machine independent events handles machine independent events 
ldb breakpoint commands easily implemented low level breakpoints plus machine independent event mechanism 
problem event mechanism available user level example way user arrange values certain expressions printed time particular breakpoint occurs 
similarly way users single step instructions new procedure called 
commands implemented existing mechanism wise general mechanism available sophisticated users consensus standard set breakpoint facilities 
ldb supports programming language ansi compiler lcc 
appears results chapters repeated language compiler soon tell 
unresolved question manage name spaces different particularly languages support overloading 
support multiple languages simultaneously difficult 
debuggers require user choose language identify symbols belonging particular language linton 
procedures may belong language time example procedure written high level language compiled modula 
implementors languages benefit debugger providing 
view procedures example high level view view machine language view 
graphical debugger useful overload certain commands different meanings depending view example show assembly high level source depending view vary size single step depending view 
previous dramatic improvements efficiency basic debugging operations putting target debugger address space 
code patching implementations breakpoints times faster requiring operating system intervention 
conditional breakpoints efficient generating patching machine code evaluates conditions 
latency reduced offloading debugging separate processor address space 
techniques widely benefit retargetability study analogous ldb study commonly techniques 
questions language operating system support debugging ldb leaves unexplored 
area exciting offers opportunity expand basic functionality debuggers provide 
different computer systems provide features data memory protection multiple threads signals exceptions 
features provided hardware kernel software user software language run time system combination 
ambitious retargetable debugger take advantage features available cope gracefully unavailable 
example debugger possible switch threads multithreaded program learn threads hold locks display waits relation 
language exceptions debugger cooperate run time system get control just particular exception handled letting run time system identify handler 
problems solved include identifying facilities implementors threads exceptions provide support debugging showing debugger structured take advantage facilities 
features mentioned pose similar problems 
support features require extensions ldb protocol problem construct protocol admits subsets 
chapter 
evaluation experience implementing ldb suggests engineering techniques deserve re implementors debuggers 
section casts techniques set imperatives 
standard machine independent format debugging information 
format extended new languages build extensibility format 
simplify design starting basic format containing language dependent information providing procedures print values 
extend hold machine dependent language dependent information needed procedures extend hold information needed expression evaluation 
design incremental input 
find way eliminate duplication arises including header files multiple compilation units 
get compiler possible 
knows data structures represented evaluate expressions re implementing features debugger wastes effort 
leverage compiler having include machine dependent information debugging output force debugger infer machine dependent information sizes alignments names types 
get compilers provide register save information machine dependent debugger code eliminated 
expression evaluation leverage compiler having debugger implement language looks compiler intermediate code 
language debugger implements manipulate abstraction resembles hardware memory 
run time support debugger implement procedure call simulating compiler actions calling procedure get compiler generate code needed 
closely design language run time system 
careful specification calling sequences easy implement stack walking debugging exception handling context switching user level threads nonlocal goto longjmp 
poor specification difficult 
operating system puts frames stack signals interrupts sure frames conform specification 
limit debugger debugging child processes 
encourage operating system designers provide support remote cross architecture debugging network protocol fixed byte order 
support available operating system consider user code ldb nub serve 
suggestions applicable programs 
carry information hiding extremes 
generate run time checking code machine dependent code compact specifications 
represent machine dependent information machine independent form create opportunities machine independent code separating gathering information 
write programs handle multiple targets simultaneously call machine dependent procedures conditional compilation 
conditional compilation avoided macros machine independent meanings machine dependent definitions better programs conditional compilation directives 
adams evan steven muchnick 
july 
window symbolic debugger sun workstations 
software practice experience 
adobe systems incorporated 

postscript language manual 
reading ma addison wesley 
adobe systems incorporated 

postscript language manual 
second edition 
reading ma addison wesley 
american national standard institute 
american national standards information systems programming language ansi 
new york 
appel andrew february 
simple generational garbage collection fast allocation 
software practice experience 

runtime system 
lisp symbolic computation 

compiling continuations 
cambridge cambridge university press 
ilya greg schaffer 
may 
efficient debugging primitives multiprocessors 
proceedings third international conference architectural support programming languages operating systems special issue sigplan notices 
balzer robert 
extendable debugging monitoring system 
afips proceedings spring joint computer conference pages arlington va afips press 
bates peter jack wileden 
december 
high level debugging distributed systems behavioral abstraction approach 
journal systems software 
marianne david macqueen 
december 
tree pattern matching ml extended 
unpublished manuscript bell laboratories 
bert 
august 
vax debug interactive symbolic multilingual debugger 
proceedings acm sigsoft sigplan software engineering symposium high level debugging sigplan notices 
bentley jon 

programming pearls coder 
reading ma addison wesley 
birrell andrew 
programming threads 
nelson greg editor systems programming modula chapter pages 
englewood cliffs nj prentice hall 
brooks gary gilbert hansen steve simmons 
july 
new approach debugging optimized code 
acm sigplan conference programming language design implementation sigplan notices 
bernd 
september 
adaptability portability symbolic debuggers 
phd thesis carnegie mellon university 
thomas august 
debugger 
proceedings acm sigsoft sigplan software engineering symposium high level debugging sigplan notices 
january 
feel pi 
proceedings winter usenix conference pages denver deborah david black 
january 
implementing mach debugger multithreaded applications 
proceedings winter usenix conference pages washington dc 
chow fred john hennessy 
october 
priority coloring approach register allocation 
acm transactions programming languages systems 
clinger william jonathan rees 
july september 
revised report algorithmic language scheme 
lisp pointers iv 
clinger william june 
read floating point numbers accurately 
proceedings sigplan conference programming language design implementation sigplan notices 
cormack gordon may 
micro kernel concurrency software practice experience 
crawford richard ronald olsson wilson ho christopher wee 
april 
semantic issues design languages debugging 
proceedings international conference computer languages pages oakland ca 
detreville john 
march 
designing modula debugger 
unpublished manuscript dec systems research center 
digital equipment 

dynamic debugging technique 
maynard ma 
digital equipment 
october 
open vms calling standard 
order number aa tk 
maynard ma 
ellis margaret bjarne stroustrup 

annotated manual 
reading ma addison wesley 
feldman stuart brown 
may 
igor system program debugging reversible execution 
proceedings acm sigplan sigops workshop parallel distributed debugging sigplan notices 
fernandez mary christopher fraser david hanson 
november 
retargetable link time code generation 
unpublished manuscript department computer science princeton university 
fraser christopher david hanson 
april 
machine independent linker 
software practice experience 
september 
code generation interface ansi software practice experience 
october 
retargetable compiler ansi sigplan notices 
january 
simple register spilling retargetable compiler 
software practice experience 
fritzson peter 
december 
symbolic debugging incremental compilation integrated environment 
journal systems software 
michael david hanson 
january 
duel high level debugging language 
proceedings winter usenix conference pages san diego ca 
michael december 
flight recorder architectural aid system monitoring 
proceedings acm onr workshop parallel distributed debugging sigplan notices 
gramlich wayne august 
debugging methodology session summary 
proceedings acm sigsoft sigplan software engineering symposium high level debugging sigplan notices 
griswold ralph griswold 

icon programming language 
second edition 
englewood cliffs nj prentice hall 
hennessy john july 
symbolic debugging optimized code 
acm transactions programming languages systems 
holzmann gerard 
design validation computer protocols 
englewood cliffs nj prentice hall 
intel 
april 
data sheet 
santa clara ca 
kalsow bill eric muller 
june 
src modula 
dec systems research center 
version 
available anonymous ftp internet host gatekeeper dec com 
kane gerry 

mips risc architecture 
englewood cliffs nj prentice hall 
kessler peter june 
fast breakpoints design implementation 
proceedings acm sigplan conference programming language design implementation sigplan notices 
killian 
processes files 
proceedings summer usenix conference pages salt lake city 
knuth donald 
art computer programming 
volume fundamental algorithms 
second edition 
reading ma addison wesley 
lampson butler david redell 
february 
experience processes monitors mesa 
communications acm 
larus james september 
mips simulator 
technical report computer sciences department university wisconsin madison wi 
david robert chase may 
computer aided software engineering distributed workstation environment 
proceedings acm sigsoft sigplan symposium practical software development environments sigplan notices 
linton mark june 
evolution dbx 
proceedings summer usenix conference pages anaheim ca 
liskov barbara alan snyder 
november 
exception handling clu 
ieee transactions software engineering se 
miller barton thomas leblanc editors 
may 
acm sigplan sigops workshop parallel distributed debugging 
available sigplan notices january 
miller barton charles mcdowell editors 
may 
acm onr workshop parallel distributed debugging 
available sigplan notices december 
mips computer systems 
may 
mips assembly language programmer guide 
mountain view ca 
moore 
forth new way program mini computer 


suppl 
myers brad allan 
june 
displaying data structures interactive debugging 
technical report csl xerox parc palo alto ca 
nelson greg editor 

systems programming modula 
englewood cliffs nj prentice hall 
olsson ronald richard crawford wilson ho 
february 
dataflow approach event debugging 
software practice experience 
oppen derek october 

acm programming languages systems 
ousterhout john january 
tcl embeddable command language 
proceedings winter usenix conference pages washington dc 
pike rob dave presotto ken thompson howard trickey phil 
september name spaces plan 
sigops european workshop distributed systems mont saint michel 
ramsey norman david hanson 
july 
retargetable debugger 
acm sigplan conference programming language design implementation sigplan notices 
ramsey norman 
august 
literate programming tools need complex 
technical report cs tr department computer science princeton university 
submitted ieee software 
redell david dalal thomas hugh lauer william lynch paul mcjones hal murray stephen purcell 
february 
pilot operating system personal computer 
communications acm 
redell david january 
experience topaz 
proceedings acm sigplan sigops workshop parallel distributed debugging sigplan notices 
rogers anne kai li 
september 
software support speculative loads 
proceedings fifth international conference architectural support programming languages operating systems sigplan notices 
russell mark 

ups 
ups graphical source level debugger available anonymous ftp host unix ac uk misc unix ups ups tar author email address mtr ac uk 
silicon graphics 
graphics library programming guide 
document number 
mountain view ca 
stallman richard roland pesch 

gdb guide gnu source level debugger gdb version 
technical report free software foundation cambridge ma 
steele guy jon white 
june 
print floating point numbers accurately 
proceedings sigplan conference programming language design implementation sigplan notices 
sun microsystems 

network programming 
part number revision mountain view ca 
sun microsystems 
january 
unix programmer manual sun release section 
mountain view ca 
manual page ld describes shared libraries 
swinehart daniel 
zellweger richard beach robert 
hagmann 
october structural view cedar programming environment 
acm transactions programming languages systems 
tolmach andrew andrew appel 
june 
debugging standard ml reverse engineering 
acm conference lisp functional programming pages nice france 
department defense 

ada programming language manual 
government printing office 
ansi 
wahbe robert 
september 
efficient data breakpoints 
proceedings fifth international conference architectural support programming languages operating systems sigplan notices 
waite william may 
cost lexical analysis 
software practice experience 
wall david 
experience software defined machine architecture 
acm transactions programming languages systems 
weiser mark alan demers carl hauser 
december 
portable common runtime approach interoperability 
proceedings th symposium operating systems principles operating systems review 
welch terry june 
technique high performance data compression 
ieee computer 
wu sun udi manber 
october 
fast text searching allowing errors 
communications acm 
zellweger 
interactive source level debugging optimized programs 
phd thesis university california berkeley 
available xerox parc csl technical report 
larry ralph johnson 
april 
debugging optimized code expected behavior 
unpublished manuscript 
available anonymous ftp st cs uiuc edu pub papers 
appendix formal model breakpoints appendix provides formal model ldb follow set breakpoints 
model takes form promela program holzmann 
promela programs define threads control communicate passing messages 
thread control runs program written guarded command language syntax 
programs may nondeterministic 
promela simulate execution program search state space states violating assertions embedded program 
simulator searches states successors deadlocks 
promela code appendix models ldb implementation breakpoints 
ldb multithreaded programs model uses multiple threads procedure call ldb target process effectively creates new thread 
assertions embedded model specify debugger takes breakpoint action just thread successful execution instruction breakpoint 
breakpoints may implemented operating system debugger choice affect model 
model assumes plant trap instructions instruction stream target program notified target program encounters trap 
model suits machine trace mode causes trap execution instruction 
model single breakpoint 
keep state space small model threads single bit represent thread ids 
ij define define threadid bit appendix formal model breakpoints page number definition appears 
modeling program counter execution keep things simple partition possible values program counter sets break breakpoint follow instruction breakpoint outside outside breakpoint 
sets modeled constants 
define define break pc breakpoint define follow pc breakpoint follow set define outside pc ability plant traps modeled array trapped records trap instruction stored particular location bool trapped model active components threads cpu executes thread time breakpoint rest debugger 
channels communication threads cpu breakpoint debugger 
breakpoint action modeled sending message channel 
chan execute bit try execute instruction chan cont bit instruction executed chan trap byte cpu trapped id chan resume bit debugger resumed trap chan byte deliver breakpoint debugger 
modeling program counter execution indicates channels synchronous senders block receiver ready vice versa 
communication structure oe hj hy phi phi phi phi phi phi phi phi phi phi phi phi debugger breakpoint cpu thread thread execute cont cont execute resume trap id id cpu repeats steps 

wait thread attempt execute instruction pc 

instruction trap notify debugger 
debugger tells cpu resume pc unchanged 

instruction trap advance pc 

ask thread continue executing 
debugger multiple threads pc communication cpu 
cpu notifies debugger trap identifies trapping thread 
messages synchronization send receive nonsense variable bit junk variable sending messages appendix formal model breakpoints proctype procedure thread execute models cpu 
receives value channel sends 
arrows 
separate guards commands 
aij proctype cpu byte count threadid id execute id 
trapped pc id 
trap id resume trapped pc id 
pc id bi fi cont id context switch change id bi od context switching discussed 
program counter abstraction advancing mean incrementing 
successful execution break guaranteed followed attempt execute follow aside instruction follow 
pc id bij pc id break 
pc id follow pc id break 
instruction pc id outside pc id break pc id follow fi fi second statement guards alternative chosen nondeterministically 
threads execution outside breakpoint 
byte pc data thread id dij pc id outside 
counting events counting events correctness criterion breakpoint implementation breakpoint action taken successful execution instruction break 
id counts times thread id executed breakpoint id counts breakpoint actions taken behalf thread id byte byte data thread id di id id model thread including assertion thread debugger counts ai proctype thread threadid id pc id break 
execute id cont id hif successfully executed break increment id ai pc id break 
execute id cont id fi assert pc id outside id id od corresponding model debugger ai proctype debugger threadid id atomic id 
id ci od appendix formal model breakpoints atomic groups statements single atomic action 
debugger takes breakpoint action atomically increments id 
atomic delay incrementing counter invalidate assertion 
thread knows successfully executed break pc changed hif successfully executed break increment id aij pc id break 
id bi pc id break 
skip fi keep state space small restrict values counters range 
id bij id id id cij id id implementing breakpoint long tradition implementing breakpoints traps single stepping 
set breakpoint plant trap target program hits trap breakpoint event 
resume execution breakpoint restore original instruction single step machine execute just instruction plant trap continue execution 
machines single step mode hardware single stepping simulated software trap instructions 
model eliminate single stepping entirely working directly trap instructions follow set modeled follow 
simpler model preclude hardware single stepping 
operations model traps locations follow set instruction 
operation implemented computing follow set actual traps setting trace bit machine hardware single stepping 
active breakpoint trapped instruction breakpoint instruction follow set 
breakpoint keeps track state invariant 
break trapped break trapped follow follow trapped break trapped follow byte break 
implementing breakpoint aij trapped break changing state preserves invariant 
traps break bij atomic break trapped break trapped follow traps follow cij atomic follow trapped break trapped follow necessary keep track state thread respect breakpoint 
thread breakpoint trapped break leave breakpoint traps follow 
threads initially outside breakpoint 
bit data thread id di id appendix formal model breakpoints possible implementation just keeps track various states delivers breakpoint event right time breakpoint implementation ij proctype breakpoint threadid id trap id 
break 
id 
id id id 
skip event fi traps follow ci follow 
id 
id id 
skip fi traps break bi fi resume od 
implementing breakpoint implementation works fine single thread 
threads promela statespace search finds erroneous execution sequence attempted executions trap marked breakpoint debugger cpu thread thread outside break breakpoint traps follow resume context switch outside break follow traps break resume outside context switch follow outside execution sequence thread goes breakpoint triggering breakpoint action 
earlier version ldb sequence provoked executing procedure call user program hit breakpoint user program thread procedure call thread 
prevent occurrence cpu permitted change contexts thread middle breakpoint 
cpu change contexts noswitch breakpoint implementation works correctly 
ai proctype breakpoint threadid id trap id 
break 
id 
id id id 
assert fi noswitch noswitch traps follow ci appendix formal model breakpoints follow 
id 
id id 
assert fi noswitch noswitch traps break bi fi resume od ban context switching possible strengthen skip assert 
noswitch declared counter bit implementation generalizes multiple breakpoints 
byte noswitch cpu code context switching correctly context switch change id bij noswitch 
id randomly ci noswitch 
skip fi id randomly cij atomic id id fi 
completing model completing model boilerplate needed turn model complete promela specification aij ai init threadid id atomic ai id initialize data thread id bi run thread run thread run debugger run breakpoint run cpu id initialize data thread id bij id id 
data thread id di id 
break id 
id id fi od appendix formal model breakpoints appendix mips instruction specification follow set computation appendix demonstrates language ldb uses specify instruction decoding 
shows instruction specification follow set computation mips 
ldb uses specification implement symbolic disassembly 
ldb need disassemble instructions users look machine code 
instruction specification specification describes size instructions gives names fields instructions gives patterns match different instructions 
mips instructions bits wide spec ij names bindings ai specification divided cpu specification floating point coprocessor specification 
appendix mips instruction specification cpu instruction field specified giving range bit positions 
code debugger uses specification refer values fields name 
values unsigned sign extended values referred prepending extend name 
example refers sign extended value offset field 
mips fields listed page mips architecture manual kane apply couple instructions 
mips manual uses name field example offset base place immed rs describing load store instructions 
numbers specification numbers starting bit positions significant bit 
names ij fields word op rs rt immed offset base target rd funct cond 
instruction specification opcode special jal beq bne addi andi ori lui cop cop cop cop lb lh lwl lw lwr sb sh sw swr swc swc swc swc special sll srl sra jr syscall break mult div add addu sub xor slt operation codes marked cause reserved instruction exceptions reserved versions architecture 
opcode tables mips architecture manual 
pattern predicate word 
patterns described grammar pattern field value constrains field pattern pattern matches pattern pattern pattern matches patterns equality inequality field identifier naming field value integer 
names bound patterns patterns statement patterns fname sequence names enclosed square brackets bound sequence patterns 
sequence patterns specified single pattern value generator generator integer 
sequence literals integer integer columns integer generates sequence integers appendix mips instruction specification generators reduce sizes specifications look tables appear architecture manuals 
columns option generates integers sequence corresponds counting columns rectangular array rows 
numeric codes mips opcodes described tables page mips architecture manual 
tables reproduced 
normal opcodes bits appear op field instruction 
bindings aij patterns special jal beq bne addi andi ori lui cop cop cop cop lb lh lwl lw lwr sb sh sw swr swc swc swc swc op statement creates names patterns constraining op field 
op generates list patterns ranging op op 
pattern associated corresponding name list left colon 
patterns associated name discarded 
example word matches pattern op field 
statement names patterns opcodes table top 
opcodes special instructions 
instructions decoded checking bit pattern funct cond fields instructions respectively 
bindings ai sll srl sra jr syscall break mult div add addu sub xor slt special funct cond 
instruction specification statements create new patterns adding constraints existing patterns special 
rest patterns organize instructions classes done chapter mips manual 
immediate mode instructions grouped signed unsigned variants depending immediate operand sign extended 
instructions grouped assembly language syntax 
bindings ai patterns load lb lh lw lwl lwr sb sh sw swr addi andi ori arith add addu sub slt xor shift sll srl sra arith mult div jump jal jr branch branch beq bne swc swc swc swc pages mips manual introduce field names convenience specifying floating point instructions names fields ft fs fd format bit appendix mips instruction specification instruction codes coprocessor floating point page mips manual 
names add add fmt possible form full name instruction concatenating name opcode pattern name format 
bindings ai patterns add 
sub 
mul 
div 
abs 
mov 
neg 
cvt cvt cvt un eq ult ole ule sf seq lt nge le ngt cop funct bit specifying branch move instructions complicated relevant codes span entries table pattern language designed bind pattern entry 
introduce new fields simplify specification 
field names defined pattern bindings bindings 
bindings ai fields cop code patterns mfc mtc ctc cop cop code funct bc cop cop code cop code bc bc bc bc grouping assembly language syntax 
bindings ai patterns arith 
add 
div 
mul 
sub 
arith 
abs 
mov 
neg 
mfc mtc ctc cond un eq ult ole ule sf seq lt nge le ngt bc bc bc lsc swc convert cvt cvt cvt 
computing follow sets computing follow sets patterns programs writing pattern case statements form case value pattern 
action 
action esac statements may imbedded modula programs values actions written modula 
pattern transformer reads program pattern specification transforms valid modula program 
pattern case statement replaced nested case statements determine action taken 
pattern transformer uses heuristics keep number tests small macqueen describe similar heuristics 
patterns simplify follow set computation 
mips define extra patterns describe straight line code conditional branches patterns inline load lui shift arith arith syscall break arith 
arith 
convert cond lsc conditional branch branch bc computing follow sets requires cases 
show structure decoding details implementations case elided case memory pc memory type inline 
line codei beq rt rs 
branch bit displacement conditional 
jump 
branch bit displacement 
esac 
