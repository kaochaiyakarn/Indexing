physical type checking satish chandra thomas reps software production research dept computer sciences dept bell laboratories lucent technologies university wisconsin madison chandra research bell labs com reps cs wisc edu april appears bell laboratories technical report bl 
effectiveness traditional type checking limited presence type conversions type casts 
standard allows arbitrary type conversions pointer types compilers tools lint guarantee type safety presence type conversions 
particular casts involving pointers structures structs programmer interpret memory region desired type compromising weak type system 
type casts program vulnerable type errors hinder program comprehension maintenance creating latent dependencies seemingly independent pieces code 
address problems developed stronger form type checking programs called physical type checking 
physical type checking takes account layout struct fields memory 
describes inference physical type checking algorithm implementation 
algorithm perform static safety checks compute useful information software engineering applications 
pointer type cast pointer type 
programmer interpret region memory type 
traditional type checking enforce reinterpretation memory done meaningful way standard allows arbitrary type conversions pointer types 
reason compilers tools lint provide warnings potential runtime errors arising casts 
motivate problem type safety programs examples 
example 
consider code fragment 
cast colorpoint structure type point interpreted structure type colorpoint 
sole dereference pointer pcp program pcp program correctly field structures offset 
dereference pcp color cause unexpected behavior 
cc lint issues warning program 
overly conservative type checker disallow cast value type point colorpoint regardless field color dereferenced pcp 
unfortunately programs contain casts surprising frequency type checker disallows casts practice programs 
example 
consider code fragment 
code cast radio converts type clock type type type radio 
program declared unsafe conservative type checker rejects casts 
glance decision appears reasonable cast sense 
notice points field structure 
pointer arithmetic rules expression yields typedef struct int point typedef struct int color colorpoint main point colorpoint pcp pcp colorpoint pcp pcp color red program illustrate problem type casts 
dereference pcp color cause unexpected behavior program 
typedef struct int hour minute clock typedef struct double frequency radio typedef struct clock clock radio radio main cr clock radio cr clock radio frequency example casting idiom 
type rules expression type cast second statement clock radio 
radio follows clock struct cast safe 
address pointer second field 
pointer field correctly dereferenced frequency field done example 
program relies fact points region memory contains clock structure followed radio structure fact size clock padding required fields clock radio 
usage appears contrived frequently production code see 
examples show programmers implicitly rely physical layout structs memory 
type checking difficult type checker manifest types program conservative compiler permit potential run time errors go undetected 
casts heavily programs particularly systems software 
table presents empirical data suite programs 
program kloc void struct struct struct gcc telephone bash vortex ijpeg perl total table count casts suite programs spec benchmarks gcc ijpeg perl vortex gnu utilities bash networking code portions lucent technologies product code telephone 
kloc number source lines thousands 
void struct column gives total number casts void converted pointer struct vice versa struct struct column gives number casts types involved pointers structs 
numbers include implicit explicit casts 
physical type checking develop new form type checking programs called physical type checking physical layout structs memory 
goal physical type checking provide static safety checks pointer dereferences program 
program passes static safety checks declared physically type safe 
example type checking algorithm declare program unsafe actual type point field color required dereference pcp color 
program contain statement pcp color red algorithm declare program type safe requirements structure pcp satisfied actual type 
second example algorithm declare program type safe requirements structure cr satisfied actual type 
physical type checking carried flow insensitive context insensitive interprocedural analysis algorithm 
terms analysis relates previous significant aspects follows ffl physical type checking algorithm cast type inference problem part analysis ignores declared types program relies inference compute required type variable program address taken 
years number papers type inference mechanism specifying flow insensitive analyses see section 
ffl similarities physical type checking algorithm previous flow insensitive points analysis ste sh 
relationship physical type checking points analysis addressed section 
physical type checking useful number purposes 
obvious application discover potential physical type errors caused inconsistent type interpretations memory 
just tool lclint eva statically identifies certain classes errors programs physical type checking detects class errors traditional type checking misses 
physical type checking number applications software engineering tools information obtained help programmer understand ways type casts programs uncover hidden dependences different types retrofit stringent type declarations variables function arguments 
ground array type size ptr pointer sfm struct jg union member labeled type offset bit field labeled size offset ground id enum void char unsigned char short int long double 
slightly simplified type system type qualifiers ignored const int volatile int treated int 
furthermore typedefs considered synonyms types redefine 
contributions starting point observation programs type casts require type checking powerful standard type checking system variables declared types 
contributions categorized follows ffl formulate alternative type system physical layout structs memory 
ffl give inference algorithm perform type checking programs 
describe implementation algorithm uses shelf constraint solver 
ffl previous introduced notion physical subtyping struct types 
handle pointer fields inside structures 
introduce way handle subtyping presence pointer fields 
outline remainder organized follows section reviews ideas previous draw sections 
section presents basic approach physical type checking algorithm describes certain problems pointers hinder approach 
section presents actual algorithm shows solves problems 
describe implementation section 
section discusses related 
preliminaries section define mean physical type safety review notion physical subtyping introduced 
addresses slightly simplified version ansi type system shown 
members bit fields struct union types annotated offset 
struct offset member indicates difference bytes storage location member member struct 
member definition offset 
union members offset 
computation offsets compiler dependent follow number requirements set ansi standard 
particular compilers lay compatible prefixes structures identically 
discuss data layout issue appendix useful define number auxiliary functions type ffl stype compiler assigned type expression ffl sizeof standard sizeof function ffl offset offset field struct union type assume statements input program normalized consist simple forms shown table 
purpose normalization limit number cases analysis consider 
procedure convert program normal form may need introduce temporary address assignment cast opt pointer dereference rhs pointer dereference lhs field dereference lhs field dereference rhs field address plus arithmetic op table statements normal form 
variables 
assume assignment statements copy values ground types struct copies transformed element wise copies 
notice cast may appear assignment statement normal form 
casts needed want normalized program legal program respects casts significance physical typechecking algorithm 
declared types variables compute appropriate offset corresponding field dereference 
table shows normalization sample statements 
tmp tmp tmp tmp tmp tmp table examples normalization 
physical type safety semantics formally specified state precisely mean physical type safety context programs 
provide intuitive notion safety requirements pointer dereferences leaving formal characterization appendix 
appendix describes runtime notion physical type safety corresponds intuitive safety requirements 
intuitively physically type safe pointer dereference point valid memory refer valid type 
valid memory mean address computed load specified transformation fully simulate call memcpy may necessary introduce manufactured field names stand holes introduced padding 
field memory bounds allocation unit pointer currently points 
stack allocated variable constitutes allocation unit chunk memory returned malloc 
valid type mean ground type referred stored memory location 
example previous section dereference color pcp physically type safe field color lies outside valid memory point variable 
suppose cast pointer struct int float consider dereference field unsafe ground type referred float match type stored memory location int address field lie allocation unit refers valid memory 
note physical type safety guarantee absence runtime errors 
example says errors related management heap storage bounds array 
physical subtyping cast free program type checks unions inconsistently physically type safe 
programmers find useful casts motivated find alternative conditions physical type safety guaranteed 
key concept defining conditions physical subtyping 
idea physical subtyping value type may operated type memory layout types values stored corresponding locations sense 
consider code point pt colorpoint cp pt pt cp pt pt red picture pt cp represented memory look pt cp red cp thought type pt simply ignoring field 
write denote physical subtype type intuition physical subtypes summarized follows ffl size type larger size subtypes 
ffl ground types physical subtypes ground types 
example int int enumerated type physical subtype different enumerated type ground type ffl struct type physical subtype struct type members types line sensible fashion 
matching struct types allow number relaxations example flattening struct types renaming member labels 
reflexivity void pointers ptr void members fm structures fm fm member subtype inference rules physical subtypes 
presents rules inferring type physical subtype type denoted style gun 
rule structures attempts match structure prefix structure 
rule show relaxations allow matching struct types 
note rule physical subtyping involves comparing union types 
unions determining branch union active orthogonal problem 
note rule comparing pointer types consider pointer type physical subtype void 
report subtyping rules explain patterns cast usage programs 
physical type checking type checking algorithm works performing backwards propagation type requirements program points memory address created bound pointer variable 
describe provide rationale new domain types type checking system 
describe main ideas physical type checking algorithm 
subsection essentially presents type checking algorithm works restricted subset programs 
describe difficulties face trying extend algorithm general programs 
section complete type checking algorithm works unrestricted programs 
motivation splitting presentation sections wish essence physical type checking somewhat simplified setting face full range complications pointers cause 
type obligations define domain type obligations follows ft type defined 
denotes null type obligation 
say type obligation pointer valued variable context provided rest program ffl occurs unconstrained value address union int double struct int struct double void struct struct shows examples single type guarantee physical type safety 
ffl ftg dereferences physically type safe points struct type physical subtype ffl ft single type guarantee dereferences physically type safe see ft ft type obligations type obligations express sufficient necessary conditions physical type safety 
systems constraints generate denote type obligation variable hpi 
intention find restrictive type obligation hpi satisfies system constraint 
introduce type obligations pointer sources 
syntactic occurrences pointer sources ffl address var ffl malloc call site ffl array arithmetic operation array 
multidimensional arrays yield pointer number subscripts declared arity 
constraint system type obligation denoted vi ai occurrence malloc particular program site define domain type obligations manner possible infer hpi single type pointer valued variable procedure procedure physically type safe 
happen reasons ffl unions introduce incompatible type requirements dereferences refer multiple interpretations union 
code fragment single type physical subtype int double guarantee type safety hui assigned type see discussion 
happen algorithm flow sensitive 
ffl flow insensitive nature inference algorithm give rise spurious type requirements 
second code fragment hpi physical subtype struct struct way time assigned 
type physical subtype struct struct may tempting infer union type restrictive type cases 
interpretation union types constituent types provides space store constituent types may hold type time 
example union fint double physical subtype int double know note analyzing unions treated consistent manner variant records orthogonal issue 
exist programs abuse unions type casting 
fields stored union 
contrast ft represents types sense represents type constituent type time 
fint physical subtype int double 
set form type obligations gives way recording information certain kinds inconsistent types helpful tool reports anomalous usages 
define binary relation type obligations captures fact type obligation type obligation right hand side term sufficient hpi left hand side term physical subtype right hand side term including types set 
relation properties ft ftg ft ft remainder usually skip surrounding curly braces mention singleton type relation 
inference physical type checking subsection describe intuition inference approach physical type checking 
description expressed simpler algorithm physical type checking works restricted subset programs full algorithm described section 
subsection assume program checked contain second level pointers 
second level pointers hold pointers variables may pointers variables struct variables may contain pointer member field 
type checking algorithm works steps 
infers restrictive type obligation pointer source type obligation greatest respect 
process inferring type obligations described section section 
second step algorithm performs type checking checks pointer sources satisfy type obligations 
pointer source satisfies type obligation cases hold 
hpi ftg static type variable associated pointer source physical subtype 
hpi ft static type fact physical subtype incomparable types 
case user information control flow determination physical type safety 
provide examples process section 
checking type obligations hold pointer sources program determine program physically type safe 
note perform checks actual points dereference type inference step propagates needs dereferences back pointer sources 
algorithm expository purposes concerned testing program qualifies restrictive algorithm 
possibility perform conservative points analysis program 
field dereference stype struct ptr hei pointer dereference stype ptr hei field address stype struct ptr hei concat hli plus stype ptr hei concat hli assignment hei hli address ei hli relation generation rules 
generating type constraints type inference procedure traverses syntax tree program generate set relations constraints type obligations 
generates set constraints rules 
hei terms appear unknowns set relations procedure solve terms described section 
relation generation procedure employs auxiliary functions constructing new types existing types 
struct type sfm gamma mn define sfm gamma sfm concat new new new new new new field label new appropriate offset 
function forms new struct type contains fields order including field function similar includes field function concat augments struct new field specified type new normally type obligation term hei second argument concat 
case concat results set types result mapping function defined constituent types type obligation argument 
rationale rules follows ffl field dereference type obligation struct space field right offset 
constructed type expresses exactly criterion 
note field contain pointer value 
ffl pointer dereference type obligation typeof constraints point valid ground type 
note contain pointer value 
may include unnamed holes introduced padding alignment restrictions may require 
explicitly mention holes examples 
struct int int struct int int int struct struct int int struct int example explain field address constraint generation rule 
struct right hand side constructed type constrains hpi 
see text details 
ffl field address rule propagates type obligation pointer middle structure back pointer top structure 
instance pointer middle structure points 
type obligation dereference struct int type obligation capture fact field offset offset struct satisfy type obligation constructed type shown right constrains hpi accordingly 
ffl plus arbitrary arithmetic algorithm declare type obligation divergent type 
algorithm takes special interest case track type obligation precisely 
rational rule field address case type obligation internal pointer structure propagated pointer points previous field structure 
note rule static type need pointer struct 
ffl assignment type obligation left hand side assignment propagated righthand side 
assignment rule propagates type obligations counter direction values flow execution 
sense analysis backwards analysis albeit flow insensitive propagates needs originating dereferences back pointer sources 
ffl address case similar assignment 
solving hei result constraint generation procedure set relations involving hei terms 
combine constraints arrive values hei terms 
transitivity resolution rules single relation involving hei term left hand side 
hei ft hei ft hei ft hei ft hei ft hei ft rules follow properties mentioned section eliminate types covered types physical subtyping related subtyping combine multi element set 
final right hand side value hei answer get hei 
side stepped certain details occurs check test constructed type terms 
implementation issues covered section 
examples inference type checking example 
consider code 
constraints generated statements program assignment rule statement field dereference statements pi struct fint xg struct fint transitivity obtain pi struct fint xg pi struct fint struct fint struct fint yg simplified constraint pi pi struct fint 
accordingly solution pi struct fint 
declared type point physical subtype pi program unsafe 
notice algorithm attach significance type cast cf 

example 
consider code 
normalize statement cr clock pcr cr pcr clock 
constraints generated statements cri concat clock clock hci hci concat clock hri hri struct constraint solution hri struct 
solution hci concat clock struct struct struct rg 
solution struct struct struct rg sg solution cri 
physical subtype constructed type program type checks 
example 
presents example code flow insensitive nature algorithm forces infer multi set types restrictive type obligations 
code fragment void variable hold time address point variable time address colorpoint variable 
hpi evaluates point point compared pt rpt forced announce possible 
aside prior running algorithm conversion single static assignment form performed program independent occurrences named differently algorithm declare program safe 
attractive feature inference type checking propagates information back source 
obvious advantage standpoint reverse engineering applications exactly ways struct variable program 
information refine type declarations procedure parameters 
pointer subtyping problem turn restrictions pointers placed program algorithm section 
suppose wish type check case member field structure pointer 
consider candidate rule pointer fields field names offsets implementation specific names unimportant 
symbolic names keep examples comprehensible 
clock clock null 
typedef struct float float point pt rpt void point pt rpt 
inferring multi element set type 
definition point 
pointer field dereference stype struct ptr hei concat hli ptr rationale rule type obligation hli requirements exist field appropriate offset type pointer valued field respect type obligation hli 
words pointing physical subtype structure field appropriate offset field contain pointer structure physical subtype hli 
difficulty rule obvious subtyping rule comparing struct ft struct ft related physical subtyping 
turn subtyping rule comparing ptr ptr 
suppose attempt remedy situation allowing pointer subtyping rule pointers ptr ptr example shows rule sound 
example 
consider code 
generate constraints pti hqi struct int common point concat cps ptr struct int color value colorpoint 
comes pointer field dereference rule struct int common colorpoint struct fint common point fact struct int common colorpoint physical subtype struct fint common point unsound pointer subtyping rule struct int common colorpoint cps physical subtype constructed type program type checks 
program unsafe accesses color field pt point 
intuitively pointer subtyping rule sound track indirect modifications 
typedef struct int common point ps typedef struct int common colorpoint cps ps psp cps cps point pt colorpoint cp main psp ps cps cps pt psp cp cp color red psp cp pt cps unsafe program 
definitions point colorpoint 
picture shows state just execution statement 
example just indirectly modified value assigning psp 
visibly assigned point pointer value able catch error 
incidentally void pointers rule sound void pointers dereferenced 
algorithm physical type checking section algorithm physical type checking works programs matter levels pointers 
algorithm follows pattern restrictive algorithm section generates set constraints involving type obligations uses final type obligations check pointer sources 
add new kind type obligation term constraint system different set rules generate constraints 
describe changes illustrate algorithm example 
compare algorithm points analysis 
type obligations revisited hpi type obligations far construction smallest ordered type safely read dereference get type obligation 
introduce complementary set type obligation 
set type obligation denoted largest type ordered restrictive type written pointer 
example illustrates idea 
example 
consider code fragment 
set type obligation pp colorpoint assign pp pp require particular constraint righthand side pointer value 
assignment indirectly modifies hqi colorpoint 
pp colorpoint 
intuitively set type obligation pointer variable represents get type obligations elements points set 
tracking set type obligation pointer variable addition get type point pp colorpoint main pp point pp color red example illustrate set type obligations 
obligation able deal problem pointer subtyping 
get type set type inference physical type checking expressed terms inference rules involve constraints unknowns form hpi 
note new rules generate constraints statements program infer new constraints previously generated constraints 
explain new items notation 
ffl ba stands base offset representation field structure type casting view structure type structure type field named belongs type accessed follow corresponding field exists type yong addressed issue symbolic representation fields positions 
adopted simpler non portable approach computing offset field structure 
notation ba stands offset bytes 
non zero offset field containing structure ba stands base new offset sum offset ba viz ba 
ffl stands offsets structure shorthand set relations rationale rules follows ffl address rule considers assignment address variable expression special case assignment 
links get obligation right hand side variable set obligation left hand side variable constraint hxi 
ffl assignment rule similar assignment rule propagates set type obligations forward direction 
set type obligations flow forwards originating address statements simple assignments indirect modification statements 
remaining rules parts case 
describe rationale second parts 
ffl pointer dereference consider case case analogous 
rule thought assignment variables point 
points variable hri generated directly inferred 
infer constraints generate assignment ffl field dereference consider case case analogous 
structure may point infer constraints generate assignment ba 
address xi hpi hxi assignment hqi hpi pointer dereference stype ptr hqi hri hri hpi pointer dereference stype ptr hpi hri hqi hri field dereference stype struct ptr hpi hri hqi hr bai ba field dereference stype struct ptr hqi hri hr bai hpi ba field address stype struct ptr hqi concat hpi hri hr bai plus stype ptr hqi concat hpi hri hr alli constraint generation inference rules 
ffl field address statement essentially translates pointer particular offset structure points 
field ba denotes field address assigned reasoning address case set obligation satisfy get obligation field 
ffl plus points field structure general know field point 
conservative assume may point structure behavior want arbitrary arithmetic 
reduces field offset case possible offsets taken account 
perform inference new judgments obtained values get type obligation pointer sources perform actual type safety checking 
process restrictive algorithm section 
inference rules encoded class set constraints known solvable cubic time sketch encoding section 
example 
reconsider code 
rules generate chain inferences cp cps bpi cp color red stype cp colorpoint colorpoint bpi colorpoint psp psp cps psp hqi bpi bpi colorpoint hqi colorpoint pt pti hqi hqi colorpoint pti colorpoint consequently pti physical subtype colorpoint 
declared type pt point physical subtype colorpoint flag error 
example 
purpose example point possibility divergence constraint generation inference way avoid 
consider statements 


statement generate constraint hmi 
statement field offset rule generate constraint hm bai 
statement 
transitivity hm bai 
steps just mentioned repeated leading increasingly deeper cumulative offsets ba ba non termination constraint generation 
rely declared types inference phase evaluating ba algorithm assume offsets matter deep possible 
circumvent problem implementation check offset field offset case 
prespecified threshold inferring usual constraint hr bai infer hr alli 
appropriate threshold size largest struct type program 
comparison flow insensitive points analysis section explore connection algorithm previous flow insensitive points analysis ste sh 
goal points analysis compute pointer variable set variables address contain 
physical type checking algorithm common algorithms pointsto analysis distinguish fields structures ste wl 
analysis tracks fields terms base pointer numeric offset 
consequently information obtained analysis specific platform confident portable platform independent version developed 
point note nature information obtained physical type checking points analysis different points analysis information obtained variable contain address variable contrast physical type checking information obtained type variable address taken program needs certain collection fields pointer dereferences program safe 
differences philosophy kinds analyses ffl obtain points information priori assumption types variables correct insofar determining size variable concerned 
declared type variable inadequate respect actual dereferences program declared type point dereferences demand colorpoint points analysis quit ii assume pessimistically arbitrary piece memory activation record clobbered iii assume optimistically bound access variables activation record 
example scenario steensgaard algorithm ste fail type check produce points graph 
contrast approach accesses treated fall bounds essence approach infer types accesses fall bounds algorithm discriminates structure fields maintain precision trust declared types 
ffl points analyses attempt track consequences casts programmer program 
motivation physical type checking different 
identify class sensible casts prepared handle subtype supertype deem unacceptable 
notion sensible motivated number idioms programmers simulate object oriented language features 
key technical difference physical type checking points analysis physical type checking involves backwards propagation needs opposed forwards propagation points information 
despite differences similarities physical type checking points analysis 
thing augmented rules section account effect indirect modifications pointers 
addition judgment hri arises analysis somewhat similar pointsto fact points rules analysis infers judgments similar rules inferring points facts andersen pointer analysis :10.1.1.109.6502
judgments form hri represent exactly information points facts points analysis generates judgment hri converse necessarily hold shown example 
example 
consider statements 


pointer analysis infer points facts points points points 
particular andersen analysis generate proof tree points points correspondingly analysis generate proof tree hri hri proof tree slightly different shape system insist immediate judgment form hri 
analysis admits proof tree hqi hqi hpi hpi points hold inferred judgment hpi appropriate 
says get type obligation larger set type obligation sense points relations hold 
example shows judgment hri points 
noted pointer analysis give alternative ways physical type checking 
ffl possible physical type checking algorithm phases performing alias analysis phase type inference section second phase 
recall problem faced formulating subtyping rule pointers section 
obvious pointer subtyping rule sound track indirect modifications 
values program aliases may denote memory location 
results points analysis compute alias relationships points aliases 
variables common member points sets aliases 
aliases field structure may denote values 
alias information augment restricted algorithm section manner case assignment lhs rhs assume aliases left hand side assigned right hand side value 
example aliasing information taken account algorithm expose type safety violation follows alias psp assignment psp requires consider effect pti hqi pi struct fint propagates type obligation cp pt 
ffl possibility results points analysis directly perform physical typechecking invoking type inference step section 
points relation verify validity field dereference looking field points target approach suited reverse engineering construct expected type target 
starting results points analysis need perform computation similar section construct expected types 
results points analysis achieve goals physical type checking involves working outside type system 
particular addresses issue physical subtyping presence pointers indirectly best 
contributions formulation rule physical subtyping presence pointers 
key idea approach involves introducing distinct variables constraint system program variable 
approach may applications physical type checking 
implementation implementation uses front build syntax tree ast program 
traverses ast generates constraints form suitable solved bane fa publicly available constraint solver university california berkeley 
section describe implementation details arise process 
dealing structure fields algorithm relies base offset scheme refer fields struct discriminates fields precisely portably 
order follow algorithm faithfully implementation store separately type obligation information offset referred structure 
practice implementation may trade precision lower memory requirements higher speed 
implementation may choose discriminate fields struct deliberately offset ba term zero 
implementation choose maintain precise information long maximum cumulative offset remains prespecified threshold 
handling arrays function pointers variables array type treated pointers memory array occupies 
array treated name block memory corresponding array 
syntactic address operator applied array treated op 
read write individual array element treated read write entire array 
function names lifted pointers function definitions 
syntactic address operator applied function treated op 
function definition associated special return variable 
algorithm tracks function pointers cfa style 
call sites formal parameters considered assigned values actual parameters possibly dummy variable gets assigned value function return variable 
treatment arrays function pointers similar foster ffa 
constraint solving sketch express algorithm bane 
intention give flavor algorithm implemented bane reader 
actual implementation algorithm includes details handling struct fields describe 
complete description bane details bane perform program analyses including points analysis refer reader fa ffa 
part bane deals sets 
bane variables constructors expressions type set 
example declare ary constructor unit binary constructor gammas binary constructor declaration specifies argument covariant second argument contravariant 
example expression constructor constant denotes empty set denotes universal set 
bane defines inclusion relation expressions 
says set denoted variable includes set denoted constructed term 
bane interpretation inclusion usual subset relation sets 
example transitive encoding constraints bane exploit constructors covariant contravariant positions 
bane resolves constructed terms follows 
constructed terms compared constructor violation leads error 
constructor resolution introduces element wise inclusion constraints sense inclusion reversed contravariant arguments 
result show write initial set constraints bane constraints starting program ast 
illustrate inferred constraints emerge automatically bane resolution procedure 
define ary constructor gammas gammas 
role positions explained shortly 
keep mind ordering imposed connective opposite sense bane see table 
purposes discussion denote variables bane specification pi note variables formulation connected constructed terms previous sections connected hqi terms values corresponding familiar meaning obtained projecting fourth argument constructed terms appearing solution formulation 
syntax bane constraints hxi hxi hpi xi ii hpi hqi iii hpi iv hqi typeof hpi table bane constraints generated normalized statements 
constructed type row concealed bane ary constructor unique constructed type 
positions constructor store set type obligations remaining positions store get type obligations 
pair position contravariant argument second covariant argument 
select positions way flow set type obligations forwards get type obligations backwards 
easiest explain example 
example 
consider statements matter detail function formal parameter declared array type type actual parameters avoid lifting array type pointer twice 


rule dereference propagate get type obligation inferring new constraint 
see similar propagation bane occurs contravariance rule table hpi hpi rule iii table hti 
transitivity resolution hti hpi 
equivalent relations rules infer hpi hpi hti chose put hti particular positions contravariance reverses sense inclusion hti covariance maintains sense giving desired relations 
compare rules iii table interact illustrated rules iv interact 
circularity results constraint solving need post processing account circularity 
consider statements 

statements generate constraints hsi concat typeof hti hti hsi example simply read answers hsi hti outcome constraint solving 
constraint system treats concat term constant leaves final set constraints 
implementation perform occurs check variable names inside constructed terms detect cycles 
particular example hsi hti evaluate divergent value 
created prototype implementation algorithm bane 
plan tune implementation run large code bases particular code lucent technologies product report experiences 
related related falls categories static semantic checking tools alternate type systems record variant subtyping points alias analysis presence structs unions constraint analysis 
static semantic checking tools physical type checking related complementary tools lint jr joh lclint eva 
algorithm lint lclint assist static detection type errors escape notice compilers 
lclint identify problems constructs system example problems dereferencing null pointers adding explicit annotations source code 
hand lint lclint notion subtyping 
alternative type systems 
idea applying alternative type systems appears places gs sv oj sr ste 
discuss application parametric polymorphism particular sv concerns new dialect polymorphic type safe 
oj uses polymorphic type inference existing programs determining information transfer values 
physical type safety may contrasted typed assembly language morrisett mwcg 
type system imposed risc assembly language way individual registers memory locations assigned types provide run time type safety 
ramalingam algorithm infer particular kind typing structures 
type system allows various degrees coarsening structure structure may treated atomically program field may referred separately 
analysis attempts find coarsest admissible type structure program 
comparison record subtyping similarity record subtyping proposed cardelli car :10.1.1.116.1298
cases structure record contains superset fields structure considered subtype second structure 
primary difference take account physical layout data types determining subtype relationships cardelli notion physical layout apply 
problem subtyping presence pointer fields inside structures appears related problem record subtyping presence mutable fields ac 
plan investigate relationship 
relation points alias analysis comparison flow insensitive points analysis physical type safety analysis section 
presents alias analysis algorithm subtype relationship called weakly right regular relation defined pairs expressions 
definition relation flavor physical subtyping rules discussed 
system described provision handling type casts considers structs related equal type system structs related physical subtype 
clear possible terminological confusion may arise compared foster ffa 
get set components type variable type inference scheme corresponds covariant contravariant aspects respectively type variable 
get set corresponds different type variables covariant contravariant components bane implementation 
constraint analyses constraint analysis inferring general physical types gathers information access obligations variable type satisfy 
bears relationship certain kinds backwards flow sensitive need analyses developed community including algorithms hug strictness analysis wh program slicing rt dependence analysis liu 
idea treating accesses variable contract limit attention certain portions variable question minimal obligations variable determined accounting accesses 
applied idea context flow insensitive analysis imperative language supports destructive updating heap allocated storage 
algorithm incorporates notion set type obligation order handle destructive updating 
algorithm perform physical type checking programs 
physical type checking useful static safety checks application program comprehension reverse engineering 
near plan experiment physical type checking large software systems particularly proprietary product lucent technologies consists thousands lines code 
acknowledgments michael thomas ball contributions 
particular material section appendices joint previous 
second author supported part national science foundation ccr ccr united states israel binational science foundation ibm associate award university wisconsin 
abs todd austin scott breach sohi 
efficient detection pointer array access errors 
sigplan notices june 
proceedings acm sigplan conference programming language design implementation 
ac mart abadi luca cardelli 
theory objects 
springer 
andersen :10.1.1.109.6502
program analysis specialization programming language 
phd thesis diku university copenhagen may 
diku report 
car luca cardelli :10.1.1.116.1298
semantics multiple inheritance 
kahn macqueen plotkin editors semantics data types number lecture notes computer science pages 
springer verlag 
eva david evans 
static detection dynamic memory errors 
proceedings acm sigplan conference programming language design implementation pages may 
fa manuel fahndrich alex aiken 
program analysis mixed term set constraints 
proceedings th international static analysis symposium 
ffa foster fahndrich aiken 
flow insensitive points analysis term set constraints 
technical report ucb csd university california berkeley july 
gs 
snelting 
polymorphic components monomorphic languages 
prieto diaz frakes editors advances software reuse selected papers second international workshop software reusability pages italy march 
ieee computer society press 
gun carl gunter 
semantics programming languages 
mit press 
hs samuel harbison guy steele jr manual 
prentice hall 
hug hughes 
backwards analysis functional programs 
partial evaluation mixed computation proc 
ifip tc workshop partial evaluation mixed computation denmark oct pages 
iso iso iec 
programming 
number 
iso iec 
joh johnson 
lint program checker july 
jr johnson ritchie 
unix time sharing system portability programs unix system 
bell systems technical journal 
kr brian kernighan dennis ritchie 
programming language 
prentice hall second edition 
liu liu 
dependence analysis recursive data 
proceedings ieee international conference computer languages pages may 
mwcg greg morrisett david walker karl crary neal glew 
system typed assembly language 
popl th acm sigplan sigact symposium principles programming languages pages january 
oj robert callahan daniel jackson 
detecting shared representations type inference 
technical report cmu cs carnegie mellon university september 
ramalingam john field frank tip 
aggregate structure identification application program analysis 
proceedings th acm symposium principles programming languages january 
rt reps 
program specialization program slicing 
proc 
dagstuhl seminar partial evaluation schloss dagstuhl ger feb lec 
notes comp 
sci vol 
pages 
chandra ball reps coping type casts technical report bl lucent technologies bell laboratories february 
available www bell labs com pubs coping tr ps 
sh shapiro horwitz 
fast accurate flow insensitive points analysis 
proceedings acm conference principles programming languages popl 
sr michael thomas reps program generalization software reuse 
fourth acm sigsoft symposium foundations software engineering pages san francisco october 
ste bjarne steensgaard 
points analysis type inference programs structures unions 
proceedings international conference compiler construction number lecture notes computer science pages 
springer verlag april 
sv geoffrey smith dennis volpano 
ml style polymorphic type system european symposium programming april 
wh wadler hughes 
projections strictness analysis 
third conf 
func 
prog 
comp 
arch 
portland sept lec 
notes comp 
sci vol 
pages 
wl robert wilson monica lam 
efficient context sensitive pointer analysis programs 
proceedings acm conference programming language design implementation pldi pages june 
yong susan horwitz thomas reps pointer analysis programs structures casting 
proceedings acm conference programming language design implementation pldi 
sean zhang barbara ryder william landi 
program decomposition pointer aliasing step practical analyses 
fourth acm sigsoft symposium foundations software engineering pages san francisco october 
data layout ansi standard section briefly review storage model data structures 
detailed account reader directed hs kr iso 
data objects represented integral number bytes memory 
size data object number bytes occupied data object hs 
character type char signed char unsigned char defined occupy byte memory 
sizes types implementation dependent conform guidelines ffl signed unsigned const volatile qualifiers affect size type 
example unsigned int size const int 
ffl shorts ints require bits 
ffl shorts longer ints 
ffl require bits 
ffl ints longer 
ffl floats doubles long doubles require bits 
ffl union requires storage largest member 
ffl struct requires storage sum storage members respecting alignments members see 
computers allow object stored address memory regardless type object 
computers impose alignment restrictions certain data types 
types required stored addresses integral multiples bytes 
data object stored accordance type alignment restriction expressions casts involving object portable compilers compliant standard 
ability programmers cast expression type type possible run alignment restrictions resulting non portable code 
character types alignment restrictions occupy byte memory 
alignment restrictions types implementation dependent conform guidelines ffl signed unsigned const volatile qualifiers affect alignment type 
example unsigned int alignment const int 
ffl alignment struct union maximum alignment members 
storage rules struct types dictate member stored struct 
subsequent members stored order declared struct 
alignments types members struct may require unused space placed members 
example suppose machine requires integers stored byte multiples 
consider struct struct char int char struct stored address address address address address 
furthermore entire struct padded multiple largest alignment resulting total size bytes 
say number bytes address field struct struct offset field 
guarantees offset member assuming bit field struct offset member assuming bit field multiple alignment type member 
guarantees non bit field members unions placed offset 
storage bit field members implementation dependent 
type system see assume offsets supplied explicitly 
implementation see section assume struct types bit fields members stored close possible violating alignment restrictions 
defining physical type safety define physical type safety scheme pointer pointer expression carries instrumentation dynamic type 
dynamic type pair type offset type 
pointer expression dtype dynamic type dtype dtype instrumentation scheme inspired tool abs 
define auxiliary function returns type object offset struct ground type pointer array 
offset contained union inside type assume correct member union chosen 
enforcing correct member union chosen orthogonal issue deal 
dynamic types created propagated rules ffl dtype malloc sizeof ffl dtype dtype dtype offset stype ffl dtype stype 
ffl dtype dtype sizeof stype ffl assignment dtype dtype note pointer casts explicit implicit affect dynamic type pointer expression 
instrumentation memory physically type safe offset valid offset respect dtype 
offset stype dtype 
offset valid offset respect conditions met ffl sizeof stype sizeof 
intuition condition referred memory location lie chunk memory currently points 
ffl stype 
refered location contain type data type field consider application instrumentation statements 
dynamic type point propagated dynamic type pointer pcp 
dereference pcp physically type safe type point contains integer offset 
dereference pcp color physically type safe offset field color outside type point 
illustrate pointers tracked move struct 
execution statement dynamic type 
execution second statement dynamic type sizeof clock represents type radio 
dereference frequency physically type safe 
implies scheme track pointers point middle arrays 

