disk scheduling revisited margo seltzer peter chen john ousterhout computer science division department electrical engineering computer science university california berkeley ca invention movable head disk people improved performance intelligent scheduling disk accesses 
applied techniques systems large memories potentially long disk queues 
viewing entire buffer cache write buffer improve disk bandwidth utilization applying traditional disk scheduling techniques 
analyzed techniques attempt optimize head movement guarantee fairness response time presence long disk queues 
propose algorithms take rotational latency account achieving disk bandwidth utilizations nearly times simple come serve algorithm 
algorithms weighted shortest total time particularly applicable file server environment guarantees requests get disk specified time window 

day magnetic disks capable providing bandwidth order megabytes second great deal bandwidth lost time required position head requested sector 
study focuses improving effective throughput rotation seek optimizing algorithms schedule disk writes 
movable head disk people undertaken similar efforts 
studies assumed short queue lengths performance improvement obtained various techniques substantial 
approach consider system file server large main memory dedicated disk buffering 
assumed newly written data need transmitted disk immediately may retained short period time main memory buffer transmitted disk time maximizes disk throughput 
increasing sizes main memory megabytes file servers hundreds thousands blocks queued writing time 
careful ordering requests possible reduce average head positioning time substantially 
hand potential starvation request important fairness requirement 
developed algorithms attempt avoid starvation provide disk utilization 

previous previous dealt scheduling small number fewer requests 
small numbers requests research concentrated come serve fcfs shortest seek time ssf scanning algorithms service requests cylinder order scanning edge disk 
appeared proceedings winter usenix washington january 
shows nearly loading conditions ssf results shorter mean waiting times fcfs 
main drawback finds ssf larger variance response time 
optimal scheduling takes account number requests cylinder pursue 
results combination theoretical analysis simulation 
coffman ryan discuss fcfs ssf 
add analysis scheduling policies intended control high variance ssf 
called scan 
scan restricts search minimum seek time request direction inward outward 
scan causes long waiting times requests extremes disk 
addresses freezing queue scan starts requests arrive scan starts serviced scan 
pure theoretical analysis coffman concludes scan uniformly results lower average response times fcfs higher average response times ssf 
geist describes continuum algorithms ssf scan differing importance attached maintaining current scanning direction 
fcfs ssf scan analyzed 
similar ssf yields shorter response times scan yields shorter response times fcfs 
scheme similar scan schedules rotational position addition seek position 
result scheme generates lower average response previous scheme queue length increases 
papers queue lengths averaging studied 
limitation due large part smaller memory sizes time slower cpu exponentially growing memory sizes moor faster cpu data may accumulate quickly disk queues longer constrained small lengths 
large queues able investigate previously impractical unnecessary schemes 
particular continue study rotationally optimal scheduling algorithms 

test environment chose analyze algorithms ways theoretical model simulation hardware tests 
theoretical model served approximation potential performance gain 
simulation provided flexible testing platform hardware tests verified correctness simulator 
validation simulator simpler algorithms remaining results derived simulation 

simulator simulator modeled fujitsu eagle described table 
simulations cpu time required calculate request ignored basis computation overlapped actual operation 
furthermore wished focus potential algorithms optimizing implementation 
interested viewing behavior algorithms presence requests introduced artificial model request arrival 
order examine behavior queue length initialized queue contain events request time 
request serviced replaced new request request time equal completion time completed request 
manner guaranteed queue length select request simulations insensitive real arrival rate 
order avoid skewing response time results leaving requests queue simulation completion completed simulation emptying entire queue 
requests generate new requests serviced remaining queue 
fujitsu eagle disk drive cylinders disk tracks cylinder sectors track bytes sector average seek ms average rotational latency ms time transfer kb ms seek time ms cylinders table specifications fujitsu disk drives 
seek time calculation graphed seek time ms function seek distance cylinders fuji 
model ms ms ms ms order guarantee averages obtained statistically significant needed determine acceptable length simulation runs 
length queue total number blocks disk 
point time objects selected set queue 
probability particular set objects drives tested blocks disk 
queue qb length order combinations queue length combinations 
clearly infeasible examine large portion space 
furthermore simulations sample size independent entries queue time differ entries queue time precisely event 
define test run simulation generated full queue random requests serviced 
analyzed variance runs ranged 
runs size variance decreased small fraction mean response time stabilized 
felt tests times number queued items representative sample 
model time information provided disk vendor results obtained disk tests described 
requests disk subsystem blocks uniformly distributed entire disk 
seek time computed function number cylinders head needed move see 
rotational latency calculated time required bring data head seek completed read data 

hardware tests verify theoretical models simulations ran tests disks modeling fujitsu eagles described table 
verified simulation basic scheduling algorithms fcfs ssf 
difficulty determining rotational position hardware verify simulation algorithms 
simulation assume zero cpu time spent process order factor cpu time subtracted constant ms individual disk access 
seek optimizing algorithms started algorithms optimize solely seek distances come serve shortest seek scanning algorithms 
algorithm evaluated provide brief description algorithm intuitive theoretical estimate performance feasible actual results graph comparing simulated versus theoretical results 
metric evaluating algorithms disk utilization define fraction time disk spends transferring data 

come serve simplest scheduling algorithm imaginable come serve fcfs 
expect model independent queue length obtain average time equal predicted average seek plus predicted average rotation 
numbers verify algorithms algorithms queue length equal fcfs 
disks spinning rpm yielding revolution time ms sectors bytes providing transfer rate ms back envelope calculation show simple come serve scheduling policies expect average time half rotation ms plus time average seek ms 
yields disk utilization fraction time disks transferring data shows close hardware derived simulated utilizations 

shortest seek algorithm ignore rotational latency select requests seek time required 
average expect see half rotation ms seek closest chose kb block size common file system block size 
estimated cpu time issuing user process issuing consecutive sectors track 
reading sector sector read missing entire revolution sector revolution 
implied ms cpu turnaround time 
utilization fcfs theor fcfs sim fcfs hw queue length comparing fcfs utilization derived theoretical analysis fcfs theor hardware measurements fcfs hw simulation fcfs sim 
cylinder request 
function total number cylinders disk length queue 
example eagles cylinders 
queue length expect average seek cylinders 
queue length expect average time approximately sqrt ms depicts predicted values results obtained simulation 
maximum queue length corresponds mb dirty blocks 
example consider file server mb main memory 
reasonable assume may dedicated file cache approximately mb dirty 

scan cscan scan scheduling algorithm oriented producing fairer response time 
orders requests cylinder number services requests cylinder moving head cylinder 
head reaches disk merely reverses direction begins scanning disk 
important notice similar shortest seek algorithm expect similar results 
shortcoming scan algorithm requests disks experience worse response time middle disk middle experience passes head evenly spaced time outermost cylinders delay quite accurate time average seek average time 
close approximation linear seek profile 
utilization ssf theor ssf sim queue length comparing ssf utilization derived theoretical analysis ssf theor simulator ssf sim 
full sweeps cylinders revisited 
cyclical scan cscan alleviates paying large seek disk move head way 
head moves direction pay long seek pass 
long seek amortized requests utilization nearly scan 
major difference maximum observed response times variance response times 
shows utilizations cscan essentially identical ssf 
shown cscan substantially improves maximum observed response time 

seek rotation optimizing algorithms 
shortest time ssf chose request yielded fastest seek 
shortest time stf choose request yields shortest time including seek time rotational latency 
advances disk technology reduced seek time rotational latency 
trend continues expect rotational latency account greater fraction total time rotation optimizing algorithms stf increasingly important 
example saving half rotation ms may cause access cylinders away shorter total time access cylinder away 
stf expected yield best throughput select fastest algorithm scans entire queue calculating time request take 
selects utilization max response time sec seek optimized policies cscan ssf ssf fcfs cscan fcfs queue length queue length disk utilization fcfs ssf cscan 
graph disk utilization derived theoretical modeling hardware verification simulation maximum observed response time fcfs ssf cscan 
ssf significantly worse maximum response time fcfs cscan roughly simple scheduling policies 
lower maximum response scan algorithm yields utilizations time fcfs 
instances identical cscan shown 
cscan able lower response time fcfs average response time lower 
request shortest expected service time 
long queue lengths greater number cylinders expect see stf time approach ms time read single block 
short queue lengths expect stf approximate ssf multiple requests cylinder adjacent requests far apart seek time dominates rotation 
shows simulated results stf 
note queue length stf utilization rising 
preliminary runs queue lengths utilizations 
unfortunately scheduling algorithm function cylinder rotational position algorithm costly terms cpu utilization 
addition stf potential starve requests producing bad response time 
note maximum observed response times empirically determined maximum response times real system worse 
algorithms attempt provide utilization benefits offered shortest time algorithm paying substantial penalty response time 

grouped shortest time gstf algorithm combine scan techniques shortest time techniques 
disk divided number cylinder groups 
cylinder group apply shortest time algorithm servicing requests group advancing group 
algorithm introduces parameters queue length size cylinder group 
shows relationship average times holds queue size changes cylinder group size 
shows maximum response times 
cylinder group size increases utilization gstf increases 
eventually group size entire disk gstf definition stf 
group size increases maximum response time longer longer approaching stf 
utilization queue length stf wstf gstf cscan fcfs max response time sec queue length gstf cscan wstf stf disk utilization fcfs maximum response time cscan stf gstf wstf 
cscan stf gstf wstf 
graph disk utilization seek graph maximum response time seek rotation optimizing algorithms 
fcfs rotation optimizing algorithms 
max cscan shown comparison 
imum response time stf worse algorithms gstf wstf bring maximum response time back 
recall maximum response time fcfs close cscan 
utilization max response time sec stf stf gstf gstf size cylinder group size cylinder group utilization maximum response time shortest seek grouped shortest time 
graphed utilization maximum response times function cylinder group size 
results queue lengths 
early dip maximum response time curve due interaction utilization average disk time fairness 
gstf fair variation response times small group sizes disk efficiently average response time larger 
utilization flattens decreasing fairness causes increasing maximum response times 
figures show utilization maximum response time group size cylinder groups disk 
see gstf utilization close stf succeeds lowering response time close maximum response time cscan 
gstf services requests current cylinder group moving cylinder group 
requests current cylinder group saturate system possible starve requests parts disk 
slight variation gstf freezes queue cylinder group soon requests cylinder group serviced guaranteeing requests cylinder group serviced head moves cylinder group 
runs variation lower disk utilizations lower maximum response times gstf depicted 

weighted shortest time algorithm applies standard shortest time technique applies aging function times computed 
assume maximum acceptable delay time write buffer cache issued data written disk simulations time chosen seconds frequently unix kernel flushes buffer cache stf calculation actual time multiplied weighting value computed calculating time left request exceed maximum allowed response time 
weighted time weighted time real actual time max response time allowed elapsed time request arrived real elapsed time increases weighting factor smaller weighted time decreases request serviced 
algorithm displays remarkable performance 
cases average time stf maximum response time drops dramatically 
wstf enforced maximum response time response time allowed take seconds 
contrast stf maximum response time empirically determined guarantee request got serviced 
trying understand wstf performs useful observe stf greedy algorithm 
selecting shortest time means regions disk get serviced 
regions get cleaned fewer close requests service 
wstf periodically arm forced bad seek costly 
result head new region providing algorithm better choice requests select 
bad seeks may occur read forced write write go immediately disk issued 
results imply long seeks harm utilization 

main 
substantial performance improvements order times gained scheduling mechanisms 
queue selects requests larger improvement realized 
second algorithms achieve improved performance ensure fairness 
note queue lengths best algorithms yield disk utilization 
leaves room improvement 
implication greater utilization disk bandwidth achievable viewing main memory large write buffer 
systems order writes unconstrained take advantage unordered nature writes minimize disk seek overhead 
larger file caches may minimize necessary individually cheaper 
adjust acceptable response time number requests queue average time fcfs queue length 
runs response time limits yielded results percent runs second limit 

brent welch keith bostic instrumenting sprite bsd machines collect statistics real queue lengths 
numbers convinced burstiness expects file server fact result large number disk writes scheduled 

coffman ryan analysis scanning policies reducing disk seek times siam journal computing september vol 

fuji mini disk drive engineering specifications fujitsu limited 
geist robert daniel stephen continuum disk scheduling algorithms acm transactions computer systems february vol 

performance movable head disk storage devices journal acm october vol 

micha disk scheduling fcfs vs sstf revisited communications acm november vol 
marshall kirk mckusick william joy sam leffler fabry fast file system unix acm transactions computer systems vol 
august pp 

moor moore progress digital integrated electronics proceedings ieee digital integrated electronic device meeting 
walter queuing analysis scan policy moving head disks journal acm july vol 

smit smith input output optimization disk architectures survey performance evaluation pp 

toby pinkerton tad comparative analysis disk scheduling policies communications acm march vol 

wilhelm neil anomaly disk scheduling comparison fcfs sstf seek scheduling empirical model disk accesses communications acm january volume 
