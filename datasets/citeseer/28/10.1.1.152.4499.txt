december src research report extended static checking david detlefs rustan leino greg nelson james saxe systems research center lytton avenue palo alto california www research digital com src systems research center charter src advance state knowledge state art computer systems 
establishment digital equipment compaq performed basic applied research support business objectives 
interests span scaleable systems including hardware networks distributed systems programming languages technology internet including web internet appliances human computer interaction 
strategy test technical practical value ideas building hardware software prototypes daily tools 
interesting systems complex evaluated solely extended allows investigate properties depth 
experience useful short term refining designs invaluable long term advancing knowledge 
major advances information systems come strategy including personal computing distributed systems internet 
perform complementary mathematical flavor 
established fields theoretical computer science analysis algorithms computational geometry logics programming 
explores new ground motivated problems arise systems research 
strong commitment communicating results exposing testing ideas research development communities leads improved understanding 
research report series supplements publication professional journals conferences technical note series complements research reports journal conference publication allowing timely dissemination research findings 
seek users prototype systems common interests encourage collaboration university researchers 
extended static checking david detlefs rustan leino greg nelson james saxe december author affiliations david detlefs staff engineer sun microsystems laboratories 
reached david detlefs sun com 
completed authors left src 
compaq computer may copied reproduced part commercial purpose 
permission copy part payment fee granted nonprofit educational research purposes provided partial copies include notice copying permission systems research center compaq computer palo alto california acknowledgment authors individual contributors applicable portions copyright notice 
copying reproducing republishing purpose shall require license payment fee systems research center 
rights reserved 
describes mechanical checker software catches common programming errors particular array index bounds errors nil dereference errors synchronization errors multi threaded programs 
checking performed compile time 
checker uses automatic theorem prover reason semantics conditional statements loops procedure method calls exceptions 
checker implemented modula 
applied thousands lines code including mature systems code fresh untested code number errors 
authors children leading lights computing declared world faced software crisis 
hardware improved year software complexity programming expensive error prone 
observations didn software industry proceeded grow revenues profits dramatically sustained growth continuous innovation 
software crisis false alarm 
really 
profitable writing software expensive error prone 
innovation software industry confined finding new things software new ways produce software 
common see software disasters millions dollars spent writing program abandoned release implementors simply get 
tragic failure establish software reliable engineering discipline painfully clear studies leveson turner investigation accidents 
revenues profits grown figures economic consulting firm dri mcgraw hill indicate period generally rising productivity productivity software industry fallen 
computations may entirely accurate difficult correct inflation safe say software productivity kept pace productivity areas computing industry hardware 
fact claim growth software industry stagnation programming technology created fold improvement price performance cpus years 
information revolution moves infancy engineering community assume responsibility delivering vast promises robots insufficiently considered progress enormously accelerated programming technology advanced curve microprocessors 
silver bullets solution software crisis 
software problem structured programming pl answer 
object oriented revolution bring mass production methods software program fragments inexpensive reusable reliable commodities 
program verification eliminate errors 
programming natural language eliminate need arcane languages users express requirements directly computer programming profession away 
dreams fulfilled 
believe programming difficulties stay 
refinement techniques prompt discovery error serves hallmark mean science 
robert oppenheimer 
silver bullets advocate strategy studying engineering practices today best programmers developing practical tools improve process expecting change essential nature 
describes particular research project strategy extended static checker called esc programming tool catches errors compile time ordinarily caught runtime 
examples array index bounds errors nil dereferences deadlocks race conditions multi threaded programs 
tool useful cost error greatly reduced detected early development process 
tool intended type checker tool lint warnings intended interpreted author program checked 
checker implemented technology program verification 
program annotated specifications annotated program verification condition generator produces logical formulas provable program free particular class errors consideration formulas automatic theorem prover 
sounds program verification firstly don try prove program supposed check certain specific types errors secondly interested failed proofs successful ones 
crucial point failed proofs useful successful ones warn programmer possible errors 
addition useful esc feasible full scale program verification 
example unsound full scale program verifier amount unsoundness tolerate static checker matter engineering judgment expects type checker lint tool find errors utility determined number errors finds weighed cost running tool 
similarly promising esc find errors free declare kinds errors tool range 
idea extended static checking new 
ph thesis know addressed idea dick sites quarter century ago problem held ph thesis topic 
research prototype checkers implemented decades simplifying assumptions 
may handle dynamically allocated data object oriented programming may handle concurrency may require source entire program order check part may require user guide theorem prover provide complicated loop invariants 
simplifying assumptions way separating concerns help focus particular aspects problem gaining depth insight 
builds deep insights produced earlier researchers esc project followed complementary mode research effort produce test realistic artifact 
complementary mode research reveal surprises 
previous checking tools tested small programs written tool implementors 
contrast plan run checker significant pieces modula runtime system 
tackling realistic programs written cases esc project members esc project launched hoped learn answers questions generate verification conditions systems programs 
able turn failed verifications specific error messages 
burden write necessary annotations 
extent automate theorem proving task 
summary determined stress test idea long 
checker handles multi threaded multi module object oriented programs 
checker works modula programs techniques language address arithmetic restricted including java ada oberon fortran 
goes press follow project replicated technology tool java 
checker performs modular checking check selected modules program checking entire program 
modern programming libraries consider modular checking essential 
checker allows check selected classes errors example useful check deadlocks race conditions checking array index bounds errors 
checker produces spurious warnings variety ways suppress get checker ignore spurious warnings continue report real errors 
checker research prototype plenty rough edges feel demonstrates promise technology clearly previous checkers esc catches errors type checker possibly catch feels programmer type checker program verifier 
specifications required statements straightforward facts inequalities error messages specific accurate respect source position error type theorem proving carried scenes automatically 
type checker program verifier isn smart hardy friendly 
jim morris 
spec procedure method name formal parameter names modifies list variables requires precondition ensures postcondition procedure specification syntax 
main goal convey reader feels checker operates intermediate level type checking verification 
consists largely examples 
examples describe general level novel aspects checker relegated details papers 
specification language section lay groundwork examples form heart briefly introducing esc specification language 
design specification language reflects structure designed programs 
pillar program structure procedural abstraction compound operation named parameterized rest program elementary operation 
procedural abstraction static analysis difficult difficult static analysis methods described literature apply programs procedures practical compilers perform inter procedural analysis perform extensive intra procedural analysis 
reason authors compilers tools wanted rely specifications inter procedural analysis fundamentally requires dealing specifications supplied programmer inferred tool 
perform inter procedural analysis esc relies programmer supplied specifications form illustrated 
pre postconditions formulas order theory includes modula built operators 
procedure specification contract implementer client client contracts call procedure state precondition true implementer contracts modify variable modi fies list return state satisfying postcondition 
checking body procedure esc assumes precondition true initially checks procedure returns postcondition true variables modifies clause modified 
conversely spec var type spec rep concrete representation data abstraction syntax 
checking client esc checks precondition true point call assumes call respects postcondition modifies clause 
example modula declaration esc specification simple random number generator var seed integer procedure rand integer integer spec rand modifies seed requires seed ensures res res seed example illustrates points 
variable listed modifies clause seed occurrences postcondition unprimed primed seed 
primed occurrence denotes value variable post state unprimed occurrence denotes value variable pre state 
second reserved name res denote result procedure 
third modula pragma brackets surround esc annotations distinguish ordinary modula 
fourth modula syntax assert values different 
pillar program structure data abstraction collection program variables concrete variables considered conceptually represent single variable 
variable clients reasoning semantic effect operations abstraction concrete variables implementation operate efficiently state 
example value complex number represented concretely terms floating point cartesian coordinates alternatively abstraction represented terms polar coordinates theta 
generally module structure program arranged concrete representation abstraction invisible scope modules abstraction clients 
shows esc syntax declaring variable specifying representation known abstraction function 
example spec var integer var integer spec rep declares integer variable concrete integer variable specifies square represents haven described specification language described give example 
elementary application modula writers extended examples modula standard library designed key abstraction monitored object oriented buffered stream 
particular reader input stream writer output stream 
stream object contains buffer methods managing buffer 
different stream subclasses override methods different ways example file reader buffer disk network reader buffer network 
class independent code common subclasses example wr writes ascii representation integer writer buffer 
modula design described chapter nelson modula book original design described stoy strachey 
describe various aspects relevant interfaces need examples 
type stream modula library provides interfaces basic interface simple clients advanced interface offers additional functionality particular access buffer structure price additional complexity 
basic writer interface 
example uses basic writer interface wr 
translation modula english 
writer class global name wr wr name interface convention principal type declared interface 
class declared opaque object type publicly known subtype built class root 
modula classes correspond object types 
actual declaration representation type hidden advanced interface invisible clients basic interface 
procedures putchar close signatures specifications text modula string type 
actual interface eleven procedures representative 
interested reader interface wr type root spec var valid map boolean spec var state map procedure putchar wr ch char spec putchar wr ch modifies state wr requires valid wr procedure wr txt text spec wr txt modifies state wr requires valid wr txt nil procedure close wr spec close wr modifies valid wr wr 
simplified writer interface 
find esc annotated version full interface referenced extended static checking homepage web 
valued field declared class corresponds semantically map declarations valid state thought boolean valued valued fields writers 
modula uses syntax denote field object annotation language uses syntax 
specifications writer interface fall common pattern call state validity paradigm 
paradigm variables valid state 
idea valid wr represents condition wr properly initialized valid writer state wr represents state wr example contents position 
doing full scale program verification pages specifications state doing extended static checking say state specify procedures may modify 
type state relevant special esc type 
state validity paradigm specifications stylized 
typical procedure method operating writer wr putchar specification modifies state wr requires valid wr valid appear modifies list specification implies preservation validity 
procedures additional annotations example requires text argument non nil simple interfaces stylized specifications state validity paradigm lion share written esc verification 
text writer interface 
illustrates text writer interface particular writer subclass occurs example 
text writer writer doesn output just stores written internal buffer provides procedure returns contents buffer text 
subclass wr specification variables valid state apply text writers specification text writer interface 
method init initializes text writer establishes valid returns establishes res 
specification entirely typical initialization methods state validity paradigm 
similarly specification typical state validity paradigm additional postcondition conjunct res nil 
interface import wr type wr object methods init spec init twr modifies wr valid twr wr state twr ensures wr valid twr res twr procedure twr text spec twr modifies wr state twr requires wr valid twr ensures res nil 
text writer interface 
procedure array text text var twr new number wr twr return twr erroneous version example program uses text writer twr accumulate growing concatenation elements example 
example program kind elementary programming exercise assigned students learning program output streams seeded program elementary errors 
problem program procedure takes array texts argument returns single text containing concatenation texts array 
done straightforwardly repeatedly calling modula binary concatenation operation text cat doing leads performance trap implementations text concatenation total cost time simple approach proportional square length final result 
way avoid quadratic cost text writer leads procedure shown 
procedure allocates text writer writes elements array writer order retrieves returns text containing written 
approach avoids quadratic cost text writers implemented 
running esc procedure produces warning array index bounds error array index bounds error line wr twr exact format esc error message identical compiler error message italics underlining convey information 
error message includes called error context long list atomic formulas characterize situation error occur 
long won show error context study context reveals implies formula number fact condition array bounds error occur modula open arrays indexed loop written indexed 
correcting error natural way produces improved program procedure array text text var twr new number wr twr return twr version loop eliminates warning array bounds error 
esc complains program follows precondition failed line wr twr study error context reveals implies formula valid twr 
esc detected warned failure initialize twr program allocated text writer failed initialize 
correct error add call init method requires inserting characters init procedure array text text var twr new init number wr twr return twr correction eliminates previous warnings esc gives warning precondition failed line wr twr study error context shows text argument equal nil forbidden precondition ensured blindly passes nil 
error forces rethinking design nil entries text array 
designs come immediately mind ignore nils forbid nils 
design easy get esc 
design nils ignored procedure recoded follows procedure array text text var twr new init number nil wr twr return twr course esc understands statements perfectly happy version 
design nils forbidden specification strengthened quantified precondition spec requires integer number implies nil esc perfectly happy design stronger precondition suppresses error message 
furthermore esc enforce stronger precondition called 
comments example 
careful specifications required writer text writer interfaces programmer able esc writing specifications program 
preconditions loop invariants required 
think anybody qualified design interfaces stream library understands preconditions postconditions abstractions level find explicit notation design decisions useful tool burden 
hand simple errors programs identified reading unannotated erroneous program require loop invariant order check pedagogical heavy handed 
second reader aware concentrated example checking client system fact esc check implementation text writers 
implementation representation declaration give concrete meaning valid twr terms concrete fields twr 
representation esc checking body procedures require validity precondition implementations depend concrete meaning validity 
third example allows user choose point continuum full functional correctness verification minimal extended static checking 
example fact true initializing text writer leaves contents empty specifications reflect truth 
wanted reflect strengthening postcondition init lines spec init twr modifies wr valid twr wr state twr ensures wr valid twr res twr wr state twr require changing type state writer seq char 
notation correct empty character sequence 
easy artificial example stronger specification essential esc verification 
example absence array bounds errors client depend fact newly initialized text writer empty 
slippery slope 
init effect state specified fully putchar 
discipline quickly slide black hole full correctness verification 
luckily experience esc verifications successfully completed specifications contents meanings types specification validity 
go long way just relying state validity paradigm specifications procedure record accurately procedure affects requires validity side effects swept ample rug modifies state wr 
believe key reason esc verifications cost effective full correctness verifications 
advanced application readers section describe esc sophisticated program whitespace skip 
example short client program modula system differs ways example previous section 
minor difference program client input streams output streams 
important difference example pay attention synchronization protocol designed readers writers 
previous example omitted synchronization order simplify exposition 
important difference section see program uses advanced interface deal buffer structure stream exclusively procedures basic interface 
protect mu protect self ll sup shared variable accessed holding lock mu object shared field accessed holding lock set locks held current thread supremum maximum locking order locking level syntax 
second form protect field declared subclass mutex 
esc checks synchronization errors 
experience synchronization errors failures acquire locks causing race conditions acquiring locks order causing deadlocks 
designed esc annotation language catch simple errors shows syntax 
programmer declares locks protect shared variables locks held entry various procedures 
programmer declares partial order threads allowed acquire locks 
esc checks shared variables accessed holding lock protects checks threads acquire locks strictly increasing order modula features non reentrant locks 
doesn prove correctness expensive techniques monitor invariants required catch common errors 
locking order mutexes denoted programmer specifies general facility adding axioms esc verification spec axiom 
example modula window system object called 
arranged trees locked leaf tree root vice versa 
rule declared interface follows spec axiom parent axioms locking order arise subtle situations 
particular example acquires reader lock time don need declare axioms locking order 
basic reader interface 
shows basic modula interface rd including esc specifications 
new features relate concurrency 
synchronization protocol designed readers highly stylized call monitored object paradigm object treated monitor mutual exclusion provided threads operating object procedure interface rd import thread exception failure text type mutex spec var valid map boolean spec var state map procedure getchar rd char raises failure thread alerted spec getchar rd modifies state rd requires valid rd sup ll rd procedure eof rd boolean raises failure thread alerted spec eof rd modifies state rd requires valid rd sup ll rd procedure rd spec rd modifies state rd requires valid rd sup ll rd procedure seek rd cardinal raises failure thread alerted spec seek rd modifies state rd requires valid rd sup ll rd rd simplified basic reader interface 
calls method calls 
mutual exclusion achieved locking object type subtype mutex modula mutual exclusion semaphore type 
acquiring lock equivalent entering monitor 
text interface reflects monitored object paradigm ways 
rd declared opaque subtype root mu tex second monitor entry procedures extra precondition sup ll rd reflects requirement called state legal acquire lock rd advanced reader interface 
basic rd interface simple clients insufficient sophisticated clients 
example hides buffer method buffer insufficient clients implement new classes readers 
shows interface provides specifications needed sophisticated clients 
interface get boiler plate esc specification paradigms start put specification language 
interface begins revealing representation type rd opaque basic interface 
representation object type containing buff field array characters 
modula keyword substitutes name equivalence modula default structural equivalence types 
addition buff field rd contains integer boolean fields 
integer fields determine active portion buffer convention illustrated 
boolean fields irrelevant example 
full interface contains methods show seek method irrelevant example 
spec protect annotation specifies fields reader protected reader thread allowed read write reader fields acquired reader lock 
annotation typical monitored object paradigm 
come specification seek 
method responsible performing class specific computation involved repositioning buffer call rd seek buffer byte number source reader buffer 
particular rd seek rd hi advance buffer data rd hi index byte current buffer data 
method returns ready repositioning successful reader returns eof 
set seek method job risking blocking allowed return 
isn relevant example 
interface import rd thread type ready eof ref array char reveal rd mutex object buff st lo cur hi cardinal intermittent boolean methods seek cardinal false raises rd failure thread alerted spec protect rd buff rd st rd lo rd cur rd hi rd rd intermittent self spec rd seek rd modifies rd state rd requires rd valid rd sup ll rd spec depends rd valid rd rd rd st rd lo rd cur rd hi rd buff spec rep rd valid rd rd iff rd nil rd buff nil rd lo rd cur rd cur rd hi rd st rd hi rd lo number rd buff spec depends rd state rd rd rd st rd lo rd cur rd hi rd buff rd buff rd rd intermittent 
simplified advanced reader interface 
rd lo rd cur rd hi source rd buff rd st reader representation 
esc specification seek method simpler informal functional specification 
specification standard monitored object state validity paradigm 
new point notice precondition sup ll rd sup ll rd reflects design decision seek called internal monitor method called monitor monitor entry method called outside monitor 
spec depends annotations ignored explained section 
spec rep declaration specifies concrete representation variable valid rd 
clients basic rd interface care readers valid don care validity means concrete terms clients care access reader concrete representation 
interface appropriate place declare representation 
spec rep declaration rd valid declares reader valid non nil buffer non nil lo cur hi fields ascending order buffer size ample 
conjuncts formula labeled labels optional including allows esc error messages useful 
illustrates conditions 
interface fairly subtle 
simple idiom valid state exercises features esc specification language 
interface carefully balance requirements simple clients subclass implementations class independent implementation 
designing critical interface inherently difficult 
believe programmer skilled job designing interface specification language 
example 
example story 
student working laboratory research intern written parser parser slow complained authors nelson modula input library inefficient 
nelson asked intern measure performance carefully time going 
intern reported back day wouldn believe time going skipping white space lexer 
nelson said believe report asked lexer skipped white space 
answer module whitespace import rd thread const set char procedure skip rd rd raises rd rd failure thread alerted var ch char repeat ch rd getchar rd ch rd rd skip whitespace 
nelson suggested intern making monitor entry call character efficient import skip white space directly buffer 
intern resisted isn violation abstraction 
believe greg nelson people violate abstraction buffer 
nelson appropriate response intern implemented new version 
reported back tried idea worked 
re right faster 
intern complained interface confusing requested nelson check code 
nelson vivid memory intern program listed 
procedure consists single loop 
loop begins testing rd cur module whitespace import rd thread const set char procedure skip rd rd raises rd failure thread alerted loop rd cur rd hi rd buff rd cur rd cur return elsif rd eof rd return rd seek rd rd cur skip whitespace 
intern attempt writing efficient procedure skips white space 
rd hi 
test succeeds current character buffer tested whiteness skipped necessary 
test rd cur rd hi fails procedure exhausted current buffer finding character 
case loop uses call rd seek rd rd cur advance buffer testing buffer call rd eof rd 
occurred esc written errors intern code removed means 
today run esc code 
running produces error message nil dereference error line rd cur rd hi warning boring just esc way saying useful checking provide specification 
course client supposed call whitespace skip rd rd nil matter rd valid 
get rid spurious error add interface typical specification spec skip rd modifies rd state rd requires rd valid rd running esc produces interesting error race condition reading shared field line rd cur rd hi warning useful program erroneously reads fact writes shared data fields holding lock protects 
surprising intern error 
programmers experienced concurrent programming tendency ignore comments concurrency interface casual testing rarely reveals errors surface 
fix race condition require reader locked entry procedure lock reader inside procedure 
fix preferable whitespace skip monitor entry procedure just getchar eof 
fix error bracketing body procedure lock rd 

time change precondition follows requires rd valid rd sup ll rd forgotten add sup ll rd precondition esc warn possible deadlock lock rd verifier prove legal lock rd entry procedure 
checker gets line complains array index bounds error line rd buff rd cur intern confused stream indexes buffer indexes 
index rd cur stream index enormous 
looking see correction substitute rd buff rd st rd cur rd lo rd buff rd cur 
interesting note array index bounds error detected section error detected ad hoc techniques 
bounds error whitespace skip error caused confusion data structure invariants 
believe theorem proving verification methods esc necessary catch errors 
may bit surprising error revealed intern testing 
presumably tested code standard disk files st files smaller kb reader buffers standard library 
buffer stream indexes buffer indexes agree 
error checker precondition failed line elsif rd eof rd unfortunately common introduce deadlock correcting race condition just locked reader entry whitespace skip 
checker warning attempt call rd eof rd procedure self deadlock 
warning message precondition failure locking level requirement rd eof specified precondition 
fix deadlock observe procedure somewhat inconsistent top loop coded style client advanced interface rdr rep example directly accessing fields reader bottom half coded style client basic interface rd example calling operations rd eof rd seek 
correction code bottom loop style top calling seek method directly 
eof seek procedure calls elsif rd eof rd return rd seek rd rd cur invoke seek method rd elsif rd seek rd cur eof return correction checker finds errors 
concludes second example 
sections describe high level crucial aspects design checker 
tool architecture bird eye view shows diagram major modules checker 
verification condition generator parses type checks annotated program produces logical formula called verification condition 
condition valid program consistent annotations free errors 
condition submitted automatic theorem prover just program verification program verification interest case theorem prover succeeds 
tool post processes theorem prover failures meaningful error messages 
checker programmed modula 
parse type check modula uses olivetti modula front toolkit designed implemented mick jordan 
counting toolkit verification condition generator lines code theorem prover lines code 
system available esc home page web 
generalized data abstraction important property checker works individual modules don need provide complete program 
checker reasons procedure calls method calls specifications implementations 
basic idea reasoning procedure calls preconditions postconditions modifies clauses understood decades basic idea works examples program verification literature standard modula libraries 
annotated program verification condition generator verification condition theorem prover success failure post processor error message block diagram esc tool 
array bounds error nil dereference subrange error narrow fault type cast error functional procedure fails return value exception raises clause case value handled arm typecase value handled arm divide mod zero accessing protected variable lock acquiring locks order precondition violation postcondition violation program invariant violation modifies clause violation errors reported esc 
problem libraries unsafe code low level tricks problem patterns data abstraction richer treated literature 
turned major problem design checker allows modular checking supports patterns data abstraction modern object oriented designs 
overview space sketch kinds difficulties hint solutions fuller treatment refer reader companion abstraction specification revisited 
basic dilemma 
writing specifications multi module program face fundamental dilemma 
specifications require procedure declarations include list variables modified call procedure 
properly modularized program variables modified procedure usually private implementation scope point declaration procedure 
solution abstraction 
solution dilemma data abstraction 
specification describes side effects procedure terms clients terms variables 
concrete variables represent variables confined private scope implementation 
generally representation function private implementation scope 
data abstraction solve basic dilemma important consequences 
downward closure 
consequence data abstraction variables appear modifies lists meaning variable modifies list license modify variable implies license modify concrete variables represent 
example consider implementation rd getchar procedure getchar rd rd char raises failure thread alerted var res char lock rd rd cur rd hi rd seek rd cur eof raise res rd buff rd st rd cur rd lo rd cur return res getchar obviously modifies rd cur rd cur occur modifies list getchar see listing rd interface 
doesn checker complain 
rd cur part representation variable state rd getchar allowed modify 
modifies list modifies state rd getchar downward closed modifies state rd cur rd ellipses stand concrete variables representing state rd 
checker complain updates rd cur getchar modifies list closed verification condition generated 
reader may wonder checker knows variables part representation state rd explained 
protecting related abstractions 
second consequence data abstraction postconditions strengthened protect related abstractions 
see consider question prevents getchar destroying validity reader 
valid rd occur modifies list getchar callers checker reasoning caller trust getchar preserves validity 
getchar allowed modify state reader downward closure allowed modify representation state includes concrete variables part representation valid 
license modify state threatens modify validity 
evidently omission valid modifies list impose implementor obligation proving changes state valid rd unchanged 
checker strengthens postcondition getchar conjunct valid rd valid rd validity destroyed checker complain 
contrived example 
variables represented terms concrete variables scope visible modifies desugared modifies ensures included downward closure related abstraction protected change adding postcondition 
scope visible visible original modifies list modifies remains unchanged downward closure protection related abstractions 
soundness lost 
downward closure protection related abstractions reflected checker semantics data abstraction rules desugaring specifications 
desugaring depends variables represent variables 
knowledge representation information different different scopes desugaring different different scopes 
raises possibility desugaring specification reasoning calls procedure different specification checking implementation 
longer clear checking modules individually ensures composite program free errors 
fact easy see imposing additional conditions hope sound modular checking 
example suppose part representation variable visible scope declaration scope gives clue connection variables 
checker chance reasoning correctly program modifications may affect modifications procedure calls may affect side effect expected checker 
rep visibility requirement 
simple way restore soundness impose requirement call rep visibility requirement part representation variable visible scope representation visible scope 
classic treatment data abstraction hoare implicitly imposes requirement requires representation concrete variables declared 
unfortunately examples modula libraries rep visibility requirement strong 
simple example scope whitespace skip concrete variables represent rd state visible representation 
furthermore awkward place representation declaration state rd scope reasons 
doing esc verification don want get bogged complexities state 
prefer declare representation state rd 
second doing full scale verification representation state reader subclass specific variables part representation scope scope class independent 
infeasibility rep visibility requirement manifest detailed example companion abstraction specification revisited 
explicit dependencies 
introduce new specification language construct depends way specifying variable part representation giving actual representation 
case readers write depends rd state rd rd rd st rd lo rd cur rd hi rd buff rd buff interface 
commit design decision concrete variables part representation state rd deferring decision representation depends visibility requirement 
armed depends weaken rep visibility requirement depends visibility requirement part representation variable visible scope dependency visible scope 
sketch rest story 
hope section reader flavor issues trying produce sound modular checker 
summarizing briefly practical systems programs information hiding ways problematical generate verification conditions sound modular fashion 
key ingredient solution problem explicit declaration dependencies 
full story kinds dependency declarations different requirements imposed different kinds dependencies 
details refer reader companion abstraction specification revisited 
problem area form rep exposure call aliasing 
unable design statically enforceable programming discipline avoiding problem 
best efforts described companion rep exposure 
take view programmer responsibility avoid aliasing 
verification condition generation half code checker devoted task translating annotated modula verification condition vc theorem prover 
task governed classic laws hoare logic demands checker require novel approaches 
usually expounded hoare logic provides framework checking hand constructed proof program property 
proof typically requires invariants control points want vc generation totally automatic 
translate annotated modula version dijkstra guarded commands weakest precondition equations generate vc 
approach provides better foundation automatic tool weakest preconditions calculational flavor hoare logic 
theorem prover novel feature allows checker report specific error messages subformula theorem prover input labeled 
prover finds counterexample emits set labels relevant subformulas false counterexample 
implementation feature described companion automatic theorem prover program checking 
vc generator uses feature labeling proof obligations vc corresponding possible error 
name label encodes source position error type 
straightforward translate failed proofs specific error messages 
translation modula control structures guarded commands quite straightforward effect type system translation interesting 
pre postconditions type declarations contain declarative information program 
checker uses information 
effective precondition procedure requires clause conjoined precondition implicit procedure declaration 
example effective precondition assumed entry body procedure cardinal imply type system guarantees 
slightly subtly consider procedure procedure type contains cardinal type object val cardinal link effective precondition assumed entry body imply val link val link link val 
far defined 
esc theorem prover untyped predicate calculus took expedient inefficient approach encoding modula type system untyped order logic 
example extra precondition assumed body ist ist axiomatized order language theorem prover 
spare reader full complexity axiomatization simplified version ist nil val ist link similarly extra precondition assumed body 
language enforced condition variables values declared types important assumed preconditions parts program including assumed postconditions typecase nar row loops 
full account subject language smaller modula see leino object oriented language axiomatic semantics 
semantic correctness half battle logically equivalent forms verification condition cause heuristic search done theorem prover perform different patterns case analyses dramatic performance consequences 
way guarantee choose slow pattern case analyses luckily straightforward heuristics prevent practice 
neglected issue fact crucial aspect vc generation 
details heuristics see companion automatic theorem prover program checking 
theorem prover experiments larch prover 
prover requires human guidance find proof programmer guide prover proof error revealed failure process 
damien doligez locking error auto flush writers prover mere laborious practical 
wrote theorem prover designed totally automatic powered automatic decision procedures functions predicates important programming particular equality arithmetic 
structure theorem prover follows design ph thesis authors nelson 
important requirement shaped design theorem prover failed proofs lead comprehensible error messages 
particular prover refutation prove verification condition vc prover attempts satisfy vc 
full scale program verification failure satisfy vc implies vc valid program meets specification esc verification satisfaction vc gives error context original program 
systematic exhaustive search techniques identical purpose different 
far time consuming part running checker backtracking search theorem prover 
find checker usually times slower compiler 
slow routinely compilation fast useful 
hardware designers learned worthwhile run simulations design checkers slow run overnight 
think esc offer benefits software hardware 
point comparison programming teams code reviews committee studies program line line 
overnight esc runs cheap comparison 
irritating time taken prover unpredictable 
input prover formula untyped order predicate calculus equality function symbols quantifiers arithmetic mccarthy store select functions 
quantifiers handled heuristic matcher exploits equalities guided user supplied trigger terms 
details theorem prover design described companion 
soundness considered harmful mentioned times failed proofs turned error messages 
proof verification condition succeeds 
case tool useful report output sorry find errors 
demonstrating tool people laugh message want absolutely clear case claim rigorously proved absence errors tool verification engine sources unsoundness included design 
kinds errors try find programmer responsibility avoid 
include arithmetic overflow aliasing see 
possible checker loop invariants generally programmer supplied inferred loop invariants see section mode generate precondition loop weaker true infinite limiting precondition 
verification condition generation unsound 
don view problems plenty errors checker find 
think important engineering judgment decide kinds errors worth checking different costs benefits kind check 
categorically require tool sound means catch kinds errors avoids difficult cost benefit tradeoff retreating mathematical idealization 
breach engineering responsibility 
interestingly theorem prover sound far know vc generation valuable leave kinds errors programmer 
loops important point notice extended examples showed previous sections programmer required supply loop invariants 
esc implements techniques greatly reduce completely eliminate need programmer supplied loop invariants 
technique infers loop invariant static analysis loop body version interpretation method cousot cousot 
fran ois bourdoncle help design implementation part esc 
second technique loop modification inference lmi guesses loop invariant strengthening part enclosing procedure postcondition comes modifies clause 
third technique weaker precondition eliminates need loop invariants considering computations loop executed bounded number times particular times 
apparently crude technique remarkably effective practice 
course sound 
fact example wonderful liberation get dropping soundness 
user activate techniques command line switch 
interpretation switch longer supported 
accounts examples assumed technique 
checking readers writers package described section performed techniques lmi checking resulted spurious warnings 
experience section report experience checker 
looking experiments find checker perform different levels verification esc verifications check absence errors listed locking level verifications check absence deadlocks race conditions functional correctness verifications esc verifications check functional correctness 
levels verification denoted esc ll 
levels verification checks program consistent annotations 
say check prove explained section vc generator leaves certain errors programmer avoid 
averaged source lines annotation overhead increase number lines 
find reasonable price pay additional checking 
standard modula library done esc verification class independent readers code standard reader subclasses 
done locking level verification class independent writers code esc verification writer subclasses 
annotated code available esc home page 
exercise uncover errors library taught things data abstraction described section companion papers 
done experiments turned checker source code 
complicated modules checker simplex part automatic theorem prover reasons linear inequalities 
straightforward detailed module checker recursive descent parser annotation language 
done esc verifications simplex 
specifications wrote ensured absence errors proper shape parse trees constructed 
esc verification func tional correctness list esc 
find errors exercised simplex module 
verifications mature code 
test esc code authors leino nelson write new writer class writer formats output stream judicious insertion line breaks indentation forwards result writer 
short tricky program took days design code 
esc errors violation validity invariant failure declare exception needed propagated self deadlock access shared field holding protecting lock 
fixing errors proceeding test program errors infinite recursion error range esc techniques handled current checker failure format correctly caused missing assignment boolean scope experiment didn try annotate functional correctness 
experiment run esc fresh code leino cormac flanagan write program generates prints random mazes 
esc errors version performed error tested 
shortly leino introduced optimization initialization error esc reported 
conclude experiments fresh code esc catch substantial fraction errors ordinarily detected debugging 
modula windowing library trestle highly concurrent requires careful synchronization 
allan heydon done locking level verification trestle tutorial discovered latent bug 
latent bug difficult find testing strike trestle implementations selection values communicated lazily address spaces 
trestle specification designed allow lazy communication selection values trestle implementations date communicate selection values eagerly 
authors leino working supporting free hand annotations line document viewing system course extended trestle library module called converts polygonal paths smooth cubic splines 
applied esc module errors 
addition library done esc verifications parts standard modula libraries 
code mature exercised error 
addition library generic sequence module glaring error mod code read package files checking level readers writers esc ll os simplex esc esc list esc maze esc rand trestle tutorial ll trestle esc path sequence text fmt total packages checked esc showing package number files lines code lines annotation proportion annotation lines code lines level verification performed 
indented rows show interfaces outside package annotated order check package 
possibility large error exposed testing 
extended annotations sequence perform functional correctness verification reveal errors 
functional correctness verification text module 
presents statistics verifications mentioned section 
surprisingly shows ratio annotation lines code lines noticeably higher functional correctness verification 
esc verifications described necessary annotate interfaces 
example checking module necessary specify path interface 
checking readers writers package trestle tutorial necessary specify number interfaces don list names individually 
includes statistics annotations imported interfaces 
different sort experiment authors detlefs george necula esc reason dynamic reachability linked structures 
hope replace garbage collection explicit deallocation statements check esc explicit safe combining safety garbage collection efficiency explicitly managed storage 
succeeded modest sized programs involving linear lists reasoning required reachability expensive 
approach practical 
aspirations section record cautionary note suggested experience 
important features annotation language nowarn assume 
adding annotation nowarn line suppresses errors type associated line 
annotation assume lets programmer take responsibility holds point annotation 
useful esc emits spurious warning 
nowarn assume feel defeat temptation harder adding specifications convince theorem prover warning spurious 
problem may spend hours days checker validity piece code really doubt 
call problem aspirations 
trained scientists particularly susceptible problem 
example danger aspirations esc verification maze generating program depends fact invariant data structure number equivalence classes positive 
doubt esc dragged proof fact reader looks example web find line spec assume illustrates pragmatic approach advocate 
course nowarn assume features unsound doesn bother 
contrary convinced features essential checker useful 
related don know system semantically thorough automatic systems solved pieces puzzle 
full scale automatic program verifiers include early systems james king peter deutsch stanford pascal verifier verification environment developing programs iterative refinement specifications penelope verification system subset ada coalgebra java verifier loop 
automatic static checkers conventional compiler flow analysis program verification semantically thorough checker example ignore semantics conditional statements 
checkers kind include lclint checks programs annotated version larch daniel jackson aspect novel system warns clu procedures fail update representation variables specified modify nicholas sterling static race analysis tool joseph sema lint tool detecting deadlocks semaphore unix kernel 
approach closest steve german verifier 
german full scale correctness verification order achieve automatic tool 
german integer integer array programs exercised tool realistic concurrent object oriented multi module programs 
early tool influenced german ford pascal verifier 
earliest exposition known goal pursuing dick sites thesis 
agree widespread view tool popular spare users burden annotating loop invariant 
view stimulated large body automatic inference program invariants including pioneering wegbreit systematic theory interpretation introduced cousot cousot 
interesting program checkers interpretation fran ois bourdoncle pascal checker alain deutsch ada checker cormac flanagan scheme checker mrspidey 
explained section implemented experimented version interpretation finding loop invariants experience led better loop invariants altogether synthesize 
goal improving programming productivity served better tools supporting traditional testing runtime checking 
plausible systematic disciplined dynamic checker eraser esc detecting race conditions deadlocks 
area detecting race conditions cilk tool intriguing combination static dynamic checking works fork join synchronization locks 
formal undecidability questions static analysis led programmers conclude reviewing code errors human programmer take accurate account semantics tests updates data structures type checking data flow analysis upper limit semantic analysis compatible automation 
general widely held pessimistic view mistaken adopting technology program verification leaving goals possible build checker achieves unprecedented combination automatic operation semantically accurate analysis 
specific level positive answers specific questions investigating able generate verification conditions realistic systems programs doing required introduce new techniques annotations handling concurrency depends annotation reconciling data abstraction information hiding 
able turn failed proofs specific error messages 
major required theorem prover 
annotation burden minimal 
annotations straightforward inequalities conditions experienced programmer record anyway english comments checker annotation language 
programmer supplied loop invariants required useful checking 
theorem proving carried automatically user guidance 
esc easy type checker feels type checker program verifier 
side theorem prover slow checker routinely build 
unpredictability performance annoying 
mathematical methodological point view interesting outcome project theory dependencies sketched section theory point way sound modular reasoning objectoriented systems 
theory increases understanding structure large programs subtle complicated wish 
today best engineering organizations produce software starting design methods principle yield programs correct construction disciplined testing effort 
optimistic engineering process improved carefully including amount extended static checking 
acknowledgments mark manasse greg nelson designed details locking level notation programming trestle window system 
checker available time hand written hand checked specifications helpful avoiding synchronization errors 
success notation helped spur development checker 
damien doligez performed successful experiment verification conditions generated locking level specifications proved larch prover 
steve glassman esc perform locking level verification readers writers package 
allan heydon performed verification trestle tutorial 
shun tak leung allan heydon provided comments drafts 
project benefited helpful suggestions jim horning raymie stata 
fran ois bourdoncle 
debugging higher order imperative languages 
proceedings acm sigplan conference programming language design implementation pldi pages 
acm sig plan notices june 
guang ien cheng feng charles leiserson keith randall andrew stark 
detecting data races cilk programs locks 
proceedings tenth annual acm symposium parallel algorithms architectures spaa pages june 
cousot cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
conference record fourth annual acm symposium principles programming languages pages 
david detlefs rustan leino greg nelson 
rep exposure 
research report digital equipment systems research center lytton ave palo alto ca july 
available www research digital com src publications src rr html 
david detlefs greg nelson james saxe 
automatic program checking 
appear 
peter deutsch 
interactive program verifier 
phd thesis university california berkeley berkeley ca 
edsger dijkstra 
discipline programming 
prentice hall englewood cliffs nj 
david evans john guttag james horning yang meng tan 
lclint tool specifications check code 
sigsoft proceedings second acm sigsoft symposium foundations software pages 
software engineering notes december 
extended static checking home page compaq systems research center 
web www research digital com src esc esc html 
christopher farrell 
industry outlook 
business week pages see especially page january 
cormac flanagan matthew flatt shriram krishnamurthi stephanie weirich matthias felleisen 
catching bugs web program invariants 
proceedings acm sigplan conference programming language design implementation pldi pages 
acm sigplan notices may 
stephen garland john guttag 
lp larch prover version january 
available www sds lcs mit edu larch lp overview html 
steven german 
automating proofs absence common runtime errors 
conference record fifth annual acm symposium principles programming languages pages 
donald 
mechanical proofs computer programs 
hoare shepherdson editors mathematical logic programming languages pages 
international series computer science 
prentice hall 
polak 
formal verification ada programs 
ieee transactions software engineering september 
john guttag jim horning 
lcl larch interface language 
research report digital equipment systems research center lytton ave palo alto ca july 
available www research digital com src publications src rr html 
hoare 
axiomatic basis computer programming 
communications acm october 
reprinted chapter 
hoare 
proof correctness data representations 
acta informatica 
reprinted chapter 
hoare jones editors 
essays computing science 
international series computer science 
prentice hall 
jim horning bill kalsow paul mcjones greg nelson 
useful modula interfaces 
research report digital equipment systems research center lytton ave palo alto ca december 
available www research digital com src publications src rr html 
daniel jackson 
aspect detecting bugs dependences 
acm transactions software engineering methodology april 
bart jacobs joachim van den berg marieke huisman martijn van 
reasoning java classes preliminary report 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla pages 
acm sigplan notices october 
johnson 
lint program checker 
computer science technical report bell laboratories murray hill nj 
mick jordan 
extensible programming environment modula 
sigsoft proceedings fourth acm sigsoft symposium software development environments pages 
software engineering notes december 
james king 
symbolic execution program testing 
communications acm july 
james king 
program verifier 
phd thesis carnegie mellon university pittsburg pa september 
joseph 
sema lint tool analyzing semaphore usage multithreaded unix kernel 
proceedings winter usenix conference pages 
usenix association january february 
rustan leino 
reliable modular programs 
phd thesis california institute technology pasadena ca january 
technical report caltech cs tr 
rustan leino 
object oriented programming language axiomatic semantics 
fourth international workshop foundations object oriented languages january 
proceedings available www cs williams edu kim fool fool html 
rustan leino greg nelson 
abstraction specification revisited 
internal manuscript digital equipment systems research center 
appear src research report 
see author phd thesis 
nancy leveson clark turner 
investigation accidents 
ieee computer july 
luckham german von henke karp milne oppen polak scherlis 
stanford pascal verifier user manual 
technical report stan cs stanford university 
mark manasse greg nelson 
trestle manual 
research report digital equipment systems research center lytton ave palo alto ca december 
available www research digital com src publications html 
mark manasse greg nelson 
trestle tutorial 
research report digital equipment systems research center lytton ave palo alto ca may 
available www research digital com src publications src rr html 
john mccarthy james painter 
correctness compiler arithmetic expressions 

schwartz editor proceedings symposia applied mathematics 
american mathematical society 
john nagle scott johnson 
practical program verification automatic program proving real time embedded systems 
conference record tenth annual acm symposium principles programming languages pages january 
charles gregory nelson 
techniques program verification 
phd thesis stanford university stanford ca 
see 
greg nelson 
combining satisfiability procedures equality sharing 
bledsoe loveland editors automated theorem proving years volume contemporary mathematics pages 
american mathematical society providence ri 
greg nelson 
generalization dijkstra calculus 
acm transactions programming languages systems 
greg nelson editor 
systems programming modula 
series innovative technology 
prentice hall englewood cliffs nj 
greg nelson derek oppen 
simplification cooperating decision procedures 
acm transactions programming languages systems october 
parnas 
criteria decomposing systems modules 
communications acm december 
reprinted www acm org classics may 
stefan savage michael burrows greg nelson patrick sobalvarro thomas anderson 
eraser dynamic data race detector multithreaded programs 
acm transactions computer systems november 
appears proceedings sixteenth acm symposium operating system principles pages operating system review 
richard sites 
proving computer programs terminate cleanly 
phd thesis stanford university stanford ca may 
technical report stan cs 
nicholas sterling 
static data race analysis tool 
proceedings winter usenix conference pages 
usenix association january 
stoy strachey 
os experimental operating system small computer 
part ii input output filing system 
computer journal 
turin deutsch gonthier 
la des programmes ariane 
pour la science january 
french 
ben wegbreit 
property extraction founded property sets 
ieee transactions software engineering september 

