solving sha analysis problems languages destructive updating mooly sagiv thomas reinhard wilhelm university wisconsin universitat des saarlandes concerns static analysis programs perform destructive updating heap allocated storage 
give algorithm conservatively solves problem finite shape graph approximate possible shapes heap allocated structures program take 
contrast previous method accurate certain programs update cyclic data structures 
example method determine input program searches list splices new element possibly circular list output possibly circular list 
concerns static analysis programs perform destructive updating heap allocated storage 
addresses problems looked depending point view problems problems storage analysts shape analysis problems type checking problems 
information obtained useful inst ante generating efficient sequential parallel code 
emphasize application approach shape analysis problems 
goal shape analysis give program point finite characterization possible shapes program heap allocated data structures point 
illustrate approach means running example apply analysis technique program uses destructive updating operations reverse list 
example illustrates connection shape analysis type checking demonstrates sufficiently precise shape analysis algorithm able verify destructive reverse program return list argument list 
application leave ibm israel scientific center 
part dose visiting tile universit des supported sfi vlsi design methods parallelism tile ul 
ts david packard science engineering tile national science foundation ccr oo tile defense advanced research projects agency arpa order monitored tile office naval research contract address computer science department west dayton madison wi usa 
sagiv reps wise edu 
kel ger 

cs 
uni sb de 
permission digital hard copies part material personal classroom granted fee provided copies distributed pro commercial advantage copyright notice title date appear notice copyright permission acm copy republish post servers redistribute lists requires specific permission fee 
popl st petersburg fla usa acm 
pointer analysis alias analysis problems discussed section 
develops new shape analysis algorithm provides conservative information possible shapes heap allocated structures program take 
certain programs including ones significant amount destructive updating takes place algorithm able verify shape preservation properties 
examples properties include input program list output list ii input program tree output tree iii input program circular list output circular list 
instance method determine list ness preserved list reversal program performs reversal destructively updating input list ii list insert program searches list splices new element list 
furthermore method determine list insert program preserves circular list ness 
surprising capabilities 
previously developed methods graphs solve problems capable determining list ness preserved examples examples similar complexity jm jm lh cwz str 
previous open question precision obtained method uses graphs model storage usage 
furthermore far know shape analysis type checking method graphs principles hn hen lr deu cbc deu ability determine circular iist ness preserved list insert program 
method allows obtain qualitatively better results mentioned programs previous methods 
detailed examination differences algorithm previous algorithms deferred section brief characterization differences follows previous methods allocation sites name jm cwz 
allocation site information imposes fixed partition memory 
contrast approach deliberately drops information concrete 
indirect connection run time locations shape graph nodes named possibly empty set 
variable set shape graph node shape graph program point consists variables execution sequence point run ime cation 
shape analysis methods method clusters collections run time locations summary nodes 
approach nodes pointed variables clustered single node 
chase wegman zadeck observed analysis method handle programs list reversal program cause lacks wav materialize summarize sum mary nodes cer ain key points analysis cwz pp 

shape node naming scheme allows method materialize copies summary node non summary nodes pointer variable assigned previously summarized run time location 
analysis assignment component say cdr nil method removes cdr edges 
previous methods remove edges str heuristics remove edges certain conditions jm lh cwz 
unusual characteristic method enabled node naming scheme technique 
sharing information increase accuracy primitive operations method 
specifically keep track shape nodes may target pointer heap 
example linked data structure traversed say loop containing assignment cdr sharing information improve precision materialization operation allows algorithm determine points list element iteration 
limited form sharing information jm cwz allow met determine fact 
shape node names provide information method determine unshared occurs program performs insertion list 
chase wegman zadeck method node shared remains shared forever 
programs operate lists trees non graph method hendren hen able determine shared node unshared 
method handle data structures contain cycles 
experimental implementation analysis method created examples prepared aid implementation 
remainder organized follows section introduces terminology notation rest 
section presents concrete semantics language destructive updating terms shape graphs nodes represent run time locations 
section introduces domain static shows approximate sets shape graphs arise collecting semantics 
section summarizes extensions basic approach 
section discusses related 
due space constraints omitted discussions elaborations extensions basic approach ii proof semantics static shape graphs safe wit respect concrete semantics 
material srw :10.1.1.152.1240
terminology notation integer real boolean constructor selector operations nil cons car appropriate predicates equal atom null 
assume read statement reads just atom entire list tree graph program represented control flow graph set vertices set arcs 
unique start vertex assume predecessors 
vertices oft control flow graph represent statements predicates program usual way st denotes statement predicate vertex normalization assumptions 
expository convenience assume programs normalized meet conditions constructor selector performed statement 
expression cons executed steps allocate cons cell assign new temporary variable ii assign car component iii assign cdr component 
statement variable occur left hand right hand side 
statement form nil preceded assignment form nil 
allocation statements form new opposed sel new 
vertex pointer manipulation performed st forms nil sel nil new sel sel 
implementation putting program form meets assumptions carried preprocessor 
note number temporary variables introduced meet restrictions worst case linear size original program 
normalization assumptions essential simplify presentation 
example assumption allows separate kill aspects statement nil gen aspects selo assuming points nil semantics 
see figures 
example shows program performs list reversal destructive updating program normalized form control flow graph program normalized form 
list initially pointed variable transformed reversal 
eration points reversal successively longer prefix original list 
simplify formulation analysis method stated single fixed arbitrary program 
set pointer variables program denoted var 
language assume working imperative language meets general description program consists assignment statements conditional statements loops repeat read statements write statements goto statements 
language provides atomic data treatment procedures discussed section 
shape graphs concrete semantics defined terms single unified concept shape graph tbe presentation couched terme tile lisp primitives manipulating heap allocated storage 
tl due basic limitation ocl extends readily tile case pointers userdefined types tl nave fields 
points unshared list vi nil nil nil nil cdr cdr od nil nil ix tl nil points unshared list nil nil os tl cdr nil nil nil tl nil vii cdr nil tl cdr nil viz cdr cdr nil cdr od tl nil nil ti nil nil program program normalized form program labeled control flow graph 
defined follows definition shape graph directed graph consists nodes called shape nodes kinds edges variable edges selector edges 
shape graph represented pair edge sets ev eu graph set variable edges form pvar shape node 
es graph set selector edges form sel shape nodes sel car cdr overload symbol ev mean function returns eu successors 
ev eo 
similarly shape node sel car cdr sel es sel sel es 
intended meaning clear arguments am supplied 
sg eu define shape 
nodes sg follows shape nodes sg eu 
class shape graphs zs denoted 
note shape graph sg shape nodes sg uniquely defined consists set non isolated nodes sg nodes touched edge 
reason explicitly list node set specifying shape graph 
shape graphs arise concrete semantics language somewhat different characteristics ones arise semantics 
fact defined shared root concept definition helps defining abstraction relation relates see definitions 
concrete semantics section result execution sequence shape graph represents state heap allocated storage memory 
case shape node represents unique run time location variable eu singleton set say empty 
furthermore 
car cdr represent run time locations pointed car cdr fields singleton sets empty depending fields point allocated locations properties captured definition definition shape graph deterministic zf pvar leo zz shape node sel car cdr es sel 
class shape graphs denoted ds 
places operation eliminate shape nodes reachable program variables 
definition gc zs defined gc eu il ej sel sel path selector edges zn ea concrete semantics section concrete semantics deterministic shape graphs represent memory state sg shape nodes represent cons cells meaning assignment statement deterministic shape graph transformer 
concrete semantics define concrete collecting semantics associates set possible shape graphs point program 
contains semantic equations concrete semantics 
meaning statement st function st mg dsg ds 
examining equations bear mind normalization assumptions section statements executes known left hand side evaluates nil 
equations need handle gen aspects statements semantics 
kill aspects handled equations 
dsg transformers listed cover kinds pointer manipulation statements dsg transformers predicates assignment statements perform pointer manipulations identity function 
design concrete semantics somewhat nonstandard 
part store concrete semantics keeps track heap allocated storage furthermore interpret predicates read statements assignment statements perform pointer manipulations 
assumptions build small amount abstraction concrete semantics 
consequence static shape graphs concrete shape graphs collecting static shape graphs semantics non deterministic es car cdr may yield set shape node 
addition static shape graphs bounded size 
achieved naming scheme shape nodes name shape node possibly empty set program variables general abstraction function clusters multiple concrete shape nodes single static shape node 
concrete semantics st dsg ds 
shape graph transformer associated predicates assignment statements perform pointer manipulations identity function 
term denotes operation generates new shape node new run time location 
assumptions collecting semantics may associate control flow graph vertex concrete dsl case start conventional concrete semantics 
assumptions patently safe take space justify 
simplicity introduce garbage collection operations concrete semantics eliminate nodes reachable program variables 
dereferences nil pointers ignored 
handled srw :10.1.1.152.1240
turn collecting semantics 
controlflow graph vertex paths set paths control flow graph start predecessors definition collecting semantics cs dsg defined follows definition static shape graph pair sg shared sg shape graph 
set shape 
modes sg subset pvar 
zs shared type shape nodes sg fake true 
class shape graphs denoted ss 
definition impose order ssgs sg sg sg contains edges sg 
definition sg shared sg el shared 
ordering ssg sg sg shape nodes sg zs shared shared 
cs st wk 
st lns 
paths domain ss complete join semi lattice join operator defined sg sg eu shared zs shared 
semantics section shape analysis technique uses restricted subset shape graphs called summarize possible shapes heap allocated storage take 
example suppose points element list list reversal program 
column shows arise vertex 
summarized representations shown column 
value computed semantics graph shown iteration row column 
example graph exactly union graphs shown column 
el static shape graphs defined section abstraction function defined section semantics section 
reverse program running example 
section explains reasons accuracy analysis method shows method capable handling insertion element arbitrary point linked list 
abstraction function task section define abstraction function relates domains vsa ssg 
formally defining abstraction function definition illustrate semantic properties ssgs 
column shows arise vertex iterations loop list reversal program input list element list 
column shows corresponding values ssgs 
note column shape node nz represents unique run time location corresponding dsg column location pointed variables collection ssgs abstractions different arise different loop iterations nz general denote different run time locations 
example shape node represents run time locations arise iterations respectively 
iter 
dsg dsg approx 
sequence ce 
tl tl tl ii il nit el tl il tl tl ml tl tl ee fixed point reached 
nit columns show corresponding ssgs mapped arise vertex iterations loop list reversal program input element list 
column shows ssg values takes process finding solution equations semantics 
shape nodes ssgs value zs ed false 
ii contrast shape node nd represent mm time single dsg 
example iii ssg column iteration row represents run time locations le dsg column 
ssg column iteration row represents run time locations 
different ssgs run time location may represented different ssg shape nodes 
instance consider ssgs column top bottom order 
location represented shape nodes location represented nd tll location represented tl 
important draw examples incorrect think shape node representing fixed partition memory 
ideas keep mind variable set shape node program point consists variables execution sequence point run time location 
going ssgs deliberately drop information concrete locations keep information indicates sequence variables point location 
consequence abstraction different shape nodes nx ny represent configurations variables na ny possibly represent information dsg 
means structural invariants hold ssgs arise abstraction process invariant equality tness edge points nx sei ny 
example ssg column iteration row selector edge cdr satisfies 
ssg contain selector edge cdr nf il 
invariant ii lf shared true node conditions hold exists selector edge ton 
nd represent multiple locations single edge represent selector edges dsg 
exist selector edges different shape nodes say zl case may exist dsg includes selector edges run time location pointed set variables runtime location pointed set variables 
exist selector edges different selectors single shape node 
illustrate conditions shared 
converse invariant ii need hold sharing information stored explicitly ssgs 
example ssg column iteration row shared false exists selector edge nd selector edge 
case fact shared nd false indicates incoming edges represent ds edges simultaneously point dsg node 
abstraction function defined definition auxiliary functions definitions definitions 
definition defines operation renaming shape nodes 
function abstraction function semantics 
definition sg ev shape graph shape nodes sg false true shape nodes sg nx pvar functions 
define projection operations respect follows ev eu jf sel sel es lf nx eu es jf 
definition abstraction function dsg shape nodes dsg nx pvar defined follows ze shared dsg shape nodes dsg false true defined follows induced 
shared dsg es abstraction function ss defined dsg gc dsg dsg shared dsg jq dsg core definition operation projection respect dsg 
function dsg establishes relationship nodes dsg corresponding nodes ssg 
example consider iteration row 
column dsg node pointed program variables tl mapped dsg ssg node tl see column 
dsg nodes pointed directly variables mapped ssg node 
general dsg generates finite set ssg nodes priori unbounded number dsg nodes dsg 
projection operation collapses dsg smaller set nodes preserving aspects structure 
say shape node nx represents shape node dsg dsg nx 
function shared dsg checks node predecessors dsg 
projection performed respect dsg ssg node sharing value true dsg nodes represents predecessors dsg 
aspect dsg illustrated example 
hand projection function dsg sets sharing value ssg node nz false means dsg node nodes represents predecessor 
example consider iteration row 
ssg column represents run time locations exactly predecessor dsg see column 
consequently shared nd 
note role gc operation appears definition dsg contains shape node predecessors filtered affect thevalue shared 
example definition provides way identifying shape graph data type 
shows represent kinds types 
foreach dsg indicated classes sg approximates graph shown 
moment ignore graph 
reason approximates shape analysis algorithm conservative algorithm shape graphs produced may superfluous edges 
algorithm reports variable points circular list may point non circular list algorithm reports variable points non circular list point circular list 
kind conservative approximation appropriate example parallelizing compilers hg 
extension basic technique allows circular structures identified 
see section new new new cdr sgi 
fi sg mt cdr nil interpretation meaning function ss ssl pointer manipulation statements 
operations manipulate variable edges selector edges sharing information alias information maintained shape node names ssgs 
shown ssg transformers conservative respect concrete semantics defined see sr 
key property semantics assignment operation crest es ss conservatively covers possible new configurations variable sets members point run time location dsg shape node 
permits unusual treatment static analysis algorithm statements form selo nil 
algorithm processes statement removes selo edges emanating points 
call operation strong 
example shows simple example illustrates strong 
note statement branch conditional point run time location 
reflected sg fact point single shape node 
sg union sgi point sg 
sg represents runtime locations pointed occurs execution sequences safe semantics statement cdr nil eliminate edge see sga 
note rs merged sg possible perform strong run time location pointed cdr edge emanating node points 
sg ii program illustrates strong 
discuss individual cases meaning function illustrating important features shows final ssgs computed program point interpretation destructive list reversal program 
block indicates shape memory just program point label appears bottom block 
text top block indicates preceding program point points control flow graph action taken 
example predecessor statement nil 
reading helpful skip remainder section proceed directly section assignment nil projection operation rename shape nodes removing name 
note may cause distinct shape nodes merged 
example 
transition block vt block assignment tl nil causes merged 
assignment nil ssg transformer removes selo selector edges called strong 
variable set shape node ssg consists variables execution linked list tree arbitrary graph possibly cyclic list possibly cyclic list possibly cyclic list length length length see section ssgs represent kinds data types 
shape nodes ssgs value shared false 
graph nodes shared 
sequence point run time location met hod remove selo selector edges 
example 
transition vii removes cdr 
important aspect ssg transformer selo nil way information shape node names reset sharing information 
invariant ii abstraction process described section 
resetting sharing information ssg transformer illustrated list reversal program shared false shape nodes shape graphs arise 
issue discussed section assignment new new unshared node created 
shape nodes unaffected 
assignment shape node names example 
see transition block block 

ssg transformer assignment selo elaborate operation 
reason selo may point nodes create ssg conservatively covers possible new configurations variable sets members point run time location dsg assignment 
selo points need materialize copy nz producing new node zu old node nz 
defining materialization operation goal cover conservatively possibilities time introduce superfluous edges prevent semantics able verify interesting properties variable points list 

see transition block vs block vq node il materialized 
reflect fact pointing pointed addition follows shape node points new variable edges added reflect assignment 
node nz pointed selo ma new node direct tl er shape analyses tl statement precisely handle precisely certain circumstances 
claiming od able treat statements precisely 
tbe inevitable loss precision intrinsic static analysis occurs tile treatment statements tile form se points statements tbe form selo nil 
particular tl ssg transformer selo node materialization operation create shape 
nodes tl conservatively cover tbe possible new configurations variable sets members point tile run time location 
edges zu 
old variable edges point assignment 
occur transition block vs block 
new variable edge 
see variable edge block vq 
selo selector edge 
edge replaces old selo selector edge emanates ny nil ss eu ts shm cd gc ev zs shared anx selo nil sg ev ej ts shared es nx selo nd shared shared zl zz jz nz car nz cdr new ss shared ev shared fake ify dcf el el shared ev es ts 
nz ssg shared el ny ny ej shared selo ss es ts shared selo 
zu nz 
ny selo ny selo nz ee disjoint equal assign selo nz ny selo zu old new zu se nw zv sel selo nz sel nw es new old lj sel sel selo shared nz assign ny selo nz sel nz es nw zu sel selo ts shared nz old nw sel es shared nz shared new new new selo ssg shared shared equa nx ny nx ny shared zs shared equal 
sel sel ny ssg meaning function st ssg ss ssl statement st assignment see old new nz shared node 
see new new case selector edge cdr qtl case 
occur transition block 
selector edge block ws block added old new case selector edges old predecessors nz cause directly cyclic selector edges handled new new case 
edge selo materialized ny selo selector edge 
see new new case 
occur transition block block vo 
suppose selector edge selo nz 
nz sel selector edge set materialized nz sel ny selo represent edges simultaneously exist dsg 
happen need connected simultaneously coexist selo selector edge ny see second old new case 
take advantage variables shape node names particular predecessor nz name incompatible ny 
occur transition block vs block lx 
connect old successors nz selector edges sel selo see start vl nil cdr qz tl qx vi vs nil wn 
tl wx tl tl tl nil tl 
nil 
tl va tl cdr 
nil wg nit vii cdr nil ri tl tl vii tl nil viz nil 
qt qt final ssgs computed control flow graph vertex interpretation destructive list reversal program block corresponds column iteration row 
shape nodes ssgs 
value shared false 
new ald case 
occur transition block block 
operation dis oint ssl eliminates selector edges points satisfy invariant abstraction process disjointness property variable set names selector edge points described section 
filter edges transition block vx block 
assignment selo selo added shape nodes pointed shape nodes pointed addition nodes pointed selector edge assignment considered shared nodes 
example 
see transition block viz block vq 
semantics associates ssg iz 
equationally defined fixed point ordering defined definition system equations sg se start sg ca sg fixed point equations iteration starting 
false 
example final values vertices list reversal program control flow graph shown 
things information tells value list program see block vi value list program see block vi 
column shows ssgs computed vertex 
list reversal program successive iterations fixed point finding procedure 
final value vertex graph shown iteration row column 
elements graph interpreted follows shape nodes represent head list points 
tl 
represents situation points head list happens iteration loop 
represents situation point head list 
shape node represents head reversed list points 
shape node represents list sublist list points 
shape node nd represents run time locations tails lists point 
shape nodes graph value zs shared false 
fact ts shared fake tells number interesting things memory state dsg produced execution sequence ends vertex implies selector edges point node consequently tails component common 
similarly pair different run time locations tail selector edges run time locations point node 
consequently variables point acyclic lists share storage common 
complicated semantic equations theorem proof srw reassuring theorem correctness theorem controlflow graph vertex cs :10.1.1.152.1240
analysis algorithm achieves interpretation defined section yields new shape analysis algorithm finding information possible shapes heap allocated structures program take 
certain programs including ones significant amount destructive updating takes place algorithm able verify properties 
examples properties include input program list output list ii input program tree output tree iii input program possibly circular list output possibly circular list 
instance able conclude information reported algorithm list reversal list ness see 
algorithm le determine list ness preserved list insert program searches list splices new element list 
circular list ness preserved list insert program 
precisely ert program possibly cyclic list length see program possibly cyclic list length see 
details see srw appendix 
instructive consider main reasons shape analysis algorithm able produce accurate information list reversal program 
analyzing program key issue algorithm keep list separate list aspects algorithm contribute successful handling problem 
cutting list 
clear cut aspect removal cdr selector edges cdr nil strong transition block block viz 
cuts list head separating element tail ti point 
tl summary node nb 
equally important way algorithm handles advancement tl list tl cdr transition vs 
os cdr points node materialization operation causes new shape node fl materialized shape analysis list reversal program crucial interaction aspects 
suppose example transition blocks os shape node tl materialized variable merely set point variables point refer nd tile primordial soup tl process node suc tl node tile soup 
nd 
removal cdr selector edges transition separate node points list pointed tl case 
transition viz set cdr field cdr field points nd points 
stage lists longer known separate lists 
note differently things turn materialized transition tl point transition cdr field set cdr field points nb point 
nb occurs tail tail shared false know lists share storage common point disjoint acyclic lists 
operations discussed cutting list advancing pointer list main operations list manipulation algorithms 
third fourth common list manipulation operations splicing new element list removing element list cases handled accurately algorithm shape nodes tem shared 
illustrated list reversal program discussed paragraph 
points strength approach algorithm handles basic list manipulation operations remarkable degree precision similar tree circular iist manipulation operations 
turn issue information names reset shape node sharing information true false 
ability main reason algorithm able determine list insert program preserves iist ness circular list ness 
situation arises list insert program vertices vm control flow graph new element spliced list 
assume program shown points unshared list length points new element inserted 
key step transition viz cdr nil 
immediately preceding transition vii vl see figures cdr assigned value adds new selector edge causes shar ed set true shape graph 
ssg transformer covers case assignments form cdr nil information shape node names reset sharing information 
particular meets conditions shared true vertex ts shared reset false 
see 

interesting note assignment cdr cdr nil shm ed reset false incoming selector edges cdr 
cdr 
consistent concrete seman ics shape node names vi tell cdr nf vi cdr qt incompatible 
know vl represent nodes exist dsg 
explains condition cdr nil case 
cdr nil od cdr cdr cdr cdr nil nil nil nil nil cdr nil nil cdr nil ij od nil cdr cdr nil cdr cdr nil cdr nil nil nil nil vi vio viz nil nil cdr nil cdr nil cdr nil nil nil program searches list splices new element list 
extensions merging shape nodes number shape nodes ssg bounded unfortunately pathological programs number shape nodes grow large limited experience date suggests arise practice 
possible overcome problem making widening operator merges selected shape nodes 
means guarantee fixed point equation section polynomial time widening operator simply applied necessary limit cardinality shape node name sets chosen constant 
similar spirit limiting jm produce accurate results limiting cardinality name sets preserves structural information graph 
details srw :10.1.1.152.1240
iy 
tl shape graph vertex vi 
graph shm ed tl ake 

shape graph vertex viz 
graph shared true shown bold 
inserted just second apply shape analysis algorithm 
third look ssg computed vertex see aliases 
approach determine possible sharing components heap allocated data structures precisely kind information needed able compile programs take advantage coarse grained parallelism 
see srw :10.1.1.152.1240
interprocedural analysis method extended handle procedure calls conservative way 
fundamental problems need resolved representing multiple occurrences local variable mutually recursive procedures 
accounting different calling contexts procedure occur 
approximate local variables recursive calls intro duce extra variable local variable variable representative copies scopes 
shape nodes name sets contain barred variables new kind summary node 
represent multiple runtime locations single dsg 
ideas extended semantics handle procedure calls returns 
second problem resolved known interprocedural techniques sharir pnueli sp 
example simple conservative solution consider procedure call goto called procedure return procedure goto statements follow invocation accurate solution determined shape graph transformation function procedure 
eel edn shape graph vertex vm 
graph false 
shape graphs vertices wi list insert program 
illustrate shared reset false shape graph vertex jm 
finding aliases sharing possible shape analysis algorithm determine pointer variables possible aliases just vertex testing point common shape node ssg 
point common node conservatively conclude may aliases 
possible extend test access paths may aliases follows instrument original program additional temporary variables say tl code advance tz pointer access paths question 
code representing definitely circular structures ssgs defined section elements represent fields nodes point atoms nil uninitialized 
consequence algorithm able determine weak datatype properties 
pointed example algorithm reports variable points circular list may point non circular list 
type circular list really means possibly circular list 
introducing additional nodes nil accurate type properties obtained cases 
impose invariant ssgs fields shape nodes going possibly consequence refinement modified domain ssgs capable representing definitely cyclic data structures 
example extension ssg shown represents definitely cyclic list length mod absence edges car fields shape nodes represents definitely cyclic list length represents cyclic list length 
related shape analysis problem originally investigated reynolds lisp language destructive updating rey 
reynolds treated problem simplifying collection set equations 
similar problem imperative language supporting non destructive manipulation heap allocated objects formulated independent ly jones muchnick treated problem solving finding fixed point collection equations regular tree grammars jm 
jones muchnick began study shape analysis languages destructive updating 
handle languages formulated analysis method associates program points sets finite shape graphs guarantee analysis terminates programs containing loops jones muchnick approach limits length acyclic selector paths chosen parameter nodes horizon clustered summary node 
limiting approach inherent drawbacks analysis yields poor results programs manipulate elements horizon 
example list reversal program little useful information obtained 
analysis algorithm model happens program applied lists length greater tail list treated conservatively arbitrary possibly cyclic data structure 
number possible shape graphs doubly exponential addition jones muchnick limiting number subsequent papers hpr 
jones muchnick sets shape graphs jm follows jones muchnick jm larus hilfinger lh lar chase wegman zadeck cwz str developed methods associate program point single shape graph 
single shape graph possibly accurate method sets graphs leads compact representations lead practical shape analysis algorithm 
jones muchnick jm chase wegman zadeck cwz str similar methods shape nodes correspond program allocation sites 
methods efficient methods discussed earlier theoretical perspective cwz 
algorithm ase wegman nd zadeck ideas sharing information form heap counts characterize shape graphs represent list structures heuristics introduced allow maintained allocation site 
selo assigned selo points represents unique run time location selo section tile term tile generic sense meaning finite graph structure approximate tile shapes run time data structures 
idea augmenting information appears tile earlier jones jm 
selector edges emanating shape node points overwritten called strong update 
chase wegman zadeck algorithm able identify properties cases instance determine program appends list list preserves list ness 
noted chase wegman zadeck allocation site information insufficient determine interesting facts programs 
example determine list ness preserved insert program reverse program 
particular reverse program chase wegman zadeck algorithm reports points possibly cyclic structure structures point possibly share elements common 
major technical differences algorithm chase wegman zadeck algorithm lead improvements accuracy obtained algorithm strong assignment selo chase wegman zadeck method ordinarily performs weak update selector edges emanating points accumulated 
performs strong update certain specialized conditions 
algorithm normalization assumptions section assignment statement selo transformed statements selo nil followed immediately selo algorithm processes statements removes selo edges emanating points 
called operation strong bv analogy strong date 
es second st 
es selo edges emanate shape node points 
taken effect overwrite selo edges emanating shape node points words statement original program form selo algorithm performs strong update 
example 
sgs tz gl separate nodes 
represents run time locations pointed safe semantics perform strong see sg 
reason possible algorithm perform strong strong updates assignment operation semantics creates ssg conservatively covers possible new configurations variable sets members point run time location dsg shape node 
name ssg shape node represents dsg node selo field definitely overwritten 
materialization assignment statement form selo algorithm materializes new shape nodes conservatively cover possible new configurations variable sets members point run time location 
example selo points nd algorithm materializes new node rz 
furthermore alse information exclude possible selector edges xl 
programs loop containing assignment cdr traverse unshared linked list technique permits method determine points unshared list element iteration 
instance occurs transition block va block 
explained section materialization tz li block key aspects algorithm allows determine list reversal program preserves list ness 
chase wegman zadeck algorithm lacks operation recognize lack stumbling block accuracy method cwz pp 

chase wegman zadeck count values boolean valued shared value 
represent significant difference ssgs selector edges allow recovering distinction incoming edges incoming selector edge ts shared fake 
method framework interpretation allows prove algorithm obtained conservative respect concrete semantics 
chase wegman zadeck give informal arguments correctness algorithm 
ad hoc features chase wegman zadeck method changes necessary reformulate interpretation 
inst ante rules give join operation complicated fact result joining shape graphs depends program point operation applied 
reason join misnomer sense 
contrast join operation essentially graph union join operation lattice ssgs defined section 
larus hilfinger lh lar devised shape analysis algorithm somewhat different principles aforementioned 
algorithm labeled auxiliary 
glance node labeling scheme appears general set label node regular limited longer chosen constant representing paths may lead instance node 
shape node labels add information representation pointer access expressions reconstructed graph stripped node labels 
contrast labels sense represent regular expressions length contribute essential information representation variable set shape node nx know strong strong update performed selector edges emanating nx 
possible worthwhile extend technique complicated shape node names kind larus hilfinger 
interesting examples length labels algorithm achieves greater accuracy larus hilfinger algorithm matter value chosen example larus hilfinger algorithm able determine programs list reversal list insert programs preserve list ness 
algorithms finding may aliases shape graphs sophisticated ones landi ryder lr deutsch deu deutsch algorithm particularly interesting certain programs manipulate lists offers way representing exact infinite set may aliases compact way 
shown deutsch algorithm yields may alias information list reversal program equivalent produced algorithm section 
landi ryder deutsch algorithms determine list ness list ness preserved insert program 
reason due lack strong operation algorithms infer assignment cdr nil program shown cuts list pointed see figures 
mean imply method dominates landi ryder deutsch algorithms exist programs deutsch algorithm accurate algorithm 
different approach taken hendren designed algorithm handles acyclic data structures hn hen choice programs manipulate acyclic structures algorithm way representing cycles conservatively 
alias analysis problem efficient algorithm manipulates matrices record access paths aliased 
best knowledge hendren algorithm algorithm detect insertion element list respectively tree preserves list tree structure 
design hendren algorithm determine structure preservation properties programs handle cyclic lists 
myers algorithm interprocedural bitvector problems accounts aliasing mye 
shape analysis algorithm algorithm keeps track sets aliased variables 
conjectured practice sizes alias sets remain small myers handle heap allocated storage destructive updating 
algorithm significantly simpler able show precise 
contrast undecidable give precise solution problem absence procedure calls lan ram 
acknowledgments grateful helpful comments alain deutsch christian neil jones laurie hendren provided extensive helpful information capabilities analysis technique 
aw 
interprocedural heap analysis parallelizing imperative programs 
shriver editors programming models computers pages 
ieee press september cbc 
choi burke 
efficient flow sensitive interprocedural computation aliases side effects 
acm symposium principles programming languages pages cwz dr chase wegman 
analysis pointers structures 
sigplan conference programming languages implementation deu der hen hg hn hpr jm jm lan lar lh lr mye ram deutsch 
model aliasing abstractions finite representations right regular equivalence relations 
ieee conference computer languages pages 
deutsch 
interprocedural may alias analysis pointers limiting sigplan conference programming languages design implementation 
hendren 
parallelizing programs recursive data structures 
phd thesis cornell university jan 
hendren gao 
designing programming languages analyzability fresh look pointer data structures 
proceedings international conference computer languages pages 
hendren nicolau 
parallelizing programs recursive data structures 
ieee transactions parallel systems january 
hendren nicolau hummel 
abstractions recursive pointer data structures improving analysis transformation imperative programs 
sigplan conference programming languages design implementation pages june 
horwitz pfeiffer reps dependence analysis pointer variables 
sigplan conference programming languages design implementation pages 
jones muchnick 
flow analysis optimization lisp structures 
muchnick jones editors program flow analysis 
theory applications chapter pages 
prentice hall jones muchnick 
flexible approach interprocedural data flow analysis programs recursive data structures 
acm symposium principles programmmg languages pages 
landi 
undecidability static analysis 
acm letters programming languages systems 
larus 
restructuring symbolic programs concur rent execution multiprocessor 
phd thesis university california 
larus hilfinger 
detecting conflicts structure accesses 
sigplan conference programming languages implementation pages 
landi ryder 
pointer induced aliasing problem classification 
acm programming languages pages 
myers 
precise inter procedural data flow algorithm 
acm principles programming languages pages 
plevyak chien karamcheti 
analysis dynamic structures efficient parallel execution 
banerjee gelernter nicolau padua editors languages parallel computing volume lecture notes computer science pages portland august 
springer verlag 
ramalingam 
aliasing acm transactions programming languages systems 
rey reynolds 
automatic computation data set definitions 
information processing proceedings ifip congress pages new york ny 
north holland 
sp sharir pnueli 
approaches interprocedural data flow analysis 
muchnick jones editors program flow analysis theory applications chapter pages 
prentice hall 
srw sagiv reps wilhelm :10.1.1.152.1240
solving problems languages destructive updating 
technical report tr computer sciences department university wisconsin wi july 
available www url www cs wisc edu trs html 
str 
lattice interpretation dynamic lisp structures 
information computation november 

