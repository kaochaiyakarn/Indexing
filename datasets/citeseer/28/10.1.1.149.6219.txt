open corba benchmarking hwu pd adam charles university faculty mathematics physics department software engineering prague czech republic phone fax mails petr mff cz adam mff cz benchmark suites corba brokers targeted broker vendor user audiences respectively 
vendor suite result benchmarking projects industrial partners covers entire functionality corba broker 
user suite simplified give overview basic factors influencing broker performance complemented approach tailoring results specific system mode operation prohibitive loss precision 
keywords corba middleware benchmarking 
corba emerged middleware architecture object communication heterogeneous distributed environments 
architecture developed established industrial standard need assessing performance implementations apparent 
response need number benchmarking projects appeared 
differed aspects including benchmarked functions environment setup results presentation 
interpretation relating different benchmarks difficult 
problem identified omg benchmarking request information received number responses summarized omg white benchmarking 
white styles step uniform benchmarking methodology applied various omg technologies focuses outlining issues related benchmarking planning 
take shape benchmarking framework methodology repository public benchmark algorithms tool automated benchmark execution 
plans materialized far white voices conviction contributors need benchmarks open understood easy measure 
typical benchmarking projects attributes considered secondary importance 
projects done response particular needs involved parties needs rarely include openness 
projects short publishing complete results complete methodology complete sources 
published project results generally difficult interpret relate 
attempt remedy gap generalizing experience area benchmarking corba middleware gathered projects mlc systeme deutsche post com bull soft iona technologies 
chapter open benchmark suite evaluating performance corba middleware 
chapter follow guidelines executing suite reporting results 
chapter discuss portability benchmark results demonstrate publishing results 
open benchmark suite obvious goal open benchmark suite cover commonly broker functionality 
goal potential yielding large suite goes requirements understood easy measure benchmarks expressed 
tackle problem consider different target audiences benchmark results broker vendors broker users broker vendors represent audience uses benchmarks mainly assess performance particular broker identify performance related bug bottleneck evaluate performance impact modification done broker development 
satisfy requirements benchmark suite needs cover possible aspect broker performance detail including aspects specific particular broker implementation 
benchmark results technical people reading familiar technical details broker implementation 
broker users represent audience uses benchmarks mainly understand performance expected broker particular application decide broker implementation architect application available broker performance 
satisfy requirements benchmark suite needs easily understandable people reading necessarily experts broker architecture performance 
benchmark results simplified generalization important clearly note cases 
audiences occasionally benefit benchmark results targeted audience principal difference significant warrant separate benchmark suites 
text describe individual aspects broker performance 
aspect describe vendor suite measures identify acceptable simplifications obtain user suite 
simplifications done suite easy understand code execute time keep informative 
analyzing data collected benchmarking projects selecting simplifications loose important information 
sake brevity descriptions kept minimum necessary person familiar corba understand benchmarks measure illustrated selected results 
invocation benchmarks vendors basic invocation benchmarks measure distribution delivery roundtrip times simple method invocation arguments available invocation modes broker 
results graph depicting statistical distribution delivery roundtrip times graph depicting regular interference patterns results 
ov xv distribution roundtrip time dynamic invocation linux dual intel pentium iii mhz mb ram wlp regular fluctuations roundtrip time static invocation linux intel pentium mhz mb ram users specific broker implementation delivery roundtrip times typically close absolute values statistical distribution regardless invocation mode 
acceptable simplification results benchmark uses single invocation model 
brokers support quality service settings additional benchmarks developed test individual policies 
current brokers support quality service settings refer reader specific quality service research attempt simplify benchmarks particular case 
marshalling benchmarks vendors marshalling benchmarks measure dependence delivery roundtrip times simple method invocation type encapsulation size direction arguments 
reduce number combinations benchmarks measure method invocations pass instance basic data types directions methods 
smaller set representative basic types selected benchmarks measure invocations pass instances inside arrays sequences structures unions value types methods type 
results graph table depicting delivery roundtrip times type encapsulation direction 
wlp ri delivery roundtrip times array types direction static invocation linux dual intel pentium iii mhz mb ram measure dependence delivery roundtrip times size data smaller set representative basic types selected benchmarks measure invocations pass growing number instances inside arrays sequences 
results graph depicting dependency delivery roundtrip times size data 
separate marshalling benchmarks measure dependency proxy creation times number existing proxies number supported proxy classes 
wlp ri roundtrip time growing sequence octet direction static invocation linux amd mhz mb ram wlp dispatcher benchmarks vendors dispatcher benchmarks measure dependence invocation times simple method invocation complexity interface method belongs complexity object adapter hierarchy instance belongs servant registration policy number servants registered object adapter 
complexity interface influencing factors number methods interface length method name 
complexity object adapter hierarchy influencing factors width depth 
lead straightforward benchmarks results graph depicting dependence invocation times factors 
servant registration policies interesting performance point view retain policy searches map active servants invocation 
leads straightforward benchmark results graph depicting dependence invocation times number servants registered retain map 
broker implementations algorithms exhibit best worst case behavior differs significantly typical case perform operations described section 
benchmarks take care measure report ordinary extraordinary behavior possibly box whisker graphs usual line graphs 
ri typecode indirection roundtrip time direction static invocation windows nt sp intel celeron mhz mb ram users specific broker implementation delivery roundtrip times typically vary significantly type encapsulation direction data 
acceptable simplification omit results benchmarks measure impact factors 
notable exception passing character data environment code page conversion introducing extra overhead 
delivery roundtrip times typically depend linearly size data 
acceptable simplification results benchmark uses single type encapsulation direction data 
notable exceptions passing large number instances value types delivery roundtrip times depend number instances behavior typecode indirection graph traversal mechanisms 
min max median value roundtrip times void ping increasing number servants static invocation linux dual pentium iii mhz mb ram users influence interface object adapter hierarchy complexity smaller importance influence number registered servants tends exhibit complex interfaces object adapter hierarchies 
acceptable simplification results benchmark measures influence number registered servants 
parallelism benchmarks vendors parallelism benchmarks measure dependence invocation times simple method cation number threads number clients issue handle invocations parallel 
invocation times perceived individual threads benchmarks measure invocation rate perceived system 
invocation times perceived single thread grow thread blocked waiting thread describe degree parallelism achieved invocation 
invocation rate perceived system increases ability system parallel execution gets increasingly exploited point fully exploited invocation rate slowly decreases overhead associated parallel execution increases 
results graph depicting dependence invocation times invocation rate number threads number clients issue handle invocations parallel 
wlp ri roundtrip time void ping increasing number threads static invocation linux dual intel pentium iii mhz mb ram depending specific broker implementation parallelism benchmarks need run times extended cover threading strategies 
distribution system capacity individual threads needs evaluated 
users simplification stems fact benchmark large number clients issue invocations difficult execute 
local setup load generated clients interferes server 
network setup network bottlenecks 
cost maintaining benchmarking environment capable executing large number clients parallel trivial 
keep benchmark suite easy execute include benchmarks multiple threads multiple clients 
miscellaneous benchmarks broker provides functions directly related invocation 
typical examples insertion extraction data string allocation dynamic inspection 
straightforward benchmarks functions incorporated vendor suite significant included user suite 
vendor suite outlined section provides detailed overview factors influencing broker performance 
evolving form successfully benchmarking projects formed basis ejb benchmark suite 
user suite outlined section provides rough overview basic factors influencing broker performance 
implemented brokers suite proved easily portable typically requiring change lines code broker 
implementation available ms mff cz bench 
executing reporting paramount criteria executing benchmarks reporting results relevancy repeatability 
benchmark needs relevant measurements reflect typical modes operation repeatable target audience able reproduce results 
results benchmarks described section immediately relevant sense considered mode operation corresponds trivial problem domains 
chief differences testing individual performance factors separately testing background load testing ideal network conditions 
combining performance factors typical approach providing relevant results adjusting benchmark executes mixture operations similar executed existing applications 
difficult broker typical modes operation importance performance factors vary significantly 
approach characterize specific mode operation terms individual performance factors combine results individual benchmarks characterization 
performance factors considered user suite size invocation arguments number registered servants number active threads 
size arguments adds overhead represents time spent marshalling transporting arguments 
number servants adds overhead represents time spent marshalling transporting longer object looking larger tables 
overheads additive sense adding extra arguments servants invocation means adding overhead invocation time 
number threads adds scaling factor represents degree parallelism invocations 
knowing typical size invocation arguments number registered servants number active threads specific mode operation results individual benchmarks combined form estimated relevant result simple formula estimated time simple size size servants servants threads threads simple simple invocation time section size invocation time arguments size section servants invocation time servants section threads invocation time threads section 
estimate assumption factors largely orthogonal 
measurements indicate condition holds factors start influencing exhaustion shared resources 
precision estimated relevant result opposed measured illustrated 
wlp wlp ri roundtrip times void ping increasing number threads static invocation linux dual pentium iii mhz mb ram wlp ri roundtrip times void ping increasing number servants static invocation linux dual pentium iii mhz mb ram incorporating background load mode operation observed performance broker varies background load 
suggested background load needs incorporated benchmark relevant 
measurements done regular processor intensive network intensive load created background processes show background load exhibits predictable increase invocation times inversely proportional percentage processing power scheduled benchmarks 
effects irregular background load incorporated benchmark results easily 
simplest way obtain precise results irregular background load conditions running benchmark suite 
ri roundtrip time growing sequence octet direction static invocation linux dual pentium iii mhz mb ram lines different numbers background processes incorporating network conditions congested network conditions influence particular broker implementation benchmark results tends quickly overshadowed influence network delays 
majority brokers communicates iiop top tcp ip implemented operating system protocol stack best measure behavior congested network conditions existing methodology tcp ip benchmarking 
reporting results report results benchmarking suite follow proven full disclosure approach specifying configuration information sufficient reproduce results 
results report contain description benchmark de scription form results reported explanation results signify simplifications apply benchmark 
example description single benchmark 
typecode indirection desc test measures typecode indirection mechanism prevents duplication giop messages 
called interface typedef interface void arr array filled instances types characters long 
dependency invocation time number identical types array measured 
graph graph depicts dependency invocation time number identical passed 
axis gives number instances passed array type axis gives invocation time 
result dependency observed orb typecode indirection mechanism 
gradually decreasing dependency exhibited 
report typecode benchmark portability results point usual approach benchmarking benchmark results tied specific hardware platform operating system compiler libraries considered 
answering basic question fast broker run system approach fails answer important questions target audience ask fast system need get specific performance specific broker fast application broker run systems customers compare benchmark results different brokers running different systems 
answer questions benchmark results particular broker need abstracted influence system benchmark executed 
general approach abstraction process basically consisting modeling execution benchmarked system mixture primitive operations execution times combined yield execution times benchmarked system suggested operating systems research domain 
basic questions need answered approach primitive operations usage particular primitive operation benchmarked system 
typically answered analysis system calls machine instructions benchmarked system profiling 
precision reported example error error 
selecting primitive operations trying apply abstraction process broker benchmark confronted fact broker system different benchmark execution 
requiring selection profiling primitive operations done combination broker system break principle designing benchmark easy measure 
problem chose select primitive operations executed broker regardless particular implementation 
primitive operations selected analysis experimental profiling broker implementations cover execution time memory allocation selected block sizes counts memory block move selected sizes blocks thread lifecycle operations selected thread numbers thread synchronization blocking socket data transport selected sizes blocks remaining execution time spent various general purpose operations 
simple benchmarks obtain execution times primitive operations integer arithmetic benchmark provide approximation general purpose operations 
weighting primitive operations profiling determine weight primitive operations combined result leads number technical problems 
include inability profiling tools correctly completely report system library calls separate profiles depending call arguments profile code symbol information 
profiling statistical analysis number collected measurements 
approach uses principal component analysis determine number independent factors contributing collected measurements uses incremental regression select primitive operations contribute combined result calculate weights 
important reasons exist limiting number primitive operations number independent factors determined exist collected measurements 
larger number primitive operations want larger number measurements needs collected statistical analysis done 
second attempt increase number primitive operations number independent factors causes incremental regression try minimizing error function precision collected measurements warrant reality 
yields false weights appear improve precision collected measurements weights cater random fluctuations reflecting reality applying new measurements fail 
set primitive operations selected vector weights weights calculated results broker benchmarks system vector primitive operation timings ops known estimated simple linear combination ops weights 
straightforward application approach calculating weights specific broker implementation benchmark predicting benchmark result systems primitive operation timings known 
extended compare performance broker implementations 
approach select suitable system primitive operation timings performance requirements known 
wlp ri roundtrip time growing sequence octet direction static invocation linux amd mhz mb ram linux dual pentium iii mhz mb ram approach tested experiment running fall 
public suite benchmarks posted ms mff cz bench web site brokers interface participants submit results benchmarks executed system 
submitted results contained system configuration information timings primitive operations broker benchmarks 
filtering duplicate submissions submissions distorted background load results test precision abstraction 
systems ranging amd dx mb ram dual cpu intel pentium iii mb ram approach predicts broker performance typical mean error worst error rarely exceeding worst error rarely exceeding primitive operations 
surprisingly approach fails predict performance shared resources exhausted 
case represent typical mode operation sufficient just warn prediction failure occurs 
done measuring basic resource usage broker memory consumed proxy servant threads consumed connection warn prediction done cases exhaust shared resources 
wlp ri lv roundtrip times void ping increasing number servants static invocation linux amd mhz mb ram linux dual pentium iii mhz mb ram uses portable results approach port performance results answer questions raised section significantly useful usual approach benchmarking 
requires collecting measurements different systems 
means outside usual possibilities single broker user easily measure portable results 
experiment public suite benchmarks suggested realistic idea set public web site results benchmarks targeted broker user audience collected 
serving repository code results benchmarks site data provide portable comparable results verify submitted results checking compliance predicted ones 
setting web site ms mff cz bench 
benchmark suite broker vendor audience outlined section provides detailed overview factors influencing broker performance suc benchmarking projects companies mlc systeme bull soft iona technologies 
knowledge published outline benchmark suite corba broker attempts cover entire functionality broker complementing specialized benchmarks focus example quality service guarantees 
basis ejb benchmark suite 
benchmark suite broker user audience outlined section provides rough overview basic factors influencing broker performance 
line suggestions omg white benchmarking suite easy execute easy port different systems 
relevant sense outlined section results adjusted reflect particular mode operation provides understanding broker performance issues 
suite implemented brokers available ms mff cz bench 
approach porting benchmark results suggested tests wide range systems shown provide precise performance estimates 
approach benchmark results deduce system requirements performance requirements compare performance brokers running different systems purposes usual benchmark lend 
approach verified platforms 
conclude show possible generalize corba broker benchmarks relatively small suite results tailored specific system mode operation prohibitive loss precision 
authors members distributed systems research group charles university headed professor ek pl il cooperation benchmarking projects industrial partners providing feedback allowing results research purposes 
object management group orbos ptf benchmark rfi omg bench callison butler real time corba trade study boeing corba testbed www ch corba benchmarks results www com oi lo pd tech 
report ksi charles university mitre open systems center proposal orbos ptf benchmarking corba scalability omg bench chung france telecom cnet response benchmark rfi omg bench university helsinki response orbos ptf benchmark rfi omg bench object management group white benchmarking omg bench ma il enterprise java beans benchmarking tech 
report ksi charles university ejb comparison project final report public distribution version charles university prague corba comparison project extension final report charles university prague corba comparison project final report charles university prague schmidt gokhale evaluating corba latency scalability high speed atm networks ieee icdcs corba omg formal schmidt overview omg corba messaging quality service qos framework report sigs march schmidt evaluating architectures multithreaded corba orbs cacm mogul brittle metrics operating systems research proceedings hotos henning spec cpu measuring cpu performance new millennium ieee computer july spec cpu www spec org tpc council policies www tpc org seltzer smith zhang case application specific benchmarking proceedings hotos saavedra smith analysis benchmark characteristics benchmark performance prediction acm transactions computer systems brown decompositional approach performance evaluation harvard university computer science tech 
tr harman modern factor analysis university chicago press ryan schmidt kuhns parsons pyarali levine evaluating policies mechanisms support distributed real time applications corba journal theory practice object systems wiley sons aslam mir benchmark metrics enterprise object request brokers proceedings tools 
