type safe multithreading cyclone dan grossman computer science department cornell university ithaca ny cs cornell edu extend cyclone type safe polymorphic language level abstraction threads locks 
data races violate type safety cyclone 
extended type system statically guarantees absence enforcing thread shared data protected locking data escape thread creates 
extensions interact smoothly parametric polymorphism region memory management 
formal machine models need prevent races polymorphic type system machine supports thread local data corresponding type safety result 
categories subject descriptors programming languages language constructs features concurrent programming structures polymorphism logics meanings programs semantics programming languages operational semantics general terms languages keywords data races types cyclone 
writing safe robust low level code difficult writing safe robust low level multithreaded code difficult 
particular takes great care avoid data races thread accessing data thread writes data single race leave data inconsistent research supported part afosr 
opinions findings recommendations expressed publication author necessarily reflect views agency 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
january new orleans louisiana usa 
copyright acm 
state 
races occur testing static systems prohibit races valuable 
cyclone needs race detection cyclone type safe polymorphic programming language close date cyclone allowed single threaded programs domain cyclone prove useful low level legacy systems style data representation resource management multithreaded applications 
reason extending cyclone type system prevent data races useful programmers 
preventing data races important target architecture update source level pointer atomically data race corrupt pointer violates type safety 
translate pointers machine addresses cyclone situation arises shared memory multiprocessor ensure atomic writes memory words 
system atomic access pointers insufficient safety require writing multiple words intervening access 
example cyclone programmers define struct types field holds bounds information array field points 
updating records refer shorter longer arrays important feature forbid access bounds information describe array 
short compelling reasons type system guarantee absence data races 
programs supposed races static assurances increase reliability 

updating may atomic implementation races corrupt pointers 

type safety require writes multiple memory locations thread reads 
perspective designing type safe language optional mandatory reasons peculiar cyclone deserve consideration safe low level multithreaded language 
lock types rescue determining multithreaded program data races trivially undecidable sound type system enforce mutual exclusion access shared memory 
flanagan abadi freund designed systems small simply typed imperative language object calculus java :10.1.1.111.9953:10.1.1.143.5635
implementation java system analyzes large programs needs sparse code annotations races 
inspired multithreaded cyclone rest explains adapt extend approach language 
flanagan main contribution collection type systems enforce discipline programmers assign data object lock thread hold access data 
enabling typing technologies singleton lock types quantification lock names held lock effects 
section explains concepts cyclone terms 
brief compile time lock names run time locks 
lock type pointer type includes lock name 
lock types lock name describe runtime lock term singleton 
pointer type lock name indicates lock mediates access pointed data 
syntax directed static analysis checks thread accesses data holds appropriate lock 
quantified types functions polymorphic lock names data structures locks guard data 
function types include effects describing locks callers hold function call 
crucial practical addition notion thread local data 
memory need lock type system enforce thread uses memory 
thread local data rule exception 
data programs easier write efficient 
boyapati lee rinard system race prevention java allows lock name parameters instantiated special name thread local data :10.1.1.1.5802
way library clients pass thread local shared data 
contributions type system contributions applying previous safe language 
second order type system 
cyclone parametric polymorphism complicates language held lock effects ways object types 
fortunately solution analogous earlier integrating polymorphism explicit memory management effects useful particularly caller locks idioms 

callers pass special nonlock thread local data callees callee locks idiom 
addition allows code reuse boyapati system requiring simple unsynchronized test thread local case 

cyclone threads safe despite manual memory management 
combination static dynamic checks prevents deallocating memory thread resorting garbage collection thread shared data 
issue independent data races important 

simple kind system classifying types lock names memory region names collects additions coherent type language 
technical contribution low level machine type system type safety proof capture features described memory object oriented systems restricted form dependent type idea similar 
management 
formalism includes proof language thread local data 
machine dynamic semantics type safety requires absence data races mutation takes steps 
intervening access thread go wrong previous prevented races machines races violate type safety 
rest proceeds follows 
section describe basic type system multithreaded cyclone 
sections extend system integrating polymorphism region memory management 
section sketches implementation necessary run time support 
section describes formal system modeling multithreaded cyclone type safety 
section describes limitations system address 
section discusses related 
section concludes 
currently implementing multithreaded cyclone 
thorough practical evaluation remains 

race free cyclone section extensions cyclone multithreading 
assume familiarity focusing cyclone sophisticated type system 
take liberty convenient symbols cyclone ascii syntax 
aim statically enforce mutual exclusion shared data 
synchronization explicit programmer 
allow libraries operate shared local data 
represent data access memory exactly singlethreaded programs 
allow accessing local data synchronization 
avoid interprocedural analysis 
multithreading terms support multithreading add primitives statement form cyclone 
primitives cyclone types implement entirely library written spawn function takes function pointer pointer value size value 
executing spawn evaluates sz respectively copies fresh memory pointed new executes new thread 
spawned thread terminates returns spawning thread continues execution 
copy points shared copy shallow local new thread 
newlock function takes arguments returns fresh lock 
locks mediate access shared data shared object lock thread hold accessing object 
explained type system connection objects locks 
nonlock constant serves 
acquiring nonlock run time effect 
purpose provide value real lock unnecessary corresponding data local 
statement sync evaluates lock nonlock acquires lock executes releases void int void lock plk int sync plk struct lkint lock plk int void struct lkint plk void lock lk newlock int new int new struct lkint new lkint plk lk spawn sizeof struct lkint lk nonlock void lu int void lu lock plk int sync plk struct lkint ls lock plk int void lu struct lkint lkint plk lk ptr lk ptr void lk newlock int new int loc new struct lkint loc new lkint plk lk spawn sizeof struct lkint lk nonlock example 
left side shows code skeleton little type information 
uses features new produces pointer new memory holding result lkint plk struct fields plk holding results respectively 
right side shows legal cyclone program optional annotations 
lock 
thread hold lock time acquisition may block thread releases lock 
note cyclone prevents deadlock 
left side uses constructs includes type information expect legal cyclone 
accesses callers hold appropriate lock shared 
lock needed call long plk lock function spawns thread function lock lk pointer 
threads increment lk mediates access 
thread local safe pass nonlock 
just call 
multithreading types key extension cyclone type system lock names exception type level variables describe run time locks 
lock names exist run time 
lock type lock lock name 
key restriction include lock names pointer types example int 
allow dereferencing pointer type type checker ensure thread holds lock type lock 
absence data races follows lock existing 
thread local data fits system having special lock name loc 
give nonlock type lock loc annotate pointers thread local data loc 
allow dereferencing pointers reachable argument spawn 
type variables lock names loc scope 
introduce lock names universal quantifiers existential quantifiers type constructors capture important idioms 
functions universally quantify lock names callers pass pointers different lock names 
example instantiate functions right side lock name 
section explains kind annotations ls lu 
instantiation implicit 
examples instantiates type second instantiates loc 
function type effect set lock names written parameters callers hold 
example function empty effect really means loc effects key enforcing locking discipline program point assigned current effect called capability :10.1.1.1.3704
function entry point function effect 
statement inherits effect enclosing statement sync type lock sync adds current effect type allow current effect 
similarly function call type checks current effect instantiation superset callee effect 
example call type checks caller holds necessary lock 
type newlock ls lock exists lock name lock name 
usual unpack called open value existential type 
declaration lk newlock unpack 
introduces variable lk lock name 
scope rest code block 
lk bound new lock type lock 
unpack lock multiple times names acquiring lock term type lock permit dereferencing pointers lock name 
existentials important user defined types 
type struct lkint example pointer lock name lock plk 
name existentially bound type definition 
newlock struct lkint value requires unpack pattern form binds lk plk giving lk type lock ptr giving ptr type int 
form struct lkint value fields types consistent respect implicit instantiation 
existential types example need mutual exclusion noted previous 
suppose threads share location type struct lkint 
thread mutate struct assigning different struct lkint value hold different lock 
mutation safe thread uses shared struct mutation progress point plk changed 
type definitions lock name parameters 
example list int values struct lst lu lu int hd struct lst tl defines type constructor applied lock names produces type 
thread local data struct lst loc loc choice 
universal quantification functions lists operate thread local data 
different locking idioms 
example prototypes int length lu lu struct lst int sum lu lu struct lst int sum lu lu struct lst lock void append lu lu lu struct lst struct lst length suppose computes list length caller acquires lock list spine length access list elements 
caller locks idiom sum sum uses hybrid idiom caller acquires elements lock sum presumably acquires spine lock 
suppose append mutates argument appending copy second argument spine 
lists different lock names spines precisely append copies second spine 
length elements accessed 
multithreading kinds known typing technologies ameliorate restrictions lock names impose 
techniques apply naturally treat lock names types describe locks values 
kinds distinguish ordinary types lock names 
sense lock names kind types kind reasons described section 
fact kinds sharable unsharable 
lock name lock newlock creates kind ls lock name loc kind lu 
kind ls lu lock name kind lu 
subsumption check calls lk ptr lk example 
prevent thread local data reachable argument passed spawn memory kinds 
example kind kind kind ls 
general type kind contain kind lu 
expected au 
bit polymorphism give spawn type void spawn lu void loc sizeof kinding ensures shared data uses locking 
effect new threads hold locks 
effect spawn copies second argument points 
type sizeof explained section 
ensuring thread local data unreachable arguments spawn necessary safety 
making restriction part kind system simpler uniform approach ad hoc rules limit spawn restriction holds 
example instantiate spawn type struct lkint type existentially bound lock name definition kind ls 
term lkint plk nonlock ill formed nonlock type lock loc struct lkint requires lock name kind ls 
default annotations type system requires lock name pointer type lock type effect function 
practice simple techniques vast majority annotations optional 
function effect omitted filled lock names appearing parameters types 
words default caller locks idiom 
second lock names optional 
filled depends context function bodies unification engine infer lock names 
function parameter return types generate fresh lock names include default effects 
discuss options lock names generate 
top level functions implicitly universally quantify free lock names 
type definitions loc 
third default sharability kinds note inference intraprocedural 
techniques fill defaults function bodies 
maintain separate compilation 
different strategies generating omitted lock names function prototypes different benefits 
generate different lock name unannotated pointer type 
strategy function calls typecheck 
prototype explicit locking annotations function body type check returns parameter assigns parameter assign different parameters location 
second loc omitted lock names 
solution advantage single threaded programs type check multithreaded programs global variables 
section discusses global variables require locks 
means programmers extra annotations write code safe multithreading callers acquire locks 
strategies useful cyclone support convenient syntax 
possibility pragma changes strategy pragmas change meaning prototypes programs difficult humans understand 
example strategy techniques allow abbreviated prototypes void int void lock plk int struct lkint ls lock plk int void struct lkint void lock names variables optional 

integrating polymorphism cyclone parametric polymorphism lets function operate values unknown types implementation duplicating code passing types run time 
type system bit complicated typical polymorphic languages nonuniform data representation 
describe locking disciplines polymorphic code need describe locks necessary access value unknown type 
section explains necessary additions 
cyclone polymorphism section describe polymorphism universal quantification types single threaded cyclone 
language existential quantification types type constructors type parameters polymorphism suffices explaining interaction locks 
function calls argument second void app void usual callers instantiate appropriate type argument type expects 
cyclone kind boxed imposes restriction instantiated pointer type int cyclone integers pointers size type variable kind restriction lets implement app code duplication run time type information basically types kind size calling convention 
type variables restriction kind 
kind change app writing type app formed kind adding level indirection void void programmers control data representation distinction boxed unboxed types natural inability cast struct type void 
final extension lets give types primitive library routines spawn need size value unknown type sizeof unary type constructor 
value sizeof sizeof callers spawn pass correct size 
sizeof ill formed size known 
polymorphism locks resolve issues type variables multithreaded cyclone 
prevent thread local data data guarded loc thread shared 

extend effects ensure polymorphic code uses proper synchronization 
hinted solution issue previous section type kind includes sharability addition sharability means type describe thread local data 
actual definition inductive type syntax sharability means part type kind bu au lu 
combining parts type kind richer types bs bu au bs bu au bs au 
sharability necessary spawn code uses sharability extend effects reconsider function app effect effect parameter describe effect know takes kind bu 
give app effect app unusable thread shared data assume holds locks caller passes acquire 
solution introduces locks new form effect represents effect consisting lock names type variables occurring 
give app type void app bu void locks locks instantiate int effect means call app hold locks int 
example polymorphic function calls app current effect include locks 
including locks effect function type universally quantifies describes caller locks idiom 
described section idiom want programmers omit explicit effects 
default effect polymorphic function includes locks type parameters 
app example omit effects 
fact short hand bu au polymorphism poses problem type checking single threaded code multithreaded code 
write polymorphic code callee locks idiom wrong example void app bu lu void locks lock lk sync lk want call app locks held acquires lk calling expresses connection current effect app calls locks effect 
solution enriches function preconditions constraints form effects 
constraint means current effect sound include current effect example write void app bu lu void locks lock lk locks sync lk call current effect constraint cover effect locks omit 
callers app establish constraint instantiate respectively know locks locks 
support instantiating needs caller held locks sophisticated type void app bu lu au void lock lk locks locks locks locks add type level effect variables represent unknown set locks locks 
described previous introducing effect variables explicitly typed language inconvenient programmers especially types 
type gave app shows programmers simulate effect variables locks 
summary polymorphism compelled add way describe lock names unknown type locks way bound lock names locks 
features express locks thread hold value unknown type 
choice default effect programmers usually ignore additions 
needed polymorphic code callee locks idioms 
dually show need existential types caller locks idioms 

integrating regions far described multithreaded cyclone data deallocated 
garbage collection maintain illusion cyclone region memory management gives programmers finer control 
section give flavor region system quite analogous locking system combining systems allows threads share data 
cyclone regions briefly review cyclone region system 
data object allocated region objects region deallocated simultaneously 
regions come flavors heap region conceptually lives forever 
practice garbage collected 
stack region corresponds local declaration block lifetime lexically scoped allocation occurs created 
dynamic region created region region deallocated control leaves execution bound region handle 
dynamic allocation primitive takes handle 
heap region predefined handle 
handles types form region region name type variable kind region 
heap handle type region 
region created region type region 
stack regions handles region names usually generated automatically type checker 
handles exist run time region names 
pointer types include region name region point 
type system prevents dereferencing pointer region name indicates corresponding region may deallocated 
function effect indicates regions live calling function 
describe regions necessary access type constructor regions locks 
example unnecessary explicit effects app function previous section type void app void regions locks regions locks lock names explicit region names unnecessary 
nature regions induces subtyping region bounds region region sound cast int int outlives 
write regions mean region reachable value type outlives 
bound true live suffices establish effect regions 
function types region bound preconditions hold call sites 
correspondence static systems regions locking striking 
singleton types locks handles type variables different kinds decorating pointer types locks regions describing requirements types sync region gaining access rights loc available resources 
regions subtyping locks region lifetimes fixed order lock acquisitions 
regions locks basic constructs regions locking compose pointer types carry region names lock names 
accessing memory requires region live lock held 
issues orthogonal objects region different locks different regions lock introducing type level variables stand region name lock name reduce burden explicit annotations orthogonality needed 
interesting interaction ensuring thread access region thread deallocates 
impose stricter type spawn 
prevent spawned thread accessing memory spawning thread deallocates region bound ensure shared data reach heap spawn recall uses quantify type second argument points add region bound precondition regions solution sound thread shared data heap 
add expressiveness introduce 
typecheck spawn type region function quantifies region name precondition regions 
words new argument handle indicating shared value region bound 
way share stack pointer threads 
doing safely impose overhead local variables cyclone programmers expect fast 
handle call corresponding region live spawning thread deallocated spawned thread terminates 
section explains run time system maintains invariant 
remaining complication subtyping described cyclone allows casting long outlives 
means deallocate region named threads spawned handle terminated 
dynamic region run time system support added complication efficiently stack region 
prevent casting stack pointers dynamic region point ers calls enrich region kinds kinds new sharability definitely sharable rs rd ru 
stack region name kind rd programmer chooses rs ru dynamic region name 
region name describes live region point region named created introduce outlives kind rd kind rs 
handle passed region kind rs 
singlethreaded cyclone programs type check choosing rd dynamic region names 

run time system run time support cyclone basic thread operations simple 
gcc compiler backend 
garbage collection heap region collector course support multithreading 
newlock sync spawn operations easy translate operations common thread packages posix threads 
translate nonlock distinguished value sync checks trying acquire lock 
cost check small check required reentrant locks 
add kind ld describe loc kind omit checks nonlock complication unnecessary 
nonlocal control jumps returns exceptions minor complication thread release lock sync acquired control transfers outside scope sync 
jumps returns compiler insert correct lock releases checks nonlock 
exceptions maintain thread run time list locks acquired installing exception handler 
interesting run time support implementation deallocate region thread done 
necessary information dynamic region handle contains list live threads including thread created 
thread list live dynamic region handles created 
list sorted lifetime 
lists internally thread shared run time system uses locks mediating access 
maintain lists follows 
starting spawned thread add handle thread list 
spawned thread terminates remove handle thread list 
handle thread list empty handle youngest handle list deallocate region remove handle handle list recur older handle handle list 

region executing create region add handle young thread handle list add executing thread handle thread list 
control leaves remove executing thread handle thread list 
handle thread list empty handle youngest handle list deallocate region remove handle handle list 
dynamic regions thread creates continue lifetimes 
stack regions deallocated dynamic regions created restrict region subtyping 
note lists doubly linked add amortized cost region 

formalism formal machine corresponding type safety result models interesting issues regarding cyclone data race detection 
omitted details appear author dissertation :10.1.1.143.3991
formal machine simplifications order focus safe multithreading 
importantly memory part single heap lives forever 
regions local variables executing variable binding allocates new heap location 
types form sizeof 
spawn statement copy value type version spawn difficult implement 
polymorphism restrictive actual cyclone forbid type variables kind au 
anonymous types product types named types defined struct 
type constructors 
assign take address objects individual fields 
earlier cyclone formalisms include orthogonal cumbersome feature 
remains quite powerful 
includes quantified types effects constraints multithreaded cyclone 
semantics assignment requires rewriting steps assigning thread 
steps assigned location holds junk expression data races threads read junk 
syntax presents language syntax 
kind includes sharability type lock name boxed type type lock name 
range types 
just convention types know kind lu ls 
type variables int pair types conventional 
function type includes effect describing locks callers hold 
source programs effects containing integer explained represent locks run time integers type substitution produce effects 
lock name effect locks cyclone 
pointer type describes pointer expression type location lock named guards 
quantified types convertible introduce constraints hold instantiate universal type introduce existential type 
type form lock lock cyclone 
source programs allow lock lock loc 
execution lock type lock pointers locations guarded lock types form 
term level distinguish statements expressions statement forms verbose syntax 
include expressions executed effect return statements sequential composition loops conditionals 
variable declaration allocates memory 
convertible form binds allocates fresh memory called initialized result infer type explicit kinds types int lock loc terms return open spawn sync release pack nonlock newlock lock call values pack nonlock lock heaps lock sets threads program states 
tn static contexts syntax core multithreaded cyclone lock name indicates lock guards new location 
explain static semantics means type 
form open opens existential package 
form allocates memory called guarded lock named memory holds contents existential package 
scope type variable statement forms provide multithreading mutual exclusion 
spawn executes new thread evaluating current thread 
sync acquires lock evaluates executing release appear source programs 
place holder machine releases lock executing expression forms similar include constants variables pointer creation pointer dereference pair creation pair projection assignment function call 
type application existential creation pack conventional polymorphic languages 
functions take single parameter pair execute statement return expression 
actual cyclone memory holding parameter thread shared annotate formal variable 
function type abstractions effect assumed constraints explicit 
remaining source program forms nonlock newlock thread local data expression generates new lock respectively 
form lock actual lock 
form appears thread currently writing call maintain call stack term syntax function call rewritten form function return eliminates 
run time full machine state 
tn consists locks created locks currently held thread single shared heap threads ti consists locks holds statement captures entire control state 
heaps map variables expressions 
words reuse variables serve addresses 
disallowed heap need allow mutating heap location takes transitions 
identify heaps lock sets reordering finite maps sets respectively write combining maps implicitly assume disjoint domains 
similarly disjoint union 
dynamic semantics author dissertation uses small step operational semantics conserve space presenting equivalent contextual semantics :10.1.1.143.3991
shows reduction rules come flavors statement contexts left expression contexts right expression contexts 
variable left value causes memory dereference right expression 
thread create new lock acquire release lock change shared heap create new thread 
single thread reduction rules form lh sopt meaning thread lh changing heap set created locks set available locks 
sopt thread spawned sopt new thread 
starts locks held 
form lh unimportant abbreviate interesting rules assignment 
change heap map rewrite expression requirement junk means write write races lead stuck thread 
subscripted necessary transition remembers value finish writing 
semantics allows reading heap doing lead stuck thread destructors form 
type system strong thread read junk 
semantics single thread machine semantics defined straightforward 
nondeterministic respect thread scheduling 
rules thread takes step spawns thread thread takes step spawns thread cleanup rule remove terminated thread holding locks 
notation largely conventional important exception 
write capture avoiding substitution similarly expressions types 
definition return open spawn spawn sync release pack call return fresh spawn return sync nonlock lh sync lock lh release vi call call return lh release lh lh return release lh return open pack lh newlock lh pack lock ls lock fresh sopt sopt sopt sopt sopt sopt dynamic semantics single thread transitions li si 
li si 
tn 

tn li si 
li si 
tn 

tn 
tj return tk 
tn 

tn dynamic semantics machine transitions dard means substitute locks defined inductively structure :10.1.1.143.3991
note types type substitution essential run time effect 
source static semantics sound system source programs closed statements terms form junk lock release call section describes extend system machine states order prove soundness 
rules discussion omit wellformedness hypotheses judgments example effect mention type variables scope appear full definition :10.1.1.143.3991
hypotheses consume space distract type system essence 
summarizes judgments type checking 
presents rules ascribing kinds types kind 
quite simple boxed types types sharable types unsharable types kinding subsumption rule 
kinding rules unsurprising 
integers functions sharable loc 
types components sharability pair sharable components 
require components sharability 
loc kinds form 
integers pointers boxed presents type system includes interdependent judgments stmt statements rtyp right expressions ltyp left expressions 
cases context includes type variables scope kinds term variables scope types lock names guard collection assumed constraints current effect 
convenient abbreviate write corresponding components statements return type enclosing function return statements expressions type 
statements side effects type right judgment 
right expressions result type expected 
left expressions describes contents location describes lock guards location 
describe locations describe right expressions just 
type system ensures correct lock held reading writing shared data 
write acc mean locks described held constraints satisfied lock named held examples suffices 
furthermore acc loc 
formal rules omitted judgments author dissertation :10.1.1.143.3991
acc derive rtyp rtyp rtyp basic expression forms access shared memory 
judgment ltyp reduction rules access memory 
judgments eff eff describe superset locks describes constraint provable respec kind kind kind int bs kind loc lu au kind kind au dom kind kind kind kind lock kind au kind kind au kind kind kind kind kind kind source static semantics kinding kind kind acc lock named held eff provides access eff constraints implied ltyp location type lock name rtyp type styp type checks return type ret diverges return source static semantics judgments tively 
checking function calls uses judgment caller current effect satisfies effect callee type 
checking existential package creation polymorphic function instantiation uses judgment constraints quantified types satisfied 
dually check open statement polymorphic function add constraints context 
remaining judgment ret just describes conservative analysis ensure function bodies terminate executing return statement 
rules merit discussion 
forbid function bodies referring free variables 
allowed free location guarded loc function passed spawn violate safety 
proven type safety relaxed system allow function body refer locations guarded lock kind ls 
note type check function bodies explicit effect effect context 
rule spawn requires shared value sharable kind function safe execution thread holds locks 
rule sync type checks stronger current effect expected 
note locks loc locks 
type safety desirable property styp 
tn reflexive transitive closure ti return thread terminated holds locks ti li si li si sopt sopt informally thread stuck 
property hold thread waiting unavailable lock si sync lock 
fact prevents deadlocked threads 
relax statement soundness say thread terminated take step additional lock available 
thread may need additional lock 
definition badly stuck 
program 
tn badly stuck badly stuck thread 
badly stuck thread thread return sopt sopt theorem type soundness 
styp ret badly stuck 
syntactic proof technique style wright felleisen define typing judgment machine states prog prove lemmas conclude type soundness simple corollary styp prog 
prog prog threads 
prog badly stuck 
key getting right definition prog confront terms types source programs run time lock sets heap 
rest section describes definition summarized additional rules judgments uses 
run time terms types refer actual locks 
locks set created locks 
enforce restriction augment kinding typing contexts include explicitly 
rules figures change accordingly 
resulting rules kind type lock unsurprising 
need various lock sets partition 
ln 
second type check parts heap judgment htyp means assuming bindings heap provides bindings machine shared heap prove threads badly interfere partition 
shared part hs require htyp hs expressions hs refer heap locations dom hs type kind sharable shr 
require addresses elements kind sharable loc iu ltyp rtyp ltyp ltyp rtyp acc rtyp rtyp acc rtyp rtyp nonlock lock loc rtyp newlock ls lock rtyp int rtyp kind eff kind au rtyp pack styp ret rtyp rtyp rtyp rtyp kind eff rtyp rtyp rtyp rtyp ltyp rtyp acc rtyp rtyp rtyp eff rtyp rtyp rtyp rtyp styp rtyp styp return styp styp styp rtyp int styp styp styp rtyp int styp styp dom rtyp styp styp dom dom kind lu kind au rtyp styp styp open rtyp rtyp kind styp spawn rtyp lock locks styp styp sync source static semantics typing si refer hs require iu htyp iu partition provides strong induction hypothesis establish race location guarded loc 
third li 
weak type check si context si releases lock ij know need ij type check 
solution iu styp si typing rule release ij add ij checking enforce terminating threads release exactly locks hold return values 
ret si suffices 
introduce judgment srel informally srel holds release statements mention exactly locks exactly release statements active redex root viewed syntax tree 
formal definition simple syntax directed :10.1.1.143.3991
typing rule junk restrict terms appear 
judgment impose strong invariant junk forbid junk si junk evaluation context case require junk junk location thread 
furthermore thread local heap part hs guarded lock thread holds enforced li hlk 
case dom dom thread access thread takes step 
similarly si form thread thread access contain junk 
kind ls rtyp rtyp junk cl rtyp lock lock styp ret rtyp call styp styp release htyp heap type hlk dom locked shr dom sharable loc dom sharable srel releases exactly diverges junk free junk junk junk free 

ln hs sh 
htyp hs shr hlk iu htyp iu loc iu li hlk iu styp si ret si li srel si si prog 
ln sn program state typing 
limitations sound decidable type system cyclone data race prevention necessarily conservative forbidding programs 
describe limitations address 
thread shared data mutated need locking 
expressing read invariant straightforward take const seriously prevent mutation const data qualifier polymorphism important code reuse :10.1.1.24.8366
similarly reader writer locks allow mutation concurrent read access 
annotating pointer types read write locks pose technical problems 
global variables thread shared require annotations 
means need locks lock names global scope 
worse single threaded programs global variables type check multithreaded programs need lock names 
note variables thread wide scope problem 
oftentimes thread shared data initialization phase thread shared 
phase locking unnecessary 
simple dataflow analysis probably suffice allow access locking long object shared 
data objects migrate threads needing locking 
example producer consumer pattern producer thread puts objects shared queue consumer thread removes 
producer objects enqueuing objects need locks 
cyclone designers exploring ways allow safe uses memory deallocation free 
issues similar deallocation precede access techniques safe deallocation support object migration 
prevent deadlock type system compatible reentrant locks help bit 
deadlock undesirable violate type safety 

related discussed section closely related static race prevention systems developed flanagan boyapati :10.1.1.1.5802
surface main difference systems targeted java need interact parametric polymorphism memory management 
java programmers enjoy convenience object lock 
tricky issue java run time downcasts sound system check cast object subclass foo field guarded lock correct foo parameterized lock systems resorted run time type passing cyclone enjoys type erasure 
boyapati system supports read data object migration described previous section 
advanced systems implemented evaluated real applications lack type safety proofs 
guava java dialect static data race prevention 
class hierarchy rigid distinction thread local sharable objects 
allows synchronized access methods fields 
move operator soundly allows object migration 
sacrificing soundness potentially missing data races reduce false positives explicit annotations 
results useful code 
examples include esc java usually acts loops iterate static race detector optimistic aliasing assumptions assumes locations holding locks mutated hold different locks 
race detection systems dynamic 
usual dynamic static approaches complementary different expressiveness performance convenience trade offs 
cyclone type safety needs data race prevention static approach feels appropriate 
easier implement change code generation 
race free disciplines cyclone type system enforces course 
flexible system programs specify verification condition 
flanagan freund qadeer explain verify specifications thread modular fashion 
adding flexibility cyclone require preventing specifications permit data races 
static analyses find thread local data eliminate unnecessary locking java 
adapting interprocedural escape analyses cyclone reduce annotations complicate language definition 
safe languages low level applications allowed threads 
vault type system restricts aliases track stateful properties data compile time 
mechanisms termed adoption focus allow tracking state lexical scope knowing aliases data 
scoping technique relies crucially absence concurrent access 
ccured unmodified legacy applications compiled extra data fields run time checks detect memory safety violations 
key performance program static analysis eliminate unnecessary fields run time checks 
analysis assumes program single threaded 
arbitrary thread interleavings expect conservative results 
run time checks thread safe 
making require expensive synchronization precise control thread scheduling 

type system prevents data races multithreaded extension cyclone includes parametric polymorphism region memory management 
programmer locks thread shared data thread local data 
formal machine models system key features including data 
rigorous proof type safety machine implies data races 
acknowledgments kevin neill wang stephanie weirich anonymous reviewers provided valuable feedback improved 

aldrich chambers sirer eggers 
eliminating unnecessary synchronization java programs 
th international static analysis symposium volume lecture notes computer science pages venice italy sept 
springer verlag 
bacon strom 
guava dialect java data races 
acm conference object oriented programming systems languages applications pages minneapolis mn oct 
blanchet 
escape analysis object oriented languages 
application java 
acm conference object oriented programming systems languages applications pages denver nov 
boyapati lee rinard 
ownership types safe programming preventing data races deadlocks 
acm conference object oriented programming systems languages applications pages seattle wa nov 
boyapati rinard 
parameterized type system race free java programs 
acm conference object oriented programming systems languages applications pages tampa bay fl oct 

programming posix threads 
addison wesley 

cheng feng leiserson randall stark 
detecting data races cilk programs locks 
th acm symposium parallel algorithms architectures pages puerto mexico june 

choi gupta serrano sreedhar midkiff 
escape analysis java 
acm conference object oriented programming systems languages applications pages denver nov 

choi lee callahan sarkar sridharan 
efficient precise datarace detection multithreaded object oriented programs 
acm conference programming language design implementation pages berlin germany june 
cyclone user manual 
www cs cornell edu projects cyclone 
deline hndrich 
enforcing high level protocols low level software 
acm conference programming language design implementation pages snowbird ut june 
hndrich deline 
adoption focus practical linear types imperative programming 
acm conference programming language design implementation pages berlin germany june 
flanagan abadi :10.1.1.111.9953
object types races 
concur concurrency theory volume lecture notes computer science pages eindhoven netherlands aug 
springer verlag 
flanagan abadi 
types safe locking 
th european symposium programming volume lecture notes computer science pages amsterdam netherlands mar 
springer verlag 
flanagan freund :10.1.1.143.5635
type race detection java 
acm conference programming language design implementation pages vancouver canada june 
flanagan freund qadeer 
thread modular verification shared memory programs 
th european symposium programming volume lecture notes computer science pages grenoble france apr 
springer verlag 
flanagan leino lillibridge nelson saxe stata 
extended static checking java 
acm conference programming language design implementation pages berlin germany june 
foster hndrich aiken :10.1.1.24.8366
theory type qualifiers 
acm conference programming language design implementation pages atlanta ga may 
grossman 
existential types imperative languages 
th european symposium programming volume lecture notes computer science pages grenoble france apr 
springer verlag 
grossman :10.1.1.143.3991
safe programming level abstraction 
phd thesis cornell university 
forthcoming 
grossman morrisett jim hicks wang cheney 
region memory management cyclone 
acm conference programming language design implementation pages berlin germany june 
jim morrisett grossman hicks cheney wang 
cyclone safe dialect usenix annual technical conference pages monterey ca june 
lucassen gifford 
polymorphic effect systems 
th acm symposium principles programming languages pages san diego ca jan 
necula weimer 
ccured type safe retrofitting legacy code 
th acm symposium principles programming languages pages portland jan 
savage burrows nelson sobalvarro anderson 
eraser dynamic data race detector multithreaded programs 
acm transactions computer systems nov 
sterling 
static date race analysis tool 
usenix winter technical conference pages 
von praun gross 
object race detection 
acm conference object oriented programming systems languages applications pages tampa bay fl oct 
walker crary morrisett :10.1.1.1.3704
typed memory management calculus capabilities 
acm transactions programming languages systems july 
wright felleisen 
syntactic approach type soundness 
information computation 

