mitsubishi electric research laboratories www merl com principles implementation deductive parsing stuart shieber yves schabes fernando pereira tr december system generating parsers directly metaphor parsing deduction 
parsing algorithms represented directly deduction systems single deduction engine interpret deduction systems implement corresponding parser 
method generalizes easily parsers augmented phrase structure formalisms grammars logic grammar formalisms rapid prototyping parsing algorithms variety formalisms including variants tree adjoining grammars categorial grammars lexicalized context free grammars 
may copied reproduced part commercial purpose 
permission copy part payment fee granted nonprofit educational research purposes provided partial copies include notice copying permission mitsubishi electric research laboratories acknowledgment authors individual contributions applicable portions copyright notice 
copying reproduction republishing purpose shall require license payment fee mitsubishi electric research laboratories rights reserved 
copyright mitsubishi electric research laboratories broadway cambridge massachusetts publication history 
printing mn may parsing viewed deductive process seeks prove claims grammatical status string assumptions describing grammatical properties string elements linear order 
lambek syntactic calculi lambek comprise early formalization idea explored relation grammar formalisms de nite clauses colmerauer pereira warren pereira warren feature logics shieber rounds carpenter 
view parsing deduction adds main new sources insights techniques study grammar formalisms parsing 
existing logics basis new grammar formalisms desirable representational computational properties 

modular separation parsing logic grammaticality claims proof search procedure allows investigation wide range parsing algorithms existing grammar formalisms selecting speci classes grammaticality claims speci search procedures 
deductive parsing concerned investigate speci cally synthesize parsing algorithms combining speci logics grammaticality claims xed search procedure 
way deduction provide metaphor parsing encompasses wide range parsing algorithms assortment grammatical formalisms 
metaphor presenting series parsing algorithms literally inference rules providing uniform deduction engine parameterized rules parse associated algorithms 
inference rules logic represented unit clauses xed deduction procedure provide prolog implementation version usual bottom consequence closure operator de nite clauses 
show method directly yields dynamic programming versions standard top bottom mixed direction earley parsing procedures 
method similarities pure bottom deduction encode dynamic programming versions de nite clause proof procedures deductive databases bancilhon ramakrishnan naughton ramakrishnan :10.1.1.32.1488
program develop especially useful rapid prototyping experimentation new parsing algorithms fact developed purpose 
instance development algorithms parsing tree adjoining grammars categorial grammars lexicalized context free grammars 
ideas new 
form part folk wisdom logic programming community 
merl tr may knowledge rst ideas available explicitly single notation clean implementation 
addition certain observations regarding cient implementation may novel 
organized follows reviewing basic logical grammatical notions applying simple example section describe structure variety parsing algorithms context free grammars expressed inference rules specialized logics section 
extend method stating implementing parsing algorithms formalisms context free grammars section 
discuss deduction proceed logics developing agenda deduction procedure implemented prolog manifests ideas section 
basic notions introduced section see parsing deductive process rules inference derive statements grammatical status strings statements 
statements represented formulas suitable formal language 
general form rule inference ak conditions ak bi antecedents ak consequent inference rule formula schemata may contain syntactic metavariables instantiated appropriate terms rule 
grammatical deduction system de ned set rules inference set axioms appropriate formula schemata 
grammatical deduction system derivation formula assumptions am usual sequence formulas sn sn si axiom aj rule inference formulas si sik ik appropriate substitutions terms metavariables si sik match antecedents rule si matches consequent rule side conditions satis ed 
write am say consequence am derivation exists 
consequence empty set assumptions said derivable symbols applications model rules axiom schemata may refer side conditions rules particular grammar formulas may refer string positions xed string parsed wn 
respect string goal formulas state string grammatical grammar 
parsing string corresponds nding derivation witnessing goal formula 
merl tr may standard notation metavariables ranging objects discussion length object language string parsed arbitrary formulas symbols grammar nonterminals arbitrary terminal symbols indices various strings especially string strings terminal nonterminal symbols 
notations leaving type object implicit notation chosen 
substrings notated wi wj th th elements inclusive 
usual take wi wj empty string example cyk parsing simple example basic mechanism cocke younger kasami cyk context free parsing algorithm kasami younger context free grammar chomsky normal form easily represented grammatical deduction system 
assume string wn parsed context free grammar hn si set nonterminals including start symbol set terminal symbols vocabulary grammar set productions form symbol immediate derivation re exive transitive closure derivation relation 
case chomsky normal form grammar productions form items logic call parsing logic formulas form state nonterminal derives substring indices string wi wj 
sound axioms grounded lexical items occur string 
word wi string rule wi clear item true claim items taken axiomatic 
know wi wj wj wk asserted items form production grammar sound conclude wi wk item inferable 
argument codi ed rule inference bc rule inference axioms conclude string admitted grammar item form deducible item asserts wn think item goal item proved 
summary cyk deduction system deductive parsing systems de ne speci ed components class items merl tr may item form axioms wi goals inference rules bc cyk deductive parsing system 
set axioms set inference rules subclass items goal items 
summary form 
deduction system encoded straightforwardly logic program nt word 
nt nt nt 
xm encoding production xn grammar word wi holds input word wi string parsed 
suitable bottom execution program example semi na bottom procedure naughton ramakrishnan behave similarly cyk algorithm grammar 
proofs correctness implement deductive system cyk separate logic program describe section meta interpreter logic programs obtained grammatical deduction systems 
meta interpreter just variant semi na procedure specialized programs implementing grammatical deduction systems 
show section procedure generates items derivable axioms soundness enumerate derivable items completeness 
show particular parsing algorithm correctly simulated meta interpreter basically need show corresponding grammatical deduction system sound merl tr may complete respect intended interpretation grammaticality items 
sound mean derivable item represents true grammatical statement intended interpretation complete mean item encoding true grammatical statement derivable 
need show grammatical deduction system faithfully represented corresponding logic program general obvious inspection 
deductive parsing context free grammars presentation parsing methods stated deduction systems standard methods parsing context free grammars 
follows assume string wn parsed context free grammar hn si 
pure top parsing recursive descent rst full parsing algorithm arbitrary context free grammars logical perspective recursive descent parsing 
contextfree grammar hn si string wn parsed consider logic items form item asserts substring string including th element followed string symbols forms sentential form language wj note dot item positioned just break point sentential form portion recognized index part 
set items propositional formulas logic informal statement concluding previous paragraph provide denotation sentences explore proof theory logic 
start axiom sound trivially 
note items form wj claim clearly sound conclude formal statement semantics truth wj falsity merl tr may item form axioms goals inference rules scanning wj prediction top recursive descent deductive parsing system 
yielding inference rule wj call scanning rule 
similar argument shows soundness prediction rule 
item claim wn string admitted grammar 
goal item proved axiom inference rules string grammar 
proof process constitute sound recognition algorithm 
turns recognition algorithm logic items speci es pure top left right regime recursive descent algorithm 
components deduction system top parsing class items axioms inference rules goal items summarized 
illustrate operation inference rules context free parsing toy grammar 
grammar string program halts merl tr may np vp np det np pn vp tv np vp iv vp det program pn terry pn iv halts tv writes example context free grammar 
construct derivation rules just np vp det vp vp vp program vp vp vp iv halts item goal item showing sentence accepted grammar 
derivation show contains just items strictly necessary derive goal item axiom 
general complete search procedure describe section generates items dead ends redundant proof grammaticality 
furthermore ambiguous grammar essentially di erent proofs grammaticality corresponding di erent analysis input string 
proof completeness shown informally inference rules top parsing sound system need guarantee completeness merl tr may string admitted grammar string derivation goal item initial item 
order prove completeness prove lemma wj leftmost derivation item generated 
prove possible instances lemma 
speci instance characterized specifying string integer wj xed 
shall denote instance ji 
proof turn ranking various instances proving result induction rank 
rank instance ji computed sum length shortest leftmost derivation wj rank zero need show generated case axiom top deduction system 
inductive step ji instance lemma rank assume lemma true instances smaller rank 
cases arise 
case wj step 
wj rule grammar 
axiom application prediction rule predicting rule wj applications scanning rule item generated 
case wj step 
assume wj kb wj wj wj instance hb ki strictly smaller rank ji 
induction hypothesis item generated 
prediction item wj wj generated applications scanning rule item generated 
concludes proof lemma 
completeness parser follows corollary lemma wn lemma item generated 
completeness proofs remaining parsing logics discussed provided similar way relating appropriate notion derivation grammar formalism consideration item invariants 
pure bottom parsing shift reduce pure bottom algorithm speci ed deduction system 
items form 
item asserts dual assertion top items wj wn wn equivalently transparently dual wj 
algorithm merl tr may item form axioms goals inference rules shift wj reduce bottom shift reduce deductive parsing system 
characterized deduction system shown 
algorithm mimics operation nondeterministic shift reduce parsing mechanism string symbols preceding dot corresponds current parse stack substring starting index corresponds unread input 
soundness inference rules easy see 
antecedent shift rule claims wj wn wn consequent claims 
reduce rule wj wn wn de nition wn wn 
completeness proved induction steps reversed rightmost context free derivation way similar completeness proof section 
derivation shows operation bottom rules example sentence det det program det det np np halts np iv np vp item goal item shows sentence parsable merl tr may grammar 
earley algorithm stating algorithms way points duality recursive descent shift reduce parsing way traditional presentations 
summary presentation may illuminate various interrelationships 
see earley algorithm earley seen natural combination algorithms 
recursive descent parsing keep partial sentential form material parsed dot string symbols remind symbols come point reached recognition process 
shift reduce parsing keep partial sentential form material parsed placing dot string remind symbols come point reached recognition process 
earley algorithm keep partial sentential forms dot marking point middle recognition reached 
dot changes mnemonic necessary role 
addition earley algorithm localizes piece sentential form tracked introduced single production 
rst parsers limit information stored item local information practical algorithms stated 
scheme sharing information items necessary tractable 
items earley algorithm form strings production grammar 
case previous algorithms index provides position string recognition reached dot position marks point partial sentential form 
items extra index marks starting position partial sentential form localized attention single production 
summary item form top claim bottom claim wj wn wi wn 
claims connected fact production grammar 
algorithm captured speci cation 
proofs soundness completeness somewhat complex pure top bottom cases shown directly related corresponding proofs earley original algorithm earley 
derivation sentence illustrates operation merl tr may algorithm bottom top earley item form invariant wj wj wn wn wj wn wi wn axioms goals scanning wj wj wj wj prediction completion summary parsing algorithms deductive parsing systems 
axioms goal items earley algorithm serves new nonterminal 
merl tr may earley inference rules np vp np det det det np det program program np det np det np vp vp iv iv halts iv halts vp iv np vp item goal item earley derivation grammaticality sentence 
deductive parsing formalisms methods implementation developed rapid prototyping experimentation parsing algorithms grammatical frameworks context free grammars 
naturally extended handle augmented phrase structure formalisms logic grammar constraint formalisms 
development testing algorithms parsing categorial grammars tree adjoining grammars lexicalized context free grammars 
section discuss extensions 
augmented phrase structure formalisms straightforward see deduction systems just extended constraint grammar formalisms context free backbone 
basis extension goes back metamorphosis grammars colmerauer de nite clause grammars dcg pereira warren 
formalisms grammar symbols rst order terms understood abbreviations sets ground instances 
merl tr may inference rule seen abbreviation ground instances variables rule consistently instantiated ground terms 
computationally instances generated lazily accumulating consistency requirements instantiation inference rules conjunction equality constraints maintaining conjunction normal form sets variable substitutions uni cation 
directly related uni cation avoid guessing instances rules existential generalization universal instantiation natural deduction presentation rst order logic 
move rst order terms general constraint grammar formalisms shieber carpenter constraint interpretation inference rules basic 
explicitly rule earley completion interpreted shorthand constrained rule rule applied constraints depends conjoined constraints current derivation 
particular case rstorder terms antecedent consequent rule application completion explicitly mgu mgu general uni er terms interpretation implemented deduction procedure described section 
move constraint formalisms raises termination problems proof construction arise context free case 
general case inevitable formalism dcg pereira warren patr ii shieber turing machine power :10.1.1.14.7095
constraints imposed context free backbone grammar productions guarantee decidability ine bresnan kaplan pereira warren shieber prediction rules top earley systems problematic 
di culty prediction feed results build unboundedly large items 
example consider dcg merl tr may clear grammar accepts strings form abn variable instantiated unary successor representation clear bottom inference rules di culty deriving analysis input string 
earley prediction item generate nite succession items problem solved case earley inference rules observing prediction just narrow number items considered scanning completion maintaining top invariant invariant required soundness completeness bottom invariant su cient guarantee items represent formed substrings input 
purpose top invariant minimize number completions attempted 
indispensable role prediction available appropriate instances grammar productions 
relaxation prediction available items items predicted original prediction rule instances ect soundness completeness rules 
precisely case item original prediction rule create instance item created relaxed prediction rule 
relaxed prediction rule create items original predictor fact may create far fewer 
particular repeated prediction may terminate cases described 
example prediction rule applied yields mgu relaxed prediction rule yield speci substitution chosen nite number instances generated 
similar notion general constraint grammars called restriction shieber shieber related technique partial evaluation logic programs sato tamaki :10.1.1.14.7095
problem dcg seen computation derivation speci information arguments nonterminals 
applications frequently require construction derivation string similar information purpose processing 
simple augment inference rules include item derivation 
earley deduction system items include fourth component value sequence derivation trees nodes labeled productions grammar derivation tree element right hand side item dot 
inference rules modi ed shown 
system function tree takes node label merl tr may item form axioms hi goals inference rules scanning wj wj prediction hi completion tree earley deductive parsing system modi ed generate derivation trees 
production grammar sequence derivation trees forms tree root labeled children trees order 
course rules caching lemmas essentially useless lemmas derived di erent ways identical 
appropriate methods implementation circumvent problem discussed section 
combinatory categorial grammars combinatory categorial grammar steedman consists parts lexicon maps words sets categories rules combining categories categories 
categories built atomic categories binary operators forward slash backward slash 
informally speaking words having categories form thought functions 
category snnp intransitive verbs interpreted function noun phrases np sentences 
addition direction slash forward backward speci es argument immediately right immediately left example ccg lexicon may assign category snnp intransitive verb word sleeps 
snnp identi es word sleeps combining subject noun phrase np yield sentence 
back slash indicates subject immediately left verb 
forward merl tr may word john bananas likes really category np np snnp np snnp snnp example ccg lexicon 
slash indicated argument immediately right verb 
formally categories de ned inductively follows set nonterminals nonterminal symbols categories 
categories nc categories 
lexicon de ned mapping words nite sets categories 
example ccg lexicon 
lexicon likes encoded transitive verb snnp np yielding sentence noun phrase np object right noun phrase subject np left 
categories combined nite set rules fall classes application composition 
application allows simple combination function argument right forward application left backward application 
example sequence snnp np np reduced snnp applying forward application rule 
similarly sequence np snnp reduced applying backward application rule 
composition allows combine categories similar fashion functional composition 
example forward composition combines categories form category rule gives appearance canceling categories numerical fractions undergoing multiplication 
rule corresponds fundamental operation composing functions function function rules composition speci ed formally productions productions cfg productions universal 
order reduce number cases vertical bar instance notation backward slash consistent de ned steedman interpreted function 
notation adopted majority combinatory categorial frameworks lambek adopted opposite interpretation function xs toy merl tr may forward backward slash instances left right hand sides single production interpreted representing slashes direction 
symbols read variables match category 
forward application backward application forward composition xjz backward composition xjz jz string words accepted ccg speci ed nonterminal symbol usually derives string categories image string words mapping bottom algorithm essentially cyk algorithm instantiated productions easily speci ed 
ccg string wn parsed consider logic items form category integers ranging item asserts substring string th element th element reduced category required proof rules logic 
illustrate operations lexicon combine string john really likes bananas ways sentence proved follows np snnp snnp snnp np snnp np np snnp extensions ccg generalized composition coordination easily implemented deduction parsing methods 
tree adjoining grammars related formalisms formalism tree adjoining grammars tag joshi levy takahashi joshi tree generating system trees combined operation adjunction substitution operation contextfree grammars 
increased expressive power adjunction allows important practical variants tag include adjunction substitution purposes exposition restrict attention adjunction substitution formally merl tr may item form axioms goals inference rules forward application backward application forward composition forward composition backward composition backward composition nz nz ccg deductive parsing system 
merl tr may vp np vp vp adv np vp trip trip vp adv example tree adjoining grammar consisting initial tree auxiliary tree 
trees form derived tree sentence trip 
actual english grammar tree depicted elementary tree derived trees lexical item substitution operation 
natural language phenomena long distance dependencies expressed locally grammar relevant lexical entries specialized context free rules joshi 
tree adjoining grammar consists set elementary trees types initial trees auxiliary trees 
initial tree complete sense frontier includes terminal symbols 
example 
auxiliary tree incomplete single node frontier foot node labeled nonterminal root 
provides example 
convention foot nodes redundantly marked asterisk gure 
auxiliary trees constitute complete grammatical structures participate construction complete trees adjunction operation 
adjunction auxiliary tree initial tree depicted 
operation inserts copy auxiliary tree tree place interior node label root foot nodes auxiliary tree 
subtree previously connected interior node reconnected foot node copy auxiliary tree 
example auxiliary tree adjoined vp implementation parsing systems describe context free operation 
similarly address issues adjoining constraints extended derivations 
discussion schabes schabes shieber 
merl tr may initial tree auxiliary tree derived tree operation adjunction 
auxiliary tree spliced initial tree yield derived tree right 
node initial tree form derived tree 
adjunction ect supports form string wrapping powerful substitution operation context free grammars 
tree adjoining grammar speci ed quintuple hn si set nonterminals including start symbol disjoint set terminal symbols set initial trees set auxiliary trees 
describe adjunction tag derivations need notation refer tree nodes labels subtrees de ne 
node tree speci ed address sequence positive integers de ned inductively follows empty sequence address root node address th child node address foot de ned address foot node tree foot unde ned 
denote node address subtree rooted grammar symbol labels node denoted label 
elementary tree node de ned set auxiliary trees adjoined node tags constraints adjunction instance de ned just set elementary auxiliary trees root node labeled label 
merl tr may denote 

result adjoining trees distinct addresses tree set trees derived tag de ned inductively 
smallest set trees 
elementary trees derivable 
de ne set trees derivable 

distinct addresses elementary trees 
obviously initial tree tree derived foot node auxiliary tree derived tree foot node 
valid derivations tag trees initial tree root labeled start symbol parsers tag described just cfg deduction systems 
parser variant cyk algorithm extended tags similar identical vijay shanker 
chose expository reasons far simplest tag parsing algorithm part restricted tags elementary trees binary branching primarily purely bottom system prediction performed 
despite simplicity algorithm handle increased generative capacity tags context free grammars 
consequently worst case complexity parser worse cfgs time sentence length algorithm uses dotted tree track progress parsing 
dotted tree elementary tree grammar dot adjacent nodes tree 
dot may positions relative speci ed node 
dotted tree speci ed elementary tree address tree marker specify position dot relative node 
notation dotted trees dot node respectively 
order track portion string covered production dot position cyk algorithm indices 
dotted tree complication elementary tree may contain foot node string covered elementary tree proper gap foot node occurs 
general indices maintained adjoining constraints allowed standard incorporated revised de nition 
algorithm earley dot items distinguish progress parse quite distinct ways 
dot earley algorithm tracks left right progress parse siblings 
dot cyk tag parser tracks pre post adjunction status single node 
reason generalizing earley algorithm tag parsing schabes dot positions simultaneously track pre post adjunction node left right progress 
merl tr may specify left edge auxiliary tree right edge parsed portion dot position auxiliary tree specify substring dominated foot node 
parser consists inference rules items forms node elementary tree indices positions input string ranging ng indicates corresponding index particular item 
item form speci es tree foot node fringe string wi wl 
item form speci es tree foot node fringe string wi wj label foot wk wl 
invariants similar derivation involve adjunction node algorithm preserves invariant traversing derived tree bottom top starting items corresponding string symbols follow axioms label combining completed subtrees larger ones combining subtrees adjunction dot derived auxiliary trees form subtrees adjunction dot 
depicts movement dot bottom top parsing proceeds 
basic rules dot movement involving adjunction shown including axiom terminal symbols combination binary tree child unary subtree movement corresponding absence adjunction node 
exactly rules parsing single elementary tree 
displays rules involved parsing adjunction tree 
dot movement rules exactly inference rules tag cyk deductive parsing system full 
order reduce number cases de ne notation indices follows unde ned parser works time adjoin rule independent indices step accounts complexity average behavior may better practice ine cient practical merl tr may adjoin complete unary adjoin complete binary terminal axiom foot axiom examples dot movement cyk tree traversal implicit tag parsing algorithm 
merl tr may item form axioms terminal axiom label wi empty string axiom label foot axiom foot goals label inference rules complete unary unde ned complete binary adjoin adjoin cyk deductive parsing system tree adjoining grammars 
merl tr may reasons 
attempt parse auxiliary trees starting bottom foot node regardless substring foot indices parsed appropriate manner 
problem alleviated suggested vijay shanker weir replacing foot axiom complete foot rule generates item foot item complete foot foot complicates invariant considerably auxiliary tree parsing goal directed 
second lack top prediction attempts parse elementary trees consistent left context 
predictive parsers tag described deductive systems 
instance schabes provides detailed explanation predictive left right parser tag inspired techniques earley algorithm 
worst case complexity average complexity english grammar superior worst case cyk tag parser 
parsing system algorithm currently development large english tree adjoining grammar university pennsylvania schabes joshi 
formalisms related tree adjoining grammars proposed deductive parsing approach applicable 
instance part investigation precise de nition tag derivation schabes shieber describe compilation tree adjoining grammars linear indexed grammars cient algorithm stated deduction system recognition parsing compiled grammar schabes shieber 
prototype parser implemented deduction engine described 
fact aid testing algorithm inference rules antecedent items deductive parsing meta interpreter rst built 
schabes waters suggest restricted form tag foot node auxiliary tree occur left right edge tree 
portion string dominated auxiliary tree contiguous constraint indices required track parsing auxiliary tree adjunction 
consequently formalism generate context free languages parsed cubic time 
resulting system called lexicalized context free grammar compromise parsing ciency context free grammar elegance lexical sensitivity tree adjoining grammar 
deductive parsing meta interpreter rapid prototyping earley style parser schabes waters 
merl tr may inadequacy sequent calculi parsing logics discussed natural deduction format implemented directly bottom execution 
important parsing logics particular lambek calculus lambek better sequent calculus format 
main reason systems nonatomic formulas represent concurrent hypothetical analyses 
instance arbitrary category conclude vu category lambek calculus conclude category main di culty applying techniques sequent systems computationally designed top direction 
instance rule hypothetical analysis form reasonable rule goal directed fashion consequent antecedent show forward direction impractical arbitrarily assumed knowing rule applicable 
generally sequent formulations syntactic calculi goal sequent showing grammaticality string wi form wn wi gives grammatical category wi category sentence 
proof search proceeds matching current sequents consequents rules trying prove corresponding antecedents recognizing sequent axiom instance corresponding natural deduction proof start assumptions wn try prove just proof format 
sequent rules correspond additional assumption wi point proof discharge natural deduction detachment rule propositional logic 
undirected assumptions just case may yield consequences needed computationally costly 
systems full sequent formulation require top proof search 
course possible encode top search bottom system complex encodings search state done earley algorithm magic sets magic templates compilation method deductive databases bancilhon ramakrishnan ramakrishnan :10.1.1.32.1488
passing similarity problem problem pure bottom parsing grammars gaps 
fact natural logical formulation gaps assumptions discharged wh phrase stand pareschi miller hodas 
merl tr may instance presents compilation lambek calculus cfg processed standard methods 
clear techniques applied ectively grammatical sequent calculi implemented method described 
control implementation speci cation inference rules carried previous sections partially characterizes parsing algorithm provides items computed order 
control information provided choosing deduction procedure operate inference rules 
deduction procedure complete little di erence order items enumerated crucial exception want enumerate item 
prevent possibility standard maintain cache lemmas adding cache items seen far 
cache plays role chart chart parsing algorithms kay formed substring table cyk parsing kasami younger state sets earley algorithm earley 
section develop forward chaining deduction procedure achieves elimination redundancy keeping chart 
items added chart proved 
new item may generate new consequences 
issue compute consequences new item quite subtle 
standard solution keep separate agenda items proved consequences computed 
item removed agenda added chart consequences computed added agenda consideration 
general form agenda driven chart deduction procedure follows 
initialize chart empty set items agenda axioms deduction system 

repeat steps agenda exhausted select item agenda called trigger item remove 
add trigger item chart necessary 
trigger item added chart generate items new immediate consequences trigger item items chart add generated items agenda 

goal item chart goal proved string recognized 
merl tr may issues determined making general procedure concrete describe general topics eliminating redundancy providing cient access 
point show reasonable assumptions general procedure sound complete 
arguments follow assume items ground derivations de ned section 
proof general case items denote sets possible grammaticality judgments require intricate de nitions items inference rules changing essence argument 
soundness need show procedure places item chart agenda initialized step items ak ak item chart agenda placed chart step su cient show ak agenda 
show induction stage ofi number iteration step added agenda placed agenda step 
note items may added agenda iteration items may stage number 
axiom trivial derivation consisting derivation ak 
assume ak nand added agenda step items jm chart rule instance jm conditions jm ii side conditions satis ed 
jm chart added agenda latest iteration step ji induction hypothesis ji derivation ak 
de nition derivation concatenation derivations followed derivation ak 
completeness want show ak chart step 
prove stronger eventually added chart assume form fairness agenda 
covered cases full iteration step terminate step interleaved step recognize goal soon generated 
form fairness assume item removed agenda step item agenda mechanism described section satis es fairness assumption 
merl tr may show completeness induction length derivation dn ak 
show implicitly procedure generates derivation general may share steps derivations 
ai placed agenda step 
fairness assumption removed agenda iterations step 
added chart required chart contains item 
see discussion necessary proviso step section 
assume result holds derivations length consider derivation dn axiom case just shown placed chart iteration de nition derivation im rule instance di im conditions im ii side conditions satis ed 
de nition derivation pre dij dn derivation dij ak 
dij chart induction hypothesis 
dij identical item ij agenda added chart step 
ip item question added chart 
immediately addition ij dij chart ip dip trigger item rule application 
placed agenda 
step add nite number items agenda fairness assumption item eventually considered steps added chart 
eliminating redundancy redundancy chart 
deduction procedure requires ability generate new consequences trigger item items chart 
key word requirement new 
entire point chart system allow caching proved lemmas previously proved old lemmas pursued 
crucial item added chart exists chart reason step speci es addition chart necessary 
de nition redundant item 
point chart serve cache previously proved items item proved pursued 
mean item redundant occurring agenda chart 
case ground items appropriate notion occurrence chart existence identical chart item 
items non ground instance parsing relative de nite clause grammars context free grammars subtle notion occurrence chart necessary 
mentioned non ground item stands merl tr may ground instances non ground item occurs chart ground instances covered chart items specialization chart item 
test su ces strong compactness sets terms de ned equations instances term subset union instances instances subset instances lassez maher 
appropriate test item chart subsumes item added 
redundancy agenda 
pointed redundancy checking chart necessary 
issue redundancy agenda distinct 
item added agenda exists 
finding rule matches trigger item triggering generation new immediate consequences checking consequences new expensive operations perform 
existence duplicate items agenda generates spurious overhead computation especially pathological cases exponentially duplicate items created agenda creating avalanche spurious overhead 
reasons important check redundancy agenda notion new immediate consequences step interpreted consequent items occur chart agenda 
redundancy checking occurs point items added agenda required added chart necessary condition step case vacuous true 
triggering generation new immediate consequences 
regard step generate items new immediate consequences trigger item items chart possible refrain generating redundant items generating checking redundant ones 
clearly item immediate consequence chart items trigger item new consequence full chart 
generated antecedents added chart 
inference rules generating new consequences antecedent items trigger item search new immediate consequences limited just antecedents trigger item 
search carried looking antecedent items inference rules match trigger item checking antecedent items chart 
consequent rule generated potential new immediate subsumption check implemented ways prolog 
code appendix presents options 
merl tr may consequence trigger items plus chart items 
course checked prior existence agenda chart outlined 
providing cient access items stored agenda chart way ciently accessed 
stored items accessed points checking new item redundancy checking non trigger antecedent item existence chart 
cient access desirable able directly index stored items appropriately appropriate indexing may di erent access paths 
discuss types indexing separately turn issue variable renaming 
indexing redundancy checking 
consider instance earley deduction system 
items potentially subsume item set attributes common item instance indices production item constructed position dot length 
appropriate indexing set stored items 
indexing antecedent lookup 
information available indexing looking items potential matches antecedents quite di erent 
looking items match second antecedent completion rule triggered item form index known 
similarly information available trigger item information appropriate index second antecedent completion rule include rst index main functor left hand side rst antecedent item similar argument calls indexing second index main functor nonterminal dot 
cases distinguished sequence dot empty case non empty 
variable renaming 
nal consideration access renaming variables 
non ground items stored chart agenda matched inference rules instantiated 
instantiation ect items stored proving consequences care taken ensure variables agenda chart items renamed consistently 
prolog provides various techniques achieving renaming implicitly 
merl tr may prolog implementation deductive parsing light considerations turn method implementing agenda deduction engine prolog 
take advantage certain features standard prolog implementations clause indexing 
code described consistent quintus prolog 
implementation agenda chart redundancy checking done agenda chart need entire set items agenda chart stored 
cient access store prolog database predicate stored 
agenda chart comprised series unit clauses stored item 
chart stored item 
stored item 
stored item 
chart stored item 
head agenda stored item 
stored item 
stored item 
tail agenda rst argument stored unique identifying index corresponds position item storage sequence chart agenda items 
information redundantly provided clause ordering reasons clear shortly 
index allows quintus indexing clauses predicate rst head argument direct access stored item 
items added sequence items chart precede items agenda 
agenda items characterized indices corresponding rst head tail items agenda 
data structure packaging pointers serves proxy agenda code 
item moved agenda chart merely incrementing head pointer 
items added agenda storing corresponding item database incrementing tail pointer 
provide cient access stored items auxiliary indexing tables maintained 
indexing table implemented set unit clauses map access keys indexes items match 
implementation single indexing table predicate key index maintained accessing items redundancy checking antecedent lookup 
possible item attributes available merl tr may types access keys leading optimal indexing redundancy checking multiple indexing tables leads database manipulation quite costly 
looking items redundancy checking stored items considered antecedent lookup chart items pertinent 
distinction agenda chart items implementation implicit 
chart items index head index agenda 
test chart items looked 
clauses stored sequentially index soon item fails test agenda search chart items cut implementation deduction engine design decisions described general agenda driven deduction procedure section implemented prolog follows parse value initialize chart agenda init chart init agenda agenda remove items agenda process agenda empty exhaust agenda try nd goal item chart goal item chart goal 
exhaust agenda trigger items repeatedly processed agenda empty exhaust empty agenda empty re done empty agenda empty 
exhaust agenda get item index agenda pop agenda agenda index agenda add chart add item chart index add consequences agenda add consequences agenda index agenda agenda code diverges slightly appendix reasons exposition 
merl tr may continue processing agenda empty exhaust agenda 
item consequences generated added agenda add consequences agenda index agenda agenda findall consequence consequence index consequence consequences add items agenda consequences agenda agenda 
predicate add items agenda adds items appropriate indices stored items updates head tail indices agenda form new agenda agenda 
trigger item consequence matches antecedent rule antecedent items side conditions antecedent items previously proved chart side conditions hold consequence index consequent index item index trigger matching rule trigger rulename consequent items chart index hold 
note indices items items stored agenda index trigger item rst mapped actual item index item matching rule antecedent 
items chart predicate needs know items look index current item index distinguishes items chart index agenda index 
assume inference rules stored unit clauses predicate inference rulename antecedents consequent rulename mnemonic name rule predict scan antecedents list antecedent items rule consequent single consequent item list encoded prolog literals execute side conditions 
match trigger item antecedent inference rule merely select rule encoded manner split antecedents matches trigger remaining unmatched antecedents checked chart 
matching rule trigger rulename consequent inference rulename antecedents consequent merl tr may split trigger antecedents 
implementation aspects full implementation deduction parsing system complete encodings deduction systems sample grammars provided appendix 
code appendix covers aspects implementation described 

input encoding string parsed section 

implementation deduction engine driver including generation consequences section 

encoding storage items section including implementation chart section agenda section 

encoding deduction systems section 

implementation subsumption checking section 
prolog code edinburgh notation tested quintus prolog system 
alternative implementations implementation agenda chart provides compromise terms ciency simplicity generality 
possibilities occur reader may advantages certain conditions 
alternatives described section 
separate agenda chart database 
storage agenda chart separate predicates prolog database allows marginally cient lookup chart items extraneous arithmetic comparison indices eliminated 
method requires extra retraction assertion moving index agenda chart redundancy checking complex separate searches engaged 
passing agenda argument 
storing agenda database list agenda items passed argument 
implementation queues prolog straightforward natural structure agenda argument 
method marginal advantage antecedent lookup impossible perform cient redundancy checking relative items agenda 
merl tr may cient bottom interpretation 
algorithm just thought pure bottom evaluator inference rules de nite clauses head clause consequent rule body antecedent 
appropriate inference rules bottom procedure simulate non bottom parsing strategies top earley strategies described section 
researchers deductive databases extensively investigated variants idea take advantage tabulation results pure bottom procedure keeping track goal directed constraints possible answers 
part investigations cient bottom evaluators logic programs designed instance coral ramakrishnan srivastava sudarshan 
clearly system directly deduction parser 
construction derivations 
direct inference rules building derivations section computationally ine cient eliminates structure sharing chart 
ways deriving string yield distinct items sharing computation subderivations longer possible 
preferable method compute derivations ine traversing chart parsing nished 
deduction engine easily modi ed technique reminiscent core language engine alshawi 
versions inference rule online version earley system computation derivations ine version generate derivation information 
presume versions stored respectively predicates inference inference offline names rules specifying correspondence related rules 
similarly online initial item speci cation corresponding initial item offline version 
deduction engine parses string online version rules stores chart information ways chart item constructed unit clauses form stored history consequent rule antecedents 
speci es item index consequent generated inference rule name rule antecedent items sequence antecedents 
item generated initial item history mark fact unit clause constant initial rule argument 
parsing completed separate process applied goal item traverses stored histories second ine version inference rules rst building derivation information process 
prolog code serves purpose 
de nes offline item index merl tr may item predicate computes ine item item presumably including derivation information corresponding online item index index second version inference rules derivations stored chart history 
offline item index item stored history index initial initial item offline item 
offline item index item stored history index rule antecedents offline items antecedents inference offline rule item hold 
offline items 
offline items index indexes item items offline item index item offline items indexes items 
ine version inference rules need merely compute derivation 
perform computation dependent derivation semantic interpretation 
abstractly technique allows staging parsing phases second comprising ne grained version rst 
staged processing sort implemented technique 
finer control execution order certain applications may necessary obtain ner control order antecedent items side conditions checked inference rule triggered 
predicates items chart holds perform simple left right checking items side conditions implementation matching rule leads remaining antecedent items side conditions checked left right order appear encoded inference rules side conditions checked antecedent items 
may preferable check antecedents side conditions interleaved di erent orders depending antecedent triggered rule 
instance side condition second inference rule section handled checking antecedent rule order minimize nondeterminism 
rst antecedent trigger want check side conditions look second antecedent correspondingly triggering second antecedent 
implementation disallows possibility side conditions handled antecedent items 
merely swapping order handling side conditions antecedent items su cient example provide merl tr may general solution problem 
various alternatives possible implement ner level control 
especially solution elegant solutions possible 
encoding inference rule single unit clause encode clause trigger element predicate inference rulename antecedents consequent rulename consequent antecedents list antecedent items side conditions rule trigger item rst 
distinguish antecedent items side conditions disambiguating pre operator item 
versus side condition 
matching item rule proceeds looking item rst element antecedent list 
matching rule trigger rulename consequent inference rulename trigger consequent consequence predicate modi ed new matching rule predicate check antecedent items side conditions hold 
consequence index consequent index item index trigger matching rule trigger rulename consequent hold index 
antecedent items side conditions checked order occur encoding inference rule 
hold index 
hold antecedent antecedents index holds antecedent index hold antecedents index 
holds item index item chart item index 
holds index call 
view parsing deduction generalizes previous area possible simple method describing variety parsing algorithms top bottom mixed way highlights relationships abstracts away incidental merl tr may di erences control 
method generalizes easily parsers augmented phrase structure formalisms de nite clause grammars logic grammar formalisms 
deduction systems specify detailed control structure control information needed turn full edged parsers uniform single deduction engine performs sound complete bottom interpretation rules inference 
implemented deduction engine described proved useful rapid prototyping parsing algorithms variety formalisms including variants tree adjoining grammars categorial grammars lexicalized context free grammars 
material part supported national science foundation 
iri sms 
authors anonymous reviewers helpful comments earlier draft 
anthony mark steedman 

order words 
linguistics philosophy 
alshawi editor 

core language engine 
acl mit press series natural language processing 
mit press cambridge massachusetts 
bancilhon francois raghu ramakrishnan 

amateur recursive query processing strategies 
michael stonebraker editor readings database systems 
morgan kaufmann san mateo california section pages 
bresnan joan ron kaplan 

lexical functional grammar formal system grammatical representation 
bresnan editor mental representation grammatical relations 
mit press pages 
carpenter bob 

logic typed feature structures 
number cambridge tracts theoretical computer science 
cambridge university press cambridge england 
colmerauer alain 

metamorphosis grammars 
leonard editor natural language communication computers 
springer verlag pages 
appeared les de groupe intelligence arti universite de marseille ii november 
merl tr may earley jay 
cient context free parsing algorithm 
communications acm 
hodas joshua 
specifying ller gap dependency parsers linear logic programming language 
krzysztof apt editor proceedings joint international conference symposium logic programming washington pages 
joshi aravind levy takahashi 

tree adjunct grammars 
journal computer system sciences 
joshi aravind 
context sensitivity necessary characterizing structural descriptions tree adjoining grammars 
dowty karttunen editors natural language processing theoretical computational psychological perspectives 
cambridge university press new york 
kasami 
cient recognition syntax algorithm contextfree languages 
technical report af crl air force cambridge research laboratory bedford ma 
kay martin 

algorithm schemata data structures syntactic processing 
barbara grosz karen sparck jones bonnie lynn webber editors readings natural language processing 
morgan kaufmann los altos california chapter pages 
originally published xerox parc technical report 
anthony aravind joshi 

linguistic relevance tree adjoining grammars 
technical report ms cis department computer information science university pennsylvania april 
lambek joachim 

mathematics sentence structure 
mathematical monthly 
american lassez jean louis michael maher kim 

uni cation revisited 
jack minker editor foundations deductive databases logic programming pages san mateo california 
morgan kaufmann 
michael 

categorial investigations logical linguistic aspects lambek calculus 
ph thesis university amsterdam amsterdam netherlands october 
naughton je rey raghu ramakrishnan 

bottom evaluation logic programs 
jean louis lassez gordon plotkin editors computational logic essays honor alan robinson 
mit press cambridge massachusetts chapter pages 
merl tr may pareschi dale miller 

extending de nite clause grammars scoping constructs 
david warren peter szeredi editors seventh international conference logic programming jerusalem israel 
mit press 
patrick yves schabes aravind joshi 

xtag graphical workbench developing tree adjoining grammars 
proceedings third conference applied natural language processing pages trento italy 

lambek grammars context free 
proceedings eighth annual ieee symposium logic computer science pages montreal canada june 
ieee computer society press 
pereira fernando david warren 

de nite clause grammars language analysis survey formalism comparison augmented transition networks 
arti cial intelligence 
pereira fernando david warren 

parsing deduction 
st annual meeting association computational linguistics pages cambridge massachusetts june 
ramakrishnan raghu divesh srivastava sudarshan 

coral control relations logic 
procs 
international conf 
large databases 
ramakrishnan raghu 

magic templates approach logic programs 
robert kowalski kenneth bowen editors logic programming proceedings fifth international conference symposium pages seattle washington 
mit press 
rounds william 

logical version functional grammar 
th annual meeting association computational linguistics pages stanford california 
stanford university 
sato hisao tamaki 

enumeration success patterns logic programs 
theoretical computer science 
schabes yves stuart shieber 

alternative conception derivation 
proceedings twentieth annual meeting association computational linguistics pages 
schabes yves richard waters 

lexicalized context free grammars 
st meeting association computational linguistics acl pages columbus ohio june 
merl tr may schabes yves richard waters 

lexicalized context free grammar cubic time parsable formalism strongly context free grammar 
technical report mitsubishi electric research laboratories broadway 
cambridge ma 
schabes yves 

left right parsing lexicalized tree adjoining grammars 
computational intelligence 
appear 
shieber stuart 
criteria designing computer facilities linguistic analysis 
linguistics 
shieber stuart 
restriction extend parsing algorithms complex feature formalisms 
rd annual meeting association computational linguistics pages chicago illinois 
university chicago 
shieber stuart 
constraint grammar formalisms 
mit press cambridge massachusetts 
vijay shanker david weir 

parsing constrained grammar formalisms 
computational linguistics december 
vijay shanker 
study tree adjoining grammars 
ph thesis department computer information science university pennsylvania 
younger 
recognition parsing context free languages time information control 
merl tr may full code deductive parsing engine infer pli parser general tabular inference engine libraries module library 
provides read module library lists 
provides append reverse components ensure loaded input 
ensure loaded driver 
ensure loaded items 
ensure loaded inference 
ensure loaded grammars 
ensure loaded utilities 
ensure loaded monitor 
infer pli reading encoding input standard logic grammar literature list encoding strings string positions 
string taken list words string positions encoded su list index question 
position string encoded terry writes program halts encoded list program halts 
items include string positions quite large testing identity string positions cumbersome especially items stored directly prolog database 
reason direct encoding string positions complicated encoding merl tr may underlying strings 
string positions taken integers 
string encoded series unit clauses predicate word specifying words occur string positions 
instance string terry writes program halts speci ed unit clauses word terry 
word writes 
word 
word program 
word 
word halts 
string longer explicitly represented encoding predicate specify information 

predicate read input string perform conversion encoded form automatically asserting appropriate unit clauses string read 
input pli reading sentences preparing parser input length sentence parsed 
dynamic 
word ith word sentence parsed 
dynamic word 
read input merl tr may read sentence user assert words length 
read input read encode sentence 
encode sentence sentence clear input store encode input sentence 
encode sentence sentence word encode words sentence length assert length 
encode words words store input words position encode words length length 
encode words word words length length length length assert word length word encode words words length length 
input pli deduction engine driver main driver operates discussion section 
driver pli inference engine merl tr may parse value value value corresponding final item generated parsing sentence typed standard input 
parse value read input read sentence init chart init 
empty chart init agenda agenda init 
agenda include axioms exhaust agenda process agenda exhausted final item goal value get form final goal item item chart goal 
find items chart init agenda axioms agenda add indices corresponding axioms empty agenda 
init agenda agenda initial items axioms get axioms empty agenda empty add items agenda axioms empty agenda 
exhaust agenda generate consequences follow indices agenda 
exhaust empty empty agenda empty 
exhaust agenda pop agenda agenda index agenda add item chart index add consequences agenda index agenda agenda exhaust agenda 
add consequences agenda index agenda agenda merl tr may add agenda indices follow immediately index yielding agenda 
add consequences agenda index agenda agenda solutions consequence consequence index consequence consequences add items agenda consequences agenda agenda 
consequence index consequent consequent consequent inference rule antecedent satisfied item index items chart 
consequence index consequent index item index trigger matching rule trigger rulename consequent items chart index hold notify consequence rulename trigger consequent 
items chart items index elements items generated processing index agenda satisfied stored items chart 
items chart index 
items chart antecedent antecedents index item chart antecedent index items chart antecedents index 
hold conditions side conditions hold 
merl tr may hold 
hold cond conds call cond hold conds 
matching rule trigger rulename consequent find inference rule rulename antecedent form trigger consequent consequent rule side conditions 
denotes list concatenation 
matching rule trigger rulename consequent inference rulename antecedent consequent split trigger antecedent 
driver pli stored items comprising chart agenda items pli stored items stored index item predicate store agenda chart items prolog database unique identifying index assigned numerical order 
dynamic stored 
key index key index merl tr may predicate store auxiliary indexing table indexing stored items 
predicate item key compute key item 
dynamic key index 
item stored item index finds stored item amd index sequence stored items 
item stored item index item key item key key index key index stored index item 
similar item item find stored item stored items subsume item 
similar item item item key item key key index key stored 
subsumed item item item subsumed stored item 
subsumed item item similar item item subsumes item 
chart agenda ensure loaded chart 
ensure loaded agenda 
merl tr may items pli chart items chart pli 
chart init chart remove bits agenda chart clauses associated keys prolog database 
init chart stored key index 
item chart item retrieve stored item matching item 
index distinguishes items chart index agenda index 
index item chart largest index 
item chart item item stored item item chart true item items agenda looking chart items 
fail 
item chart item merl tr may item item chart generated agenda exhausted index pointing chart stored items chart items 
item chart item item stored item 
add item chart index add item stored index stored items chart 
need done moving agenda item changes index implicitly making item chart item just print debugging information 
add item chart index notify chart addition index 
chart pli agenda items agenda items just contiguous subsequence stored items 
speci cation items agenda implicitly chart provided head tail indices agenda subsequence 
queue speci cation agenda packed term functor queue passed argument deduction engine 
term queue head tail represents queue agenda items head index rst element queue tail index element put queue current element 
notice asymmetry add item agenda takes explicit items pop agenda produces indices may mapped items index item 
somewhat inelegant balances need abstraction generic algorithm ciency main solutions need store item consequences sought 
implementation adequate items agenda form contiguous set stored items indices sequential 
agenda pli merl tr may 
agenda empty agenda agenda holds agenda represents empty agenda 
empty agenda queue front back front back 
empty agenda agenda agenda new empty agenda 
empty agenda queue 
pop agenda agenda index index top index agenda agenda item removed 
pop agenda queue front back front queue back front back front 
add item agenda item agenda agenda add index corresponding item agenda yielding agenda 
stores appropriate items prolog database 
note stored clause asserted database index numbering provides ordering information allow early cut searches item chart 
add item agenda item queue front back queue front merl tr may notify agenda addition item subsumed item item stored back item item key item key assert key index key back back back 
add items agenda items agenda agenda add indices corresponding items agenda yielding agenda 
add items agenda agenda agenda 
add items agenda item items agenda agenda add item agenda item agenda agenda add items agenda items agenda agenda 
index item index item item actual stored item index 
index item index item stored index item 
agenda pli encoding deductive parsing systems prolog encodings deduction systems discussed including context free systems section ccg system described section 
deduction systems context free de nite clause grammars assume encoding grammar series unit clauses forms grammar rules grammar rules encoded clauses form lhs rhs lhs nonterminal rhs list nonterminals respectively left right hand side rule 
merl tr may lexicon lexicon encoded relation terminals unit clauses form lex term nonterminal dominating terminal covers terminal 
start symbol start symbol grammar encoded unit clause form start start start nonterminal grammar may nonterminals 
nonterminals terminal symbols encoded arbitrary terms constants 
distinction nonterminals terminals implicit terms exist left hand side rule 
inference pli inference rules parsing algorithms specified inference system 
includes definition class items inference rules items 
subsets corresponding initial items final items defined 
predicates defining inference system initial item item item initial item 
final item value value pertinent information return final item 
inference rulename antecedent consequent specifies inference rule named rulename antecedent items consequent item 
predicate define appropriate indexing items item key item key merl tr may key hash key associate item 
item stored prolog database key 
definitions predicates files ensure loaded inf top pl 
ensure loaded inf bottom pl 
ensure loaded inf earley pl 
ensure loaded inf ccg pl 
initial items items items initial items inference system 
initial items items solutions item initial item item items 
inference pli top system inf top pli parsing algorithm inference system pure top parsing op 
item encoding merl tr may item value list nonterminals terminals need position string string 
value term passed items returned final value associated parse 
seeded start category parse may instantiated parse progresses 
initial item item start start start 
final item item length value value length 
item indexing item key item index items indexed position category constituent 
item key item value index 
hash term index 
item key item value index hash term index 
inference rules 
scanner inference scanner merl tr may item beta value item beta value word bterm lex bterm 
predictor inference predictor item alpha value item value beta append beta alpha 
inf top pli bottom system inf bottom pli parsing algorithm inference system pure bottom parsing op 
item encoding item merl tr may list nonterminals terminals start string position note stack parsed constituents kept reversed order parsed left edge list 
initial item item 
final item item value length value length value 
item indexing item key item index items indexed position category constituent 
item key item index 
hash term index 
item key item index hash term index 
inference rules 
shift inference shift item beta item beta word bterm merl tr may lex bterm 
reduce inference reduce item item alpha beta reverse beta append alpha 
inf bottom pli earley algorithm system inf earley pli parsing algorithm inference system earley algorithm op 
ensure loaded library strings 
item encoding item lhs lhs dcg production reversal merl tr may indices string initial item item start start start 
final item item start start length start start length 
item indexing item key item key active edges indexed category constituent dot starting position constituent 
item key item alpha beta hash 
hash term hash 
passive edges dot indexed category parent constituent starting position constituent 
item key item alpha hash 
hash term hash 
inference rules 
scanner inference scanner item alpha beta item alpha beta merl tr may word bterm lex bterm 
predictor inference predictor item alpha beta item gamma gamma 
type inference item alpha beta item gamma item alpha beta 
inf earley pli combinatory categorial grammar system ccg parser section assumes encoding ccg grammar lexicon unit clauses form lex word category word word lexicon category ccg category word 
categories encoded terms functors forward slash backward slash 
start category encoded context free grammars 
inf ccg pli parsing algorithm inference system bottom combinatory categorial grammar parsing merl tr may encoding item cat deriv cat ccg category indices string deriv derivation item initial item item cat cat word word word lex word cat 
final item item start length start length 
item indexing item hash item index temporarily disabled 
item hash item index 
inference rules 
forward application inference forward application item item item merl tr may 
backward application inference backward application item item item 
forward composition inference forward composition item item item 
forward composition inference forward composition item item item 
backward composition inference backward composition item item item 
backward composition merl tr may inference backward composition item item item 
inf ccg pli sample grammars grammars pli sample grammars ensure loaded gram dcg pl 
ensure loaded gram ccg pl 
grammars pli sample de nite clause grammar de nite clause grammar encoded section 
gram dcg pli np vp np np vp vp 
np np det rel det det rel 
np np pn pn pn 
vp vp tv np tv tv np np 
vp vp iv iv iv 
rel vp vp vp 
rel epsilon 
merl tr may lex 
lex terry pn pn terry 
lex pn pn 
lex halts iv iv halts 
lex det det 
lex program program 
lex writes tv tv writes 

gram dcg pli sample combinatory categorial grammar combinatory categorial grammar encoded appropriately ccg deduction system 
gram ccg pli lex john lex bananas lex likes lex really np 
np 
np np 
np np 

gram ccg pli utilities utilities pli utilities subsumes general specific holds general subsumes specific 
merl tr may note quintus prolog subsumes chk replace subsumes 
explicit implementation left illustrate standard prolog idiom subsumption testing 
subsumes general specific ground specific general specific 
ground term instantiates variables term fresh constants 
ground term term 
solutions term goal solutions solutions list instances term goal holds 
free variables goal taken existentially quantified 
solutions may empty list solutions 
implementation relies details findall quintus prolog 
reimplemented standard built predicate setof follows solutions var goal solutions setof var goal goal solutions 
solutions var goal solutions findall var goal solutions 
split elem list rest list elem rest split term term rest rest 
split term rest rest split term rest rest 
merl tr may utilities pli monitoring debugging monitor pli monitoring verbose predicate governs degree verbosity notifications 
dynamic verbose 
notify 
prints debugging information flag verbose true 
notify consequence rulename trigger consequent verbose format trigger rulename trigger format format side conds format cons consequent true 
notify agenda addition item verbose format agenda item print 
notify chart addition index index item index item merl tr may item key item key verbose format chart key item print 
monitor pli merl tr may 
