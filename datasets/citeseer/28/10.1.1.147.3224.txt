dimacs series discrete mathematics theoretical computer science external memory algorithms data structures je rey scott vitter 
data sets large applications massive completely inside computer internal memory 
resulting input output communication fast internal memory slower external memory disks major performance bottleneck 
survey state art design analysis external memory algorithms data structures referred em core algorithms data structures 
em algorithms data structures designed analyzed parallel disk model pdm 
machine independent measures performance pdm number operations cpu time amount disk space 
pdm allows multiple disks disk arrays parallel cpus generalized handle tertiary storage hierarchical memory 
discuss important paradigms solve batched online problems ciently external memory 
programming tools environments available simplifying programming task 
tpie system transparent parallel programming environment easy cient terms execution speed 
report experiments tpie domain spatial databases 
newly developed em algorithms data structures incorporate paradigms discuss signi cantly faster methods currently practice 

input output communication simply fast internal memory slow external memory disk bottleneck process massive amounts data 
promising approach design algorithms bypass virtual memory system explicitly manage refer algorithms external memory algorithms mathematics subject classi cation 

key words phrases 
external memory secondary storage disk block input output core hierarchical memory multilevel memory batched online external sorting 
supported part army research ce muri daah national science foundation research ccr eia 
part done brics university aarhus denmark inria sophia antipolis france 
earlier versions entitled external memory algorithms appeared invited tutorial proceedings th annual acm symposium principles database systems seattle wa june invited proceedings th annual european symposium algorithms venice august 
updated version available electronically author web page www cs duke edu jsv 
je rey scott vitter jeffrey scott vitter simply em algorithms 
terms core algorithms algorithms 
survey paradigms solving problems ciently external memory 
problems consider fall general categories 
batched problems preprocessing done entire le data items processed stream mode passes data 

online problems computation done response continuous series query operations 
common technique online problems organize data items hierarchical index small portion data needs examined response query 
data queried static preprocessed cient query processing dynamic queries intermixed updates insertions deletions 
base approach parallel disk model pdm described section 
pdm provides elegant reasonably accurate model analyzing relative performance em algorithms data structures 
main performance measures pdm number operations disk space usage cpu time 
reasons brevity focus rst measures 
algorithms discuss cient terms cpu time 
section look canonical batched em problem external sorting related problems permuting fast fourier transform 
important paradigms distribution merging account known external sorting algorithms 
provide fundamental lower bounds number os needed perform sorting batched problems external memory 
brie discuss grid linear algebra batched computations section 
section ective paradigms batched em problems computational geometry 
paradigms include distribution sweep spatial join nding nearest neighbors persistent trees batched point location graph drawing batched ltering convex hulls batched point location external fractional cascading red blue line online ltering cooperative search fractionally cascaded data structures external conquest output sensitive convex hulls randomized incremental construction gradations line segment intersections geometric problems 
section look em algorithms combinatorial problems graphs 
cases cient algorithms obtained sorting simulate known parallel algorithms 
sections spatial data structures online setting 
section begins discussion trees important dynamic online em data structure 
trees method choice dictionary operations dimensional range queries 
weight balanced trees provide uniform mechanism dynamically rebuilding substructures level balanced trees permit maintenance parent pointers 
useful building interval trees doing dynamic point location external memory 
bu er tree called batched dynamic version tree cient implementation search trees priority queues em sweep line applications consider multidimensional extensions tree 
trees variants practice multidimensional spatial applications range searching spatial external memory algorithms data structures 
platter magnetic disk drive 
joins 
section discuss specialized spatial structures online multidimensional range search yield optimal bounds di erent cases range searching 
nonlinear disk space required order achieve optimal query performance general range searching 
contrast trees linear space bad worst case performance 
data structures sorting searching nding matches strings focus section 
section discuss programming environments tools facilitate high level development cient em algorithms 
section demonstrate problems arising spatial databases signi cant speedups obtained practice cient em techniques 
tpie system programming environment covered section implementations 
section discuss em algorithms adapt optimally dynamically changing memory allocations 
conclude nal remarks observations section 

parallel disk model pdm external memory algorithms explicitly control data placement movement important algorithm designers reasonably accurate model memory system characteristics 
magnetic disks consist rotating read write head platter surface 
data stored concentric circles called tracks shown 
read write data item certain address disk read write head mechanically seek correct track wait desired address pass 
seek time move random track order milliseconds average rotational latency time half revolution order magnitude 
order amortize delay pays transfer large collection contiguous data items called block 
similar considerations apply levels memory hierarchy 
application structure pattern memory accesses exploit locality take full advantage disk block transfer substantial access gap internal memory performance external memory performance 
fact access gap growing speed memory chips increasing quickly disk bandwidth 
parallel processors widens jeffrey scott vitter dd internal memory internal memory internal memory internal memory cpu cpu cpu cpu interconnection network 
parallel disk model gap 
storage systems raid developed deploy multiple disks get additional bandwidth 
section describe high level parallel disk model pdm design analysis algorithms data structures 
section list fundamental bounds pertain problems considered 
practical considerations pdm alternative memory models discussed sections 

pdm problem parameters 
capture main properties magnetic disks multiple disk systems commonly parallel disk model pdm introduced vitter shriver problem size units data items internal memory size units data items block transfer size units data items independent disk drives cpus db 
single disks simultaneously transfer block contiguous data items 
processors drive disks disk shared processors 
internal memory size processor processors connected network 
desired property network capability sort data items collective main memories processors parallel optimal log time 
special cases pdm pictured 
queries naturally associated online computations done batched mode 
example batched orthogonal range searching problem discussed section set points plane set queries form rectangles problem report points notation log denote binary base logarithm log bases base speci ed explicitly 
external memory algorithms data structures stripe stripe stripe stripe 
initial data layout disks disks block size 
input data items initially striped block disks 
example data items stored second block stripe disk 
lying query rectangles 
batched online settings number items reported response query may vary 
need de ne performance parameters queries batched problem query output size units data items convenient refer pdm parameters units disk blocks units data items 
de ne lower case notation problem input size internal memory size query speci cation size query output size respectively units disk blocks 
assume input data initially striped disks units blocks illustrated require output data similarly striped 
striped format allows le data items read written db os optimal 

fundamental bounds objectives 
primary measures performance pdm 
number operations performed 
amount disk space 
internal parallel computation time 
reasons brevity focus rst measures 
algorithms mention run optimal cpu time case 
ideally algorithms data structures linear space means disk blocks storage 
performance algorithms data structures expressed terms bounds fundamental operations 
scanning streaming touching le data items takes db os 

sorting items done logm os 
db logm 
online search items takes os 

reporting answers query blocked fashion external memory takes dz dz de os 
rst bounds scanning sorting apply batched problems 
mentioned earlier batched problems involve queries jeffrey scott vitter case bound query reporting relevant 
bounds online search query reporting apply online problems 
typically assume online problems disk case bounds online search query reporting simply logb multiple disks generally optimal way online problems disk striping technique explained section 
batched problems consider sorting ffts triangulation computing convex hulls algorithms solve corresponding internal memory versions problems log cpu time 
deploy algorithm naively external memory setting virtual memory handle page management may require log os excessive 
similarly online setting problems solved log query time internal memory data structure external memory setting may require log os query 
achieve bounds logm batched example online case 
risk paraphrase goal em algorithm design syntactic way derive cient algorithms terms bounds naive algorithms replaced base logarithm terms case batched problems db case online problems 
relative speedup performance signi cant theoretically practice 
example batched problems performance improvement factor log logm db log large 
online problems performance improvement factor log log db log log db log db signi cant practice asz db large bound db trivial batched problem scanning considered linear number os pdm model 
interesting feature pdm model nontrivial batched problems require nonlinear number os solved easily linear cpu time internal memory ram model 
examples discuss include permuting transposing matrix combinatorial graph problems 
sorting equivalent complexity problems 
practice nonlinear log term sorting bound log db term searching bound small constants 
example units items case get log 
memory shared processes log term somewhat larger 
online applications smaller value appropriate explained section corresponding value log db example 
sense identify terms log log db hide big oh factors terms signi cant di erence practice 
course equally important consider constants hidden big oh notations 
nonlinear bound logm usually indicates multiple extra passes data required 
truly massive problems data reside tertiary storage 
mention brie section pdm algorithms generalized recursive framework handle multiple levels memory 
multilevel algorithm developed pdm algorithm external memory algorithms data structures os run order magnitude faster hierarchical memory multilevel algorithm generated pdm algorithm log os 

practical modeling considerations 
track size parameter disk hardware altered disks range kilobytes 
batched applications block transfer size pdm chosen signi cant fraction track size small multiple track size better amortize seek time 
online applications smaller value appropriate minimum block transfer size imposed systems kilobytes 
pdm generic programming model facilitates elegant design cient algorithms especially conjunction programming tools discussed section 
complex precise disk models developed ones ruemmler wilkes shriver farach 
distinguish sequential reads random reads consider ects throughput features disk bu er caches shared buses reduce time eliminating hiding seek time 
practice ects complex models realized approximated pdm appropriate choice parameters 
bottom line programs perform terms pdm generally perform implemented real systems 

memory models 
study problem complexity algorithm analysis external memory devices began years ago ph thesis sorting 
early knuth extensive study sorting magnetic tapes lesser extent magnetic disks 
time floyd considered disk model akin pdm constant developed optimal upper lower bounds sorting matrix transposition 
hong kung developed model computations savage vitter extended model deal block transfer 
aggarwal vitter generalized floyd model allow simultaneous block transfers model unrealistic simultaneous transfers allowed take place single disk 
developed matching upper lower bounds parameter values host problems 
pdm model thought restrictive realistic version aggarwal vitter model lower bounds apply pdm 
modi ed versions pdm integrate various aspects parallel computation developed 
surveys models algorithms appear 
models active disks augmented processing capabilities reduce data tra host especially scanning applications 
type bottleneck occurs internal memory external disk storage occur levels memory hierarchy registers data cache data cache level cache level cache dram disk storage tertiary devices 
pdm model generalized model hierarchy memories ranging registers small tertiary storage large 
optimal algorithms pdm generalize recursive fashion yield optimal algorithms hierarchical memory models 
match theory practice harder jeffrey scott vitter establish hierarchical models simpler models practical practical models cumbersome 
reasons brevity emphasis consider hierarchical models 
refer reader aggarwal de ne elegant hierarchical memory model aggarwal augment block transfer capability 
alpern model levels memory memory size block size bandwidth grow uniform rates 
vitter shriver vitter nodine discuss parallel versions variants hierarchical models 
parallel model li applies hierarchical memory 
savage gives hierarchical version 
carter de ne models nonassociative direct mapped caches 

external sorting related problems problem external sorting sorting external memory central problem eld em algorithms partly sorting sorting operations account signi cant percentage computer sorting important paradigm design cient em algorithms 
technical quali cations problems solved easily linear time internal memory list ranking expression tree evaluation nding connected components sparse graph require number os pdm sorting 
theorem 
average case worst case number os required sorting data items disks logm log dlog conceptually simpler program single disk case multiple disk case 
disk striping paradigm ease programming task multiple disks 
os permitted entire stripes time 
example data layout data items accessed single step blocks grouped stripe 
net ect striping disks behave single logical disk larger logical block size db 
consider happens technique disk striping conjunction optimal sorting algorithm disk 
optimal number os disk log log log blog ect disk striping disks replace db yields bound log db db log db log dlog striping bound larger optimal bound factor log log signi cant order causing log term denominator small 
order attain optimal sorting bound theoretically wemust able control disks independently disk access di erent stripe external memory algorithms data structures step 
sorting disk striping cient practice complicated techniques utilize independent disks log log factor may additional overhead disks independently 
sections consider developed external sorting algorithms distribution merge paradigms 
srm method uses randomized merge technique outperforms disk striping practice reasonable values see section 
sections consider related problems permuting fast fourier transform 
methods cover exception greed sort section access disks independently parallel read operations parallel writes done striped manner facilitates writing parity error correction information 
refer reader discussion error correction issues 
section discuss fundamental lower bounds number os needed perform sorting batched problems external memory 

sorting distribution simultaneous online load 
distribution sort recursive process data items sorted partitioned set partitioning elements buckets 
items bucket precede items bucket 
individual buckets sorted recursively concatenated form single totally sorted list 
partitioning elements chosen buckets roughly equal size 
case bucket sizes decrease bya factor level recursion logs levels recursion 
level recursion data streamed internal memory buckets written disks online manner streaming proceeds 
double bu er size allocated buckets 
half double bu er lls block written disk half store incoming items 
maximum number buckets partitioning elements resulting recursion logm 
di cult nd partitioning elements os guarantee bucket sizes constant factor 
cient deterministic methods exist choosing partitioning elements ect doubling number levels recursion 
probabilistic methods random sampling 
order meet sorting bound formation buckets level recursion done os easy case 
general multiple disk case read step write step bucket formation involve average blocks 
le items partitioned buckets formed previous level recursion 
order read le ciently blocks spread uniformly disks disk bottleneck 
challenge distribution sort write blocks buckets disks online manner achieve global load balance partitioning bucket read ciently level recursion 
partial striping ective technique reducing amount information stored internal memory order manage disks 
disks grouped clusters size data written logical blocks size cb jeffrey scott vitter cluster 
choosing won change optimal sorting time constant factor pointed earlier full striping nonoptimal 
vitter shriver randomized online techniques partitioning high probability bucket balanced disks 
partial striping pointers needed keep track layout buckets disks internal memory 
rst technique size le partition su ciently large db log number blocks bucket log 
parallel write operation writes blocks random order disk stripe 
orders equally 
partitioning high probability block evenly distributed disks 
situation analogous hashing scenario number inserted items larger logarithmic factor number bins hash table causing items spread fairly evenly expected maximum bin size constant factor expected bin size 
number blocks bucket log technique breaks distribution bucket disks tends uneven 
smaller values vitter shriver di erent technique pass le read time 
randomly permuted written back tothe disks new order 
second pass le accessed time diagonally striped manner 
show high probability individual diagonal stripe contributes number items bucket blocks buckets assigned disks balanced round robin manner optimal number os 
better way distribution sort deterministically method developed nodine vitter 
partitioning process algorithm keeps track bucket distributed far disks 
sand numb total number items bucket processed far partitioning numb number items written disk numb numb 
algorithm able write half disks maintain invariant bucket bd largest values numb numb numb di er numb twice ideal value numb alternative sorting technique higher overhead bu er tree data structure described section developed batched dynamic applications 
dewitt randomized distribution sort algorithm similar model handle case sorting done passes 
sampling technique nd partitioning elements route items bucket particular processor 
buckets sorted individually second pass 
matias develop optimal place distribution sort algorithms disk function number distinct key values 
corresponding bound log minfk ng technique extended bounds merge sort 
external memory algorithms data structures distribution sort algorithms may advantage merge approaches section typically better lower levels cache memory hierarchy systems 
intuition comes analysis distribution sort merge sort algorithms models hierarchical memory model vitter nodine 

sorting merging 
merge paradigm somewhat orthogonal distribution paradigm discussed section 
atypical merge sort algorithm works follows run formation phase blocks data streamed memory time sorted single run output stripes disk 
run formation phase sorted runs striped disks 
actual implementations replacement selection technique get runs data items average 
initial runs formed merging phase begins 
pass merging phase groups runs merged 
merge block run resides internal memory 
data items block expire block run input 
double bu ering keep disks busy 
runs merged time resulting number passes logm 
achieve optimal sorting bound merging pass done os easy single disk case 
general multiple disk case parallel read operation merging average bring blocks needed merging 
challenge ensure blocks reside di erent disks read single small constant number os 
di culty lies fact runs merged formed previous merge pass 
blocks written disks previous pass knowledge interact runs merges 
perfect solution blocks needed merge guaranteed distinct disks devised binary merging case principle rst run striped ascending order disk number run striped descending order 
regardless items runs interleave merge case blocks needed output accessed single operation amount internal memory bu er space needed binary merging kept minimum 
unfortunately analog principle need value large order get optimal sorting algorithm 
greed sort method nodine vitter rst optimal deterministic em algorithm sorting multiple disks 
handles case relaxing condition merging process 
step blocks disk brought internal memory block smallest data item value block largest item value smallest 
block read memory added output stripe 
blocks merged memory smaller items written output stripe remaining items written back disk 
resulting run produced approximately merged jeffrey scott vitter table 
ratio number os simple randomized merge sort srm number os merge sort disk striping merge kd runs 
gures obtained simulation back pessimistic analytic upper bound 
run saving grace inverted items far apart 
nal application conjunction partial striping su ces restore total order 
optimal deterministic merge sort somewhat higher constant factors distribution sort algorithms developed aggarwal plaxton hypercube sorting algorithm 
guarantee distribution merging employs high level merging schemes scheduling oblivious 
practical method sorting simple randomized merge sort srm algorithm referred randomized striping knuth 
run striped disks random starting point place algorithm randomness utilized 
merging process block needed disk read memory room needed blocks ushed os required free space 
expected performance srm optimal parameter values signi cantly outperforms disk striping reasonable values parameters shown table 
derive upper bound performance precise analysis interesting open problem 
applying srm bu er management techniques distribution sort 
hope get better sorting performance means improved cache utilization intuition mentioned previous section 

permuting transposition 
permuting special case sorting key values data items form permutation ng 
theorem 
average case worst case number os required permuting data items disks min logm bound permuting realized sorting algorithms section extreme case log log case faster move data items non blocked way 
method trivial multiple disks may bottlenecks individual disks solution doing permuting os apply randomized balancing strategies 
external memory algorithms data structures matrix transposition special case permuting permutation represented transposition matrix row major order order 
theorem 
number os required disks transpose matrix row major order column major order logm minfm ng pq large compared matrix transposition hard general sorting smaller special structure transposition permutation transposition easier 
particular matrix broken square submatrices elements submatrix contains blocks matrix row major order blocks matrix column major order 
transpositions done simple pass operation transposing submatrices time internal memory 
matrix transposition special case general class permutations called bit permute complement bpc permutations turn subset class bit matrix multiply complement permutations 
permutations de ned log log nonsingular matrix log length vector item binary address mapped permutation binary address ax bpc permutations special case permutations permutation matrix column contain single 
bpc permutations include matrix transposition bit reversal permutations arise fft vector reversal permutations hypercube permutations matrix 
cormen characterize optimal number os needed perform permutation solely function associated matrix give optimal algorithm implementing 
theorem 
number os required disks perform permutation de ned matrix vector rank log lower left log log submatrix interesting theoretical question simple characterization function input cost general permutation 

fast fourier transform 
computing fast fourier transform fft external memory consists series os permit computation implied fft directed graph butter done arguments internal memory 
permutation network computation consists xed pattern os 
possible permutations realized data items reordered internal memory 
permutation network realized series ffts 
theorem 
disks number os required computing input fft digraph input permutation network bound sorting 
jeffrey scott vitter cormen nicol give practical implementations dimensional ffts optimal pdm algorithm 
algorithms fft faster simpler sorting computation nonadaptive nature communication pattern oblivious 

lower bounds section prove lower bounds theorems mention related lower bounds batched problems computational geometry graphs 
trivial batched problem scanning streaming touching le data items done linear number db os 
permuting simple problems done linear cpu time internal memory ram model require nonlinear number os pdm locality constraints imposed block parameter proof permutation lower bound theorem due aggarwal vitter 
idea proof measure number distinct orderings realizable sequence os 
value number distinct orderings rst exceeds bound average number os worst case number os needed permuting 
assume moment disk 
consider number realizable orderings change read disk block internal memory 
data items block items internal memory ways number realizable orderings increases factor block resided internal memory number realizable orderings increases extra 
factor items block permuted 
extra contribution 
happen original blocks 
ect writing disk block considerably reading 
log ways choose disk block 
allow algorithm arbitrary amount disk space 
number distinct orderings realized sequence os log setting expression simplifying logarithm get log log log nlog get lower bound case solving general lower bound follows dividing permuting special case sorting permuting lower bound applies sorting 
case log log permuting bound resort comparison model get full lower bound theorem 
arge show comparison model problem log lower bound ram model requires logm os pdm 
typical case log log comparison model needed prove sorting lower external memory algorithms data structures bound di culty sorting case arises determining order data permuting routing data 
proof permuting works permutation networks communication pattern oblivious 
choice disk block xed log term correspondingly additive log term inner expression 
solve get lower bound 
lower bound follows directly counting argument sorting derivation require comparison model case log log 
lower bound applies directly ffts permutation networks formed ffts sequence 
transposition lower bound involves potential argument relation 
related argument demonstrates optimality algorithm sorting items distinct key values 
chiang arge arge give models lower bound reductions computational geometry graph problems 
problems list ranking expression tree evaluation nonlinear lower bound permuting 
problems connected components biconnected components minimum spanning trees sparse graphs edges vertices require os instances sorting items 
situation contrast ram model problems done linear cpu time 
known linear time ram algorithm minimum spanning tree randomized 
cases gap best known upper lower bounds discuss section 
geometry problems discussed section equivalent sorting internal memory pdm models 
lower bounds mentioned assume data items sense indivisible split reassembled magic way get desired output 
conjectured sorting lower bound remains valid assumption lifted 
arti cial problem related transposition adler showed removing assumption lead faster algorithms 
similar result shown arge decision problem determining data item values distinct 
conjecture true challenging theoretical problem 

matrix grid computations dense matrices generally represented memory row major order 
matrix transposition special case sorting involves conversion matrix representation discussed section 
certain operations matrix addition representations 
standard matrix multiplication semiring operations pand lup decomposition better representation block matrix square submatrices gives upper bound theorem theorem 
number os required standard matrix multiplication kp matrices compute lu factorization matrix minfk gdb hong kung nodine give optimal em algorithms iterative grid computations leiserson reduce number os naive multigrid implementations factor 
gupta show jeffrey scott vitter derive cient em algorithms automatically computations expressed tensor form 
matrix sparse number nz nonzero elements smaller may cient store nonzero elements 
nonzero element ai represented triple ai 
dense case transposition easier sorting see theorem transposition sparse matrices hard sorting theorem 
matrix stored format containing nz nonzero elements number os required matrix row major order column major order vice versa nz logm nz lower bound follows reduction sorting 
ith item input sorting instance key value nonzero element matrix position 
defer discussion numerical em algorithms refer reader toledo survey volume 
issues regarding programming environments discussed section 

batched problems computational geometry problems involving massive amounts geometric data ubiquitous spatial databases geographic information systems gis constraint logic programming object oriented databases statistics virtual reality systems computer graphics 
nasa earth observing system project core part earth science enterprise mission planet earth produces petabytes bytes raster data year 
microsoft online database satellite images terabyte size 
major challenge develop mechanisms processing data useless 
systems size cient need fast em algorithms data structures basic problems computational geometry 
luckily problems geometric objects reduced small core problems computing intersections convex hulls nearest neighbors 
useful paradigms developed solving problems external memory 
theorem 
batched problems related problems involving input items queries output items solved log os set relevant particular problem 
computing pairwise intersections orthogonal segments plane 
answering orthogonal range queries points plane nding points query rectangles 
computing pairwise intersections segments plane brevity remainder deal single disk case 
single disk bounds batched problems cut factor case load balancing techniques section 
practice disk striping may su cient 
online problems disk striping convert optimal bounds case optimal bounds 
external memory algorithms data structures 
finding intersections nonintersecting red line segments nonintersecting blue line segments plane 

constructing convex hull points 
voronoi diagram triangulation points plane 
performing point location queries planar subdivision size 
finding nearest neighbors set points plane 
finding pairwise intersections orthogonal rectangles plane 
computing measure union orthogonal rectangles plane 
computing visibility segments plane 
performing ray shooting queries constructive solid geometry csg models size goodrich zhu arge arge develop em algorithms problems em paradigms batched problems distribution sweeping generalization distribution paradigm section externalizing plane sweep algorithms persistent trees ine method constructing optimal space persistent version tree data structure see section yielding factor improvement generic persistence techniques driscoll :10.1.1.41.7473
batched ltering general method performing simultaneous external memory searches data structures modeled planar layered directed acyclic graphs external fractionally cascaded data structures useful convex hulls batched point location 
external fractional cascading em analog fractional cascading segment tree 
online ltering technique tamassia vitter online queries data structures fractional cascading 
external marriage conquest em analog known technique kirkpatrick seidel performing output sensitive convex hull constructions 
randomized incremental construction gradations localized version incremental construction paradigm clarkson shor 
distribution sweep paradigm fundamental sweep line processes 
example compute pairwise intersections orthogonal segments plane recursive distribution sweep level recursion plane partitioned vertical strips containing segments endpoints 
sweep horizontal line top bottom process segments 
vertical segment encountered sweep line segment inserted appropriate strip 
horizontal segment encountered sweep line report intersections active vertical segments strips spanned completely 
vertical segment active intersected current sweep line vertical segments longer active deleted strips 
remaining portions partially span strip passed recursively level vertical segments 
initial sorting preprocessing log levels recursion requires os yielding desired bound 
arge develop uni ed approach distribution sweep higher dimensions :10.1.1.41.7473
jeffrey scott vitter central operation spatial databases spatial join 
common preprocessing step nd pairwise intersections bounding boxes objects involved spatial join 
problem intersecting orthogonal rectangles solved combining previous algorithm orthogonal segments range searching 
uni ed approach extendible higher dimensions taken arge distribution sweep :10.1.1.41.7473
objects stored data structure case rectangles vertical segments 
branching factor chosen 
rectangle associated largest contiguous range vertical strips spans 
possible contiguous ranges called multislab 
branching factor chosen accommodate bu er internal memory multislab height tree remains log 
resulting algorithm outperforms techniques empirical timings section 
arge give algorithm nding intersections line segments output component bound slightly nonoptimal log incremental randomized construction attain optimal bound line segment intersection problems 
compute trapezoidal decomposition intersecting segments 

batched problems graphs rst em graph algorithms ullman yannakakis problem transitive closure 
chiang consider variety graph problems lower bounds related permuting 
key idea chiang exploit cient em algorithms developed sequential simulation parallel algorithm problem 
sorting done periodically data 
list ranking subroutine solution graph problems number working processors parallel algorithm decreases geometrically time number os entire simulation proportional number os rst phase sorting bound logm 
dehne kaufmann show howto get cient bounds exploiting coarse grained parallel algorithms certain assumptions parameters pdm model assuming logm total disk space usage periodic done linear number os 
list ranking optimality em algorithm assumes log log usually true 
assumption removed bu er tree data structure see section 
practical randomized implementation list ranking appears 
em graph algorithms appears 
problem store graphs disks cient traversal discussed 
em problems arise data mining line analytical processing include constructing classi cation trees computing wavelet decompositions histograms 
complexity basic graph problems considered remain open including connected components topological sorting shortest paths breadth rst search depth rst search 
example external memory algorithms data structures graph vb vertices eb edges best known em algorithms breadth rst search depth rst search transitive closure require logm vv os respectively 
connected components determined logm log maxf log vb os deterministically logm os probabilistically 
order parallel simulation technique yield cient em algorithm parallel algorithm processors preferably unfortunately polylog time algorithms problems depth rst search shortest paths polynomial number processors 
interesting connection parallel domain em domain suggests may relationships computational complexity classes related parallel computing complete problems related ciency 

spatial data structures attention online spatial data structures massive data applications 
purposes exposition consider dictionary lookup orthogonal range search canonical query operations 
want data structures support insert delete lookup orthogonal range query 
value lookup operation returns item structure key value range query dimensional rectangle returns points interior rectangle 
spatial data structures tend types space driven data driven 
quad trees grid les hashing space driven partitioning embedding space methods trees kd trees organized partitioning data items 
discuss primarily type section 

trees variants 
tree data structures arise naturally dynamic online setting data updated queries processed immediately 
binary trees host applications ram model 
order exploit block transfer trees external memory generally block node store pointers data values 
tree degree bc leaf nodes ne levels 
known tree due bayer logb mccreight balanced multiway tree height roughly logb node degree 
root node allowed smaller degree 
trees support dynamic dictionary operations dimensional range search optimally linear space log os query log os insert delete 
ows insertion splits half full nodes splitting causes parent ow parent node splits 
splittings propagate root 
deletions handled symmetric way merging nodes 
tree variant pictured items stored leaves leaves linked symmetric order facilitate range queries sequential access 
internal nodes store key values pointers higher branching factor 
popular variant ofb trees called trees splitting usually postponed node ows sharing node data adjacent siblings 
node needs split sibling full happens node splits data full sibling evenly redistributed making jeffrey scott vitter level level leaves 
tree multiway search tree 
internal leaf node corresponds disk block 
items stored leaves 
internal nodes store key values pointers node 
indicated leaf blocks linked sequentially 
nodes full 
local optimization reduces new nodes created increases relative storage utilization 
sharing done trees yao shows nodes roughly ln full average assuming random insertions 
sharing trees average storage utilization increases ln 
storage utilization increased sharing siblings insertions deletions get complicated 
persistent versions trees developed becker verma 
lomet salzberg explore mechanisms add concurrency recovery trees 
arge vitter give useful variant trees called weight balanced trees property number data items subtree height xed parameter order 
contrast sizes subtrees level regular tree di er factor exponential 
level gets rebalanced rebalancing needed subtree updated ah times 
feature support applications cost rebalance node allowing rebalancing done amortized worst case way os 
weight balanced trees originally conceived part optimal dynamic data structures stabbing queries segment trees external memory discuss section applications internal memory ram model 
example setting constant get simple worst case implementation interval trees internal memory 
serve simpler worst case alternative data structure augmenting dimensional data structures range restriction capabilities 
agarwal develop interesting variant trees called level balanced trees maintain parent pointers 
straightforward modi cation conventional trees require log os split maintain parent parents 
level balanced trees support insert delete merge split operations log log os amortized bounded log agarwal level balanced trees data structure point location monotone subdivisions supports queries amortized updates logb os 
dynamically maintain planar st graphs logm logb os amortized update reachability queries answered logb os worst case 
external memory algorithms data structures open results improved 
question deal non monotone subdivisions 
question level balanced trees implemented log os update 
improvement immediately give optimal dynamic structure reachability queries planar st graphs 

bu er trees 
batched problems computational geometry solved plane sweep techniques 
example section showed compute orthogonal segment intersections keeping track vertical segments hit horizontal sweep line 
tree store hit vertical segments insertion query uses log os resulting bound log times larger desired bound log 
solution suggested binary tree items pushed lazily tree blocks items time 
binary nature tree results data structure height log yielding total bound log nonoptimal signi cant log factor 
arge developed elegant bu er tree data structure support batched dynamic operations sweep line example queries answered right away particular order 
bu er tree balanced multiway tree degree possibly root 
key distinguishing feature node bu er store items blocks items 
items node pushed children bu er lls 
emptying bu er requires os amortizes cost distributing items children 
item incurs amortized cost os level 
queries updates take logm os amortized 
bu er trees subroutine standard sweep line algorithm order get optimal em algorithm orthogonal segment intersection 
arge showed extend bu er trees implement segment trees external memory batched dynamic setting reducing node degrees introducing node 
bu er trees expanding list applications 
provide example natural amortized implementation priority queues applications discrete event simulation sweeping list ranking 
provide worst case optimal priority queue sense sequence insert delete min operations requires log os 

multidimensional spatial structures 
grossi italiano construct multidimensional version trees called cross trees combine data driven partitioning weight balanced trees upper levels tree space driven partitioning methods quad trees lower levels tree 
dimensional orthogonal range queries done os inserts deletes take log os 
data structure uses linear space supports dynamic operations split concatenate os 
way get multidimensional em data structures augment known internal memory structures quad trees kd trees block access capabilities 
examples include grid les kd trees buddy trees hb trees 
technique linearize multidimensional space imposing total ordering called space lling curve total order organize points tree 
jeffrey scott vitter methods described paragraph linear space certain situations worst case range query performance better cross trees methods grid les queries require os points satisfying query 
refer reader broad survey methods 
space lling curves arise connection trees describe section 

trees 
tree guttman variants elegant multidimensional generalization tree storing variety geometric objects points segments polygons polyhedra 
internal nodes degree possibly root leaves store items 
node tree associated bounding box bounding polygon elements subtree 
big di erence trees trees trees bounding boxes sibling nodes allowed overlap 
tree point location example point bounding box children current node search 
case search proceed children 
heuristics insert new items tree rebalance surveyed 
methods perform practical cases especially low dimensions poor worst case bounds 
interesting open problem nontrivial bounds proven typical case behavior trees problems range searching point location 
similar questions apply methods discussed previous section 
tree variant beckmann give best query performance 
precomputing tree repeated insertions extremely slow 
faster alternative hilbert tree kamel faloutsos 
item labeled position center hilbert space lling curve tree built bottom manner totally ordered labels 
bulk loading hilbert tree easy center points quality hilbert tree terms query performance tree especially higher dimensional data 
arge van den devised fast bulk loading methods trees bu er trees 
method especially cient support dynamic batched updates queries 
experiments technique discussed section 

online multidimensional range searching multidimensional range search fundamental primitive online geometric applications provides indexing support new constraint data models object oriented data models 
see background 
discussed multidimensional range searching batched setting section 
section concentrate important online case 
types range searching problems di cult develop theoretically optimal algorithms 
seen linear space online data structures sections query performance optimal 
open problems remain 
primary theoretical challenges fold 
get combined search output cost queries log os 
linear amount disk storage space 
support dynamic updates log os 
external memory algorithms data structures develop optimal data structures queries helpful combine cost log search component cost reporting output criterion consider search cost separately output cost cost larger query algorithm extra freedom ltering paradigm search component output reporting allowed larger number os 
subramanian ramaswamy prove lower bound em data structure range searching achieve criterion log log logb disk blocks relax allow logb os query constant result holds em version pointer machine model approach chazelle internal memory model 
hellerstein consider generalization layout lower bound argument kanellakis studying tradeo disk space usage query performance 
cient data structure expected contain output points query compactly dz blocks 
shortcoming model considers data layout ignores search component queries rules ltering approach 
example reasonable query algorithm perform logb os output size algorithm may able satisfy criterion output contained logb blocks blocks 
consider output sizes larger logb problem nd relevant blocks ignored 
despite shortcoming model elegant provides insight complexity blocking data external memory 
results model appear 
data structure restricted contain single copy item singh show restricted class index trees dimensional range queries worst case require os provide data structure matching bound 
approach toachieve bound cross tree data structure mentioned section addition supports operations split concatenate 
lower bounds mentioned range search apply general rectangular queries 
natural question ask data structures meet criteria interesting special cases orthogonal range searching 
fortunately answer 
precise de ne sd sided range query dimensional space si orthogonal range query si nite limits xi dimension 
example range query isa sided range query nite limits dimension nite limit dimension 
general range query sided query 
see 
dimensional cases studied authors terms sided sided range query mean call sided sided sided queries respectively 
arge vitter design em interval tree data structure weight balanced tree meets criteria 
uses linear disk space queries log os updates log os 
solves problems stabbing queries dynamic interval management utilizing optimal static structure kanellakis 
stabbing queries equivalent jeffrey scott vitter 
di erent types range queries diagonal corner sided query sided query sided query general sided query 
sided range queries corner point diagonal 
applications arise graphics gis 
example chiang silva apply em interval tree structure extract query time boundary components isosurface contour surface 
data structure related problem addition optimal output complexity appears 
interval tree approach yields dynamic em segment trees optimal query update bound log block space usage 
sided sided range queries ramaswamy subramanian introduce notion path caching develop em data structures meet criterion higher storage overheads amortized nonoptimal update bounds 
subramanian ramaswamy range tree data structure sided queries uses optimal linear disk space nearly optimal query amortized update bounds 
get static data structure general sided range searching query bound applying ltering technique chazelle outer level structure log way dimensional search tree sided query reduced sided queries stabbing query log list traversals 
disk space usage log log logb required pointer machine lower bound 
structure modi ed perform updates application weight balanced tree techniques resulting update time amortized nonoptimal consequence sided data structure 
arge apply notions persistence get simple optimal static data structure sided range queries supports queries logb os uses linear disk space 
get fully dynamic data structure sided queries optimal query space bounds optimal update bound logb combining static structure external priority search tree weight balanced trees 
structure generalized technique handle sided queries optimal query bound logb optimal disk space usage log log logb update bound logb log log logb intuition disk space needed ciently answer queries queries bounded aspect ratio ratio longest side length shortest side length query rectangle bounded 
interesting question trees linear space structures sections shown perform provably queries 
external memory algorithms data structures types range searching higher dimensions nonorthogonal queries di erent ltering techniques needed 
far relatively little done 
vitter develop rst theoretically near optimal em data structure static dimensional orthogonal range searching 
create hierarchical partitioning items dominate query point densely contained set blocks 
modi cations author queries done log os optimal space usage log log log disk blocks support range queries dimensions nite ranges 
space bounds optimal sided queries sided queries 
result provides optimal log time query performance ram model linear space answering sided queries improving result 
agarwal give optimal bounds static halfspace range searching dimensions variants higher dimensions 
number os needed build halfspace data structures large order 
structures shed useful light complexity range searching 
open problem design cient construction update algorithms improve constant factors 
types range searching simplex range searching investigated external memory setting 
callahan develop dynamic em data structures online problems nding approximately nearest neighbor maintaining closest pair vertices 
numerous data structures developed range queries related problems spatial data 
refer broad survey 

string processing digital trie structures branching decisions node values particular bits strings ective string processing internal memory 
em applications needed multiway digital structure 
unfortunately strings long space store completely node pointers strings stored node number os node access large 
ferragina grossi develop elegant generalization tree storing strings called string tree simply sb tree 
sb tree di ers conventional tree way way branching node represented 
conventional tree unit sized keys stored internal node guide searching entire node ts blocks 
strings arbitrarily long may space store strings node 
pointers strings stored node access strings search require constant number os node 
ferragina grossi solution represent node sb tree variant trie character data structure lines ajtai 
patricia trie achieves way branching total storage characters 
internal nodes stores index ton character label outgoing edges 
example example right child root index jeffrey scott vitter ab bc ba abac 
patricia trie representation single node branching factor 
strings partitioning pictured leaves actual data structure pointers strings strings stored leaves 
pointers children sb tree node stored leaves 
characters means node left subtrie consists strings fth character character right subtrie consists strings fth character 
preceding characters strings node subtrie identically 
nd branches take search string binary search patricia trie binary branching decision character indexed node 
search string binary search trie traverses far right path patricia trie examining character positions 
unfortunately leaf node eventually reached example leaf far right corresponding general correct branching point certain character la positions string examined search 
key idea situation sequentially compare search string string associated leaf di er index di er 
example search string di ers fourth character character search string lexicographically smaller entire right subtrie root 
ts leaves abac 
searching patricia trie requires load memory plus additional os sequential scan string leaf patricia trie reached 
block search string examined sequential scan read lower levels sb tree os sequential scan charged blocks search string 
resulting query time search sb tree string characters logb optimal 
ferragina grossi apply sb trees string matching pre search substring search 
farach etal 
show sb trees su trees su arrays strings length logm os optimal 
clark munro give alternate approach su trees 
arge consider models problem sorting strings total length external memory 
develop cient sorting algorithms external memory algorithms data structures models making sb tree bu er tree techniques simpli ed version sb tree merging called lazy trie 
ram model problem solved log time 
analogy problem sorting integers natural expect complexity logm time dk 
arge show somewhat sorting short strings strings length complexity depends total number characters long strings complexity depends total number strings 
theorem 
sort strings total length total length short strings number long strings number os log log lower bounds various models strings manipulated 
gaps cases upper lower bounds 

tpie external memory programming environment basic approaches supporting development cient code call array oriented systems vic systems unix le system panda mpi io framework oriented systems tpie 
refer reader background 
section describe tpie transparent parallel programming environment implementation platform experiments section 
tpie comprehensive software package helps programmers develop high level portable cient implementations em algorithms 
tpie takes somewhat non traditional approach batched computation viewing enterprise code reads data operates writes results tpie views computation continuous process program fed streams data outside source leaves trails results 
programmers need worry making explicit calls routines merely specify functional details desired computation tpie automatically sequence data movements keep computation fed tpie written set classes functions 
consists main components block transfer engine memory manager mm access method interface ami 
responsible moving blocks data disk 
responsible scheduling asynchronous read ahead write necessary allow computation overlap 
mm responsible managing main memory coordination ami 
ami provides high level uniform interface application programs 
ami component programmers normally need interact directly 
applications ami portable hardware platforms deal underlying details tpie software distribution available charge world wide web www cs duke edu tpie 
jeffrey scott vitter performed particular machine 
seen previous sections batched problems spatial databases gis scienti computing graphs string processing solved optimally relatively small number basic paradigms scanning multiway distribution merging tpie supports access mechanisms 
tpie supports block oriented operations trees online problems 

empirical comparisons section examine empirical performance algorithms problems arise spatial databases 
tpie system described previous section common implementation platform 
experiments involving paradigms discussed appear 

rectangle intersection spatial join 
rst experiment algorithms implemented tpie problem rectangle intersection typically rst step spatial join computation 
rst method called scalable sweeping spatial join robust new algorithm distribution sweep paradigm section 
methods partition spatial merge paradise new modi cation called uses improved dynamic data structure intervals 
algorithms tested data sets 
timing results data sets figures figures respectively 
rst data set worst case sweep line algorithms large fraction line segments le active intersect current sweep line 
second data set best case sweep line algorithms 
algorithms disadvantage making extra copies 
shows considerable improvement methods 
typical data tiger line road data sets experiments indicate run faster 

batched operations trees 
second experiment methods building trees evaluated terms bulk loading time resulting query performance 
methods tested newly developed bu er tree method labeled bu er naive sequential method construction trees labeled naive best update algorithm hilbert trees labeled hilbert 
experimental data came tiger line road data sets states 
experiment involved building tree road data state possible bu er sizes 
bu er sizes capable storing rectangles respectively 
query performance resulting tree measured posing rectangle intersection queries rectangles taken tiger data 
results depicted show bu er trees relatively small bu ers achieve tremendous speedup construction time worsening query performance compared naive method corresponds bu er size 
experiment single tree built states containing road data objects state 
algorithms remaining objects inserted tree external memory algorithms data structures time seconds number rectangles time seconds number rectangles 
comparison scalable sweeping spatial join original new variant data set consists tall skinny vertically aligned rectangles 
data set consists short wide horizontally aligned rectangles 
running times data set 
running times data set 
jeffrey scott vitter naive bu er size bu er size bu er size ri ct nj ny ri ct nj ny 
costs tree processing units os naive repeated insertion method bu er tree various bu er sizes cost bulk loading tree query cost 
data update update data set method building querying packing ri ct nj ny naive hilbert bu er naive hilbert bu er naive hilbert bu er naive hilbert bu er table 
summary costs number os tree updates queries 
packing refers percentage storage utilization 
external memory algorithms data structures construction time measured 
query performance tested 
results table show bu er tree faster construction time hilbert tree previous best method construction time similar better query performance repeated insertions previous best method query performance 

dynamic memory allocation amount memory allocated program may course execution demands placed system users processes 
em algorithms able adapt dynamically resources available preserve performance 
algorithms previous sections assume xed memory allocation resort virtual memory memory allocation reduced causing severe performance hit 
vitter discuss design analysis em algorithms adapt gracefully changing memory allocations 
model loss generality program allocated memory phases ith phase allocated mi blocks internal memory memory remains allocated completes mi operations point phase begins 
process continues nishes execution 
model reasonable assumption duration memory allocation phase long allow memory phase program 
sorting lower bound approach implies mi log mi nlog say dynamically optimal sorting mi log mi log possible sequences memory allocation 
intuitively dynamically optimal program perform constant number sorts worst case sequence memory allocations 
vitter de ne model generality give dynamically optimal strategies sorting matrix multiplication bu er trees operations 
represents rst theoretical model dynamic allocation em algorithms 
pang zhang larson give memory adaptive merge sort algorithms algorithms handle special cases perform poorly certain patterns memory allocation 

described useful paradigms design implementation cient external memory algorithms data structures 
problem domains considered include sorting permuting fft scienti computing computational geometry graphs databases geographic information systems text string processing 
interesting challenges remain virtually problem domains 
di cult problem prove lower bounds permuting sorting assumption 
promising area design analysis algorithms cient multiple disks 
optimal bounds determined basic graph problems jeffrey scott vitter topological sorting shortest paths breadth rst depth rst search connected components 
intriguing connection problems speedups problems fast cient parallel algorithms 
continuing goal develop optimal em algorithms translate theoretical gains observable improvements practice 
problems solved optimally constant factor constant overhead large algorithm practical simpler approaches needed 
practice algorithms assume static internal memory allocation adapt robust way memory allocation changes 
new architectures networks workstations hierarchical storage devices disk drives processing capabilities interesting challenges opportunities 
example extensions tpie domains applying bu er management techniques srm method section cache friendly distribution sort algorithms 
active intelligent disks disk drives processing capability lter information sent host proposed reduce bottleneck especially large database applications 

author wishes members center geometric computing duke university anonymous referees helpful comments suggestions 
abello buchsbaum westbrook 
functional approach external memory graph algorithms 
proceedings th annual european symposium algorithms volume lecture notes computer science venice italy august 
springer verlag 
acharya saltz 
active disks programming model algorithms evaluation 
acm sigplan notices november 
adler 
new coding techniques improved bandwidth utilization 
th ieee symposium foundations computer science burlington vt october 
agarwal arge vitter 
cient dynamic point location monotone planar subdivisions 
proceedings acm siam symposium discrete algorithms 
agarwal arge erickson vitter 
cient searching linear constraints 
proc 
th acm symposium principles database systems 
agarwal arge murali varadarajan vitter 
cient algorithms contour line extraction planar graph blocking 
proceedings acm siam symposium discrete algorithms 
agarwal erickson 
geometric range searching relatives 
chazelle goodman pollack editors advances discrete computational geometry volume contemporary mathematics 
american mathematical society press providence ri 
aggarwal alpern chandra snir 
model hierarchical memory 
proceedings th acm symposium theory computation 
aggarwal chandra snir 
hierarchical memory block transfer 
proceedings th annual ieee symposium foundations computer science 
aggarwal plaxton 
optimal parallel sorting multi level storage 
proceedings fifth annual acm siam symposium discrete algorithms 
aggarwal vitter 
input output complexity sorting related problems 
communications acm 
external memory algorithms data structures ajtai fredman 
hash functions priority queues 
information control 
alpern carter selker 
uniform memory hierarchy model computation 
algorithmica 
arge 
bu er tree new technique optimal algorithms 
proceedings workshop algorithms data structures volume lecture notes computer science 
springer verlag 
complete version appears brics technical report rs university aarhus 
arge 
complexity ordered binary decision diagram manipulation 
proceedings international symposium algorithms computation volume lecture notes computer science 
springer verlag 
arge 
external memory algorithms applications geographic information systems 
van kreveld nievergelt roos widmayer editors algorithmic foundations gis volume lecture notes computer science 
springer verlag 
arge ferragina grossi vitter 
sorting strings external memory 
proceedings acm symposium theory computation 
arge hinrichs vitter 
cient bulk operations dynamic trees 
proceedings st workshop algorithm engineering experimentation baltimore january 
arge knudsen larsen 
general lower bound complexity comparison algorithms 
proceedings rd workshop algorithms data structures volume lecture notes computer science 
springer verlag 
arge 
showing lower bounds external memory computational geometry problems 
abello vitter editors external memory algorithms visualization 
american mathematical society press providence ri volume 
arge procopiuc ramaswamy suel vitter 
scalable sweeping spatial join 
proceedings th international conference onvery large databases new york august 
arge procopiuc ramaswamy suel vitter :10.1.1.41.7473
theory practice cient algorithms multidimensional batched searching problems 
proceedings acm siam symposium discrete algorithms 
arge vitter 
dimensional optimal range search indexing 
proceedings acm symposium principles database systems philadelphia pa may june 
arge vitter 
external memory algorithms processing line segments geographic information systems 
algorithmica appear 
special issue cartography geographic information systems 
earlier version appeared proceedings third european symposium algorithms volume lecture notes computer science springer verlag september 
arge vitter 
optimal dynamic interval management external memory 
inproceedings ieee symposium foundations computer science burlington vt october 
baeza yates 
expected behaviour trees random insertions 
acta informatica 
grove vitter 
simple randomized mergesort parallel disks 
parallel computing 
shriver gibbons matias vitter 
modeling optimizing throughput multiple disks bus 
joint international conference modeling computer systems atlanta ga may 
vitter 
external memory algorithms dynamically changing memory allocations long version 
technical report cs duke university 
bayer mccreight 
organization large ordered indexes 
acta inform 
becker seeger widmayer 
asymptotically optimal multiversion tree 
vldb journal december 
beckmann 
kriegel schneider seeger 
tree cient robust access method points rectangles 
proceedings sigmod international conference management data 
jeffrey scott vitter bentley 
multidimensional divide conquer 
communications acm 
berchtold bohm 
kriegel 
improving query performance highdimensional index structures bulk load operations 
proceedings international conference extending database technology 

worst case cient external memory priority queues 
proceedings scandinavian workshop algorithms theory volume lecture notes computer science stockholm sweden july 
springer verlag 
callahan goodrich 
topology trees applications 
proceedings workshop algorithms data structures volume lecture notes computer science 
springer verlag 
carter 
optimal bit reversal permutation program 
proceedings ieee symposium foundations comp 
sci palo alto ca november 
chazelle 
filtering search new approach query answering 
siam journal computing 
chazelle 
lower bounds orthogonal range searching reporting case 
journal acm april 
chazelle edelsbrunner 
linear space data structures types range search 
discrete computational geometry 
chen lee gibson katz patterson 
raid highperformance reliable secondary storage 
acm computing surveys june 

chiang 
experiments practical ciency geometric algorithms distribution sweep vs plane sweep 
computational geometry theory applications 

chiang goodrich grove tamassia vitter 
external memory graph algorithms 
proceedings acm siam symposium discrete algorithms january 

chiang silva 
external memory techniques isosurface extraction scienti visualization 
abello vitter editors external memory algorithms visualization providence ri volume 
american mathematical society press 
clark munro 
cient su trees secondary storage 
proceedings acm siam symposium discrete algorithms atlanta ga june 
clarkson shor 
applications random sampling computational geometry ii 
discrete computational geometry 
comer 
ubiquitous tree 
comput 
surveys 
corbett feitelson hsu nitzberg 
snir wong 
overview mpi io parallel interface 
jain browne editors input output parallel distributed computer systems volume kluwer international series engineering computer science chapter 
kluwer academic publishers 
cormen nicol 
performing core ffts parallel disk systems 
parallel computing january 
cormen wisniewski 
asymptotically tight bounds performing permutations parallel disk systems 
siam journal computing 
ferragina mehlhorn meyer ramos 
randomized algorithms geometric problems 
proceedings th acm symposium computational geometry june 
ferragina mehlhorn meyer ramos 
optimal computation segment intersections 
abello vitter editors external memory algorithms visualization 
american mathematical society press providence ri volume 
cypher plaxton 
deterministic sorting nearly logarithmic time hypercube related computers 
journal computer system sciences 
dehne hutchinson maheshwari 
reducing complexity simulating coarse grained parallel algorithms 
proceedings international parallel processing april 
external memory algorithms data structures 
electronic data sorting 
ph stanford university 
shortened version appears ieee transactions computing april special issue sorting lindstrom wong vitter editors 
dewitt naughton schneider 
parallel sorting shared architecture probabilistic splitting 
proceedings international conference parallel distributed information systems december 
driscoll sleator tarjan 
making data structures persistent 
journal computer system sciences 
nasa earth observing system eos web page nasa goddard space flight center gsfc nasa gov 
lomet salzberg 
hb tree multi attribute index supporting concurrency recovery node consolidation 
vldb journal 
farach ferragina muthukrishnan 
overcoming memory bottleneck su tree construction 
proceedings ieee symposium foundations comp 
sci palo alto ca november 
feller 
probability theory applications volume 
john wiley sons new york third edition 
ferragina grossi 
fast string searching secondary storage theoretical developments experimental results 
proceedings acm siam symposium discrete algorithms atlanta june 
ferragina grossi 
string tree new data structure string search external memory applications 
journal acm appear 
earlier version appeared proceedings th annual acm symposium theory computing las vegas nv may 
floyd 
permuting information idealized level storage 
miller thatcher editors complexity computer computations 
plenum 
funkhouser sequin teller 
management large amounts data interactive building walkthroughs 
proceedings acm siggraph symposium interactive graphics boston march 
gaede gunther 
multidimensional access methods 
computing surveys june 
gardner 
magic show chapter 
new york 
gibson vitter wilkes 
report working group storage issues large scale computing 
acm computing surveys december 
goodrich 
vitter 
external memory computational geometry 
foundations computer science palo alto ca november 
greene 
implementation performance analysis spatial data access methods 
proceedings ieee international conference data engineering 
grossi italiano 
cient splitting merging algorithms order decomposable problems 
information computation press 
earlier version appears proceedings th international colloquium automata languages programming volume lecture notes computer science springer verlag 
grossi italiano 
cient cross trees external memory 
abello vitter editors external memory algorithms visualization 
american mathematical society press providence ri volume 
gupta li reif 
generating cient programs level memories tensor products 
proceedings seventh iasted ismm international conference parallel distributed computing systems washington october 
guttman 
trees dynamic index structure spatial searching 
proceedings acm sigmod conference management data 
hellerstein koutsoupias papadimitriou 
analysis indexing schemes 
proceedings th acm symposium principles database systems tucson az may 
hellerstein gibson karp katz patterson 
coding techniques handling failures large disk arrays 
algorithmica 
jeffrey scott vitter hinrichs 
grid le system implementation case studies applications 
phd thesis dept information science eth zurich 
hong kung 
complexity red blue pebble game 
proceedings th annual acm symposium theory computation may 
hutchinson maheshwari 
sack 
early experiences implementing bu er tree 
workshop algorithm engineering 
kamel faloutsos 
packing trees 
proceedings nd international conference information knowledge management 
kamel faloutsos 
hilbert tree improved tree fractals 
proceedings th international conference onvery large databases 
kamel khalil 
bulk insertion dynamic trees 
proceedings th international symposium spatial data handling 

complexity graph algorithms 
proceedings acm siam symposium discrete algorithms baltimore md january 
kanellakis kuper revesz 
constraint query languages 
proceedings th acm conference principles database systems 
kanellakis ramaswamy vitter 
indexing data models constraints classes 
journal computer system science 
singh 
optimal dynamic range searching non replicating index structures 
proceedings th international conference database theory jerusalem january 
kirkpatrick seidel 
ultimate planar convex hull algorithm 
siam journal computing 
knuth 
sorting searching volume art computer programming 
addison wesley reading ma second edition 
koutsoupias taylor 
tight bounds dimensional indexing schemes 
proceedings th acm symposium principles database systems seattle wa june 
krishnamurthy 
wang 
multilevel grid les 
tech 
report ibm watson center yorktown heights ny november 
kumar schwabe 
improved algorithms data structures solving graph problems external memory 
inproceedings th ieee symposium parallel distributed processing october 

storage utilization trees generalized ow technique 
acta informatica 
thompson 
fundamentals spatial information systems 
academic press 
leighton 
tight bounds complexity parallel sorting 
ieee transactions computers april 
special issue sorting lindstrom wong vitter editors 
leiserson rao toledo 
cient core algorithms linear relaxation blocking covers 
proceedings ieee symposium foundations comp 
sci 
li mills reif 
models resource metrics parallel distributed computation 
parallel algorithms applications 
lomet salzberg 
hb tree indexing method guaranteed performance 
acm transactions database systems 
lomet salzberg 
concurrency recovery index trees 
vldb journal 
matias segal vitter 
cient bundle sorting 
manuscript 
morrison 
patricia practical algorithm retrieve information coded alphanumeric 
journal acm 
nievergelt hinterberger sevcik 
grid le adaptable symmetric multi key le structure 
acm trans 
database syst 
nievergelt widmayer 
spatial data structures concepts design choices 
van kreveld nievergelt roos widmayer editors algorithmic foundations gis volume lecture notes computer science 
springer verlag 
external memory algorithms data structures nodine goodrich vitter 
blocking external graph searching 
algorithmica august 
nodine lopresti vitter 
overhead parallel vlsi architectures lattice computations 
ieee transactions computers july 
nodine vitter 
deterministic distribution sort shared distributed memory multiprocessors 
proceedings th annual acm symposium parallel algorithms architectures germany june july 
nodine vitter 
greed sort optimal sorting algorithm multiple disks 
journal acm july 
pang carey livny 
memory adaptive external sorts 
proceedings th conference onvery large data bases 
patel dewitt 
partition spatial merge join 
proceedings acm sigmod international conference management data june 
ramaswamy subramanian 
path caching technique optimal external searching 
proceedings th acm conference principles database systems 
riedel gibson faloutsos 
active storage large scale data mining multimedia 
proceedings ieee international conference onvery large databases august 
robinson 
tree search structure large multidimensional dynamic indexes 
proc 
acm conference principles database systems 
ruemmler wilkes 
disk drive modeling 
ieee computer march 
samet 
applications spatial data structures computer graphics image processing gis 
addison wesley 
samet 
design analysis spatial data structures 
addison wesley 
miranker bound theorem indexing schemes application multidimensional range queries 
proc 
th acm conf 
princ 
database systems seattle wa june 
savage 
extending hong kung model memory hierarchies 
proceedings st annual international conference computing combinatorics volume lecture notes computer science 
springer verlag august 
savage vitter 
parallelism space time tradeo preparata editor advances computing research volume 
jai press 
seeger 
kriegel 
buddy tree cient robust access method spatial data base systems 
proc 
th vldb conference 
shriver merchant wilkes 
analytic behavior model disk drives readahead caches request reordering 
joint international conference modeling computer systems june 
shriver nodine 
parallel models algorithms 
jain browne editors input output parallel distributed computer systems chapter 
kluwer academic publishers 

parallel external list ranking 
technical report mpi max planck institut september 
kaufmann 
bsp external memory computation 
proceedings rd italian conference complexity 
subramanian ramaswamy 
range tree new data structure range searching secondary memory 
proceedings acm siam symposium discrete algorithms 
tamassia vitter 
optimal cooperative search fractional cascaded data structures 
algorithmica february 
microsoft online database satellite images available world wide web microsoft com 
tiger line tm 
technical documentation 
technical report bureau census 
toledo 
survey core algorithms numerical linear algebra 
abello vitter editors external memory algorithms visualization 
american mathematical society press providence ri volume 
jeffrey scott vitter ullman yannakakis 
input output complexity transitive closure 
annals mathematics arti cial 
van den seeger widmayer 
generic approach bulk loading multidimensional index structures 
proceedings rd vldb conference 
van kreveld nievergelt roos 
eds 
algorithmic foundations gis volume lecture notes computer science 
springer verlag 
verma 
cient multiversion access structure 
ieee transactions knowledge data engineering may june 
tpie user manual 
duke university 
manual software distribution available web www cs duke edu tpie 
vitter 
cient range searching external memory 
inproceedings acm symposium theory computation philadelphia pa may 
vitter 
cient scienti computation tpie 
proceedings fifth nasa goddard conference mass storage systems ii september 
vitter 
cient memory access large scale computation 
proceedings symposium theoretical aspects computer science lecture notes computer science 
springer verlag 
invited 
vitter flajolet 
average case analysis algorithms data structures 
van leeuwen editor handbook theoretical computer science volume algorithms complexity chapter 
north holland 
vitter nodine 
large scale sorting uniform memory hierarchies 
journal parallel distributed computing 
vitter shriver 
algorithms parallel memory level memories 
algorithmica 
vitter shriver 
algorithms parallel memory ii hierarchical multilevel memories 
algorithmica 
vitter wang 
approximate computation multidimensional aggregates sparse data wavelets 
proceedings acm sigmod international conference management data philadelphia pa june 
vitter wang iyer 
data cube approximation histograms wavelets 
proceedings seventh international conference information knowledge management washington november 
wang vitter iyer 
scalable mining classi cation rules relational databases 
proceedings international database engineering application symposium wales july 
willard lueker 
adding range restriction capability dynamic data structures 
journal acm 
greenberg wheat 
core making parallel computer practical 
proceedings dags pc symposium hanover nh june 
dartmouth institute advanced graduate studies 
wu feng 
universality shu exchange network 
ieee transactions computers may 
yao 
random trees 
acta informatica 
zdonik maier editors 
readings object oriented database systems 
morgan kau man 
zhang 
larson 
dynamic memory adjustment external mergesort 
proceedings third international conference onvery large data bases 
zhu 
computational geometry secondary memory 
inproceedings international symposium algorithms computation 
center geometric computing department computer science duke university durham nc usa mail address jsv cs duke edu url www cs duke edu jsv 
