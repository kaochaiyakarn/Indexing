improvement lazy context operational theory call need andrew moran oregon graduate institute david sands chalmers university technology standard implementation technique lazy functional languages call need ensures argument function call evaluated 
signi cant problem call need dicult compiler writers predict ects program transformations 
traditional theories lazy functional languages call name models er help determining transformations optimize program 
operational theory call need improvement ordering programs improved program contexts terminates terminates cheaply 
show improvement relation satis es context lemma supports rich theory subsuming call need lambda calculi ariola ariola 
reduction call need calculi inadequate theory lazy program transformation permit transformations speed programs constant factor claim go various reduction calculi call need providing powerful proof rules recursion including syntactic continuity basis induction style reasoning improvement theorem suitable arguing correctness safety recursion program transformations 
developing theory question remains measure cost 
attempt predict actual running times assign implementation speci constants machine step 
possible doubtful compilers perform myriad optimisations lead ne grained implementation speci theory 
measure cost aim non implementation speci theory 
earlier version moran sands moran sands simplicity chose simply count number machine steps measure :10.1.1.37.144
unrealistic assume machine steps reveal information actual running times working highlevel machine 
cost measure choose bottom line sucient describe complexity computation 
words measure constant factor actual cost 
reasonable question step machine considered implementable constant time defer discussion point appendix move notion cost machine steps 
