survey frequent pattern mining bart hiit basic research unit department computer science university helsinki box fin helsinki finland frequent itemsets play essential role data mining tasks try find interesting patterns databases association rules correlations sequences episodes classifiers clusters mining association rules popular problems 
original motivation searching association rules came need analyze called supermarket transaction data examine customer behavior terms purchased products 
association rules describe items purchased 
example association rule beer chips states customers bought beer bought chips 
rules useful decisions concerning product pricing promotions store layout 
frequent itemset association rule mining problems received great deal attention 
past decade hundreds research papers published presenting new algorithms improvements existing algorithms solve mining problems efficiently 
chapter explain basic frequent itemset association rule mining problems 
describe main techniques solve problems give comprehensive survey influential algorithms proposed decade 
problem description set items 
set 
ik called itemset itemset contains items 
transaction couple tid tid transaction identifier itemset 
transaction tid said support itemset transaction database set transactions omit clear context 
cover itemset consists set transaction identifiers transactions support cover tid tid 
support itemset number transactions cover support cover 
frequency itemset probability occurring transaction frequency support note support 
omit clear context 
itemset called frequent support absolute minimal support threshold abs abs 
working frequencies itemsets supports relative minimal frequency threshold rel rel 
obviously abs rel 
thesis absolute minimal support threshold itemsets omit subscript abs explicitly stated 
definition 
transaction database set items minimal support threshold 
collection frequent itemsets respect denoted support simply clear context 
problem 
itemset mining set items transaction database minimal support threshold find 
practice interested set itemsets actual supports itemsets 
association rule expression form itemsets 
rule expresses association transaction contains items transaction contains items called body antecedent called head consequent rule 
support association rule support similarly frequency rule frequency association rule called frequent support frequency exceeds minimal support frequency threshold abs rel 
absolute minimal support threshold association rules omit subscript abs explicitly stated 
confidence accuracy association rule conditional probability having contained transaction contained transaction confidence support support rule called confident exceeds minimal confidence threshold 
definition 
transaction database set items minimal support threshold minimal confidence threshold 
collection frequent confident association rules respect denoted confidence simply clear context 
problem 
association rule mining set items transaction database minimal support confidence thresholds find 
set association rules interested support confidence rules 
note itemset mining problem special case association rule mining problem 
support confidence thresholds frequent itemset represents trivial rule holds confidence 
obviously support rule equals support note frequent itemset rules hold rel confidence 
minimal confidence threshold higher minimal frequency threshold effect 
example 
consider database shown table set items beer chips pizza wine 
tid beer chips wine beer chips pizza wine chips pizza table example transaction database table shows frequent itemsets respect minimal support threshold 
table shows frequent confident association rules support threshold confidence threshold 
algorithm proposed solve association rule mining problem divided phases 
phase frequent itemsets generated frequent rules form 
second phase consists generation frequent confident association rules 
association rule mining algorithms comply phased strategy 
sections discuss phases detail 
exist successful algorithm called uses strategy immediately generate large subset association rules 
discuss algorithm main focus survey frequent itemset mining association rules natural extension 
support confidence measures lot interestingness measures proposed order get better interesting association rules 
tan overview various measures proposed statistics machine learning data mining literature 
survey consider algorithms support confidence framework 
itemset cover support frequency beer chips pizza wine beer chips beer wine chips pizza chips wine pizza wine beer chips wine table itemsets support rule support frequency confidence beer chips beer wine chips beer pizza chips pizza wine wine beer wine chips wine pizza beer chips wine beer wine chips chips wine beer beer chips wine wine beer chips table association rules support confidence itemset mining task discovering frequent itemsets quite challenging 
search space exponential number items occurring database 
support threshold limits output hopefully reasonable subspace 
databases massive containing millions transactions making support counting tough problem 
section analyze aspects detail 
search space search space itemsets contains exactly different itemsets 
large naive approach generate count supports itemsets database achieved reasonable period time 
example applications contains thousands items number itemsets number atoms universe 
generate itemsets occur transaction database 
specifically generate subsets transactions database 
course large transactions number large 
optimization generate subsets maximum size 
technique studied amir proven pay sparse transaction databases 
large dense databases algorithm suffers massive memory requirements 
solutions proposed perform directed search search space 
search collections candidate itemsets generated supports computed frequent itemsets generated 
formally definition 
candidate itemset transaction database minimal support threshold algorithm computes itemset called candidate algorithm evaluates frequent 
obviously size collection candidate itemsets may exceed size available main memory 
important generate candidate itemsets possible computing supports collection itemsets time consuming procedure 
best case frequent itemsets generated counted 
unfortunately ideal impossible general shown section 
main underlying property exploited algorithms support monotone decreasing respect extension itemset 
proposition 
support monotonicity transaction database itemsets 
proof 
follows immediately support support 
cover cover 
itemset infrequent supersets infrequent 
literature monotonicity property called downward closure property set frequent itemsets closed respect set inclusion 
search space itemsets represented subset lattice empty itemset top set containing items bottom 
collection frequent itemsets represented collection maximal frequent itemsets collection minimal infrequent itemsets respect set inclusion 
purpose mannila toivonen introduced notion border downward closed collection itemsets 
definition 
border downward closed collection subsets border bd consists itemsets subsets superset bd 
itemsets bd called positive border bd bd itemsets bd called negative border bd bd 
lattice frequent itemsets example borders shown 
efficient algorithms proposed find positive border frequent itemsets want know supports beer chips pizza wine beer chips beer pizza beer wine chips pizza chips wine pizza wine beer chips pizza beer chips wine beer pizza wine chips pizza wine positive border beer chips pizza wine negative border lattice itemsets example border 
itemsets collection need count 
algorithms discussed survey 
theoretical point view border gives interesting insights frequent itemset mining problem poses interesting open problems 
theorem 
transaction database minimal support threshold 
finding collection requires itemsets negative border bd evaluated 
note number itemsets positive negative border downward closed collection itemsets large bounded combinatorics upper bound known theorem 
number frequent itemsets database large infeasible generate 
transaction database dense minimal support threshold set low exist lot large frequent itemsets sending output infeasible 
frequent itemset size includes existence frequent itemsets subsets 
overcome problem proposals generate concise representation frequent itemsets transaction database necessary support frequent itemset representation efficiently computed estimated accessing database 
techniques observation support frequent itemsets deduced supports itemsets 
discuss algorithms survey frequent itemsets need considered generate association rules anyway 
techniques improve performance algorithms generate frequent itemsets explained chapter 
database compute supports collection itemsets need access database 
databases tend large possible store main memory 
important consideration algorithms representation transaction database 
conceptually database represented binary dimensional matrix row represents individual transaction columns represent items matrix implemented ways 
commonly layout horizontal data layout 
transaction transaction identifier list items occurring transaction 
commonly layout vertical data layout database consists set items followed cover 
table shows layouts database example 
note layouts possible exact bit strings binary matrix 
combination layouts explained chapter 
beer wine chips pizza beer wine chips pizza table horizontal vertical database layout count support itemset horizontal database layout need scan database completely test transaction course done large collection itemsets 
important misconception frequent pattern mining scanning database intensive operation 
cases major cost counting steps 
updating supports candidate itemsets contained transaction consumes considerably time reading transaction file database cursor 
transaction need check candidate itemset included transaction similarly need check subset transaction set candidate itemsets 
hand number transactions database correlated maximal size transaction database 
number transactions influence time needed support counting means dictating factor 
vertical database layout major advantage support itemset easily computed simply intersecting covers subsets set candidate itemsets technique requires covers lot sets available main memory course possible 
covers singleton itemsets represent complete database 
association rule mining search space association rules contains exactly different rules 
frequent itemsets search space immediately shrinks tremendously 
frequent itemset exists rules form order efficiently traverse search space sets candidate association rules iteratively generated evaluated frequent confident association rules 
underlying technique similar monotonicity property mining frequent itemsets 
proposition 
confidence monotonicity itemsets 
confidence confidence 
proof 
support support support support words confidence monotone decreasing respect extension head rule 
item extension included body beer chips wine chips wine beer beer wine chips beer chips wine wine beer chips chips beer wine beer chips wine beer chips wine example lattice representing collection association rules beer chips wine 
removed body rule 
certain head association rule itemset causes rule head supersets result rules 
mentioned problem description association rule mining problem general frequent itemset mining problem sense itemset represented rule holds confidence support zero 
hand itemset frequency rule equals confidence 
frequency minimal confidence threshold association rules constructed frequent itemset search space possible association rules represented subset lattice respect head rule rule empty head top rule items head bottom 
shows lattice itemset beer chips wine frequent artificial data set example 
frequent itemsets supports computation frequent confident association rules relatively straightforward 
compute confidence association rule need find supports easily retrieved collection frequent itemsets 
data set items transactions min max avg mushroom bms webview basket example data sets table data set characteristics 
experiments performed thesis data sets different characteristics 
experimented real data sets publicly available synthetic data set generated program provided quest research group ibm almaden 
mushroom data set contains characteristics various species mushrooms originally obtained uci repository machine learning databases 
bms webview data set contains months worth clickstream data commerce web site publicly available blue martini software 
basket data set contains transactions belgian retail store unfortunately publicly available 
table shows number items number transactions data set minimum maximum average length transactions 
additionally table shows data set lowest minimal support threshold experiments number frequent items itemsets size longest frequent itemset 
data set max fk mushroom bms webview basket table data set characteristics 
apriori algorithm algorithm generate frequent itemsets confident association rules ais algorithm agrawal mining problem 
shortly algorithm improved renamed apriori agrawal exploiting monotonicity property support itemsets confidence association rules :10.1.1.40.6757
technique independently proposed mannila 
works cumulated 
itemset mining remainder thesis assume simplicity items transactions itemsets kept sorted lexicographic order stated 
itemset mining phase apriori algorithm algorithm 
notation represent ith item prefix itemset itemset 

algorithm apriori itemset mining input output ck compute supports candidate itemsets transactions tid candidate itemsets ck support extract frequent itemsets fk support generate new candidate itemsets fk fk ck ck algorithm performs breadth search search space itemsets iteratively generating candidate itemsets ck size starting line 
itemset candidate subsets known frequent 
specifically consists items certain level itemsets size bd fk generated 
done steps 
join step fk joined 
union itemsets fk generated prefix lines 
prune step inserted ck subsets occur fk lines 
count supports candidate itemsets database retains secondary storage horizontal database layout scanned transaction time supports candidate itemsets included transaction incremented lines 
itemsets turn frequent inserted fk lines 
note algorithm set itemsets generated candidate itemsets turned infrequent exactly bd 
number candidate itemsets large retain main memory candidate generation procedure stops supports generated candidates computed happened 
iteration generating candidate itemsets size remainder candidate itemsets generated counted repeatedly frequent itemsets size generated 
association rule mining frequent itemsets generate frequent confident association rules 
algorithm similar frequent itemset mining algorithm algorithm 
frequent itemsets generated algorithm 
frequent itemset divided candidate head body process starts resulting rule holds confidence line 
algorithm iteratively generates candidate heads ck size starting line 
head candidate subsets known represent confident rules 
candidate head generation process exactly candidate itemset generation algorithm lines 
compute confidence candidate head support retrieved heads result confident rules inserted hk line 
confident rules inserted line 
seen algorithm fully exploit monotonicity confidence 
itemset candidate head representing rule algorithm checks rule confident rule algorithm apriori association rule mining input output compute ck extract heads confident association rules hk ck confidence generate new candidate heads hk hk ck ck cumulate association rules hk dent 
perfectly possible rules generated itemset rules generated itemsets exploiting monotonicity possible best solution 
computing confidence rule requires lookup support itemsets better exploit confidence monotonicity simply remove prune step candidate generation process remove lines 
course depends efficiency finding support itemset head data structures 
luckily number frequent confident association rules large time needed find rules consists mainly time needed find frequent sets 
proposal algorithm association rule generation phase significant optimizations proposed anymore research focused frequent itemset generation phase 
data structures candidate generation support counting processes require efficient data structure candidate itemsets stored important efficiently find itemsets contained transaction itemset 
hash tree order efficiently find subsets potential candidate itemset frequent itemsets fk stored hash table 
candidate itemsets stored hash tree 
node hash tree contains list itemsets leaf node hash table interior node 
interior node bucket hash table points node 
root hash tree defined depth 
interior node depth points nodes depth 
itemsets stored leaves 
add itemset candidate generation process start root go tree reach leaf 
interior node depth decide branch follow applying hash function item itemset pointer corresponding bucket 
nodes initially created leaf nodes 
number itemsets leaf node depth exceeds specified threshold leaf node converted interior node order find candidate itemsets contained transaction start root node 
leaf find itemsets leaf contained increment support 
interior node reached hashing item hash item comes recursively apply procedure node corresponding bucket 
root node hash item trie data structure commonly trie prefix tree :10.1.1.25.3707
trie itemset node associated prefix 
empty itemset root node 
itemsets attached root node branches labelled item represent 
itemset attached prefix 
node stores item itemset represents support branches 
branches node implemented data structures hash table binary search tree vector 
certain iteration candidate itemsets stored depth trie 
order find candidate itemsets contained transaction start root node 
process transaction node trie follow branch corresponding item transaction process remainder transaction recursively branch discard item transaction process recursively node 
procedure optimized described 
join step candidate generation procedure simple trie itemsets size prefix represented branches node node represents prefix 
generate candidate itemsets prefix simply copy siblings node represents branches node 
try minimize number siblings reordering items database support ascending order :10.1.1.25.3707
heuristic reduce number itemsets generated join step implicitly reduce number times prune step needs performed 
find node representing specific itemset trie perform searches set branches 
obviously performance search improved sets kept small possible 
depth study implementation details trie apriori 
implementations frequent itemsets mining algorithms thesis implemented trie data structure 
optimizations lot algorithms proposed apriori retain general structure adding techniques optimize certain steps algorithm 
performance apriori algorithm completely dictated support counting procedure research focused aspect apriori algorithm 
mentioned performance procedure mainly dependent number candidate itemsets occur transaction 
aprioritid apriorihybrid proposal apriori algorithm agrawal proposed algorithms aprioritid apriorihybrid :10.1.1.40.6757
aprioritid algorithm reduces time needed support counting procedure replacing transaction database set candidate itemsets occur transaction 
done repeatedly iteration adapted transaction database denoted ck 
algorithm algorithm 
implementation details algorithm :10.1.1.40.6757
aprioritid algorithm faster iterations performs slower apriori early iterations 
mainly due additional overhead created ck fit main memory written disk 
transaction contain candidate itemsets ck entry transaction 
number entries ck may smaller number transactions database especially iterations algorithm 
additionally iterations entry may smaller corresponding transaction candidates may contained transaction 
early iterations entry may larger corresponding transaction 
algorithm apriorihybrid proposed combines apriori aprioritid algorithms single hybrid :10.1.1.40.6757
hybrid algorithm uses apriori initial iterations switches aprioritid expected set ck fits main memory 
size ck proportional number candidate itemsets heuristic estimates size ck current iteration 
size small fewer candidate patterns current iteration previous iteration algorithm decides switch aprioritid 
unfortunately heuristic shown chapter 
apriorihybrid performs better apriori 
algorithm aprioritid input output compute frequent items items removed fk compute ck candidate itemsets ck compute supports candidate itemsets transactions tid ck ct ck 

ct ct support ct ck ck tid ct extract fk frequent itemsets counting candidate itemsets shortly proposal apriori algorithms described park proposed optimization called dhp direct hashing pruning reduce number candidate itemsets 
kth iteration supports candidate itemsets counted scanning database dhp gathers information candidate itemsets size way subsets transaction pruning hashed hash table 
bucket hash table consists counter represent itemsets hashed bucket far 
candidate itemset size generated hash function applied itemset 
counter corresponding bucket hash table minimal support threshold generated itemset added set candidate itemsets 
support counting phase iteration transaction trimmed way 
transaction contains frequent itemset size item contained itemset appear candidate itemsets ck 
result item transaction trimmed appear candidate itemsets ck 
techniques result significant decrease number candidate itemsets need counted especially second iteration 
creating hash tables writing adapted database disk iteration causes significant overhead 
dhp reported better performance apriori apriorihybrid claim countered ramakrishnan optimization added apriori 
hash tree store count candidate itemsets triangular array created support counter candidate itemset stored location 
array support counting procedure reduces simple twolevel loop transaction 
similar technique orlando dcp dci algorithms 
number candidate itemsets exactly possi ble number large part structure generated multiple scans database need performed 
experience discovered lot candidate itemsets occur database support remains 
propose optimization 
single items counted resulting set frequent items generate candidate itemset 
start scanning database remove transaction items frequent fly 
trimmed transaction increase support candidate itemsets contained transaction 
candidate itemset exists generate candidate itemset initialize support 
way candidate itemsets occur database generated 
example technique especially useful basket data set experiments data set exist frequent items apriori generate candidate itemsets 
technique number drastically reduced 
support lower bounding mentioned earlier chapter apart monotonicity property possible derive information support itemset support subsets 
algorithm uses technique proposed bayardo apriori lb algorithms 
technique property gives lower bound support itemset 
proposition 
itemsets 
support support support support proof 
support cover cover cover cover cover cover cover cover cover cover cover cover cover cover support support support practice lower bound way 
time candidate itemset generated joining subsets size easily compute lower bound candidate 
suppose candidate itemset generated joining simply add supports itemsets subtract support lower bound higher minimal support threshold know frequent generate candidate itemsets larger sizes lower bound computed 
need count exact supports itemsets done support counting procedure 
efficient support counting mechanism described optimization result significant performance improvements 
additionally exploit special case proposition 
corollary 
itemsets 
support support support support specific property exploited pasquier order find concise representation frequent itemsets 
improve apriori algorithm 
suppose generated counted support frequent itemset support equal support know supports superset equal support generate supersets anymore keep information superset represented superset generalization techniques resulting system deduction rules derive tight bounds support candidate itemsets 
deduction rules allow constructing minimal representation frequent itemsets efficiently generate set frequent itemsets 
unfortunately candidate itemset exponential number rules length itemset need evaluated 
rules section part complete set derivation rules shown result significant performance improvements rules show marginal improvement 
combining passes improvement apriori algorithm part folklore tries combine iterations possible candidate patterns generated 
potential combination technique realized early modalities applied examined 
chapter study problem provide upper bounds number candidate itemsets generated certain iteration apriori algorithm 
dynamic itemset counting dic algorithm proposed brin tries reduce number passes database dividing database intervals specific size 
candidate patterns size generated 
supports candidate sets counted interval database 
supports new candidate pattern size generated subsets known frequent support counted database patterns size 
general interval candidate patterns generated counted 
algorithm stops candidates generated candidates counted complete database 
method drastically reduces number scans database performance heavily dependent distribution data 
authors claim performance improvement reordering items support ascending order negligible true apriori general 
reordering dic supports itemsets computed interval 
obviously success heuristic highly dependent distribution data 
algorithm continuous association rule mining algorithm proposed uses similar technique reducing interval size 
specifically candidate itemsets generated fly transaction 
reading transaction increments supports candidate itemsets contained transaction generates new candidate itemset contained transaction subsets suspected relatively frequent respect number transactions processed 
consequence generates lot candidate itemsets dic apriori 
note number candidate itemsets generated dic exactly apriori 
additionally allows user change minimal support threshold execution algorithm 
database processed guaranteed generated superset frequent itemsets relative threshold depends user changed minimal support threshold execution 
minimal support threshold kept fixed complete execution algorithm frequent itemsets generated 
determine exact supports generated itemsets second scan database required 
sampling sampling algorithm proposed toivonen performs scans database picking random sample database finding relatively frequent patterns sample verifying results rest database 
cases sampling method produce frequent patterns missing patterns generating remaining potentially frequent patterns verifying supports second pass database 
probability failure kept small decreasing minimal support threshold 
reasonably small probability failure threshold drastically decreased cause combinatorial explosion number candidate patterns 
partitioning partition algorithm proposed savasere uses approach completely different previous approaches 
database stored main memory vertical database layout support itemset computed intersecting covers subsets 
specifically frequent item algorithm stores cover 
compute support candidate itemset generated joining subsets apriori algorithm intersects covers resulting cover course storing covers items means complete database read main memory 
large databases impossible 
partition algorithm uses trick 
database partitioned disjoint parts algorithm generates part itemsets relatively frequent part algorithm described previous paragraph shown algorithm 
parts database chosen way part fits main memory 
algorithm merges relatively frequent itemsets part 
results superset frequent itemsets de complete database itemset frequent complete database relatively frequent parts 
actual supports itemsets computed second scan database 
part read main memory vertical database layout support itemset computed intersecting covers items occurring itemset 
exact partition algorithm algorithm 
algorithm partition local itemset mining input output compute store frequent item cover fk fk fk 
fk cover cover cover cover fk fk algorithm partition input output partition 
dn find local frequent itemsets compute dp rel dp merge local frequent itemsets cp compute actual support itemsets generate cover item dp support support cover cover extract global frequent itemsets support exact computation supports itemsets optimized refer original article implementation details 
covers items stored main memory generation local frequent itemsets part possible covers local candidate itemsets stored main memory 
algorithm highly dependent heterogeneity database generate local frequent itemsets resulting significant decrease performance 
complete database fits main memory total covers iteration exceed main memory limits database partitioned outperforms apriori orders magnitude 
course mainly due fast intersection counting mechanism 
depth algorithms explained previous section intersection counting mechanism possible vertical database layout shows significant performance improvements 
possible total size covers certain iteration local itemset generation procedure exceed main memory limits 
possible significantly reduce total size generating collections candidate itemsets depth strategy 
algorithm proposed generate frequent itemsets depth manner eclat algorithm zaki 
depth algorithms proposed fp growth algorithm han known :10.1.1.3.2424:10.1.1.3.2424
section explain eclat fp growth algorithms 
transaction database minimal support threshold denote set frequent itemsets prefix 
note 
eclat fp growth recursively generate item set 
sake simplicity presentation assume items occur transaction database frequent 
practice frequent items computed initial scan database infrequent items ignored 
eclat eclat uses vertical database layout uses intersection approach compute support itemset 
eclat algorithm algorithm 
algorithm eclat input output occurring create di di occurring cover cover di di depth recursion compute di note candidate itemset represented set support computed line algorithm 
algorithm doesn fully exploit monotonicity property generates candidate itemset subsets number candidate itemsets generated larger compared breadth approaches previous section 
comparison eclat essentially generates candidate itemsets join step apriori itemsets necessary prune step available 
reorder items database support ascending order reduce number candidate itemsets generated reduce number intersections need computed total size covers generated itemsets 
fact reordering performed recursion step algorithm line line algorithm 
comparison apriori counting supports itemsets performed efficiently 
comparison partition total size covers kept main memory average 
breadth approach certain iteration frequent itemsets stored main memory covers 
hand depth approach certain depth covers itemsets prefix stored main memory item reordering number kept small 
zaki gouda proposed new approach efficiently compute support itemset vertical database layout 
storing cover itemset difference cover cover prefix stored denoted compute support simply need subtract size support prefix 
note support need stored itemset maintained parameter recursive function calls algorithm 
itemset diffsets subsets computed follows 
technique experimentally shown result significant performance improvements algorithm designated 
original database stored original vertical database layout 
observe arbitrary recursion path algorithm starting itemset itemset 
ik 
itemset stored cover recursion step generates subset compute 
obviously total size diffsets generated recursion path cover 
hand generate cover generated itemset total size generated covers path cover 
course generated diffsets covers stored recursions 
observation indicates total size diffsets stored main memory certain point algorithm total size covers 
predictions supported experiments 
depth approach remains possible exploit technique optimization apriori algorithm previous section 
specifically suppose generated counted support frequent itemset support equal support empty 
know support superset equal support generate supersets anymore retain information superset represented superset database fit main memory partition algorithm local frequent itemsets eclat 
optimization proposed hipp combines apriori eclat single hybrid 
specifically algorithm starts generating frequent itemsets breadth manner apriori switches certain iteration depth strategy eclat 
exact switching point user 
main performance improvement strategy occurs generation candidate itemsets generated online described section 
lot items database frequent eclat generates possible itemset occurs database 
hand transaction database contains lot large transactions frequent items apriori needs generate subsets size eclat outperforms apriori 
course long number transactions contain candidate itemsets high store main memory switching eclat impossible apriori nicely 
fp growth order count supports generated itemsets fp growth uses combination vertical horizontal database layout store database main memory 
storing cover item database stores actual transactions database trie structure item linked list going transactions contain item 
new data structure denoted fp tree frequent pattern tree created follows :10.1.1.3.2424
order items database support ascending order reasons 
create root node tree labelled null 
transaction database items processed reverse order support descending branch created transaction 
node fp tree additionally stores counter keeps track number transactions share node 
specifically considering branch added transaction count node common prefix incremented nodes items transaction prefix created linked accordingly 
additionally item header table built item points occurrences tree chain node links 
item header table stores support 
reason store transactions fp tree support descending order way hoped fp tree representation database kept small possible frequently occurring items arranged closer root fp tree shared 
example 
assume transaction database minimal support threshold 
supports items computed infrequent items removed database transactions tid table example preprocessed transaction database 
reordered support descending order resulting example transaction database table 
fp tree database shown 
fp tree supports frequent items header table 
obviously fp tree just vertical horizontal database layouts lossless representation complete transaction database generation frequent itemsets 
linked list starting item header table represents compressed form cover item 
hand branch starting root node represents compressed form set transactions 
apart fp tree fp growth algorithm similar eclat uses additional steps maintain fp tree structure recursion steps eclat needs maintain covers generated itemsets 
specifically order generate frequent itemsets fp growth creates called projected database essentially eclat vertical database layout projected database considered 
fp growth algorithm algorithm 
difference eclat fp growth way count supports candidate itemset represent maintain projected database 
lines eclat algorithm renewed 
fp growth computes frequent items lines course different recursion step 
efficiently done simply linked list starting entry header table 
node fp tree follows path root node increments support item passes count 
lines fp tree projected database built transactions occurs intersected set frequent items greater transactions efficiently starting entry item header table path node root fp tree ignoring algorithm fp growth input output occurring create di di occurring support tid di di tid depth recursion compute di null header table item support node link example fp tree 
items node count transaction added times 
course implemented simply incrementing counters path transaction new projected fp tree technique require node fp tree stores link parent 
additionally technique generates candidate itemsets occur database 
dynamically add counter initialized item occurs path fp tree traversed 
steps optimized follows 
suppose consists single path 
recursion simply enumerate combination items occurring path support set minimum supports items combination 
essentially technique similar technique algorithms support itemset equal support subsets 
fp growth able detect recursion step ahead eclat 
seen recursion step item occurring represents itemset 
words frequent item occurring algorithm recursively finds frequent itemsets cover fp tree data set fp tree mushroom bms webview basket table memory usage eclat versus fp growth 
projected database di authors fp growth algorithm claim algorithm generate candidate itemsets shown algorithm generates lot candidate itemsets essentially uses candidate generation technique apriori prune step :10.1.1.3.2424
main advantage fp growth eclat linked list starting item header table representing cover item stored compressed form 
unfortunately accomplish gain needs maintain complex data structure perform lot dereferencing eclat perform simple fast intersections 
intended gain compression hoped 
eclat cover item implemented array transaction identifiers 
hand fp growth cover item compressed linked list starting node link header table node linked list needs store label counter pointer node pointer branches pointer parent 
size fp tree size covers eclat order profit compression 
table shows data sets size total length arrays eclat total number nodes fp growth fp tree corresponding compression rate fp tree 
additionally entry show size data structures bytes corresponding compression fp tree 
seen data set fp growth actual compression database mushroom data set 
data sets compression contrary fp tree representation larger plain array representation 
experimental evaluation implemented apriori implementation online candidate itemset generation optimization 
additionally implemented eclat hybrid fp growth algorithms previous section 
algorithms implemented data structures provided standard template library 
experiments reported thesis performed mhz sun ultra sparc mb main memory running sun solaris 
shows performance algorithms data sets described section varying minimal support thresholds 
interesting behavior observed experiments basket data 
eclat performs worse algorithms 
behavior predicted number frequent items basket data set large huge amount candidate itemsets generated 
algorithms dynamic candidate generation itemsets resulting better performance results 
hybrid algorithm performed best apriori switched eclat second iteration frequent itemsets generated 
remarkable result apriori performs better fp growth basket data set 
result due overhead created maintenance fp tree structure updating supports candidate itemsets contained transaction performed fast due sparseness data set 
bms webview data set hybrid algorithm performed best switched second iteration 
minimal support thresholds higher differences performance negligible mainly due initialization destruction routines data structures 
low support thresholds eclat clearly outperforms algorithms 
reason performance apriori large transactions subset generation procedure counting supports candidate itemsets consumes time 
support claim additional experiments showed transactions containing frequent items consumed time support counting candidate itemsets sized 
example counting supports itemsets takes seconds seconds transactions 
synthetic data set experiments showed normal behavior predicted analysis survey 
time switching point hybrid algorithm performed best time seconds apriori eclat hybrid support basket apriori eclat hybrid time seconds support bms webview frequent itemset mining performance 
apriori eclat hybrid time seconds support time seconds apriori eclat hybrid support mushroom frequent itemset mining performance 
third iteration 
mushroom data set shows interesting results 
performance differences eclat fp growth negligible mainly due differences initialization destruction 
obviously small size database run extremely fast 
apriori hand runs extremely slow transaction contains exactly items high supports 
hybrid algorithm doesn perform performed apriori 
show time hybrid switch performed second iteration 
decade lot people implemented compared algorithms try solve frequent itemset mining problem efficiently possible 
unfortunately small selection researchers put source codes algorithms publicly available fair empirical evaluations comparisons algorithms difficult 
experienced different implementations algorithms result significantly different performance results 
consequence claims articles contradicted articles 
example implementation apriori algorithm christian borgelt 
compared implementation performance algorithms showed immense differences 
borgelt implementation performed better high support thresholds performed worse small thresholds 
mainly due differences implementation data structures procedures 
different compilers different machine architectures showed different behavior algorithms 
different kinds data sets algorithms tested showed remarkable differences performance algorithms 
interesting example zheng article real world performance association rule algorithms known association rule mining algorithms compared new real world data sets 
discovered different performance behaviors algorithms previously claimed respective authors 
survey depth analysis lot algorithms significant contribution improve efficiency frequent itemset mining 
shown long database fits main memory hybrid algorithm combination optimized version apriori eclat far efficient algorithm 
dense databases eclat algorithm better 
database fit memory best algorithm depends density database 
sparse databases hybrid algorithm best choice switch apriori eclat soon database fits main memory 
dense databases envisage partition algorithm eclat compute local frequent itemsets performs best 
experiments implement apriori possible optimizations survey 
main cost algorithm dictated large transactions optimizations sufficient 
experiments different data sets confirmed reasoning analysis various algorithms 
agarwal aggarwal prasad 
depth generation long patterns 
ramakrishnan pages 
agarwal aggarwal prasad 
tree projection algorithm generation frequent itemsets 
journal parallel distributed computing march 
agrawal imielinski swami 
mining association rules sets items large databases 
buneman jajodia editors proceedings acm sigmod international conference management data volume sigmod record pages 
acm press 
agrawal mannila srikant toivonen verkamo 
fast discovery association rules 
fayyad piatetsky shapiro smyth uthurusamy editors advances knowledge discovery data mining pages 
mit press 
agrawal srikant 
quest synthetic data generator 
ibm almaden research center san jose california www almaden 
ibm com cs quest html 
agrawal srikant 
fast algorithms mining association rules 
jarke zaniolo editors proceedings th international conference large data bases pages 
morgan kaufmann 
agrawal srikant :10.1.1.40.6757
fast algorithms mining association rules 
ibm research report rj ibm almaden research center san jose california june 
amir feldman 
new versatile method association generation 
information systems 
bayardo jr efficiently mining long patterns databases 
haas editors proceedings acm sig mod international conference management data volume sigmod record pages 
acm press 
blake merz 
uci repository machine learning databases 
university california irvine dept information computer sciences www ics uci edu mlearn mlrepository html 
borgelt kruse 
induction association rules apriori implementation 
nz editors proceedings th conference computational statistics pages fuzzy cs uni magdeburg de borgelt software 
html 
physica verlag 


free sets condensed representation boolean data approximation frequency queries 
data mining knowledge discovery 
appear 
brin motwani ullman tsur 
dynamic itemset counting implication rules market basket data 
proceedings acm sigmod international conference management data volume sigmod record pages 
acm press 

condensed representation find frequent patterns 
proceedings twentieth acm sigact sigmod sigart symposium principles database systems pages 
acm press 

mining non derivable frequent itemsets 
elomaa mannila toivonen editors proceedings th european conference principles data mining knowledge discovery volume lecture notes computer science pages 
springer 
chen naughton bernstein editors 
proceedings acm sigmod international conference management data volume sigmod record 
acm press 
dayal gray nishio editors 
proceedings th international conference large data bases 
morgan kaufmann 
gunopulos khardon mannila toivonen 
data mining hypergraph transversals machine learning 
proceedings sixteenth acm sigact sigmod sigart symposium principles database systems pages 
acm press 
han pei yin 
mining frequent patterns candidate generation 
chen pages 
han pei yin mao :10.1.1.3.2424
mining frequent patterns candidate generation frequent pattern tree approach 
data mining knowledge discovery 
appear 

online association rule mining 
faloutsos ghandeharizadeh editors proceedings acm sig mod international conference management data volume sigmod record pages 
acm press 
hipp 
mining association rules deriving superior algorithm analyzing today approaches 
komorowski zytkow editors proceedings th european conference principles data mining knowledge discovery volume lecture notes computer science pages 
springer 
kohavi brodley mason zheng 
kdd cup organizers report peeling onion 
sigkdd explorations 
www ecn purdue edu kddcup 
mannila 
inductive databases condensed representations data mining 
editor proceedings international symposium logic programming pages 
mit press 
mannila 
global local methods data mining basic techniques open problems 
widmayer ruiz morales hennessy editors proceedings th international colloquium automata languages programming volume lecture notes computer science pages 
springer 
mannila toivonen 
levelwise search borders theories knowledge discovery 
data mining knowledge discovery november 
mannila toivonen verkamo 
efficient algorithms discovering association rules 
fayyad uthurusamy editors proceedings aaai workshop knowledge discovery databases pages 
aaai press 
orlando 
enhancing apriori algorithm frequent set counting 
arikawa editors proceedings third international conference data warehousing knowledge discovery volume lecture notes computer science pages 
springer 
orlando 
adaptive resource aware mining frequent sets 
kumar yu zhong editors proceedings ieee international conference data mining 
ieee computer society 
appear 
park 
chen yu 
effective hash algorithm mining association rules 
proceedings acm sigmod international conference management data volume sig mod record pages 
acm press 
pasquier bastide taouil lakhal 
discovering frequent closed itemsets association rules 
beeri buneman editors proceedings th international conference database theory volume lecture notes computer science pages 
springer 
ramakrishnan stolfo bayardo jr editors 
proceedings sixth acm sigkdd international conference knowledge discovery data mining 
acm press 
savasere omiecinski navathe 
efficient algorithm mining association rules large databases 
dayal pages 
shenoy sudarshan bawa shah 
turbo charging vertical mining large databases 
chen pages 
srikant 
fast algorithms mining association rules sequential patterns 
phd thesis university wisconsin madison 
srikant agrawal 
mining generalized association rules 
dayal pages 
stroustrup 
programming language 
addison wesley third edition 
tan kumar srivastava 
selecting right interestingness measure association patterns 
hand keim ng editors proceedings acm sigkdd international conference knowledge discovery data mining pages 
acm press 
toivonen 
sampling large databases association rules 
buchmann mohan editors proceedings nd international conference large data bases pages 
morgan kaufmann 
webb 
efficient search association rules 
ramakrishnan pages 
zaki 
scalable algorithms association mining 
ieee transactions knowledge data engineering may june 
zaki 
fast vertical mining diffsets 
technical report rensselaer polytechnic institute troy new york 
zaki 
hsiao 
charm efficient algorithm closed itemset mining 
grossman han kumar mannila motwani editors proceedings second siam international conference data mining 
zaki parthasarathy ogihara li 
new algorithms fast discovery association rules 
heckerman mannila pregibon editors proceedings third international conference knowledge discovery data mining pages 
aaai press 
zheng kohavi mason 
real world performance association rule algorithms 
provost srikant editors proceedings seventh acm sigkdd international conference knowledge discovery data mining pages 
acm press 

