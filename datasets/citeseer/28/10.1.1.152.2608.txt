llvm compilation framework lifelong program analysis transformation chris lattner vikram adve university illinois urbana champaign lattner cs uiuc edu llvm cs uiuc edu describes llvm low level virtual machine compiler framework designed support transparent lifelong program analysis transformation arbitrary programs providing high level information compiler transformations compile time link time run time offline 
llvm defines common low level code representation static single assignment ssa form novel features simple language independent type system exposes primitives commonly implement high level language features instruction typed address arithmetic simple mechanism implement exception handling features high level languages setjmp longjmp uniformly efficiently 
llvm compiler framework code representation provide combination key capabilities important practical lifelong analysis transformation programs 
knowledge existing compilation approach provides capabilities 
describe design llvm representation compiler framework evaluate design ways size effectiveness representation including type information provides compiler performance interprocedural problems illustrative examples benefits llvm provides challenging compiler problems 

modern applications increasing size dynamic change behavior execution components written multiple different languages 
applications small hot spots spread execution time evenly application 
order provide maximum efficiency programs believe program analysis transformation performed lifetime program 
lifelong code optimization techniques encompass interprocedural optimizations performed link time preserve benefits separate compilation machine dependent optimizations install time system dynamic optimization runtime optimization runs idle time profile information collected user 
program optimization lifelong analysis transformation 
emerging applications static analysis fundamentally interprocedural convenient perform link time examples include static debugging static leak detection memory management transformations :10.1.1.19.8733
sophisticated analyses transformations developed enforce program safety done software installation time load time 
allowing lifelong reoptimization program gives architects power evolve processors exposed interfaces flexible ways allowing legacy applications run new systems 
presents llvm low level virtual machine compiler framework aims lifelong program analysis transformation available arbitrary software manner transparent programmers 
llvm achieves parts code representation novel features serves common representation analysis transformation code distribution compiler design exploits representation provide combination capabilities available previous compilation approach know 
llvm code representation describes program risc instruction set key higherlevel information effective analysis including type information explicit control flow graphs explicit dataflow representation infinite typed register set static single assignment form 
novel features llvm code representation low level language independent type system implement data types operations high level languages exposing implementation behavior stages optimization 
instructions performing type conversions low level address arithmetic preserving type information 
low level exception handling instructions implementing language specific exception semantics exposing exceptional control flow compiler explicitly 
simple low level memory model distinguishing heap stack global data code memory regions accessed typed pointers 
llvm representation source language independent reasons 
uses low level instruction set memory model slightly richer standard assembly languages type system prevent representing code little type information 
second impose particular runtime requirements semantics programs 
important note llvm intended universal compiler ir 
particular llvm represent high level languages features directly language dependent transformations capture machine dependent features code sequences back code generators lowered 
differing goals representations llvm complementary high level virtual machines small talk self jvm microsoft cli alternative systems 
differs key ways llvm notion high level constructs classes inheritance exception handling semantics compiling source languages features 
llvm specify runtime system particular object model low level runtime system particular language implemented llvm 
llvm implement high level virtual machines 
llvm guarantee type safety memory safety language interoperability assembly language physical processor 
llvm compilation framework exploits code representation provide combination capabilities believe important order support lifelong analysis transformation arbitrary programs 
general capabilities quite difficult obtain simultaneously llvm design inherently lifelong compilation model compilation model allows sophisticated optimizations performed stages application lifetime including runtime idle time runs preserving llvm code representation 
offline code generation despite previous point possible compile programs efficient native machine code offline aggressive code generation techniques suitable runtime code generation 
crucial performance critical programs important target lifelong optimization 
user profiling optimization llvm framework gathers profiling information run time field representative actual users apply profile guided transformations run time idle time 
transparent runtime model system specify particular object model exception semantics runtime environment allowing language combination languages compiled 
uniform program compilation language independence possible optimize compile code comprising application uniform manner linking including language specific runtime libraries system libraries 
believe previously existing system provides properties 
source level compilers provide attempt provide 
link time interprocedural optimizers common commercial compilers provide additional capability link time 
profile guided optimizers static languages provide benefit cost trans idle time optimizer planned implemented 
crucially provide 
high level virtual machines jvm cli provide provide 
binary runtime optimization systems provide provide partially provide 
explain detail section 
evaluate effectiveness llvm system respect issues size effectiveness representation including ability extract useful type information programs compiler performance performance generated code depends particular code generator optimization sequences examples illustrating key capabilities llvm provides challenging compiler problems 
summarize contributions follows llvm defines rich low level code representation low level operations memory model rich type control flow dataflow information necessary powerful language independent analyses transformations 
achieves goals novel instruction set features described earlier 
llvm compiler framework provides transparent lifelong analysis optimization arbitrary programs 
design provides capabilities believe important effective lifelong code analysis optimization arbitrary programs listed 
knowledge unique respect 
experimental results show llvm compiler prove average memory accesses type safe range specint benchmarks 
discuss experience type information captured llvm safely perform number aggressive transformations traditionally attempted type safe languages source level compilers 
show llvm representation comparable size sparc machine code risc architecture roughly larger code average despite capturing richer type information infinite register set ssa form 
example timings showing llvm representation amenable extremely efficient interprocedural optimizations 
implementation llvm date supports traditionally compiled entirely statically 
currently exploring llvm beneficial implementing dynamic runtimes jvm cli 
llvm freely available non restrictive license 
rest organized follows 
section begins describing llvm code representation 
section describes design llvm compiler framework 
section discusses evaluation llvm system described 
section compares llvm related previous systems 
section concludes summary 
see llvm home page llvm cs uiuc edu 

program representation llvm representation key factors differentiates llvm systems 
specific design features llvm believe novel llvm type system getelementptr instruction implements type safe pointer arithmetic 
llvm memory model invoke unwind instructions implement source language exception handling features 
section gives overview llvm instruction set describes features briefly describes offline memory representations 
detailed syntax semantics representation defined llvm manual 
overview llvm instruction set llvm instruction set captures key operations ordinary processors avoids machine specific constraints physical registers pipelines low level calling conventions 
llvm provides infinite set typed virtual registers hold values primitive types boolean integral floating point pointers 
virtual registers static single assignment ssa form 
llvm load store architecture programs transfer values registers memory solely load store operations typed pointers 
llvm memory model described section 
entire llvm instruction set consists opcodes 
possible avoid multiple opcodes operations second opcodes llvm overloaded example add instruction operate integer floating point operand type 
instructions including arithmetic logical operations address form take operands produce single result 
llvm uses ssa form primary code representation ssa register defined exactly register dominated definition 
llvm instruction set includes explicit phi instruction corresponds directly standard non gated function ssa form 
ssa form simplifies dataflow optimizations enables fast flow insensitive algorithms achieve benefits flow sensitive algorithms expensive dataflow analysis 
dramatically simplifies transformations registers aliases 
llvm control flow graph cfg function explicit representation 
function set basic blocks basic block sequence llvm instructions exactly terminator instruction branches return unwind invoke explained 
terminator explicitly specifies successor basic blocks 
language independent type information cast getelementptr fundamental design feature llvm inclusion language independent type system 
ssa register explicit memory object associated type operations obey strict type rules 
type information conjunction instruction opcode determine exact semantics instruction example unary operators neg implemented terms xor sub respectively 
floating point vs integer add 
type information enables broad class high level transformations low level code example see section 
addition type mismatches detect optimization bugs 
llvm type system includes source language independent primitive types predefined sizes void bool signed unsigned integers bits single double precision floating point types 
possible required write portable code types 
llvm includes derived types pointers arrays structures functions 
believe high level language data types eventually represented combination types terms operational behavior classes inheritance described section 
llvm cast instruction convert value type arbitrary type needed supporting non type safe languages 
cast instruction way convert values program casts necessarily type safe absence memory access errors array overflow 
llvm types aggressive interprocedural optimizations check correctness wide variety transformations 
section shows despite allowing values arbitrarily cast types reliable type information available memory accesses programs compiled llvm 
critical difficulty preserving type information low level code implementing address arithmetic 
getelementptr instruction llvm system perform type safe pointer arithmetic 
typed pointer object aggregate type instruction calculates address sub element object manner effectively combined operator llvm 
example pointer structure field number getelementptr instruction returns pointer field 
pointer array integer index returns pointer specified element 
load store instructions take single pointer perform indexing 
design processing memory accesses simple uniform 
explicit memory allocation unified memory model llvm provides instructions typed memory allocation 
malloc instruction allocates elements specific type heap returning typed pointer new memory 
free instruction releases memory allocated malloc alloca instruction similar allocates memory stack frame current function heap memory automatically deallocated return function 
stack resident data including automatic variables allocated explicitly alloca 
llvm addressable objects lvalues explicitly allocated 
global variable function definitions define symbol provides address object object 
gives unified memory model memory operations including call instructions occur typed pointers 
implicit accesses native code generated program malloc free instructions converted appropriate native function calls allowing custom memory allocators 
memory simplifying memory access analysis representation needs address operator 
function calls exception handling ordinary function calls llvm provides call instruction takes typed function pointer may function name actual pointer value typed actual arguments 
abstracts away calling conventions underlying machine simplifies program analysis 
unusual features llvm provides explicit low level machine independent mechanism implement exception handling high level languages 
fact mechanism supports setjmp operations allowing operations analyzed optimized way exception features languages 
common exception mechanism instructions invoke unwind 
invoke unwind instructions support exception handling model logically stack unwinding llvm native code generators may zero cost table driven methods setjmp longjmp implement instructions 
instruction operates just call instruction associates extra basic block call starting block exception handler 
program executes unwind instruction program logically unwinds stack removes activation record created invoke instruction 
transfers control basic block specified invoke 
instructions explicitly expose exceptional control flow llvm cfg critical aspect design 
primitive instructions implement wide variety exception handling mechanisms currently implemented support longjmp calls full support exception model 
unwind instruction implement exception throwing longjmp high level languages 
code executed exception thrown example setjmp catch blocks automatic variable destructors uses invoke instruction unwinding execute desired code continue execution unwinding necessary 
class object destructor func throw 
exception handling example example illustrates case invoke instruction generated front order execute destructors stack allocated object exception thrown result func call 
shows llvm code example 
front java similar code unlock locks acquired synchronized blocks methods exceptions thrown 
catch clause java ocaml languages implemented directly terms exception destination 
exception semantics high level language written runtime libraries called exception blocks 
plain text binary memory representations 
allocate stack space object object alloca class uint construct object call void class class class object call func invoke void func label label execution continues 
unwind occurs continues 
destroy object call void class class class object continue unwinding unwind llvm code example llvm representation class language defines equivalent textual binary memory compiler internal representations 
instruction set designed serve effectively persistent offline code representation compiler internal representation semantic conversions needed able convert llvm code representations information loss debugging transformations simpler allows test cases written easily decreases amount time required understand memory representation 

compiler architecture goal llvm compiler framework enable sophisticated transformations link time run time application installed field operating llvm representation program stages 
practical transparent application developers users efficient real world applications 
section describes system individual components designed achieve goals 
high level design llvm compiler framework shows high level architecture llvm system 
briefly static compiler front ends emit code llvm representation combined llvm linker 
linker performs variety link time optimizations produces highly optimized native code target step may alternatively deferred install time saves llvm code native code 
runtime light weight instrumentation system detect program hot spots perform simple runtime optimizations 
program behavior collected runtime optimizer collected attached program allowing offline optimizer perform aggressive interprocedural optimizations field profile information gathered user developer runs 
strategy provides powerful benefits available traditional model static compilation na contrast typical jvm implementations convert stack bytecode language offline appropriate representation compiler transformations convert ssa form purpose 
compiler fe compiler fe llvm llvm files llvm libraries linker ipo ipa llvm native codegen llvm exe llvm exe llvm exe llvm llvm system architecture diagram offline cpu exe jit profile trace info llvm profile info runtime optimizer tive machine code 
argued capabilities important lifelong analysis transformation named lifelong compilation model offline code generation user profiling optimization transparent runtime model uniform program compilation 
difficult obtain simultaneously reasons 
offline code generation normally allow optimization stages higher level representation native machine code 
second lifelong compilation traditionally associated bytecode languages provide 
fact noted existing compilation approach provides capabilities listed 
reasons follows traditional source level compilers provide attempt 
provide interprocedural optimization require significant changes application makefiles 
commercial compilers provide additional benefit link time exporting intermediate representation object files performing optimizations link time 
system know capable preserving representation runtime offline benefits 
higher level virtual machines jvm cli provide benefit partially provide particular need bytecode verification greatly restricts optimizations may done runtime cli support code multiple languages 
provide runtime optimization generally possible jit code generation 
aim provide provide rich runtime framework languages match runtime object model java 
transparent binary runtime optimization systems dynamo runtime optimizers transmeta processors provide benefits provide benefit limited extent runtime constrained native binary code limiting optimizations perform 
provides provide representation suitable highlevel analysis optimization 
profile guided optimization static languages provide benefit cost transparent require multi phase compilation process 
additionally suffers main problems empirically developers compiling benchmarks 
application tuned behavior training run 
training run representative user usage patterns program may profile information 
profiling information completely static meaning compiler phase behavior program adapt changing usage patterns 
limitations llvm strategy 
language specific optimizations performed front generating llvm code 
llvm designed universal representation source languages 
second open question languages requiring sophisticated runtime systems java benefit directly llvm 
currently exploring potential benefits implementing higher level virtual machines jvm cli top llvm 
subsections describe key components llvm compiler architecture emphasizing design implementation features capabilities practical efficient 
compile time external front static optimizer external static llvm compilers referred front ends translate source language programs llvm virtual instruction set 
static compiler perform key tasks third optional perform language specific optimizations optimizing closures languages higher order functions 
translate source programs llvm code preserving useful type information data values possible 
invoke llvm passes global interprocedural optimizations module level 
llvm optimizations built libraries making easy front ends 
front perform ssa construction 
variables allocated stack ssa form llvm stack promotion pass build ssa form 
note high level optimizations special cases general optimizations may performed llvm level virtual function resolution described section 
case useful extend llvm optimizer investing effort code benefits particular front 
allows optimizations performed lifetime program 
linker interprocedural optimizer link time phase compilation process program available analysis transformation 
link time natural place perform aggressive interprocedural optimizations entire program 
link time optimizations operate llvm directly take advantage semantic information contains 
design compile link time optimizers permit known technique speeding interprocedural analysis compile time interprocedural summaries computed function program attached llvm bytecode 
link time interprocedural optimizer process interprocedural summaries input having compute results scratch 
technique dramatically speed incremental compilation small number translation units modified 
note achieved building program database deferring compilation input source code link time 
offline jit native code generation link time optimization code generator selected translate llvm native code current platform currently support sparc architectures ways 
configuration code generator run offline statically link time generate high performance native code application potentially expensive code generation techniques 
user decides post link runtime offline optimizers copy entire llvm bytecode program included executable addition code generator inserts light weight instrumentation program identify frequently executed loop regions 
alternatively just time execution engine invokes appropriate code generator runtime translating function time execution uses portable llvm interpreter native code generator available 
runtime path profiling reoptimization goals llvm project develop new strategy runtime optimization ordinary applications 
briefly describe strategy summarize key benefits 
program executes frequently executed execution paths identified combination offline online instrumentation 
offline instrumentation inserted just native code generation described identifying frequently executed loop regions code 
online instrumentation library instruments hot loop region identify frequently executed paths region 
hot paths identified duplicate original llvm code trace perform llvm optimizations regenerate native code software trace cache 
native code stitched existing application code subsequent executions 
strategy described powerful combines characteristics native code generation performed ahead time note shared libraries system libraries may available analysis link time may compiled directly native code 
eliminating possibility runtime offline optimizers get wrong bytecode program 
cated algorithms generate high performance code 
native code generator runtime optimizer part llvm framework allowing runtime optimizer exploit support code generator instrumentation simplifying transformations 
runtime optimizer high level information llvm representation perform sophisticated runtime optimizations 
believe characteristics represent optimal design point runtime optimizer allow best choice key aspects high quality initial code generation offline online cooperative support code generator ability perform aggressive optimizations llvm native code input 
offline reoptimization user profile information applications particularly amenable runtime optimization applications large amount code hot 
runtime optimizer afford spend large amount time improving piece code detect frequent paths executed program code layout optimizations 
order support applications support optimizations require potentially expensive analyses transformations offline 
designed run idle time user computer allowing aggressive runtime optimizer 
offline combines profile information gathered runtime optimizer llvm optimize recompile application 
way able perform aggressive profile driven interprocedural optimization competing application processor cycles 
usage pattern application changes time runtime offline coordinate ensure highest achievable performance 

applications experiences sections describe design llvm code representation compiler architecture 
section evaluate design terms categories issues effectiveness representation speed performing program analyses transformations compiler illustrative uses llvm system challenging compiler problems focusing novel capabilities llvm benefit uses 
representation issues key contributions llvm representation language independent type system 
type system provide fundamental value violated casts 
second high level language features classes map llvm type system code representation 
third large llvm representation written disk 
value type information provide 
reliable type information programs enable optimizer perform aggressive transformations difficult reordering fields structure optimizing memory management :10.1.1.19.8733
llvm weakly typed language declared type information reliable analysis typically including pointer analysis check declared type information 
key question reliable type information available programs compiled llvm 
llvm includes flow insensitive field sensitive contextsensitive points analysis called data structure analysis dsa transformations llvm dsa main foundation automatic pool allocation :10.1.1.19.8733
part analysis dsa extracts llvm types memory objects program verified accessed type safe manner 
types llvm representation speculative type information checks conservatively type information correct 
dsa performs verifies memory accesses agree declared types wide range benchmarks measured fraction static load store operations reliable type information accessed objects available 
table shows statistic benchmarks spec cpu simpler benchmarks olden benchmarks better results scoring close cases 
benchmark typed untyped typed name accesses accesses percent gzip vpr art mcf equake crafty ammp parser gap vortex bzip twolf average table loads stores provably typed table shows programs surprisingly type safe despite fact programming language enforce type safety 
leading cause loss type safety remaining programs custom memory allocators dsa aggressive 
despite custom allocators dsa able prove significant number accesses type safe 
important note similar results difficult obtain llvm untyped representation 
example earlier version llvm front gcc rtl internal representation provided little useful type information dsa dsa quite aggressive prove objects stored generic void data structure loaded type safe despite casts void 
unfortunately llvm bugs prevented getting numbers gcc mesa perlbmk time submission 
pool allocation effective 
new front ast representation gcc front type information available 
high level features map llvm 
compared source languages llvm lower level representation 
quite low level features lowered compiler targeting llvm 
example complex numbers structure copies unions bit fields variable sized arrays setjmp longjmp lowered llvm compiler 
order representation support effective analyses transformations mapping features llvm capture high level operational behavior cleanly possible 
discuss issue example richest language implemented front 
believe complex high level features expressed clearly llvm allowing behavior effectively analyzed optimized implicit calls copy constructors parameters pointers explicit 
templates fully instantiated front llvm code generated 
base classes expanded nested structure types 
fragment class base int class base float class derived base base short llvm type derived class int float short 
classes virtual functions table pointer included initialized object allocation time point virtual function table described 
virtual function table represented global constant table typed function pointers plus type id object class 
representation virtual method call resolution performed llvm optimizer effectively typical source compiler effectively source compiler uses program pointer analysis 
exceptions lowered invoke unwind instructions described section exposing exceptional control flow cfg 
fact having information available link time enables llvm interprocedural analysis eliminate unused exception handlers 
optimization effective done module basis source level compiler 
believe similarly clean llvm implementations exist constructs language families scheme smalltalk ml family java microsoft cli important examples include closures continuations 
aim explore issue preliminary underway implementation java scheme front ends 
compact llvm representation 
code compiled program stored llvm representation lifetime important overly large 
flat address form llvm suited simple linear layout instructions requiring single bit word file 
shows size llvm files spec cpu executables linking compared native bit sparc executables produced gcc cases 
executable sizes llvm sparc shows llvm code size native executables sparc roughly larger average denser variable size instruction set 
believe result llvm encodes rich type information control flow information data flow ssa information native executables 
attempted optimize size bytecode files may reduced 
fast llvm 
important aspect llvm low level representation enables efficient analysis transformation small uniform instruction set explicit cfg ssa representations careful implementation data structures 
speed important uses late compilation process link time run time 
order provide sense speed llvm shows table runtimes interprocedural optimizations 
timings collected ghz intel xeon processor 
table includes numbers aggressive dead global variable function elimination dae aggressive dead argument elimination inline function integration pass dsa data structure analysis gcc time compile programs gcc compiler provided point 
interprocedural optimizations program link time 
find cases optimization time substantially compile program gcc despite fact gcc cross module optimization little interprocedural optimization aggressive dce assume objects dead proven allowing dead objects cycles deleted 
benchmark dae inline dsa gcc gzip vpr art mcf equake crafty ammp parser gap vortex bzip twolf interprocedural optimization timings seconds translation unit 
optimizations dae efficient touch small portions program perform analysis 
inlining pass fairly quick time linear number inlines perform vortex example inlines functions deleting bodies functions subsequently dead 
data structure analysis aggressive analysis group owing largely fact context sensitive field sensitive flow insensitive pointer analysis relatively fast compared gcc 
applications life time analysis optimization capabilities llvm illustrate capabilities provided compiler framework briefly describe examples llvm widely varying compiler problems novel capabilities described 
projects llvm general compiler infrastructure noted earlier implemented compiler techniques llvm 
aggressive data structure analysis dsa automatic pool allocation analyze transform programs terms logical data structures :10.1.1.19.8733
techniques inherit significant benefits llvm especially techniques effective program available link time type information allows crucial effectiveness techniques source language independent ssa significantly improves precision dsa flow insensitive 
researchers affiliated group actively exploring llvm compiler framework number different ways 
include llvm intermediate representation binary transformations compiler back support hardware trace cache optimization system basis runtime optimization adaptation grid programs compiler memory partitioning optimization embedded codes 
safe low level representation execution environment provides safe code representation execution environment type safe subset llvm 
goal enforce memory safety programs representation static anal ysis variant automatic pool allocation garbage collection extensive interprocedural static analysis minimize runtime checks 
system exploits nearly capabilities llvm framework runtime optimization 
directly uses llvm code representation provides ability analyze programs crucial supporting embedded software middle ware system libraries 
relies type information llvm syntactic changes check enforce type safety 
relies array type information llvm enforce array bounds safety uses interprocedural analysis eliminate runtime bounds checks cases 
uses interprocedural safety checking techniques exploiting link time framework retain benefits separate compilation key difficulty led related systems avoid interprocedural techniques 
external isa design virtual instruction set computers virtual instruction set computers processor designs distinct instruction set architectures external program representation virtual isa isa actual hardware isa particular implementation isa 
software translator designed hardware essentially sophisticated implementation specific back compiler translates isa code isa software aware isa 
argued extended version llvm instruction set choice external isa processor designs 
proposed novel implementation strategy virtual native translator enables offline code translation caching translated code completely os independent manner exploits important features instruction set representation extends suitable isa hardware 
fundamental benefit llvm llvm code representation lowlevel represent arbitrary external software including operating system code provides rich information support sophisticated compiler techniques translator 
second key benefit ability offline online translation exploited translation strategy 

related focus comparing llvm classes previous virtual machine compiler systems research typed assembly languages link time dynamic optimization systems 
noted goals llvm complementary higher level language virtual machines smalltalk self jvm microsoft cli 
noted key differences goals llvm vs systems repeat 
virtual machine similar llvm low level risc architecture support multiple source languages 
goals provide safety performance 
particular include high level information necessary goals contributions quite different llvm instruction set 
lifelong optimization 
wide range field typed intermediate representations 
functional languages strongly typed intermediate languages natural extension source language 
projects typed assembly languages tal ltal focus preserving high level type information type safety compilation optimizations :10.1.1.24.6526
safetsa representation combination type information ssa form aims provide safe efficient representation jvm bytecode java programs 
contrast llvm virtual instruction set attempt preserve type safety high level languages capture high level type information languages enforce code safety directly 
goal llvm enable sophisticated analyses transformations static compile time 
attempts define unified generic intermediate representation 
largely failed ranging original universal computer oriented language discussed implemented architecture language neutral distribution format andf implemented seen limited 
unified representations attempt describe programs ast level implying include features possible source languages 
llvm ambitious assembly language uses small set types low level operations implementation high level language features described terms types 
ways llvm simply appears strict risc architecture 
kistler franz describe compilation architecture performing optimization field simple initial load time code generation followed profile guided runtime offline optimization 
system uses slim binaries code representation compact treebased code representation 
kistler franz observe representations 
llvm directly architecture making unnecessary regenerate ssa form recompilation suggest 
systems perform interprocedural optimization link time 
operate assembly code processor focusing primarily machinedependent optimizations export additional information static compiler form ir annotations :10.1.1.35.5045:10.1.1.30.3772
approaches attempt support optimization runtime offline software installed field difficult directly extend 
systems perform transparent runtime optimization native code 
systems inherit challenges optimizing machine level code addition constraint operating tight time constraints runtime optimization :10.1.1.35.5045
contrast llvm aims provide type dataflow ssa information explicit cfg runtime optimizations 
example online tracing framework section directly exploits cfg perform limited instrumentation hot loop regions runtime 
systems supports link time install time offline optimizations profile information 

described llvm system performing lifelong code analysis optimization 
system describe uses low level fully typed language representation program lifetime 
llvm representation language independent code program including system libraries portions written multiple languages compiled optimized 
llvm compiler framework includes powerful link time interprocedural optimizer low overhead tracing technique runtime trace optimization just time static code generators 
showed experimentally experience llvm available extensive type information programs safely perform number aggressive transformations normally attempted type safe languages source level compilers 
showed llvm representation comparable size sparc machine code larger code average despite capturing richer type information infinite register set ssa form 
showed example optimizations performed fast llvm representation 
key question exploring currently high level language virtual machines implemented effectively top llvm runtime optimization code generation framework 


adl tabatabai lucco wahbe 
efficient language independent mobile programs 
proceedings acm sigplan conference programming language design implementation pages 
acm press 
adve lattner shukla 
low level virtual instruction set architecture 
page appear san diego ca dec 
dalton franz ery 
safetsa type safe referentially secure mobile code representation static single assignment form 
pldi june 
ayers de jong peyton schooler 
scalable cross module optimization 
acm sigplan notices 
bala duesterwald banerjia 
dynamo transparent dynamic optimization system 
pldi pages june 
burke torczon 
interprocedural optimization eliminating unnecessary recompilation 
toplas 
burke 
choi fink grove hind sarkar serrano sreedhar srinivasan whaley 
jalape dynamic optimizing compiler java 
java grande pages 
chase 
implementation exception handling 
journal language translation june 
chen wu appel fang 
provably sound tal back optimization 
pldi san diego ca jun 
chernoff fx profile directed binary translator 
ieee micro 
cohn goodwin lowney 
optimizing alpha executables windows nt spike 
digital technical journal 
cohn goodwin lowney rubin 
spike optimizer alpha nt executables 
consortium 
architectural neutral distribution format www andf org 
cytron ferrante rosen wegman zadeck 
efficiently computing static single assignment form control dependence graph 
toplas pages october 
transmeta code morphing software speculation recovery adaptive address real life challenges 
proc 
st ieee acm symp 
code generation optimization san francisco ca mar 
deline fahndrich 
enforcing high level protocols low level software 
pldi snowbird ut june 
adve lattner 
memory safety runtime checks garbage collection 
san diego ca jun 
ebcioglu altman 
daisy dynamic compilation architectural compatibility 
isca pages 
fern ndez 
simple effective link time optimization modula programs 
acm sigplan notices 
franz kistler 
slim binaries 
communications acm 
grossman morrisett jim hicks wang cheney 
region memory management cyclone 
pldi berlin germany june 
heine lam 
practical flow sensitive context sensitive memory leak detector 
proceedings acm sigplan conference programming language design implementation pages 
acm press 
ibm xl fortran ways boost performance 
white 
adve 
ensuring code safety runtime checks real time control systems 
cases grenoble france oct 
lattner adve 
llvm language manual 
llvm cs uiuc edu docs html 
lattner adve :10.1.1.19.8733
automatic pool allocation disjoint data structures 
proc 
acm sigplan workshop memory system performance berlin germany jun 
lattner adve 
data structure analysis fast scalable context sensitive heap analysis 
tech 
report uiucdcs computer science dept univ illinois urbana champaign apr 
morrisett walker crary glew :10.1.1.24.6526
system typed assembly language 
toplas may 
muth :10.1.1.35.5045
alto platform object code modification 
ph thesis department computer science university arizona 
romer voelker lee wolman wong levy bershad chen :10.1.1.19.8733
instrumentation optimization win intel executables etch 
proc 
usenix windows nt workshop august 
shao league 
implementing typed intermediate languages 
international conference functional programming pages 
srivastava wall 
practical system intermodule code optimization link time 
journal programming languages dec 
steel 
myth fact 
annual review automated programming 
wall 
global register allocation link time 
proc 
sigplan symposium compiler construction palo alto ca 
