published proceedings principles programming languages pages ccured type safe retrofitting legacy code george necula scott weimer university california berkeley necula weimer cs berkeley edu propose scheme combines type inference run time checking existing programs type safe 
describe ccured type system extends separating pointer types usage 
type system allows pointers usage verified statically type safe pointers safety checked run time 
prove type soundness result surprisingly simple type inference algorithm able infer appropriate pointer kinds existing programs 
experience ccured system shows inference effective programs able infer pointers statically verifiable type safe 
remaining pointers instrumented efficient run time checks ensure safely 
resulting performance loss due run time checks times better comparable approaches dynamic checking 
ccured discovered programming bugs established programs specint benchmarks 
programming language provides programmers great deal flexibility representation data pointers 
features language choice systems programming 
unfortunately cost weak type system consequently great deal flexibility introducing subtle bugs programs 
research supported part national science foundation career 
ccr itr 
ccr 
ccr gifts research microsoft research 
information necessarily reflect position policy government official endorsement inferred 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
popl jan portland usa acm isbn sacrificing type safety flexibility performance sensible language design choice today situations type safety just important important performance 
errors array bounds accesses lead painful debugging sessions chasing inadvertent memory updates malicious attacks exploiting buffer overrun errors security critical code 
cert advisories result security violations kind 
type safety desirable isolating program components large extensible system loss performance separate address spaces 
valuable inter operation systems written type safe languages type safe java native methods example 
great deal useful code written written useful practical scheme bring type safety programs 
described main premises 
believe programs written unsafe languages large part program verified statically type safe 
remaining part program instrumented run time checks ensure execution memory safe 
second premise applications loss performance due run time checks acceptable price type safety especially compared alternative cost reprogramming system type safe language 
main contribution ccured type system extension type system explicit types pointers arrays dynamic types 
extends previous adding dynamic types statically typed languages types capabilities statically typed elements known compile time elements guarded run time checks 
type system inspired common usage includes support physical type equivalence special sequence pointers accessing arrays :10.1.1.30.6614
second contribution simple effective type inference algorithm translate ordinary programs ccured automatically matter seconds line programs 
inference algorithm produce type safe versions programs observed slowdown 
process programming bugs analyzed code int array int index int acc accumulator int elem ptr int acc ptr arith read elem int check tag int unbox acc int strip tag short program fragment demonstrating safe unsafe pointers 
surprising array bounds errors specint compress go ijpeg benchmarks 
continue section informal overview system context small example program 
section simple language pointers type system section operational semantics section followed discussion type safety guarantees ccured programs 
section simple constraint type inference algorithm ccured 
discuss informally extension language programming language section necessary source code changes section section relate experience prototype implementation 
overview approach ensure memory safety pointer keep track certain properties memory area supposed point 
properties include area size types values contains 
pointers information computed precisely compile time compute run time case insert run time safety checks 
kinds pointers appear example program shown 
program operates hypothetical disjoint union datatype call boxed integer efficiently implemented follows boxed integer value odd represents bit integer significant bits significant tag bit equal represents pointer boxed integer 
datatype int represent boxed integers 
variable pointer array boxed integers 
purpose function accumulate variable acc sum boxed integers array 
line compute address boxed integer line fetch boxed integer 
loop lines integer 
subscripts pointer type constructors added simplify cross referencing text 
inspection program observe values variables supposed point array 
variables subject casts aliases know type values point int 
furthermore observe pointer subject pointer arithmetic pointer 
means check uses array bounds errors need uses assuming check performed line initialized 
refer safe pointer sequence pointer 
precise associate information pointer type constructors respectively 
safe sequence pointers aliases agree type value pointed point memory areas contents statically typed 
turn attention pointer values 
values incompatible types int int 
means count static type accurate description values 
type system say dynamic pointer type associate information pointer type constructors 
dynamic pointers point memory areas contents reliable static type store extra information classify contents pointers integers 
correspondingly aliases dynamic pointers dynamic pointers safe pointer static type assumptions violated memory write dynamic pointer alias 
means type constructors classified dynamic pointers 
example program mixture pointers static type relied require little access checks safe sequence pointers pointers static type unreliable require extensive checking 
motivated similar examples ccured language essentially union languages strongly typed language containing safe sequence pointers untyped language type information maintained checked run time 
values memory areas system part safe sequence world part dynamic world 
place worlds touch typed memory area contains pointer untyped memory 
untyped memory contain safe sequence pointers assign reliable static type contents dynamic areas 
shall formalize invariants starting section 
order provide intuition formal development summarize capabilities invariants various pointer kinds 
null pointer frequently allow safe pointers null 
similarly allow arbitrary integers disguised sequence dynamic pointers safe pointers 
kind invariants maintained capabilities access checks required safe valid address containing value cast sequence pointer null pointer check pointer type 
aliases safe sequence pointers base type 
base type 
set 
cast integer 
dereferenced 
sequence pointer dynamic pointer knows run time integer knows memory area containing number values type points 
aliases safe sequence pointers base type 
knows run time integer knows memory area containing number integer dynamic pointer values points 
memory area pointed maintains tags distinguishing integers pointers 
aliases dynamic pointers 
cast safe pointer base type 
cast integer 
cast integer 
perform pointer arithmetic 
cast dynamic pointer type 
cast integer 
cast integer 
perform pointer arithmetic 
summary properties capabilities various kinds pointers 
non pointer check subsumes null pointer check 
bounds check dereferenced cast safe 
non pointer check 
bounds check dereferenced 
maintain tags pointed area reading writing 
types int ref safe ref seq dynamic expressions op commands skip syntax simple language pointers pointer arithmetic casts 
language pointers constructs programming language misused violate memory safety type safety 
type casts pointer arithmetic arrays union types address operator explicit deallocation 
simplify presentation key ideas approach describe formally small language containing pointers casts pointer arithmetic discuss informally section extend approach handle remaining constructs 
presents syntax types expressions commands simple programming language serves vehicle formalizing ccured 
level types retained integers pointer types 
symbol various syntactic roles conjunction pointer types avoid confusion adopted syntax ml modeling language 
flavors pointer types corresponding safe sequence dynamic pointers respectively 
type dynamic pointer type carry type values pointed 
indicative fact count referenced type dynamic pointer 
expressions integer literals assortment binary integer operations arithmetic relational operations written generically op 
relational operations pointers done casting pointers integers 
binary operation denotes pointer arithmetic notation denotes result reading memory location denoted 
language commands greatly simplified 
notable form commands memory update pointer 
control flow operations interesting approach flow insensitive 
function calls omitted simplification discuss briefly section handle function calls function pointers 
notable omissions variable updates address operator variables 
simplify formal presentation consider variable updated address taken allocated heap operated address immutable pointer variable language 
ignore allocation deallocation memory including stack frames 
resulting language appears simpler allows expose formally succinct way major ideas type system type inference algorithm implementation 
implementation handles entire language 
example program transcribed language variable declarations additional control flow constructs shown 
major change version replaced variables acc pointers accesses variables memory operations 
lines technically representable language 
show provide context rest example 
ignore initialization variables 
newly introduced pointer type constructors safe corresponding pointers reading writing 
change nested dynamic pointer type constructors collapsed dynamic type 
dynamic ref seq array int ref safe index int ref safe acc accumulator dynamic ref safe ref safe elem ptr dynamic ref safe acc dynamic ref safe int acc acc int program translated ccured 
type system section describe ccured type system language introduced previous section 
purpose type system maintain separation statically typed untyped worlds ensure typed programs run safely addition appropriate run time checks 
run time checks described part operational semantics section 
concentrate type checking shall assume program contains complete pointer kind information 
type system expressed means judgments expression typing command typing convertibility judgments denotes typing environment mapping variable names types 
declarations language typing environment assumed provided externally 
derivation rules typing judgments shown 
observe typing rules check casts respect convertibility relation types rules defined bottom 
special typing rule creating safe null pointer 
pointer arithmetic done sequence dynamic pointers 
memory operations legal safe dynamic pointers 
dereference operation sequence pointer performed pointer cast safe 
notice type dynamic pointers untyped areas values stored areas 
type convertibility relation captures situations cast coercion legal ccured 
notice rules type converted integer integers converted sequence dynamic pointers 
convert integer sequence dynamic pointer obtain pointers dereferences prevented run time checks 
conversion rule converting sequence pointers safe pointers case referenced type change 
conversion rule operational semantics inserts run time check verify pointer cast bounds home area 
important point cases casts act conversions different representations values cases accompanied run time checks 
run time manipulations accompany casts convertibility different subtyping respects 
convertibility extended transitivity viewed coercion subtyping relation incoherent 
example series coercions corresponding dynamic int dynamic different effect identity start perfectly usable pointer pointer lost capability perform memory operations 
lack coherence allow general subsumption rule program control conversions casts 
consequently transitivity rule rely programmer obtain effect sequence casts 
operational semantics section describe run time checks necessary ccured programs run safely 
form operational semantics ccured 
execution environment consists mapping variable names values set allocated memory areas call homes mapping memory addresses homes values 
mapping assumed provided externally just similar mapping typing rules 
language memory changes execution 
order better expose precise costs kind pointer low level representation addresses natural numbers 
home represented starting address homes define function size value size home 
require properties set function size null size 
disjoint 
size size choose size null home order ensure null pointer belongs null home 
write set 
memory corresponding set allocated homes mapping addresses values mh values domain consists exactly addresses contained non null homes dom mh size set homes change evaluation omit subscript memory 
define operations memory 
write denote contents memory address write denote new memory state obtained storing value address operations defined valid address dom 
expressions int int int op int ref safe ref safe ref seq int ref seq dynamic int dynamic ref safe dynamic dynamic commands ref safe dynamic dynamic skip convertibility int int ref seq int dynamic ref seq ref safe typing judgments 
expressions casts int var int ref seq dynamic op op int ref seq dynamic op pointer arithmetic memory reads ref safe size ref safe arith saferd size commands skip skip chain safewr size operational semantics 
boxed premises run time checks ccured uses 
values integer safe pointer expressions plain integers representation overhead values sequence dynamic pointer expressions form values kind pointer value carries identity represented home 
home check pointer integer converted pointer home retrieve size home performing bounds check 
operational semantics defined means judgments 
write say environment memory state denoted expression evaluates value commands similar judgment case result new memory state 
derivation rules judgments 
notice rules casts rule combination destination type form value cast 
rules show integer converted sequence dynamic pointer null home 
rule applies cast integer safe pointer safe pointer rule applies casts sequence pointers safe pointers 
case perform bounds check 
rules follow mark run time checks box 
instances run time checks memory operations 
memory operation uses safe pointer null pointer check done check bounds check done 
typing rules suggest perform sequence conversions ref seq int ref seq similar destination type ref seq 
legal ccured operational rules show starting pointer value conversions value pointer value reading writing 
property quite important practice programs cast pointers integers back pointers able resulting pointers memory addresses 
discuss issue section 
type safety type system described section enforces separation typed untyped worlds 
operational semantics section describes run time checks perform operation various pointer kinds 
section formalize outline proof resulting safety guarantees obtain ccured programs 
non null home define kind typed meaning contains number values type safe sequence pointers base type pointing untyped meaning contains number values type dynamic pointers type dynamic pointing 
define type set valid values type 
notation suggests set depends current set homes int dynamic kind untyped ref seq kind typed ref safe size kind typed extend notation element wise corresponding notation environments meaning dom 

times execution contents memory address correspond typing constraints home belongs 
say memory formed written wf mh property defined follows wf mh def size kind untyped dynamic kind typed reasons evaluation expression command fail 
obvious boxed run time check fail 
consider safe behavior 
reason failure operands evaluate unexpected values second operand evaluates value form third reason operations memory undefined involve invalid addresses 
state theorems saying essentially reasons failure happen typed ccured programs 
order state progress theorem want distinguish executions memory safety violated trying access invalid memory location executions failed run time check boxed hypotheses rules 
accomplish introducing new possible outcome evaluation 
say run time checks fails evaluation expression similarly say execution command results failed run time check 
technically means add derivation rules initiate result run time check fails rules propagate outcome subexpressions enclosing expression 
theorem progress type preservation wf mh mh mh theorem progress commands wf mh mh mh wf 
proofs theorems fairly straightforward inductions structure typing derivations 
note progress theorems state just memory expressions commands ref int ref safe ref ref ref convertibility ref int int ref safe ref ref dynq constraint generation rules 
safety 
imply typed computations type type preserving similar corresponding results type safe language 
means ccured memory safe type safe non dynamic fragment 
type inference far considered case program written ccured type system 
implementation allow programmer write programs directly pointer kinds specified attribute keyword gcc 
main goal able ccured existing un annotated programs 
purpose designed implemented type inference algorithm program constructs set pointer kind qualifiers program typed ccured type system 
inference algorithm operate program modules interfaces annotated pointer kind qualifiers 
rely fact program uses types form ref 
need discover occurrence pointer type constructor safe sequence dynamic 
describe inference algorithm extend ccured type language pointer type ref qualifier variable ranging set qualifier values safe seq dynq dynq qualifier associated dynamic type 
inference algorithm starts introducing qualifier variable syntactic occurrence pointer type constructor program 
scan program collect set constraints qualifier variables 
solve system constraints produce substitution qualifier variables qualifier values apply substitution types program produce ccured program 
substitution applied types rules int int ref dynamic ref dynq note qualifier substituted dynq ignore referenced type pointer consistent idea dynamic pointers count declared referenced type 
dynamic pointers point typed areas inference algorithm designed infer dynq qualifiers referenced types dynq pointers 
strategy inference find safe seq pointers possible 
simply making qualifiers dynq yields typed solution safe seq pointers preferred 

constraint collection 
collect constraints modified typing judgment written meaning scanning expression context inferred type set constraints auxiliary judgments collect constraints corresponding convertibility relation express constraint collection commands 
intent solution set constraints applied substitution elements appearing symbol yields valid typing judgment corresponding syntactic form ccured 
rules constraint collection judgments shown 
constraints pointer arithmetic fairly straightforward casts expressed separate convertibility judgment 
memory reads writes bridge gap rules rules ccured 
specifically allow memory access seq just safe pointers allow ints read written dynamic pointers 
cases implicit cast inserted yield valid ccured program 
memory write allow conversion value written type referenced type 
express convertibility constraints concise way introduce convertibility relation qualifier values essentially says seq cast safe def seq safe capture requirement dynamic pointers point dynamically typed areas type form ref ref collect pointsto constraint dynq dynq 
constraint generation set containing kinds constraints arith safe conv pointsto dynq dynq dynq constraint requires valid solution substitution types identical 
notion precise 

constraint normalization 
step normalize generated constraints simpler form 
notice system constraints generated far conditional constraints 
pointsto constraints easy handle ignore long qualifier left unknown dynq add constraints dynq system constraints 
remains unknown normalization process safe seq 
true constraints 
postpone constraints qualifiers involved remain unconstrained safe seq number dynamic pointers 
introduce system type equality constraint lead contradictions require backtracking 
fortunately simple solution problem 
start simplifying constraint possible forms types dynq int int dynq int ref dynq dynq dynq ref int dynq dynq dynq ref ref dynq subtlety rule 
observe constraint form dynq ref ref arises types ref ref ref ref appear program 
means pointsto constraints exist dynq dynq dynq dynq turn means disjunct dynq reduction rule redundant eliminated 
simplifying constraints normalized system kinds constraints arith safe conv pointsto dynq dynq dynq eq 
constraint solving 
final step algorithm solve remaining set constraints 
algorithm quite simple propagate constraints constraints eq conv pointsto 
done qualifier variables seq safe follows qualifier variables involved arith constraints set seq information propagated constraints eq conv case seq information propagated direction cast 
variables safe 
essentially find minimum number dynq qualifiers 
remaining qualifiers find pointer arithmetic performed seq remaining qualifiers safe 
solution best possible terms maximizing number safe seq pointers 
type inference process linear size program 
linear number qualifier variables introduced syntactic occurrence pointer type constructor linear number constraints created cast memory read write program 
simplification constraints number constraints get multiplied maximum nesting depth qualifier type 
constraint solving linear number constraints 
handling rest interest clarity formalized small subset ccured dialect implementation handles entire programming language extensions gnu dialect 
section discuss informally handle rest programming language 
full details forthcoming 
dynamic world structures arrays simply alternative notations saying bytes storage allocate 
safe world structures accesses required respect types fields 
example possible safe pointer structure field perform arithmetic pointer 
treat unions syntactic sugar casts 
explicit deallocation currently ignored boehm weiser conservative garbage collector reclaim storage 
ccured system maintains type information allow precise collector may 
address operator yield pointer variable 
variable pointer points may inferred live dynamic safe worlds depending pointer 
difficulty storage deallocated function returns ccured run time checks ensure stack pointer gets written heap globals 
restriction allows common address implement call uses storage question may allocated heap 
dynamic function pointers variable argument functions handled ccured passing hidden argument specifies types arguments passed 
hidden argument checked callee parameters interpreted accordingly 
things level checking sufficient detect format string errors 
certain library functions handled specially 
functions malloc important treated polymorphically lest dynamically allocated data marked dynamic 
impose constraints argument qualifiers memcpy internally pointer arithmetic accept safe pointers 
source changes ccured type system inference algorithm designed minimize amount source changes required conform restrictions 
cases legal programs failed runtime check 
cases manual intervention necessary 
common situation program stores pointer variable declared hold integer casts back pointer dereferences pointer 
cases suffices change variable declaration say unsigned long void 
type certainly marked dynamic 
programs may able replace casts pointer arithmetic 
example sequence dynamic pointer expression legal ccured expression int effectively cast integer pointer home 
resort possible query garbage collector run time find home type pointer far necessary 
problem legal code interaction sizeof fat pointers change occurrences sizeof type sizeof expression type contains pointers 
typical example allocating array integer pointers int int malloc sizeof int code allocate space safe pointers inferred point seq dynamic pointers 
code changed int int malloc sizeof size passed malloc related size uses address implement call programs attempt store stack pointers memory 
programs compiled ccured specint benchmarks li ijpeg 
solution annotate certain local variables qualifier causes allocated heap 
li fairly extensive feature results performance penalty 
ccured changes representation pointers lead problems calling functions libraries compiled ccured 
typical solution write wrapper functions translate word word arguments return values 
wrapper run time checks pointers passing underlying library 
wrapper solution works standard library 
expect encounter difficulties interoperating third party libraries interface involves passing pointers large structures contain pointers 
experimenting alternative implementation scheme bookkeeping information sequence dynamic pointers escape ccured world kept global table change representation exported data structures 
experiments ran translator programs ranging size ijpeg lines code including whitespace comments goals 
wanted measure performance impact run time checks introduced translator 
second wanted see effective inference system eliminating checks 
investigated changes program source required program run ccured restrictions 
test cases specint compress lzw data compression go plays board game go ijpeg compresses image files li lisp interpreter olden benchmark suite collection small compute intensive kernels bh body simulator sorting algorithm em solves problem health simulates colombia health care system mst computes minimum spanning trees perimeter computes perimeters regions images power simulates power market prices simply builds binary tree tsp uses greedy algorithm approximately solve random traveling salesman problem instances voronoi constructs voronoi diagrams 
source changes needed run benchmarks simple syntactic adjustments adding correcting prototypes marking printf functions 
benchmarks required changing sizeof prevalent ijpeg moving locals heap li 
program required changes data structures basic design elements 
number remaining bugs implementation prevents applying ccured benchmarks specint suite 
running time median benchmarks shown 
measurements quiescent ghz amd athlon mb linux machine gcc compiler optimization level depending benchmark size 
cases pointer kind inference performed program 
inference time linear size program argued section observed scalability problems approach 
fact biggest scalability problem optimizer compiler consumes output single large source file 
benchmarks slowdown 
measure effectiveness inference name lines orig 
ccured purify code time sf sq ratio ratio specint compress go ijpeg li olden bh em health mst perimeter power tsp ccured versus original performance 
measurements ratios means program takes twice long run instrumented ccured 
sf sq column show percentage static pointer declarations inferred safe seq dynamic respectively 
gorithm ccured naive inference algorithm pointers dynamic 
slowdown case significant times slower approaches reported researchers tried time checks approach memory safety example pointer intensive benchmark li runs times slower pointers blindly marked dynamic inference discovers pointers safe seq twice slow 
program size big influence pointers statically verified 
small programs olden benchmark suite tend data types straightforward ways 
large programs especially designed extended pointers ways 
case ijpeg uses object oriented downcasts large number pointers dynamic 
discovered fixed bugs specint benchmarks compress ijpeg contain array bounds violation go array bounds violations uninitialized integer variable array index 
case verified fixing bug change program eventual output test vectors considered partially explains bugs survived long tested programs 
bugs go involved erroneous index arithmetic large multi dimensional arrays 
finding bugs demonstrates advantage type sensitive approach 
simply marked home areas untyped checked errors pointer home area errors happen stay intended home area 
originally motivated performance discover safe pointers doing enhanced bug finding ability 
column shows slowdown programs instrumented purify version tool instruments existing binaries detect memory errors leaks keeping bits storage byte heap unallocated uninitialized initialized 
purify catch pointer arithmetic yields pointer separate valid region property fischer patil show important 
purify tends slow programs factor ccured 
course purify require source code may applicable situations 
purify find uninitialized variable go bugs accesses question stray far noticed 
related abadi study theoretical aspects adding dynamic type simply typed calculus discuss extensions polymorphism data types :10.1.1.39.8459
thatte extends system replace typecase expressions implicit casts 
system handle types memory updates dynamic types introduced add flexibility language 
contrast system designed handle memory reads writes allows dynamic values manipulated pointer arithmetic checking tags uses dynamic types guarantee safety code statically verified 
chandra reps method physical type checking programs structure layout presence casts :10.1.1.30.6614
inference method reason casts various structure types considering physical layout memory 
example section fail type check system reason mark pointers dynamic safety guaranteed compile time 
identify casts programs safe tool check casts 
programming languages clu cedar mesa modula include similar notions dynamic type typecase statement 
idea seen caml exception type 
related area falls broad categories extensions type system adding runtime checks removing run time checks lisp 
previous efforts extend type system usually deal polymorphism 
smith polymorphic provably type safe dialect includes features higher order functions current system handles weakly lacks casts structures :10.1.1.152.7309
evans describes system programmer inserted annotations static checking techniques find errors anomalies large programs 
ramalingam algorithm finding coarsest acceptable type structures programs 
type systems inference methods sources information 
type inference system goal making programs safe 
attempts bring measure safety past trading space speed security 
previous techniques concerned spatial access errors array bounds checks pointer arithmetic temporal access errors touching memory freed static analysis form 
interpretive scheme called detect rich class errors including uninitialized reads dynamic type mismatches temporal access errors runs times slower normal 
austin store extra information pointer achieve safety cost large speed space overhead lack backwards compatibility 
jones kelly store extra information run time checks splay tree allowing safe code unsafe libraries 
results slowdown factor 
fischer patil system uses second processor perform bounds checks 
total execution overhead program typically technique requires dedicated second processor 
store type information memory location incurring slowdown factor 
extra information allows perform detailed checks detect stored types mismatch declared types union members accessed order 
tool similar respects goal provide rich debugging information programs safe retaining efficiency 
steffen compiler portable adds object attributes pointers fails detect temporal access errors perform check optimizations 
fact array bounds check elimination techniques type static analysis aggressively reduce overhead instrumented code 
done remove dynamic checks tagging operations lisp languages 
henglein details type inference scheme remove tagging operations lisp languages 
structure algorithm similar simple syntax direct constraint generation constraint normalization constraint solving domain discourse quite different base language dynamically typed 
henglein system primitive type constructor associated exactly tag need deal pointer array ambiguity motivates seq pointers 
necessary allocate object having certain type view having type henglein system disallows tags set object creation time true style casts unions fully supported 
henglein able sidestep update aliasing issues tagging create new copy object set 
applied example tagged untagged aliases item 
algorithm consider polymorphism module compilation 
ccured system uses form physical subtyping pointers structures clear extend henglein constraint normalization procedure case 
jagannathan expensive precise flow sensitive analysis called polymorphic splitting eliminate run time checks higher order call value programs 
shields system dynamic typing staged computation run time code generation coexist deferred computations dynamic type compile time checked precisely run time 
technique handle persisting dynamic data weakness current system 
soft type systems infer types procedures data structures dynamically typed programs 
advanced soft type systems inclusion subtyping handle unions recursive types complex language features 
presents practical ml style type inference system lisp 
henglein systems start dynamically typed language tackle different core problem 
programming language language choice systems programming flexibility control layout data structures pointers 
unfortunately comes expense type safety 
propose scheme combines program analysis run time checking bring type safety existing programs trading performance 
key insight programs pointers way verified type safe typing rules similar strongly typed languages 
furthermore rest pointers checked run time ensure safely 
entire approach hinges ability infer accurately pointers need checked run time 
surprisingly simple type inference algorithm able just 
surprising result experiments programs pointers perfectly safe inference able discover means programs just safe written type safe language 
consequently cost enforcing safety programs relatively low prototype implementation able achieve overheads times smaller comparable tools rely exclusively run time checking 
flavors typed pointers cover programming paradigms encountered programs 
operations pointers statically proven safe type system fails recognize 
important example tagged union types incompatible members current ccured system flags untyped special case object oriented downcasts heavily ijpeg 
handle situations resorting dynamic useful expressive language pointer types current system provides 
acknowledgments alex aiken jeff foster useful comments earlier drafts raymond bhargava rahul danny helping implementation ccured system 
abadi cardelli pierce plotkin :10.1.1.39.8459
dynamic typing statically typed language 
acm transactions programming languages systems april 
austin breach sohi 
efficient detection pointer array access errors 
sigplan notices june 
proceedings acm sigplan conference programming language design implementation 

boehm weiser 
garbage collection uncooperative environment 
software practice experience sept 
breazu tannen gunter scedrov 
computing coercions 
lisp functional programming pages 
cardelli donahue glassman jordan kalsow nelson 
modula report 
carlisle 
olden parallelizing programs dynamic data structures distributed memory machines 
phd thesis princeton university department computer science june 
cartwright fagan 
soft typing 
proceedings conference programming language design implementation pages 
chandra reps physical type checking proceedings acm sigplan sigsoft workshop program analysis software tools engineering volume software notes sen pages :10.1.1.30.6614
acm press sept 
evans 
static detection dynamic memory errors 
acm sigplan notices 
hastings joyce 
purify fast detection memory leaks access errors 
proceedings usenix winter technical conference pages berkeley ca usa jan 
usenix association 
henglein 
global tagging optimization type inference 
proceedings acm conference lisp functional programming pages 
jagannathan wright 
effective flow analysis avoiding run time checks 
proceedings second international static analysis symposium volume pages 
springer verlag 
jones kelly 
backwards compatible bounds checking arrays pointers programs 

lopez 
programming environment language 
proceedings summer usenix conference pages 
kind friedrich 
practical approach type inference 
lisp symbolic computation 
lampson 
description cedar language 
technical report csl xerox palo alto research center 
liskov atkinson bloom moss schaffert snyder 
clu manual 
springer verlag berlin 
yong horwitz reps debugging run time type checking 
proceedings fase fundamental approaches software engineering apr 
patil fischer 
efficient run time monitoring shadow processing 
automated algorithmic debugging pages 
patil fischer 
low cost concurrent checking pointer array accesses programs 
software practice experience jan 
ramalingam field tip 
aggregate structure identification application program analysis 
symposium principles programming languages pages jan 
remy vouillon 
objective ml simple objectoriented extension ml 
symposium principles programming languages pages 
shields sheard jones 
dynamic typing staged type inference 
symposium principles programming languages pages 
chandra ball reps coping type casts acm foundations software engineering conference lncs volume lecture notes computer science pages 
springer verlag acm press september 
smith volpano :10.1.1.152.7309
sound polymorphic type system dialect science computer programming 
spec 
standard performance evaluation benchmarks 
www spec org osg cpu cint july 
steffen 
adding run time checking portable compiler 
software practice experience apr 
thatte 
quasi static typing 
conference record th acm symposium principles programming languages popl pages 
wagner foster brewer aiken 
step automated detection buffer overrun vulnerabilities 
network distributed systems security symposium pages feb 
wright cartwright 
practical soft type system scheme 
acm transactions programming languages systems 

