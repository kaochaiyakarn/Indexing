lecture notes computer science edited goos hartmanis van leeuwen berlin heidelberg new york hong kong london milan paris tokyo michel bidoit peter mosses casl user manual common algebraic specification language chapters till mossakowski donald sannella andrzej tarlecki series editors gerhard goos karlsruhe university germany hartmanis cornell university ny usa jan van leeuwen utrecht university netherlands authors michel bidoit laboratoire sp cnrs umr cole normale sup rieure de cachan avenue du pr wilson cachan cedex france mail bidoit lsv ens cachan fr peter mosses university aarhus brics department computer science aarhus denmark mail brics dk cataloging publication data applied catalog record book available library congress 
bibliographic information published die deutsche die deutsche lists publication deutsche detailed bibliographic data available internet de 
cr subject classification issn isbn springer verlag berlin heidelberg new york subject copyright 
rights reserved part material concerned specifically rights translation re illustrations broadcasting reproduction microfilms way storage data banks 
duplication publication parts thereof permitted provisions german copyright law september current version permission obtained springer verlag 
violations liable german copyright law 
springer verlag part springer science business media com ifip international federation information processing austria printed germany typesetting camera ready author data conversion printed acid free spin preface casl algebraic specification language designed cofi common framework initiative algebraic specification development 
casl expressive language specifying requirements design conventional software 
algebraic sense models casl specifications algebras axioms arbitrary order formulas 
user manual illustrates discusses write casl specifications 
casl major new algebraic specification language 
carefully designed large group experts general purpose language practical software development particular specifying requirements design 
casl includes carefully selected features previous specification languages novel features allow algebraic specifications written concisely hitherto 
may ultimately replace previous languages provide common basis research development 
casl attracted widespread interest algebraic specification community generally regarded de facto standard 
various sublanguages casl available primarily connection existing tools developed connection previous languages 
extensions casl provide languages oriented development particular kinds software reactive concurrent 
major libraries validated casl specifications freely available internet specifications reused simply referring names 
tools provided support practical casl checking correctness specifications proving facts managing formal software development process 
vi preface companion casl manual provides full details casl design including formal semantics 
briefly reviewing background cofi casl underlying concepts algebraic specification languages book introduces potential user features casl mainly means illustrative examples 
presents discusses typical ways language concepts constructs expected course building system specifications 
presentation focuses constructs concepts casl 
points clear possible referring simple examples discussing general ideas details casl specifications 
chapters introduce reader casl manual currently available casl support tools couple casl libraries basic datatypes 
substantial case study practical casl relevant context completes material 
appendices provide quick casl constructs list main points bear mind casl original informal requirements case study 
structure part background chapter describes origins casl proliferation algebraic specification languages preceding decades aims scope formulated international initiative 
benefit readers familiar algebraic specification languages chap 
reviews main concepts algebraic specification explaining standard terminology regarding specification language constructs models algebras 
part ii writing casl specifications chapter shows familiar datatypes involving total functions specified casl essentially algebraic specification languages 
loose generated free specifications discussed turn illustrative examples advice different specification styles 
partial functions arise naturally 
chapter explains casl supports specification partial functions drawing attention special care needed compared specifications involving total functions 
subsorts useful casl specifications 
chapter illustrates declared defined avoid need partial functions 
preface vii examples far named structured specifications simple natural way 
chapter takes closer look constructs casl provides structuring specifications explaining large complex specifications easily built simpler ones means small number specification building operations 
chapter shows making specification generic appropriate improves reusability allowing instantiated different arguments compound identifiers avoid need explicit renaming combining results different instantiations 
introduces constructs expressing called views specifications 
specification building operations useful structure text large specifications architectural specifications meant imposing structure implementations 
chapter discusses illustrates role architectural specifications shows express casl 
chapter explains illustrates libraries named specifications formed available internet encourage widespread reuse evolution specifications 
version control crucial importance 
part iii carrying chapter gives detailed overview foundations casl established accompanying casl manual 
tool support vital efficient formal specifications connection practical software design development 
chapter presents main tools implemented far allow casl specifications connection tools originally developed specification languages showing casl provides tool interoperability 
chapter introduces specifications available casl libraries basic datatypes 
chap 
gives realistic case study casl practice connection design software steam boiler control system 
particular example standard bench marks comparing specification frameworks 
appendices indexes volume completed appendices app 
provides compact overview casl constructs quick app 
lists main points bear mind casl app 
reproduces informal requirements specification case study 
names specifications book listed back index concepts list literature 
comprehensive annotated bibliography publications involving casl provided manual 
viii preface accompanying cd rom contains source files illustrative specifications copy libraries specifications basic datatypes 
organization main points highlighted 
material book organized tutorial fashion 
main point usually accompanied illustrative example complete casl specification names specifications listed order presentation alphabetically book 
points repeated order presentation app 
readers familiar previous algebraic specification languages especially participating design development casl may prefer skip lightly 

chapter mandatory casl features needed understand subsequent chapters introduced 
contrast 
skipped reading reader interested partial functions resp 
subsorting proviso examples chapters chapters 
chapters mainstream material feels comfortable main points examples advisable wait proceeding 

chapter primarily want follow book detailed study casl manual 
part chap 
assumes familiarity concepts introduced chap 

chap 
sect 
assumes 
sect 
assumes 

chap 
studied chap 
sect 
requires chap 


chapter written donald sannella andrzej tarlecki 
chapter written till mossakowski contributions mark van den brand markus 
till mossakowski provided chap 
libraries casl specifications developed bremen institute secure systems joint markus lutz schr der checked formedness specifications book cats casl tool set 
public drafts book released july october 
insightful comments cofi participants readers helpful authors preparation final version 
detailed comments part public drafts received rgen christian preface ix narciso mart oliet till mossakowski don sannella giuseppe scollo andrzej tarlecki fr ric alexandre 
responsibility mistakes final version belongs course authors 
michel bidoit gratefully acknowledges support lsv cnrs cole normale sup rieure de cachan 
peter mosses gratefully acknowledges support brics department computer science university aarhus 
material book developed connection activities cofi wg esprit working group ifip wg foundations system specification 
special springer particular alfred hofmann executive editor willingness publish book helpful advice concerning preparation 
michel bidoit peter mosses october laboratoire sp www lsv ens cachan fr 
basic research computer science www brics dk funded danish national research foundation 
contents part background 
cofi 
casl 
underlying concepts 




part ii casl specifications getting started 



partial functions 




subsorting 
subsort declarations definitions 
subsorts overloading 
subsorts partiality 
xii contents structuring specifications 

renaming 
hiding 


generic specifications 



views 
specifying architecture implementations 

writing meaningful architectural specifications 
libraries part iii carrying foundations tools heterogeneous tool set hets hol casl asf sdf basic libraries library basic numbers library basic case study steam boiler control system specifying detection equipment failures 
boiler contents xiii validation casl requirements specification 
appendices casl quick libraries points bear mind subsorting 
libraries foundations 
tools steam boiler control specification problem messages received program 
list named specifications index library specification names concept index chapter explains background aims cofi common framework initiative algebraic specification development software 
gives overview main features casl common algebraic specification language 
cofi open collaborative effort initiated design common framework algebraic specification development software 
referred common framework initiative cofi 
urgent need common framework 
rationale initiative lack common framework major hindrance dissemination application algebraic specification techniques 
particular proliferation languages differing quite minor ways 
major languages included act act asf asl clear extended ml larch obj spectrum 
abundance languages obstacle adoption algebraic methods industrial contexts making difficult exploit standard examples case studies training material 
common framework widespread support research community urgently needed 
cofi pronounced coffee 
bidoit mosses casl user manual lncs pp 

ifip international federation information processing aim cofi base common framework possible critical selection features explored previous research applications see ifip state art report algebraic foundations systems specification background 
collective experience expertise cofi participants provided unique opportunity achieve aim reasonably short time span 
various groups working algebraic specification frameworks ample opportunity develop particular variations theme algebraic specification clear winner emerged strong contenders 
cofi aims establishing wide consensus 
aim cofi design framework incorporating just features wide consensus regarding appropriateness 
framework able subsume existing frameworks seen attractive common basis research development high potential strong collaboration various groups 
initial aims cofi formulated follows common framework algebraic specification software development designed developed disseminated 
production common framework collaborative effort involving large number experts different groups working algebraic specification 
short term common framework accepted appropriate basis significant proportion research development algebraic specification 
specifications common framework uniform syntax straightforward semantics 
common framework able replace existing algebraic specification frameworks 
common framework supported concise manual user guide libraries specifications tools educational materials 
longer term common framework attractive industrial contexts 
common framework available free charge academic institutions industrial companies 
protected appropriation 
cofi focus cofi algebraic techniques 
functionality common framework allow useful algebraic specification functional requirements software systems significant class software systems formal development design specifications requirements specifications particular methods documenting relation informal statements requirements formal specifications verification correctness development steps formal requirements design specifications documenting relation design specifications implementations software exploration logical consequences specifications rewriting theorem proving prototyping reuse parts specifications adjustment specifications developments changes requirements providing library useful specification modules providing workbench tools supporting 
cofi achieved main aims 
major achievement cofi completion design casl common algebraic specification language 
casl design effort started september 
initial design proposed may language summary syntax formal semantics concrete syntax tentatively approved ifip wg 
report ifip referees initial casl design proposal suggested reconsideration points language design requested improvements documents describing design 
apart details design finalized april casl version released october 
ifip wg asked review final design casl version may subsequently approved design april 
current version adopted october incorporates adjustments minor details concrete syntax semantics 
revisions casl design anticipated 
casl manual published companion volume book includes detailed concise pages summary casl design rest concerned mainly formal syntax semantics casl libraries basic datatype specifications 
manual chap 
book 
parallel design casl cofi developed tool support casl see chap 
substantial libraries casl specifications see chap 

despite previous lack casl user manual evidence casl accepted appropriate basis research development algebraic specification 
gives overview achieved period annotated bibliography casl manual lists significant number publications involve casl 
time writing remains seen significant industrial take follow 
cofi open voluntary initiative 
cofi started compass esprit basic research wg cooperation ifip wg foundations system specification founded basis proposals meetings santa margherita ligure italy oslo norway participation cofi confined members working groups 
active participants included leading researchers algebraic specification representatives european groups working area 
ideally representatives non european groups involved logistic difficulties prevented 
originally cofi separate task groups concerning language design semantics tools methodology reactive systems 
substantial amount interaction task groups facilitated cofi participants involved task group 
coordination task groups managed peter mosses start cofi september august subsequently don sannella 
cofi task groups replaced looser coordination mechanism steering committee chaired don sannella 
cofi received funding esprit working group sponsored ifip wg 
european commission provided funding european component cofi esprit working group 
partners coordinating sites various cofi task groups university aarhus university bremen cole normale sup rieure de cachan university genova inria lorraine warsaw university university edinburgh coordinator 
goals working group coordinate completion disseminate common framework casl demonstrate practical applicability industrial contexts establish infrastructure needed european collaborative research algebraic techniques 
apart period funding support meetings compass working group termination cofi relied entirely efforts participants 
participation frequent working meetings supported generous subsidies local organizers 
ifip wg sponsors cofi reviewing proposals changes design casl proposals extensions casl 
considerable number members ifip wg time writing active participants cofi 
new participants welcome 
cofi open collaboration new participants welcome 
current information cofi activities available main cofi web site www cofi info 
low volume mailing list cofi cofi info reserved cofi announcements discussions cofi activities generally take place mailing list cofi discuss cofi info cofi web site subscribe access archives 
casl casl designed general purpose algebraic specification language subsuming existing languages 
primary specification language developed cofi called casl common algebraic specification language 
main features design casl critical selection concepts constructs existing algebraic specification frameworks 
casl expressive specification language simple semantics pragmatics 
casl appropriate specifying requirements design conventional software packages 
casl heart coherent family languages obtained sublanguages extensions casl 
casl subsumes previous languages formal specification functional requirements modular software design 
tools casl interoperable capable combination isolation 
casl interfaces existing tools extend inter operability see chap 

intention base design casl critical selection concepts constructs existing specification languages 
easy reach consensus coherent language design 
great deal careful consideration effect constructs available language aspects methodology tools 
complete formal semantics casl produced parallel stages language design desire relatively straightforward semantics factor choice various alternatives design 
casl represents consolidation past design algebraic specification languages 
minor exceptions features form languages language comes close subsuming 
designing language particular novel collection features required solutions number subtle problems interaction features 
overview casl design full details provided casl manual 
casl center family languages 
clear start single language suit purposes 
hand sophisticated features required deal specific programming paradigms special applications 
hand important methods prototyping reasoning specifications absence certain features instance term rewriting requires specifications equational conditional equational axioms 
casl extensions sublanguages fig 

casl family languages casl center family languages see fig 

tools delineated sublanguages casl obtained syntactic semantic restrictions extensions casl generally casl designed support various paradigms applications 
design casl took account need define sublanguages extensions 
casl major parts 
major parts casl concerned basic specifications structured specifications architectural specifications libraries specifications 
designed basic specifications structured specifications turn architectural specifications structured architectural specifications collected libraries 
parts casl quite independent may understood separately shall see part ii 
underlying concepts casl standard concepts algebraic specification 
chapter reviews main concepts algebraic specification 
briefly explains illustrates standard terminology regarding specification language constructs models specifications algebras indicates differences basic structured architectural specifications 
focus concepts relevant casl needed chapters 
comprehensive presentations concepts results concerning algebraic specification see overview design casl see full details casl casl manual 
reader assumed familiar basic mathematical notions sets relations total partial functions logical formulas axioms 
basic specifications basic specification declares symbols gives axioms constraints 
basic specification algebraic specification language generally consists set declarations symbols constraints restrict interpretations declared symbols 
casl allows basic specifications include items simultaneously declare symbols restrict interpretations 
bidoit mosses casl user manual lncs pp 

ifip international federation information processing underlying concepts semantics basic specification signature class models 
meaning semantics basic specification sp generally parts signature corresponding symbols introduced specification class models corresponding interpretations signature satisfy axioms constraints specification 
model satisfies specification sp sp say model sp 
formalizing theory called institutions involves categorical structure set signatures class models natural condition satisfaction relation 
bother details see concept signature morphism sect 
specification said consistent class models non empty inconsistent 
casl specifications may declare sorts subsorts operations predicates 
signature represents declarations sorts subsorts operations predicates 
signature called sorted subsort declarations subsorted called algebraic predicate declarations 
sorts interpreted carrier sets 
sort symbol interpreted set called carrier set 
elements carrier set generally representations data processed software numbers characters lists sort declared specification corresponds type programming language 
sort symbols usually chosen strongly suggestive intended interpretations int sort interpreted set integers list set lists 
casl allows compound sort symbols list int lists integers 
readers interested foundational aspects may treat word class synonym set 
general models algebraic specification casl constitute proper class restriction elements carrier sets 
basic specifications subsorts declarations interpreted embeddings 
sort may declared subsort supersort sorts 
subsort relation sorts interpreted set inclusion 
casl general interpreted embedding function carrier set subsort supersort 
example ascii specified subsort iso latin casl carrier set ascii simply subset iso latin declared subsort string carrier sets char string disjoint embedding mapping character corresponding single character string 
see concept overloading 
operations may declared total partial 
operation symbol consists name operation profile indicates number sorts arguments result sort 
declared operation symbol interpreted total partial function cartesian product carrier sets argument sorts carrier set result sort subset argument tuples result function defined called domain definition 
declaration indicates function total partial 
example integer addition declared total integer division partial 
result applying operation undefined arguments undefined regardless operation total partial 
arguments operation called constant 
interpreted simply element result sort 
predicates different boolean valued operations 
predicate symbol consists name predicate profile indicates number sorts arguments result sort predicates syntactically different boolean valued operations form atomic formulas terms 
casl declared predicate symbol interpreted relation subset cartesian product carrier sets argument sorts 
application predicate said hold tuple arguments relation 
example partial function just happen defined course 
underlying concepts symbol interpreted relation declared binary predicate integers 
application predicate simply fails hold arguments undefined undefinedness holding 
allows logic remain valued logical connectives familiar interpretations 
contrast result evaluating application total operation true false undefined case arises argument application undefined 
boolean valued operations corresponding logical connectives conjunction implication take account undefinedness leads valued logic 
significant difference predicates boolean valued operations shows connection concept initiality see sect 

predicates valued logic represented accurately partial operations single valued result sort holding represented definedness 
operation symbols predicate symbols may overloaded 
operation predicate name declared different profiles specification 
called overloading 
example constant empty overloaded interpreted unrelated elements sorts list set context 
similarly predicate name overloaded unrelated sorts char int 
casl overloading required compatible embeddings subsorts 
example sort nat interpreted set natural numbers subsort int interpreted set integers operation name predicate name declared nat int interpretations required difference embedding nat int applied arguments result operation applied arguments predicate 
axioms formulas order logic 
interpretation quantification universal existential usual logical connectives negation conjunction disjunction implication equivalence casl axioms completely standard 
variables formulas range carrier sets specified sorts 
structured specifications apart usual predicate applications atomic formulas casl axioms equations strong existential definedness assertions subsort membership assertions 
existential equation holds values terms defined equal strong equation holds values terms undefined 
regardless values terms occurring axiom defined axiom holds hold particular model logic valued undefinedness holding axioms 
recall value argument term undefined application predicate holds similarly definedness subsort membership assertions hold arguments undefined 
sort generation constraints eliminate junk specific carrier sets 
general carrier sets models specification may contain junk elements elements obtained composition operations declared signature specification 
sort generation constraint casl concerns specific sorts operations satisfied model elements indicated carrier sets junk respect indicated operations elements sets obtained consecutively applying operations elements carrier sets remaining sorts 
example carrier set sort container constrained generated sort elem operations constant empty binary operation insert container result sort container 
constraint ensure elements container carrier obtained finite number successive applications insert operation elements sort elem starting empty value sort container 
structured specifications structured specifications formed basic specifications named specifications generic specifications constructs composing specifications 
underlying concepts semantics structured specification simply signature class models 
semantics structured specification form basic specification signature class models 
structure specification reflected models specification modular style 
specification architecture implementations addressed sect 
symbols signature called exported symbols specification 
interpretation structured specification constructs involves mappings signatures called signature morphisms corresponding mappings models called reducts morphisms 
signature morphism consists mapping gives sort corresponding sort preserving subsort relationships operation predicate symbol profile sorts corresponding symbol profile corresponding sorts preserving overloading symbols profiles related subsorting 
partial operation may mapped total operation vice versa 
model 
define reduct signature morphism model obtained follows symbol interpreted exactly way corresponding symbol interpreted conversely said expansion reduct suppose specification sp signature sp signature signature morphism said specification morphism sp sp reduct model sp model sp 
models weak homomorphism maps elements carrier sets elements corresponding carrier sets preserving embeddings subsorts values definedness operations holding predicates 
homomorphism isomorphism inverse homomorphism 
initial class models unique homomorphism model class 
class models initial model need case casl upto isomorphism 
concepts signature morphism model reduct homomorphism proceed explain constructs involved structured specifications 
structured specifications translation merely renames symbols 
translating sort symbol requires translating profiles operation predicate symbols involving sort translating operation predicate symbol respect overloading symbols profiles related subsorting 
translation sort operation predicate names casl determines signature morphism mapping signature specification sp new signature models translation specification models interpreting reducts models sp 
hiding symbols removes parts models 
hiding sort symbol implies hiding operation predicate symbols profiles involve sort hiding operation predicate symbol implications 
hiding set symbols occur signature specification sp give subsignature determines signature morphism simply includes 
models hiding specification reducts models sp 
example operation suc introduced purely facilitate specification natural numbers sort nat constants usual arithmetic operations 
hiding suc removes interpretation suc models specification leaves carrier set nat unchanged 
union specifications identifies common symbols 
signature union specifications sp sp simply union respective signatures models union models union signature reducts signature inclusions satisfy sp sp respectively 
symbol signatures common single interpretation model union specification 
known name thing principle 
successor number course obtained addition underlying concepts extension specifications identifies common symbols 
signature extension specification sp specification items declarations axioms constraints simply extension signature sp symbols new declarations 
models extension models extended signature satisfy axioms constraints specified extension reducts satisfy sp 
extension symbol sp occurrence symbol signature extension interpretation name thing principle 
casl unions extensions kinds structured specification formed specification fragments determine signature extensions necessarily complete signatures 
free specifications restrict models free initiality special case 
specification freely extended additional specification items interpretations additional declarations required satisfy axioms properties consequences axioms hold 
particular domains definition partial operations sets arguments predicates hold small possible 
carriers original sorts left unchanged new carriers larger required provide interpretations operations unnecessary junk elements 
restriction models referred freeness constraint 
degenerate case specification enriched empty models free extension just initial models 
difference predicates boolean valued operations particularly apparent free specifications predicates required specify hold holding default boolean valued operations true false values treated symmetrically necessary specify cases default 
generic specifications parameters instantiated referenced 
named specification may declare parameters union extended body called generic 
purpose generic architectural specifications specification reuse body different contexts generic specification instantiate providing parameter argument specification fitting morphism parameter argument specification 
fitting may achieved named views parameter argument specifications 
instantiation generic specification gives union arguments translation generic specification expansion fitting morphism 
corresponds called push construction account explicit imports generic specification 
architectural specifications semantics architectural specification reflects modular structure 
intention architectural specifications primarily impose structure implementations expressing composition component units decomposition task developing implementations requirements specifications 
contrast structured specifications considered sect 
specified models structure basic specifications considered sect 

architectural specifications involve notions persistent function conservative extension 
function mapping models models signature extends model reduct toa model exactly specification extension sp sp said conservative model sp expanded model sp persistent function mapping models sp models sp exists sp conservative extension sp 
underlying concepts libraries specifications semantics library specifications mapping names specifications semantics 
specification library gives library name determines version number 
getting started simple specifications may written casl essentially algebraic specification languages 
simplest kind algebraic specification specified operation interpreted ordinary total mathematical function takes values particular types arguments returns defined value 
total functions correspond software execution terminates normally 
types values named simple symbols called sorts 
practice realistic software specification involves partial total functions 
may formed simpler specifications involve total functions 
chapter explains express simple specifications casl illustrating various features language 
simple specifications discussed chapter expressed previous specification languages usually straightforward reformulate casl 
readers know specification languages probably recognize familiar examples illustrations chapter 
casl provides useful abbreviations 
technique algebraic specification axioms generally wellsuited expressing properties functions 
functions commonly occurring mathematical properties tedious give corresponding axioms explicitly 
casl provides useful abbreviations cases 
similarly called free datatype declarations allow sorts value constructors specified functional programming languages concise suggestive notation 
bidoit mosses casl user manual lncs pp 

ifip international federation information processing getting started casl allows loose generated free specifications 
models loose specification include declared functions specified properties restrictions sets values corresponding various sorts 
models generated specification contrast required values expressed terms formed specified constructors unreachable values prohibited 
models free specifications required values terms distinct equality follows specified axioms possibility unintended coincidence prohibited 
section focuses loose specifications sect 
discusses generated specifications sect 
free specifications 
loose generated free specifications casl style advantages particular circumstances explained connection illustrative examples 
loose specifications casl syntax declarations axioms involves familiar notation self explanatory 
spec strict partial order start simple example sort elem pred elem elem pred abbreviates predicate elem strict asymmetric transitive note may exist basic specification named strict partial order introduces sort elem binary infix predicate symbol 
declaration predicate symbol argument sorts separated sign input directly iso latin ascii 
note casl allows called mixfix notation specifier free indicate pairs underscores place holders place arguments building loose specifications terms single underscores treated letters identifiers 
mixfix notation generally allows familiar mathematical programming notations contributes substantially readability specifications 
interpretation binary predicate symbol axioms 
set axioms generally list formulas preceded universally quantified declaration relevant variables respective sorts shown example 
casl axioms written order logic equality quantifiers usual logical connectives 
universal quantification preceding list axioms applies entire list 
axioms annotated labels written convenient proper explanations tools 
note input forall input 
usual logical connectives input respectively input directly iso latin character 
existential quantifier exists input exists 
advisable comment appropriate various elements introduced specification 
syntax line grouped multi line comments illustrated example 
keyword specification optional 
strict partial order specification loose sense non isomorphic models models total ordering relation models interpreted partial 
specifications easily extended new declarations axioms 
spec total order strict partial order elem total extensions introduced keyword may specify new symbols possibly constrained axioms merely require properties old ones total order example generally time 
total order constrain interpretation predicate symbol requiring total ordering relation 
symbols introduced specification default exported visible extensions 
instance case sort elem mixfix notation called generalizes infix prefix postfix notation allow arbitrary mixing argument positions identifier tokens 
getting started predicate symbol introduced strict partial order exported available total order 
simple cases operation predicate symbol may declared intended interpretation defined time 
spec total order minmax total order ops min elem elem max elem elem total order minmax extends total order introducing binary operation symbols min max functional notation place holders 
intended interpretation symbol min defined simultaneously declaration done max 
instance abbreviates op min elem elem op min elem elem elem elem min similarly max 
predicate symbol declarations operation symbol declaration argument sorts separated sign result sort preceded input 
construct abbreviation min abbreviates min min casl specifications visibility linear symbol declared 
example min declared define max 
linear visibility imply fixed scheme writing specifications specifier free required declarations axioms order long linear visibility rule respected 
instance may prefer declare sorts operation see chap 
constructs allowing explicit restriction set symbols exported specification 
loose specifications predicate symbols needed specify properties relevant axioms 
contrast may prefer operation predicate symbol declaration immediately followed axioms constraining interpretations 
styles equally fine mixed desired 
flexibility illustrated variant total order minmax specification explanatory purposes refrain useful abbreviations explained 
spec variant total order minmax total order vars elem op min elem elem elem min min op max elem elem elem max max note order avoid tedious repetition declaration variables list axioms global variable declaration introduces rest specification 
variable declarations course exported specification extensions variables declared variant total order minmax visible extensions 
symbols may conveniently displayed usual mathematical symbols means display annotations 
display latex spec partial order strict partial order pred elem display annotation obvious reasons specification text input iso latin character set convenient display symbols differently mathematical symbols 
case conveniently displayed 
display annotations casl annotations auxiliary parts specification tools affect semantics specification 
display annotations provided library explained detail chap 

getting started example facility simultaneously declaring defining symbol predicate symbol order obtain concise specification 
implies annotation indicate axioms supposedly redundant consequences 
spec partial order partial order implies elem transitive implies annotation emphasize transitivity follow axioms words model class partial order exactly model class partial order 
implies annotation applies specification extension occurs happens introduce single axiom 
note annotation affect semantics specification removing implies annotation change class models specification 
sole aim implies annotation stress specifier intentions help readers confirm understanding 
tools may course annotations generate corresponding proof obligations 
instance proof obligation partial order elem discharging proof obligations increases trustworthiness specification 
fully understand implies annotation effect semantics best consider example corresponding proof obligation discharged shown 
spec implies hold partial order implies elem total loose specification partial order models partial ordering relation proof obligation corresponding implies annotation discharged 
annotations impact semantics specification implies hold formed just constrains interpretation total ordering relation 
fact proof obligation discharged merely points potential mistake specification 
loose specifications attributes may abbreviate axioms associativity commutativity idempotence unit properties 
spec monoid sort monoid ops monoid monoid monoid monoid assoc unit example introduces constant symbol sort monoid thena binary operation symbol asserted associative unit element 
note sign sort declaring constant 
assoc attribute abbreviates expected axiom monoid unit attribute abbreviates monoid note unit legal necessary previously declared constant respect linear visibility rule 
available attributes comm abbreviates obvious axiom stating binary operation commutative idem assert idempotence binary operation 
asserting associative attribute assoc term formed assuming right sort grouping parentheses required 
expected tools systems rewriting may special assoc attribute generally advisable attribute stating property axiom applies attributes 
genericity specifications explicit parameters 
spec generic monoid sort elem sort monoid ops inj elem monoid monoid monoid monoid monoid assoc unit elem inj inj getting started example describes monoids built arbitrary elements sort elem 
intention reuse specification generic monoid derive specifications monoids built say characters symbols cases appropriate emphasize intended genericity specification making explicit distinguished parameter part sort elem piece specification intended vary derived specifications 
possible instantiate parameter part desired order specialize specification appropriate obtain specification monoids built characters 
named specification parameter called generic 
body generic specification generic monoid extension specified parameter part 
alternative generic specification generic monoid elegant nongeneric specification specialized instantiation spec non generic monoid sort elem sort monoid ops inj elem monoid monoid monoid monoid monoid assoc unit elem inj inj generic specification may parameter parameters arbitrary specifications named 
reused name generic specification instantiated 
generic specifications instantiate discussed detail chap 

generic specifications appropriate improves reusability specification definitions 
generic specifications instantiate parameters 
spec generic commutative monoid sort elem generic monoid sort elem monoid generic specification generic commutative monoid defined extension generic monoid instantiated explained 
instantiating generic specification done providing argument specification fits parameter part generic specification instantiated 
loose specifications quite frequent instantiation trivial argument specification identical parameter 
case example generic specification generic monoid instantiated providing argument specification sort elem original parameter 
spec generic commutative monoid sort elem generic monoid sort elem op monoid monoid monoid comm generic commutative monoid alternative version specification requiring explicitly axiom commutativity operation require attribute comm 
explained general better describe requirements attributes explicit axioms expected tools rely attributes specialized algorithms ac term rewriting 
example illustrates important feature casl name thing principle 
operation symbol declared twice profile generic monoid generic commutative monoid second declaration enriched attribute comm 
perfectly fine defines binary operation symbol corresponding profile name thing principle 
principle applies sorts operation predicate symbols 
applies symbols defined locally symbols imported extended specification case 
course apply separate named specifications symbol may different named specifications entirely different interpretations 
note operation predicate symbols name thing principle little subtle sorts name operation predicate includes profile argument result sorts operations defined symbol different profiles name symbol just overloaded 
overloaded symbol intended profile determined context sorts arguments symbol applied 
explicit disambiguation needed specifying profile result sort application 
note overloaded constants allowed casl empty may declared constant various sorts collections 
see discussion overloading presence subsorts chap 

instance depending context term disambiguated writing op monoid monoid monoid just monoid monoid monoid 
getting started datatype declarations may abbreviate declarations sorts constructors 
spec container sort elem type container empty insert elem container pred elem container elem container isin empty eisin insert eisin specifications datatypes constructors frequently needed 
casl provides special constructs datatype declarations abbreviate corresponding tedious declarations 
instance datatype declaration abbreviates type container empty insert elem container sort ops container empty container insert elem container container datatype declaration looks context free grammar variant bnf 
declares symbols left sorts alternative right declares constructor 
datatype declaration loose imply constraint values declared sorts may values sort container built declared constructors value may built different applications constructors arguments 
datatype declarations may specified generated see sect 
free see sect 

selectors usually partial operations may specified component see chap 

loose datatype declarations appropriate constructors may added extensions 
spec marking container sort elem container sort elem type container mark insert elem container generated specifications pred marked elem container elem container eisin mark insert eisin empty insert mark insert specification extends container trivially instantiated introducing constructor mark insert sort container values added container may marked 
note heavily rely name thing principle ensures sort container introduced datatype declaration container sort container introduced datatype declaration marking container sort implies combination datatype declarations equivalent type container empty insert elem container mark insert elem container note new values may constructed mark insert itis necessary extend specification predicate symbol extra axiom care newly introduced constructor 
generated specifications sorts may specified generated constructors 
spec generated container sort elem generated type container empty insert elem container pred elem container elem container isin empty eisin insert eisin datatype declared generated example corresponding sort constrained generated declared constructors means value sort built application constructors 
constraint referred junk principle 
instance example having declared datatype container generated entails model generated container getting started sort container term built empty insert sort elem 
consequence properties values sort container proved induction declared constructors 
major benefit generated datatypes induction declared constructors sound proof principle 
construct generated type just abbreviation generated type 
generated arbitrary signature declarations enclosed 
generated specifications general loose 
spec generated container merge sort elem generated container sort elem op merge container container container elem container eisin merge isin eisin generated specification general loose 
instance generated container loose values sort container specified generated empty insert behavior insert constructor loosely specified said case element inserted container contains element 
generated container admits non isomorphic models 
generated container merge loose generated container respect insert addition newly introduced operation symbol merge loosely specified said happens merging containers share elements 
important understand looseness specification problem contrary avoids unnecessary overspecification 
particular loose specifications general suited capturing requirements 
fact merge loosely specified mean produce new values sort container 
contrary sort specified generated empty insert follows value term form merge 
denoted term built empty insert merge 
specification generated container merge proofs induction container need consider empty insert case generated container 
generated specifications generated specifications need loose 
spec generated set sort elem generated type set empty insert elem set pred elem set ops elem set insert empty set set set remove elem set set elem set isin empty eisin insert eisin elem eisin isin eisin eisin remove eisin implies elem set insert insert insert insert insert insert insert generated type set empty elem set set op set set set assoc comm idem unit empty equal sets generated specifications general loose need illustrated generated set specification axiom equal sets combined axioms defining fully constrains isomorphism interpretations sort set constructors empty insert interpretation sort elem chosen 
note example displays power annotation implies 
remember annotation applies specification extension occurs applies explicit axioms insert properties corresponding attributes constraint 
implies annotation stress usual properties insert expected follow preceding declarations axioms alternative induction scheme empty sets 
asserts expected associative commutative idempotent empty unit 
note implies part heavily relies name meaning principle 
getting started generated types may need declared 
specification fragment illustrates may go wrong 
sort node generated type tree mktree node forest generated type forest empty add tree forest incorrect due linear visibility rule 
easily fixed replacing sort node sorts node tree forest 
corrected wrong corresponding semantics naive reader may expect 
may expect models carrier sets sorts tree forest generated mktree empty add acceptable models satisfy separate sort constraints 
instance model junk tree jt junk forest jf fulfills declarations assuming interpretations mktree add jt jf model jt mktree jf node jf add jt jf 
write sort node generated types tree mktree node forest forest empty add tree forest mutually recursive datatypes tree forest correctly defined simultaneously generated types construct resulting semantics expected junk values trees forests 
note linear visibility rule applicable generated types construct allow mutually recursive definitions exception linear visibility principle 
mutually recursive generated datatypes need declared simpler cases difference sequence successive generated datatype declarations just introducing desired datatypes 
free specifications free specifications provide initial semantics avoid need explicit negation 
spec natural free type nat suc nat explanations apply free datatypes introduced subsection 
free specifications free datatype declaration corresponds called junk confusion principle values sort nat denoted constructor terms built suc distinct constructor terms denote different values 
free datatype declaration exactly effect corresponding generated datatype declaration axioms stating suc injective successor natural number 
alternative free type nat suc nat generated type nat suc nat nat suc suc nat suc free datatype declarations particularly convenient defining enumerated datatypes 
spec color free type rgb red green blue free type cyan magenta yellow black free generated defining enumerated datatypes saves writing explicit distinctness assertions instance red green red blue 
free specifications constructors related axioms 
spec integer free type int suc int pre int int suc pre pre suc relations imposed constructors case suc pre inverses free datatype declaration contradiction confusion principle axioms imposed constructors lead inconsistent specification 
impose freeness constraint datatype declaration followed required axioms 
freeness getting started constraint expressed keyword free imposed specification 
case integer specification freeness constraint imposes semantics specification class algebras isomorphic quotient constructor terms minimal congruence induced axioms 
exactly desired semantics 
generally freeness constraint specification indicates initial model may exist course 
known initial models basic specifications axioms restricted horn clauses equations integer special case exist 
remember equality holds minimally initial models equational specifications 
predicates hold minimally models free specifications 
spec natural order natural free pred nat nat nat suc suc suc freeness constraint imposed predicate declaration followed defining axioms effect predicate holds follows axioms hold 
instance example necessary explicitly state follow imposed freeness constraint 
cases freeness constraint exactly effect called negation failure closed world assumption principles logic programming 
generally convenient define predicate freeness constraint doing specify positive cases 
operations predicates may safely defined induction constructors free datatype declaration 
spec natural arithmetic natural order strictly speaking existence initial models depends requirement existence ground term sort 
ensures non empty carriers casl model 
ops nat suc nat nat nat assoc comm unit nat nat nat assoc comm unit nat suc suc suc free specifications define operation free datatype generally recommended case distinction respect various constructors defined 
illustrated definitions operation case constructor taken care attribute unit 
care may needed defining operations predicates free datatypes axioms relating constructors 
spec integer arithmetic integer ops int suc int int int assoc comm unit int int int int int int assoc comm unit int suc suc pre pre suc pre pre suc suc pre case distinction respect constructors free datatype harmless may case datatype defined freeness constraint due axioms relating constructors cases may overlap 
mean case distinction just attention paid free datatype needs ensure definitions lead specification libraries ordinary decimal notation natural numbers provided called literal syntax annotations see chap 

getting started results overlapping cases 
instance example problem arises 
careful negative integer form suc asserting suc course wrong 
spec integer arithmetic order integer arithmetic preds int int int pre suc pre suc pre pre suc generic specifications involve free extensions loose parameters 
spec list sort elem free type list empty cons elem list parameter generic specification loose cope various expected instantiations 
hand frequent situation body generic specification free initial interpretation 
illustrated example want combine loose interpretation sort elem free interpretation lists 
example similar spirit 
spec set sort elem free type set empty insert elem set pred elem set elem set insert insert insert insert insert insert insert isin empty eisin insert eisin insert free specifications list example want loose interpretation sort elem free interpretation sets 
axioms required hold set constructors empty insert free datatype declaration freeness constraint 
note explained predicates hold minimally models free specifications example define predicate insert 
doing decreased comprehensibility specification reason preferred verbose axiomatization predicate 
note keyword write implication reverse order eisin insert equivalent eisin eisin insert example specifies transitive closure arbitrary binary relation sort elem provided parameter 
spec transitive closure sort elem pred elem elem free pred elem elem elem xry xr xr yr xr example crucial predicates hold minimally models free specifications property ensures define smallest transitive relation including requiring freeness constraint allow arbitrary transitive relations containing undesired relations eliminated merely specifying order axioms 
loose extensions free specifications avoid overspecification 
spec natural bound natural arithmetic op max size nat max size element set denoted constructor term form insert due axioms constraining constructor insert 
getting started example shows benefit mixing loose initial semantics 
assume stage want introduce bound sort nat fixing value value fixed refinement need existence bound 
provided specification natural bound initial interpretation sort nat defined free datatype declaration natural loose interpretation constant max size 
model natural bound provide fixed interpretation constant max size models captured natural bound sense loose 
loose extensions general appropriate avoid unnecessary overspecification 
spec set choose sort elem set sort elem op choose set elem set empty choose example shows benefit mixing initial loose semantics 
want extend sets defined free constraint set bya loosely specified operation choose 
stage property required choose provide element belonging set applied want specify precisely specific element chosen 
note model set choose provide function implementing specific choice strategy interpretations choose functions necessarily deterministic applied twice set argument return result 
datatypes observer operations predicates specified generated free 
spec set generated sort elem generated type set empty insert elem set pred elem set elem set isin empty eisin insert eisin elem purpose example disregard fact choose undefined empty set just leave case unspecified 
partial functions 
free specifications specification alternative specification set see 
set set generated define exactly class models 
specification relies freeness constraint set generated relies observer specify sets equal 
axiom set generated expresses directly sets having exactly elements equal values 
axiom axioms defining entail expected properties constructor insert see generated set 
note set generated predicate defined freeness constraint specify holds way implication 
freeness constraint may unavoidable define predicate illustrated transitive closure choice relying freeness constraint define datatype set generated datatype declaration observers unambiguously determine values interest largely matter convenience 
may argue set suitable prototyping tools term rewriting set generated suitable theorem proving tools 
def annotation useful indicate operations predicates uniquely defined 
spec set union sort elem set sort elem def ops set set set assoc comm idem unit empty remove elem set set elem set insert insert remove empty empty remove insert remove remove insert insert remove annotation def expresses set union definitional extension set model set uniquely extended model set union means operations introduced set union uniquely defined 
implies annotation def annotation impact semantics corresponding proof obligation generated discharged theorem proving tools 
def annotation especially useful stress specifier intention impose unique interpretation defined scope annotation interpretation part extended chosen 
getting started operations defined axioms involving observer operations inductively constructors 
spec set union sort elem set generated sort elem def ops set set set assoc comm idem unit empty remove elem set set elem set eisin isin eisin eisin remove eisin specification set union alternative set union defines exactly model class 
inductive definition style chosen operations set union inset union operations defined implicitly characterizing results observer 
note observer style prevent providing unique definition operations claimed def annotation 
similarly discussion respective merits set set generated choice inductive definition style observer definition style partly matter taste 
may argue observer definition style sense hint algorithmic computation defined operations inductive definition style mimics recursive definition functional programming language 
inductive definition style may suitable prototyping tools term rewriting observer definition style may suitable theorem proving tools 
sorts declared free specifications necessarily generated constructors 
spec unnatural free type suc op assoc comm unit suc suc peculiar example illustrates fact sort defined freeness constraint need generated constructors 
unnatural specification enclosed free 
construct specifies free specifications abelian groups generator suc integers free abelian group 
unique isomorphism model unnatural corresponds integers natural numbers may expect just consider axiom 
example points general datatypes defined freeness constraints difficult understand datatypes defined constraints 
reader aware specification unnatural uses proper order formula existential quantifier axioms 
specification unnatural provided explanatory purposes clearly writing similar specifications discouraged 
horn clauses axioms freeness constraint datatype generated constructors 
partial functions partial functions arise naturally 
partial functions arise number situations 
casl provides means declaration partial functions specification domains definition generally specification system properties involving partial functions 
aim chapter discuss illustrate handle partial functions casl specifications 
declaring partial functions partial functions declared differently total functions 
spec set partial choose sort elem generated set sort elem op choose set 
elem choose function sets naturally partial function expected undefined empty set 
casl partial function declared similarly total question mark arrow profile 
quite easy distinguish functions declared total ones declared partial 
function declared partial may happen total models specification 
instance specification set partial choose exclude models function symbol choose interpreted total function defined set values 
axioms bidoit mosses casl user manual lncs pp 

ifip international federation information processing partial functions specify domain definition partial function detailed chapter 
terms containing partial functions may undefined may fail denote value 
instance value term choose empty may undefined 
natural insisting choose empty denote arbitrary fixed element elem 
note variables range defined values variable denotes value contrast terms containing partial functions 
functions total ones propagate undefinedness 
term choose undefined value term insert choose undefined value insert total function 
predicates hold undefined arguments 
casl classical valued logic 
predicate symbol interpreted relation value argument term undefined application predicate term hold 
instance term choose undefined atomic formula choose hold 
equations hold terms undefined 
casl equations default strong means hold sides denote equal values sides simultaneously undefined 
instance consider equation insert choose insert choose empty insert choose empty note term choose empty formed correct term 
value may undefined 
avoid unnecessary simply write term undefined mean value 
obviously term variables may defined values variables undefined values 
declaring partial functions choose defined sides defined denote equal values due axioms insert undefined sides undefined strong equation holds trivially 
casl provides called existential equations explained chapter 
special care needed specifications involving partial functions 
partial functions intrinsically difficult understand specify total ones 
special care needed writing axioms specifications involving partial functions 
point axiom may imply definedness terms containing partial functions consequence functions total may specifier intended 
typical cases asserting choose axiom implies choose defined point predicates applied undefined term hold model satisfying choose function choose total defined 
asserting remove choose insert choose empty empty axiom implies choose defined term empty defined 
understand assume choose undefined set value equation hold value undefinedness choose implies undefinedness remove choose insert choose empty giving contradiction definedness empty 
equation term involving partial function pf term involving total functions may imply partial function pf defined 
asserting insert choose axiom implies choose defined variable denotes defined value 
case similar previous difference right hand side equation variable term involving total functions 
name thing principle subtle side effect regarding partial operations operation declared total operation partial operation profile argument sorts result sort interpreted total operation models specification 
partial functions specifying domains definition definedness term checked asserted 
spec set partial choose sort elem set partial choose sort elem def choose empty set def choose choose definedness assertion written def term special kind atomic formula holds value term defined 
instance example def choose empty explicitly asserts choose undefined applied empty 
note axiom say definedness choose applied values empty means choose may undefined values 
second axiom example asserts choose condition def choose avoid undesired definedness induced axioms explained previous section 
note axioms example replaced set empty choose conclude choose defined equal empty undefinedness choose empty 
domains definition partial functions specified exactly 
spec set partial choose sort elem set partial choose sort elem set def choose empty set def choose choose example domain definition partial function choose exactly specified axiom def choose empty 
specifying domains definition loosely specified domains definition may useful 
spec natural bound addition natural bound op 
nat nat 
nat nat def max size maxsize implies maxsize maxsize def cases useful loosely specify domain definition partial function illustrated example required defined arguments max size may defined larger natural numbers 
point loose specifications definition domains avoid unnecessary constraints models specification 
instance example exclude model interpreted total function coincide 
cases specifying exactly domains definition considered overspecification 
specifications expect exact specification domains definition loosely specified functions see choose set partial choose 
domains definition specified explicitly 
spec set partial choose sort elem set partial choose sort elem def choose empty set empty choose set partial choose specifies exactly domain definition choose implicitly reasoning needed conclude specification entails def choose empty 
example essential choose new name partial addition operation 
rightly declared total operation natural bound declaration op nat nat 
nat useless name thing principle lead models just total addition operation 
partial functions improve clarity specifications general advisable specify definition domains explicitly possible set partial choose easier understand set partial choose specifications define class models 
spec natural partial pre natural arithmetic op pre nat 
nat def pre nat pre suc example consider domain definition pre exactly specified explicit way axiom states exactly pre undefined second implies pre defined natural numbers form suc 
spec natural partial subtraction natural partial pre op nat nat 
nat nat suc pre specification perfect mathematical point view clearly explicit easy way infer defined 
methodological point view alternative version better 
spec natural partial subtraction natural partial pre op nat nat 
nat nat def suc pre examples clearly demonstrate explicit specification definition domains generally advisable methodological point view 
indicate recommendation applied strict way deciding specification explicit extent matter taste 
specifying domains definition partial functions minimally defined default free specifications 
spec list selectors sort elem list sort elem free ops head list 
elem tail list 
list elem list head cons tail cons example axioms imply head tail defined lists form cons 
freeness constraint requires functions minimally defined 
terms head empty empty equated term freeness constraint implies terms undefined functions head tail undefined empty 
situation similar fact predicates hold minimally models free specifications see chap 

spec list selectors sort elem list sort elem ops head list 
elem tail list 
list elem list def head empty def tail empty head cons tail cons specification list selectors alternative list selectors specifications define exactly class models 
list selectors clearly easier understand considered technically simpler involves freeness constraint 
operations head tail usually called selectors provides abbreviations specify selectors concise way see 
partial functions partial selectors constructors selectors specified concisely datatype declarations usually partial 
spec list selectors sort elem free type list empty cons head 
elem tail 
list free datatype declaration introduces addition constructors empty cons partial selectors head tail yielding respective arguments constructor cons 
free datatype declaration selectors exactly effect ordinary free datatype declaration free type list empty cons elem list operation declarations axioms list selectors list selectors list selectors define exactly class models 
example similar spirit 
spec natural suc pre free type nat suc pre 
nat selectors usually total constructor 
spec pair sorts elem elem free type pair pair elem second elem selectors usually partial operations alternative corresponding datatype declaration total generally case constructor example 
free datatype declaration entails particular axioms asserting second yield respective arguments constructor pair pair second pair 
constructors may partial 
spec part container sort elem generated type container empty insert elem container 
pred addable elem container vars elem container def insert addable existential equality pred elem container isin empty isin insert eisin addable intention example define reusable specification partial containers 
insert constructor specified partial operation defined condition element added container element added holds 
condition abstracted predicate addable far left unspecified 
instantiations part container specification adapted specific purposes extending axioms defining addable 
generated datatype declaration abbreviates usual declaration sort container constant constructor empty partial constructor insert elem container 
container 
entails corresponding constraint 
existential equality existential equality requires definedness terms equality 
spec natural partial subtraction natural partial subtraction nat wrong def def correct better abbreviated axiom existential equation equivalent def def holds terms defined denote value 
existential equality input 
note trivial strong equation form holds case existential equations 
instance trivial existential equation hold term may undefined 
general consequences undefinedness undesirable 
conditional equation form wrong may undefined equality undefined strong equation hold 
specification provides typical example situation wrong entail partial functions arbitrary values equal choose greater undefined 
avoid undesirable consequences undefinedness advisable existential equations strong equations premises conditional equations involving partial operations 
alternative add relevant definedness assertions explicitly equations premises 
subsorting subsorts useful casl specifications 
examples naturally involve subsorts 
casl provides means declaration sort subsort values subsort regarded special case sort 
aim chapter discuss illustrate handle subsorts casl specifications 
subsort declarations definitions subsort declarations directly express relationships carrier sets 
spec generic monoid sort elem sorts elem monoid ops monoid monoid monoid monoid assoc unit example declares sort elem subsort monoid symmetrically sort monoid supersort elem 
specification generic monoid quite similar specification generic monoid chap 
difference subsorting relation elem monoid explicit inj operation embed values sort elem values sort monoid 
bidoit mosses casl user manual lncs pp 

ifip international federation information processing subsorting contrast algebraic specification languages providing subsorting facilities subsorts casl interpreted arbitrary embeddings corresponding carrier sets 
example subsort declaration elem monoid induces implicit unnamed embedding carrier sort elem carrier sort monoid 
main difference generic monoid generic monoid embedding explicit named inj generic monoid implicit generic monoid 
note interpreting subsorting relations embeddings inclusions exclude models carrier subsort happens subset carrier supersort embedding proper inclusion 
embeddings just slightly general inclusions technically complex 
operations declared sort automatically inherited subsorts 
spec vehicle natural sorts car bicycle vehicle ops max speed vehicle nat weight vehicle nat engine capacity car nat example introduces sorts car bicycle vehicle declares car bicycle subsorts vehicle 
subsort declaration entails term subsort term supersort term sort car term sort vehicle apply operations max speed weight similarly term sort bicycle 
words single declaration max speed vehicle nat get effect having declared operations max speed car nat max speed bicycle nat 
obviously operations meaningful subsort defined appropriate level 
case operation engine capacity relevant cars defined appropriate profile exploiting subsort car 
strictly speaking just max speed operation signature vehicle 
difference kind inheritance described operations declared subsorts important writing symbol maps see chap 

subsort declarations definitions inheritance applies subsorts declared 
spec vehicle vehicle sorts boat vehicle order subsort operation supersort declared irrelevant 
vehicle introduce subsort boat vehicle consequence get effect having max speed weight available boats case cars bikes 
subsort membership checked asserted 
spec speed regulation vehicle ops speed limit vehicle nat car speed limit bike speed limit nat vehicle car speed limit car speed limit bicycle speed limit bike speed limit subsort membership assertion written term sort special kind atomic formula holds value term embedding value sort instance example car holds denotes vehicle embedding car value 
note input displayed 
datatype declarations involve subsort declarations 
sequence declarations sorts car bicycle boat type vehicle sort car sort bicycle sort boat equivalent declaration sorts car bicycle boat vehicle 
may values sort vehicle embedding value sort car bicycle 
intuitively datatype declaration just means vehicle contains union may disjoint car bicycle boat 
note subsorts datatype declaration declared 
subsorting sequence declarations sorts car bicycle boat generated type vehicle sort car sort bicycle sort boat restrictive constraint implies value supersort vehicle embedding value declared subsorts car bicycle boat 
intuitively datatype declaration means vehicle exactly union may disjoint car bicycle boat 
particular declaration prevents subsequent subsorts values new subsorts intended correspond values declared subsorts 
instance extend specification sorts plane vehicle values sort plane correspond car bicycle boat values presumably intending 
sequence declarations sorts car bicycle boat free type vehicle sort car sort bicycle sort boat entails constraint previous example freeness constraint requires common value subsorts vehicle 
intuitively declaration means vehicle exactly disjoint union car bicycle boat 
means particular common subsort car boat say sorts car boat impossible 
subsorts may arise classifications previously specified values values explicitly defined 
spec natural subsorts natural arithmetic pred nat nat suc suc sort nat sort prime nat nat subsort definition sort nat equivalent declaration subsort nat sorts nat assertion nat 
subsorts overloading main advantage defining subsort addition predicate may subsort declaring operations op times nat 
subsort definition prime illustrates necessary introduce define explicit predicate characterizing values subsort formula subsort definition restricted predicate applications 
fact unary predicate sort defined pred formula define sort sort membership assertions predicate applications avoiding predicate altogether 
example illustration subsort definitions 
declare subsort pos nat ensure values pos correspond non zero values nat 
alternative ways specifying sort pos considered section 
spec positive natural partial pre sort pos nat subsorts overloading may useful previously defined operations new subsorts introduced 
spec positive arithmetic positive ops pos suc nat pos pos pos pos pos nat pos nat pos pos positive subsort nat operations defined natural numbers suc arithmetic chap 
extended natural partial pre chap 
automatically inherited pos applied terms sort pos 
declarations operations applied terms sort pos yield results sort nat 
indicate results correspond values subsort pos necessary explicitly overload operations similar ones appropriate profiles 
subsorting aim lines operation declarations example 
operation declarations overload specify yields result sort pos soon arguments term sort pos 
quite important understand overloading declarations achieve desired effect axioms necessary 
fundamental rule models casl specifications subsorting embedding overloading compatible embeddings commute overloaded operations 
rephrased intuitive statement terms look value sort 
example value combination overloaded constant operation chosen need axiom ensure implicit semantics subsorting 
subsorts partiality subsort may correspond definition domain partial function 
spec positive pre positive arithmetic op pre pos nat introduced subsort pos non zero natural numbers sense overload partial pre operation nat total pos illustrated emphasize fact pre total operation definition domain 
note axiom necessary semantics subsorting ensure partial total pre operations give value applied non zero value 
subsorts may avoid need partial functions 
spec natural positive arithmetic free types nat sort pos pos suc pre nat confused name meaning principle apply total pre partial different profiles just overloaded 
subsorts partiality ops pos suc nat nat nat assoc comm unit nat nat nat assoc comm unit pos pos pos pos nat pos nat pos pos nat suc suc suc tempting exploit subsorting avoid declaration partial functions illustrated natural positive arithmetic specification alternative positive pre avoids partial predecessor operation 
note example fully facilities defining free datatypes subsorts particular non linear visibility declared sorts allows refer subsort pos line defining second 
avoiding partial predecessor operation drawbacks previously formed terms defined values ill formed pre pre suc pre suc wellformed term sort nat pre expects argument sort pos 
pre suc consequence specified axioms sort pos course entail pre suc sort pos axioms disregarded checking formedness 
see possible workarounds explicit casts 
possible easy avoid declaration partial operations appropriate subsorts just consider subtraction natural numbers 
issue reader aware fact overloading partial operation supersort say pre nat witha total subsort pre pos fine overloading total operation supersort partial subsort forces partial operation total better declared total 
casting term supersort subsort explicit value cast may undefined 
overloading total cons list partial cons subsort lead total cons operation inconsistent specification depending definition domain partial cons specified 
subsorting casl term subsort considered term supersort embeddings implicit 
contrary casting term supersort subsort explicit casting essentially partial operation resulting casted term may denote value 
casting term written 
consider term pre pre suc pos formed context natural positive arithmetic specification 
term denote value value positive natural number value term pre pre suc pos pos undefined 
note def ass formed term supersort may useful generalizing previously specified sorts 
spec integer arithmetic natural positive arithmetic free type int sort nat pos ops int int int assoc comm unit int int int int int int assoc comm unit abs int nat int nat pos suc suc suc abs abs specification integer arithmetic extends natural positive arithmetic defines sort int supersort sort nat 
asa consequence terms parses sort int depending embedding nat int applied arguments result overloaded operations required semantics subsorting value parses explicit disambiguation 
subsorts partiality situation quite different combination natural arithmetic integer arithmetic see chap 
say extending structured specification see chapter details structured specifications 
combination term suc parses sort nat sort int inthe absence subsort declaration relating nat int implicit embedding term ambiguous require explicit disambiguation formed term 
may extending intended values new values representing errors exceptions 
spec set error choose sort elem generated set sort elem sorts elem op choose set pred set set empty choose elem choose specification set error choose variant various specifications sets equipped partial choose function chap 

variant avoids declaration partial function choose target sort choose 
idea values embeddings values elem represent errors application choose empty set 
note obtain desired effect necessary explicitly state choose elem empty set term choose formed explicitly overload predicate elem set provided generated set predicate set shown 
example demonstrates avoiding partial functions error innocuous may general need enlarge signatures considerably adding required 
spec set error choose sort elem generated set sort elem sorts elem op choose set set empty choose elem specification set error choose attempt avoid partial functions introduce supersort subsorting set error choose avoid need overloading predicate explicitly cast term choose choose elem note value choose elem holds implies choose elem defined choose elem holds 
version may preferable previous 
aware despite attempt avoid partial functions rely explicit casts terms may denote values partiality eliminated partial functions merely factorized compositions total functions casting 
structuring specifications large complex specifications easily built simpler ones means small number specification building operations 
previous chapters focused attention basic specifications detailed various constructs casl write meaningful relatively simple specifications 
aim chapter discuss illustrate assemble simple pieces specifications complex structured ones 
particular explain extend specifications union specifications rename hide symbols assembling specifications 
parametrization instantiation generic specifications explained chapter 
union extension union extension structure specifications 
spec list set sort elem list selectors sort elem generated set sort elem op elements list set elem list elements empty empty elements cons elements bidoit mosses casl user manual lncs pp 

ifip international federation information processing structuring specifications example shows union expressed specifications list selectors see chap 
generated set see chap 
extend union operation axioms 
union extension commonly specification building operations 
contrast extension purpose extend piece specification new symbols axioms union generally combine self contained specifications 
union specifications obviously associative commutative 
symbols introduced specification default exported visible extensions unions specifications 
variables considered symbols exported 
remember name thing principle list set specification sort elem construct lists sets 
specifications may combine parts loose generated free interpretations 
spec list choose sort elem list selectors sort elem set partial choose sort elem ops elements list set choose list 
elem elem list elements empty empty elements cons elements def choose empty choose choose elements spec set list sort elem list set sort elem op list set list set elements list specification list choose built extension union list selectors set partial choose see chap 

extension introduces operation elements list set partial operation choose defined axioms 
list selectors lists defined free datatype construct selectors constant empty overloaded constant empty list lists constant empty set sets 
renaming free interpretation 
set partial choose extension set partial choose generated set defined generated datatype construct 
note discussed chap 
apparently loose specification generated set fact 
choose partial function sets loosely defined set partial choose choose partial function lists defined list choose 
easy see operation elements uniquely defined 
sort elem course loose interpretation 
specification list choose combines parts free interpretation parts generated interpretation parts loose interpretation 
situation similar list set set list operation list loosely defined help operation elements renaming renaming may avoid unintended name clashes adjust names sorts change notations operations predicates 
spec stack sort elem list selectors sort elem sort list stack ops cons push head top tail pop name thing principle proven appropriate numerous examples previous chapters may happen combining specifications principle leads unintended name clashes 
unintended name clash arises instance combines specifications export symbol profile case operation predicate symbol intended denote thing combination 
cases necessary explicitly rename symbols exported specifications put order avoid unintended name clashes 
reusing named specification may convenient rename symbols case operation predicate symbols may change style notation 
illustrated specification stack obtained renaming specification list selectors 
renaming introduced keyword 
sort list renamed stack operation cons renamed mixfix structuring specifications operation push selectors head tail renamed top pop respectively 
note input 
user needs indicate symbols provided renamed specification mapped new symbols 
signature morphism automatically deduced symbol map 
instance signature morphism inferred symbol map specified stack maps operation symbol cons elem list list operation symbol push elem stack stack operation name changed profile renaming list stack 
symbol map qualify symbol renamed kind keywords sort op plural forms appropriate illustrated stack 
qualification symbol maps generally recommended improves readability 
possible change syntax operation predicate symbol illustrated cons mapped push possible change order arguments renamed operation predicate 
general need rename symbols provided specification renamed 
symbol map describing intended renaming mention symbols change 
default symbol explicitly mentioned left unchanged profile may updated renaming specified sorts 
illustrated stack need rename constant empty name lists stacks 
induced signature morphism maps constant symbol empty list constant symbol empty stack 
explicitly rename symbol say writing empty empty just mention providing new name empty equivalent empty empty 
default overloaded symbols renamed simultaneously 
instance integer arithmetic plus overloaded infix operations exported integer arithmetic see chap 
renamed plus operations functional syntax appropriate profiles 
general possible specifically rename overloaded symbols specifying profile symbol map 
instance list set empty list nil constant empty sort list renamed nil constant empty sort set remains unchanged 
care needed presence subsorts signature morphism induced specified symbol map preserve overloading relations associated subsorts 
instance attempt rename specification integer arithmetic addition positive numbers plus write integer arithmetic pos pos pos plus merely obtain ill formed specification 
specification integer arithmetic overloaded operations renamed simultaneously overloaded symbols 
hiding combining specifications origins symbols indicated 
spec list set sort elem list selectors sort elem empty cons generated set sort elem empty op elements list set elem list elements empty empty elements cons elements explained empty cons means empty empty cons cons identity renaming just emphasize fact specification exports symbols 
illustrated specification list set quite similar list set fact emphasize list selectors exports particular operations empty cons set exports particular operations empty 
hiding auxiliary symbols structured specifications hidden 
spec natural partial subtraction natural partial subtraction hide suc pre spec natural partial subtraction natural partial subtraction reveal nat writing large specifications quite frequent rely auxiliary operations predicates specify operations predicates interest 
defined auxiliary operations longer needed better removed exported signature specification include symbols required specified 
purpose hide construct 
consider instance specification natural partial subtraction chap 

addition subtraction defined structuring specifications basic operations suc pre longer needed suc conveniently written similarly pre expressed hidden 
illustrated specification natural partial subtraction 
depending relative proportion symbols hidden cases may convenient explicitly list symbols exported specification hidden 
construct reveal purpose hide reveal symmetric constructs achieve effect 
reveal illustrated natural partial subtraction reader convince natural partial subtraction natural partial subtraction export exactly symbols 
case specification clearly concise 
convincing example reveal provided example 
spec partial order partial order reveal pred similar rules ones explained renaming apply hide reveal constructs 
qualify symbol hidden revealed kind sort op pred default overloaded symbols hidden revealed simultaneously 
note hiding sort entails hiding operations predicates profile 
similarly revealing operation predicate entails revealing sorts involved profile 
instance specification partial order revealing predicate entails revealing sort elem 
consequence hiding sorts care presence subsorts 
instance hiding sort nat specification positive chap 
leads specification positive natural numbers sort pos expected carrier set operation predicate available 
hiding sort nat specification positive arithmetic see chap 
may appropriate note predicate longer available positive arithmetic hide sort nat 
note convenient reveal combined renaming exported symbols 
instance partial order specification written reveal pred leq addition restriction signature partial order wanted rename infix predicate functional notation 
local specifications local specifications auxiliary symbols local need exported 
spec list order total order sort elem pred list selectors sort elem local op insert elem list list elem list insert empty cons empty insert cons cons insert cons cons op order list list elem list order empty empty order cons insert order cases auxiliary symbols introduced immediate need exported specification declared 
best limit scope declarations auxiliary symbols local construct 
illustrated specification list order operation introduced purpose axiomatization order 
declaration insert scope limited part follows insert exported specification list order 
generally advisable ensure auxiliary symbols declared local parts specifications 
spec list order sorted total order sort elem pred list selectors sort elem local pred sorted list elem list empty sorted cons empty sorted cons cons sorted cons sorted op order list list list order sorted specification list order sorted variant specification list order illustrating local structuring specifications construct time declare auxiliary predicate 
specifications equivalent list order sorted looser requires order sorted list elements 
care needed local sort declarations 
spec wrong list order sorted total order sort elem pred list selectors sort elem local pred sorted list sort list elem list empty sorted cons empty sorted cons cons sorted cons sorted op order list note specification wrong list order sorted may glance considered slight variant list order sorted ill formed order exported wrong list order sorted sorts occurring profile exported sort auxiliary 
specifier really intends insist result sort order subsort exported shown 
spec list order sorted total order sort elem pred list selectors sort elem local pred sorted list elem list empty sorted cons empty sorted cons cons sorted cons sorted sort list op order list fact local construct abbreviates combination extension explicit hiding 
specification list order sorted instance abbreviates spec list order sorted total order sort elem pred list selectors sort elem pred sorted list elem list empty sorted cons empty sorted cons cons sorted cons sorted sort list op order list hide sorted named specifications main advantage local 
construct hiding symbols introduced local part left implicit 
convenience generally outweighs danger overlooking locally declared sort needed profile exported symbol 
case casl allows styles users simply choose prefer 
named specifications naming specification allows reuse 
general advisable define named specifications felt appropriate improves reusability specifications named specification easily reused referring name 
names serve abbreviations writing specifications easy readers notice reuse 
name specification aptly chosen natural arithmetic able guess signature specified axioms name 
chap 
shall see named specifications items collected libraries particular versions available internet 
named specifications particularly convenient specifications structured unions extensions verbatim insertion unnamed specifications tend obscure structure 
needed signature referenced specification adjusted appropriate combinations renaming hiding necessary provided auxiliary symbols local explained previous section 
generic specifications making specification generic appropriate improves reusability 
mentioned previous chapter naming specifications idea 
cases datatypes naturally generic operations predicates deliberately left loosely specified determined datatype 
instance datatypes lists sets generic regarding sort elements 
generic specifications allow genericity datatype explicit declaring parameters specification named case lists sets single parameter simply declares sort elem 
fitting argument specification provided parameter generic specification referenced called instantiation generic specification 
aim chapter discuss illustrate define generic specifications instantiate 
seen plenty simple examples generic specifications instantiations previous chapters 
complicated cases explicit fitting symbol maps may required determine exact relationship parameters arguments instantiations called imports separated bodies generic specifications 
generic specifications useful ensure loose coupling named specifications replacing explicit extension parameter including necessary symbols required properties 
illustrated steam boiler control system case study see chap 

bidoit mosses casl user manual lncs pp 

ifip international federation information processing generic specifications parameters instantiation parameters arbitrary specifications 
specification named parameter generic specification 
commonly parameter trivial specification consisting merely single sort declaration examples previous chapters spec generic monoid sort elem see chap 
spec list selectors sort elem see chap 
parameter complex possibly structured specification spec list order total order sort elem pred see chap 
recall requires signature specification include listed symbols fact signature total order contain symbols symbols supplied instantiating list order 
argument specification instantiation provide symbols corresponding required parameter 
spec list order nat list order natural order correspondence symbols provided argument specification required parameter described fitting symbol map left implicit ambiguous case 
example argument specification natural order provides sort nat operation symbols suc binary predicate symbol 
specification provides symbols corresponding required parameter specification total order correspondence left implicit argument natural order single symbols right kind 
coincidence predicate symbol parameter argument irrelevant 
describe explicit fitting symbol maps omitted detailed section 
parameters instantiation argument specification instantiation ensure properties required parameter hold 
spec nat word generic monoid natural fitting signature morphism signature parameter part signature argument specification automatically deduced account explicitly specified fitting symbol map situation quite similar renaming signature morphism deduced symbol map 
instantiation defined models argument specification reduced induced fitting signature morphism provide models parameter part 
particular symbols provided argument specification properties specified parameter counterparts 
case get signature morphism fitting specification morphism argument specification parameter specification 
nat word example parameter generic monoid trivial obvious instantiation defined 
effect instantiation union argument specification non generic equivalent generic specification renamed induced fitting signature morphism 
particular side effect instantiation rename symbols generic specification fitting signature morphism induced instantiation 
nat word example operation symbol inj elem monoid renamed inj nat monoid operation symbols left unchanged sort monoid 
specification nat word abbreviates specification natural non generic monoid elem nat 
convenient instantiation completed renaming illustrated variant nat word 
spec nat word generic monoid natural monoid nat word case specification list order nat checking definedness instantiation corresponds non trivial proof obligation 
instantiation defined predicate order total ordering relation properties required note consistency entirely orthogonal definedness defined instantiation may consistent 
generic specifications total order fulfilled syntactic correspondence axioms total order natural order 
shared symbols argument specification body instantiated generic specification 
spec wrong generic monoid monoid intention example may specify monoids monoids 
instantiation ill formed sort monoid operation symbols shared body generic specification generic monoid argument specification monoid 
section provides useful hints structure generic specifications order avoid far possible undesirable clashes symbols instantiations 
correct specification monoids monoids provided sect 

instantiations fitting parameter symbols identical argument symbols left implicit 
spec generic commutative monoid sort elem generic monoid sort elem 
parameter argument symbols common parameter symbols implicitly taken fit directly corresponding argument symbols 
necessary explicit symbol mapped identically 
example instance parameter specification generic monoid exactly argument specification instantiation fitting left implicit 
fitting parameter sorts unique argument sorts left implicit 
argument specification single sort fitting parameter sorts sort obvious left implicit illustrated earlier nat word specification 
course apply way round parameter single sort parameters instantiation case practice argument specification sort parameter sort mapped argument sorts fitting symbol map explicit parameter sort identical argument sorts previously explained fitting sorts implied fitting symbols explained 
fitting operation predicate symbols left implicit imply fitting sorts 
spec list order positive list order positive fitting operation predicate symbols imply fitting sorts 
instance parameter predicate symbol fitted argument predicate symbol profile involves different sorts implies parameter sorts involved fitted corresponding sorts argument specification 
illustrated list order positive specification 
step fitting parameter sort elem argument sorts nat pos provided specification positive see chap 
may ambiguous 
explicit fitting symbols necessary argument specification provides binary predicate symbol fitting corresponding binary predicate symbol parameter specification entails fitting sort elem sort nat coincidence predicate symbol parameter argument irrelevant 
may clear exact rules fitting parameter argument symbols left implicit quite sophisticated 
best intended fitting explicit completely obvious notation fitting arguments illustrated examples 
intended fitting parameter symbols argument symbols may specified explicitly 
spec nat word generic monoid natural subsorts fit elem nat correspondence symbols required parameter provided argument specification explicit socalled fitting symbol maps 
instance nat word specification differs nat word regarding presence subsorts generic specifications nat obtained instantiation generic monoid fitting parameter part sort elem subsorts specification 
mapping parameter sort elem sort nat provided natural subsorts described fitting symbol map fit elem nat 
generic specification may parameter 
spec pair sort elem sort elem free type pair pair elem second elem parameters merely notational convenience equivalent union 
instance pair specification variant specification pair just parameter sorts elem elem defined chap 

note writing spec homogeneous pair sort elem sort elem free type pair pair elem second elem merely defines pairs values sort homogeneous pair equivalent better defined follows spec homogeneous pair sort elem free type pair pair elem second elem parameters homogeneous pair equivalent just sort elem parameter 
methodological point view generally advisable parameters convenient part specification intended specialized instantiation time better split logically coherent units corresponding parameter 
consider instance spec table sort key sort val 
parameters table emphasizes key val logically distinct entities specialized desired independently 
instantiation generic specifications parameters similar case just parameter 
spec pair natural color pair natural arithmetic color fit elem rgb parameters instantiation example parameter sort elem instantiated natural arithmetic exports sort nat explicit fitting symbol map necessary 
second parameter sort elem pair instantiated color case fitting symbol map provided color exports sorts rgb specification pair require write spec pair natural color pair natural arithmetic color fit elem nat elem rgb clearly demonstrates benefit parameters pair just pair 
parameters trivial ones just sort avoid explicit fitting maps 
consider instance alternative pair natural color spec pair natural color pair sort nat sort rgb natural arithmetic color may convenient argument specification exports sorts 
compare instance spec pair pos homogeneous pair sort pos integer arithmetic spec pair pos homogeneous pair integer arithmetic fit elem pos note instantiation homogeneous pair natural color fit elem rgb ill formed entails mapping sort elem nat rgb 
generally care needed parameters generic specification share symbols general advisable 
note easy specialize generic specification parameters partial instantiation version table spec table sort val table natural arithmetic sort val parameter values stored decided keys natural numbers 
generic specifications composition generic specifications expressed instantiation 
spec set list sort elem generated set list selectors sort elem fit elem list list describes sets lists arbitrary elements obtained instantiation generic specification generated set parameter sort elem instantiated specification list selectors trivially instantiated 
trivially instantiated specification list selectors exports sorts elem list course necessary specify instantiation generated set fitting symbol map parameter sort elem argument sort list 
note especially specification spec mistake sort elem generated set list selectors sort elem provide sets lists elements sort elem parameter generated set mapped identity fitting symbol map sort elem provided instantiation generic specification list selectors sort elem sort list 
mistake just provides sets arbitrary elements lists arbitrary elements 
desired effect write spec set list sort elem generated set sort elem list selectors sort elem illustrated set list composition generic specifications fairly easy casl 
note composition achieved means appropriate instantiations possibly trivial casl provide higher order genericity 
may worth mentioning composition generic specifications ill formed spec wrong generic monoid generic monoid sort elem fit elem monoid situation different parameter generated set sort val absence explicit fitting symbol map led ambiguity case specifier specify sort val mapped elem list 
compound symbols instantiation ill formed sort monoid operation symbols shared body generic specification generic monoid argument specification generic monoid sort elem time generic specification generic monoid trivially instantiated 
section provides correct specification monoids monoids 
compound symbols compound sorts introduced generic specification get automatically renamed instantiation avoids name clashes 
spec list rev sort elem free type list elem empty cons head 
elem tail 
list elem ops list elem list elem list elem assoc unit empty reverse list elem list elem elem list elem cons cons reverse empty empty reverse cons reverse cons empty spec list rev nat list rev natural compound sort sort form name name 
specification list rev introduce compound sort list elem lists arbitrary elements simple sort list previous examples 
specification list rev instantiated list rev nat translation induced implicit fitting symbol map applied component elem occurs list elem providing sort list nat 
compound sorts seen convenient way implicitly completing instantiation appropriate renaming compound sorts introduced generic specification 
spec lists list rev natural provides sort list nat list rev color fit elem rgb provides sort list rgb elem proves particularly useful example lists union distinct instantiations generic specifications list rev ordinary sort list unintentional name clash arisen complete instantiation explicit renaming sort list 
note specification lists nat list rgb overloaded constants empty sort may need disambiguation terms 
disambiguate terms explained chap 

similarly overloaded operation symbols cons head tail reverse general context terms disambiguate meant 
spec lists list rev integer arithmetic fit elem nat list rev integer arithmetic fit elem int specification integer arithmetic provides sorts nat pos explicit fitting symbol map needed instantiations provide sorts list nat int 
note subsorting relation nat int entail list nat list int course added desired extension subsorting declaration 
compound sorts easily specify monoids monoids 
spec monoid sort elem sort monoid elem ops inj elem monoid elem monoid elem monoid elem monoid elem monoid elem assoc unit elem inj inj spec monoid monoid sort elem monoid monoid sort elem fit elem monoid elem instantiation monoid monoid correct compound sort monoid elem ensures clash symbols body instantiated generic specification argument specification 
specification lists inconsistent due name thing principle fact list defined free type construct 
compound symbols compound symbols operations predicates 
spec list rev order total order list rev sort elem local op insert elem list elem list elem elem list elem insert empty cons empty insert cons cons insert cons cons op order list elem list elem elem list elem order empty empty order cons insert order spec list rev orders list rev order integer arithmetic order fit elem int provides sort list int operation order list rev order integer arithmetic order fit elem int provides sort list int operation order implies list int order reverse order example illustrates compound identifiers operation symbols rules apply predicate symbols 
cases compound identifiers sorts sufficient situations convenient operation predicate symbols done order 
list rev order instantiated sort list elem get renamed list int operation symbol order fitting symbol map corresponding instantiation 
compound identifier order operation unintentional name clash arisen 
note hand rely name thing principle ensure sorts list int provided instantiations want example 
course bother compound identifier insert operation symbol 
operation local exported list rev order source unintentional name clashes instantiations 
generic specifications generic specifications imports parameters distinguished fixed specifications intended instantiated 
spec list weighted elem sort elem op weight elem nat natural arithmetic list rev sort elem op weight list elem nat elem list elem weight empty weight cons weight weight example specialize lists arbitrary elements lists elements equipped weight operation overloaded weight operation lists 
specify generic specification list weighted elem parameter specification extending specification natural arithmetic sort elem symbol weight 
intention emphasize fact sort elem operation weight intended specialized specification list weighted elem instantiated fixed part natural arithmetic 
specifications listed keyword called imports 
written spec list weighted elem natural arithmetic sort elem op weight elem nat correct misses essential distinction part intended specialized part fixed definition parameter part specialized 
note omitting natural arithmetic clause declaration spec list weighted elem sort elem op weight elem nat ill formed sort nat available 
summarize construct useful distinguish true parameter part fixed 
parameter body generic specification extend provided imports specifications listed keyword exported symbols available 
generic specifications imports argument specifications implicitly regarded extension imports 
spec list weighted pair natural color list weighted elem pair natural color fit elem pair weight instantiation specified list weighted pair natural color correct fitting symbol map identity symbols exported fixed part natural arithmetic happens included argument specification pair natural color 
generally argument specification regarded extension imports fitting symbol map identity symbols provided imports 
illustrated example spec list weighted instantiated list weighted elem sort value op weight value nat rely trivial instantiation purpose merely illustrate point fitting symbol map omitted ambiguity arises argument specification sort value op weight value nat formed regarded extension imports list weighted elem extension natural arithmetic implies sort nat available 
imports useful prevent ill formed instantiations 
spec list length sort elem natural arithmetic list rev sort elem op length list elem nat elem list elem length empty length cons length implies list elem length reverse length specification list length needs sort nat usual arithmetic operations provided natural arithmetic specify length operation 
case clear imports trivial parameter list length 
reason specify natural arithmetic import instantiations list length similar formed 
generic specifications spec list length natural list length natural arithmetic understand point consider variant list length spec wrong list length sort elem natural arithmetic list rev sort elem specification wrong list length fine long need instantiate natural arithmetic argument specification 
instantiation wrong list length natural arithmetic ill formed symbols argument specification shared symbols body occurring parameter instantiated generic specification wrong explained 
course problem occur argument specification provides sort nat 
generic specifications auxiliary required specifications imported extended 
illustrated examples remember essential point 
instantiation ill formed soon shared symbols argument specification body generic specification designing generic specification generally advisable turn auxiliary required specifications natural arithmetic list length imports generic specifications form sp better written sp allow instantiation sp 
views views named fitting maps defined specifications 
view integer total order total order integer arithmetic order elem int view integer reverse total order total order integer arithmetic order elem int views spec list rev orders list rev order view integer total order list rev order view integer reverse total order implies list int order reverse order view convenient way name specification morphism induced symbol map parameter specification argument specification 
rules regarding omission evident symbol maps explicit apply views 
view proves particularly useful instantiation fitting symbol map intended times naming specification morphism reuse easier 
view defined integer total order referenced instantiations list rev order view integer total order keyword view clear argument merely named specification implicit fitting map written differently 
view defined symbol map induces specification morphism models target specification reduced signature morphism induced symbol map provide models source specification may convenient views just explicitly document existence specification morphisms intended instantiation 
instance view integer total order seen assertion integer arithmetic order specifies total ordering relation sense instantiations 
views generic 
view list monoid sort elem monoid list rev sort elem monoid list elem empty view generic defined parameters illustrated list monoid view possibly imports 
reader aware generic view target specification trivially instantiated specification list rev interpreted body generic specification parameters generic specifications imports view 
source specification contrary interpreted exactly provided 
example illustrates view proof obligation asserting lists equipped operation form monoid 
specifying architecture implementations architectural specifications impose structure implementations specification building operations structure text specifications 
explained previous chapters specification complex system may fairly large structured coherent easy grasp pieces 
casl provides number specification building operations achieve detailed chap 

generic specifications described chap 
provide pieces specification easy reuse different contexts adapted desired instantiating 
specification building operations generic specifications useful structure text specification system consideration 
models structured specification structure flat unstructured specification 
examples previous chapters structured differently meaning models 
structured specifications usually adequate requirements stage focus expected properties system consideration 
contrast aim architectural specifications prescribe intended architecture implementation system 
architectural specifications provide means specifying various components system built describing components assembled provide implementation system interest 
time allow task implementing system split independent clearly specified sub tasks 
architectural specifications essential design stage focus factor implementation system components 
aim chapter discuss illustrate role architectural specifications express casl 
bidoit mosses casl user manual lncs pp 

ifip international federation information processing specifying architecture implementations idea underlying architectural specifications eventually process systematic development modular software specifications components implemented software modules chosen programming language 
step scope specification formalisms casl chapter identify components models functions models models case generic components 
modular structure software development described architectural specification captured simply explicit structural way build casl models 
examples chapter artificially simple 
architectural specifications generally component oriented approaches intended relatively large systems 
chapter rely simple small examples illustrate explain casl architectural specification concepts constructs 
reading chapter reader encouraged study chap 
provides realistic examples architectural specifications 
detailed account rationale architectural specifications context formal software development stepwise refinement 
structured specifications referred chapter illustrating casl architectural specifications spec color defined chap 
spec natural order defined chap 
spec natural arithmetic defined chap 
spec elem sort elem spec cont elem generated type cont elem empty insert elem cont elem preds empty cont elem elem cont elem ops choose cont elem 
elem delete elem cont elem cont elem elem cont elem empty empty insert empty eisin empty eisin insert eisin def choose def choose choose eisin delete isin architectural specifications spec cont diff elem cont elem op diff cont elem cont elem cont elem elem cont elem eisin diff isin isin spec req cont diff natural order spec flat req free type nat suc nat pred nat nat generated type cont nat empty insert nat cont nat preds empty cont nat ops nat cont nat choose cont nat 
nat delete nat cont nat cont nat diff cont nat cont nat cont nat nat cont nat suc suc suc empty empty insert empty eisin empty eisin insert eisin def choose def choose choose eisin delete isin eisin diff isin isin architectural specifications assume req describes requirements system implemented 
note req flat req models illustrates point fact casl specification building operations merely facilities structure text specifications coherent units 
specifying architecture implementations architectural specification consists list unit declarations specifying required components result part indicating combined 
arch spec system units natural order cont natural order cont diff natural order result system architectural specification intended prescribe specific architecture implementing system specified req 
part introduced keyword units indicates require implementation system components second part introduced keyword result indicates component provides desired implementation 
component provided specification 
line natural order declares component specified natural order means simply model natural order 
line cont natural order declares component previously declared component provides model cont natural order 
essential understand component expand assumed component model cont natural order means reduced signature natural order equal property reflects fact software module supposed exactly supplied altering 
similarly line cont diff natural order declares component component expands model cont diff natural order 
final result simply 
complex examples result expressions illustrated examples 
rest casl visibility linear architectural specifications meaning component declared component declared referred inthe declaration component architectural specification system 
architectural specifications component names andd system architectural specification declared visible outside 
distinct architectural choices requirements specification 
arch spec system units natural order cd cont diff natural order result cd architectural specifications system system provide models req 
insists implementation components insists implementation components 
architectural specification system corresponds different architectural choice implementing req specification 
course design implementing component cd system may lead splitting implementation task exactly system 
possibilities including instance architectural design split task implementing cd different tasks implementing containers operations including diff delete implementing delete means diff operations 
unit declaration listed architectural specification corresponds separate implementation task 
instance architectural specification system task providing component expanding implementing cont diff natural order independent tasks providing implementations natural order cont natural order providing component assumption component implemented expressly ensured specification 
understand consider requirements specification req variant flat req 
models containers implemented sorted lists increasing order repetitions model choose implement diff algorithm specifying architecture implementations diff nil nil nil insert head diff tail head head diff tail tail head head diff tail model rely knowledge implementation containers decide implement diff fine simultaneously implemented component 
contrast architectural specification system request containers implemented component diff provided separate component imposing component developed independently component means longer possible implement diff sketched specific implementation choice may compatible independently chosen realization containers may implemented bags instance 
implementation diff component rely operations provided choose delete may turn efficient particular realization compatible independently chosen realization bags instance 
case architectural specification system containers diff operation implemented component cd course decide implement containers ordered lists repetitions diff sketched 
component expand implementation cont natural order provide implementation cont diff natural order tantamount providing generic implementation cont diff natural order takes particular implementation cont natural order parameter expanded 
obtain simply applying genericity arises independence developments desire build multiple implementations cont diff natural order different implementations cont natural order 
reflected fact left implicit architectural specification system 
unit implemented specification conservative extension specifications units 
instance component exist specification cont diff natural order conservative extension cont natural order model specification expanded model case 
similarly component exist cont natural order conservative extension natural order 
architectural specifications consider variant cont diff natural order associated variant architectural specification system 
spec cont diff cont natural order op diff cont nat cont nat cont nat nat cont nat diff empty diff empty empty diff insert insert insert diff insert diff diff insert diff isin isin arch spec inconsistent units natural order cont natural order cont diff result specification cont diff consistent models instance sorted lists increasing order repetitions conservative extension cont natural order instance model cont natural order containers realized arbitrary lists possibly repetitions expanded model cont diff case axioms contradictory 
consequence architectural specification inconsistent specification component inconsistent component expand implementations cont natural order diff 
architectural specification inconsistent inconsistent 
summarize architectural specifications prescribe intended architecture implementation system ensure specified components developed independently imposes certain degree genericity components 
specifying architecture implementations generic components genericity components explicit architectural specifications 
arch spec system units natural order natural order cont natural order cont natural order cont diff natural order result architectural specification system variant system choose specify second third components explicit generic components 
line natural order cont natural order declares generic component component implementing model natural order expand implementation cont natural order 
models generic component specification natural order cont natural order functions map model natural order model cont natural order 
functions required persistent meaning result model expands argument model 
third component specified generic component implementation cont natural order expand implementation cont diff natural order 
system obtained composition applications described result part 
casl combinations components called unit terms 
complex examples unit terms illustrated examples 
component system corresponds application system similarly component system corresponds system models specification form sp sp generic components gc expand argument model target specification 
sense long signature target specification contains signature sp 
sp considered implicit extension sp sp abbreviates sp sp sp 
generic component gc sp defined extension sp case instance cont diff natural order sp equivalent sp sp generic components expand model sp specification sp sp consistent models specification sp sp conservative extension sp 
forgetting fact potential source inconsistent specifications generic components architectural specifications 
instance specification cont natural order cont diff inconsistent reasons explained previous section 
generic component may applied argument richer required specification 
arch spec system units na natural arithmetic natural order cont natural order cont natural order cont diff natural order result na architectural specification system variant system require component na implementing specification natural arithmetic component implementing natural order system know component available collection previously implemented components 
generic component requires component fulfilling specification natural order course applied richer argument na 
similar reasoning applies generally generic component applied component unit term reduced morphism argument required type model required specification 
necessary fitting symbol map describe correspondence symbols provided argument expected generic component 
detail technicalities related fitting symbol maps quite similar instantiations generic specifications notations 
note similarly happens instantiating generic specification argument specification generic component applied argument richer required extra symbols kept result 
result architectural specification system contains interpretations arithmetic ordering operations natural numbers provided component na 
means particular implementations described system larger signature ones described system specifying architecture implementations specifications components named reuse 
unit spec cont comp elem cont elem unit spec diff comp cont elem cont diff elem arch spec system units natural order cont comp diff comp result example give name cont comp specification generic components elem cont elem 
similarly give name diff comp specification cont elem cont diff elem 
named specifications reused architectural specification system similar architectural specification system architectural specification system fact generic component applied richer arguments models elem similarly 
elem general models natural order potentially fewer possibilities implementing generic component specified cont comp compatible model elem implementing generic component specified natural order cont natural order needs compatible models natural order similar argument holds diff comp 
consequence architectural specifications system system describe implementations requirements specification req 
named unnamed specifications specify components 
unit spec diff comp cont elem op diff cont elem cont elem cont elem elem cont elem eisin diff isin isin far named structured specifications specify components 
unnamed specifications illustrated variant diff comp diff comp 
sake example directly specify diff operation referring generic components named specification cont diff 
remember specification generic component form sp sp sp considered implicit extension sp explains example formed 
specifications generic components confused generic specifications 
generic specifications naturally give rise specifications generic components named reuse illustrated cont comp 
reader confuse generic specification piece specification easily adapted instantiation corresponding specification generic component instantiated specified generic component gets applied suitable components 
conservative extensions form spec sp sp sp naturally give rise specifications generic components form sp sp illustrated diff comp 
generic component may applied architectural specification 
arch spec system units natural order color cont comp result fit elem rgb architectural specification requires component specified natural order component specified color generic component specified cont comp 
described result part desired system obtained applying applying case explicit fitting symbol map necessary color exports sorts rgb 
application results combined expressed 
apart free specification building operations structured specifications natural counterparts level components expressed keywords 
reader remember specification building operations specifications defining classes situation bit different specification extensions lead specifications generic components explained specifications components expanding component illustrated previous section 
specifying architecture implementations models union specifications denoted architectural specifications individual models corresponding components case system combine components andf fit elem rgb 
renaming hiding natural counterparts level components 
instance remember implementations described system larger signature implementations described system easy modify result part system really want implementations signature implementations described system just hide extra symbols resulting component na follows result na hide result na hide symbol maps renaming hiding level components follow rules symbol maps renaming hiding level structured specifications see chap 

applications generic component different applications generic components similar specifications 
arch spec system units natural order color fn natural order cont natural order fc color cont color fit elem rgb result fn fc architectural specification system variant system 
system insist choosing implementation containers generic component apply twice component implementing natural order implementing color 
contrast system may choose different implementations containers containers natural numbers component fn containers colors component fc architectural specifications system system similar clearly different 
better corresponds different architectural decision selecting matter architectural design 
components widely reusable tend efficient implementations general 
generic components fact rgb values exploited fc give space efficient representation containers possible fn generic components may argument 
unit spec set comp elem generated set elem spec cont set elem cont elem generated set elem op elements cont elem set elem cont elem elements empty empty elements insert elements arch spec arch cont set nat units natural order cont comp set comp cont elem generated set elem cont set elem result architectural specification arch cont set nat requires component implementing natural order generic component implementing cont comp containers generic component implementing set comp sets 
requires generic component pair compatible models cont elem andy generated set elem expands model cont set elem 
models said compatible share common interpretation symbols common 
symbol common sort elem compatibility condition means carrier set elem 
compatibility natural condition obviously necessary common interpretation common symbols expanded complex component 
result produced applying pair obtained applying pair arguments ands obviously compatible common symbols sort nat equipped operations suc component provides interpretation expanded modified compatibility guaranteed 
specifying architecture implementations open systems described architectural specifications generic unit expressions result part 
arch spec arch cont set units cont comp set comp cont elem generated set elem cont set elem result elem arch spec arch cont set units natural order csf arch spec arch cont set result csf far example architectural specifications described closed stand systems components necessary build desired system declared architectural specification interest 
casl itis possible describe open systems systems components require components provide closed system 
illustrated architectural specification arch cont set describes system generic component implementing containers generic component implementing sets generic component expands provide implementation operation elements result part generic structured component open system component implementing elem provides system built applying pair applications casl input lambda 
illustrated arch cont set describe closed system component implementing natural order open system csf specified arch cont set applied result part 
writing meaningful architectural specifications previous sections pointed potential sources inconsistent specifications components 
issue deserves attention designing architectural specification compatibility components generally unit terms combined fitting generic component multiple arguments 
writing meaningful architectural specifications components combined best check shared symbol originates non generic component 
arch spec arch cont set nat units natural order cont comp set comp cont elem generated set elem cont set elem result fit cont elem cont nat architectural specification arch cont set nat variant arch cont set nat declaring generic component arguments declare generic component single argument model specification cont elem generated set elem obtained union trivially instantiated specifications containers sets 
consequence obtain desired system result part apply generic component combination denoted applied applied combination sense share interpretation common symbols 
common symbols sort nat equipped operations suc come component provides interpretation expanded modified compatibility guaranteed 
clear analogy application generic component multiple arguments arch cont set nat combination ands cont set nat cases result meaningful trace shared symbols sort nat operations suc single component introducing 
emphasize compatibility natural requirement unit declaration corresponds separate implementation task unit subterm independently developed subsystem obviously combination components unit terms sense compatibility conditions fulfilled 
consider example compatibility condition violated 
application generic component need explicit fitting symbol map sort cont elem ambiguously mapped cont nat 
specifying architecture implementations arch spec wrong arch spec units cn cont natural order sn generated set natural order cont elem generated set elem cont set elem result cn sn architectural specification wrong arch spec variant arch cont set nat requiring component implementing natural order generic components implementing containers sets respectively just require component cn implementing containers natural numbers component sn implementing sets natural numbers 
application cn sn sense way ensure common symbols cn sn interpretation 
may case natural numbers interpreted way cn different way sn application impossible 
similar problem arise combination components cn sn 
consider complex example 
arch spec badly structured arch spec units natural order natural order natural arithmetic cont comp set comp cont elem generated set elem cont set elem result architectural specification badly structured arch spec variant arch cont set nat addition component implementing natural order require generic component expand implementation natural arithmetic 
specification arch cont set nat compatibility condition application easy discharge 
result unit term badly structured arch spec apply pair 
case semantic analysis ensure arguments compatible common symbols traced non generic component applications generic component similar arguments 
arguments just general checking require non trivial semantic reasoning 
advisable unit terms compatibility checked simple static analysis 
casl provides additional constructs easy follow recommendation explained 
writing meaningful architectural specifications auxiliary unit definitions local unit definitions may avoid repetition generic unit applications 
arch spec structured arch spec units natural order natural order natural arithmetic cont comp set comp cont elem generated set elem cont set elem result arch spec structured arch spec units natural order natural order natural arithmetic cont comp set comp cont elem generated set elem cont set elem result local problem illustrated badly structured arch spec fixed easily 
auxiliary unit definition may avoid repetition generic unit applications structured arch spec 
alternative definition local result unit term illustrated structured arch spec 
cases common symbols traced non generic unit compatibility checked easy static analysis 
libraries libraries named collections named specifications 
foregoing chapters seen examples named specifications specifications 
chapter explains collection named specifications named library 
creation libraries facilitates reuse specifications 
practical applications important able reuse existing specifications basic datatypes described chap 

local libraries self contained 
library called local self contained specification name library library includes specification name 
local libraries appear sight need provide poor support reuse specifications 
problem specification local library reused repeated verbatim 
formal link original specification copy despite having name names library chosen freely different libraries name completely different specifications 
distributed libraries support reuse 
distributed libraries allow duplication specifications avoided altogether 
making explicit copy named specification bidoit mosses casl user manual lncs pp 

ifip international federation information processing libraries library second library merely indicates specification concerned downloaded 
different versions library distinguished hierarchical version numbers 
practice specifications evolve provide operations predicates specified sorts define new subsorts 
libraries containing specifications evolve adding removing named specifications 
form version control change library cause specifications libraries ill formed affect meanings 
casl allows different versions library coexist distinguishing hierarchical version numbers allows library indicate particular version library required 
creation new libraries essential connection larger specification projects projects scale benefit reuse specifications existing libraries 
rest chapter illustrates constructs specify local libraries distributed libraries versions gives advice organization libraries 
local libraries local libraries self contained collections specifications 
library examples spec natural 
spec natural order natural 
collection illustrative examples foregoing chapters self contained local library named user manual examples outlined 
provide separate local library chapter involve considerable amount duplication specifications defined earlier chapters referenced chapters set partial choose chap 
local libraries generated set defined chap 

distributed libraries explained sect 
duplication avoided 
name thing principle casl applies specifications possible library include alternative specifications symbols different sets axioms 
alternative specifications extended indirectly specification principle apply unintended name clashes arise 
general advisable developers library respect name thing principle choosing symbols library 
case obviously helpful browse library 
alternative specifications symbols separate libraries 
specifications refer previous items library 
library examples spec strict partial order 
spec total order strict partial order 
spec partial order strict partial order 
may regard libraries sets named specifications sequences order specifications occur significant 
specification names linear visibility specification refer names specifications precede 
series extensions bottom fashion starting specification entirely self contained containing specifications 
specification name library unique defining occurrence overriding arise 
extensions refer may order partial order just total order 
linear visibility specification names means mutual recursion specifications prohibited 
specifications symbols declared declarations symbols duplicated moved preceding specification referenced 
distributed library chapter part ii available cofi web pages copies provided cd rom accompanying book 
intended comprehensive examples library general remove illustrative alternative specifications 
libraries kinds named specifications included libraries 
library examples spec strict partial order 
spec generic monoid sort elem 
view integer total order 
view list monoid sort elem 
arch spec system 
unit spec cont comp 
items libraries kind named specification illustrated simple named specifications generic specifications named view definitions generic view definitions architectural unit specifications 
shall henceforth refer generally library items 
libraries include anonymous specifications declarations sorts operations 
symbols declared library item automatically available subsequent items explicit name library item required import item 
technically library item said closed interpreted pre declared symbols 
facilitates downloading items distributed libraries see sect 

display parsing literal syntax annotations apply entire libraries 
library examples 
display latex display latex display union latex prec left assoc spec strict partial order 
local libraries spec partial order strict partial order 
spec generated set sort elem 
spec integer arithmetic order 
annotations affecting way terms written displayed apply entire library collected library 
annotations include display precedence annotations illustrated 
recall various reserved words symbols casl specifications input ascii displayed mathematical signs universal quantification input forall displayed sign available current display format 
display annotations provide analogous flexibility declared symbols 
example display annotations illustrated determine infix symbols input union latex format specification 
note display annotation applies occurrences input symbol library regardless overloading 
display annotations give alternative displays different formats apart latex rtf html presently supported 
display annotation shows input syntax symbol result produced current formatter 
input form annotations follows display union html sup sup latex cup display annotation particular format input format displayed 
symbol displayed latex version user manual displayed union annotation extended rtf part 
parsing annotations allow omission grouping parentheses terms input 
single annotation indicate relative precedence associativity left right group operation symbols 
precedence annotation infix arithmetic operations prec allows term input displayed left associativity annotation left assoc allows input similarly parentheses omitted included left associativity annotation 
libraries operation symbol declared associativity attribute assoc associativity annotation symbol provided automatically 
practice explicit associativity annotations needed nonassociative operations subtraction division 
libraries library items author date annotations 
library examples authors michel bidoit bidoit lsv ens cachan fr peter mosses brics dk dates oct apr spec strict partial order 
authors michel bidoit bidoit lsv ens cachan fr dates july spec integer arithmetic order 
author annotation library indicates collective authorship entire library preceding individual library item indicates specific authorship 
date annotation library indicate release date current version library 
may give release dates previous major versions possibly including original version 
date annotation individual library item indicate item changed optionally dates previous changes 
distributed libraries libraries installed internet remote access 
library basic numbers 
left assoc number floating prec implicit parsing annotation local enclosing specification specifications contrast ordinary parsing annotations 
distributed libraries spec nat free type nat suc nat ops nat suc nat suc 
nat nat suc spec int nat spec rat int spec rat ops nat nat rat 
rat int rat example extract casl libraries basic datatypes described chap 
available internet 
illustrates structure library intended general helpful annotations concerning literal syntax numbers explained 
validated libraries registered public access 
cofi maintain register useful libraries 
registered casl libraries identified hierarchical path names 
instance casl libraries basic datatypes names starting basic path names starting casl reserved libraries connected casl language specification syntax casl casl 
registered libraries mirrored sites ensure continuous accessibility 
urls library obtained library name table provided cofi web pages 
libraries validated registration 
validation library ensures formed semantic annotations expressing consistency specifications conservativity parameters case generic unit specifications added proof obligations corresponding formedness conditions semantic annotations library verified 
new versions existing libraries produced providing operations usefulness realized 
assignment library version numbers allows users protect specifications changes due new versions see sect 
names registered library change versions 
libraries libraries include appropriate annotations 
particular parsing display annotations provided explained sect 

example illustrates kind annotation provide literal syntax numbers casl 
effect illustrated annotations downloading appropriate specifications library basic numbers conventional decimal notation integers decimal fractions digits interpreted term interpreted term subsequently interpreted 
definition operation shown bit involved omitted 
notice library basic numbers hard wired casl users provide annotations interpret literal syntax integers decimal fractions terms involving different operations different sorts 
libraries include items downloaded libraries 
library basic basic numbers get nat int spec list sort elem nat 
spec array int 
individual specifications items downloaded libraries 
example library basic outlined provide specifications natural numbers integers needed specifications list array downloads nat int basic numbers library 
names items downloaded library listed explicitly request downloading items happen provided library 
name item provided downloading explicit indication kind ordinary generic architectural specification view symbols declares 
formedness library depends items downloaded libraries 
construct get effect downloading specifications named nat int basic numbers preserving names 
possible give downloaded specifications different distributed libraries names avoid clashes specification names locally basic numbers get nat natural int integer items referenced downloaded items automatically downloaded downloading int entail downloading nat 
downloading involves semantics named items text 
consists signature class models self contained entity recall chap 
models structured specification structure flat unstructured specification 
downloading int gives exactly result nat text replaced text nat downloading 
reason presence item name nat current library difference result downloading int 
terms software packages downloading specifications casl libraries analogous installing packages binaries sources 
downloading item library library causes parsing display annotations inserted 
conflicting annotations different libraries ignored altogether local annotations override conflicting downloaded annotations 
copied annotations allow terms written displayed way substantial libraries basic datatypes available 
organization libraries basic datatypes explained chap 
basic numbers natural numbers integers rationals 
basic reflexive symmetric transitive relations equivalence relations partial total orders boolean algebras 
basic algebra monoids groups rings integral domains fields 
basic booleans characters 
basic sets lists strings maps bags arrays trees 
basic graphs directed graphs paths reachability connectedness colorability planarity 
basic algebra ii monoid group actions space euclidean factorial rings polynomials free monoids free commutative monoids 
basic vector spaces bases matrices 
basic ii algebras field 
basic bounded subtypes naturals integers 
libraries libraries form coherent collection highly polished specifications 
libraries provided full casl manual available internet 
libraries need registered public access 
library www cofi info casl test security casl password www cofi info casl rsa get key spec decrypt key 
libraries development libraries provided restricted groups users named accessed urls simple path names registered libraries 
allows casl library constructs fully exploited libraries registered public access 
validation libraries demanding time consuming process getting library approved registered appropriate provides specifications useful persons directly involved development 
primary internet access protocols ftp support password protection libraries insertion usernames passwords urls allows downloading protected libraries username password unrelated host file system 
version control subsequent versions library distinguished explicit version numbers 
library basic numbers version spec nat 
spec int nat 
spec rat int 
version control illustrated library assigned explicit version number allowing distinguished previous versions library 
casl allows conventional hierarchical version numbers familiar version numbers software packages initial digits indicate major version digits dot indicate sub versions digits dot indicate patches correct bugs 
distinctions alpha beta pre release versions supported 
smallest version number written simply omitted specifying initial version library case version basic numbers shown sect 
implicitly version number general installed version library version number 
numbers successively installed versions contiguous increasing patched version installed version 
individual library items separate version numbers 
date annotations indicate items changed versions library 
libraries refer specific versions libraries 
library basic version basic numbers version get nat int spec list sort elem nat 
spec array int 
downloading items particular versions libraries necessary wants ensure coherence libraries 
example illustrated version basic downloads nat int version basic numbers 
omitting version number downloading gives implicitly current version library may course change 
way current version library necessarily installed largest version number 
mentioned patched version installed version downloading explicit version number refer version 
developers libraries may try ensure backwards compatibility versions happen symbols introduced new version downloaded specification clash symbols library specified downloading causing ill formedness inconsistency 
safety advisable give explicit version numbers libraries downloading downloading version library 
subsequently wants symbols introduced version library needed change version number downloading 
alternative strategy ensure consistency current versions libraries specifications downloaded observing changes new versions adapting downloading library accordingly 
instance download int current version basic numbers version library 
may involve extra new version basic numbers appears advantages cautious approach 
casl leaves choice user registered libraries generally required explicit version numbers downloading libraries 
collected library 
casl allows interleaved specification definitions advisable collect libraries parsing display annotations 
easy see dependencies libraries ensure different library refer version 
foundations donald sannella andrzej tarlecki complete presentation casl manual 
user manual introduced potential user features casl mainly means illustrative examples 
discussed typical ways language concepts constructs expected course building system specifications 
presentation part ii focused constructs concepts casl 
tried points clear possible referring simple examples discussing general ideas details casl specifications 
hope reader sufficient feel formalism understanding look presentation basic library casl specifications chap 
follow case study chap 
start experimenting casl writing specifications employing support tools chap 

means book regarded complete presentation casl specification formalism accompanying volume casl manual 
casl definitive summary 
casl manual begins definitive summary entire casl language language constructs listed systematically syntax write detailed explanation intended meaning 
tries precise complete casl summary relies natural language casl 
bidoit mosses casl user manual lncs pp 

ifip international federation information processing foundations inherently leaves room interpretation ambiguity various corners language example details different constructs interact 
casl complete formal definition 
key aim entire cofi initiative avoid potential ambiguities providing complete formal definition casl sound mathematical foundations advocated methodology software specification development 
concrete syntax casl defined formally 
part manual formal definition syntax casl 
syntax phrase written way directly indicates components making evident internal structure 
essence construct language explicitly labeled 
convenient formal manipulation analysis readable 
called concrete syntax casl instance examples book retaining direct correspondence syntax 
offers user casl convenient readable way writing casl specifications way clear formal structure phrases constructs build 
usual syntax context free grammar variant bnf notation relying established theory give formal meaning variety tools techniques available syntactic analysis languages style 
casl complete formal semantics 
ultimate definition meaning casl specifications provided semantics casl manual 
semantics defines mathematical entities formally model intended meaning various concepts underlying casl hinted chap 
introduced discussed summary 
key concepts casl signature model formula satisfaction relation models formulas common signature 
fact variants standard algebraic logical notions linking casl established mathematical theories ideas 
foundations standard way concepts build semantic domains meanings phrases various syntactic categories casl inhabit 
chosen give semantics form called natural semantics formal deduction rules derive judgments concerning meaning casl phrase meanings constituent parts 
mathematically established formalism unambiguous interpretation hope semantics readable details easier follow approaches 
semantics casl consists parts 
static semantics captures form static analysis casl specifications checked formedness example axioms typed named entities scope 
model semantics takes formed casl specification assigns model theoretic meaning 
casl specifications denote classes models 
casl formed specifications denote signatures static semantics classes models model semantics 
basic specifications essence signature set axioms signature denote class models satisfy axioms 
semantics basic specifications split parts sorted basic specifications described features defining subsorts added 
semantics largely institution independent 
concepts needed explain semantics structured specifications 
key notion signature morphism model reducts translation sentences signature morphisms induce 
having introduced obtain institution casl underlying logical system casl equipped extra structure capture ways moving signatures linked signature morphisms 
important point semantics layers semantics basic specifications institution independent defined institution chosen build basic specifications long institution comes bit extra structure concerned forming unions signatures defining signature morphisms 
semantics architectural specifications relies formal counterpart concept unit module system developed self contained units viewed simply models underlying institution parametrized units functions mapping parameter models result models 
architectural specifications provide way specifying component units system indicating system foundations built putting units 
intuition captured semantics architectural specifications denote class permitted unit bindings function maps environment result unit 
libraries layer casl standard description libraries modeled environments giving names entities introduced specifications architectural specifications 
semantics ultimate meanings casl constructs 
formal mathematical semantics crucial understanding casl specifications 
provides unambiguous meaning gives ultimate point questions concerning interpretation casl phrase context 
experienced important formal semantics may design casl 
cases intended semantics prominent internal discussions details constructs consideration provided guidelines choices design casl 
concrete syntax casl designed semantics settled 
proof systems various layers casl provided 
semantics necessary prerequisite development mechanisms formal reasoning casl specifications 
role proof calculi support reasoning various layers casl 
starting point formal system deduction rules determines proof theoretic counterpart consequence relation sets formulas providing way deriving consequences sets axioms casl specifications 
extended systems rules deriving consequences structured specifications proving inclusions classes models specifications 
systems rules formal verification internal correctness system designs captured architectural specifications 
systems soundness proved completeness discussed formal semantics casl 
point interest extension basic proof system consequences sets formulas structured architectural specifications really rely specifics underlying institution just reflects way structuring architectural constructs defined arbitrary institution 
foundations foundations casl rock solid 
mathematical underpinnings casl related specification development methodology documented manual exceptionally trustworthy sense provides formal point claims may checked 
tools till mossakowski chapter gives overview casl tools 
analysis tools casl parsers static checkers formatters stable cover casl 
proof tools available mature 
casl designed goal subsuming previous specification languages 
languages come specific tools course tools reusable context casl 
central issue build bridges existing tools building new tools scratch 
interchange format generated analysis tools casl interfaced way rewriting engines theorem provers usually working subset casl 
naturally due ongoing development tools detailed descriptions outdated sooner 
give just appetizer intended encourage reader install tools experiment convince easy 
detailed descriptions tools latest versions tools may developed available links cofi tools home page www cofi info tools 
analysis tools casl check examples contained book casl basic libraries 
proofs case study refinement carried proof tools 
casl specifications checked formedness form web page 
specification formedness visit web interface 
web form submit specification need install machine get immediate bidoit mosses casl user manual lncs pp 

ifip international federation information processing tools feedback formedness specification 
follow web interface link cofi tools home page 
heterogeneous tool set hets heterogeneous tool set hets main analysis tool casl 
hets tool set analysis specifications written casl extensions sublanguages name heterogeneous 
hets consists logic specific tools parsing static analysis different casl extensions sublanguages logic independent parsing static analysis tool structured architectural specifications libraries course calls logic specific tools basic specification encountered 
order able tackle proof obligations occurring statically formed specifications hets interfaced various theorem proving rewriting consistency checking tools 
top logic independent proof engine called maya manages proof obligations 
maya uses called development graphs graphical representation casl structured specifications 
architecture hets shown fig 

latest version obtained cofi tools home page 
installation easy just follow instructions 
consider example book spec strict partial order sort elem pred elem elem elem strict asymmetric transitive note may exist hets parsing checking static formedness specifications 
basic specifications logic specific tools casl extensions text parser syntax static analysis signature sentences interfaces xml aterms theorem prover hol casl consistency checker ccc heterogeneous tool set hets hascasl rewriter elan casl graph casl sublanguages proposed extensions csp casl casl fol horn casl ltl sb casl pfol structured architectural specifications text parser syntax static analysis development graph interfaces xml aterms maya heterogeneous proof engine management proofs change fig 

architecture heterogeneous tool set 
assume example file named order casl file provided web cd rom coming volume 
check formedness specification typing shell hets order casl hets checks correctness specification respect casl syntax correctness respect static semantics identifiers declared operators applied arguments correct sorts overloaded symbols unambiguous 
possible generate pretty printed atex version order casl typing hets pp tex order casl order casl numbers form strict partial order view follows spec natural free type nat suc nat tools spec natural order natural pred nat nat nat suc suc suc view strict partial order natural order elem nat specifications checked hets 
checks syntactic static semantic formedness checked predicate introduced natural order constrained interpreted strict partial ordering relation 
checking requires theorem proving discussed 
hets displays manages proof obligations development graphs 
coming theorem proving inspect proof obligations arising specification 
done hets order casl assuming specifications view added file order casl 
hets displays called development graph just overview graph showing structure specifications library see fig 

strict partial order natural natural order fig 

sample development graph 
heterogeneous tool set hets nodes development graph correspond casl specifications 
arrows show specifications related structuring constructs 
solid arrow denotes ordinary import specifications generated extension dashed arrow denotes proof obligation corresponding view 
proof obligation needs discharged order show view formed 
complex example consider loose specification sorting function taken chap 
spec list order sorted total order sort elem pred list selectors sort elem local pred sorted list elem list empty sorted cons empty sorted cons cons sorted cons sorted op order list list list order sorted specification sorting insertion taken chap 
spec list order total order sort elem pred list selectors sort elem local op insert elem list list elem list insert empty cons empty insert cons cons insert cons cons op order list list elem list order empty empty order cons insert order specifications related 
see inspect signatures 
possible hets sorting casl dashed arrow displayed solid red hets colors available 
tools assuming sorting casl contains specifications 
hets displays complex development graph see fig 

strict partial order elem total order list selectors list order sorted list order fig 

development graph sorting specifications 
heterogeneous tool set hets internal nodes development graph correspond unnamed parts structured specification 
mentioned development graph types nodes 
named ones correspond named specifications unnamed nodes corresponding anonymous basic specifications declaration insert operation list order 
basically internal node structured specification named 
simple solid arrows denote ordinary import specifications corresponding extensions unions specifications double arrows denote hiding corresponding local specification 
clicking nodes inspect signatures 
way see list order sorted list order signature 
legal add view view total order list order sorted total order list order total order added view sorting casl 
corresponding proof obligation list order sorted list order displayed fig 
dotted arrow 
proof obligations discharged various ways 
trivial proof obligations discharged hets proofs menu 
proof obligation fig 
indicated lower dotted arrow list order sorted list order states insertion sort defined operation order list order properties sorting algorithm 
choose theorem prover discharge proof obligation done commands specific theorem prover cf 
section 
alternatively state just conjectures obligation true 
hets written haskell 
parser uses combinator parsing 
userdefined known mixfix syntax casl calls pass approach 
pass skeleton casl syntax tree derived order extract user defined syntax rules 
second pass performed static analysis syntax rules parse expressions mixfix notation 
output stored called aterm format interchange format interfacing tools 
hets provides interface institutions new logics integrated smoothly 
order parser static checker prover basic specifications logic provided 
tools hets built experiences precursors cats maya tool set cats comes roughly analysis tools hets 
management development graphs integrated cats provided stand version tool maya 
cats maya obtained cofi tools home page 
hol casl hol casl interactive theorem prover casl tactical theorem prover isabelle 
hol casl system provides interface casl theorem proving system isabelle hol 
chosen isabelle small core guaranteeing correctness provers simplifier tableaux prover built top core 
furthermore years experience mathematical textbooks partially verified isabelle 
casl linked isabelle hol encoding 
subsorting partiality casl isabelle hol encode features explained 
means theorem proving done casl logic directly logic hol higherorder logic isabelle 
hol casl tries user life easy choosing shallow embedding casl hol means casl logical implication mapped directly isabelle hol logical implication holds logical connectives quantifiers adapting isabelle hol syntax conform casl syntax isabelle hol displayed 
essential aware fact isabelle hol logic different casl logic 
formulas appearing subgoals proofs hol casl fully conform casl syntax may features isabelle hol higher order functions casl 
hol casl obtained cofi tools home page 
start hol casl system follow installation instructions type hol casl asf sdf parser syntax directed editor load specification file order casl typing casl order try prove part view 
prepare conducting proof target specification view natural order casl context natural order casl command just selects specification current proof context second adds axioms specification isabelle simplifier rewriting engine 
note advisable axioms terminating considered set rewrite rules 
prove property expressed view type goal 
chose perform induction variable andthe rest done automatic simplification 
name theorem goal forall nat induct tac auto tac qed nat irreflexive stand maya maya part hets provide interface hol casl discharge proof obligations arising development graphs 
asf sdf parser syntax directed editor asf sdf prototype casl syntax 
algebraic specification formalism asf sdf asf sdf meta environment deployed prototype casl concrete syntax develop mapping concrete syntax syntax representation called aterms 
currently pass parsing mixfix analysis realized sdf 
parsing performed underlying scannerless generalized lr parsing technology 
prototype mapping concrete representation 
tools asf sdf meta environment provides syntax directed editing casl specifications 
concrete syntax definition casl sdf syntax directed editors asf sdf meta environment come free 
developments meta environment allow development casl specification environment 
asf sdf meta environment provides built library mechanism contains collection grammars casl 
library user meta environment access casl syntax sdf collection asf equations map casl specifications interchange format named 
tool compiles casl grammar stand program 
link asf sdf meta environment information download possibility cofi tools home page 
built library meta environment version higher provide full casl grammar sdf mapping asf specification 
tools tools prototype stage time appearance volume 
please refer cofi tools home page latest versions downloaded 
translation ocaml translation casl ocaml developed paris 
translation works functional programming sublanguage casl includes free datatypes recursive definitions operations types 
translation haskell translation casl haskell developed bremen 
translation works executable subset hascasl higher order extension casl 
embedding casl hascasl translation 
elan casl elan casl rewriting engine horn sublanguage casl 
itis translation sublanguage input language rewriting engine elan 
tools casl specification query term elan casl computes normal forms term 
note set rules required terminating confluent query term may normal forms may terminate 
elan 
casl consistency checker casl consistency checker ccc developed bremen swansea 
ccc interactively check casl specification consistent 
faithful implementation consistency calculus full casl 
certain syntactical criteria consistency calculus relies heavily casl structuring mechanisms semantic annotations 
consequently consistency proofs follow structure specification 
way calculus highlights usually hot spots specification views requiring theorem proving lengthy trivial parts consistency argument discharged automatically 
consistency calculus works structure specification need construct prove correct actual models specifications avoided far possible 
proof infrastructure goals tactics rules library rules provers derived basic ext ext 
cons cons sig test definitional theorem wellformed hol casl cats static analysis logical core casl syntax unification substitution fig 

ccc system architecture tools casl consistency checker consists parts see fig 
logical core implementing representation propositions proved basic proof rules generic unification package casl syntax secondly representations calculi stated axiomatically derived rules thirdly proof procedures automatic semi automatic decision procedures serve discharge specific proof obligations proof infrastructure package helps users conduct goal directed proofs tactics support writing advanced proof procedures simple database allows storage retrieval proved theorems 
system encapsulated single interface allow user working specifier add axiomatic rules provers typing increase confidence correctness implementation style lcf protect integrity system user intervention 
basic libraries till mossakowski casl basic libraries contain standard datatypes 
casl basic libraries consist specifications needed datatypes views freeing specifier re inventing known things 
compared standard libraries programming languages 
book discusses styles specification casl basic datatypes consistently follow specific style described 
show cut version axioms 
describe libraries see overview fig 
libraries numbers structured datatypes 
provide versions libraries specifications axioms annotations removed 
stripped versions serve getting overview signatures specified datatypes 
full casl basic libraries complete specifications casl manual included cd rom coming volume 
latest version available www cofi info libraries hets get overview basic libraries 
hets tool described chap 
allows structure specifications libraries displayed graph signatures inspected 
recommended way obtaining better overview answering specific questions arise basic datatypes 
bidoit mosses casl user manual lncs pp 

ifip international federation information processing basic libraries numbers algebra algebra ii graphs ii fig 

dependency graph libraries basic datatypes 
library basic numbers library provides specifications natural numbers integers rational numbers 
natural numbers specified free datatype 
specification nat natural numbers specified free datatype collection predicates operations sort nat natural numbers 
note names partial operations subtraction 
division 
include question mark 
avoid overloading total operations integers rationals lead inconsistencies specifications import specification nat 
total operation subtraction differs subtraction integers library basic numbers 
written 
partial subtraction 
undefined coincides 
digits introduced constants operation concatenation digits 
annotation see chap 
number allows write usual literals natural numbers 
subsort pos consisting positive naturals gives rise certain new operations pos pos pos semantics completely determined overloading 
library basic numbers spec nat free type nat suc pre nat preds nat nat odd nat ops nat nat min max 
nat nat nat 
div mod gcd nat nat 
nat operations represent natural numbers digits ops nat suc def nat nat suc def nat nat suc def nat nat suc def nat nat suc def nat nat suc def nat nat suc def nat nat suc def nat nat suc def nat nat nat nat suc decimal def sort pos nat ops pos suc pos def pos pos pos pos nat pos nat pos pos suc nat pos integers specified difference pairs naturals 
basic libraries specification int integers built top specification nat integers defined equivalence classes pairs naturals written differences axioms omitted specification specify pairs equivalent differences equal nat equality int sort nat declared subsort int 
division operator 
specification int provides function pairs div mod quot rem respectively constructs division behaving differently negative numbers see discussion 
operation sign gives sign integer 
spec int nat generated type int sort nat nat nat int system representatives sort int wherea pos preds int int odd int ops sign int int abs int nat min max int int int int nat int 
div quot rem int int 
int mod int int 
nat rationals specified fractions integers 
specification rat rational numbers follows scheme specification integers discussed 
time specification int imported 
rationals defined equivalence classes pairs consisting integer positive number written fractions axiom int pos equality rat sort int declared subsort rat 
note behavior subsorted overloading casl declaration operation library basic rat rat 
rat allows rationals written arbitrary integers spec rat int generated type rat int pos sort int rat preds rat rat ops abs rat rat min max rat rat rat rat rat 
rat rat int rat library basic library provides specifications familiar structured datatypes design algorithms programming languages 
main focus data structures finite sets lists strings finite maps finite bags arrays various kinds trees 
common concepts generic 
consequently specifications library generic 
finite sets maps bags specified generated datatypes equality determined means observers 
finite sets finite maps finite bags specified generated sort 
observer operation predicate introduced order define equality sort 
concerning finite sets equality sort set elem characterized predicate eps displayed specification 
leads extensionality axiom elem equality set library basic basic libraries spec sort elem generated type set elem set elem elem pred elem set elem system representatives sort set elem 

arbitrary strict total order elem 
spec set sort elem nat sort elem def preds set elem set elem set elem ops elem set elem set elem nat elem set elem set elem set elem elem set elem set elem set elem set elem finite maps elements sort map considered identical looking value yields result cases lookup lookup equality map top specification map adds predicates determining profile map means map 
specification restricts maps defined maps isomorphic tuples 
maps finite totality possible maps finite argument sorts 
specified specification finite partial surjection natural numbers 
specification unusual exception show axioms 
spec sort sort generated type map empty map op lookup map 
library basic spec map sort sort nat sort sort set sort set sort def free type entry target source preds isempty map entry map map set set ops map entry map map map map map dom map set range map set map map 
map spec finite sort elem nat op nat 
elem elem nat surjective reveal elem nat nat def bounded spec finite sort sort map sort sort sort map def lookup ops lookup entry range set 
pred entry hide map specification elements sort bag elem identified show number occurrences observed operation freq entries elem freq freq equality bag basic libraries spec sort elem nat generated type bag elem bag elem elem op freq bag elem elem nat spec bag sort elem nat sort elem preds isempty bag elem elem bag elem bag elem bag elem ops elem bag elem bag elem bag elem elem bag elem bag elem bag elem bag elem lists specified free datatype 
specification lists built empty list adding elements front 
usual list operations provided select element list rest front select remaining list counts number elements list freq counts number occurrences element take takes elements list drop drops 
spec sort elem free type list elem elem rest list elem spec list sort elem nat sort elem preds isempty list elem elem list elem ops list elem elem list elem list elem 
elem front rest list elem 
list elem list elem nat list elem list elem list elem reverse list elem list elem list elem nat 
elem take drop nat list elem 
list elem freq list elem elem nat library basic arrays specified certain finite maps 
specification array includes condition min max axiom parameter 
ensures non empty index set 
arrays defined finite maps sort index sort elem typical array operations lookup assignment introduced terms finite map operations 
revealing essential signature elements yields desired datatype 
spec array ops min max int min max cond sort elem int sort index int min max map sort index sort elem sort map index elem array elem op empty init ops array elem index elem array elem array elem index 
elem reveal sort array elem ops init kinds tree available differing branching positions elements 
library concludes specifications concerning trees 
specifications binary trees bintree bintree branching trees trees possibly different branching node ntree 
branching structures equipped data different ways nodes tree carry data case bintree ntree just leaves tree data entry bintree 
basic libraries binary trees admit children internal node 
spec sort elem free type bintree elem nil bintree entry elem left bintree elem right bintree elem spec bintree sort elem nat sort elem set sort elem preds isempty bintree elem bintree elem elem bintree elem ops height bintree elem nat leaves bintree elem set elem spec sort elem free type elem leaf entry elem bintree left elem right elem free type bintree elem nil sort elem spec bintree sort elem nat sort elem set sort elem def preds isempty bintree elem bintree elem elem bintree elem ops height bintree elem nat leaves bintree elem set elem library basic trees admit children internal node fixed 
come branching trees 
branching specified arrays trees size contain children node tree 
spec op int cond sort elem int array ops int int fit ops min int max int sort elem free type elem nil entry elem branches array elem spec op int cond sort elem int op int sort elem set sort elem def preds isempty elem elem elem elem ops height elem nat index array elem nat leaves elem set elem index array elem set elem basic libraries trees admit arbitrary branching 
trees trees possibly different branching node 
specified equipping node tree list child trees 
spec sort elem list sort ntree elem free type ntree elem nil ntree entry elem branches list ntree elem spec ntree sort elem nat sort elem set sort elem preds isempty ntree elem ntree elem elem ntree elem ops height ntree elem nat list ntree elem nat leaves ntree elem set elem list ntree elem set elem case study steam boiler control system chapter illustrate casl fairly large complex case study steam boiler control system 
case study particularly interesting times specification frameworks illustrated see 
describe derive casl specification steam boiler control system starting informal requirements provided participants dagstuhl meeting methods semantics specification organized jointly jean raymond abrial egon rger hans langmaack june 
aim formalization process analyze informal requirements detect inconsistencies loose ends translate requirements specification 
process provide interpretations unclear missing parts 
explain keep track additional interpretations localizing precisely formal specification lead specific axioms care traceability issues 
explain casl specification obtained stepwise way successive analysis various parts problem description 
discuss validation casl requirements specification resulting formalization process step refine requirements specification sequence architectural specifications describe intended architecture steam boiler control system 
reader familiar steam boiler control system case study may want start reading app 
original description problem reproduced 
chapter partially relies earlier published specification language larch prover 
specification methodology illustrated chapter significantly improved casl provides features lead concise perspicuous specification illustrated chapter 
bidoit mosses casl user manual lncs pp 

ifip international federation information processing case study steam boiler control system aim chapter illustrate solve steam boiler control specification problem casl 
provide casl specification software system controls level water steam boiler 
plan described follows 
main task derive starting informal requirements requirements specification written casl steam boiler control system 
particular task involves activities perform depth analysis informal requirements 
obviously necessary gain sufficient understanding problem specified preliminary task may worth mentioning 
stress kind preliminary analysis required writing formal specification proves especially useful detect discrepancies informal requirements difficult detect 
practical experience step usually fruitful engineering point view argue benefits expected justify formal methods lack time resources full formal development system performed 
sufficient understanding problem specified translate informal requirements formal specification 
step require provide interpretations unclear missing parts informal requirements 
formalization process helpful detect inconsistencies loose ends informal requirements 
important issue keep track interpretations formalization process order able take account modifications changes informal requirements 
written formal requirements specification carefully check adequacy respect informal requirements part called validation formal specification 
principle interaction specification team team designed informal requirements particular check suggested interpretations detected loose ends adequate 
framework case study interactions possible intuition assess soundness interpretations writing formal specification 

validated requirements specification obtained proceed program sequence refinements 
crucial step choice architecture desired implementation expressed architectural specification explained chap 

refinement step getting started leads proof obligations allow correctness performed refinement assessed 
step program derived final design specification 
starting explain write casl requirements specification steam boiler control system comments case study 
note principle hybrid system steam boiler control system turns merely reactive system hard realtime system see assumptions app 

system control program physical environment distributed case requirements level steam boiler control system 
casl turns especially suited capture features systems steam boiler control system data control equally important particular data play prominent role failure detection 
various constructs provided casl allow specifications formulated straightforwardly significantly concisely algebraic specification languages 
clear sake simplicity initialization phase steam boiler control system see app 
specified 
clear straightforward extend specification take initialization phase account exactly methodology rest case study 
chapter organized follows 
sect 
start providing elementary specifications useful rest case study 
sect 
explain proceed derive casl requirements specification stepwise way 
sect 
detail specification mode operation steam boiler control system 
sect 
specify detection various equipment failures sect 
explain compute cycle predicted values messages received cycle 
sect 
explain casl requirements specification validated sect 
refine casl requirements specification sequence architectural specifications describe intended architecture implementation steam boiler control system 
getting started explained app 
cycle steam boiler control system collects messages received performs analysis information contained sends messages physical units 
start specification elementary datatypes messages received messages sent 
specify messages sent received follow app 

note messages parameters pump number pump state pump controller state mode operation case study steam boiler control system specify corresponding datatypes 
sake clarity group similar messages repaired messages failure messages introducing suitable parameter physical unit 
physical unit pump pump controller water level measuring device steam output measuring device 
remember specify physical units specify physical environment steam boiler specify steam boiler specify steam boiler control system 
datatype physical unit just elementary datatype says pumps pump controllers measuring devices 
messages value parameter 
informal requirements infer values approximations real numbers necessary level decision exact specification values 
case study rely loose specification value introducing sort value operations predicates left unspecified expect course operations predicates intuitive interpretation suggested names 
means consider value general parameter specification 
point discussed sect 

note measuring units liter liter sec ensuring units consistently minor aspect particular case study 
analysis leads specifications value basics messages sent received 
basic numbers get nat display half latex display square latex spec value level don care exact specification values 
nat sorts nat value ops value value value assoc comm unit value value value value value value assoc comm unit leave value implicit parameter specifications generic specifications value parameter specifications instantiated argument specifications describing kinds values contrary refer datatype values 
course possible take measuring units account instance method described 
appropriate casl libraries supporting measuring units currently developed 
getting started value value min max value value value preds value value spec basics free type pumpnumber pump pump pump pump free type open closed free type flow free type pump pumpnumber pumpnumber free type mode initialization normal degraded rescue spec messages sent basics free type message mode mode program ready valve open pump pumpnumber close pump pumpnumber failure detection repaired spec messages received basics value free type message steam boiler waiting physical units ready pump state pumpnumber pump controller state pumpnumber level value steam value repaired failure junk addition messages received specified app 
add extra constant message junk 
message represent message received belong class recognized messages 
add similar message messages sent may assume control system send proper messages 
obviously receiving case study steam boiler control system junk message lead detection failure message transmission system 
sbcs constants specification describe various constants characterize steam boiler constants explained app 

spec sbcs constants value ops value dt value time duration cycles sec 
constants verify obvious properties specify datatypes set messages received set messages sent suggested app 
messages supposed received emitted simultaneously cycle 
specifications obtained instantiation generic specification set sets elements imported library basic 
basic get set spec preliminary set messages received fit elem message set messages sent fit elem message sbcs constants illustrated specifications particularly convenient structure formal specification coherent easy grasp named specifications easily reused referring names course prove important sequel 
free datatypes especially useful obtain concise specifications 
hand loose specifications useful avoid overspecification values value constants sbcs constants 
declaring nat subsort value ensures natural numbers arguments operations values 
reusing standard specifications usual datatypes basic libraries avoids need specify course essential specifications generic order easily adapt desired reused 
display annotations useful conveniently display symbols usual mathematical symbols 
chapter adequacy casl features highlighted 
carrying carrying emphasized app 
steam boiler control system typical example control command system 
specification systems follows pattern preliminary set specifications group basic information system controlled specification various messages exchanged system environment specification various constants related system interest 
aim specification preliminary introduced previous section 
various states control system described 
stage early determine state variables needed 
states represented values loosely specified sort state equipped observers corresponding access state variables 
requirements analysis formalization phase may need observers introduced need basis 
group specification take care analysis messages received failure detection particular 
basis analysis actions taken corresponding messages sent environment 
state variables updated result analysis messages received messages sent 
specification describes control command system labeled transition system 
rough preliminary sketch steam boiler control system specification looks follows library sbcs basic numbers get nat basic get set display half latex display square latex spec preliminary see previous section 
spec sbcs state preliminary sort state ops needed state observers introduced 
need observer mode operation mode state mode case study steam boiler control system spec sbcs analysis sbcs state analysis messages received particular failure detection 
computation messages sent 
op messages send state set message set message computation updates state variables 
observer obs defined sbcs state introduce operation obs computes corresponding update analysis messages received round 
instance specify operation mode corresponding update observer mode 
ops mode state set message mode spec steam boiler control system sbcs analysis op init state pred step state set message set message state specification initial state init means observers mode init 
specification step means observers updating operations state msgs set message set message step msgs mode mode msgs messages send msgs specification reachable states free pred reach state state msgs set message set message reach init reach step msgs reach course specification sbcs analysis structured smaller pieces specifications 
informal requirements complex handled successively concentrate various parts 
study formalization chunk requirements lead specifications put obtain sbcs analysis specification 
pointed analyzing chunk requirements discover need new observers states new state variables 
means specification sbcs state subject iterated extensions introduce new observers needed 
specifying mode operation instance app 
explained message received times row program go mode 
need observer state variable record number times successively received message 
sequel start specification states spec sbcs state preliminary sort state ops mode state mode state nat introducing new observer means specify corresponding operation sbcs analysis specification 
insist importance structuring formal specification coherent easy grasp named specifications easy reuse referring names 
explained essential rely loose specification states introduce observers needed 
predicate step describe labeled transition system quite convenient provides elegant way handling input output transition 
essential free constraint specify reachable states need combine parts loose interpretation parts initial interpretation specification 
specifying mode operation step specification various operating modes steam boiler control system operates 
explained sect 
take account initialization mode specification 
app 
operating mode steam boiler control system depends failures detected see physical units operating correctly failure water level measuring unit detection erroneous transmission 
depends expected evolution water level see water level risking reach 

assume specification sbcs analysis provide predicates known state newly received messages reflect failures detected steam boiler control system important subtle distinction actual failures basically know failures detected steam boiler case study steam boiler control system transmission ok state set message hold iff rely message transmission system pu ok state set message hold iff rely corresponding physical unit state set message hold iff estimate water level risks reaching min limits 
stage understanding steam boiler control system quite preliminary early attempt specify predicates 
specification mode evolution specify new operating mode previous newly received messages operation mode generic predicates 
emphasize genericity ensure loose coupling current specification interest mode evolution specifications expected provide needed predicates 
explain specify new mode operation 
glance informal requirements see app 
look quite complicated mainly explain operating mode conditions steam boiler control system stay operating mode switch 
things get simpler analyze conditions mode specified operating modes 
particular careful analysis requirements shows mode determine new operating mode receiving messages account previous 
improve legibility specification better introduce auxiliary predicates ok emergency facilitate characterization conditions system switches mode aim predicate ok express believe physical units operating correctly including message transmission system 
aim predicate determine received message times row 
characterize conditions steam boiler control system operate rescue mode 
point corresponding part informal requirements see app 
totally clear particular exact meaning sentence rely information comes units controlling pumps 
double ambiguity hand unclear pumps means pumps control system 
behavior steam boiler control system induced failures detected actual failures 
specifying mode operation pump hand ways controlling pump information sent pump information sent pump controller unclear controlling refers pump controller 
interpretation follows consider pump correctly working correctly working mean rely pump associated pump controller 
interpretations formalization process principle interact designers informal requirements order clarify exact intended meaning check interpretation adequate 
important point interpretation entirely localized axiomatization fairly easy change specification case misinterpretation 
aim predicate emergency characterize switch mode 
app 
said steam boiler control system switch normal mode rescue mode soon failure water level measuring unit detected 
app 
explained steam boiler control system operate rescue mode additional conditions hold represented predicate 
decide normal mode failure water level measuring unit detected steam boiler control system switch rescue mode holds switch directly mode 
axiomatization mode operation simple clear illustrated mode evolution specification 
spec mode evolution preds transmission ok state set message pu ok state set message state set message sbcs state local auxiliary predicates structure specification mode 
interpretation incorrect cases may replaced sequence normal rescue sequence normal 
rescue normal degraded possible cycles necessary failure detection decision corresponding unit fully operational see sect 
sequence form normal rescue rescue normal degraded cases 
note mode specify stay mode forever specifying steam boiler control system stops 
note realize operation better specified mode evolution specification 
case study steam boiler control system preds ok emergency state set message state msgs set message ok msgs transmission ok msgs pu pu ok msgs pu msgs msgs msgs pu ok msgs pn pumpnumber pu ok msgs pump pn pu ok msgs pn emergency msgs mode msgs transmission ok msgs msgs pu ok msgs msgs ops mode state set message mode state set message nat state msgs set message emergency mode emergency msgs mode msgs normal mode emergency msgs ok msgs mode msgs normal degraded mode emergency msgs ok msgs pu ok msgs transmission ok msgs mode msgs degraded rescue mode emergency msgs pu ok msgs msgs transmission ok msgs mode msgs rescue msgs msgs step formalization process specify predicates assumed mode evolution amounts specifying detection equipment failures 
topic section 
specifying detection equipment failures essential features casl specification mode evolution 
hand generic specification imports ensures loose coupling current specification interest rest steam boiler control system specification 
hand auxiliary predicates improve legibility specification declaring local part specification ensures hidden exported 
specifying detection equipment failures detection equipment failures described app 

quite clear detection difficult part formalize mainly intuition requirements see knows incompatible dynamics suggest take account inter dependencies detecting various possible failures 
instance ask pump cycle pump state indicates pump open may principle infer failure message transmission system order properly sent received message indicating pump state corrupted failure pump able execute order sends incorrect state messages 
understanding requirements case conclude failure pump message transmission system 
stress important distinguish actual failures various pieces equipment diagnosis 
relevant specification 
understanding detection equipment failures starting specify detection equipment failures proceed careful analysis app 
order clarify inter dependencies mentioned 
able understand structure specification crucial part problem 
rough analysis part app 
devoted description potential failures physical units pumps pump controllers measuring devices shows failures detected basis information contained messages received check received values accordance expected values history system dynamics system messages previously sent steam boiler control system 
particular detection failures physical units relies fact effectively received necessary messages 
received messages conclude failure message transmission system see cases see case study steam boiler control system mode evolution specification steam boiler control system switches mode 
detection failures physical units addition detected failure message transmission system irrelevant cases 
consider message transmission system 
description potential failures message transmission system app 
quite short 
basically tells check steam boiler control system received messages expecting messages received 
important note involved analysis messages received combines aspects hand static analysis messages received order check messages transmission effectively see app 

messages exactly messages required proceed detection failures physical units 
hand steam boiler control system expects receive contrary receive specific messages history system instance steam boiler control system expects receive failure physical unit detected corresponding failure sent failure message unit dynamic analysis required 
obviously static analysis messages basis messages received dynamic analysis take account addition messages received history system precisely history failures detected far failure repaired messages received far 
analysis draw specify detection equipment failures 
step keep track failure status physical units 
lead new observer status states specification status evolution status evolves status operation 

specify detection message transmission system failures transmission ok specification message transmission system failure 
explained step take care static analysis messages received second step take care dynamic analysis messages received kept track status physical units observer status 

physical unit specify detection failures comparing message received expected 
comparison freely assume static analysis messages received successful message sent physical unit received 
corresponding specifications described subsections 
specifying detection equipment failures keeping track status physical units remember perform dynamic analysis messages received explained check receive failure repaired messages appropriate 
order keep track failures detected failure repaired messages received 
reasoning applies physical units analysis generic way 
physical unit keep track status ok 
status physical unit updated accordingly detection failures receipt failure repaired messages 
step extend specification sbcs state add observer related failure status physical units spec sbcs state sbcs state free type status ok op status state status specification status physical unit evolves operation status status evolution quite straightforward 
rely predicate pu ok spec status evolution pred pu ok state set message sbcs state op status state set message status state msgs set message pu status pu ok pu ok msgs pu status msgs pu ok status pu ok pu ok msgs pu status msgs pu status pu failure pu msgs status msgs pu status pu failure pu msgs status msgs pu reader may detect specification status evolution completely correct 
prefer give text specification originally written explain sect 
detect validating specification steam boiler control system correct problem fixed 
case study steam boiler control system status pu repaired pu msgs status msgs pu ok status pu repaired pu msgs status msgs pu rely generic specification imports ensure loose coupling 
claimed earlier loose specification states easy introduce observers state variables 
detection message transmission system failures explained specify static analysis messages received specify dynamic analysis messages 
specify static analysis messages necessary check indispensable messages 
addition set messages received acceptable duplicated messages set 
specified collection messages received set occurrences exactly message set 
note means choice sets bags instance totally innocent assume receiving occurrences exactly message happen assumption environment assume case lead detection failure message transmission system assumption requirements 
specifying collection messages received set imply set messages received contain level messages distinct values instance 
check explicitly 
remember receiving unknown messages messages belong list messages specified app 
taken account extra constant junk message see specification messages received 
erroneous situation simultaneously receive failure repaired message physical unit cycle needed acknowledging failure repairing unit 
check 
focus dynamic analysis messages received 
explained perform dynamic analysis check receive failure repaired messages appropriate current status physical unit 
understand confess belief induced intuition behavior system 
requirements allows interpretation opposite 
essential assumption simplify axiomatization 
specifying detection equipment failures failure signaled steam boiler control system corresponding physical unit send just failure 
specify steam boiler control system way receives repaired message steam boiler control system acknowledges immediately 
problem message transmission system due fact transmission time neglected steam boiler control system principle receive repaired message failure 
note contradict 
part sentences describing repaired messages informal requirements see app 

summarize consider received unexpected message program receives initialization messages longer initialization mode program receives physical unit failure having previously sent corresponding failure detection message receives redundant failure program receives physical unit repaired message unit ok failure acknowledged 
ingredients required specify transmission ok predicate account static dynamic aspects leads message transmission system failure specification 
spec message transmission system failure sbcs state local static analysis pred static ok set message msgs set message msgs static ok junk msgs value level msgs value steam msgs pn pumpnumber ps pump state pn ps msgs pn pumpnumber pcs pump controller state pn pcs msgs pu failure pu msgs repaired pu msgs dynamic analysis pred dynamic ok set message state case study steam boiler control system state msgs set message msgs dynamic ok mode initialization steam boiler waiting msgs physical units ready msgs pu failure pu msgs status pu ok status pu pu repaired pu msgs status pu ok status pu pred transmission ok state set message state msgs set message transmission ok msgs msgs static ok msgs dynamic ok auxiliary predicates declared local part specification quite useful improve legibility specification 
note nested quantifiers axioms aswell axioms intricate auxiliary operations needed 
detection pump pump controller failures start considering detection failures pumps 
explained sec rely predicted pump state message 
step extend specification sbcs state add observer related prediction pump state messages 
prediction open closed status corresponding pump ok extend sort introduce constant unknown ps spec sbcs state sbcs state free type sort unknown ps op ps predicted state pumpnumber status pn ok ps predicted pn unknown ps specification detection pump failures straightforward pump failure specification 
remember meaning pump ok relevant transmission ok holds particular implies pump pump state message specifying detection equipment failures msgs 
check received value predicted value unknown ps spec pump failure sbcs state pred pump ok state set message pumpnumber state msgs set message pn pumpnumber pump ok msgs pn ps predicted pn unknown ps pump state pn ps predicted pn msgs consider detection failures pump controllers 
rely predicted pump state controller message 
bit careful order reflect fact stopping pump instantaneous effect starting takes seconds see app 

seconds unfortunately exactly elapsed time cycles decide activate pump may wait cycles receive corresponding flow pump controller state 
addition constant unknown pcs cases prediction pump controller working correctly introduce constant prediction related just activated pump 
spec sbcs state sbcs state free type sort unknown pcs op pcs predicted state pumpnumber status pn ok pcs predicted pn unknown pcs specification detection pump controller failures straightforward pump controller failure specification 
remember meaning pump controller ok relevant transmission ok holds particular implies pump pump controller state message msgs 
check received value predicted value flow unknown pcs conclude 
case study steam boiler control system spec pump controller failure sbcs state pred pump controller ok state set message pumpnumber state msgs set message pn pumpnumber pump controller ok msgs pn pcs predicted pn unknown pcs pcs predicted pn pump controller state pn pcs predicted pn msgs specifications extend previously defined datatypes particularly convenient avoids need explicitly relate values values similarly 
note explicit axioms particular fact predicates hold undefined arguments resulting specifications 
detection steam water level measurement device failures specify failures steam water level measurement devices rely predicted values 
predict exact value interval received value contained 
leads extension sbcs state spec sbcs state sbcs state free type pair low value high value ops steam predicted level predicted state low steam predicted minimal steam output predicted high steam predicted maximal steam output predicted similarly level predicted 
specification failures measurement devices straightforward steam failure level failure specifications 
remember meaning steam ok level ok resp 
relevant transmission ok holds particular implies steam level resp 
message msgs possible quantifications value 
note assume predicted values take care static limits steam water level need check static limits explicitly 
specifying detection equipment failures spec steam failure sbcs state pred steam ok state set message state msgs set message steam ok msgs value steam msgs low steam predicted high steam predicted spec level failure sbcs state pred level ok state set message state msgs set message level ok msgs value level msgs low level predicted high level predicted summing ingredients necessary specification predicate pu ok detection specification integrates specifications related failure detection 
spec failure detection message transmission system failure pump failure pump controller failure steam failure level failure pred pu ok state set message state msgs set message pn pumpnumber pu ok msgs pump pn pump ok msgs pn pu ok msgs pn pump controller ok msgs pn pu ok msgs steam ok msgs pu ok msgs level ok msgs hide ops pump ok pump controller ok steam ok level ok specification rely explicit hiding operations longer needed 
name thing principle essential specifications extended failure detection extension specification sbcs state states name thing principle get effect extends sbcs state 
case study steam boiler control system predicting behavior steam boiler previous section explained failure detection large extent comparison messages received expected ones 
purpose extended specification sbcs state observers means assumed cycle record state variables information needed compute expected messages cycle 
explanations sect 
specify observer obs introduced corresponding obs operation 
aim section 
defined operation mode generic specification mode evolution see sect 
operation status generic specification status evolution see sect 

left specification operations ps predicted pcs predicted steam predicted level predicted 
explained sect 
informal requirements suggest take account inter dependencies predicting values received cycle 
instance water level steam boiler depends steam produced water poured steam boiler pumps open 
information provided water level prediction obviously crucial decide activate pumps 
hand predict pump state pump controller state messages received cycle know pumps ordered activated stopped 
analysis draw specify needed predictions 
step predict interval steam output expected stay cycle prediction relies just received value steam trust previously predicted values steam production 
production steam expected vary maximum gradients increase decrease 

step decide pumps ordered activate 
decision plus knowledge current state pumps trust predicted evolution steam production allow predict evolution water level 

basis current states pumps pump controllers choice pumps activated stopped predict states pumps pump controllers cycle 
course predictions meaningful long failure message transmission system detected case predicting behavior steam boiler steam boiler control system switches mode stops predictions needed anyway 
corresponding specifications described subsections 
predicting steam output water level predict intervals steam output water level expected stay cycle proceed follows account additional information provided pp 

analysis sketched state received messages msgs predict interval steam output expected stay cycle compute adjusted steam interval interval interval reduced received steam value rely pu ok msgs holds steam predicted interval stored state previous cycle 

maximum gradients increase decrease predict interval steam output expected stay cycle 

proceed similarly water level compute adjusted level interval interval reduced received level value rely pu ok msgs holds level predicted interval stored state previous cycle 

consider broken pumps pumps pn pu ok msgs pump pn hold pu ok msgs pump controller pn hold reliable pumps broken known open closed 

point decide pumps ordered activate 
specific control strategy deciding pumps activated stopped need detailed requirements specification left refinement implementation steam boiler control system 
obviously strategy compare adjusted level recommended interval decide accordingly 
rely loosely specified chosen pumps operation just impose soundness conditions pump ordered activate currently considered reliable closed pump ordered currently considered reliable open 

compute minimal maximal amounts water poured steam boiler cycle 
compute minimal pumped water consider pumps reliable open pour water broken pumps pumps just ordered activate pumps ordered considered pouring water 
similarly case study steam boiler control system compute maximal pumped water consider pumps reliable open pumps just ordered activate broken pumps may pour water reliable pumps just ordered stopped known pouring water 

predict interval water level expected stay cycle 

prediction basis deciding water level risks reach 
note intervals steam output water level expected stay cycle predicted considering status devices 
necessary degraded rescue operating modes 
leads steam level prediction specification 
spec steam level prediction failure detection set sort pumpnumber local ops received steam state set message value adjusted steam state set message received level state set message value adjusted level state set message broken pumps state set message set pumpnumber reliable pumps state set message set pumpnumber state msgs set message pn pumpnumber ps axioms steam transmission ok msgs steam received steam msgs msgs adjusted steam msgs pair received steam msgs received steam msgs transmission ok msgs pu ok msgs steam predicted axioms level transmission ok msgs level received level msgs msgs adjusted level msgs pair received level msgs received level msgs transmission ok msgs pu ok msgs level predicted axioms auxiliary pumps operations pn broken pumps msgs pu ok msgs pump pn pu ok msgs pn predicting behavior steam boiler pn reliable pumps msgs ps pn broken pumps msgs pump state pn ps msgs ops steam predicted state set message chosen pumps state set message set pumpnumber minimal pumped water maximal pumped water state set message value level predicted state set message pred state set message axioms steam state msgs set message pn pumpnumber low steam predicted msgs max low adjusted steam msgs dt high steam predicted msgs min high adjusted steam msgs dt axioms pumps pn chosen pumps msgs open pn reliable pumps msgs closed pn chosen pumps msgs closed pn reliable pumps msgs open minimal pumped water msgs dt reliable pumps msgs open chosen pumps msgs closed maximal pumped water msgs dt reliable pumps msgs open chosen pumps msgs open broken pumps msgs chosen pumps msgs closed axioms level low level predicted msgs max low adjusted level msgs minimal pumped water msgs dt dt high adjusted steam msgs high level predicted msgs min high adjusted level msgs maximal pumped water msgs dt dt low adjusted steam msgs msgs low level predicted msgs high level predicted msgs case study steam boiler control system hide ops minimal pumped water maximal pumped water note combination implicit hiding auxiliary operations declared local part explicit hiding operations minimal pumped water maximal pumped water local specification relies chosen pumps exported 
predicting pump pump controller states specifying predicted state pump cycle trivial 
pump state unknown ps status pump ok open open pump ordered pump ordered activate closed closed pump ordered activate ordered 
leads pump state prediction specification 
specification extends steam level prediction rely chosen pumps predictions status evolution provides status instantiated failure detection provides predicate pu ok parameter status evolution 
spec pump state prediction status evolution failure detection steam level prediction op ps predicted state set message pumpnumber state msgs set message pn pumpnumber ps predicted msgs pn unknown ps status msgs pump pn ok open pump state pn open msgs pn chosen pumps msgs closed pn chosen pumps msgs open closed reasoning predict pump controller state similar take account cycles may needed just activated pump leads flow state provided pump stopped 
pump controller state unknown pcs status pump controller ok status corresponding pump ok predicted pump controller state value predicting behavior steam boiler flow pump ordered currently flow currently pcs predicted pump ordered currently pcs predicted pump ordered activate 
leads pump controller state prediction specification 
spec pump controller state prediction status evolution failure detection steam level prediction op pcs predicted state set message pumpnumber state msgs set message pn pumpnumber pcs predicted msgs pn unknown pcs status msgs pn ok status msgs pump pn ok flow pump controller state pn flow msgs pump controller state pn msgs pcs predicted pn pn chosen pumps msgs closed pn chosen pumps msgs closed pump controller state pn msgs pcs predicted pn pn chosen pumps msgs open predictions summarized pu prediction specification 
spec pu prediction pump state prediction pump controller state prediction specifications extend status evolution instantiated failure detection steam level prediction specification failure detection provides predicate pu ok required status evolution put pieces case study steam boiler control system illustrated pu prediction 
name thing principle essential 
specifying messages send stage left specification messages send cycle 
easily specified app 
leads sbcs analysis specification 
specification sbcs analysis obtained instantiating mode evolution specification pu prediction extending result specification operation messages send 
spec sbcs analysis mode evolution pu prediction local ops state set message set message set message set message state msgs set message message msgs pn pumpnumber pn chosen pumps msgs open open pump pn pn chosen pumps msgs closed close pump pn msgs pu failure detection pu status msgs pu msgs pu repaired pu status msgs pu op messages send state set message set message state msgs set message messages send msgs msgs msgs msgs mode mode msgs steam boiler control system specification rely auxiliary operations declared local part axiomatization fairly easy existential quantifiers 
steam boiler control system specification plan detailed sect 
specified main parts case study 
display basic flat specification equivalent sbcs state state observers listed 
spec sbcs state preliminary sort state free type status ok free type sort unknown ps free type sort unknown pcs free type pair low value high value ops mode state mode state nat status state status ps predicted state pumpnumber pcs predicted state pumpnumber steam predicted level predicted state ready provide specification steam boiler control system considered labeled transition system 
leave partly unspecified initial state init specification state represents state immediately receipt physical units ready message 
intuitively omitted axioms take account messages sent received initialization phase 
better leave open value observers init note taken care specifying initialization phase 
value mode init specified app 

spec steam boiler control system sbcs analysis op init state pred step state set message set message state case study steam boiler control system specification initial state init mode init normal mode init degraded specification step state msgs set message set message step msgs mode mode msgs msgs pu status pu status msgs pu pn pumpnumber ps predicted pn ps predicted msgs pn pcs predicted pn pcs predicted msgs pn steam predicted steam predicted msgs level predicted level predicted msgs messages send msgs specification reachable states free pred reach state state msgs set message set message reach init reach step msgs reach validation casl requirements specification formalization informal requirements completed face question formal specification adequate 
difficult question answer formal way establish adequacy formal specification informal requirements prove adequacy 
try test performing various experiments 
experiments successful confidence formal specification increased 
experiment fails inspect specification try understand causes failure possibly detecting flaw specification 
base validation process theorem proving check formulas logical consequences requirements specification steam boiler control system 
purpose tools described chap 

validation process consider kinds proof obligations 
inspect text specification derive inspection formulas expected logical consequences specification 
considered kind internal validation formal specification 
validation casl requirements specification 
check expected properties inferred informal requirements logical consequences specification external validation 
informal specification state expected properties translate formulas attempt prove formulas logical consequences specification 
task easy general feeling expected properties detected included axioms formalization process 
application principles requirements specification steam boiler control system leads various proofs 
give illustrative examples 
instance consider specification mode mode evolution advisable prove cases considered specification mode mutually exclusive disjunction equivalent true 
typical example internal validation specification just consider text specification decide proof attempt performed considering informal requirements 
spell corresponding proofs reader easily check operation mode defined cases mutually exclusive disjunction equivalent true 
spirit prove pump simultaneously ordered activate failure signaled long operating mode set water level safe consider example external validation 
understanding failure detection see sect 
detected failure physical unit pu pu ok hold pu status physical unit set ok corresponding proof obligation reads follows steam boiler control system state msgs set message pu transmission ok msgs pu ok msgs pu reach status msgs pu ok unable discharge proof obligation 
careful analysis proof attempt shows proof fails case simultaneously receipt repaired message physical unit pu detect failure unit 
analysis conclude axiom status evolution adequate status pu repaired pu msgs status msgs pu ok means fix status evolution specification replace axiom case study steam boiler control system status pu repaired pu msgs status msgs pu ok pu ok msgs pu specification status evolution modified explained prove expected property holds 
conclude reader keep mind validation specification important task deserves serious attention 
section briefly illustrated typical proof attempts naturally arise validating steam boiler control system specification obviously proof attempts required reach stage trust requirements specification steam boiler control system 
designing architecture validated requirements specification steam boiler control system steam boiler control system 
step refine architectural specification prescribing intended architecture implementation steam boiler control system 
explanations sect 
suggest obvious architecture steam boiler control system arch spec arch sbcs units value preliminary preliminary sbcs state sbcs state sbcs analysis sbcs analysis steam boiler control system result value note decide describe implementation steam boiler control system open system relying external component implementing value 
consistent explanations sect 
choosing specific implementation value obviously orthogonal designing implementation steam boiler control system 
means particular component implementing value encapsulate chosen representation natural numbers values operations predicates operating 
illustrated arch sbcs intended architecture steam boiler control system easily described architectural specification 
proceed separate implementation tasks independent 
designing architecture step refine specification value preliminary component architectural specification 
arch spec arch preliminary units set sort elem nat set sort elem basics ms messages sent value messages received cst value sbcs constants result value set ms fit elem message set fit elem message cst decide implement generic sets component set reused sets messages received sets messages sent 
implementation natural numbers provided external component second argument generic component set result unit term 
note generic specification imports set transposed specification generic component set note component specification generic component extending unit 
specification components arch sbcs simple need architecturally refined 
specification component implements states steam boiler control system refined specification unit sbcs state provides concrete implementation states record observable values 
basic get spec sbcs state impl preliminary free type status ok free type sort unknown ps free type sort unknown pcs free type pair low value high value basics fit sort status basics fit pumpnumber sort basics fit pumpnumber sort case study steam boiler control system free type state mk state mode mode nat status status ps predicted pumpnumber pcs predicted pumpnumber steam predicted level predicted ops status state pu status lookup pu status ps predicted state pn pumpnumber lookup pn ps predicted pcs predicted state pn pumpnumber lookup pn pcs predicted unit spec unit sbcs state preliminary sbcs state impl formalization process convenient rely loose specification states 
design stage loose specification refined specification state variables explicit 
specification sbcs state sbcs analysis component arch sbcs refined architectural specification arch spec arch analysis units fd sbcs state failure detection pr failure detection pu prediction pu prediction mode evolution pu prediction mts mode evolution pu prediction sbcs analysis result sbcs state mts pr fd architectural specification arch analysis component fd provides implementation failure detection component pr implementation predicted state variables cycle component provides implementation mode component mts provides implementation messages send 
specifications components mts simple directly implemented 
specifications components fd pr refined follows 
designing architecture arch spec arch failure detection units sbcs state message transmission system failure pf sbcs state pump failure pcf sbcs state pump controller failure sf sbcs state steam failure lf pu sbcs state level failure message transmission system failure pump failure pump controller failure steam failure level failure failure detection result sbcs state pu pf pcf sf lf hide pump ok pump controller ok steam ok level ok architectural specification arch failure detection refines specification sbcs state failure detection component fd arch analysis introduces component kind failure detection 
component pu implements pu ok result unit expression hide auxiliary predicates provided components pf pcf sf refine specification failure detection pu prediction component pr architectural specification arch analysis follows arch spec arch prediction units se failure detection status evolution failure detection slp failure detection steam level prediction pp status evolution failure detection steam level prediction pump state prediction pcp status evolution failure detection steam level prediction pump controller state prediction result fd failure detection local se fd slp fd pp pcp auxiliary predicates hidden specification failure detection 
remember specification generic component target specification implicit extension argument specifications 
necessary hide auxiliary predicates level result unit expression 
case study steam boiler control system architectural specification component se provides implementation status 
component slp provides implementation steam predicted level predicted chosen pumps 
component pp provides implementation ps predicted component pcp provides implementation pcs predicted 
left specifications components simple directly implemented concludes case study 
casl quick appendix provides overview concrete syntax part casl 
basic specifications structured specifications declarations definitions sorts subsorts functions total partial constants total partial predicates datatypes sort generation constraints variables axioms formulas terms symbols comments annotations specification structure translation hiding revealing union extension free extension initiality hiding local symbols instantiation named generic specifications fitting arguments named generic views fitting views symbol lists maps architectural specifications libraries named architectures units architectural specifications unit specifications unit declarations definitions unit expressions terms named libraries library names versions bidoit mosses casl user manual lncs pp 

ifip international federation information processing casl quick basic specifications list items optional sorts sort declarations definitions ops operation declarations definitions preds predicate declarations definitions types datatype declarations definitions generated 
sort generation constraint vars global variable declarations fn universally quantified list axioms unquantified list axioms fn declarations definitions sort declarations definitions sort sort declaration sorts sn sorts declaration sorts subsort declaration sorts sn subsorts supersort declaration sorts sn subsort declaration sorts sn isomorphic sorts declaration sort subsort definition function declarations definitions op sn total function declaration op sn 
partial function declaration op assoc associative binary function op comm commutative binary function op idem idempotent binary function op unit unit term binary function op multiple function attributes ops fn functions declaration op vn sn total function definition op vn sn partial function definition op vi si abbreviated arguments ops multiple declarations definitions constant declarations definitions op op ops cn op op ops constant declaration partial constant declaration constants declaration constant definition partial constant definition multiple declarations definitions basic specifications predicate declarations definitions pred sn predicate declaration pred constant predicate declaration preds pn predicates declaration pred vn sn predicate definition pred constant predicate definition pred vi si abbreviated arguments preds multiple declarations definitions datatype declarations type types sn generated types free types datatype declaration alternatives multi sorted datatype declaration generated datatype declaration free datatype declaration alternatives total constructor function 
partial constructor function fi si 
total constructor selector functions fi si 
total constructor partial selector functions fi fim si 
abbreviated selectors constant constructor value sort subsort sorts subsorts am multiple alternatives sort generation constraints generated sorts generated sorts ops generating operations preds types generated sorts generating constructors casl quick variables axioms var vars vn sn vars vn sn vars fn vn fn global variable declaration global variables declaration abbreviated variables declaration multiple global variable declarations universally quantified list axioms abbreviated quantifications multiple quantifications unquantified list axioms formulas universal quantification formula existential quantification 
unique existential quantification fn conjunction fn disjunction implication reverse implication equivalence negation true truth false falsity tn predicate application tn tn mixfix predicate application constant predicate ordinary strong equality def existential equality definedness subsort membership terms tn tn tn tn application mixfix application literal syntax constant variable sorted term projection subsort conditional choice basic specifications symbols character set ascii optional iso latin 
key words signs reserved key words lowercase arch axiom axioms closed def exists false fit forall free generated get hide lambda library local op ops pred preds result reveal sort sorts spec true type types unit units var vars version view reserved key signs 
key signs key words signs representing mathematical symbols forall exists exists 
lambda identifiers identifiers sorts variables simple words reserved words possibly containing digits primes single underscores elem long identifier sort identifiers compound list int map index elem identifier operations predicates sequences signs brackets balanced 
single decimal digits single quoted characters 
signs allowed identifiers iso latin signs general currency yen broken vertical bar registered trade mark masculine feminine ordinals left right angle quotes fractions soft hyphen acute accent umlaut 
operation predicate identifiers compound order casl quick function predicate identifiers infixes prefixes general formed words sequences signs separated double underscores indicating positions arguments brackets balanced push select invisible mixfix identifiers arguments allowed 
subsort embeddings give effect invisible unary functions 
operation predicate identifier compound list identifiers appended final token 
literal strings numbers string library identifiers names libraries paths basic numbers basic algebra ii urls formed za hexadecimal codes xx prefixed ftp 
version numbers libraries hierarchical 
comments comment line 
line comment 
comment take lines commenting text including kinds comment annotations label form text 
line annotation general form word space word 
possibly multi line annotation general form word 
space preceding 
structured specifications structured specifications specifications sp sp sm sp hide sl sp reveal sm sp spn sp spn free sp local sp sp closed sp sn sn fa fan symbol translation hiding listed symbols revealing translating listed symbols union extension free initial hiding local symbols self contained named specification instantiation generic specification named generic specifications spec sn sp spec sn sp spn sp spec sn sp spn sp sp sp named specification optional generic specification optional generic specification imports optional fitting arguments fa sp fit sm sp fv fitting symbol map implicit fitting fitting view named generic views view vn sp sp sm view vn sp spn sp sp sm view vn sp spn sp sp sp sp sm named view optional generic view optional generic view imports optional fitting views fv view vn view vn fa fan named view instantiation generic view symbol lists sl maps sm sy syn lists sorts ops preds sy sy syn sy maps sorts ops preds map abbreviates 
casl quick architectural specifications named architectures units arch spec asn asp unit spec sn usp named arch 
spec 
optional named unit spec 
optional architectural specifications asp asn units ud result ue arch 
spec 
name basic arch 
spec 
unit specifications usp sp sp spn sp closed usp arch spec asp unit specification generic unit specification self contained models arch 
spec 
unit declarations definitions ud un usp un usp ut un ue unit declaration importing units unit definition unit expressions ue ut un sp spn unit term ut unit composition unit terms ut ut sm ut hide sl ut reveal sm ut local ud ut un un ut un ut fit sm fit symbol translation hiding listed symbols revealing translating listed symbols amalgamation local units unit name generic unit application fitting symbol maps libraries libraries library ln named library specifications views ln get inn downloads listed items ln get renames downloaded items library names ln basic numbers basic algebra ii version 

version greatest version registered specified version registered greatest version unregistered specified version unregistered points bear mind 
focus cofi algebraic techniques 


cofi received funding esprit working group 

casl designed general purpose algebraic specification language 
casl center family 
casl major parts 
underlying concepts casl standard concepts algebraic specification 
basic specification declares symbols gives axioms constraints 
semantics basic specification signature class models 
casl specifications may declare sorts subsorts operations predicates 

subsorts declarations interpreted embeddings 

predicates different boolean valued operations 
operation symbols predicate symbols may overloaded 

bidoit mosses casl user manual lncs pp 

ifip international federation information processing points bear mind sort generation constraints eliminate junk specific carrier sets 
semantics structured specification simply signature 



extension specifications identifies common symbols 
free specifications restrict models free initiality 
generic specifications parameters instantiated 
semantics architectural specification reflects modular structure 
architectural specifications involve notions persistent 
semantics library specifications mapping 
getting started simple specifications may written casl essentially 
casl 
casl 
casl syntax declarations axioms involves familiar notation explanatory 
specifications easily extended new declarations axioms 
simple cases operation predicate symbol may declared intended interpretation defined time 
symbols may conveniently displayed usual mathematical symbols means display annotations 
implies annotation indicate axioms supposedly redundant consequences 
attributes may abbreviate axioms associativity commutativity idempotence 
genericity specifications explicit parameters 
generic specifications instantiate parameters 
datatype declarations may abbreviate declarations 
loose datatype declarations appropriate 



partial functions 
free specifications provide initial semantics avoid need 
free datatype declarations particularly convenient defining 
free specifications constructors 
predicates hold minimally models free specifications 
operations predicates may safely defined induction 
care may needed defining operations predicates free datatypes axioms relating constructors 
generic specifications involve free extensions loose parameters 
loose extensions free specifications avoid overspecification 
datatypes observer operations predicates specified 
def annotation useful indicate operations 
operations defined axioms involving observer operations inductively constructors 
sorts declared free specifications necessarily generated 
partial functions 
partial functions declared differently total functions 
terms containing partial functions may undefined may 
functions total ones propagate undefinedness 
predicates hold undefined arguments 
equations hold terms undefined 
special care needed specifications involving partial functions 

domains definition partial functions specified exactly 

domains definition specified explicitly 
partial functions minimally defined default free specifications 
selectors specified concisely datatype declarations 
selectors usually total constructor 

points bear mind existential equality requires definedness terms 
subsorting subsorts useful casl specifications 
subsort declarations directly express relationships carrier sets 
operations declared sort automatically inherited subsorts 
inheritance applies subsorts declared 
subsort membership checked asserted 
datatype declarations involve subsort declarations 
subsorts may arise classifications previously specified values 
may useful previously defined operations 
subsort may correspond definition domain partial function 

casting term supersort subsort explicit value cast may undefined 
may useful generalizing previously specified sorts 
may extending intended values 
structuring specifications large complex specifications easily built simpler ones means small number specification building operations 
union extension structure specifications 
specifications may combine parts loose generated free interpretations 
renaming may avoid unintended name clashes adjust names sorts change notations operations predicates 
combining specifications origins symbols indicated 
auxiliary symbols structured specifications hidden 
auxiliary symbols local need exported 


generic specifications specifying architecture implementations making specification generic appropriate improves reusability 

argument specification instantiation provide symbols corresponding required parameter 
argument specification instantiation ensure 
shared symbols argument specification body instantiated generic specification 
instantiations fitting parameter symbols identical 
fitting parameter sorts unique argument sorts 
fitting operation predicate symbols left 
intended fitting parameter symbols argument 
generic specification may parameter 
instantiation generic specifications parameters 
composition generic specifications expressed instantiation 
compound sorts introduced generic specification get automatically renamed instantiation avoids name clashes 
compound symbols operations predicates 
parameters distinguished fixed 
argument specifications implicitly regarded extension 
imports useful prevent ill formed instantiations 
generic specifications auxiliary required specifications 
views named fitting maps defined specifications 

specifying architecture implementations architectural specifications impose structure implementations specification building operations structure text specifications 
points bear mind architectural specification consists list unit declarations specifying required components result part indicating 
distinct architectural choices 
unit declaration listed architectural specification 
unit implemented specification conservative 
genericity components explicit architectural specifications 
generic component may applied argument richer specifications components named reuse 
named unnamed specifications specify components specifications generic components confused generic component may applied 
applications generic component different applications generic components similar specifications open systems described architectural specifications 
components combined best check shared symbol originates non generic component 
auxiliary unit definitions local unit definitions may libraries libraries named collections named specifications 
contained different versions library distinguished 
local libraries self contained collections specifications 
specifications refer previous items library 
display parsing literal syntax annotations apply entire libraries libraries library items author date annotations 
libraries installed internet remote access 
tools validated libraries registered public access 
libraries include appropriate annotations 
libraries include items downloaded libraries 
substantial libraries basic datatypes available 

subsequent versions library distinguished explicit libraries refer specific versions libraries 
collected library 
foundations complete presentation casl manual 
casl casl concrete syntax casl casl 
casl 
independent semantics ultimate meanings casl constructs 
proof systems various layers casl 
foundations casl solid 
tools casl specifications checked formedness form heterogeneous tool set hets main analysis tool casl 
hets parsing checking static formedness 
hets displays manages proof obligations nodes development graph correspond casl specifications 
arrows show specifications related structuring constructs 
internal nodes development graph correspond unnamed 
hol casl interactive theorem prover casl tactical theorem prover isabelle casl linked isabelle hol asf sdf prototype casl syntax points bear mind asf sdf meta environment provides syntax directed editing casl specifications basic libraries casl hets get overview basic libraries 
steam boiler control specification problem completeness text describing steam boiler control system case study originally provided jean raymond abrial reproduced additional information section see pp 

text constitutes informal specification program serves control level water steam boiler 
important program works correctly quantity water steam boiler working low high steam boiler turbine sitting front seriously affected 
proposed specification derived original text written 
bauer institute risk research university waterloo ontario canada 
original text submitted competition problem solved participants international software safety symposium organized institute risk research 
institut de protection de ret nucl aire aux roses france 
author institute risk research institut de protection de ret nucl aire kind permission text 
text follow severely biased particular implementation 
case industrial specifications rarely independent certain implementation people mind 
sense specification realistic 
formal specification steps important particular formalism allows 
words encouraged structure specification way necessarily proposed follows 
case asked demonstrate specification refined implementation close functional requirements specification proposed 
bidoit mosses casl user manual lncs pp 

ifip international federation information processing physical environment maximum gradient decrease quantity steam sec sec 
water level measurement device device measure level water steam boiler provides information quantity water steam boiler 
pumps pump characterized elements capacity sec 
functioning mode 
started having switched pump needs seconds start pouring water boiler due fact pump balance instantaneously pressure 
stopped instantaneous effect 
pump control devices pump controller provides information water circulates pump steam boiler contrary circulate 
steam measurement device device measure quantity steam comes provides information sec 
summary constants variables table summarizes various constants physical variables system steam boiler control specification problem unit comment quantity water steam boiler liter maximal capacity liter minimal limit liter maximal limit liter minimal normal liter maximal normal outcome steam exit steam boiler liter sec maximal quantity liter sec sec maximum gradient increase liter sec sec maximum gradient decrease capacity pump liter sec nominal capacity current measures liter quantity water steam boiler liter sec throughput pumps liter sec quantity steam exiting steam boiler operation program program communicates physical units messages transmitted number dedicated lines connecting physical unit control unit 
approximation time transmission neglected 
program follows cycle priori terminate 
cycle takes place seconds consists actions reception messages coming physical units 
analysis informations received 
transmission messages physical units 
simplify matters approximation messages coming going physical units supposed received emitted simultaneously program cycle 
operation modes program program operates different modes initialization normal degraded rescue emergency 
operation modes program initialization mode initialization mode mode start 
program enters state waits message steam boiler waiting come physical units 
soon message received program checks quantity steam coming steam boiler really zero 
unit detection level steam defective equal zero program enters emergency mode 
quantity water steam boiler program activates valve steam boiler order empty 
quantity water program activates pump fill steam boiler 
program realizes failure water level detection unit enters emergency mode 
soon level water reached program send continuously signal program ready physical units receives signal physical units ready necessarily emitted physical units 
soon signal received program enters mode normal physical units operate correctly mode degraded physical unit defective 
transmission failure puts program mode emergency 
normal mode normal mode standard operating mode program tries maintain water level steam boiler physical units operating correctly 
soon water level level adjusted program switching pumps 
corresponding decision taken basis information received physical units 
soon program recognizes failure water level measuring unit goes rescue mode 
failure physical unit puts program degraded mode 
water level risking reach limit values program enters mode emergency 
risk evaluated basis maximal behavior physical units 
transmission failure puts program emergency mode 
degraded mode degraded mode mode program tries maintain satisfactory water level despite presence failure physical unit 
assumed water level measuring unit working correctly 
functionality preceding case 
units defective repaired program comes back normal mode 
soon program sees water level measuring unit failure program goes mode rescue 
ifthe steam boiler control specification problem water level risking reach limit values program enters mode emergency 
transmission failure puts program emergency mode 
rescue mode rescue mode mode program tries maintain satisfactory water level despite failure water level measuring unit 
water level estimated computation done account maximum dynamics quantity steam coming steam boiler 
sake simplicity calculation suppose exactly water supplied pumps account exactly amount boiler contents thermal expansion 
calculation done unit measures quantity steam working rely information comes units controlling pumps 
soon water measuring unit repaired program returns mode degraded mode normal 
program goes emergency mode realizes cases holds unit measures outcome steam failure units control pumps failure water level risks reach limit values 
transmission failure puts program emergency mode 
emergency mode emergency mode mode program go seen vital units failure water level risks reach limit values 
mode reached detection erroneous transmission program physical units 
mode set directly outside 
program reached emergency mode physical environment responsible take appropriate actions program stops 
messages sent program messages sent program mode program sends cycle current mode operation physical units 
program ready initialization mode soon program assumes ready message continuously sent message physical units ready coming physical units received 
messages received program valve initialization mode message sent physical units request opening closure valve evacuation water steam boiler 
open pump message sent physical units activate pump 
close pump message sent physical units pump 
pump failure detection message sent receipt corresponding indicate physical units program detected pump failure 
pump control failure detection message sent receipt corresponding indicate physical units program detected failure physical unit controls pump 
level failure detection message sent receipt corresponding indicate physical units program detected failure water level measuring unit 
steam failure detection message sent receipt corresponding indicate physical units program detected failure physical unit measures outcome steam 
pump repaired message sent program acknowledge message coming physical units indicating corresponding pump repaired 
pump control repaired message sent program acknowledge message coming physical units indicating corresponding physical control unit repaired 
level repaired message sent program acknowledge message coming physical units indicating water level measuring unit repaired 
steam repaired message sent program acknowledge message coming physical units indicating unit measures outcome steam repaired 
messages received program messages received program message received times row program program go emergency 
steam boiler waiting message received initialization mode triggers effective start program 
steam boiler control specification problem physical units ready message received initialization mode acknowledges message program ready sent previously program 
pump state message indicates state pump open closed 
message transmission 
pump control state message gives information comes control unit pump flow water flow water 
message transmission 
level message contains information comes water level measuring unit 
message transmission 
steam message contains information comes unit measures outcome steam 
message transmission 
pump repaired message indicates corresponding pump repaired 
sent physical units corresponding message sent program received physical units 
pump control repaired message indicates corresponding control unit repaired 
sent physical units corresponding message sent program received physical units 
level repaired message indicates water level measuring unit repaired 
sent physical units corresponding message sent program received physical units 
steam repaired message indicates unit measures outcome steam repaired 
sent physical units corresponding message sent program received physical units 
pump failure message physical units acknowledge receipt corresponding failure detection message emitted previously program 
pump control failure message physical units acknowledge receipt corresponding failure detection message emitted previously program 
level failure message physical units acknowledge receipt corresponding failure detection message emitted previously program 
steam failure message physical units acknowledge receipt corresponding failure detection message emitted previously program 
detection equipment failures detection equipment failures erroneous kinds behavior distinguished decide certain physical units failure pump assume program sent start message pump 
program detects transmission pump indicate having effectively started stopped 
program detects pump changes state spontaneously 
pump controller assume program sent start message pump 
program detects second transmission start message pump indicate water flowing flowing despite fact program knows pump working correctly 
program detects unit changes state spontaneously 
water level measuring unit program detects unit indicates value valid static limits 
program detects unit indicates value incompatible dynamics system 
steam level measuring unit program detects unit indicates value valid static limits 
program detects unit indicates value incompatible dynamics system 
transmission program receives message presence 
program receive message presence indispensable 


abrial rger langmaack editors 
formal methods industrial applications specifying programming steam boiler control lncs vol 

springer 

astesiano bidoit krieg br mosses sannella tarlecki 
casl common algebraic specification language 
theoretical comput 
sci 

astesiano 
kreowski krieg br editors 
algebraic foundations systems specification 
ifip state art reports 
springer 

hutter mossakowski 
development graph manager maya system description 
kirchner ringeissen editors algebraic methods software technology th international conference amast saint gilles les island france proceedings lncs vol 
pages 
springer 

mossakowski 
integrating hol casl development graph manager maya 
armando editor frontiers combining systems th international workshop santa margherita ligure italy proceedings lncs vol 
pages 
springer 

bergstra heering klint 
algebraic specification formalism asf 
bergstra heering klint editors algebraic specification acm press frontier series 
addison wesley 

bidoit 
development modular specifications stepwise refinements specification language 
rattray clark editors unified computation laboratory modelling specifications tools pages 
oxford univ press 

bidoit 
algebraic specification steam boiler control system 
abrial pages 

bidoit 
gaudel 
algebraic specifications understandable 
experiment specification language 
science computer programming 

bidoit 
kreowski lescanne orejas sannella editors 
algebraic system specification development 
lncs vol 

springer 

bidoit sannella tarlecki 
architectural specifications casl 
formal aspects computing 
bidoit mosses casl user manual lncs pp 

ifip international federation information processing 
van den brand de jong klint olivier 
efficient annotated terms 
software practice experience 

van den brand van deursen heering de jong de jonge kuipers klint moonen olivier visser visser 
asf sdf meta environment componentbased language development environment 
wilhelm editor compiler construction th international conference cc genova italy proceedings lncs vol 
pages 
springer 

broy grosu hu mann st len 
requirement design specification language spectrum informal 
technical report tum tum institut informatik technische universit nchen 

burstall goguen 
semantics clear specification language 
bj rner editor software specifications copenhagen winter school proceedings lncs vol 
pages 
springer 

cerioli gogolla kirchner krieg br qian wolf editors 
algebraic system specification development survey annotated bibliography 
monographs 
shaker nd edition 

cerioli reggio editors 
trends algebraic development techniques th international workshop wadt joint cofi wg meeting genova italy selected papers lncs vol 

springer 

chen rosu venkatesan 
rule analysis dimensional safety 
nieuwenhuis editor rewriting techniques applications th international conference rta valencia spain proceedings lncs vol 
pages 
springer 

cla en ehrig 
algebraic specification techniques tools software development 
amast series computing vol 

world scientific 

cofi common framework initiative 
casl manual 
lncs ifip series 
springer 
appear 

cofi common framework initiative tools group 
home page 
www cofi info tools 

van deursen heering klint editors 
language prototyping algebraic specification approach 
amast series computing vol 

world scientific 

goguen burstall 
institutions model theory specification programming 
acm 

goguen winkler meseguer futatsugi 
jouannaud 
introducing obj 
goguen malcolm editors software engineering obj algebraic specification action 
kluwer 

guttag horning 
larch languages tools formal specification 
springer 

sannella tarlecki 
definition extended ml gentle 
theoretical comput 
sci 


ehrich wolf 
specification data types 
wiley teubner 

mossakowski 
casl semantics tools 
graf schwartzbach editors tools algorithms construction analysis sys tems th international conference tacas berlin germany proceedings lncs vol 
pages 
springer 

mossakowski 
relating casl specification languages institution level 
theoretical comput 
sci 

mossakowski krieg br 
static semantic analysis theorem proving casl 
parisi presicce editor trends algebraic development techniques th international workshop wadt italy selected papers lncs vol 
pages 
springer 

paulson 
isabelle generic theorem prover 
lncs vol 

springer 

schr der 
trustworthy specifications consistency checks 
cerioli reggio pages 

sannella 
common framework initiative algebraic specification development software progress 
cerioli reggio pages 

sannella tarlecki 
foundations algebraic specification formal program development 


sannella tarlecki 
essential concepts algebraic specification program development 
formal aspects computing 

wirsing 
structured algebraic specifications kernel language 
theoretical comput 
sci 

wirsing 
algebraic specification 
van leeuwen editor handbook theoretical computer science volume chapter 
elsevier science publishers amsterdam mit press 
list named specifications strict partial order 
total order 
total order minmax 
variant total order minmax 
partial order 
partial order 
implies hold 
monoid 
generic monoid 
non generic monoid 
generic commutative monoid 
generic commutative monoid 
container 
marking container 
generated container 
generated container merge 
generated set 
natural 
color 
integer 
natural order 
natural arithmetic 
integer arithmetic 
integer arithmetic order 
list 
set 
transitive closure 
natural bound 
set choose 
set generated 
set union 
named specifications set union 
unnatural 
set partial choose 
set partial choose 
set partial choose 
natural bound addition 
set partial choose 
natural partial pre 
natural partial subtraction 
natural partial subtraction 
list selectors 
list selectors 
list selectors 
natural suc pre 
pair 
part container 
natural partial subtraction 
generic monoid 
vehicle 
vehicle 
speed regulation 
natural subsorts 
positive 
positive arithmetic 
positive pre 
natural positive arithmetic 
integer arithmetic 
set error choose 
set error choose 
list set 
list choose 
set list 
stack 
list set 
natural partial subtraction 
natural partial subtraction 
partial order 
list order 
list order sorted 
wrong list order sorted 
list order sorted 
list order sorted 
list order nat 
nat word 
nat word 
named specifications wrong 
list order positive 
nat word 
pair 
homogeneous pair 
homogeneous pair 
table 
pair natural color 
pair natural color 
pair natural color 
pair pos 
pair pos 
table 
set list 
mistake 
set list 
wrong 
list rev 
list rev nat 
lists 
lists 
monoid 
monoid monoid 
list rev order 
list rev orders 
list weighted elem 
list weighted pair natural color 
list weighted instantiated 
list length 
list length natural 
integer total order 
integer reverse total order 
list rev orders 
list monoid 
elem 
cont 
cont diff 
req 
flat req 
system 
system 
cont diff 
inconsistent 
system system named specifications cont comp diff comp system diff comp system system set comp cont set arch cont set nat arch cont set arch cont set arch cont set nat wrong arch spec badly structured arch spec structured arch spec structured arch spec natural order numbers basic numbers nat int rat basic set map finite bag list array bintree bintree ntree named specifications value basics messages sent messages received sbcs constants preliminary sbcs sbcs state mode evolution sbcs state status evolution message transmission system failure sbcs state pump failure sbcs state pump controller failure sbcs state steam failure level failure failure detection steam level prediction pump state prediction pump controller state prediction pu prediction sbcs analysis sbcs state steam boiler control system arch sbcs arch preliminary sbcs state impl unit sbcs state arch analysis arch failure detection arch prediction index library specification names structured arch spec arch analysis arch cont set arch cont set nat arch cont set nat arch cont set arch failure detection arch prediction arch preliminary arch sbcs array badly structured arch spec bag basic numbers basic basics bintree bintree color cont cont set cont comp cont diff cont diff container diff comp diff comp elem failure detection finite flat req generated container generated container merge generated set generic commutative monoid generic commutative monoid generic monoid generic monoid homogeneous pair homogeneous pair implies hold inconsistent int integer integer arithmetic integer arithmetic integer arithmetic order integer reverse total order integer total order index library specification names level failure list list monoid list choose list length list length natural list order list order nat list order positive list order sorted list order sorted list order sorted list rev list rev nat list rev order list rev orders list rev orders list selectors list selectors list selectors list set list set list weighted elem list weighted instantiated list weighted pair natural color map marking container message transmission system failure messages received messages sent mistake mode evolution monoid monoid monoid monoid vehicle table nat nat word nat word nat word natural natural arithmetic natural order natural order natural partial pre natural partial subtraction natural partial subtraction natural partial subtraction natural partial subtraction natural partial subtraction natural positive arithmetic natural subsorts natural suc pre natural bound natural bound addition non generic monoid ntree numbers system system pair pair pair natural color pair natural color pair natural color pair pos pair pos part container partial order partial order partial order positive positive arithmetic positive pre preliminary pu prediction pump controller failure pump controller state prediction pump failure pump state prediction rat req index library specification names sbcs sbcs analysis sbcs constants sbcs state sbcs state sbcs state sbcs state sbcs state sbcs state sbcs state impl set set list set choose set comp set error choose set error choose set generated set list set partial choose set partial choose set partial choose set partial choose set list set union set union speed regulation stack status evolution steam level prediction steam boiler control system steam failure strict partial order system system system system system table wrong wrong total order total order minmax transitive closure lists lists unit sbcs state unnatural value variant total order minmax vehicle structured arch spec wrong arch spec wrong list order sorted concept index abbreviation syntax algebraic signature analysis static annotation associativity author date definitional extension display implies label literal syntax parsing precedence relative precedence architectural specification argument specification fitting asf sdf assertion definedness subsort membership associativity annotation attribute aterms attribute associativity commutativity idempotence unit author annotation auxiliary operation predicate symbol axiom basic datatypes libraries specification body specification carrier set casting cats class models closed specification system world assumption comment commutativity attribute compatibility overloading embedding renaming subsorting completeness component declaration generic application specification concept index named composition generic specification compound sort symbol operation predicate concrete syntax consequence relation conservative extension consistency checker consistent constant operation overloaded symbol constraint sort generation constructor partial current version datatype declaration enumerated free generated structured date annotation decimal notation declaration see linear visibility component datatype function partial total subsort symbol unit variable global decomposition deduction rule definedness assertion definition domain operation predicate style subsort unit definitional extension development graph disambiguation display annotation format distributed library domain definition semantic downloaded specification editor syntax directed embedding compatibility overloading line comment enumerated datatype equation existential strong error supersort evolution specification existential equation quantification expansion explicit fitting exported symbol expression unit extension conservative definitional specification fitting argument specification explicit implicit morphism symbol map fixed part formal specification verification formalization process concept index formula free datatype model specification freeness constraint function partial persistent total generated datatype specification generic component application specification composition view global variable declaration hets hiding specification revealing hol casl homomorphism idempotence attribute identity renaming ill formed instantiation implementation implicit fitting implies annotation imports inconsistent independence institution induction proof scheme inductive definition style informal requirements inherited initial model input format instantiation ill formed institution independence interpretation isomorphism junk label annotation libraries basic datatypes library current version distributed item local registered self contained development validation version linear visibility literal syntax annotation local library specification unit definition logic see institution loose specification sorted signature map symbol mathematical theory maya meaning mixfix notation model class free specification semantics morphism fitting signature specification multi line comment mutual recursion name path named specification concept index view natural semantics negation failure junk confusion principle junk principle non isomorphic models non linear visibility notation decimal number observer definition style open system operation auxiliary boolean valued predicate constant definition symbol compound overloaded constant symbol renaming overloading compatibility embedding renaming parameter specification parsing annotation partial constructor function declaration selector path name persistent function place holder precedence annotation predicate auxiliary definition symbol compound boolean valued operation principle junk name thing process formalization profile programming language proof calculus induction obligation propagate undefinedness quantification existential unique existential universal recursion mutual reduct name refinement registered library relative precedence annotation renaming compatibility overloading identity overloaded symbol specification requirements informal specification result sort reuse specification revealing hiding rewriting name thing principle satisfaction relation scheme induction selector partial total self contained library specification see closed semantic domain semantics model natural concept index static set carrier inclusion signature algebraic sorted morphism subsorted software modules sort compound generation constraint result union soundness specification architectural argument fitting basic body closed downloaded evolution extension fitting argument formal free generated generic hiding instantiation local loose model morphism named component named parameter renaming requirements reuse structured subsorted translation union unit static analysis semantics strong equation structured datatype specification subsort declaration definition membership assertion subsorted signature specification supersort symbol auxiliary compound constant declaration exported map fitting operation overloaded predicate syntax directed editor system term unit theorem prover total function declaration selector translation valued logic undefined value union sort specification unique existential quantification unit attribute declaration definition concept index expression local definition specification term universal quantification validation library variable declaration version control current library number library view generic named visibility component name linear 
