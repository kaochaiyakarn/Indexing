debugging optimised code function interpretation kim fit qut edu au programming languages systems group department computer science queensland university technology gpo box brisbane queensland australia previously debugging optimised code possible recompiling executable code preventing code optimisation techniques 
current research efforts offer partial solutions small set optimisation techniques unified approach developed overcome barriers imposed large range sophisticated optimisation techniques 
approach taken building prototype described combines program simulation interpretation techniques run time executable modification techniques provide integrated environment function level interpretation 
achieved modification existing compiler enhancement compiler debugger interface cdi allowing direct application debugger current operational environments 
describes construction gpdb debugger gardens point compiler environment 
debugger proved fundamental production interactive development environment allows optimised program run corrected modified developed need recompilation executable program resetting debugging environment 

problems associated debugging programs compiled assistance optimisation techniques severe 
literature available presents techniques minimisation difficulties limited scope readily available 
introduces gpdb gardens point debugger comprehensive debugging platform allows optimised program run corrected modified developed need recompilation executable program resetting debugging environment consider situation 
debugging session discovered particular function returning unexpected value 
logically suspected algorithm function may incorrect particular set data values supplied call 
understanding algorithm supposed plausible way test hypothesis algorithm erroneous examine verify internal computations function 
commonly done stepping statements function verifying consistency actual state execution conceptual model algorithm 
case code function optimised verification typically impossible 

compiler produces code implement function constraint correctness object code produces input output behaviour specified algorithm source code 
example legitimate compiler re order operations code instruction statement levels eliminate redundant computations place different variables storage location remove completely computations insert computations produce final values 
inherent problem observing state optimised code environment replaces functions heavy interprocedural optimisations may hinder procedural interpretation efforts require associated functions interpreted 
program points source code may corresponding point execution optimised object code 
logically optimised code modified substitution procedures 
control point view query line am responded open reply alternatively places data point view modern optimisation techniques graph colouring code motion applied question value local variable may meet open response currently value alternatively values case verifying internal workings suspect function require recompilation source code function optimisations turned full symbolic debugging support turned 
complex cases helpful edit source code function recompiling appropriate executable assertions applied check internal states computation correspond expected behaviour 
order address problem language tool implementers researchers considering options 
gain information regarding optimisation techniques resulting code modifications compiler optimiser save analysis 
provide purely interpretation system generally operating directly source code simulates running executable code controlled environment 
decompile executable program file generally data flow control flow analysis techniques generate required mappings able represent program source code 
hcu approach outlined differs techniques provides demand intermediate language interpretation functions contained program executable environment 
provides flexible environment ad hoc replacement program functions purposes bug fixing enhancement profiling 
gpdb optimised code debugging environment developed languages pascal modula provide purely executable version user source code internal language mechanisms garbage collection dynamic linking kernel function interpretation self lisp oberon 
gpdb applied environments primary purpose provide dynamic environment languages deliver autonomous program execution 
gpdb environment developed due regard supporting current debugging facilities stepping break pointing variable watching additional files bundled executable symbolic executable file format accompanying external file specially modified versions compiler optimiser required high level language machine independence 
research resulted development mechanism allows internal examination assertion insertion carried recompilation 
level functionality currently available debug platform 
sections outline requirements optimal debugging platform enable non intrusive debugging optimised code 
concepts effecting design implementation gpdb environment discussed illustrate gpdb applied advanced debugging concepts development 

local agent technology able implement tool gpdb traditional parent child process control technology see similar way debuggers gdb sdb dbx 
allows debugger interface parent process occupy separate area process memory user executable program contained child process merely communicate ptrace system call remotely bsd socket connection 
design minimised possibility side effect memory modifications easily allowing gpdb utilised distributed environment 
debugger parent process debugger interface module process control ptrace bsd socket communication child process user executable program local agent local agent architecture importantly model uses local agent process communication architecture similar manner gdb remote 
architecture provides simple self contained module incorporated user executable program purpose providing internal information program execution variables interacting executable program modify execution path 
traditionally achieved static linking local agent user target program compile time dynamic loading linking local agent user target program runtime target program loaded parent process control debugger profiler dynamic loading linking small code routine statically linked program 
routine disrupt execution user executable signal received debugger profiler process instructs load local agent establish communication target executable debugger 
invaluable ad hoc bugs 
traditional parent child interaction overhead minimised gpdb passing debugging tasks local agent child process 
allows involvement parent limited maintenance user debug interface controls sending high level user instructions child process placing removing breakpoints loading replacing functions setting variable display points 
interactions live target program conducted local agent obtaining current variable values interaction executable image interpreted module 
architecture allowed far intelligent extensible control mechanism reduces amount kernel traffic produced ptrace call 

gardens point environment gardens point environment see compiler architecture designed developed queensland university technology programming languages systems research concentration area 
enables independent maintenance development compiler front language parsers tree builders languages modula oberon sather back instruction selector produces optimised executable code range machine architectures dec mips dec alpha sun sparc intel dos intel os linux 
front tree walker back instruction selector executable dcode intermediate file gardens point environment overview architecture provides easier development platform separation front back hinders collection information debugging 
example front privileged information structure name types variables back focuses local variable memory register 
level process separation aided development intermediate language called dcode example written ascii text format completion tree walker reread instruction selector 
dcode utilises stack machine similar code code enables procedural language 
dcode offers advantage simplified memory access model provides faster data access able achieved code code providing natural map risc architectures 
code output produced gpm hello mod title hello file hello mod export import inout writeln import import inout import inout const mnam hello const hello world hello needs args 
byte ch ch fh ch byte fh ch byte ch ch fh eh byte eh fh byte proc size entry call inout call inout writeln trap gp label call label exit endp dcode produced modula hello world module hello import assert inout import inout import writeln hello world writeln assert needs args hello 
modula version hello world shows modula language version simple hello world program shows representation dcode 
dcode produced ascii format language front tree walker necessary transform compact binary format reduce tasks parsing command validation dcode interpreter contained local agent provided substantial increases speed interpretation 

gpdb architectural overview gpdb uses local agent technology implement internal modification control mechanisms totally modular approach rams development 
approach allows easier modification extension component independently seen 
parent process main symbolic reader object format reader process control debugger interface module ptrace communication child process loader dld user executable program asm stubs lib initial loadable module gpdb process components local agent local agent technology influenced design gpdb low level program interaction routines placed child process user executable program 
allowed child process consist components loader small loading routine initially executable program loaded 
establishes executable environment invokes dld local agent required 
dld dynamic linker loader originally implemented wilson ho ho ported dec mips ultrix environment allows supporting local agent routines asm stubs lib loaded area process memory executable program 
asm stubs small set assembler routines assist transition standard executable environment debug interpretation mode 
concept context switching discussed section 
lib dcode interpreter library main component local agent 
component dynamically loads binary encoded dcode code blocks memory interprets demand interacting current variable states contained executable program 
likewise parent process composed main main module gpdb interface consists subcomponents provide user command parser maintain information current breakpoints inserted display current source code line 
component forms hub user interface 
symbolic reader component transforms symbolic information available standard executable programs binary encoded dcode modules internal data structures available function variable information 
information main display user process control module pertinent memory access 
object format reader user executable program available gpdb parent child process contained machine module available obtaining symbolic information sections executable program 
process control process control component parent process functions control breakpoint insertion removal routine maintain connection child process sending receiving user commands 
inclusion symbolic reader object format reader parent process allows directly analyse executable programs binary encoded dcode intermediate language files generated demand user components parent process able symbolically represent data obtains child process real executable mode performing function interpretation 
symbolic object format readers contained lib component child process eliminated brevity 
reduces cost large data transmissions symbolic information processes done gpdb remote environment 

implementation gpdb stated problems debugging optimised code severe due fundamental problem program points source code may corresponding point execution optimised object code 
approach assumes optimised code modified substitution procedures 
allows existing compiler intermediate code utilised representation source function eliminated need concepts control flow analysis 
gle gpdb prototyped decstation machine mips microprocessor running ultrix operating system environment unmodified gardens point gp language compiler front ends 
front tree walker back instruction selector executable current compiler environment dcode intermediate file format executable image dcode ascii binary util 
binary form dcode intermediate modules overview file sources debugger gpdb implementation gpdb gardens point compiler environment shows interaction gardens point gp compiler environment gpdb 
modification front tree walker instruction selector components gp compilers development 
gpdb designed operate total debug environment 
executables loaded disk source code located displayed debugger 
source code modified limitations placed modification global variable types lengths source file passed front tree walker produce intermediate dcode ascii file module 
dcode intermediate instruction files assembled binary file format reduce overhead ascii interpretation runtime environment dcode interpretation library lib 
binary dcode file available lib load child process interpretation individual functions required parent process symbolic reader meaningful display program information 
utilising symbolic symbolic read current executable file loaded binary dcode modules parent process object symbol readers symbol reader component dcode interpreter local agent child process 
symbolic information known processes purpose totally different parent uses symbolic information meaningful display information user command requests local agent 
allows parent remain high level abstraction reduces low level interactions placed local agent contained child child process hand uses symbolic information map high level command requests parent process low level memory addresses symbolic encountered interpretation binary dcode 
machine dependent knowledge encapsulated asm stubs module local agent allowing gpdb targeted new platforms architectures symbolic environments easily 
includes easier migration model remote socket implementation removes necessity parent child process running compatible architectures 
dcode interpretation dcode interpretation module heart child process local agent similar structure language interpretation kernels written facilitate reduction stack manipulation increasing efficiency execution interpretation context switching 
reduces complexity implementation reduces overheads interpretation systems 
achieved implementing number small machine dependent jump code blocks 
code blocks able developed independently due implementation register determiner routine calculates jump code block required register rules machine number types parameters passed 
structure allowed code interpreter machine dependent register determiner jump code blocks readable easily maintained additional modules able easily provided multi platform machine independent source development environment 
breakpoint mechanism implementation foo bar stub user executable program asm stubs run dcode interpreter binary dcode blocks child process execution bar interpreted illustrates implementation breakpoint code patch placed entry point function bar contains instructions 
instruction loads specific breakpoint identifier temporary register dcode interpreter knows code block interpret performs unconditional jump routines assembler code block set stub 
function return address preserved value registers saved global structure 
execution control passed dcode interpreter run 
interpreter utilises binary dcode files previously loaded memory disk 
method implementation allowed number assembler code lines kept minimum remainder system implemented high level language reduced complexity task eliminates low level interactions debuggers difficult time consuming retarget new architecture 
execution interpretation context switching execution interpretation context switching facility heart breakpoint mechanism described user wishes switch mode operation generally ease function replacement 
facility consists number low level routines contained asm stubs dcode interpreter modules local agent child process 
transition executable live program interpretation state involves direct copy values contained registers saving structure restoration 
interpretation state context switching execution library user defined procedures called function interpreted chosen stepped user situation registers allocated procedure parameters register determiner stack placed state expected execution live program 
intended call interpretation stack restored addition returned results interpretation continued 
context switch interpretation environment back live executable control passed back point control came initial temporary register unconditional jump register save area value program counter pc register passed temporary register 
saving executable pc value allows continued execution point interruption discussed function 
inter procedural optimisations inlining currently handled 
calling routine return results placed expected 
flexibility allows total replacement function addition code execution function called function prologue 
features allow gpdb meet primary objective able modify optimised executable code run time recompiling modified set tools 

applications gpdb gpdb able function standard symbolic debugger full capabilities implementation utilised provide additional powerful facilities 
effective concepts illustrated typical debugging example 
debugging program fail running quite time user chose scan quickly source code place print statements routines presumed causing problem 
user recompiled executable debugging information turned steps previous testing process 
time different problem occurred different circumstances user edits source code adds carefully crafted diagnostic source statements program 
eventually user traces source problem updating dynamic memory structure 
user decides modify source addition suite routines viewing validation dynamic memory structure question 
routines applied various places source code utilised user ad hoc callable functions standard debug environment 
approach may able achieve result advantages debug platform gpdb viz gpdb run time environment error initially discovered lost executable compiled debugging information turned 
gpdb allows evaluation variable values minimum symbolic information available 
gpdb source code modifications addition initial print statements interrupting run time environment recompiling relinking retesting executable 
function built run time validation dynamic memory structure placed start various functions 
totally new functions just code fragment coded complex evaluation dynamic memory structure need recompiling relinking 
routines interpreted just applied function 
history provided values certain key variables execution program 
information collected validated routines providing tolerance levels variable value changes merely collection point variable information analysed formally 
function concept interpreting modified source code extended gpdb allow code assertion blocks independent function utilised program execution 
allowed suite program validation routines built time development process dcode interpreter required 
foo bar stub user executable program asm stubs run dcode interpreter binary dcode blocks user view operation gpdb shows execution function bar function foo invokes dcode interpreter 
interpreter breakpoint identifier contained patch inserted start function bar determine binary dcode block read interpreted 
interpretation commands completed interactions parent debug interface environment cleaned pre interpretation state including replacement original instructions start bar point execution returned start bar 
tracing variable states facilities gpdb proven invaluable application final debug assertions variable tracing referred data 
implemented gpdb automated conditional function prologue facility 
variable tracing allows collection variable value certain points execution program merely recording evaluation collection variable value certain points execution program provide comparison historical values 
allows interpretation certain routine successful evaluation condition tolerance level 
example variable trace applied user particular key variables suitable levels tolerance applied validation routine specified interpretation execution levels 
allowed fast broad debug testing approach applied potential easily quickly narrow user attention problem hand 
automation program testing largest problems debugging finding bug reproduction test environment 
gpdb sought reduce problem allowing maintenance run time environment dynamic patching user executable program 
test plans important record sequence form documentation level completeness test suite 
variables concerned traced values recorded approach prove laborious recording variable prone incompleteness 
facility provided gpdb allow collection input output values low level ensuring capture values 
facility allows background recording test session loading application previous set values target program allowing test session may consist test plans easily reproduced 
facility value conjunction variable tracing facility described provides automated testing environment automated validation recording facility 

current implementation gpdb solely utilises local agent technology 
gpdb migrated multi threaded environment 
allow interrogation target process need local process modification interface currently achieved ptrace 
target process stopped temporarily parent results gained interpretation returned having insert function breakpoint 
allow gpdb implemented remote debugging tool heavy modification existing implementation 

research aimed allow user modify source code function insert additional debug information available interpretation eliminating need recompilation executable allowing preservation executable state 
proven extremely useful tracking errors easily reproduced usually surface hours tedious debugging 
current systems computationally intensive techniques allow debugging specific code optimisation mechanisms gpdb utilises function level code replacement concept allows dynamic replacement removal executable code blocks interpretable modules 
addition gpdb require specially modified compilers language platform independent 
approach provides framework building run time interpretation modules allows complex evaluation run time states comprehensive debugging environment 
environment proving indispensable automation comprehensive testing environment run time resolution program bugs 

required guidance encouragement support mentors supervisors prof john gough dr john received exception 
efforts project possible 
especially acknowledge prof gough placed development dcode gardens point compiler environment 
brooks hansen simmons new approach debugging optimised code 
proceedings sigplan conference programming language design implementation sigplan notices pp san francisco california june acm press 
cifuentes gough methodology decompilation 
proceedings xix de inform tica pp buenos aires argentina august 
centro de en inform tica 
cmelik keppel shade fast instruction set simulator execution profiling 
tr 
university washington june 
debugging optimised code misled 
phd thesis tr ucsc crl 
university california santa cruz may 
gle gough interpretive debugging optimised code proceedings christchurch 
gough dcode intermediate program representation manual report available ftp fit qut edu au pub papers dcode ps 
hcu lzle chambers ungar debugging optimised code dynamic deoptimization 
proceedings sigplan conference programming languages design implementation sigplan notices 
pp san francisco california june acm press 
hennessy symbolic debugging optimised code 
acm transactions programming languages systems 
pp july 
ho ho dld dynamic link unlink editor 
university california davis 
kessler fast breakpoints design implementation 
proceedings acm sigplan conference programming language design implementation sigplan notices 
pp june 
paxson local agent architecture implementing efficient breakpoint debuggers 
cs eecs department university california berkeley 
perkins sites machine independent pascal code optimisation 
proceedings sigplan symposium compiler construction pp 
gnu debugger internal architecture 
university california davis december 
ramsey hanson retargetable debugger 
proceedings sigplan conference programming language design implementation sigplan notices pp july 
rams ramsey retargetable debugger 
phd thesis princeton university princeton nj january 
sosic tool program directing 
proceedings sigplan conference programming language design implementation sigplan notices pp june 
sosic procedural interface program directing 
software practice experiences pp july 
wirth design pascal compiler 
software practice experience 
pp 
ller debugging globally optimised programs data flow analysis 
proceedings sigplan conference programming language design implementation sigplan notices pp june 
zellweger interactive high level debugger control flow optimised programs 
proceedings acm sigsoft sigplan software engineering symposium high level debugging 
debugging optimised code expected behaviour university illinois urbana champaign 

