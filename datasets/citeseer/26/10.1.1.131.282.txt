fast optimal instruction selection tree parsing christopher fraser bell laboratories mountain avenue murray hill nj cwf research att com robert henry tera computer th st suite seattle wa tera com todd proebsting dept computer sciences university wisconsin madison wi todd cs wisc edu december overview burg program generates fast tree parser burs bottom rewrite system tech nology 
accepts cost augmented tree grammar emits program discovers linear time optimal parse trees language described grammar 
burg construct fast optimal instruction selectors code generation 
burg addresses problems addressed twig somewhat flexible faster 
burg avail able anonymous ftp cs wisc edu 
compressed shar file pub burg shar holds complete distribution 
document describes fraction burs model required burg 
readers interested detail start 
relevant documents include 
input burg accepts tree grammar emits burs tree parser 
shows sample grammar implements simple instruction selector 
burg grammars structurally similar yacc 
comments follow conventions 
text called configuration section may segments 
concatenated copied verbatim head generated parser called burm 
text second copied verbatim burm 
configuration section configures burm trees parsed client environ ment 
section define visible typedef symbol pointer node subject tree 
burm invokes copyright cfl acm define type define op label op define left child left define right child right define state label state label define panic printf start reg term assign constant fetch mul plus con constant con addr con addr plus con reg addr plus con mul reg reg fetch addr reg assign addr reg sample tree grammar read operator children node pointed invokes panic detects error 
configuration section defines operations macros implemented line implemented functions 
section diagnostics elaborates panic 
burm computes stores single integral state node subject tree 
config section define macro access state field node pointed macro required burg uses lvalue 
short usually right choice typical code generation grammars require distinct state labels 
tree grammar follows configuration section 
gives ebnf grammar burg tree grammars 
comments text text optional second treated lexically omits 
ebnf grammar quoted text appear literally nonterminal integer self explanatory term denotes identifier previously declared terminal 
fxg denotes zero instances text declares start symbol terminals operators subject trees 
terminals declared line declarations begins term 
terminal fixed arity burg infers rules terminal 
burg restricts terminals children 
terminal declared positive unique integral external symbol number 
return valid external symbol number ideally external symbol numbers form dense enumeration 
non terminals declared start symbol may declared line begins start 
text declares rules 
tree grammar context free grammar rules non terminals terminals special start non terminal 
right hand side rule called pattern tree 
tree patterns appear prefix parenthesized form 
non grammar dcl rule dcl start nonterminal dcl term identifier integer rule nonterminal tree integer cost cost empty cost integer integer tree term tree tree tree term tree tree term tree nonterminal ebnf grammar tree grammars burg terminal denotes tree 
chain rule rule pattern non terminal 
start symbol declared burg uses non terminal defined rule 
burg needs single start symbol grammars natural multiple start symbols augmented artificial start symbol derives zero cost grammar natural start symbols 
burm automatically select costs tree 
burg accepts embedded semantic actions yacc format suited intended applications 
rule positive unique integral external rule number pattern preceded 
ideally external rule numbers form dense enumeration 
burm uses numbers report matching rule user supplied routine implement desired semantic action see 
humans may select integers hand burg intended server building burs tree parsers 
burg clients consume richer description translate burg simpler input 
rules vector non negative integer costs parentheses separated commas 
cost vector omitted elements assumed zero 
burg retains elements list 
cost derivation sum costs rules applied derivation 
arithmetic cost vectors treats member vector independently 
tree parser finds cheapest parse subject tree 
breaks ties arbitrarily 
default burg uses principal cost cost vector defaults element options described provide alternatives 
output burm traverses subject tree twice 
pass runs bottom left right visiting node exactly 
node labeled state single number encodes full partial optimal pattern matches viable node 
second pass reducer traverses subject tree top 
reducer accepts tree node state label goal non terminal initially root state label start symbol combine determine rule applied node 
construction rule goal non terminal left hand side 
rule pattern identifies subject subtrees goal non terminals recursive visits 
subtree necessarily immediate child current node 
patterns interior operators cause reducer skip corresponding subject nodes reducer may proceed directly grandchildren great grandchildren 
hand chain rules cause reducer revisit current subject node new goal non terminal regarded subtree reducer visits possibly revisits node user supplied code implements semantic action side effects controls order subtrees visited 
self contained reducer combines code burg code user burm stand 
burm generated burg provides primitives labelling reducing trees 
mechanisms compromise expressibility abstraction simplicity flexibility efficiency 
clients may combine primitives traverse trees arbitrary ways may call semantic routines wish traversal 
burg generates higher level routines implement common combinations primitives generates mechanisms help debug tree parse 
burg generates function named signature extern int burm label type labels entire subject tree pointed returns root state label 
state zero labels unmatched trees 
trees may corrupt merely inconsistent grammar 
simpler code traverse tree read write fields 
may integrate labelling user supplied traversal code 
typical signature extern int burm state int op int int accepts external symbol number node labels node left right children 
returns state label assign node 
unary operators argument ignored leaves arguments ignored 
general burg generates accepts maximum number child states required input grammar 
example grammar includes binary operators signature extern int burm state int op int feature included permit expansion operators children 
user write reducer burm writes code data help 
primary extern int burm rule int state int accepts tree state label goal non terminal returns external rule number rule 
rule matched tree goal non terminal left hand side returns zero tree labelled state match goal non terminal 
initial root level call burm exports array identifies values nested calls extern short burm nts 
array indexed external rule numbers 
element points zero terminated vector short integers encode goal non terminals rule pattern left right 
user needs write complete reducer third external simplifies applications extern type burm kids type int type kids accepts address tree external rule number empty vector pointers trees 
procedure assumes matched rule fills vector subtrees sense described reduced recursively 
kids returned 
zero terminated 
simple user code labels fully reduces subject tree reducer prints tree cover 
defined 
parse type burm label label tree reduce reduce reduce type int int indent int burm rule state label matching rule number short nts burm nts subtree goal non terminals type kids subtree pointers int indent printf print indented 
printf burm string text rule burm kids kids initialize subtree pointers nts traverse subtrees left right reduce kids nts indent print recursively reducer may recursively traverse subtrees order may interleave arbitrary seman tic actions recursive traversals 
multiple may written implement multi pass algorithms independent single pass algorithms 
non terminal burg emits preprocessor directive equate integral encoding 
defines macro equivalent 
grammar burg emits define burm reg nt define burm con nt define burm addr nt define burm reg rule 
define burm con rule 
define burm addr rule 
symbols visible code second 
symbols needed extract burm source 
option directs burg emit encoding input may help user produce diagnostics 
vectors extern char burm extern char burm arity hold name number children respectively terminal 
indexed terminal external symbol number 
vectors extern char burm string extern short burm cost hold text cost vector rule 
indexed external rule number 
zero terminated vector extern char burm indexed holds name non terminal procedures extern int burm op label type extern int burm state label type extern type burm child type int index callable versions configuration macros 
implements implements 
sample grammar independent expression yields textual name operator tree node pointed complete tree parser assembled just configuration section panic 
generated routines rest configuration section compiled configuration section defines omitted user prefers hide tree structure burm 
course may wise say tree structure defined large header file symbols collide burm 
burm selects optimal parse dynamic programming compile time 
burg dynamic programming compile compile time builds burm 
consequently burm parses quickly 
similar taken instructions node node visited 
debugging burm invokes panic error prevents proceeding 
panic signature printf 
pass arguments printf diagnostics desired abort say exit recover say longjmp 
returns burm aborts 
errors caught 
burg assumes robust preprocessor omits full consistency checking error recovery 
burg constructs set states closure algorithm lr table construction 
term const plus reg green reg reg red reg green reg const green reg plus green reg green reg red reg const red reg plus red reg red reg diverging tree grammar burg considers possible trees generated tree grammar summarizes infinite sets trees finite sets 
summary records cost trees manipulates dif ferences costs viable alternatives dynamic programming algorithm 
elaborates 
grammars derive trees optimal parses depend arbitrarily distant data 
happens burg tree grammar cost diverge burg attempts build infinite set states ultimately exhausts memory exits 
example tree grammar diverges non terminals derive identical infinite trees different costs 
cost rule changed grammar diverge 
practical tree grammars describing instruction selection cost diverge infinite trees derived non terminals model temporary registers 
machines move data different types registers small bounded cost rules instructions prevent divergence 
example included rules move data red green registers grammar diverge 
machine grammar appears burg loop try host memory 
apply burg problems instruction selection prepared consult literature cost divergence 
running burg burg reads tree grammar writes burm burm compiled included file 
suitably named option disjoint instances burm link name conflicts 
command burg arguments file invokes burg 
file named burg expects grammar reads standard input 
options include abort relative cost exceeds keeps burg looping diverging grammars 
explain relative costs 
report statistics flag unused rules terminals 
file write parser file 
writes standard output 
prefix start exported names prefix 
default burm 
generates smaller tables faster goal non terminals passed come appropriate 
may give unpredictable results 
emit code 
change principal cost elements cost vector numbered zero 
compare costs lexicographically costs order 
option slows burg may produce larger parser 
increases range small astronomical 
burg adapted second author codegen package developed university washington partial support nsf ccr 
codegen support tera computer 
current burg written third author support nsf ccr 
interface documentation testing involved authors 
comments large group dagstuhl seminar code generation improved burg interface 
robert giegerich susan graham organized workshop interna tional conference research center computer science schloss dagstuhl provided ideal environment collaboration 
beta testers included helmut dave hanson john hauser hugh bill waite 
alfred aho mahadevan ganapathi steven tjiang 
code generation tree matching dynamic programming 
acm transactions programming languages systems october 
alfred aho steven johnson 
optimal code generation expression trees 
journal acm july 
andrew appel 
concise specification locally optimal code generators 
technical report cs tr princeton university 
balachandran dhamdhere biswas 
efficient retargetable code generation bottom tree pattern matching 
computer languages 
urgen ulrich reinhard wilhelm 
table compression tree automata 
technical report informatik berichte rwth aachen infor aachen fed rep germany 
david chase 
improvement bottom tree pattern matching 
fourteenth annual acm symposium principles programming languages pages january 
christopher fraser robert henry 
hard coding bottom code generation tables save time space 
software practice experience january 
philip hatcher thomas christopher 
high quality code generation bottom tree pattern matching 
thirteenth annual acm symposium principles programming languages pages january 
robert henry 
encoding optimal pattern selection table driven bottom tree pattern matcher 
technical report university washington computer science department seattle wa february 
christoph hoffmann michael donnell 
pattern matching trees 
journal acm january 

tree templates subtree transformational grammars 
phd thesis uc santa cruz december 
eduardo 
tree transformations compiler systems 
phd thesis uc ley december 
eduardo susan graham 
optimal code generation expression trees application burs theory 
fifteenth annual acm symposium principles program ming languages pages january 
todd proebsting 
simple efficient burs table generation 
technical report department computer sciences university wisconsin 

