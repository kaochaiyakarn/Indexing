enhanced chord system resilient routing attacks dong xuan sriram krishnamoorthy department computer information science ohio state university columbus oh propose variant chord system resilient routing attacks 
routing attacks mean attacks detour looking messages aiming disrupt performance data look systems increasing path length queries 
chord routes messages uni directionally bi directional edges 
performance absence routing attacks acceptable degrades dramatically routing attacks 
observation introduce concept reverse edges chord system 
named new chord system 
propose deterministic randomized algorithms construct reverse edges 
design routing algorithm new system simple efficient backward compatible original system 
analyze performance routing attacks 
find performance significantly improved terms average path length adding reverse edges 
peer peer networked system individuals participate construction independent network 
network centralized decentralized meaning network constructed central authority 
system performs application level routing top ip routing 
organization network classified structured unstructured 
structured systems nodes organize orderly fashion unstructured systems nodes organize randomly 
structured systems efficient lookup mechanism means distributed hash tables dhts unstructured systems broadcast search technique 
literature newly developed architectures places emphasis construction operation maintenance systems presence benign trustworthy participating nodes 
operation presence malicious nodes considered 
reasonable participating nodes isolated network 
case internet 
authenticity nodes administered central authorization authority recommended pastry 
undermine basic features systems 
situations desirable constrain membership system 
system able operate presence malicious nodes 
step systematically studying performance structured system presence malicious nodes choose study resilience chord 
resilience mail xuan cis ohio state edu mean ability system maintain performance levels presence compromised nodes performance metric average path length queries 
focus study resilience chord popular structured system 
chord salient features distinguish known systems 
chord employs uni directional routing mechanism 
substantially complicated handles concurrent node joins failures 
data lookups efficient available data guaranteed 
fact chord better features high probability resolves data look ups path length nodes node system 
proving property authors consider effect malicious forwarding 
chord designed operation internet scales need case path length highly impacted presence malicious nodes 
study propose enhancement resilience routing attacks current chord system focusing average path length taken queries analyze impacted presence malicious nodes 
study impact uni directional routing resilience 
findings propose improve resilience introducing concept reverse edges chord system 
name new chord system 
propose classes reverse edge adding algorithms deterministic comprises mirror uniform local remote combination algorithms random local remote combination randomization algorithm 
due existence reverse edges enhanced chord system routing behavior different original chord system 
design routing algorithm new system simple efficient backward compatible original system 
analyze performance new chord system routing attacks 
find performance significantly improved adding reverse edges 
system achieve performance efficiency greater intensive attack conditions 
find different reverse edge construction algorithms different impacts performance vary intensity attack changes described 
organized follows 
section briefly describe chord compare known systems introduce impact malicious nodes 
section introduce system describe semantics 
section analyze system compare resilience respect original chord system 
section provides reader overview related section gives concluding remarks 
ii 
background motivation section provide brief chord routing mechanism sake clarity ease understanding 
compare similar systems give brief description popular structured peer peer systems 
proceed describe motivation doing study 
chord chord uses single dimensional circular key space node responsible key analogous data node identifier equals closely follows key numerically node called key successor 
node chord maintains sets neighbors 
node successor list nodes immediately follow key space 
neighbor list node called finger table constructed nodes distances powers nodes distances mod node system form entries finger table shown 
node maintains entries finger table number bits node key identifier space node key identifiers generated hash functions 
nodes placed chord finger table node keys start int 
succ 
finger table node keys start int 
succ 
finger table node keys start int 
succ 
fig 

simple chord network finger tables nodes 
illustrate routing semantics chord consider 
nodes chord system 
consider keys 
definition node successor key node successor key node successor key 
show corresponding finger table node 
order search key node query currently located searches finger table find node immediately precedes asks node search 
repeating process node ultimately finds successor key 
illustrate node wants search key checks finger table find closest node immediately precedes key 
interval int column finger table node 
node contacts node 
node checks finger table finds successor node contain required key 
information fed back node 
routing done past key 
technique routing technique high probability data look ups resolved path length event failures chord protocol runs 
stabilization algorithm uses successor list recover failures 
special feature routing process different structured systems routing uni directional chord example routing done direction 
feature prominently studying 
structured peer peer systems sylvia proposed content addressable networks distributed infrastructure provides hash table functionality internet scales 
models participating peers zones dimensional toroidal space 
node associated hyper region key space neighbors nodes associated adjoining 
routing consists forwarding neighbor closer key toroidal space 
dimensional space partitioned equal zones average routing path length hops individual nodes maintain neighbors 
systems multiple paths exist points space node neighbors crash node automatically route best available path 
pastry pastry nodes responsible keys closest numerically keyspace considered circle similar chord 
neighbors consist set closest nodes half larger half smaller 
correct necessarily efficient routing achieved leaf set 
achieve efficient routing pastry set neighbors spread key space 
routing consists forwarding query neighboring node longest shared prefix key case ties node identifier numerically closest key 
pastry event node failures uses algorithm discussed 
tapestry tapestry overlay location routing infrastructure provides location independent routing messages directly closest copy object service point point links centralized resources 
nodes maintain routing table called 
routing nodes follow longest prefix routing similar cidr ip address allocation architecture 
tapestry location mechanism similar plaxton location scheme semantic flexibility 
motivation motivation study resilience chord system due combination simplicity clarity design coupled vulnerability attacks 
chord offers lot desirable features minimal complexity 
chord robust partial node failures node join leave process simpler 
chord requires minimal maintenance overhead cases 
system performance gracefully degrades situations lack sufficient information routing 
presence malicious nodes chord quite fragile 
focus resilience chord system attacks aiming increase average path length queries fundamental performance metric 
average path length average number hops taken query locate desired key system 
malicious node cause malfunctioning system ways 
sophisticated completely characterize effects malicious node 
critical effects malicious node increasing path length queries 
types attacks increase path length taken queries incorrect routing adhering protocol rules ordinated attacks nodes query toggle back forth path length theoretically infinite 
analyze simple albeit effective attack model malicious node forwards query node farthest destination 
possible attack models model potentially maximum damage system 
type attack performed malicious node 
attack model applied study resilience pastry systems 
focus average path length proposed attack model process designing complicated attack models test chord structured system resilience metrics apart just average path length 
compare average path lengths chord pastry attack model 
system size number nodes set 
axis probability node chord system performs attack 
node receives query forward probability behave malicious node forward query node farthest intended destination 
assume nodes reality case different different nodes 
argue performance system highly representative structured systems study symmetric focus average performance 
protocols simulated recursive fashion similar described original chord algorithm 
clearly see impact direction routing chord resilience 
dimension set respectively system sizes analyzed 
seen chord performs normal conditions performance degrades dramatically cases hostile conditions 
chord average path length dim chord pastry average path length dim chord pastry fig 

impact direction performance evaluation super malicious routing 
susceptible hostile attacks compared pastry 
primarily uni directional routing mechanism chord 
pastry support bi directional routing 
query overshoots destination benign node able correctly route backtracking destination case pastry possible chord 
believe chord resilience greatly improved incorporating bi directional routing 
section propose enhance chord support bidirectional routing systematically adding reverse edges analyze performance system 
iii 
enhancing chord reverse edges overview concept unidirectional routing chord misused routing attack 
alternative unidirectional routing routing take place forward normal chord node reverse direction depending proximity destination 
request overshoots crosses destination due attack receptor node return request correct node reverse direction minimizing path length query point making system resilient attacks 
face issues add reverse edges routing table 
routing reverse edges 
subsections address issues detail 
adding reverse edges formally described follows simple approach adding reverse edges include node reverse neighbors mod nodes mirror nodes nodes 
call algorithm routing table normal chord node 
obviously uniform algorithm reason explained 
reverse edges lead better performance ii illustrates algorithm 
node introduce overhead redundancy reverse neighbors mod mod 
edges 
believe significant performance improvement local remote combination algorithm achieved adding reverse edges 
final approach propose deterministic section focus adding constant number reverse edges local remote combination algorithm 
algorithm propose approaches add 
broadly attempts follow idea cooperation local classify deterministic randomized algorithms 
edges remote edges 
observations section intuitive see kind deterministic algorithm add reverse edges cooperation improve performance considerably 
approach nodes reverse edges point add edges close current node add determined system parameters example remote distance 
chosen alternatively 
example system size 
way current chord system adds edges reverse edges introduced combination deterministic 
node fixed set neighbors local ones remote 
reverse edges located predetermined distances relative node 
introduced local ones remote enables simpler routing procedure little overhead com ones 
gives formal description algorithm putation 
fact design deterministic node reverse neighbors mod approaches add reverse edges chord 
proceed discussion algorithm define 
iii notation reverse neighbors simplify description illustrate simplest case reverse edges node said reverse neighbor node reverse closer node farther node reverse edge node points node 
direction 
node local reverse neighbor mirror algorithm simple algorithm remote reverse neighbor 
add reverse edges straight extension chord algorithm 
algorithm reverse edges node mirrors fingers clock wise edges input system size number original chord system node system 
reverse edges current node id algorithm formally described 
inputs output reverse neighbors algorithm system size number peers system number nodes mod mod reverse edges algorithm mirror algorithm determines reverse neighbors node follows mod 
node reverse neighbors mod uniform algorithm 
call algorithm mirror algorithm 
illustrates simple 
algorithm 
system size local remote combination algorithm number reverse edges system node mod reverse neighbors 
sake clarity nodes close node shown 
uniform algorithm mirror algorithm easily extended 
note chord assume system size node nodes id mod mod mod mod 
local remote random algorithm mod probability node odd follows selected node finger neighbors 
words node finger neighbors fig 

algorithms adding reverse edges chord system distributed uniformly space scale 
benefit section extend local remote combi approach average path length nation algorithm introducing concept randomization 
situation number reverse edges constant adding remote edges 
number say 
divide uniformly space randomized algorithm add reverse edges sections sections 
algorithm section approach add reverse edges note algorithms inputs 
avoid nodes randomly selected 
basic motivations redundancy describe parameters describing follows randomly selected reverse edges algorithms 
note figures size system number reverse edge numbers 
describe parameters examples 
difficult highly destructive attack cause extensive damage 
efficient way add edges get performance benefits 
mod mod mod mod mod remote neighbor finger neighbor node mirror routing approach ii 
uniform routing remote neighbor finger neighbor node iii 
local remote combination approach iv 
local deterministic remote random combination approach fig 

reverse edge adding algorithms mod remote neighbor finger neighbor node remote neighbor finger neighbor local remote combination algorithm randomization random algorithm local reverse neighbors selected way algorithm remote reverse neighbors selected random fashion 
specifically probability node selected remote reverse neighbor proportional distance current node node 
algorithm node far away current node higher probability chosen remote node 
sense algorithm similar deterministic local remote combination algorithm 
nodes closer current node probability selected expect performance different deterministic 
formal description algorithm 
call algorithm random algorithm 
iv illustrates random algorithm 
node local edge point remote edge may point node node node probability mod 
introducing reverse edges deterministic random approaches follows protocol chord discovering maintaining reverse edges 
discovering reverse edges location remote edges determined algorithm 
maintaining reverse edges node leaves system immediate successor reverse direction takes responsibility node just normal chord deterministic case random case node chooses replacement algorithm discussed 
node routing need extend chord routing algorithm consider reverse edges 
chord routing algorithm greedy 
receiving request peer pick node neighbors closest destination clock wise direction 
algorithm simple robust 
extended algorithm merits 
important algorithm backward compatible original chord 
reverse edge new algorithm equivalent original 
simple extension picking neighbor forward reverse neighbors closest destination directions 
example enhanced chord system nodes reverse edges 
set source destination respectively 
assume algorithm adding reverse edges 
simple algorithm node remote reverse neighbor node selected closest destination node forward reverse neighbors 
algorithm simple compatible original algorithm efficient 
basic reason asymmetry clock wise edges reverse edges 
example illustrate inefficiency extension 
example find node reverse neighbor node closer destination forward neighbor node routing node take hops hops reach destination node hops 
fig 

erroneous routing reverse neighbor forward neighbor example conclude extension consider asymmetry forward edges reverse edges 
need estimation routing capabilities forward edges reverse edges 
forward reverse edges may achieve performance 
routing algorithm consider kind scenario 
cooperation types edges comprehensive 
considering possible cooperation schemes lead algorithm complicated robust dynamic systems 
care taken balance complexity efficiency 
consideration mind design routing algorithm source node node enhanced chord system 
algorithm system different reverse edge adding algorithms 
inputs current node destination outputs hop routing number hops taken node 
find forward neighbors closest destination forward reverse direction 
find reverse neighbors closest destination reverse forward direction say 
compute number hops taken candidates return uni forward routing uni reverse routing uni forward routing uni reverse routing min node min hops fig 

routing algorithm enhanced chord system algorithm functions estimate average number hops node node assuming edges routing 
pseudo codes uni direction routing functions appendix routing algorithm returns values hop node route query number hops query needs route node node destination 
define enhanced chord distance node node 
take example illustrate algorithm 
set source destination node node node 
node considered calling function routing decision 
iv 
analysis system section analyze impact introducing reverse edges chord system 
particularly analyze impact different reverse edge adding algorithms mirror uniform local remote combination local remote combination randomization random chord system draw important act guidelines designing robust chord system 
iv shows comparison performance average path length different system sizes varying intensity attacks different 
reverse edge size fixed cases 
figures observations compared original chord system resilience system improved significantly partic random algorithms 
prominent intensity attack increases 
example case system nodes performance efficiency random algorithms respectively 
intensity attack performance efficiencies increasing drastically respectively times ideal condition 
easy believe effect having constant number reverse edges decrease increase system size 
results show significant decrease degree performance 
explained fact system size increases reverse nodes constant number different positions relative node having reverse edges nodes 
position reverse edges influences performance algorithms 
comparing performance systems different algorithms find performance 
algorithm node node mirror algorithm poor ones algo selected hop node node rithms vary depending different value enhanced chord distance node node 
performance system note routing algorithm features different algorithms similar 
compatible original chord routing algorithm sense reverse edge 
candidate node selected hop know node selected original chord routing algorithm 
considers cooperation forward reverse edges 
algorithm neighbors performance system better random outperforms 
observation explained fact uniform algorithm system covered edges including reverse edges forward edges 
mild attack conditions considered hop 
node selected regular routing mechanism functions 
query routed forward direction may coverage system edges help achieve routed close destination reverse direction 
performance 
case similar node selected 
performance system algorithm limits simple scenario routing better random chance change direction difference outperforms explained routing capacity forward reverse edges fact large chance regular routing reach destination small 
query nodes system due super routing attack 
algorithm remote reverse edge useful redirect query node closer destination local reverse edge supplement remote reverse edge send query destination 
related lot current ongoing research area improving security features systems 
discuss closely related 
emil sit robert morris discussed security considerations systems 
propose set design principles systems stronger secure attacks 
pipe information preservation exchange network designed cooper attempts protect data stored environment malicious nodes replication mechanisms 
systems lockss archival intermemory replication mechanisms similar pipe prevent denial service attack certain extent 
replication systems poet provide security setting access rights data available system 
certain systems cfs uses node id hash node ip address preventing malicious 
clone chord known proposed provide censorship resistance 
design inspired architecture freenet unstructured system 
systems interesting try provide security framework data replication access control mechanisms imposed data system 
focus study impact basic system design features resilience 
able point malicious nodes take advantage semantics system show significantly improve performance minimal changes system design 
vi 
final remarks studied resilience average path length chord routing attacks 
pointed importance bi directional routing 
proposed enhanced chord system reverse edge adding approaches routing algorithm 
enhanced system simple efficient sense outperforms significantly original chord system terms average path length routing attacks reverse edges 
feature system backward compatible original chord system 
directions extend study potentially interesting theoretically prove features reverse edge adding algorithms derive algorithm give optimum performance 
extend study peer peer systems types attacks example dropping cooperative routing attacks 
include metrics apart just average path length study 
rowstron druschel pastry scalable distributed object location routing large scale peer peer systems 
ifip acm international conference distributed systems platforms middleware heidelberg germany pages november 
ratnasamy francis handley karp shenker scalable content addressable network 
proc 
acm sigcomm 
stoica morris karger kaashoek balakrishnan chord scalable peer peer lookup service internet applications 
proc 
acm sigcomm august 
zhao kubiatowicz joseph tapestry infrastructure fault tolerant wide area location routing technical report ucb csd university california berkeley 

plaxton rajaraman richa accessing nearby copies replicated objects distributed environment 
proceedings acm spaa 
acm june 
sylvia ratnasamy scott shenker ion stoica routing algorithms dhts open questions 
proc 
iptps march 
andrew tenenbaum maarten van steen distributed systems principles paradigms prentice hall st ed 
ravindran don phillips james operations research principles practice nd edition john wiley sons 
randolph nelson probability stochastic processes queueing theory mathematics computer performance modelling springer verlag 
dong xuan krishnamoorthy wang enhanced chord technical report technical report department computer information science ohio state university columbus www cis ohio state edu xuan 
motwani raghavan randomized algorithms cambridge university press cambridge 
sit morris security considerations peer peer distributed hash tables proc 
iptps 
cooper bawa daswani garcia molina 
protecting pipe malicious peers technical report stanford 
reich rosenthal lockss lots copies keep stuff safe preservation nov 
chen prototype implementation archival intermemory proc 
acm conf 
digital libraries 
lagoze 
policy carrying policy enforcing digital objects proc 
european conf 
digital libraries ecdl 
dabek wide area cooperative storage cfs proc 
acm symposium operating systems principles 
wiley 
variant chord lookup service censorship resistant peer peer publishing systems proc 
iptps 
clarke freenet distributed anonymous information storage retrieval system designing privacy enhancing technologies international workshop design issues anonymity unobservability 
appendix uni directional routing functions section provides pseudo code unidirectional forward reverse routing functions 
functions determine hops assumption routing take place direction 
relatively easy deterministic edges 
harder randomized edges 
regarded merits approach difficult attacker super attack strategy 
randomized edges algorithm simple assumption node assumes node random reverse edge distance random reverse edge 
average path length average path length average path length average path length chord lr random chord lr random pr ii chord lr random pr chord lr random pr iii iv fig 

performance evaluation enhanced chord system super routing attack 
pr input source node destination node system size number reverse edges output node number hops need taken node node uni forward routing mod compute factors add dist return uni reverse routing array location reverse neighbors determined reverse edge adding algorithms mod return fig 

routing functions 
