polymorphic pi calculus theory implementation david turner ph 
university edinburgh investigate calculus able serve foundation design implementation strongly typed concurrent programming language 
half dissertation examines calculus supports simple type system flexible provide suitable foundation type system concurrent programming language 
second half dissertation considers implement calculus efficiently starting machine calculus presenting compilation calculus start dissertation presenting simple structural type system calculus proving soundness type system show infer principal types terms 
simple type system extended include useful type theoretic constructions recursive types higherorder polymorphism 
higher order polymorphism important gives ability implement datatypes type safe manner providing greater degree modularity calculus programs 
functional computational paradigm plays important part programming languages 
known calculus encode functional computation 
go show type structure terms preserved encodings sense relate type term type encoding calculus 
means calculus programming language genuinely support typed functional programming special case 
efficient implementation calculus necessary wish consider calculus operational foundation concurrent programming 
give simple machine calculus prove correct 
show machine inspires simple efficient compilation calculus forms basis pict programming language implementation 
express gratitude robin milner supervisor excellent guidance encouragement 
go friends department computer science edinburgh time studying edinburgh profitable enjoyable 
joint benjamin pierce pict programming language great help developing theoretical practical parts dissertation 
consider fortunate able collaborate benjamin enjoyable project hope dissertation serves foundation pict type system implementation pict 
jointly supported science engineering research council limited 
am indebted phil wadler giving time finish dissertation working university glasgow 
declaration dissertation composed 
ideas results contained stated 
contents polyadic calculus 


polymorphism 
relating typed terms typed terms 
machine calculus 
compiling pict 

polyadic calculus syntax 
semantics 


runtime failure monadic calculus 


booleans 
lists 
process cells 
channel 
process typing 
contents 


booleans 
process cells 
channel 
properties typed terms 

type soundness 

substitutions 
unification 



encoding monadic calculus 
properties 

type soundness 
polymorphism 


process cells 
channel 
lists 

type soundness 
relating typed terms typed terms encoding terms 
contents call 
expressions 
call 
call 
encoding 
call 
call 

encoding polymorphic terms 
damas 
call 
call 
machine calculus 




simplifying replicated input 
asynchronous communication 



environments efficiently 
compiling pict design 



closures 
channels 

contents compiling pict implementation 


atoms 










replicated input expressions 
input expressions 


performance 
related 


implementation 
bibliography chapter calculus mpw mpw mpw process calculus able describe dynamically changing networks concurrent processes 
example process network shown 
network models mobile telephone ground stations 
describe telephone switch ground station need able change communication topology network unlinking telephone station linking second 
telephone able accept messages existing links tell access ground stations 
car travels region region details closer ground stations may transmitted phone enabling reroute communications closest station 
control centre control centre active agents calculus processes exchange information channels 
process form outputs value channel continues communication synchronous prevented executing communication completed 
similarly chapter 
process waits receive value continuing value received substituted formal parameter 
calculus literature variations syntax input output syntax similar pict programming language pt :10.1.1.127.1777
processes may run parallel parallel composition operator enabling interactions 
example processes wish communicate channel interaction possible symbol denote process reduction denote substitution 
style synchronous rendezvous process calculi including ccs mil mil value passing ccs mil mil 
predecessors calculus channels provide means communication values exchanged communication 
dissertation investigates calculus able serve foundation design implementation strongly typed concurrent programming language 
half dissertation examines calculus supports simple type system flexible provide suitable foundation type system concurrent programming language 
second half dissertation considers implement calculus efficiently starting machine calculus presenting compilation calculus sections summarise contents dissertation 
polyadic calculus input output primitives calculus monadic exactly channel exchanged communication 
polyadic calculus mil useful extension calculus allows atomic communication tuples channels 
additional structure introduced polyadic communication important raises possibility runtime failure tuple chapter 
sent channel may length tuple expected receiver 
monadic calculus corresponding operational notion runtime failure encode polyadic communication 
chapter give syntax semantics polyadic calculus show encoding polyadic calculus monadic calculus destroys operational notion runtime failure 
convenient derived forms examples shall appear chapters 
process typing formal simplicity calculus ideal foundation construction type systems sequential programming languages 
believe calculus play similar role construction type systems concurrent programming languages 
chapter show polyadic calculus admits simple typing discipline easily extended include useful type theoretic constructions recursive types polymorphism 
show typing rules behave examples derived forms chapter prove means subject reduction theorem type system guarantees freedom runtime errors 
simplicity calculus type system allows infer types automatically 
benefits automatic type inference clearly demonstrated languages standard ml mth haskell programmer write minimum explicit type information 
similar unification techniques infer types terms 
recursive types useful programs assigned type calculus 
similarly useful calculus programs assigned type simple type system 
important deficiency support programming recursive datatypes example lists trees 
chapter simple solution problem recursive types 
fact calculus recursive types typed calculus chapter 
expressive untyped monadic calculus assign type monadic term 
polymorphism common disadvantage simple type systems prevent common programming errors disallow useful intuitively correct programs 
polymorphic type systems overcome problem allowing generic operations operations safely applied different types argument 
list operations reversing concatenation examples generic operations act completely independently types elements lists 
extra flexibility offered polymorphic type system allow natural style programming type system perceived getting way 
chapter define explicitly typed polymorphic type system calculus arises natural extension simple type system chapter 
illustrate utility polymorphic types calculus programming number examples show polymorphic channels model datatypes type safe manner 
prove type system sound techniques similar prove soundness monomorphic type system 
relating typed terms typed terms type system constructed type theoretic techniques borrowed calculus natural ask precise relationship typed terms typed terms 
milner mil shown encode various calculus reduction strategies calculus 
chapter show type structure term preserved encodings 
fact cases prove principal type term directly related encoding principal type calculus 
interesting feature encodings presence chapter 
polymorphism don 
example find damas milner type system dm agree calculus type system types term may inhabit 
surprising familiar ml known damas milner polymorphism unsafe presence side effects tof 
calculus nature calculus containing side effects better allow kind polymorphism damas milner type system 
fact find soundness damas milner type system closely connected precise evaluation order result discovered leroy ler encodings calculus 
find call value encoding calculus preserve damas milner type structure call name encoding 
machine calculus calculus implemented efficiently clearly serve flexible intermediate language compilers concurrent languages view diverse high level constructs shown encodable calculus 
example calculus encode higher order communication communication processes channels san san structured datatypes mil mutable data concurrent objects wal calculus mil 
chapter describe machine calculus simple realistic 
fact chapters compilation calculus directly machine chapter 
machine calculus introduces basic mechanisms process creation channel creation communication 
prove reductions machine correspond valid calculus reductions 
number refinements machine source language 
particular record variable bindings explicitly environments substitution operation basic operations machine simple efficient implemented directly 
chapter 
compiling pict primary motivation pict pt project design implement high level concurrent language purely terms calculus primitives :10.1.1.127.1777
proposals concurrent languages car hol rep mat gmp include communication primitives similar calculus 
knowledge proposed calculus primitives sole mechanism computation 
pict language consists layers simple core calculus just calculus extended built structured data high level language defined translation core calculus 
chapters describe efficient compilation core pict compilation implemented forms part pict programming language implementation 
compilation surprisingly quite simple designed exploit information provided number program analyses 
compilation thought refined description machine section explicit exact representation runtime data implementation operations environment lookup 
useful information labelled items definitions lemmas theorems labelled cis chapter item occurs indicates item th labelled item chapter 
familiarity ccs calculus helpful readers dissertation 
useful background reading mil mpw mpw mpw mil mil 
implementation pict programming language referred previously available electronically 
distribution includes manual tutorial number examples windows programs written pict 
dissertation available online 
chapter polyadic calculus input output primitives calculus monadic exactly channel exchanged communication 
polyadic calculus mil useful extension calculus allows atomic communication tuples channels 
additional structure introduced polyadic communication important raises possibility runtime failure tuple sent channel may length tuple expected receiver 
monadic calculus corresponding operational notion runtime failure encode polyadic communication 
give syntax semantics polyadic calculus show encoding polyadic calculus monadic calculus destroys operational notion runtime failure 
syntax syntax polyadic calculus definition 
require arguments summation operator input prefixes output prefixes nil process 
commonly known guarded summation non trivial term summation guarded input output prefix 
allow full summation adds little useful power exchange complexity introduces formal semantics calculus 
restriction operator variable process input operator xn binds variables xn disallow chapter 
polyadic calculus duplicate bound variables input prefixes 
length sequence clear context unimportant denote xn distinguish terms convertible 
definition process syntax parallel composition restriction summation xn input xn output replication nil common continuation output nil process allow xn abbreviation xn 
precedences operators described 
example term denotes denotes note precedence meta syntactic substitution operator example implies denotes input output restriction parallel composition summation replication substitution 
tuples interesting evaluation behaviour 
example embed communications inside tuples 
computation polyadic calculus processes communicating channels just monadic calculus 
semantics semantics polyadic calculus reduction relation see mil details 
style semantics involves defining relations processes reduction relation formalises actual communication behaviour processes structural congruence relation 
chapter 
polyadic calculus structural congruence relation allows rewrite process active input output prefixes syntactically juxtaposed 
simplifies presentation reduction relation reducing number cases consider 
definition describes reduction terms 
rules state reduce parallel composition restriction 
symmetric rule parallel composition redundant structural congruence 
definition process reduction xn yn yn xn communication rule takes processes willing communicate channel simultaneously substitutes free names yn bound variables xn 
simultaneous substitution yn xn defined disallow duplicate bound variables input prefixes 
remaining components summations discarded component summation allowed execute 
note communication rule rule directly reduces term 
communication rule assumes processes particular format example inputting process left contained summation 
structural congruence rule allows rewrite processes correct format communication rule 
rewriting may necessary parallel composition rule assumes reduction occur right sub component 
rule communication sufficient considering guarded summation 
allowed full summation able assume chapter 
polyadic calculus participants communication immediate sub components summations 
definition structural congruence structural congruence smallest congruence relation satisfies axioms 
fv definition presents structural congruence relation 
rules simply assert associativity commutativity parallel composition summation operators 
show example reductions illustrate simple uses structural congruence 
infer process communication need associativity commutativity parallel composition bring input output prefixes communication rule expects input output prefixes contained summations identity commutativity rules summation parallel composition communication rules infer communication chapter 
polyadic calculus structural congruence rules allow generate copies replicated process require 
allows ignore replication reduction rules 
example structural congruence single copy replicated process start communicating usual way 
benefits reduction style semantics obvious consider restriction operator reduction rules contain mention restriction rule allows reduce underneath restriction 
managed separate rules implementing communication rules change scope restriction labelled transition semantics operations usually combined resulting complicated rules 
case channel shared communicating processes reduction rule restriction directly case private channel communicated process expand scope private channel encompass recipient structural congruence reduce process expanding scope example valid occur process condition checked rule 
suppose fv wish apply rule 
achieve converting term chapter 
polyadic calculus longer occurs free apply structural congruence rule 
mention conversions explicitly distinguish convertible processes 
runtime failure additional structure introduced polyadic communication primitives important raises possibility runtime failure 
example process ill formed attempts input pair fact carry triple 
definition runtime failure fails fails fails fails xm yn fails definition formalises mean runtime failure polyadic calculus rules mimic reduction rules exactly communication rule detects runtime failure 
encoding polyadic communication ability create private channels communicate processes allows encode polyadic communication monadic calculus mil 
encode polyadic output symbol denote definitional equality vn vn fv vn chapter 
polyadic calculus encoding creates new channel sends transmits vn sequentially continues condition fv vn ensures auxiliary variable free variable vn 
encode polyadic input similar composite communication components received tuple bound xn xn xn fv xn example demonstrates communication results number reduction steps substitution 
exchange private channel shared inputting outputting processes 
final result composite communication mentions private channel extra channel harmless mentioned scope side conditions encoding ensure fv 
runtime failure monadic calculus show encoding polyadic calculus monadic calculus destroys operational notion runtime failure 
consider process fails polyadic calculus examine encodings monadic calculus find reduction sequence possible assume fv chapter 
polyadic calculus harder detect example failed perform number reduction steps 
communication encounter problem process proceed processes cooperate output find failure due ill formed communication manifests deadlocked sub process 
case process deadlocks process free proceed precise definition failure terms deadlock difficult 
reason deadlock suitable notion failure useful calculus programs expect certain processes deadlocked 
assumed deadlocked processes garbage collected example server clients garbage collected need explicit termination 
difficulties suggest monadic calculus syntactic structure support simple type system information term guess programmer expected deadlock 
polyadic calculus thought minimal extension calculus allows detect runtime failure purely syntactically 
recursive process definitions presentations calculus replication operator enable processes infinite behaviour 
replication operator neatly replaces complicated mechanism recursively defined processes earlier presentations calculus 
helpful highlevel syntax recursively defined processes writing calculus examples 
provide derived form definitions chapter 
polyadic calculus definition process definitions def xn xn xn xn xn pn process definition xi xi create new channel xi replicated process xi xi pi 
process xi xi pi waits tuple arguments sent channel xi runs pi arguments substituted formal parameters xi 
replication operator enables xi called arbitrarily providing arbitrary number copies xi xi pi 
invoke process definition xi simply sending desired arguments channel xi 
example process repeatedly outputs def illustrate behaviour expanding derived form def def simple example mutually recursive process definition example repeatedly waits value retransmits 
expand derived form illustrate scoping get put channels allows mutually recursive calls channels scope bodies get put process get 
def get put put get get 
get put get put put get get chapter 
polyadic calculus returning results common process behave functional manner accepting number arguments doing computation returning result 
calculus necessary return results means explicit communication processes implicit results 
convention write functional processes form parameter result channel 
results 
processes frequently replicated enable multiple calls executed case write process definition def results 
style programming reminiscent continuation passing style current continuation inserts result 
don need special syntax help define processes return results convenient derived form getting results back process definitions definition getting results processes xn am am xn fv am definition calls creating new channel new channel necessary avoid interference sending arguments 
waits results sent back continuing withthe results substituted bound variables 
fact communication polyadic means conveniently support calls require multiple arguments return multiple results 
omit keywords nested expressions need write chapter 
polyadic calculus consider process definition action get result return def simplify processes making tail call def returns result directly returning indirectly tail calls simplify examples useful effect practice save creating extra result channel avoid communication booleans mil milner demonstrated data structures encoded calculus 
example define booleans true false def true def false true false take parameters result channel create new channel serves location boolean value return result channel true false start replicated process purpose answer queries boolean process replicated want query boolean omitting replication yield linear boolean 
implement conditionals 
suppose location boolean value 
send pair private channels reply true false 
proceeds true proceeds false 
chapter 
polyadic calculus definition conditionals fv easy implement conjunction disjunction negation operations booleans 
consider example behaviour conjunction operation 
true simply returns result channel instructs false create boolean return lists def false def true def false true lists constructors nil cons 
nil doesn take parameters apart result channel 
cons takes head tail list parameters plus result channel 
def nil def cons hd tl hd tl behaviour nil similar true 
creates new channel location list returns creates replicated process responds requests signalling component request 
behaviour cons slightly complicated signal trivial value sends pair hd tl 
enables process interrogating cons cell interrogate head tail list assuming course hd location data structure tl location list 
define list pattern matching derived form 
operates similarly derived form conditionals binds variables hd tl head tail cons cell 
chapter 
polyadic calculus definition list pattern matching match nil cons hd tl hd tl fv list pattern matching write list concatenation procedure 
concat procedure take lists arguments plus result channel responds sending concatenation def concat match nil cons hd tl rest concat tl cons hd rest nil concat immediately sends recursively calculate concatenation tl naming result rest 
rest instructing cons return resulting list process cells easily encode updatable data structures processes 
example process cell read update represents cell current contents read update channels read modify contents cell 
def cell read update read cell read update update cell read update summation operator ensures read update requests executed concurrently 
guarantee update request accepted subsequent read requests answered updated contents cell 
process definition ref initial value result channel creates new cell creating new read write channels starting cell process 
def ref read update read update cell read update chapter 
polyadic calculus channel cells alternative style cell doesn summation operator shown 
cell represented single channel process 
initial value result channel process builds new cell creating new channel ref asynchronously writing 
def ref ref ref read process cell ref result channel value ref current contents cell immediately puts back sending back client def read ref ref ref similarly cell ref new value result channel update process reads current contents cell ref replaces signalling completion sending empty tuple 
def update ref ref ref read update operations preserve invariant active writer ref channel 
action read update processes read value channel ref 
successfully reading value ref effect temporarily blocking read update operations active writer channel ref 
avoid interference concurrent read update operations 
chapter process typing useful type systems programming languages typechecked automatically usually compilation 
ml type system mil dm particularly example type system programmer write type information inferred automatically type checker 
wish type checking type inference performed compilation evaluation hope calculate exact behaviour program general depend input data available compilation time 
conservative approximation behaviour program assuming example clauses conditional expression executed attempting calculate exactly clauses executed 
pragmatic reasons avoid complicated calculations programming language type system programmers need understand type errors reported type system 
computation calculus communication channels 
simplify type system making important decisions 
type channel remains constant lifetime 

specify temporal properties channels 
decisions avoid need consider causal relationships communications significantly simplify type system 
chapter 
process typing chapter presents monomorphic calculus type system 
define syntax types typing contexts typing rules processes showing typing rules behave examples derived forms chapter 
prove means subject reduction theorem type system guarantees freedom runtime errors 
types type contexts definition gives syntax types 
just type constructor channel type constructor channels data polyadic calculus 
allow type variables enable type inference 
definition types channel type type variable record types free variables type context 
type contexts possibly empty sequences bindings form xn distinct variables 
denote context xn definition type contexts xn leave distinct variable condition implicit typing rules 
example mention rule implicitly assuming mentioned 
expression denotes type associated defined definition context lookup undefined chapter 
process typing typechecking processes calculus processes explicit results 
interact process communicating 
typing judgements processes take form typing context gives types free variables read asserting uses free variables consistently types 
simplest calculus process nil process 
communicate consistent context nil output operator xn sends tuple xn channel process continues communication completed 
output typing rule xn xn output states context channel carrying tuple length components match types values xn sending formed process context xn formed process 
note output operator name binding operator expected formed context 
simple example typed output arbitrary types 
input operator xn receives tuple length channel binding components received tuple xn input typing rule xn xn input checks channel carrying tuple length formed context extended types bound variables 
note bound variables distinct variables bound chapter 
process typing possible satisfy condition converting bound variables 
simple instance input typing rule 
note typechecked context bound second components tuple sent input typing rule ensure free variables consistent manner 
require typed context 
ensures channels type 
check previous examples run parallel prl output input prl rule clearly disallows ill formed examples left hand process requires type right hand process requires type restriction operator new channel scope typing rule restriction extends context adding type binding rule particularly simple type constructor channel type 
basic types integers need extra restriction res rule ensure channel type 
restriction localise channels previous example res prl chapter 
process typing note process consistent empty context 
fact show consistent context 
sense closed process communicate outside world internally consistent able execute safely context 
summation operator ensures operands execute general statically determine 
require consistent context 
ensures possible execution behave correctly types attempt describe channel 
replication operator serves arbitrary number copies available consistency depends consistency repl smt typing rules processes summarised definition 
chapter 
process typing definition process typing rules xn xn xn xn prl res smt input output repl nil derived rules process definitions process typing rules give rise admissible rule process definitions definition typing process definitions xn xn xi pi def xn xn expand derived form see definition page process definition find construct complete proof premises rule 
suppose premises rule true 
definition xi input rule second assumption def chapter 
process typing repl rule xn xi xi pi xn xi xi pi prl rule assumption find xn xn xn pn res rule prove required 
xn xn xn pn processes return results process typing rules give rise admissible rule 
introduce type abbreviation clarifies types arguments results 
definition typing am xn xn am easy check rule admissible expanding derived form definition page 
suppose premises rule true 
weakening lemma lemma prove prove xn side condition derived form ensures fv 
annotate bound variables expansion xn am show rule valid am xn chapter 
process typing booleans typecheck boolean examples 
bool type 
reproduce definitions true false indicating typed annotating bound variables types 
def true bool bool def false bool bool true false type bool written bool making clear true false take arguments return boolean 
definition typing conditionals bool easy check rule admissible expanding derived form definition page 
suppose premises rule true 
weakening lemma lemma prove prove side condition derived form ensures fv 
annotate bound variables expansion show rule valid easy verify types conjunction disjunction negation operations booleans 
def bool bool bool false def bool bool bool true def bool bool false true chapter 
process typing process cells process cell represented pair channels channel read contents cell second update contents cell 
type cell arbitrary fixed update channels type 
def cell read update read cell read update update cell read update process definition ref takes initial value creates new cell 
type 
def ref read update read update cell read update example highlights weaknesses simple calculus type system 
firstly forced choose single type definitions cell ref clearly operate uniformly types address problem chapter 
secondly user cell write read channel read write channel restriction enforced type system 
fortunately pierce sangiorgi ps shown possible refine channel type constructor input output capabilities manipulated separately 
pict programming language pt adopts pierce sangiorgi refinement enabling give ref thetype thetype read access type allows write access :10.1.1.127.1777
channel cells type type cell represented channel 
process type 
def ref ref ref read process type 
chapter 
process typing def read ref ref ref update process type 
def update ref ref ref example highlights weaknesses simple calculus type system 
firstly just process cells forced choose definitions read update clearly operate uniformly types address problem chapter 
secondly read update operations preserve invariant active writer ref channel way ensuring read update processes manipulate ref channel 
precisely datatypes useful chapter show polymorphic extension calculus type system able provide just mechanism 
properties typed terms fv add new type binding invalidating typing lemma weakening fv proof simple induction structure similarly fv remove type binding invalidating typing lemma strengthening fv proof simple induction structure xi yi type context substitute preserving type lemma substitution xi yi yn xn proof simple induction structure chapter 
process typing properties structural congruence definition page structural congruence relation defined congruence relation satisfies set axioms 
fact explicit say defined relation satisfying axioms definition plus rules defining way allows induction depth derivation proofs 
refl trans sym cong denotes process context process containing hole xn xn structural congruence relation captures runtime behaviour restriction operator 
important lemma types preserved structural congruence 
part lemma necessary type soundness result part essential wish induction prove sym rule preserves type process 
lemma types preserved structural congruence proof prove parts simultaneously induction depth inference omit cases involving summation operator similar parallel composition cases 
case part 
assumption nil wehave required 
part easy 
case part 
clearly result follows prl rule 
part similar 
chapter 
process typing case part 
clearly result follows applications prl rule 
part similar 
case part 
prl rule required 
part easy 
case wherex fv part 

weakening lemma prove fv 
result follows prl res rules 
part 

strengthening lemma prove fv 
result follows prl res rules 
case immediate 
case part 
induction part required 
part similar 
case part 
induction induction required 
part similar 
case wherep simple sub induction structure proves result 
note important structural congruence rules delete create sub terms 
allowed rules types preserved structural congruence 
example read left right garbage collection rule perfect sense output succeed 
read right left rule allows magically create arbitrary term particular may typed 
chapter 
process typing type soundness able prove main soundness theorems typed processes fail 
theorem typed processes fail fails 
proof suppose fails 
induction depth inference fails show contradiction possible types failure encounter case fails fails assumption induction prove fails contradiction required 
case fails assumption induction prove fails contradiction required 
case fails fails assumption lemma prove induction prove fails contradiction required 
case xm yn fails assumption xm yn clearly inputting outputting processes contradiction required 
definition process failure detects immediate failure process subject reduction theorem required prove typed processes remains typed successful reduction step 
corollary theorems typed process fail number reduction steps 
theorem subject reduction proof prove result induction depth inference chapter 
process typing case pand induction prove result follows prl rule 
case case induction prove result follows res rule 
case xn yn yn xn assumption xn yn case xn 
yn 
substitution lemma lemma prove xn yn xn strengthening lemma lemma yn xn xn free substituted process 
assumption result follows prl rule 
case assumption lemma induction result follows lemma 
type inference benefits automatic type inference clearly demonstrated languages standard ml mth haskell programmer write minimum explicit type information 
similar unification techniques show possible automatically infer types terms 
substitutions substitution finite map type variables types 
dom denote domain 
substitution naturally extends operation types contexts defined 
chapter 
process typing definition substitutions xn dom xn type inference necessary compose substitutions 
composition written defined definition composition substitutions dom dom lemma simple properties substitutions proof straightforward definitions substitution composition 
important fact prove substitution typing judgements closed substitution 
fact crucial type inference algorithm able apply substitutions typing context invalidating types terms checked 
lemma preservation process types substitution proof simple induction structure unification calculus types simple trees know robinson rob sound complete unification algorithm calculus types refer unify 
propositions state appropriate soundness completeness properties algorithm 
chapter 
process typing proposition soundness unification algorithm rob unify 
proposition completeness unification algorithm rob unify succeeds returning 
unify fails 
inference algorithm definition give algorithm takes type context process arguments fails valid typing exists returns minimal substitution definition inference algorithm case return fail 
case return fail 
case fresh type variable return fail 
case xn fresh type variables unify xn return fail 
case xn xi unify return fail 
case return fail 
case return empty substitution 
formalise algorithm picks fresh type variables 
proofs assume type variable declared chapter 
process typing fresh distinct type variables mentioned current context types computed 
practice condition easily satisfied global counter number new type variables 
soundness inference algorithm demonstrated theorem theorem soundness inference algorithm proof proceed induction structure case induction induction lemma prl rule required 
case 
case fresh 
induction conclude res rule 
case xn unify 
xn induction xn proposition find clearly implies 
apply input rule prove xn required 
case xn xi unify 
induction proposition find clearly implies xn result follows output rule 
case induction repl rule required 
chapter 
process typing case immediate nil rule 
proof need take union substitutions 
defined domains disjoint introduce overwrite operation combines arbitrary behaviour takes precedence behaviour domain definition union substitutions dom dom dom theorem demonstrates inference algorithm returns principal substitution exists 
theorem completeness inference algorithm succeeds returning 
proof proceed induction structure case induction find succeeds returning exists 
induction succeeds returning exists 
succeeds returning required 
case 
case fresh type variable 
fresh 
induction succeeds returning 
implies 
succeeds returning required 
chapter 
process typing case xn xn fresh type variables 
fresh 
forsome 
proposition show unify succeeds returning 
induction xn succeeds returning 
xn succeeds returning required 
case xn case xi 
proposition show unify succeeds returning exists 
induction succeeds returning exists 
xn succeeds returning required 
case induction succeeds returning exists 
result immediate succeeds returning 
case succeeds returning result follows 
chapter recursive types useful programs assigned type calculus 
similarly useful calculus programs assigned type simple type system 
important deficiency support programming recursive datatypes example lists trees 
simple solution problem recursive types 
fact calculus recursive types typed calculus expressive untyped monadic calculus assign type monadic term 
type syntax extend syntax types recursive types form bind scope 
definition recursive types type variable channel type recursive type possible ways proceed allow implicit folding unfolding recursive types cf 
coppo cc amadio cardelli ac example require explicit annotations programmer cf 
macqueen plotkin sethi mps example 
choose chapter 
recursive types requires minimum changes typing rules operational semantics 
simplest way allow implicit folding unfolding recursive types modify definition type equality insensitive operations 
commonly achieved considering type finite specification infinite tree obtained repeatedly applying rule 
interpretation say denote infinite tree 
take direct approach defining equality means bisimulation relation types 
treatment recursive types inspired pierce sangiorgi formalisation subtyping recursive types ps 
refine eliminating uses infinite trees pierce sangiorgi bisimulation relation defined infinite trees bisimulation relation defined directly syntax types 
believe eliminating uses infinite trees presentation get simpler treatment recursive types direct proof correctness type equality algorithm 
define means types bisimilar 
intuitively types bisimilar distinguish type structure 
relation formalises observations type definition observation allow type variables channel types observed directly 
order bisimulation insensitive folding unfolding recursive types prevent direct observation recursive types 
unfold recursion observe structure unfolded type 
means example type unfolding exactly observable type structure distinguished bisimulation relation 
require recursive types contractive occurrences inside channel type constructor 
disallows types observable type structure guarantees type exists unique 
chapter 
recursive types definition bisimulation range relations types 
relation bisimulation function relations 


function definition monotone tarski fixpoint theorem tar greatest fixpoint exists equal 
fixpoint follows definition bisimulation 
example relation bisimulation sufficient prove 
typing rules reinterpret process typing rules definition page replacing syntactic type equality input output rules typing rules remain unchanged definition typing rules xn xn xn xn input output example give type process sends pair channel ifx output typing rule show proved section chapter 
recursive types importantly typecheck list processing examples section 
list recursive type 
easy check list list list list list list bisimulation implies list list 
reproduce definitions nil cons indicating typed annotating bound variables types 
def nil list list list def cons hd tl list list list list hd tl annotations imply nil type list type list list 
definition typing list pattern matching list hd tl list match nil cons hd tl match easy check expanding derived form definition page rule admissible 
proof technique section verify concat type list list list def concat list list list match nil cons hd tl list rest list concat tl cons hd rest chapter 
recursive types encoding monadic calculus monadic calculus clearly special case polyadic calculus tuples arity 
help recursive types monadic terms type simple type system example term 
rules admissible recursive types definition typing monadic terms monadic input monadic output variable type monadic term free variables subset bound monadic input rule preserves invariant variable type 
regain full power monadic calculus allow recursive types pay price flexibility type uninformative 
properties prove reasonable equality relation equivalence relation preserved substitution preserved type constructors 
proposition equivalence relation 

proof part follows fact identity relation bisimulation 
part follows fact bisimulation bisimulation 
part follows fact chapter 
recursive types bisimulation bisimulations 
prove preserved substitution need show substitution affects observations type 
lemma observation substitution 
proof results proved induction depth inference observation 
lemma proves observations type arise original type substituted type 
essentially new observations arise substitute 
lemma substitution observation 
fv 


proof result proved induction depth inference equality relation forces free type variables equal types lemma free type variables fv iff fv 
proof easy see fv eventually observe type variable 
observe case observe bisimilar fv required 
identical reasoning prove fv fv 
prove preserved substitution 
chapter 
recursive types proposition preserved substitution proof result follows prove bisimulation bisimulations containing pairs respectively 
suppose 
know lemma 
fv case bisimulation 
know lemma fv result follows 
bisimulation bisimulation 
lemma required 
alternatively know lemma 
fv case know ulation lemma fv result follows 
case know bisimulation bisimulation 
lemma required 

case know bisimulation 
lemma result follows pair bisimulation relation 
required 
prove congruence relation prove lemmas observation recursive types 
chapter 
recursive types lemma observation recursive types 
exist proof results proved induction depth inference initial observation 
rely fact occurrences recursively bound variable contractive 
proposition congruence relation 

proof part follows fact rn bisimulation relation ri bisimulation containing pair 
part follows fact relation bisimulation bisimulation containing pair 
suppose 
know lemma 
fv case bisimulation 
know lemma fv result follows 
bisimulation 
lemma 
bisimulation 
lemma required 
alternatively know lemma 
fv case bisimulation know lemma fv result follows chapter 
recursive types 
case know ris bisimulation 
lemma exist bisimulation exist lemma 
result follows pair bisimulation relation 

know bisimulation 
lemma proves result follows pair ulation relation 
observations identical checked pairs bisimilar 
required 
checking type equality algorithm relation types builds bisimulation containing pair 
algorithm fails match cases 
clause takes precedence clauses case clause matches 
definition checking type equality case eq return case eq return 
case eq ri eq ri return rn 
relation contains pairs types checked algorithm 
simply return encounter pair chapter 
recursive types checked 
note fact recursive types contractive guarantees effectively compute unique type 
soundness eq depends crucially relation passed argument 
example eq succeeds returning types clearly bisimilar 
prove result eq sound assuming sound 
definition formalises relation bisimulation relative second relation thought containing pairs types checked equality 
definition relative bisimulation relation bisimulation relative function relations definition 
suppose wish check bisimulation relative foreach pair need check interpret meaning checked means check observable type structure normal way 
state prove soundness eq 
note top level calls relation empty relation 
top level result eq bisimulation relative implies bisimulation 
lemma soundness eq eq bisimulation relative proof prove result induction depth inference eq case eq immediate definition relative bisimulation 
case eq immediate identical observable type structure 
chapter 
recursive types case eq ri eq ri induction ri bisimulation relative ri ri ri ri ri 
clearly implies rn 
rn rn rn rn rn rn rn rn rn 
rn rn monotone rn rn rn bisimilar relative rn 
iterating argument proves bisimilar relative rn rn 
rn conclude rn rn required 
easy see rn ri rn bisimulation relative required 
lemma proves completeness eq bisimilar eq succeed returning bisimulation containing 
lemma completeness eq bisimulation eq succeeds returning proof prove result induction number pairs checked eq size set 
base case eq succeeds returning required 
size non zero cases consider eq rand result follows 
case 
succeeds returning result follows 

clearly induction prove eq ri succeeds returning ri ri ri succeeds returning rn rn rn required 
cases eq succeeds required 
propositions simple corollaries lemmas give simplified statements soundness completeness 
chapter 
recursive types proposition soundness eq eq succeeds 
proof eq lemma bisimulation containing pair 
follows definition 
proposition completeness eq eq succeeds 
proof exist bisimulation containing pair 
lemma prove eq succeeds required 
type soundness easy check weakening strengthening substitution lemmas section hold presence recursive types proofs identical section 
prove types preserved structural congruence techniques section 
able prove type system remains sound extended recursive types 
proofs identical section 
theorem typed processes fail fails 
theorem subject reduction interesting note proof theorem relies fact nand fact obvious follows immediately definition marks dividing line acceptable equality relation types unacceptable 
proofs weakening strengthening substitution preservation types structural congruence subject reduction remain valid arbitrary congruence relations example universal relation 
chapter polymorphism common disadvantage simple type systems prevent common programming errors disallow useful intuitively correct programs 
polymorphic type systems overcome problem allowing generic operations operations safely applied different types argument 
list operations reversing concatenation examples generic operations act completely independently types elements lists 
extra flexibility offered polymorphic type system allow natural style programming type system perceived getting way 
chapter define explicitly typed polymorphic type system calculus arises natural extension simple type system earlier 
illustrate utility polymorphic types calculus programming number examples show polymorphic channels model datatypes type safe manner 
prove means subject reduction theorem polymorphic type system guarantees freedom runtime errors 
typing rules simple example channel polymorphically channel explicitly typed process chapter 
polymorphism intuitively able send pair channels types instances respectively 
fact think having additional type argument shown similarly extended indicate requires explicit type argument sent pair channels 
example process send channels types match types required instantiate type parameter explicit type argument 
server pointer view point view process reading messages type interpreted requirement server behave correctly type pair channels type respectively 
client pointer view point view process writing messages type interpreted guarantee process listening behave correctly long client supplies type channels types match types substituting argument type type parameter 
formally define explicitly typed polymorphic calculus 
give syntax explicitly typed terms 
require explicit type annotation bound variable explicit type parameters input expressions explicit type arguments output expressions 
syntax parallel composition summation replication nil process unchanged 
chapter 
polymorphism definition explicitly typed calculus parallel composition restriction summation yn input yn output replication nil note allow polyadic type arguments polyadic channel arguments 
case write just yn yn andx yn yn expression yn binds type variables scope 
type parameters pairwise distinct 
generalise syntax simple channel types channels may contain type parameters 
types bound channel type constructor scope type parameters pairwise distinct 
case write just 
definition polymorphic types polymorphic channel type type variable syntax type contexts just monomorphic type system modulo change syntax types 
variables xn pairwise distinct 
expression ftv denotes free type variables defined union free type variables types 
definition type contexts xn chapter 
polymorphism typechecking rules nil process parallel composition summation replication typing rules gave monomorphic type system nil smt prl repl typechecking rule explicitly typed restriction similar original rule restriction force type assigned channel type 
restriction type necessary preserve soundness type system simplifies reasoning datatypes encoded polymorphic calculus see section details 
res case polymorphic input check body input requires type structure xn 
condition ftv ensures capture type variables occur free context 
rule generalises rule input gave monomorphic calculus type system chapter just set 
ftv xn input xn simple instance input typing rule context 
ftv input case output polymorphic channel check channel values sending substitution instances types specified type type arguments explicit instantiate abstracted variable 
generalises rule output gave monomorphic calculus type system chapter just set 
chapter 
polymorphism ai output output rule easy check type contains type arguments output rule just monomorphic output rule case 
input repl rules conclude original example replicated process reading typed output input repl furthermore output rule check output expression typed types substitution instances specified type denote context 
type output expression indicates instantiate type argument actual type 
output easy check replicated input example typed context input output examples agree type run parallel repl output worth noting general may number processes reading channel example reason shouldn copies replicated process serving requests prl chapter 
polymorphism type system ensures process inputs values channel provides standard service requirements arguments 
example certainly expect process typed context rightmost process demands argument allowed type sends empty tuple important generalise types input prefixes stage typing derivation guarantee process uses polymorphic channel sufficiently polymorphic 
suppose typing rule allows generalise type point type inference long type variables appear typing context rule give polymorphic type channel example process reading behaves identity function time called returns result channel subsequent calls return argument call principal type example monomorphic type system gives type 
top level clear polymorphic type apply typing rule generalise type 
unsound polymorphic 
suppose send pair integer result channel type int 
receive back expected 
send result channel type bool certainly able polymorphic 
receiving back receive type int incompatible value type bool expected receive 
chapter 
polymorphism polymorphic typing rules deal example correctly check separate input prefix sufficiently polymorphic 
tried give type find second replicated input ill formed type occurs free type 
ease summarise typing rules explicitly typed polymorphic terms definition 
definition polymorphic typing rules nil ftv xn xn ai prl smt repl res input output tempted add type restriction operator polymorphic calculus match calculus channel restriction operator 
intuitively type restriction operator create new type distinct types just channel restriction operator creates new channel distinct channels 
operator essentially useless way create values inhabit new type 
chapter 
polymorphism really need ability create new type values type 
sounds datatype show section datatypes encoded just polymorphic channel types obvious type restriction operator calculus 
recursive process definitions derived form process definitions definition channels model recursively defined process 
easily generalise derived form allow recursively defined polymorphic process definitions 
allow explicit type parameters definition require explicit types channel parameters xi match type information required polymorphic input expressions 
process definition xi create new channel xi replicated process polymorphic input xi 
note infer appropriate explicit type channel xi explicit types process definition xi 
definition process definitions def xn xn 
xn xn xn pn provide high level typing rule process definitions proved admissible techniques section 
definition typing polymorphic process definitions ftv xn xn xi pi def xn xn def chapter 
polymorphism invoke process definition xi simply sending desired type value arguments channel xi 
example process repeatedly output different types def processes return results possible generalise syntax getting results processes definition get results polymorphic processes definition getting results polymorphic processes fv polymorphic typing rules give rise admissible rule 
introduce type abbreviation clarifies types arguments results 
definition typing check rule admissible expanding derived form just section 
process cells give better types process cells gave monomorphic types examples section 
chapter 
polymorphism process cell represented pair channels channel read contents cell second update contents cell 
process definition cell describes behaviour cell current contents accessed channels read write 
polymorphic channels cell polymorphic def cell read update read cell read update update cell read update process definition ref takes initial value type creates new cell 
note ref creates new instance cell process instantiated type 
def ref read update read update cell read update channel cells types channel section similarly generalised 
type type cell represented channel 
value type returns value type 
def ref ref ref read process parametric type 
takes cell returns current contents cell 
def read ref ref ref similarly update process works correctly cell ref type value type 
def update ref ref ref chapter 
polymorphism lists give polymorphic types list examples section require add recursive types polymorphic type system 
complicating type system encoding lists polymorphic list operations typechecked polymorphic types encoding closely related church encoding lists polymorphic calculus 
practice probably better add recursive types relying solely polymorphic types operations naturally described encoding lists section particular finding tail list constant time operation church encoded lists previous encoding 
recall church encoding lists polymorphic calculus 
expression list denotes type 
nil cons hd tl list 
hd tl nc type nil list type cons list list 
encoded list allows iterate function elements list accumulating result type 
instance expression int int computes size list function int elements value initial value 
example function uses encoding lists concat function shown 
concat effect concatenating lists type list list list concat list list list cons give calculus version list encoding expression list denotes type 
process definition nil accepts type result channel arguments returns location process definition implementing empty list 
chapter 
polymorphism def nil list def nil nil process definition cons accepts type head list hd list tl result channel arguments returns location process definition implementing cons cell 
def cons hd tl list list def cons tl hd cons definition cons derived syntax get result accumulating tail list 
yields result type pass head list element hd 
calculus version concatenate function shown 
little verbose calculus version explicitly construct partial application cons local process definition cons 
def concat list list list def cons hd tl list list cons hd tl list cons datatypes datatypes known important program structuring technique 
mp mitchell plotkin showed typing behaviour datatype correctly modeled existential type 
fact turns possible encode existential types polymorphic calculus rey 
similar technique applicable polymorphic calculus enabling provide support programming datatypes calculus 
example illustrates package booleans boolean operations section datatype 
show section true false simple monomorphic types 
annotated bound variables process definition chapter 
polymorphism indicate types rep denotes representation type booleans 
bool def true rep def false rep def rep rep rep false def rep rep rep true def rep rep false true bool rep true false bool bool true bool false bool bool bool bool bool bool bool bool bool channel bool polymorphic expects sent representation type bool collection operations type bool 
type channel bool bool representation booleans bool implementation true bool implementation false bool bool bool implementation bool bool bool implementation bool bool implementation aim hide representation type rep inside datatype ensuring uses boolean values outside datatype independent actual representation booleans 
boolean process definitions directly define outside scope channel bool assume bool chapter 
polymorphism fresh channel 
operationally process equivalent process def true rep def false rep def rep rep rep false def rep rep rep true def rep rep false true rep bool typing behaviour processes different 
process boolean representation rep visible process inthe fact channel bool polymorphic type bool forces behave independently actual representation booleans 
encoding booleans calculus said booleans represented channels sent pair channels respond exactly type system enforced constraint values type bool simply abbreviation type constraints process reading channel values receives 
packaged boolean operations datatype sure occurrences values type bool constructed number applications true false 
easy see true false produce processes protocol booleans 
similarly assuming boolean arguments satisfy protocol produce behaved booleans 
proved values type bool satisfy protocol booleans 
reasoning quite informal believe useful practice 
leave issue formalise reasoning interesting open problem 
note reasoning relies crucially fact way constructing values type bool operations provided datatype 
see changed typing rule restriction force type restricted name channel type 
restriction easily write expressions bool chapter 
polymorphism breaking invariant value type bool created operation datatype implementation 
encoding booleans channel cells section channels controlled manner read update operations preserve invariant value stored channel implementing ref cell see section details 
channel cells provide example representation hiding useful 
certainly possible hide representation technique booleans 
better solution type constructor provide polymorphic operations cells type 
order need able send channel just sent rep channel bool 
unfortunately type system allow communication type constructors channels implement high order polymorphism 
reason add feature 
pict language pt author collaboration benjamin pierce developed higher order polymorphic calculus calculus enables communicate type constructors channels implement datatypes type constructors list :10.1.1.127.1777
type soundness need modify calculus reduction semantics gave section take account fact communicate type channel arguments channels 
need modify communication rule shown 
rest reduction rules remain unchanged behaviour structural congruence unchanged modulo fact restriction operator contains explicit type annotation 
chapter 
polymorphism definition polymorphic communication xn yn yn xn alternative way specifying behaviour polymorphic terms say polymorphic term exactly behaviour type erasure erase defined 
definition type erasure erase erase erase erase yn erase yn erase erase erase erase erase erase erase yn erase yn erase erase fact easy check definitions equivalent welltyped terms proposition type erasure erase erase 
erase exists erase proof simple induction structure property useful point view implementation means need maintain explicit type information runtime 
worth noting corresponding property true functional languages say chapter 
modify definition runtime failure take account possible type argument mismatches chapter 
polymorphism definition polymorphic runtime failure xn yn fails properties prove typed polymorphic terms essentially proved section monomorphic type system 
example fv add new type binding invalidating typing lemma weakening fv proof simple induction structure similarly fv remove type binding invalidating typing lemma strengthening fv proof simple induction structure xi yi type context substitute yn xn preserving type lemma substitution xi yi yn xn proof simple induction structure typed context simultaneously substitute get typed term 
lemma type substitution proof simple induction structure chapter 
polymorphism easy prove lemmas types preserved structural congruence 
lemma types preserved structural congruence proof similar proof lemma prove type soundness exactly way proved type soundness monomorphic type system 
rules changed proofs theorems similar monomorphic type system 
theorem typed processes fail fails 
proof similar proof theorem theorem subject reduction proof similar proof theorem chapter relating typed terms typed terms type system constructed type theoretic techniques borrowed calculus natural ask precise relationship welltyped terms typed terms 
milner mil shown encode various calculus reduction strategies calculus 
show type structure term preserved encodings 
fact cases prove principal type term directly related encoding principal type calculus 
interesting feature encodings presence polymorphism don 
example find damas milner type system dm agree calculus type system types term may inhabit 
surprising familiar ml known damas milner polymorphism unsafe presence side effects tof 
calculus nature calculus containing side effects better allow kind polymorphism damas milner type system 
fact find soundness damas milner type system closely connected precise evaluation order result discovered leroy ler encodings calculus 
find call value encoding calculus preserve damas milner type structure call name encoding 
chapter 
relating typed terms typed terms encoding terms syntax terms 
expression fv free variables defined usual way 
definition calculus syntax variable abstraction ee application call value reduction definition presents milner encoding call value calculus reduction strategy polyadic calculus 
assume set calculus variables subset set calculus variables avoids having rename calculus variables translating terms 
definition call value calculus encoding ee translation terms parameterised auxiliary channel channel location encoded term returns result 
encoding introduces auxiliary variables ranged 
assume distinct calculus variables 
encoding property fv fv just variable just return variable immediately 
abstraction create new channel think location closure immediately send start replicated process process acts compute server send pair argument result channel server respond computing value returning evaluate application node ee left right start running wait result start running wait result chapter 
relating typed terms typed terms sent values function argument apply sending pair tof 
function send result finished recall result term supposed sent 
example function value immediately sends channel creating replicated process implements function process implementing application node received function evaluates function argument value signals result channel immediately application node values channel representing function andy function argument 
sends pair causing replicated process compute value applied final result structurally congruent process clear replicated input execute communications process access channel 
final result executing equivalent expected 
chapter 
relating typed terms typed terms encoding expressions damas milner typing rules dm rely explicit expressions indicate type generalisation allowable 
expression intended behaviour indirect interpretation unfortunately yields complex encoding calculus 
direct encoding corresponds optimisation usually compilers functional languages definition call value expressions hint prove direct encoding equivalent indirect 
denote strong weak congruence respectively see san definitions 
expand definition execute communication local channel yielding process rewritten structural congruence fact fv follows channel replicated input moved inside input prefix interact input completed 
execute communication chapter 
relating typed terms typed terms yielding process equivalent channel appear call name reduction definition presents davie od encoding call byname calculus 
davie encoding milner shares structure call value encoding easily modified implement call need evaluation evaluation function arguments shared 
notation denote call name encoding just call value encoding auxiliary channel communicate result evaluating encoding just create new channel represent function immediately send result channel definition call name calculus encoding ee behaviour encoded application ee follows start executing wait return function forcing evaluation argument call value encoding start new replicated process channel apply argument result channel get value associated argument communicate replicated process send result channel replicated process respond starting new copy running return result 
chapter 
relating typed terms typed terms example illustrates encoding able reduce evaluating function value immediately sends channel creating replicated process implements function process implementing application node received function starts replicated process channel sends pair tof effect starting process executing required 
note equal assume auxiliary variables distinct previous process structurally congruent clear replicated input replicated input participate reductions process access channels 
process equivalent term required 
provide optimised encoding expressions call name encoding just call value encoding definition call name expressions call need reduction easy refine previous call name encoding shares evaluation function arguments implements call need reduction correctness encoding proved brock bo 
just replace encoding application definition chapter 
relating typed terms typed terms definition call need application ee encoding differs starting replicated process channel start single input channel time receive signal time value demanded go ahead evaluate received result evaluating start replicated process subsequent requests value answered directly returning value re evaluating 
encoding application changed intended semantics changed 
easy modify previous call name encoding implements call need reduction definition remains definition definition call need expressions encoding calculus types usual notation calculus types 
assume set calculus type variables coincides set calculus type variables avoids renaming calculus type variables translating calculus types 
definition calculus types type variable function type calculus typing context possibly empty sequence bindings form xn wherex distinct variables 
chapter 
relating typed terms typed terms definition calculus type contexts xn definition gives usual typing rules simply typed calculus 
stage matters little church style curry style presentation simply typed calculus 
soon see significant difference come consider polymorphic type systems 
definition calculus typing rules call value encoding ee definition give encoding calculus types calculus types written 
encoding function types matches representation call value functions calculus function represented channel send pair value argument type channel capable carrying result type definition type encoding 
encoding introduces lot unary channel types allow types form written 
extend encoding contexts applying encoding types point wise fashion 
definition context encoding xn xn chapter 
relating typed terms typed terms proposition proves type structure calculus preserved call value encoding calculus 
note type auxiliary channel return result know type 
proposition preservation calculus type structure proof induction structure case required 
case induction weakening lemma input repl rules output rule 
weakening prl res rules required 
case ee induction clearly inputs give type type 
output formed type required 
obvious question ask calculus typing discipline admits types allowed calculus type discipline 
result proves translation term may assigned type correspond valid typing type assigned contains structure valid calculus typing see typings encoded terms image valid calculus typing consider term type easy check certainly calculus types correspond chapter 
relating typed terms typed terms encoding calculus type case aforementioned calculus type substitution instance encoding certainly type trying prove calculus typing image valid calculus typing prove calculus typing substitution instance valid calculus typing proposition calculus typings reflect calculus type structure exist 
proof induction structure case yn context yn type xand substitution give required result required 
case case strengthening lemma induction show exist rule abstraction required 
case strengthening lemma eliminate unnecessary auxiliary variables induction exist exist case communications auxiliary channels easy check exist 
typings preserved substitution chapter 
relating typed terms typed terms calculus 
required 
previous propositions prove principal type simply typed calculus coincides principal type simply typed calculus theorem relating principal types principal typing principal typing principal typing exists principal typing 
proof part 
suppose principal typing proposition typing principal proposition tells calculus typing substitution instance calculus typing know calculus typing substitution instance 
part 
suppose principal typing wehave proposition exist 
typing principal proposition tells calculus typing correspond directly calculus typing know calculus typing substitution instance 
call name encoding prove davie encoding call name calculus preserves type structure terms 
encoding types definition 
encoding function types reflects fact function arguments values channels trigger evaluation argument 
definition type encoding chapter 
relating typed terms typed terms extend encoding contexts 
call byvalue encoding contexts apply encoding types pointwise fashion free variable xi encoded term longer ranges values channels trigger evaluation expression bound xi 
definition context encoding xn xn proposition proves type structure calculus preserved call name encoding calculus 
proposition holds replace call name encoding application callby need encoding 
proposition preservation calculus type structure 
proof similar proof proposition 
case calculus typing equal encoding calculus typing proposition got problem proving calculus typing substitution instance encoded calculus typing 
unfortunately trick call name encoding 
example variable free variable expression may assigned type calculus type system example type unconstrained encoding contexts requires variable bound context type form fact type may general counter example call name equivalent theorem 
problem unused variables may turn cause abstractions types general 
example type corresponds type bound variable unconstrained calculus type system may cause type fail instance calculus type chapter 
relating typed terms typed terms prove slightly weaker result calculus typings callby name encoded terms 
prove encoded calculus variables constrained type encoding calculus type calculus typing equal calculus typing previous condition variables global sufficient constrain just top level free variables encoded term 
proposition calculus typings reflect calculus type structure calculus variables assigned type form implies exists 
proof simple induction structure note propositions remain true replace call byname encoding application call need encoding 
case simply typed calculus distinguishable difference calculus typing call name call need encodings 
encoding recursive types extend call value call name encodings calculus types encompass recursive types 
conjecture results similar previous section proved recursive types calculus calculus 
definition encoding recursive types known term inhabits type interesting note mil milner shows call value term inhabits type rewritten chapter 
relating typed terms typed terms milner type notation 
fact informative recursive type give term previous propositions prove type structure encoded term fact contains accurate reflection original calculus type structure 
encoding polymorphic terms consider encode explicitly typed polymorphic calculus girard reynolds gir rey having explicit term syntax type abstraction type application clarifies semantic issues encounter encoding polymorphic terms calculus 
syntax terms follows definition polymorphic terms variable abstraction ee application type abstraction type application syntax polymorphic types 
damas milner type system restrictions positions polymorphic type may occur 
definition polymorphic types type variable function type polymorphic type polymorphic typing rules variables application just simply typed calculus 
typing rule abstraction slightly different explicit type annotation bound variable additional rules type abstraction type application chapter 
relating typed terms typed terms definition polymorphic typing rules ee call value call name encodings variables abstraction application remain translate explicit type annotations bound variables explicit calculus type annotations call need encoding similarly modified definition encoding explicitly typed terms ee ee reduction behaviour type applications call value call name call need evaluation type argument type application needs evaluated 
encodings type abstraction type application ensure reduces required 
note call value call name encodings differ way encode explicit type argument call need encoding identical call name encoding 
definition encoding type abstraction application chapter 
relating typed terms typed terms encoding type abstraction similar encoding abstraction abstracted variable type variable 
send result channel encoding returns value instantiated type 
encoding type application similar encoding application evaluate expression wait return type function apply type argument 
need evaluate type argument 
example process equivalent channels unused easy check required 
seen encodings type abstraction type application see encode type calculus encodings value type represented channel send pair type result channel polymorphic term respond returning appropriately instantiated value result channel 
encodings function types type variables unchanged reproduce ease 
definition encoding polymorphic types 
strictly speaking encoding translates explicitly typed term partially typed term example give explicit types encoding abstraction 
turns missing type information uniquely determined explicit type information encoded term 
surprising missing chapter 
relating typed terms typed terms calculus type information completely determined result type term known terms encoding unique result types typable 
write type erasures equal contains explicit type information proposition proves typable exists fully typed version typable calculus proposition preservation calculus type structure exists proof induction structure cases similar proof proposition show new cases 
case induction exists input rule fv 
easy prove required 
case induction exists easy see result follows 
proposition proves fully typed version typable calculus typable calculus 
note proposition need global restriction types assigned calculus variables explicit type annotations encoded term restriction 
proposition calculus typings reflect calculus type structure exists exists proof induction structure omit cases variables application straightforward 
chapter 
relating typed terms typed terms case 
ignore bindings occur 
induction 
type result follows 
case ignore bindings occur 
induction 
case fv fv 
required 
case case induction exists 
case forsome 
case required 
similar results hold call name call need encodings polymorphic terms encoding type abstraction application essentially proposition preservation calculus type structure exists 
proof similar proof proposition 
proposition calculus typings reflect calculus type structure exists exists 
proof similar proof proposition 
note interpretation terms depends crucially fact type abstraction type application real computational content 
chapter 
relating typed terms typed terms instance polymorphic value completely separate instances time instantiate type encoding recomputes value 
see section encoding fails property run trouble encoding polymorphic types 
damas milner polymorphism damas milner type system dm relies expressions indicate type generalisation allowable explicit type abstraction type application constructs 
types damas milner type system syntax simply typed calculus typing contexts generalised variables may bound type schemes form 
variable bound type scheme type quantifiers 
definition damas milner type contexts xn type context typing rules implement damas milner type system rules abstraction application simply typed calculus 
definition damas milner typing rules call name evaluation ee call name encoding expressions recomputes time value requested process expression responds request chapter 
relating typed terms typed terms value starting new copy running eventually send result polymorphic calculus extend interaction just waiting result channel sent wait tuple type arguments sent respond recomputing value instantiated types means occurrence variable expression specify instantiated types neatly matches damas milner typing rule variables 
just previous section find type instantiation closely coupled recomputation time instantiate start new copy executing 
show formally encode damas milner type system polymorphic calculus assuming call name reduction strategy 
encoding types remains cf 
definition generalise encoding contexts take account fact variables may bound type schemes definition context encoding xn xn encoding captures fact access variable xi sending tuple types result channel xi 
process implementing xi responds instantiating expression bound xi types evaluating expression returning final result result channel 
note case xi monomorphic empty sequence get exactly encoding cf 
definition 
proposition proves terms typable damas milner type system encoded typed polymorphic terms 
chapter 
relating typed terms typed terms proposition preservation calculus type structure exists 
proof induction structure omit cases abstraction application similar proof proposition 
case 
required 
case induction twice exist easy see input formed result follows 
leroy ler shown call name semantics damas milner type system proved sound language containing imperative features cells exceptions known damas milner type system unsound language call value reduction semantics tof 
harper lillibridge hl consider similar issues study typing properties cps conversion extension control operators 
calculus encode stateful computation fact call name terms typed calculus confirms leroy observation 
note bound expressions may polymorphic proposition remains true evaluate function arguments strictly 
prove calculus variables assigned type form calculus typing equal encoding damas milner typing proposition calculus typings reflect calculus type structure calculus variables assigned type form implies exists 
proof simple induction structure chapter 
relating typed terms typed terms call value evaluation choose evaluate expressions call value semantics run trouble encoding terms typable damas milner type system 
problem stems fact encoding expression call value encoding reproduced evaluated exactly time value case call name encoding 
damas milner typing rule allows type generalised assuming types generalising occur free type environment 
calculus typing rules allow type encoded expression generalised reasons explained chapter 
damas milner type system sound call value calculus don polymorphic calculus typing rules allow polymorphic 
problem stems fact calculus processes may interact ways pure functions may interact call value calculus 
typing rules calculus conservative types may generalised 
type system identifies better behaved processes encoded terms easy way allow type generalised 
chapter machine calculus calculus implemented efficiently clearly serve flexible intermediate language compilers concurrent languages view diverse high level constructs shown encodable calculus 
example calculus encode higher order communication communication processes channels san san structured datatypes mil mutable data concurrent objects wal calculus mil 
describe machine calculus simple realistic 
fact chapters compilation calculus directly machine 
primarily interested machine suitable implementation uniprocessor concurrent execution simulated interleaving execution processes 
distributed implementation poses challenges distributed garbage collection outside scope dissertation 
reduction rules machine deterministic 
sight may surprising calculus non deterministic language 
intend calculus programming language need simulate non determinism behaviour naturally arise time dependent interactions machine operating system example input output interrupt handling 
chapter 
machine calculus important calculus machine provide fair execution guaranteeing runnable processes eventually executed processes waiting communicate channel eventually succeed sufficient communication partners available 
machine calculus introduces basic mechanisms process creation channel creation communication 
prove reductions machine correspond valid calculus reductions expect converse property hold machine deterministic calculus reduction non deterministic 
number refinements machine source language 
particular record variable bindings explicitly environments substitution operation basic operations machine simple efficient implemented directly 
source language simplifications polyadic calculus attempting formulate machine 
restrict replication operator input process 
restriction significantly simpler implement replication easy detect need create new copy replicated process 
easily illustrate effect simplification calculus semantics section remove structural congruence rule pand add new reduction rule uses syntax replicated input replacing 
clear need create new copy instant replicated input communicates process compare structural congruence rule create new copies worth noting removing replication rule structural congruence relation significantly simplify meta theoretic properties chapter 
machine calculus calculus semantics easy prove structural congruence relation decidable process finitely processes structurally congruent takes considerably effort prove structural congruence decidable retain replication rule 
practice essentially occurrences replication appear recursive process definitions cf 
section encodings data structures cf 
sections 
cases replicated input operator required 
theory encode full replication terms just replicated input fv encoding real implementation quickly fill heap run queue copies second simplification surprising disallow summation operator 
disallowing summation significantly simplify implementation communication 
fact mere presence summation calculus double amount storage required channel see section details 
experience pict programming language pt suggests essential uses summation operator infrequent 
possible implement versions summation operator library module pt 
approach pay cost summation summation library communication 
languages cml rep facile gmp mix functional concurrent computation communications sufficiently infrequent additional cost implementing summation may significant 
pict computation achieved communication channels additional costs imposed summation unacceptable 
additional advantage implementing summation library module encourages programmer specialised library modules contexts require full generality summation operator 
example ref process uses summation choose accepting messages read update channels builds essentially summation iteration modulo changes argument ref represents current state 
chapter 
machine calculus def ref read ref update ref operator called replicated choice operator pt implement ref 
replicated choice operator exploits fact ref repeatedly waits input read update manages implement ref small amount set communications iteration 
addition replicated choice operator guarantees concurrent read update requests interleaved fairly read update requests stored fifo queue guarantees requests processed order arrival 
difficult impossible implement general summation operator guarantees behaviour detect summation created iteration ref process summation created previous iteration 
easiest thing vary order checks communications inside summation behaviour insufficient guarantee fair processing requests requests generated different rates read update channels 
machine states channel queues form key component machine state 
elements suspended channel queue may readers writers replicated readers 
rs range queues readers including replicated readers ws range queues writers 
denote empty queue clarify positions queue empty 
definition channel queues sn channel queue reader writer replicated reader case channel needs contain blocked readers writers reader writer pairs delay communicating 
note chapter 
machine calculus case calculus allows mixed inputs outputs inside summation operator expression process allowed communicate allow block channel machine state pair heap run queue 
heap stores channels created far processes waiting communicate channels 
run queue stores processes currently runnable 
definition machine state components xn cn heap pn run queue order bindings appear heap irrelevant order processes appear run queue important machine executes process head run queue 
place newly created processes run queue ensure runnable processes eventually executed 
similarly ordering items channel queue important wake process head channel queue communication possible 
expression denotes heap entry updated entry denotes heap extended binding definition heap update 
reduction rules machine formulated set reduction rules form rule takes process head run queue executes chapter 
machine calculus reduction step process 
run queue empty execution finished 
nil process behaviour simply remove run queue enabling process run queue start executing 
nil interpret parallel composition asymmetric manner placing run queue executed continuing execution prl restriction operator new channel heap substitutes bound variable continues executing new channel initially empty 
fresh res channel blocked writers queue execute input remove writer queue substitute supplied values bound variables place unblocked process run queue continue executing ws ws inp channel blocked readers queue execute input rs ranges queues readers suspend current process put channel queue 
note rule covers case queue associated empty 
rs rs inp channel blocked readers queue execute output unblock reader queue substituting unblocked process 
place unblocked process run queue continue executing chapter 
machine calculus rs rs channel blocked writers queue execute output ws ranges queues writers suspend current process put channel queue 
note rule covers case queue associated empty 
ws ws channel contains readers execute replicated input place replicated input channel queue 
rs rs repl channel blocked writers queue execute replicated input fork new copy substituting output values bound variables unblock writer placing run queue 
remove replicated input run queue rule effect removing writers previous rule apply replicated input removed run queue 
ws ws repl channel contains replicated input execute output place new copy replicated process run queue substitute new process 
consume replicated input put back channel queue readers able proceed 
rs rs note case contains single replicated input rule effect channel queue rs rs rs empty queue 
chapter 
machine calculus example reductions example illustrates process performs interaction channel create fresh channel substitute bound variable assume simplicity fv fork process head run queue execute output effect suspending queue process run queue unblocks process continues executing proceed run queue 
note channel reverted back empty state 
examples illustrate behaviour replication rules 
example shows reduction process assume fv simplicity 
process executes process blocks channel executed repl rule remove blocked writer repl rule install replicated input channel 
res prl repl repl chapter 
machine calculus example process installs channel gets executed 
execute rule fork copy immediately 
need suspend process previous example 
note status change executing output readers blocked res prl repl correctness machine prove machine produces valid calculus reductions 
need relate channel queues ordinary terms 
expression denotes calculus equivalent channel queue located definition encoding channel queues terms run queue pn equivalent parallel process pn easily relate machine states calculus processes definition encoding machine states terms cn cn pn cn cn cn pn order bindings heap processes run queue irrelevant consider encodings terms encoding permutation pn structurally congruent encoding pn need associativity commutativity parallel composition 
chapter 
machine calculus easy prove machine produces valid calculus reductions 
fact single reduction machine may correspond zero reductions calculus 
example prl reduction rule executes parallel process placing run queue leaving head run queue yields new machine state structurally congruent original machine state 
surprising calculus reduction rules maintain separate run queue need reduction steps move process run queue 
similarly res rule direct equivalent calculus reduction rules fact corresponds combination conversion scope extrusion tricky features calculus reduction rules 
worth mentioning conversion real computation meaning calculus reduction rules allows creation fresh channels 
quite calculus conversion completely avoided execution closed program 
theorem machine produces valid execution 
proof proceed case analysis machine rules 
omitted output replication cases similar input cases case nil easy see case prl associativity commutativity parallel composition 
case res fresh prove conversion name clash problems fresh 
scope extrusion fact required 
case inp ws ws chapter 
machine calculus case ws reduction rule communication prove result follows 
case inp rs rs rs rs rs case rs rs case rs reduction rule replicated input cf 
section prove result follows 
note converse result true expect calculus reduction non deterministic machine deterministic 
prove machine deadlocks possible calculus reductions machine state 
strictly speaking prove result restrictions machine states 
example machine deadlock machine state arity input expression incorrect calculus reduction rules ignore erroneous term infer reduction slightly different problem occurs channel queues allowed contain mixtures readers writers 
example machine deadlocks machine state calculus reduction rules reduce input output expressions contained channel queue chapter 
machine calculus say machine state formed channel queue contains mixture input output terms 
fact typed guarantees free runtime errors ensures closed expression 
easy check starting initial configuration machine rules preserve invariant channel queue contains mixture input output terms 
theorem deadlocks formed 
proof inspect reduction rules machine find formed machine state reducible non empty 
case empty case invariant channel queues ensures input output terms active channel 
important result hope prove machine implements fair reduction strategy 
attempt prove result formal definition fairness calculus topic current research pie 
conjecture machine guarantees pierce calls process fairness individual process infinitely able communicate communication partner simultaneously available infinitely eventually 
fact fifo queues channel queues run queue ensures process blocked channel queue eventually unblocked assuming sufficient communication partners available 
simplifying replicated input useful restriction terms guarantees channel contains mixture ordinary replicated inputs replicated input encounters waiting writers executes 
example chapter 
machine calculus replicated inputs appear contexts form uses input distinct variables cn cn xn pn guarantee replicated input executed channel empty 
longer need repl rule dealt case contained writers need check status executing replicated input repl rule repl restriction replication guarantees readers channel containing replicated reader 
output value channel need change state seen new rule restriction replication problematic practice uses replication example recursively defined processes exactly format 
fact translate replicated input equivalent replicated input form pict implementation enforce restriction replicated input combination syntactic restrictions special typing rules pict implements channel types proposed pierce sangiorgi ps easily check channel input particular context 
fact better job compiling outputs channels cn processes form cn cn xn pn know starts executing executed replicated inputs channels cn 
execute chapter 
machine calculus output channel ci need test status ci know ci contain single replicated input outputs ci change status 
course ci higher order manner sending ci channel process process receives ci test status ci 
refinements replicated input outputs channels containing replicated inputs necessary get reasonable performance functions encoded processes 
strict functional language need test status function calling 
calculus represent functions processes communicate distinguished channel 
example identity function represented process channel id returns result process represents rest program id id disappointing id output channel id required test status id fortunately process fits criteria optimising rule id statically known contain replicated input process starts executing 
fact disallowed mixtures inputs replicated inputs channel test status channel efficiently 
channel just states empty containing blocked writers containing blocked readers containing single replicated reader 
represent information single status value stored channel 
representation test channel status single multi way conditional expression 
allowed mixtures readers replicated readers channel queue need conditional expressions implement output test channel contained readers case reader channel second test determine reader replicated 
chapter 
machine calculus asynchronous communication pict programming language pt implementation communication simplified asynchronous communication :10.1.1.127.1777
asynchronous calculus simple sub calculus calculus restrict continuation output process 
fact asynchronous outputs common introduced derived syntax writing 
known synchronous communication simulated explicit acknowledgments asynchronous calculus 
example simulate synchronous communication asynchronous communication sequence local channel serves acknowledgment channel signals received data allowing continue 
course encoding synchronous communication terms asynchronous communication efficient implementing synchronous communication directly experience pict suggests synchronous communication fact rare 
largely due fact functions encoded processes essentially result passing convention introduced section 
means processes form results accept arguments result channel compute return results communication returns results asynchronous 
standard calling convention processes uses asynchronous communication seen derived form getting results section xn am am xn fv am chapter 
machine calculus point synchronous output communicate interested detecting starts executing finishes returns results 
show simplify machine implement asynchronous communication 
firstly syntax channel queues simplified longer need put suspended output processes channel queue retain simplifications replicated input proposed section 
useful simplification cheaper store tuple values channel queue store tuple values suspended process 
say cost suspending processes section 
definition asynchronous channel queues xn pn queue readers xn queue writers replicated reader simplify communication rules take account fact communication asynchronous 
case read value channel contains blocked writer need extract written values channel 
longer need put writer processes back run queue ws ws reduction rules asynchronous output expressions simplified executed output expression rs aout rs ws ws aout aout chapter 
machine calculus way avoid placing redundant processes run queue asynchronous communications 
consider example reduction asynchronous process new reduction rules assume channel created prl aout wasteful synchronous reduction strategy evaluate process store nil process channel queue unblock nil process interacting operations waste time space nil process behaviour prl inp note initial expressions examples identical just shorthand 
creating fewer processes key problems encounter executing calculus programs processes short lived 
consider example process creates result channel sends arguments result channel waits reply machine executes expressions andr separate processes 
wasteful expressions relatively little 
better execute andr thread control having place process run queue 
modify machine able execute number actions thread control 
relation formalises execute process single thread control 
chapter 
machine calculus takes heap process executes number operations yields updated heap run queue process execute completely blocked channel queue heap need return process result evaluating relation formalises just process scheduling policy picks process run queue executes sched reduction rules implementing communication 
see section significant advantages executing operations possible single thread control practice suspending process means preserving current process context heap executing new process requires load new process context back heap 
reduction rule restriction similar reduction rule gave previously 
simply allocate fresh channel continue executing process fresh rule parallel composition significantly different seen 
putting run queue executed evaluate thread control evaluation rule nil process returns heap run queue unchanged nil executing replicated input expression atomic operation guaranteed find channel empty res prl chapter 
machine calculus repl execute input channel contains writer continue executing current thread control ws ws execute output channel contain readers store output values channel queue ws ws aout infinite behaviour terms arises result interactions processes replicated input expressions 
rule implements interactions places process run queue ensures evaluation finite 
aout reasons clear moment aout rule execute unblocked process thread control current process breaking property evaluation finite rs rs aout set rules maximum amount required execute process determined structure replaced aout rule rule executes unblocked process thread control longer case know general big unblocked process 
rs rs important know single thread execute long may processes waiting execute run queue 
case user interface example may important waiting processes execute soon provide quick responses user input 
chapter 
machine calculus machines states environments unrealistic substitution operation record variable binding information refinement previous machine uses explicit environments record bindings variables channels 
avoids substitution means process terms modified execution 
explicit environments clearer real costs executing calculus programs 
environment simply finite mapping variables channels 
expression denotes finite map extended mapping assume distinct variables bound 
expression denotes channel associated undefined bound abbreviation 
definition environments xn need store process environment suspend process channel 
modify elements channel queue store information retain proposed simplifications machine proposed previous sections 
note particular need process environments implement queue writers 
case allowed synchronous output 
definition channel queues en xn pn queue readers xn queue writers replicated reader machine state pair heap run queue defined 
run queue stores environment process currently runnable 
chapter 
machine calculus definition machine state components xn cn heap en pn reduction rules environments process scheduling rule removes process environment run queue executes sched reduction rule nil process returns heap run queue unchanged nil rule parallel composition executes restriction operator new channel heap continues executing recording binding environment fresh writer available execute input extract stored data record environment continue executing ws ws prl res writers available execute input store current process environment channel queue 
chapter 
machine calculus rs rs inp channel blocked readers queue execute output unblock reader queue record bindings environment unblocked process 
rs rs aout channel blocked writers queue execute output store output values channel queue 
ws ws aout restrictions replicated input guarantee executed channel empty 
need suspend place channel repl channel associated contains replicated input execute output place new copy replicated process run queue recording bindings environment new process 
aout environments efficiently calculus processes created frequently tend run short amount time blocked terminating 
stands sharp contrast concurrent languages cml rep facile gmp process may significant amount sequential terminating communicating channel 
important allow processes added removed run queue allocating chapter 
machine calculus permanent storage heap 
similarly processes short lived sense try store environment bindings kind temporary area allocating environment entries heap 
fortunately see chapter mechanism place storing run queue entries temporary area possible mechanism store environment bindings generated execution 
evaluation rules previous section place process run queue need store number argument bindings time 
example aout rule needs store bindings process able consume rs rs aout fortunately need store bindings memory starts executing store run queue adding environment rule 
add new component elements run queue local environment local environments exactly description environments introduced previous section expect implemented differently 
local environment intended entity shared process difficult avoid allocating heap 
fact chapter see environments stored run queue lives special temporary storage area 
global environment may potentially long lived allocated heap 
processes may share global environment definition run queue en ln pn efficient implementation run queues mentioned earlier relies fact allocate deallocate storage run queue regular manner add new processes tail run queue remove processes chapter 
machine calculus head run queue attempt insert remove process middle run queue instance 
run queue 
storage allocated channel queues hand welldefined lifetime process blocks channel generally idea process unblocked 
process blocked channel build new environment heap 
ensure environment build minimal contains bindings process unblocked case process remains blocked channel queue significant amount time retain pointers values garbage collected 
definition presents reduction rules final machine 
machine compilation calculus 
reduction rules similar rules seen just explain important features 
environment entries created thread control possible avoid storing entries memory 
compilation calculus chapters built variable binding mechanism store variable bindings created thread control 
need explicit allocation bindings reasonable expect optimising compiler store registers 
capture fact implement environment entries thread control differently stored run queue heap add new local environment evaluation relation 
evaluations take form variable bindings stored heap contains bindings created current thread execution 
binding variable may stored global environment local environment expression bound 
note possible statically determine variable bound locally expression require runtime tests 
chapter 
machine calculus definition reduction rules local environments fresh ws ws rs fv rs rs rs ws ws fv sched nil prl res inp inp aout aout repl aout res rule stores new binding local environment current thread 
note evaluation rule parallel composition require storage allocation executed current thread control need preserve environment entries heap 
chapter 
machine calculus inp repl rules need suspend current process store environment entries channel queue build new minimal environment fv heap expression fv restricts domain set free variables 
aout aout rules store argument bindings run queue ready consumed starts executing 
require permanent storage allocated heap particularly important case aout rule infinite recursive behaviour arises result aout rule 
chapter compiling pict design primary motivation pict pt project design implement high level concurrent language purely terms calculus primitives :10.1.1.127.1777
proposals concurrent languages car hol rep mat gmp include communication primitives similar calculus 
knowledge proposed calculus primitives sole mechanism computation 
pict language consists layers simple core calculus just asynchronous calculus extended built structured data highlevel language defined translation core calculus 
yields compact formal definition core language type system pages operational semantics page derived forms pages derived typing rules pages 
means pict programs compiled way formally specified translate high level pict program core calculus compile core calculus 
efficiency pict relies exclusively efficient compilation channel communication 
compiling language poses number challenges implementor process creation large numbers processes created execution processes created frequently functions called functional language process creation fast consume little memory 
chapter 
compiling pict design process scheduling process blocked necessary preserve current state process remove run queue 
pict processes tend run short period time blocking important ensure context switches executed quickly 
blocked processes system may remain blocked long time ensure blocked process represented efficiently memory 
channel communication protocol required implement communication expensive terms code size execution time 
costs arise channel may possible states empty containing blocked readers containing blocked writers 
code input output operation process able deal possible channel states 
fortunately status channel cases known compile time enabling specialise code communication avoiding testing status channel 
channel representation channel may general contain arbitrary number blocked readers writers 
turns large percentage channels contain reader writer 
fact compiler access linear type information kpt guarantee certain channels contain reader writer 
optimise channel representation case enabling compact channel representation faster implementation communication 
pay small additional cost space time case channel hold reader writer 
describe compilation core pict compile native code allows generate efficient code sacrificing portability incur slightly increased compilation times loss efficiency 
additional benefit approach easily allow code embedded inside pict programs enabling extensive operating system library functions available example author collaboration benjamin pierce feature develop windows interface controlled pict processes 
chapter 
compiling pict design chapter describes pict core language decisions choosing representations pict data 
don describe pict built datatypes records tuples implementation standard 
chapter describes actual compilation pict source language chapter described motivated number simplifications calculus omitting summation asynchronous communication disallowing general replication operator significantly simplify implementation 
pict core language incorporates simplifications extensions source language proposed chapter 
firstly include integers booleans conditional expressions primitives feasible encodings implement important datatypes 
compiling integer boolean operations corresponding operations provided give compiler reasonable chance optimising avoid having reimplement standard optimisations arithmetic boolean operations pict compiler 
secondly allow code embedded terms 
allows easy access operations libraries available fact pict programming language feature available programmer just compiler writer 
range atomic values variables integers booleans 
atomic values generalisation channel values kind atomic value pure polyadic calculus 
definition atomic values variable 
integer constant true false boolean constant syntax processes 
note may send arbitrary atoms channels just channel names 
need chapter 
compiling pict design subject communication arbitrary atom integer boolean values may communication 
definition process syntax asynchronous output yn input yn replicated input channel creation parallel composition null process conditional code inlined code null process definable calculus deadlocked process example retain implemented efficiently 
restrictions replicated input occur chapter section replicated inputs may appear contexts form uses input distinct variables cn cn xn pn arbitrary expressions may included inside terms expression form code 
inlined code treated string pict compiler allowed refer pict variable scope 
example integer variables expression effect binding value computed expression variable binding benefits compiling reasonably high level language reuse built variable binding constructs 
compilation pict variable simply represented variable chapter 
compiling pict design name 
way avoid having consider low level details implementing variable binding efficiently register allocation 
problem course restricted notion variable binding higher order functions 
example wish suspend pict process store channel queue capture current variable bindings store channel code process 
built mechanism implementing operation points computation explicitly preserve current variable bindings closure 
fortunately mean back situation implement variable bindings help compiler practice variables consumed need create closure 
compiler free implement variable bindings chooses example registers 
data representations runtime data accessed single machine word 
bit word tag inform garbage collector word pointer heap 
chapter 
compiling pict design definition runtime data tagged value non pointer tagged value pointer descriptor data descriptor address size tagged value tagged value tagged value tag bits heap allocated value picture describes general format runtime data 
zero tag bit indicates value pointer heap 
tag bit signifies value pointer heap allocated object 
subtracting value yields address descriptor heap gives details type object 
significant bits descriptor indicate type value 
remaining bits give size object words including descriptor word 
heap allocated objects integral number words long 
definition presents possible descriptor tag values macro definitions convenient refer tags name code follows 
chapter 
compiling pict design definition tag values define empty empty channel define channel reader define channel writer define channel readers define channel writers define replicated channel replicated reader define tuple tuple values tag values indicate object descriptor channel status channel wasteful separate channel status word addition heap descriptor 
tuples store different kinds high level data closures fifo queues 
garbage collector need distinguish kinds high level data considers simple tuple tagged values 
garbage collector ignores pointers point addresses outside heap 
means store pointers data structures inside pict data structures necessary feature wish allow easy transfer data pict programs code 
allow pict pointers stored data structures outside pict heap describe mechanism 
integers booleans significant bit data value tag bit tell garbage collector value pointer represent pict integer integer definition integer representation integer built boolean operators interpret non zero integer true zero false 
easier implement conjunction disjunction chapter 
compiling pict design negation represent true integer false integer 
built comparison operators return values form anyway incur additional cost implementing pict comparison operators terms comparison operators 
definition boolean representation true false representation true clashes tagging scheme pict data cause garbage collector problems garbage collector ignores pointers point addresses outside heap address certainly outside heap 
closures processes represented heap allocated closures 
closure stores code pointer address function free variables process definition closures code pointer value value garbage collector treats closure just tuple tagged values ignores pointers point addresses outside heap gets confused presence code pointer tuple 
function address stored closure point function form described section 
channels turns practice majority input operations find channel queue empty majority output operations find chapter 
compiling pict design channel queue contains exactly reader replicated reader 
largely due fact encode functions processes 
example examine encoding function application reproduced behaves compilation find input finds channel queue empty fresh channel 
xn am am xn fv am eventually return result find exactly reader channel queue process xn 
furthermore usually case function represented replicated input output am usually find contains single replicated process 
optimise channel representation case channel contains possible replicated reader 
case need store reader written value allocate extra storage communication 
representation channels experience author gained implementing pict compiler tries job common types channel usage pict programs 
better leave decision channel representation compilation time program analysis tell approximate usage channel choose representation channel expected usage 
say analyses section 
channel descriptor indicates size channel words current channel status 
subsequent word contains tagged data value 
significant bits channel descriptor garbage collector knows channels words long 
chapter 
compiling pict design definition simple channel values empty replicated closure tagged value closure channel status isempty content value field irrelevant garbage collector examines value field case 
channel status value field contains pointer closure reader written value respectively 
channel containing replicated reader format channel containing ordinary reader treated differently communication course 
word available store written data allocate separate piece storage heap written data arity channel greater 
need store blocked reader writer allocate separate queue structure heap 
instance channel status value field points fifo queue store blocked readers shown 
representation channel status just shown store values queue closures 
chapter 
compiling pict design definition complex channel values channel reader closure fifo queue closure reader channels fifo queues ensure fairness 
fifo queues implemented keeping pointers start queue 
enables fast insertion queue get new reader writer fast removal front queue unblock waiting process 
run queue add remove processes run queue frequently important implement run queue way run queue entries consume permanent storage 
allocate run queue entries opposite heap allocate ordinary storage definition heap storage heap start allocated storage free space heap run queue limit free queue queue pointer start add entries run queue grows middle heap 
similarly allocate memory ordinary part heap free pointer moves centre heap 
memory model benefit need perform single test determine need chapter 
compiling pict design garbage collection just test difference run queue free pointer sufficiently large allocation wish 
remove entries start run queue 
gap heap 
fortunately gap easily reused need garbage collection check space gap start run queue heap 
just shift run queue back heap doing real garbage collection 
turns run queue usually short containing processes copying run queue back heap significantly cheaper doing garbage collection 
compaction heap start allocated storage free space run queue heap limit compaction unused space heap start allocated storage free space run queue heap limit data contained run queue simple format definition run queue endq value value closure closure followed number values correspond arguments process 
instance output values chapter 
compiling pict design channel contains reader represented closure add closure followed values run queue 
avoids having allocate permanent storage note possible execute unblocked process immediately general need store unblocked process consume 
chapter compiling pict implementation compilation pict parts expression denotes expression implements pict atom expression denotes statement sequence implements process expression denotes statement sequence builds closure process abstraction basic definitions macro definitions code follows definition basic macro definitions define offset val define status offset define val offset define tuple tuple define tag val offset macro takes arguments tagged word extracts th word heap object pointed note tagged subtract get address start object chapter 
compiling pict implementation heap 
assume type identifier val defined type integers size machine word 
status macro extracts word pointed contains descriptor 
val macro extracts second word pointed case channel contains value stored channel 
tuple macro constructs valid descriptor tuple size thetag macro takes pointer value tags stored heap 
processes refer small number global variables hold pointers start run queue free allocation space heap definition global variables val endq pointer run queue val pointer start run queue val free pointer free space heap encoding processes mentioned chapter processes represented heap allocated closures 
closure contains address function form described definition 
function represents process abstraction ym free variables xn note xn fv ym 
declare local variables free variables abstracted variables ym 
thing check free space heap 
allocate ordinary storage allocation region pointed free allocate run queue entries opposite heap pointed endq 
free heap endq space heap allocate heap words call garbage collector 
chapter 
compiling pict implementation definition process template void void val closure ym xn free heap endq gc heap get closure pointer closure get arguments ym bind free variables offset closure xn offset closure execute process expression heap denotes total number words wish allocate ordinary storage area run queue 
pass heap argument garbage collector guarantees returns control heap words free heap determine maximum amount storage required process see definition section details 
load variable closure value run queue pointer closure current process 
initialise argument variables ym loading values run queue 
free variables xn loaded values stored closure 
case free variables omit code loads closure body 
assume free variables xn canonical order know stored closure 
expression denotes code implements process actual translation processes described 
code implementing chapter 
compiling pict implementation refer variables normal program 
means compiler free optimise storage sets variables way program 
scheduler described representations run queue processes inhabit explain execute processes 
top level function responsible initializing heap space run queue placing initial process run queue executing processes subsequently placed run queue 
processes run top level program returns program finishes 
code implements behaviour described sched rule section 
definition main program scheduler loop void main int argc char argv initialise heap run queue free endq put initial process run queue scheduler loop endq void void offset recall endq pointers start run queue respectively 
expression denotes value run queue pointer closure 
extracts data value closure pointer function form described previous section 
cast type offset void void type pointers functions take arguments return result enabling apply resulting chapter 
compiling pict implementation value empty argument list 
effect running process run queue 
process terminates returns control scheduler loop checks processes run queue repeating procedure run queue non empty 
scheduler simple reason really separate function process finished executing code just call process run queue 
compilation scheme runs known problem compiling see jon example suppose processes run queue 
start running calling function representing 
finished doing calls function representing 
behaviour eventually cause stack overflow return functions representing processes left execute pict program finished executing 
course clever compiler notice function pi call pi action pi remove stack frame pi calling pi 
unfortunately aware compiler optimisation 
pict compiler virtue necessity uses scheduler various useful checks example checking interrupts input output data available 
atoms compilation integer boolean atoms expressions straightforward representations integers booleans section 
compilation pict variables trivial maintain convention pict variable represented variable name definition compiling atoms true false chapter 
compiling pict implementation process abstractions processes represented heap allocated closures closure contains address function general format described section 
expression ym yields statement builds closure process abstraction ym allocating closure free space heap 
definition process abstractions ym free tuple free val free 
free xn free write appropriate descriptor word says object tuple size 
write address function contains code implementing ym values closure 
increment free words created 
assume variables canonical order come implement code ym know part closure free variable stored 
assume name function fresh function defined template section encoding processes follows 
null process null process behaviour implemented empty instruction sequence 
effect returning control scheduler done current process 
code implements behaviour described nil rule section 
chapter 
compiling pict implementation definition null process channel creation create new channel assign current value free space pointer local variable tagging indicate pointer heap 
set word descriptor word empty increment free pointer size channel words 
need initialise value field channel garbage collector knows channel status empty scan value field 
process compiled scope local variable 
code implements behaviour described res rule section 
definition channel creation val tag free free empty free conditional expressions boolean values true false represented integers respectively 
representation consistent conditional statement just interpret pict conditionals conditionals 
definition conditionals chapter 
compiling pict implementation parallel composition compilation parallel composition short sweet compile parallel composition sequential composition operator 
calculus concurrent non deterministic language sequential deterministic surprising find compilation effect execution terms 
code implements behaviour described prl rule section 
definition parallel composition compilation clearly determines execute deterministic behaviour surprisingly helpful tracking programming errors 
possible simulate form non determinism required instance compile test random number runtime decide process execute basis test 
worth noting author felt need pict compiler non trivial programs plenty non deterministic behaviour arises due time dependent interactions pict code operating system example input output interrupt handling 
inline code pict variables represented variables easy insert user defined code code produced compiler definition interfacing code val code chapter 
compiling pict implementation value resulting expression containing string code bound variable example usual integer operations defined inline code follows definition integer operations addition subtraction multiplication division comparison recall pict integer represented integer implement sufficient just add representations 
subtraction implemented way 
comparison operations unaffected representation integers example pay additional cost doing simple arithmetic comparison operations tagged integers 
representation integers cause extra multiply integers divide operands multiplying representations necessary divide multiplying integers lose precision 
fact right shift operation divide usually faster doing real division 
note practice case operands multiplication constant case compute right shift operation compile time avoid additional cost multiplying tagged integers 
implementation division behaves similarly 
boolean conjunction disjunction negation implemented bitwise operators need general logical operators designed allow non zero integer interpreted true 
chapter 
compiling pict implementation definition boolean operations conjunction disjunction negation style code generation gives optimiser chance place intermediate values registers 
example pict code translated code expect reasonable optimising compiler implement registers hold values val val chapter 
compiling pict implementation fifo queue creation function allocates new fifo queue containing queue elements 
definition fifo queue creation val val val val fifo tag free allocate fifo free tuple free tag free free tag free allocate queue element free tuple free free tag free allocate second queue element free tuple free free free return fifo resulting data structure structure 
fifo contains pointers queue elements 
queue element contains linked queue element contains 
fifo queue chapter 
compiling pict implementation fifo queue insertion function inserts 
local variable pointer element queue second field point tag free location new queue element update fifo points new element 
build new queue element increment free number words allocated 
definition fifo queue insertion void val fifo val val val offset fifo offset tag free offset fifo tag free free tuple free val free free fifo queue removal function returns element channel queue contain fifo queue 
removing element find queue length remove queue structure change status status 
chapter 
compiling pict implementation definition fifo queue removal void val int status val fifo val val offset fifo val offset offset fifo status ch status val ch offset offset fifo return offset value pointer element fifo 
pointer element queue 
offset fifo element queue reset status put contents value field 
output expressions behaviour asynchronous output expression dependent status channel outputting 
switch statement select appropriate thing outputting channel 
code presents just outer structure switch statement actual code case separately 
definition output switch status 
contains reader reset status empty place closure reader stored value field run chapter 
compiling pict implementation queue 
place translations output atoms closure run queue ready consumed reader scheduler restarts 
code implements behaviour described aout rule section specialised case reader 
definition output case status empty endq val endq 
endq endq break contains replicated reader exactly thing reset status empty communicating replicated reader consume reader 
worth noting replicated cases need allocate permanent storage storage allocated run queue reclaimed doing garbage collection explained section 
code implements behaviour described aout rule section 
definition output replicated case replicated endq val endq 
endq endq break status empty set status allocate tuple store output atoms place tagged pointer tuple value field ifn need allocate tuple chapter 
compiling pict implementation space store output atom value field 
similarly need allocate tuple need write dummy value say zero value field necessary write value field garbage collector scan value field non empty channel get problem having special descriptor tag case just special case empty channels 
code implements behaviour described aout rule section specialised case channel empty 
definition output empty case empty status val tag free free tuple free 
free free break contains writer allocate fifo data structure form described section 
change status allocate fifo data structure containing queue elements value stored tuple values 
arrange queue value stored placed queue 
code implements behaviour described aout rule section specialised case just writer 
chapter 
compiling pict implementation definition output case tuple tag free free tuple free 
free free val val tuple break writers situation slightly simpler fifo data structure allocated need allocate extra queue element tuple 
insert new queue element fifo 
code implements behaviour described aout rule section specialised case channel contains writer 
definition output case val tuple tag free free tuple free 
free free val tuple break case holds readers implement inverse previous operation remove reader fifo queue readers 
chapter 
compiling pict implementation removing reader fifo queue reader left function sets status back 
implements behaviour described aout rule section specialised case reader 
definition output case endq endq 
endq endq break clearly code implementing output expression large comparison constructs earlier 
output expressions fundamental part computation mechanism pict common programs 
tried compile asynchronous output indicated generate huge amounts code toy programs 
trade code size execution time inlining code commonly executed cases putting cases library function hope library function called relative infrequently 
section describe flexible technique optimising communication finding approximations channel status compile time 
replicated input expressions restrictions occurrences replicated input see section details sure status empty execute expression yn set status replicated place tagged pointer closure yn value field recall expression yn returns sequence chapter 
compiling pict implementation statements builds closure process abstraction free space heap 
code implements behaviour described repl rule section 
definition replicated input yn status replicated val tag free yn input expressions behaviour input expressions cases similar output expressions 
main difference check status allocate closure process abstraction yn free space heap local variable closure bound tagged address closure 
case output value channel wasteful build closure yn immediately put run queue just executed directly 
fortunately case sufficiently rare simpler uniform treatment input 
definition input yn val closure tag free yn switch status 
case writer channel put closure run queue followed elements stored tuple values 
code chapter 
compiling pict implementation implements behaviour described inp rule section specialised case channel contains just writer 
definition input case val tuple val status empty endq closure endq offset tuple 
endq offset tuple endq break shame copy individual values run queue just copying pointer tuple 
wish avoid cost need multiple entry points process abstraction case closure put run queue output operation find arguments run queue case closure put run queue input operation find arguments tuple 
case channel empty store closure channel set channel status 
code implements behaviour described inp rule section specialised case channel empty 
definition input empty case empty status val closure break chapter 
compiling pict implementation remaining cases fifo queue manipulation functions similar way compilation output expressions 
code implements behaviour described inp inp rules section specialised case channel contains just reader reader writer 
definition input case status val val closure break case val closure break case val tuple endq closure endq offset tuple 
endq offset tuple endq heap usage seen compilation processes easy determine maximum number words process may need allocate 
information process template definition action process check free space allocation 
chapter 
compiling pict implementation definition heap usage heap heap heap heap heap code heap heap yn heap yn heap heap heap max heap heap heap code heap yn yn expression heap code denotes number words allocated inline code pict number provided explicitly programmer 
calculate number words required hold closure process abstraction yn calculating size set free variables yn adding word descriptor word code pointer 
definition closure size yn fv yn optimising communication code required implement input output expressions large considering fact fundamental operations pict pervasive pict programs 
fortunately plenty scope optimisation program analysis able determine state channel compile time set possible states potentially useful 
example channel known contain replicated process common situation functions implemented replicated processes avoid testing status execute appropriate code directly chapter 
compiling pict implementation definition optimised output endq val endq 
endq endq specialising code input output expressions benefits code small inline avoid testing status pict compiler uses local program analysis analysis attempt track higher order uses channels determine channels guaranteed contain replicated readers channels guaranteed empty common cases 
number researchers proposed sophisticated analyses produce similar information usually maximum size channel queue nn 
author collaboration kobayashi pierce developed linear type system pict determine channel exactly reader writer pair kpt 
linear type code definition sufficient implement output case linear input expressions similar 
linear type system ensures linear type exactly reader writer pair 
expression write capability rest program capability single read means empty rest program read capability contain single reader rest program done read 
chapter 
compiling pict implementation definition linear output status empty status val tag free free tuple free 
free free endq val ch endq 
endq endq note case contains reader need reset status empty linearity ensures processes input output capabilities consumed 
performance purpose chapter investigate calculus implemented efficiently considered reasonable operational foundation concurrent programming 
get rough idea performance code generated pict compiler wrote solutions problem 
wrote ml program solve problem translated pict pict high level derived forms functions 
table indicates pict version program approximately times slower produced new jersey ml compiler version 
considering simplicity compilation pict code generator implemented just lines ml performance pict quite surprise 
chapter 
compiling pict implementation time code size new jersey ml kb pict kb cml kb get idea fast implementation communication converted ml program cml rep program cml concurrent extension ml implements channel communication top new jersey ml 
converted functions returning results directly returned results explicit result channel matches way return results functions encoded pict 
channels implement functions cml built support replicated inputs 
seen cml ran example times slower pict 
reader attach importance exact quoted number differences difficult quantify differences garbage collection strategy 
reassuring find performance pict code uses just channel communication ball park functional code 
especially worth bearing mind pict loses performance just compile native code 
tarditi acharya lee tal compiling native code costs factor new jersey ml code 
paying similar price compiling pict reasonably expect native code generator improve performance pict factor new jersey ml 
pict compiler produces smaller programs new jersey compiler 
compiling calculus pict tiny runtime system just lines 
code normally live runtime system appears inline code pict programs 
gives pict compiler ability discard code unused program compiled helps contribute small code size pict programs 
chapter related chapter review related type systems implementation techniques concurrent calculi 
shown chapter strong relation calculus types calculus types discuss calculus type systems 
type systems compare type system milner original sort system mil mil polyadic calculus inspired calculus type system 
milner sort system partitions channels term subject sorts 
subject sort associated object sort xn association written xn 
object sort describes members particular subject sort may communication 
example process say sort sort channels sort carry pairs channels sort channels sort carry empty tuple 
example sorted communicate pair expected sort 
similarly communicate empty tuple 
sort equivalent type type system sort equivalent type 
typing previous example chapter 
related milner allows recursive sorts 
example sort integer lists list list nil cons nil cons int list compare corresponding recursive type type system list int list conjecture typed terms type system coincide milner sorted terms 
note milner sorts allow partition channels carefully types 
example sorts considered equivalent 
matching sorts name structure quite attractive 
suppose different intended uses wish avoid accidentally place case part semaphore 
set milner sorting system detect confusion note technique useful explicitly typed calculus 
previously mentioned type system evolved milner sort system 
decided traditional type theoretic techniques reasons 
milner sort system simple sort information global 
example closed term trivial type sort information required inside term visible top level 
unsatisfactory causes number technical problems proving subject reduction 

possible formulate polymorphic sorts complicated polymorphic types system 
chapter 
related 
sufficiently powerful polymorphic type system possible distinguish values isomorphic type datatype encodings section 
vasconcelos honda vh independently proposed monomorphic type system polyadic calculus similar treat recursive types traditional way interpreting recursive types regular trees 
prove type system sound principal type property essentially identical techniques proposed 
pierce sangiorgi ps developed calculus type system uses idea tags capture additional information channel controlling channel may written read 
type system thought refinement type system developed independently 
give essence idea notation 
introduce new channel types types input output channels respectively 
clearly ordinary channel type allows input output place input output channel 
terms subtyping relation usual subtyping systems introduce rule subsumption values refine typechecking rules input output operators new channel types chapter 
related clearly derive original rules input output rules subsumption show required 
suppose purposes explanation introduce record patterns values typing rules vn ln vn ln pn ln pn ln allow subtyping records usual way 
pierce sangiorgi give subtyping rules new channel types 

ln ln subtyping rule input channels says forget information value receive input channels 
example forget field age int record sent string name string age int name subtyping rule output channels dual says send extra information output channels 
example send record extra field male true name string age int name string age int name dave age male true rule ordinary channel types states invariant subtyping relation subtyping safe input output channels 
suppose allow covariant subtyping input output channels similar example constructed allow contravariant subtyping 
typecheck chapter 
related example subsumption incorrect channel subtyping rule promote type name string 
clearly example cause runtime error sent record lacking age field 
name string age int name string age int name dave pict type system pt uses pierce sangiorgi channel subtyping subtyping record values patterns :10.1.1.127.1777
type inference vasconcelos honda vh independently developed type inference algorithm similar 
algorithm takes process argument constructs principal context formed 
easily derive similar algorithm type inference algorithm definition new type inference algorithm xn xn free variables distinct type variables return 
conjecture algorithm equivalent proposed vasconcelos honda modulo fact type inference recursive types 
note case closed term algorithms coincide vasconcelos honda algorithm returns trivial type gay gay developed algorithm infers principle sorts terms milner sort system 
algorithm unification algorithm sorts 
example unify sorts chapter 
related yielding substitution identifies sort unification similar unification regular trees cou algorithm vasconcelos honda type inference algorithm 
subject sorts particularly convenient unifying recursive sorts 
unification algorithms recursive trees tags record nodes visited ensuring unification algorithm terminates 
unnecessary sort unification node object sort labelled subject sort 
need keep record subject sorts visited 
polymorphic types vasconcelos vas independently proposed polymorphic type system calculus special case polymorphic type system 
relies explicit expressions indicate type generalisation may occur just damas milner type system 
form expression process definitions def xn xn type system allows process definitions xn polymorphic types forcing ordinary channels 
section showed typing rules polymorphic channels give rise derived typing rule polymorphic process definitions 
conjecture vasconcelos polymorphic calculus strict sub calculus polymorphic calculus 
note benefit restricting type generalisation process definitions type inference simpler fact just damas milner type system vasconcelos type system principal types computed automatically 
languages hol poly ml mat cml rep facile gmp concurrent extensions standard ml mth allow chapter 
related limited form channel polymorphism retain standard ml polymorphic type system 
known damas milner type system unsound presence side effecting computation care taken typing channel creation operator 
example cml rep channel function creates new channels channel 
weakly polymorphic type type channel necessary avoid giving types unsound programs val ch channel send ch 
accept ch expression channel type channel 
fact weak type variable means unsafe generalise type 
allowed polymorphic instantiate type ch int channel expression send ch channel expression accept ch clearly unsound process sending integer ch expecting boolean 
side effect treatment channel creation channels status functions datatypes comes polymorphic typing 
instance server function supposed wait pair sent id reply sending explained chapter reason channel id polymorphic server example essentially transliteration example chapter 
unfortunately type id polymorphic type channel weakly polymorphic 
val id channel fun server val receive ch send server chapter 
related thomsen tho illustrates improve behaviour polymorphic channels effect system context facile language 
type system quite complicated able allow type id polymorphic 
implementation number proposals machines concurrent calculi ama car gmp 
high level implementation communication identical described cardelli car 
machine unique implements communicating processes 
example machines proposed amadio ama gmp separate secd machine implement process execution facile processes may involve calculus reduction communication 
practice fact rely communication sole computational mechanism means take care representing channels processes 
instance unaware implementation channel communication implements replicated input construct concurrent languages rely functional part language express infinite behaviour prove built recursive process definitions aware compiler implements language sole computational mechanism channel communication 
compilation calculus dissertation quite closely related sml compiler described tal 
representation calculus processes reminiscent continuation passing style code generation new jersey ml compiler am sml compiler built 
chapter dissertation looked calculus perspective concurrent programming 
shown calculus admits simple type system extended include advanced type theoretic features familiar calculus 
fact pict programming language pt author collaboration benjamin pierce developed higher order polymorphic calculus includes subtyping higher order subtyping extensible records :10.1.1.127.1777
experience date suggests refinements calculus type systems applicable typed calculus 
fact communication protocols enforced datatypes see section details gives real reason believe type system able catch significant number common errors calculus programs 
reason avoided complicating channels types complex protocol information type checking type inference difficult 
pict datatypes provided polymorphic type system extensively library code pt ensure internal representations built datatypes integers booleans manipulated functions supplied compiler 
course say useful refinements channel types 
pict type system includes useful refinement proposed pierce sangiorgi ps distinguishes input output chapter 
capabilities channels see chapter details 
linear type system developed author collaboration kobayashi pierce kpt presents useful refinement channel types 
refinements add modest amount information channel types retain simple type inference type checking algorithms 
problem type inference polymorphic calculus interesting problem required 
expressiveness polymorphic type system type inference decidable general 
pict compiler currently gets problem partial type inference algorithm 
allows explicit type information omitted 
experience pict suggests partial type inference algorithm quite usable practice writes explicit type information programs anyway simple form program documentation 
sort type inference appear formal definition pict description partial type inference required 
compilation calculus dissertation forms basis pict language implementation 
compilation implemented pict compiler really match modulo simple refinements avoid incrementing free space pointer cache values global variables local variables enable compiler better job optimising pict programs 
nice find calculus simple concise compilation despite simplicity able provide reasonable performance 
having efficient implementation calculus possible real programming pict 
largest pict programs developed far comprise approximately lines pict code implement graphical user interface toolkit performance perfectly acceptable form incremental garbage collection helpful 
compilation calculus designed easily exploit information channel status compilation time 
interesting area development appropriate program analyses calculus 
linear type system proposed kobayashi pierce author kpt example analysis potential refinements 
chapter 
examples chapter hint problem encounters programming calculus calculus quite low level language irritating feature need deal result channels explicitly 
solved problem defining number derived forms 
pict language takes similar approach starts core language just asynchronous calculus extended built structured data defines high level language series derived forms 
style formal language definition concise type system pages operational semantics page derived forms pages derived typing rules pages 
necessary extend pict type system add new derived forms simply derive high level typing rules basic calculus typing rules sections example 
additional benefit soundness high level pict type system depends soundness pict core language type system 
believe calculus type system enables calculus simple type theoretic foundation concurrent programming 
compilation calculus efficient allow calculus basis compiling high level concurrent programming languages 
bibliography ac robert amadio luca cardelli 
subtyping recursive types 
acm symposium principles programming languages january 
am andrew appel david macqueen 
standard ml compiler 
functional programming languages computer architecture pages 
springer verlag 
ama roberto amadio 
translating core facile 
technical report ecrc tr european computer industry research centre 
bo simon brock gerald 
process semantics graph reduction 
technical report cs computer science division university st andrews 
car luca cardelli 
implementation model communication 
seminar concurrency number lecture notes computer science 
springer verlag 
car luca cardelli 
amber machine 
combinators functional programming languages number lecture notes computer science 
springer verlag 
cc felice mario coppo 
type inference recursive types 
syntax semantics 
information computation 
cou courcelle 
fundamental properties infinite trees 
theoretical computer science 
dm luis damas robin milner 
principal type schemes functional programs 
acm symposium principles programming languages january 
bibliography joost engelfriet gelsema 
multisets structural congruence pi calculus replication 
technical report tr department computer science leiden university leiden netherlands 
gay simon gay 
sort inference algorithm polyadic calculus 
acm symposium principles programming languages 
gir girard 
interpr tation fonctionelle elimination des arithm ordre sup 
phd thesis paris 
gmp alessandro mishra prasad 
facile symmetric integration concurrent functional programming 
international journal parallel programming volume april 
paul hudak simon peyton jones philip wadler brian boutel jon fairbairn joseph fasel mar guzm kevin hammond john hughes thomas johnsson dick kieburtz nikhil partain john peterson 
report programming language haskell 
technical report version march 
hl robert harper mark lillibridge 
explicit polymorphism cps conversion 
technical report cs cmu department computer science carnegie mellon university october 
hol functional language parallel programming 
declarative programming workshop programming methodology group chalmers university technology university goteborg sweden 
jon simon peyton jones 
implementing lazy functional languages stock hardware spineless tagless machine 
journal functional programming april 
naoki kobayashi akinori yonezawa 
static analysis communication asynchronous concurrent programming languages 
technical report department information science university tokyo april 
kpt naoki kobayashi benjamin pierce david turner 
linearity pi calculus 
acm symposium principles programming languages 
bibliography ler xavier leroy 
polymorphism name continuations 
acm symposium principles programming languages pages 
mat david matthews 
distributed concurrent implementation standard ml 
technical report ecs lfcs laboratory foundations computer science university edinburgh august 
mil robin milner 
theory type polymorphism programming 
journal computer system sciences 
mil robin milner 
calculus communicating systems volume lecture notes computer science 
springer verlag 
mil robin milner 
communication concurrency 
series computer science 
prentice hall international 
mil robin milner 
functions processes 
technical report institut national de recherche en informatique en automatique sophia antipolis february 
final version journal mathematical structures computer science 
mil robin milner 
polyadic calculus tutorial 
technical report ecs lfcs laboratory foundations computer science university edinburgh october 
proceedings international summer school logic algebra specification marktoberdorf august 
mil robin milner 
sorts calculus 
third workshop concurrency compositionality germany 
mp john mitchell gordon plotkin 
types existential type 
acm transactions programming languages systems pages july 
mps david macqueen gordon plotkin ravi sethi 
ideal model recursive polymorphic types 
information control 
mpw robin milner joachim parrow david walker 
calculus mobile processes part 
technical report ecs lfcs laboratory foundations computer science university edinburgh june 
bibliography mpw robin milner joachim parrow david walker 
calculus mobile processes part 
technical report ecs lfcs laboratory foundations computer science university edinburgh june 
mpw milner parrow walker 
calculus mobile processes parts ii 
information computation 
mth robin milner mads tofte robert harper 
definition standard ml 
mit press 
nn hanne riis nielson flemming nielson 
higher order concurrent programs finite communication topology 
acm sigplan sigact symposium principles programming languages acm press 
od gerald antony davie 
calculus characterisations practical calculus reduction strategies 
technical report cs department mathematical computing sciences university st andrews october 
pie benjamin pierce 
machines fairness pict 
personal communication 
ps benjamin pierce davide sangiorgi 
typing subtyping mobile processes 
ieee symposium logic computer science june 
pt benjamin pierce david turner 
concurrent objects process calculus 
ito akinori yonezawa editors theory practice parallel programming sendai japan nov number lecture notes computer science pages 
springer verlag april 
pt benjamin pierce david turner :10.1.1.127.1777
pict programming language pi calculus 
pt benjamin pierce david turner 
pict standard libraries 
department computer science university cambridge university glasgow 
rep john reppy 
concurrent ml design application semantics 
programming concurrency simulation automated reasoning number lncs pages pp 

springer verlag 
bibliography rey reynolds 
theory type structure 
lecture notes computer science springer verlag 
rey john reynolds 
types abstraction parametric polymorphism 
ifip congress paris september 
rob robinson 
machine oriented logic resolution principle 
journal association computing machinery january 
san sangiorgi 
expressing mobility process algebras order higher order paradigms 
phd thesis department computer science university edinburgh 
published technical report ecs lfcs 
san sangiorgi 
calculus higher order calculus back 
proceedings tapsoft lncs 
springer verlag 
san davide sangiorgi 
theory bisimulation calculus 
technical report ecs lfcs laboratory foundations computer science university edinburgh 
tal david tarditi anurag acharya peter lee 
assembly required compiling standard ml technical report cmu cs department computer science carnegie mellon university november 
tar alfred tarski 
lattice theoretical fixpoint theorem applications 
pacific journal mathematics 
tho bent thomsen 
polymorphic sorts types concurrent functional programs 
technical report ecrc european computer industry research centre 
tof mads tofte 
operational semantics polymorphic type inference 
phd thesis department computer science university edinburgh may 
vas vasco vasconcelos 
predicative polymorphism calculus 
proceedings th conference parallel architectures languages lecture notes computer science 
springer verlag july 
bibliography vh vasco vasconcelos kohei honda 
principal typing schemes polyadic pi calculus 
proceedings concur july 
available keio university report cs 
wal david walker 
calculus semantics object oriented programming languages 
conference theoretical aspects computer software university japan 
