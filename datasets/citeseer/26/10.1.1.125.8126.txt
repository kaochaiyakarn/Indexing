automata theoretic approach linear temporal logic moshe vardi 
rice university department computer science box houston tx email vardi cs rice edu url www cs rice edu vardi 
automata theoretic approach linear temporal logic uses theory automata unifying paradigm program specification verification synthesis 
programs specifications essence descriptions computations 
computations viewed words alphabet 
programs viewed descriptions alphabet 
automata theoretic perspective considers relationships programs specifications relationships languages translating programs specifications automata questions programs specifications reduced questions automata 
specifically questions satisfiability specifications correctness programs respect specifications reduced questions nonemptiness containment automata 
classical automata theory focused automata finite words applications program specification verification synthesis automata infinite words computations interested typically infinite 
provides theory automata infinite words demonstrates applications program specification verification synthesis 
program verification desirable easy task advent concurrent programming significantly necessary difficult 
conceptual complexity concurrency increases likelihood program containing errors 
quote ol large body sad experience indicate concurrent program withstand careful scrutiny revealing errors step program verification come formal specification program 
widely specification languages concurrent programs temporal logic pnu mp 
temporal logic comes varieties linear time branching time eh lam concentrate linear time 
linear temporal part done ibm almaden research center 
specification describes computations program program satisfies specification correct computations satisfy specification 
course specification interest satisfiable 
unsatisfiable specification satisfied program 
advocated approach program development avoid verification step altogether specification synthesize program guaranteed correct 
approach specification verification synthesis intimate connection linear temporal logic automata theory discussed explicitly see pei sis vw 
connection fact computation essentially infinite sequence states 
applications consider state described finite set atomic propositions computation viewed infinite word alphabet truth assignments atomic propositions 
basic result area fact temporal logic formulas viewed finite state acceptors 
precisely propositional temporal formula construct finite automaton infinite words accepts precisely computations satisfied formula vw 
describe applications basic result satisfiability testing verification synthesis 
extensive treatment automata theoretic approach verification see kur 
classical automata theory focused automata finite words applications specification verification synthesis automata infinite words computations interested typically infinite 
going applications give basic theory automata infinite words 
help readers build intuition review theory automata finite words contrast theory automata infinite words 
advanced theory automata infinite objects readers referred tho 
automata theory finite nonempty alphabet finite word element finite symbols infinite word element sequence symbols automata finite words define finitary languages sets finite words automata infinite words define infinitary languages sets infinite words 
automata finite words closure nondeterministic finite tuple finite nonempty alphabet sis finite nonempty set states sis nonempty set initial states set accepting states sis transition function 
intuitively set states move state sand reads 
note automaton may nondeterministic may initial states transition function may specify possible denotes infinite ordinal 
transitions state symbol 
deterministic sand 
automaton essentially edge labeled directed graph states automaton nodes edges labeled symbols certain set nodes designated initial certain set nodes designated accepting 
means edge witha 
deterministic transition function viewed partial mapping extended partial mapping follows sand xw forx 
finite sequences states thats si ai note nondeterministic automaton runs input word 
contrast deterministic automaton run input word 
accepting 
picture automaton having green light switched automaton accepting state switched automaton non accepting state 
run accepting green light run 
accepted accepting run deterministic wheres fs 
finitary language ofa set finite words accepted bya 
important property automata closure boolean operations 
start considering closure union intersection 
proposition 
rs leta automata 

proof leta anda 
loss generality assume thats ands disjoint 
intuitively ora runs input word 
leta wheres ifs ifs easy see thatl 
proof union ofa anda 
proposition 
rs leta automata 

proof leta anda input word 
leta wheres 
easy see thatl 
proof product ofa anda 
note union product constructions effective polynomial size constituent automata 
anda 
intuitively consider issue complementation 
consider deterministic automata 
proposition 
rs leta deterministic automaton thenl 
easy complement deterministic automata just complement acceptance condition 
nondeterministic automata nondeterministic automaton runs input word runs reject accept input word runs reject input word 
complement nondeterministic automaton 
proposition 
rs nondeterministic automaton 
deterministic thatl ad 
proof leta 
fs fd 
state set sets states single initial state 
gis collection sets states 
tg 
intuitively possible runs input word run larger state set 
construction called subset construction 
combining propositions complement 
construction effective involves exponential blow determinization involves exponential blow 
shown mf exponential blow determinization complementation unavoidable 
example fix 
set finite words alphabet fa position right accepted automaton fi intuitively position input word checks checks right input 
suppose deterministic fs fewer accepts language 
recall viewed partial mapping 
uav 
uav members ad contradicting assumption thatl ad consists exactly words position right uj uj automata infinite words closure suppose input infinite word sequences wheres si si ai alli 
run infinite define acceptance type final state run 
consider limit behavior ng fng run 
define lim infinitely sg set states occur 
finite lim necessarily nonempty 
accepting accepting state repeats lim 
picture automaton having green light switched precisely automaton accepting state run accepting green light switched infinitely times 
infinite accepted bya thenl accepting run 
infinitary language ofa set infinite words accepted bya 
viewed automaton finite words automaton infinite fag fs tg fsg fsg anda fag fs tg fsg ftg thatl words 
viewed automaton infinite words called chi automaton 
automata infinite words closure properties similar automata finite words 
cases answer positive proofs may involved 
start considering closure union 
union construction right thing 
proposition 
cho leta chi automata 

tempted think similarly case 
accepting set ofa product accepting sets ofa anda 
accepts infinite accepting andr ofa anda respectively runs go infinitely simultaneously accepting states 
requirement strong 
result strict subset ofl 
example define chi fsg 
clearly thatl fa closure intersection hold 
proposition 
cho leta chi automata 
chi automaton thatl 
proof leta anda 
leta wheres ifs andi ori andt 
intuitively anda input word 
automaton viewed having tracks ofa anda 
addition remembering state track pointer points tracks 
track goes accepting state pointer moves track 
acceptance condition guarantees tracks visit accepting states infinitely run accepts iff goes infinitely 
means track visits infinitely accepting state pointer pointing track 
track visits accepting state pointer pointing track pointer changed point second track 
pointer returns point track second 
track visits accepting state 
second track visit accepting state infinitely 
chi automata closed union intersection construction intersection somewhat involved simple product 
situation considerably involved respect closure complementation 
shall shortly see chi automata closed determinization nondeterministic chi automata expressive deterministic chi automata 
second obvious complement deterministic chi automata 
consider deterministic chi 
may think suffices complement acceptance condition fand define 
going infinitely going infinitely throughs run go infinitely 
may strict superset 
example consider chi fag fs tg fsg fsg fsg 
thatl fa chi automata deterministic nondeterministic closed complementation 
proposition 
chi automaton alphabet possibly nondeterministic chi thatl 
construction doubly exponential 
improved singly exponential construction quadratic exponent thena states 
contrast exponent wherea fs construction proposition linear 
come back complexity complementation 
return issue determinization 
show nondeterministic chi automata expressive deterministic chi automata 
consider infinitary language consists infinite words occurs finitely times 
easy see defined nondeterministic chi automaton 
leta fs tg fsg ftg fs tg 
states initial state accepting state long states read inputs 
point nondeterministic transition statet point read input 
easy see 
contrast defined deterministic chi automaton 
proposition 

deterministic chi 
proof assume way contradiction deterministic 
recall viewed partial mapping 
consider infinite 
clearly accepted bya accepting run 
finite 
consider infinite 
clearly accepted bya accepting run 
finite 
ui uj ui alphabet fag fs tg fsg ftg similar fashion continue find finite finite ui uj 
follows accepting run word infinitely occurrences 
note complementary language set infinite words occurs infinitely acceptable deterministic chi automaton fs tg fsg fsg ftg 
automaton starts state simply remembers symbol read 
nondeterminism proposition essential 
understand subset construction chi automata consider automata singleton anda fag fs tg fsg ftg fs tg fs tg fsg 
easy see thata accept infinite word infinite run visit statet 
contrast accepts infinite run st accepting 
apply subset construction automata cases initial state fsg fs tg andd fs tg fs tg 
subset construction distinguish anda 
able automata finite words consider general acceptance condition 
finite nonempty set states 
rabin condition collection pairs sets states written lk uk drop external brackets condition consists single pair 
rabin automaton infinite words acceptance condition specified rabin condition form 
accepting lim li lim ui pair left set visited infinitely right set visited finitely 
rabin automata expressive chi automata 
proposition 
cho rabin automaton chi automaton thatl ab 
proof leta lk uk 
easy see thatl ki ai li ui 
chi automata closed union proposition suffices prove claim rabin conditions consists single pair say 
idea construction take copies ofa anda 
chi ina stays long wants 
point transition stays visiting 
formally ab sb sf 
note construction proposition effective polynomial size automaton 
ui andb hs restrict attention deterministic automata rabin automata expressive chi automata 
recall infinitary language 
showed earlier definable deterministic chi automaton 
easily definable rabin automaton 
leta fs tg fsg ftg fsg fsg ftg 
automaton starts state simply remembers symbol read 
easy see 
additional expressive power rabin automata sufficient provide closure determinization 
proposition 
mcn chi automaton 
deterministic rabin thatl ad 
proposition proven mcn doubly exponential construction provided 
improved saf singly exponential linear exponent construction provided nlogn states ando pairs 
furthermore shown saf ej determinization construction modified yield determinization construction construction deterministic rabin thatl ad ad underlying alphabet 
determinization construction singly exponential linear exponent thena nlogn states ando pairs 
combining determinization construction polynomial translation rabin automata chi automata proposition get complementation construction complexity singly exponential linear exponent 
improves previously mentioned bound complementation singly exponential quadratic exponent essentially optimal mic 
contrast complementation automata finite words involves exponential blowup linear exponent section 
complementation automata infinite words provably harder complementation automata finite words 
constructions exponential finite case exponent linear infinite case exponent nonlinear 
automata finite words algorithms automaton interesting defines interesting language language empty contains possible words 
nonempty ifl 
fundamental algorithmic issues automata theory testing automaton interesting nonempty 
nonemptiness problem automata decide nonempty 
problem automata decide 
turns testing nonemptiness easy testing hard 
proposition 
rs jon 
nonemptiness problem automata decidable linear time 

nonemptiness problem automata nlogspace complete 
proof leta automaton 
lets tbe states ofs 
say directly connected 
say connected sequences sm states sn directly connected essentially tis connected path viewed edge labeled directed graph 
note edge labels ignored definition 
easy see thatl nonempty iff andt connected tos 
automata nonemptiness equivalent graph reachability 
claims follow observations 
breadth search algorithm construct linear time set states state ins clr ais nonempty iff set nontrivially 

graph reachability tested nondeterministic logarithmic space 
algorithm simply guesses states guesses states directly connected tos guesses states directly connected tos reaches statet 
recall nondeterministic algorithm accepts sequence guesses leads acceptance 
care sequences guesses lead acceptance gj 
step algorithm needs remember current state state algorithm needs keep logn bits suffice describe state 
hand graph reachability nlogspace hard jon 
proposition 
ms 
problem automata decidable exponential time 

problem automata pspace complete 
proof note thatl iff complementary automaton ofa see section 
suffices nonemptiness 
recall exponentially bigger 
nonemptiness tested linear time follows tested exponential time 
nonemptiness tested nondeterministic logarithmic space tested polynomial space 
argument requires care 
simply test nonemptiness exponentially big 
fly nonemptiness algorithm wants move statet statet algorithm checks directly connected tot 
verified algorithm 
step algorithm needs keep memory states need generate single step algorithm 
yields nondeterministic polynomial space algorithm 
eliminate nondeterminism appeal known theorem savitch sav states dspace forf logn istic algorithm uses quadratically larger amount space 
particular nondeterministic algorithm uses logarithmic space simulated determin nondeterministic polynomial space algorithm simulated deterministic polynomial space algorithm 
prove pspace hardness shown pspace hard problem reduced problem 
logarithmic space algorithm polynomial space bounded turing wis non universal ms hu 
automata infinite words algorithms results chi automata analogous results section 
proposition 
tl 
el el nonemptiness problem chi automata decidable linear time 

vw nonemptiness problem chi automata nlogspace complete 
proof leta automaton 
claim thatl nonempty iff andt connected tos connected 
suppose thatl nonempty 
accepting input word 
clearly si directly connected alli 
connected accepting particular si sj 
tis connected tos connected 
conversely suppose andt connected tos connected 
connected tos sequence sequence si ai similarly connected sequence sequence tk ti bi accepting run ak bl nonempty 
chi automata nonemptiness reducible graph reachability 

depth search algorithm construct decomposition graph strongly connected components clr ais nonempty iff component possible reach nontrivial component intersects 
strongly connected component nontrivial contains edge means strongly connected contains cycle 

algorithm simply guesses states guesses states directly connected tos guesses states directly connected tos reaches statet 
point algorithm continues move nondeterministically states directly connected 
clearly algorithm needs logarithmic memory needs remember description states step 
ik 
il 
sk tl nlogspace hardness follows nlogspace hardness nonemptiness automata finite words 
proposition 

problem chi automata decidable exponential time 

problem chi automata pspace complete 
proof iff complementary automaton ofa see section 
suffices nonemptiness 
exponentially bigger nonemptiness tested linear time follows tested exponential time 
nonemptiness tested nondeterministic logarithmic space tested polynomial space 
polynomial space algorithm fly 
pspace hardness follows easily pspace hardness universality problem automata finite words wol 
automata finite words alternation nondeterminism gives computing device power existential choice 
dual gives computing device power universal choice 
compare complexity classes np np gj 
natural consider computing devices power existential choice universal choice 
devices called alternating 
alternation studied cks context turing machines bl cks finite automata 
alternation formalisms bl cks different equivalent 
follow formalism bl 
setx letb set positive boolean formulas boolean formulas built elements allow formulas true false 

say formula truth assignment assigns true members assigns false members ofx example satisfy formula satisfy formula 
consider nondeterministic 
transition function maps states sand input set states 
element set possible nondeterministic choice automaton state 
represent example fs written 
alternating automata arbitrary formula 
instance transition meaning automaton accepts symbol word states accepts ands 
transition combines features existential choice disjunction formula universal choice conjunctions formula 
formally alternating automaton finite nonempty alphabet sis finite nonempty set states sis initial state notice unique initial state fis set accepting states transition function 
universal choice alternating transitions run alternating automaton tree sequence 
tree finite infinite connected directed graph node designated root denoted non root node unique parent sis parent child edge root parent 
level distance root particular 
branch tree maximal sequence nodes root parent alli 
note finite infinite 
labeled tree finite alphabet pair tree mapping assigns node label refer labeled tree 
branch infinite wordt consisting sequence labels branch 
formally run finite labeled tree holds xk example nodes run tree level include labels labels include labels labels 
note depth ofr maximal level node inr branches need reach depth ai true need children 
hand ai false false satisfiable 
run accepting nodes labeled states inf 
branch accepting run hit true transition hit accepting state reading input word 
relationship alternating automata nondeterministic automata 
turns just nondeterministic automata expressive power deterministic automata exponentially succinct alternating automata expressive power nondeterministic automata exponentially succinct 
show alternating automata expressive succinct nondeterministic automata 
proposition 
bl cks lei nondeterministic automaton 
alternating thatl aa 
proof leta 
fs wheres new state defined follows forb ands ai xk wt wt 
take empty disjunction definition equivalent false 
essentially transitions viewed disjunctions 
special treatment needed initial state allow set initial states nondeterministic automata single initial state alternating automata 
note essentially size asa descriptions length 
show alternating automata expressive nondeterministic automata 
proposition 
bl cks lei alternating automaton 
nondeterministic thatl 
andv andv proof leta 
sn ffs gg fn fn fp aig fp big ha ii fp qg take empty conjunction definition equivalent true 
intuitively run tree ofa 
point run ofan keeps memory level run tree ofa 
reads input symbol guesses level run tree ofa 
translation alternating automata nondeterministic automata involves lets exponential blow 
shown bl cks lei blow unavoidable 
example fix fa bg 
nbe set words different symbols 
easy see nis accepted nondeterministic ng fpg fqg intuitively input word reads input symbol position right checks contains different symbol 
note thata states 
propositions alternating automaton states accepts complementary language suppose nondeterministic nd fewer accepts 
wan accepting run 
distinct 
sn vis accepting run different symbols 
advantage alternating automata easy complement 
need define dual operation formulas inb 
intuitively dual ft jt satisfies fha hb ii ha ni ha ni fqg hb ni hb ni fqg 
formula obtained switching switching true false 
example 
note considering formulas inb simply apply negation formulas 
formally define dual operation follows 
suppose alternating 
alls sanda 
transition function 
proposition 
bl cks lei alternating automaton 

combining propositions obtain nonemptiness test alternating automata 
proposition 
cks 
nonemptiness problem alternating automata decidable exponential time 

nonemptiness problem alternating automata pspace complete 
proof remains shown pspace hardness nonemptiness 
recall pspace hardness shown proposition generic reduction 
logarithmic space algorithm polynomial turing wis 
proposition alternating automaton thatl aa am size proposition aa aa 
am wis nonempty 
automata infinite words alternation forx true false false true saw earlier viewed automaton finite words automaton infinite words 
similarly alternating automaton viewed automaton infinite words case called alternating chi automaton ms 
leta alternating chi automaton 
run infinite possibly infinite labeled holds xk ai xk accepting infinite branch infinitely labels inf 
note run finite branches ai true need children 
alternating automata alternating chi automata expressive nondeterministic chi automata 
show alternating automata expressive succinct nondeterministic automata 
proof proposition identical proof proposition 
proposition 
ms nondeterministic chi automaton 
alternating chi thatl aa 
reader may expect alternating chi automata expressive nondeterministic chi automata 
proof fact involved proof finite word case 
proposition 
mh alternating chi automaton 
nondeterministic chi thatl 
proof finite word case run ofa 
point run keeps memory level run ofa tree 
reads input symbol guesses level run tree ofa 
nondeterministic automaton keep information occurrences accepting states order sure infinite branch hits accepting states infinitely 
level run sets distinguish branches branches 
andv andv fg leta 
sn fn state pair sets states ofa fs single initial state pair consisting singleton empty set fn proof construction correct requires careful analysis accepting runs ofa 
important feature construction blowup exponential 
complementation alternating automata easy proposition case alternating chi automata 
run difficulty ran section going infinitely accepting states going infinitely non accepting states 
propositions 
follows alternating chi automata closed complement precise complexity complementation case known 
combining propositions obtain nonemptiness test alternating chi automata 
proposition 

nonemptiness problem alternating chi automata decidable exponential time 

nonemptiness problem alternating chi automata pspace complete 
proof remains shown pspace hardness nonemptiness 
show nonemptiness problem alternating automata reducible nonemptiness problem alternating chi automata 
leta alternating automaton 
consider alternating chi fors true fors 
claim thatl 
suppose 
accepting 
accepting run ofa true fors wu 
suppose hand 
accepting 
accepting state infinite branches nig lemma finite 
finite accepting run jj sou 
linear temporal logic automata infinite words formulas linear time propositional temporal logic ltl built atomic propositions closed application boolean connectives unary temporal binary temporal pnu 
ltl interpreted computations 
computation function prop assigns truth values elements time instant natural number 
computation ik kj 
abbreviated asf says holds eventually formula says holds henceforth 
example request says request holds continuously eventually granted 
say satisfies formula iff 
computations viewed infinite words alphabet prop 
shall see set computations satisfying formula exactly accepted ij ij iff ij ij ij ij 
ij iff ij iff 
iff finite automaton infinite words 
fact proven sph 
proof induction structure formulas 
unfortunately certain inductive steps involve exponential blow negation corresponds complementation seen exponential 
result complexity translation nonelementary may involve unbounded stack exponentials complexity bound form height stack isn 
theorem establishes simple translation ltl alternating chi automata 
theorem 
mss var ltl formula build alternating chi ino thatl exactly set computations satisfying formula 
proof states consists subformulas negation identify formula 
initial states 
accepting states consists formulas form 
remains define transition function construction variation notion dual section 
dual formula obtained switching switching true false addition negating subformulas ins xq isp xq 
formally true false false true 
define note defined induction structure consider 
easy see types infinite branches 
infinite branch labeled point formula form formula form 
infinite branch labeled point ensures fails point fails point 
hand infinite branch labeled point byu ensure holds point ensure eventually holds 
allow infinite true ifp false ifp 
fp qg fpg fqg branches labeled allow infinite branches labeled byu true consists formulas form 
example 
consider formula uq 
alternating chi automaton associated isa fp qg qg described table 
true false true true true false false false true false true false true state hold state thena requires pto satisfied state satisfied state satisfied state 
eventually reach state 
note states reachable appear run ofa 
fpg applying proposition get corollary 
vw ltl formula build chi automaton thatl exactly set computations satisfying formula 
proof corollary vw direct go alternating chi automata 
advantage proof separates logic combinatorics 
theorem handles logic proposition handles combinatorics 
example 
consider formula hold point 
chi automaton associated isa fpg described table 
gf stay forever state 
choose go state 
transition keep rejects 
note thata transition state point state accepting 
accepts precisely point 
applications satisfiability ltl formula satisfiable computation 
unsatisfiable formula uninteresting specification unsatisfiability indicates erroneous specification 
satisfiability problem ltl decide ltl formula satisfiable 
theorem 
sc satisfiability problem ltl pspace complete 
proof corollary ltl formula construct chi automaton size exponential length accepts precisely computations satisfy 
satisfiable nonempty 
reduces satisfiability problem nonemptiness problem 
nonemptiness chi automata tested nondeterministic logarithmic space proposition exponential size get polynomial space algorithm algorithm constructs fly 
prove pspace hardness shown pspace hard problem reduced satisfiability problem 
logarithmic space algorithm polynomial space bounded turing ltl formula wis satisfiable 
ltl formula valid computation 
valid formula uninteresting specification 
validity problem ltl decide ltl formula valid 
easy see valid iff satisfiable 
validity problem ltl pspace complete 
verification focus finite state programs programs variables range finite domains 
significance class follows fact significant number communication synchronization protocols studied literature essence finite state programs liu rud 
state characterized finite amount information information described certain atomic propositions 
means finite state program specified propositional temporal logic 
assume finite state program ltl formula specifies legal computations program 
problem check computations program legal 
going define notions precisely 
finite state program atomic propositions structure finite set states wis initial state rw total accessibility relation andv truth values propositions state 
intuition states program state includes content memory registers buffers location counter possible transitions states allowing nondeterminism states propositions tells states true 
assumption total state child technical convenience 
view terminated execution repeating forever state 
infinite states alli 
computation ofp 
say ltl formula computations 
verification problem check 
complexity verification problem measured different ways 
fix specification measure complexity respect size program 
call measure program complexity measure 
precisely program complexity verification problem complexity fixed 
secondly fix measure complexity respect size specification 
call measure specification complexity measure 
precisely specification complexity verification problem complexity 
complexity combined size program specification combined complexity 
complexity class 
say program complexity verification problem formula 
say program complexity verification problem hard gis hard formula 
say program complexity verification problem complete hard 
similarly say specification complexity verification problem program say specification complexity verification problem hard gis hard say specification complexity verification problem complete hard 
describe automata theoretic approach verification problem 
finite state viewed chi automaton set accepting states equal set states infinite run automaton accepting 
ap set computations finite state ltl formula verification problem verify infinite words accepted formula 
corollary know build chi accepts exactly computations satisfying formula 
verification problem reduces automata theoretic problem checking computations accepted automaton accepted isl ap 
equivalently need check automaton ap empty note corollary states 
straightforward approach starting proposition complement result doubly exponential blow 
get intersection automata proposition 
consequently build automaton ap states 
need check automaton emptiness 
proposition get results 
fw iff 
theorem 
lp sc vw 
program complexity verification problem complete nlogspace 

specification complexity verification problem complete pspace 

checking finite state ltl formula done jpj 
note time upper bound polynomial size program exponential size specification considered reasonable specification usually short lp 
practical verification algorithm automata theoretic approach see 
synthesis previous section dealt verification finite state program ltl specification verify program meets specification 
frequent criticism approach verification done significant resources invested development program 
programs invariably contain errors verification simply part debugging process 
critics argue desired goal specification program development process order guarantee design correct programs 
called program synthesis 
turns solve program synthesis problem need automata infinite trees 
rabin tree automata rabin tree automata run trees witha uniform branching degree recall definition labeled trees section 
infinite setf kg set finite sequences kg 
elements nodes tree 
nodes ofk edge xis parent child ofx 
empty sequence root ofk 
branch infinite sequence nodes parent alli 
ary finite alphabet assigns node label 
refer labeled trees trees intention clear context 
branch infinite wordt consisting sequence labels branch 
ak ary rabin tree tuple finite alphabet sis finite set states sis set initial states rabin condition transition function 
automaton input ary trees 
note set ofk tuples 
intuitively automaton reading nondeterministically chooses ak moves ary ans ary tree root labeled initial state transitions obey transition function xk 
run accepting ifr branch ofk 
xi branch pair infinitely xi finitely note different branches satisfied different pairs ing 
language ofa set trees accepted bya 
easy see rabin automata infinite words essentially ary rabin tree automata 
nonemptiness problem rabin tree automata decide rabin tree nonempty 
nonemptiness problem automata finite infinite words nonemptiness problem tree automata highly nontrivial 
shown decidable rab algorithm nonelementary time complexity time complexity bounded fixed stack exponential functions 
elementary algorithms described hr rab 
algorithm hr runs doubly exponential time algorithm rab runs exponential time 
years eme vs shown nonemptiness problem rabin tree automata np 
ej shown problem np complete 
relevant size parameters rabin tree automata 
transition size size transition function sum sizes sanda transition size clearly takes account number states ins 
second number pairs acceptance 
application need complexity analysis nonemptiness problem takes account separately parameters 
proposition 
ej pr rabin tree automata transition pairs nonemptiness problem solved time mn 
words nonemptiness problem rabin tree automata solved time exponential number pairs polynomial transition size 
see distinction quite significant 
realizability classical approach program synthesis extract program proof specification satisfiable 
ec mw shown extract programs finite representations models specification 
late researchers realized classical approach suited closed systems open systems dil pr alw 
open systems program interacts environment programs called reactive programs hp 
correct reactive program able handle arbitrary actions environment 
applies techniques ec mw reactive programs obtains programs handle certain actions environment 
pr alw dil argued right way approach synthesis reactive programs consider situation infinite game environment program 
finite states prop 
intuition observable states system 
see emphasis observability 
infinite word 
intended meaning describes sequence states system goes transition caused environment odd program 
program move state environment responds second move program counters third move 
associate say ltl formula ifv satisfies 
goal program satisfy specification face possible move environment 
program control environment moves controls moves 
situation viewed infinite game environment program goal program satisfy specification 
infinite games introduced gs fundamental importance descriptive set theory mos 
histories finite words 
history finite wi consisting states moved environment history empty sequence fori 
program functionf histories states 
idea program scheduled point history ish program cause change 
captures intuition program acts reaction environment actions 
run si hist 
state transitions caused program consistent 
specification run 
correct program viewed winning strategy game environment 
say realizable respect satisfies case say 
sequel omit explicit mention clear context 
turns satisfiability sufficient guarantee realizability 
example 
consider case fpg fpg 
consider 
formula requires true clearly satisfiable 
way program enforce requirement environment moves state 
realizable 
hand hold infinitely realizable fact realized simple program maps history state 
shows realizability stronger requirement satisfiability 
consider specification 
corollary build chi automaton thatl exactly set computations satisfying formula 
state prop construct chi thatl exactly set behaviors satisfying formula simply 
follows assume loss generality winning condition game environment program expressed chi game run accepted bya 
say chi automaton runs accepted bya 
say realizable 
turns realizability problem chi automata essentially solvability problem described chu 
winning condition chu expressed ijk monadic second order theory successor function known sentences translated chi automata 
solvability problem studied bl rab 
shown rab problem solved rabin tree automata 
consider suppose loss generality ifr kg 
represented aw ary 
consider im note history 
conversely aw ary 
consider im forj note node ofk 
ary trees viewed programs 
hard see runs branches 
branch wherex xj ij forj 
run 
conversely run branch wherex xj xj andt xj 
way visualize think edge labeled 
sequence edge node labels refer branches aw ary runs oft say chi runs accepted bya 
obtained proposition 
chi 
reduced realizability problem ltl specifications problem chi decide realizes step reduce problem nonemptiness problem rabin tree automata 
construct rabin accepts precisely trees 
iff tree 
theorem 
chi fg fg kg construct ak ary rabin tree transition size nlogn ando pairs thatl precisely set trees 
proof consider input 
rabin tree verify branch 
parallel branches oft 
need deal fact labels information actions information actions environment implicit edges 
suppose thata 
define chi reading pairs input symbols time 
sf sf ha bi fht ffor fht fht ffor intuitively applies transitions remembering transition 
note construction doubles number states 
easy prove claim claim accepts infinite hw ha ha ki ando accepts infinite 
order able parallel branches apply proposition toa obtain deterministic rabin thatl ad 
commented section nlogn states ando pairs 
fq 
construct rabin tree automaton parallel branches oft letb fq defined follows intuitively feeding pairs consisting node label edge label 
note ha ii ik claim precisely set trees 
remains analyze size ofa 
clear nlogn states pairs 
deterministic transition size nlogn 
apply proposition solve realizability problem 

theorem 
alw pr realizability problem chi automata solved exponential time 
proof theorem chi alphabet kg construct ak ary rabin tree transition size nlogn ando pairs thatl precisely set trees realize proposition test nonemptiness logn 
corollary 
pr realizability problem ltl solved doubly exponential time 
states thatl exactly set computations satisfying formula 
combining bound theorem get time bound 
pr shown doubly exponential time bound corollary essentially optimal 
realizability problem ltl decidable worst case highly intractable 
example 
consider situation fpg andv fpg 

transitions empty 
note deterministic 
automaton reads pairs symbols transitions empty 
construct rabin tree automaton proof corollary ltl formula build chi wf fh ig wf fh ig hw wf empty 
clearly implies realizable 
note corollary tells decide ltl formula realizable 
shown pr algorithm proposition provide just answer 
rabin nonempty algorithm returns finite representation infinite tree accepted 
turns representation converted realizes specification 
turns program finite state program 
means finite function nw function remembering requires unbounded memory program needs 
performs action sees environment updates memory 
note memory internal program pertinent specification 
contrast observable states pertinent specification 
am grateful orna kupferman moller comments earlier drafts 
alw abadi lamport wolper 
realizable unrealizable concurrent program specifications 
proc 
th int 
colloquium automata programming volume pages 
lecture notes computer science springer verlag july 
bl chi hg 
landweber 
solving finite state strategies 
trans 
ams 
bl brzozowski 
finite automata sequential networks 
theoretical computer science 
chi 
decision method restricted second order arithmetic 
proc 
internat 
congr 
logic method philos 
sci 
pages stanford 
stanford university press 
cho choueka 
theories automata tapes simplified approach 
computer system sciences 
chu church 
logic arithmetics automata 
proc 
international congress mathematicians pages 
institut leffler 
cks chandra kozen stockmeyer 
alternation 
journal association computing machinery 
clr cormen leiserson rivest 
algorithms 
mit press 
courcoubetis vardi wolper yannakakis 
memory efficient algorithms verification temporal properties 
formal methods system design 
dil dill 
trace theory automatic hierarchical verification speed independent circuits 
mit press 
ec emerson clarke 
branching time logic synthesize synchronization skeletons 
science computer programming 
eh emerson halpern 
revisited branching versus linear time 
journal acm 
ej emerson jutla 
complexity tree automata logics programs 
proceedings th ieee symposium foundations computer science pages white plains october 
ej emerson jutla 
simultaneously complementing automata 
proceedingsof th ieee symposium logic computer science pages 
el emerson 
lei 
modalities model checking branching time logic strikes back 
proceedings twelfth acm symposium principles programming languages pages new orleans january 
el emerson 
lei 
temporal model checking generalized fairness constraints 
proc 
th hawaii international conference system sciences pages hawaii 
eme emerson 
automata tableaux temporal logics 
logic programs volume lecture notes computer science pages 
springer verlag berlin 
gj garey johnson 
computers intractability guide theory np completeness 
freeman san francisco 
gabbay pnueli shelah 
temporal analysis fairness 
proceedingsof th acm principles programming languages pages january 
gs gale stewart 
infinite games perfect information 
ann 
math 
studies 
hp harel pnueli 
development reactive systems 
apt editor logics models concurrent systems volume nato advanced summer institutes pages 
springer verlag 
hr rackoff 
emptiness problem automata infinite trees 
proc 
th ieee symp 
switching automata theory pages 
hu hopcroft ullman 
automata theory languages computation 
addison wesley new york 
jon jones 
space bounded reducibility combinatorial problems 
journal computer system sciences 
kur robert kurshan 
computer aided verification coordinating processes automata theoretic approach 
princeton university press princeton new jersey 
lam lamport 
temporal logic programs 
proceedingsof th acm principles programming languages pages january 
lei 
regular boolean automata 
theoretical computer science 
liu liu 
protocol engineering 
advances computing 
lp lichtenstein pnueli 
checking finite state concurrent programs satisfy linear specification 
proceedings twelfth acm symposium principles programming languages pages new orleans january 
lichtenstein pnueli zuck 
glory past 
logics programs volume lecture notes computer science pages brooklyn 
springer verlag berlin 
mcn mcnaughton 
testing generating infinite sequences finite automaton 
information control 
mf meyer fischer 
economy description automata grammars formal systems 
proc 
th ieee symp 
switching automata theory pages 
mh miyano hayashi 
alternating finite automata words 
theoretical computer science 
mic michel 
complementation difficult automata infinite words 
cnet paris 
mos moschovakis 
descriptive set theory 
north holland 
mp manna pnueli 
temporal logic reactive concurrent systems specification 
springer verlag berlin 
ms meyer stockmeyer 
equivalence problem regular expressions squaring requires exponential time 
proc 
th ieee symp 
switching automata theory pages 
ms muller schupp 
alternating automata infinite trees 
theoretical computer science 
mss muller schupp 
weak alternating automata give simple explanation temporal dynamic logics decidable exponential time 
proceedings rd ieee symposium logic computer science pages edinburgh july 
mw manna wolper 
synthesis communicating processes temporal logic specifications 
acm transactions programming languages systems january 
ol owicki lamport 
proving liveness properties concurrent programs 
acm transactions programming languages systems july 
pei regular languages propositional temporal logic 
technical report eth 
pnu pnueli 
temporal logic programs 
proc 
th ieee symposium foundation computer science pages 
pr pnueli rosner 
synthesis reactive module 
proceedings sixteenth acm symposium principles programming languages austin 
rab rabin 
decidability second order theories automata infinite trees 
transaction ams 
rab rabin 
automata infinite objects church problem 
regional conf 
ser 
math providence rhode island 
ams 
rs rabin scott 
finite automata decision problems 
ibm research development 
rud rudin 
network protocols tools help produce 
annual review computer science 
saf safra 
complexity omega automata 
proceedings th ieee symposium foundations computer science pages white plains october 
sav savitch 
relationship nondeterministic deterministic tape complexities 
computer system sciences 
sc sistla clarke 
complexity propositional linear temporal logic 
journal association computing machinery 
sis sistla 
theoretical issues design analysis distributed systems 
phd thesis harvard university 
sph sherman pnueli harel 
interesting part process logic uninteresting translation pl pdl 
siam computing 
sistla vardi wolper 
complementation problem chi automata applications temporal logic 

tho thomas 
automata infinite objects 
handbook theoretical computer science pages 
var vardi 
nontraditional applications automata theory 
computer software proc 
int 
symposium tacs volume lecture notes computer science pages 
springer verlag berlin 
vs vardi stockmeyer 
improved upper lower bounds modal logics programs 
proc th acm symp 
theory computing pages 
vw vardi wolper 
automata theoretic approach automatic program verification 
proceedings symposium logic computer science pages cambridge june 
vw vardi wolper 
reasoning infinite computations 
information computation 
wol wolper 
synthesis communicating processes temporal logic specifications 
phd thesis stanford university 
wolper vardi sistla 
reasoning infinite computation paths 
proc 
th ieee symposium foundations computer science pages tucson 
