framework certified program analysis applications mobile code safety 
bor evan chang adam george necula university california berkeley california usa bec necula cs berkeley edu 
certified program analysis analysis implementation accompanied checkable proof soundness 
framework purpose simplify development certified program analyses compromising run time efficiency analyses 
core framework novel technique automatically extracting coq proof assistant specifications ml implementations program analyses preserving large extent structure implementation 
show framework allows developers mobile code provide code receivers untrusted code verifiers form certified program analyses 
demonstrate efficient implementations framework bytecode verification typed assembly language proof carrying code 
static analysis verification tools validating safety important consider question results analyses trustworthy 
question answer analysis algorithms implementations increasingly complex order improve precision performance scalability 
describe framework goal assist developers program analyses producing formal proofs implementations sound respect concrete semantics code 
call analyses certified come machine checkable proofs soundness 
seek soundness assurances foundational avoid assumptions trust relationships don objectives users 
contributions deal making development analyses practical particular emphasis sacrificing analysis process 
strong soundness guarantees certified program analyzers important potential cost wrong results significant 
research supported part nsf ccr ccf ccr nsf graduate fellowship fellowship 
information necessarily reflect position policy government official endorsement inferred 
ability check independently implementation sound allows construct mobile code receiver allows untrusted parties provide code verifier 
code verifier program analysis proof soundness entails soundness code verification main contributions framework propose describe methodology translating automatically analyses written general purpose language currently ml models specifications proof assistant currently coq 
specifically handle aspects general purpose language translate directly founded logic proof assistant suchas side effects non primitive recursive functions 
framework interpretation derive soundness theorems proved certified analysis 
show design flexible efficient mobile code verification protocol untrusted code producer complete freedom safety mechanisms compilation strategies mobile code long provide code verifier form certified analysis proof soundness witnesses analysis enforces desired code policy 
section describe program analysis framework example analyzer 
sect 
technique specification extraction code written general purpose language 
program analyzer certification process sect 

sect 
application certified program analysis mobile code safety highlight describe implement architecture foundational typed assembly language java bytecode verification proof sect 

survey related sect 
conclude sect 

certified program analysis framework order certify program analysis consider proving directly implementation analysis 
possible framework expect alternative strategy simpler 
anal ysis certified write certifier runs analysis checks results 
prove soundness certifier 
approach advantages 
certifier simpler analysis 
example need iterate instruction need complicated heuristics analysis speed convergence fixpoint 
expect certifier prove sound analysis 
biggest benefit existing implementation program analysis black box written language ready analyze formally analysis algorithm fit perfectly formalism desired fig 

certified verifier architecture trusted code base shaded certification soundness proofs 
extreme example analysis contain model checker want soundness proof formalism interpretation 
fig 
diagram architecture purpose mobile code safety 
distinguish installation time activity occurs analyzer activity occurs program analyze 
choose theory interpretation foundation proofs generality soundness conditions simple understood 
developers sect 
describe soundness verification 
type type abs pc nat val abs list val abs result datatype result fail succ abs list core certifier isan untrusted custom module containing implementation transition relation provided certifier developer custom module certifier implement signature 
type abs encodes include program counter value type chosen certifier developer 
value consists 
minimum include invariants entry points code destination jump 
function transition relation state particular instruction compute set successor states minus states part transition relation may fail example state ensure safe execution instruction 
take advantage write safety checkers mobile code framework 
implementation examples ml language custom 
fun fun top nat list todo abs list bool case todo nil true rest list member pc false case fail false succ top pc todo top nil fig 

trusted top level analysis engine 
list cons append respectively order exe cute framework pro vides trusted engine shown fig 
main entry point function top invoked list program processed list states process 
tion ensured mechanisms invocation untrusted guarded time program counter processed 
timeout simple alternative proving termination successful run fig 
intended certify states properties verifying program invariant function succeeds reachable instructions 
take advantage ofthis property write untrusted code verifiers framework sect 

discuss guarantees precisely sect 

example java bytecode verifier 
introduce example program ana requires expressivity general purpose programming language highlights challenges specification extraction 
particular con sider certifier style java bytecode verifier operating simple assembly language bytecodes 
fig 
presents fragment ofthis custom verifier 
value partial map registers class names missing entry denoting uninitialized register function show case memory write instruc tion 
framework provides sel accessor function partial maps decoder partial function returns typeof field certain offset partial function super returns superclass class 
case succeeds destination address form register pointing object class offset field type super class type register 
omit code function preconditions meta data packaged class files andthen uses iterative fixed point algorithm find typing precondition program label 
precondition satisfied time actual implementation registers hold code pointers return addresses dynamic dispatch addresses assigned types specify state expected destination code block 
type reg class type abs pc nat fun subclass class class fun abs list val abs list fun abs result case pc write case sel sel csrc case subclass csrc succ pc pc fail fail fail 
fig 

skeleton verifier style java bytecode verifier control reaches label 
kind algorithm standard studied inthe context java bytecode verifier omit details 
importantly need reason formally algorithm 
specification extraction obtain certified program analyses need methodology bridging implementation analysis specification suitable proof assistant 
attractive technique start proof program extraction supported proof assistants coq isabelle obtain implementation 
strategy proof centric yield sound implementation hard control non soundness related aspects code efficiency instrumentation interaction external libraries 
alternative verification conditions function annotated pre postcondition entire program compiled single formula validity implies specification 
formulas inputs automated deduction tools usually quite confusing human prover 
structure original program 
plus experience auxiliary functions program analyzer jobs serving subclass function inevitable proving soundness sufficiently complicated require human guidance seek approach maintains close fun subclass depth nat class class bool option orelse case super false sup depth subclass depth sup fig 

translation subclass function 
boxed elements added translation correspondence implementation model possible 
non recursive purely functional programs easily achieve ideal implementation reasonably function model suitable logic coq proof assistant 
suggests need way handle imperative features method dealing non primitive re cursive functions 
remainder section give overview approach 
detail companion technical report 
handling recursion 
expect invocations recursive certification terminate may inconvenient write functions primitive recursive form required coq 
framework termination function invocations timeouts 
means successful run time bound stack depth 
observation functions primitive recursive call stack depth 
translate function definition add argument depth checked decremented function call fig 
shows result translating typical implementation running example 
boxed elements added translation 
note order able signal timeout return type option type 
coq accept function primitive recursive depth argument 
translation preserves partial correctness property code 
forexample prove specification invocation yields true implies classes subclass relationship thenthe property holds original code terminates value true 
handling imperative features 
function 
uses operations read decode basic block invariants class file kvm version java fixed point computation deduce basic block preconditions method start precondition standard class files :10.1.1.106.647
case uses significant number imperative constructs external libraries 
example demonstrates situation result computations hint exact value important soundness completeness 
believe writing suggests monadic style translation unnecessarily complicate resulting specification :10.1.1.100.9674
fun buff int array idx int int fun buff int array idx int int buff buff fig 

translation function reading bit bit big endian numbers class file 
original body translation buff buff situations propose cheaper translation scheme result side effecting operations 
describe scheme informally means example functions read java class file bit bit numbers respectively written big endian notation shown fig 

update mutable state ignored 
syntactic occurrence state access replaced fresh function argument abstraction call stack state 
call stack argument needed ensure relationship deduced recursive syntactic state access 
function body reads mutable state calls functions read mutable state gets new parameter abstraction call stack state 
function function needs call stack argument uses fresh transformer produce new actual state argument 
abstraction sound sense ensures results mutable state accesses property prove abstraction holds actual implementation 
call stack argument prove invocation function produces result results multiple 
example shows depth argument abstraction call stack state 
note state differs known explicit state passing style functional programming state literally track mutable aspects execution environment 
translation style function updates state take input state produce output state passed statement 
scheme states passed callers result type function change 
cost simplicity translation loss completeness 
weare interested preserving semantics input programs 
conjecture refactor programs soundness depend imperative parts get away looser translation 
particular want able prove properties input translation 
need opposite inclusion hold 
soundness specification extraction 
argue informally sound ness specification extraction mutable state 
implementation soundness code implements extraction procedure assumed 
investigation ways relax assumption 
observe syntactic occurrence function call unique transformer 
means execution trace speci fication function call actual state argument obtained unique sequence applications transformers initial state furthermore function invocation syntactic occurrences mutable state read unique access functions applied state parameter 
means execution trace specification state read value abstracted unique combination functions 
turn means trace original program definition parameters yields results actual reads transformers left proof specification works model transformers applies execution trace original program 
formal proof companion technical report 
soundness certification techniques described previous section convert ml datatype abs description domain logic proof assistant 
similarly convert value set ai transition function transition relation succ abuse identify sets lists convenient 
prove soundness transition relation respect con crete transition relation 

transition system 
particular domain states set allowable 
step transition relation 
elements provided proof assistant logic trusted 
build safety policy inter ests 
usual way disallow transitions violate policy errors modeled stuck 
precise way inwhich specify trusted safety policy certified program verifiers sect 
certify soundness program analyzer certifier developer needs provide additionally form coq definition soundness relation written holds state sound abstraction concrete state demonstrate author provides proofs coq standard local soundness properties interpretations bi simulations 
property initialization 
exists ai initialization property assures interpretation appropriate invariant possible concrete initial state 
property progress 
exists 
progress guarantees state stuck corre sponding concrete states stuck 
property preservation 

ai preservation guarantees step concrete machine resulting concrete state matches successor states machine 
preservation required machine program 
allows machine reject safe programs desires 
important notice order ensure termination function relation returns successor part initial states 
aspect ai preservation theorem properties imply global soundness certifier implements interpretation stated theorem certification soundness 
concrete state reach able initial state concrete machine progress program counter state ai technical report give idea obligations met sketching proof goes example java bytecode verifier shown fig 

applications mobile code safety language security mechanisms gained acceptance enforcing essential safety properties memory type safety untrusted mobile code 
widely deployed solution mobile code safety byte code verification java virtual machine jvm microsoft common intermediate language ms cil :10.1.1.12.7398
bytecode verifier uses interpretation track types machine registers enforce memory type safety 
main limitation approach soundness bytecode verifier 
turn means easily change verifier enforcement mechanism 
effectively clients code receiver fixed type system fixed source language mobile code 
programs written source compiled trusted intermediate language unnatural ways loss expressiveness performance example ms cil language expressive target compilers 
compilers produce verified compilers intermediate language instructions rejected built bytecode verifier case code may accepted producer code provide explicit proof code obeys required safety policy receiver uses proof carrying code 
existing proof carrying code pcc attests versatility fails address essential issue proof objects obtained 
touchstone system proofs generated special theorem detailed knowledge java object layout compilation strategies 
foundational pcc eliminates need hard code knowledge cost increasing times proof generation burden 
systems incur cost transmitting proofs open verifier project proposes send code program proofs proof generators run code receiver 
generated proofs checked trusted proof checker standard pcc setup certified program analyses improve process 
producer mobile code writes safety policy verifier customized compilation strategy safety reasoning generation mobile code 
verifier written form certified transition fails verify safety instruction 
example discuss sect 
cases typed assembly language checker bytecode verifier actual pcc verification engine relying annotations accompanying mobile code 
key element soundness proof accompanies analysis checked automatically 
verification time trusted program analyzer validate code need manipulate explicit 
simplifies writing validator compared theorem prover touchstone open verifier 
show insect 
reduces validation time order magnitude 
point soundness proof respect semantics 
adding additional safety checks concrete semantics instance logical equivalents dynamic checks enforce safety policy code receiver construct customized safety policies 
case studies section case studies applying certified program mobile code security 
describe experience verifiers typed assembly language java bytecode proof carrying code developed prototype implementation certified program analysis infrastructure 
concrete language analyzed intel bly language 
specification extractor built top front ocaml compiler supports large fragment ml language 
features supported object oriented features 
addition line extractor trusted computing base includes ocaml compiler coq proof checker designed small 
focus exploring ease run time efficiency approach 
leave minimizing trusted 
typed assembly language 
realistic framework assembly language 
particular developed proved correct verifier talx provided release tools 
tal includes interesting features including continuation universal existential recursive product sum stack array types 
handles features test cases distributed exception modularity features handle hand linking multiple file tests single files 
includes compilers tal popcorn safe dialect mini scheme 
unchanged case study 
implemented talx verifier lines ml code 
code size type checker lines ocaml 
developed verifier course months simultaneously implementing certification infrastructure 
expect possible construct new verifiers comparable week time infrastructure stable 
proved local soundness properties implementation lines coq definitions proof scripts 
took month interleaved developing trusted parts infrastructure 
re definitions previous tal formalization didn re proofs 
significantly reduce effort required constructing custom proof tactics experiences 
don believe formalization novel fundamental way 
uses previous foundational tal 
main difference prove basic theorems behavior implementation ofthe type checker properties inference rules 
proofs slightly cumbersome see brings improvement 
expected fixed bugs verifier course proving soundness 
suggests useful developer interested debugging analysis 
conv cpv pcc table 
average verifier run ning times seconds table presents verification results implementation average running times inputs par ticular counts assembly instructions 
ran number verifiers test cases pro vided assembly instructions 
typechecker included finishes resolution timing technique don include results 
type checker operates special typed assembly language results give verifying programs types macro instructions meta data 
result expect inherent slow instructions compiled multiple real instructions 
experiments performed athlon xp gb ram seconds 
give times conventional conv thin wrapper type checker native assembly code cpv certified program verifier implementation pcc talx verifier implementation previous explicit proof checked verification 
results show cpv verifier performs comparably con verifier formal correctness proof exists 
appears cpv verifier small constant factor conventional verifier 
inefficient lisp serialization format including meta data current implementation 
expect faster binary encoded system elaborate version 
see certified verifier performs better 
difference performance due cost required manipulate check explicit proof objects verification 
provide evidence aren comparing poorly constructed straw man look projects 
wu appel stump give performance re sults prolog implementation trustworthy verifiers 
results input programs instructions seconds ghz pentium iv 
par pcc implementation 
trusted code base smaller require trust specification extractor hope achieve similarly small checking kernel techniques related 
java bytecode verification 
framework implementa partial java bytecode verifier lines ml 
checks properties full check mainly excluding exceptions subroutines 
implementation structure follows closely running example sect 

begins calling calculates fixed point standard techniques 
example precise code doesn matter purpose populate hash table function preconditions control flow join point invariants 
information function implements rules 
extracted complete proof obligations implementation begun process proving 
sure track acceptable final product performed simple bench marks bytecode verifier included blackdown java linux 
downloaded java projects sourceforge ran verifier class project 
largest prototype implementation handle verifier finishes seconds checking bytecode instructions compared second traditional verifier 
note relatively small absolute sense 
probably takes user considerably longer download software package verify method see verifier small factor away matching traditional approach performance know empirically users accept 
doubt engineering effort close gap come close doing 
proof carrying code 
implement version foundational framework basic block mobile code contains invariant start block proof strongest postcondition invariant block implies invariant successor block 
state abs certifier consists predicate written intended strongest postcondition program point 
obtained reading invariants data segment mobile code 
fun prf proof pred bool fun abs result case pc succ pc pc eq exists jump dest prf prf imply dest succ fail fig 

fragment certifier pcc fig 
shows code cal strongest postcondition ev ery instruction 
jump fetch variant destination proof andthen check proof 
prove soundness need ensure invariants part function sound 
call returns true concrete satisfies satisfies dest 
particular care works gets proof decrypts decom presses produces proof 
soundness proof possible reasonably straightforward weare writing meta proofs coq expressive logic 
related certified program analyses 
system developed similar respect goal providing realistic framework certified program analyses 
focus simpler compiler analysis problems soundness today automated methods 
expect proofs similarly automated framework kinds analyses expressible style domain specific languages 
systems developed specifying program analyses indomain specific languages generating code specifications 
expressiveness systems limited compared standard mobile code safety problems 
direction established body extracting formal verification conditions programs annotated specifications 
especially relevant tools produce coq proof obligations output 
amount constructing trustworthy veri extracting code constructive proofs soundness 
extracted data flow analysis proof general 
klein nipkow bertot built certified java bytecode verifiers program extraction code generation programs isabelle coq respectively 
publications performance figures suggest extracted verifiers scale real enforcing mobile code safety 
alluded earlier prior tional proof carrying code focused generality expressivity various formalisms including original project syntactic foundational talt :10.1.1.12.2113
projects convincing arguments expressiveness demonstrated scalable implemen tation 
research looked efficiency considerations implementations including wu appel stump open verifier 
architecture proposed wu appel stump fairly similar propose restriction verifiers implemented prolog 
essence build interpretation engine wu etal 
build prolog interpreter 
feel important support verifiers developed traditional programming languages 
provided wu demonstrated scalability 
past open verifier heavily influenced design program analysis architecture 
approaches build interpretation engine trusted base allow uploading 
open verifier essentially adheres standard pcc architecture involves proof generation checking verified pays usual performance price doing 
strategy simplifying task proving soundness program analysis algorithms implementations 
starting implementation extracting natural proof tions allow developers fine tune non functional aspects code performance debugging instrumentation certified program analyses immediate applications developing certified program verifiers untrusted parties customize cation process untrusted code 
created prototype implementation demonstrate infrastructure support way proof carrying code type checking data flow verification style bytecode verifiers 
completed verifier typed assembly language 
performance certified verifier quite par traditional talx type checker 
believe results provide published evidence foundational code certification system scale 

appel 
foundational proof carrying code 
proc 
th symposium logic computer science pages june 

appel felty 
semantic model types machine instructions proof carrying code 
proc 
th symposium principles programming languages pages jan 

barthe de sousa 
tool assisted specification verification javacard platform 
proc 
th international conference algebraic methodology software technology sept 

benton kennedy russell 
compiling standard ml java bytecodes 
proc 
international conference functional programming pages june 

bertot 
formalizing jvml verifier initialization theorem prover 
proc 
th international conference computer aided verification volume lncs pages july 

blanchet cousot cousot feret min rival 
static analyzer large safety critical software 
proc 
conference programming language design implementation pages 


kawa compiling dynamic languages java vm 
proc 
freenix track usenix annual technical conference 

jensen 
extracting data flow analyser constructive logic 
schmidt editor proc 
th european symposium programming volume lncs pages mar 


chang necula 
framework certified program analysis applications mobile code safety 
technical report ucb erl university california berkeley 


chang necula 
open verifier framework foundational verifiers 
proc 
nd workshop types language design implementation jan 

colby lee necula blau cline 
certifying compiler java 
proc 
conference programming language design implementation pages may 

cousot cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
proc 
th symposium principles programming languages pages jan 

cousot cousot 
interpretation frameworks 
log 
comput 

crary 
foundational typed assembly language 
proc 
th symposium principles programming languages pages jan 

dijkstra 
guarded commands formal derivation programs 
communications acm 


atre 
multi language multi prover verification tool 
research report lri universit paris sud march 


atre march 
multi prover verification programs 
proc 
th international conference formal engineering methods volume lncs pages nov 

gordon syme 
typing multi language intermediate code 
proc 
th symposium principles programming languages pages jan 

gough 
evaluating java virtual machine target languages java 
joint modula languages conference sept 

hamid shao trifonov ni 
syntactic approach foundational proof carrying code 
proc 
th symposium logic computer science pages july 

klein nipkow 
verified lightweight bytecode verification 
concurrency practice experience 

klein nipkow 
verified bytecode verifiers 
theor 
comput 
sci 


toolkits automatic construction data flow analyzers 
technical report cis tr university oregon 

lerner millstein rice chambers 
automated soundness proofs dataflow analyses transformations local rules 
proc 
nd symposium principles programming languages pages 

lindholm yellin 
java virtual machine specification 
java series 
addison wesley reading ma usa jan 

morrisett crary glew grossman samuels smith walker weirich zdancewic 
releases 
url www cs cornell edu releases html 

necula 
proof carrying code 
proc 
th symposium principles programming languages pages jan 

necula majumdar henzinger weimer 
proofs systems code 
proc 
conference computer aided verification nov 

paulson 
isabelle generic theorem prover 
lecture notes computer science 

rose 
lightweight bytecode verification 
autom 
reason 

wadler 
monads functional programming 
advanced functional programming volume lncs pages 
springer 

wu appel stump 
foundational proof checkers small witnesses 
proc 
th international conference principles practice declarative programming pages aug 
