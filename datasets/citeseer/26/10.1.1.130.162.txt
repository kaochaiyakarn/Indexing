black box checking doron peled university texas austin department electrical computer engineering austin tx usa moshe vardi lambda rice university department computer science houston tx usa yannakakis laboratories mount road ridge nj usa october main approaches increasing quality systems model checking checks properties known design system testing usually checks implementation internal structure unknown conforms design 
interested combination techniques 
able test implementation unknown structure satisfies properties 
propose formalize problem black box checking suggest algorithms 
input black box checking initially case classical model computation learned experiments propose computational model games incomplete information 
model analyze complexity problem 
address practical question finding approach detect errors implementation completing exhaustive search 
model checking testing complementary approaches enhancing reliability systems 
model checking usually deals checking design finite state system satisfies properties mutual exclusion responsiveness 
hand testing usually applied actual system having access knowledge internal structure 
checks system implementation conforms design informally behaviors 
access internal structure tested system possible idea performing tests may lead bias testing process 
furthermore system may large millions lines code interested specific aspects 
extracting part code relevant system especially case large legacy systems probably infeasible subject errors 
suppose interested checking specific properties system communication switch protocol 
model checking appropriate checking properties model system checking system 
hand testing methods compare system design 
motivation current case acceptance tests need performed user access design internal structure checked system 
aim combine approaches checking automatically properties finite state systems structure unknown 
course completely hidden structure effectively checked 
properties assumed ffl bound number states checked system known 
ffl tester reset system unique initial state 
ffl input alphabet sigma checked system known 
ffl experiment consists repeatedly applying input sigma reset current state 
indication input possible enabled current state available 
ffl input ff possible current state system move 
stays current state 
backtracking available tester simulate backtracking resetting repeating successful prefix experiment 
ffl checked system deterministic sense state move input successor state 
assume size system known precisely upper bound number states 
particular study effect possibility bound number states may bigger actual number states 
case number states estimated 
practice system checked may large multiple functions property may concern specific aspect system 
system may quite big large parts may irrelevant property system may equivalent smaller finite state machine far checking property concerned 
case taken estimate logical complexity control structure system respect property hand 
methods bound available running algorithms extent available time space resources allow guarantees case depend time spent 
automata theoretic approach model checking negation checked property directly translated finite automaton infinite words usually uchi automaton 
system complement checked property represented automata 
example system principles spin specification automaton called claim recognizes bad disallowed computations 
order check system consideration satisfies checked property intersect automaton representing system automaton representing disallowed computations 
sequence intersection counterexample checked property absence counterexample means property satisfied 
problem study variant model checking problem 
automaton represents computations allowed checked property 
internal structure checked system revealed experiments described allowed 
want check system satisfies property 
call problem black box checking 
simplify discussion deal machines output 
treatment results similar ones 
fly algorithms aimed quickly detecting errors checked system 
choice appropriate computational model central issue black box checking 
standard decision problems input computation learned sequence experiments 
propose computational model games incomplete information model analyze complexity problem 
notions time complexity testing problems testing time complexity time spent testing black box corresponding length experiment performed computational time complexity time spent computing test sequence experiment interpreting result 
methods combine techniques model checking conformance testing learning theory 
areas actively pursued number years extensive body literature 
model checking area research years development theory number software tools 
tools check properties finite state models expressed formal notation 
tool directed checking software systems model verisoft aimed checking state invariants assertions communicating processes partial order reduction methods space exploration 
book model checking see 
study testing black box automata initiated moore classical defined studied problems including machine identification problem infer state transition diagram unknown black box automaton 
posed fault detection conformance testing problem checking black box conforms specified design automaton 
problem studied subsequent years researchers obtaining bounds lengths tests needed efficient algorithms check conformance different types automata machines distinguishing sequence reset general 
years lot conformance testing protocols community large number papers black box automaton testing models methods 
early surveys surveys results related protocol testing 
substantial learning community problem learning finite automata machine identification help teacher 
efficient algorithms learning different types automata framework developed 
preliminaries automata theoretic model checking uchi automaton quintuple sigma ffi finite set states initial states sigma finite alphabet ffi theta sigma theta transition relation accepting states 
run word sigma infinite sequence states si ffi si ffi 
run accepting accepting state occurs infinitely times 
word accepted uchi automaton exactly exists run accepting 
language uchi automaton set words accepts 
automata equivalent accept language 
implementation automaton sb sb sigma restrictions sb singleton sb states accepting 
assume number states bounded value view implementation machine model mealy machine state input machine outputs transition enabled remains state enabled 
furthermore assume implementation automaton deterministic 
specification automaton sp sp sigma ffip denote number states jsp size alphabet sigma common implementation specification mentioned easily extend framework results implementation machines arbitrary output mealy machines specification machines describe legal input output behaviors 
intersection product theta sb theta sp sb theta sp sigma ffi sb theta ffi ff ff ff ffip intersection contains initial states pairs initial respectively states individual automata 
note version intersection simple case uchi automata intersection sb 
transition relation relates pairs transition relations 
accepting states pairs second component accepting state theta 
reset additional symbol sb included sigma allowing move state initial state 
experiment finite sequence ff ff ffk gamma sigma lambda exists sequence states sk sb sb 
ffj reset sj reset move 
sj ffj sj automaton move 
sb sj ffj sj sj disabled move 
games incomplete information computation model experiments black box automata standard input known computation 
part input hidden structure studied experiments 
relevant computational model related games incomplete information player plays deterministic environment representing degenerate version player 
contrasted games adversarial environment example program synthesis 
game consists nondeterministic machine finitely configurations containing disjoint subsets ci initial configurations gamma positive negative winning configurations player respectively 
intuitively want check properties systems corresponds finding error gamma corresponds concluding error 
sets labels player environment respectively 
sets moves theta theta 
theta respectively 
player choice moves relation connecting current configuration possible pairs move labels resulted successor configurations 
moves environment defined function current configuration unique transition label successor configuration 
move originate winning configuration 
different moves configuration different labels 
players moves alternation starting player move initial configuration 
play sequence cl cl lambda adjacent triple conforms move players 
play winning ends winning configuration gamma initial configurations starting play ends configurations play ends configurations gamma incomplete information stated partition configurations equivalence classes called information sets 
player distinguish configurations information set denoted ss 
move function allow moves labels configurations equivalence class 
furthermore ss gamma respectively gamma respectively 
deterministic strategy player function st theta 

player keep playing st turn configuration environment played move labeled sequence configuration gamma 
ss labels st st 
additional value init paired initial configurations ci previous label configuration 
path played strategy alternating sequence games described involve choosing automaton performing experiments choose distinguish configuration game state automaton 
fi fi fi fi combination lock automaton configurations labels starting initial configuration 
winning path ends winning configuration 
define deterministic time complexity length longest winning path deterministic strategy ends configuration gamma define nondeterministic strategy nst theta 
player 
ci arbitrary configuration exists play ends configuration 
play starting player keeps playing turn nst strategy configuration 
second constraint imposed deterministic strategy counterpart definition nondeterministic strategy 
intuition nondeterministic case player playing nondeterministic strategy guesses distinguish configurations information set 
define nondeterministic time complexity length longest winning path nondeterministic strategy ends configuration 
combination lock automata family automata plays major role proving lower bounds experiments black box automata combination lock automaton finite automaton exists complete order states sn initial state state sn enabled transition 
state si transition labeled fii sigma si 
letters fl sigma transition labeled fl si back initial state 
automaton said combination automaton fi fi fin gamma 
depicts combination lock automaton 
sequence leading state successor state letters enabled combination lock automaton suffix length gamma fi fi fin gamma 
necessary sufficient condition example automaton reach deadlock state result sequence fi fi fi fi fi fi fi fi second fi causes return initial state 
path contain consecutive sequence fi fi fin gamma allowed enabled automaton 
black box deadlock detection section describe simpler problem related black box checking section 
deterministic finite state system states want check machine deadlocks reaches state input possible 
problem part model unknown learned experiments motivates modeling problem game incomplete information 
demonstrate deterministic nondeterministic complexity connections standard model computation turing machines 
implementation automaton states exists single initial configuration 
configuration play contains automaton initial configuration current state automaton controlled moves player information sequence moves played far 
current state automaton initial configuration initial state 
moves environment labeled success fail 
label indicates environment successful executing transition corresponding label move player state implementation automaton 
moves player possible input symbols reset followed symbol 
projecting labels moves player play obtain experiment implementation automaton initial configuration 
configurations reachable prefixes plays correspond experiment ss 
winning set contains configurations include automaton deadlock 
similarly winning set gamma contains configurations include automaton deadlock 
nondeterministic strategy player guesses move label forming sequence length smaller brings state selected machine initial state deadlock state 
checks state enabled transitions trying input labels success 
complexity nondeterministic time 
information needed kept configuration counter gamma counter number labels checked final state 
deterministic strategy player checks systematically possible sequences length gamma starting initial state 
course need check sequences include prefixes led failure 
complexity deterministic testing computational time pn 
theorem deterministic testing time complexity black box deadlock detection omega pn gamma 
proof 
suppose initial configuration includes implementation automaton states allows input state 
consider play played deterministic strategy player 
assume pn gamma moves player terminates winning configuration cw gamma sequence fi fi fin gamma appear consecutively experiment associated 
automaton environment chosen combination lock automaton fi fi fin gamma deterministic strategy resulted prefix play labels 
reached configuration cw ss 
cw associated automaton deadlocks associated automaton deadlocks 
contradicts assumption cw gamma standard complexity model known obtain polynomial deterministic algorithm nondeterministic polynomial algorithm 
tight lower deterministic bound exponentially larger nondeterministic complexity 
justifies games incomplete information alternative common computational model turing machines 
checking properties black box finite state machines address problem black box checking 
specification uchi automaton states black box implementation automaton states mutual alphabet sigma letters check sequence accepted recall automaton accepts bad computations allowed 
property originally linear temporal logic ltl property automaton corresponding 
efficient translation ltl automata see 
simple theorem demonstrates current problem exponential time size automaton theorem deterministic testing time complexity black box checking omega pn gamma 
proof 
similar proof theorem construct variants combination lock automata 
deadlock state replaced self loop labeled fl 
symbol fl disabled initial state 
removes half possible combinations case complexity changes constant factor 
property automaton consists states initial state accepting state 
self loop label sigma fl 
edge labeled fl 
intersection nonempty exactly state reached black box automaton fl 
executed 
state combination lock black box state path prescribed combination 
line strategy straightforward way perform black box checking infer structure black box system apply model checking techniques newly revealed structure 
machine identification problem studied problem 
typically applied automata produce output states moore machines transitions mealy machines 
mentioned implementation machine model viewed mealy machine output transition means enabled output means enabled known machines states equivalent input length gamma distinguishes 
implies machine states completely characterized output input strings length gamma 
black box uniquely determined applying gamma input strings 
ary tree depth gamma constructed responses black box minimized produce minimal machine consistent outputs 
model checking check satisfies property length test sequence terms games incomplete information length corresponding play gives testing time complexity np gamma 
implemented straightforward way space complexity exponential record tree input strings output 
construction minimization done incrementally polynomial space 
computational time model checking comparatively small size property automaton typically small 
complexity method far lower bound worst case may need identify effect black box machine order check property 
intuitively clear cases method wasteful take advantage property avoid doing complete identification 
example suppose property error indication label fl occurs 
property automaton representing bad computations case simple state automaton 
obviously example reason wait reconstruct full black box automaton check property 
sensible thing check assertion try see fl enabled current state go test gets violated point error check complete 
general obviously beneficial property automaton fly detect errors early possible prune test 
notably estimate number states higher actual number different states accurate small counterexample small set states exhibits faulty behavior able find error searching space possible 
easy especially case properties depend infinite behavior system cases property automaton genuine uchi automaton 
investigate methods sections 
convention output provides partial information state output know state change 
important follows methods apply mealy machine obvious optimizations tests 
example apply input enabled pointless try enabled transition performed 
fly strategy strategy guided checked property terminate exploring entire structure black box automaton 
nondeterministic strategy start nondeterministic version order demonstrate principle fly black box checking 
strategy player guesses path oe automaton starting initial state partitioned subpaths oe oe length smaller equal mn 
subpaths accepting state furthermore blackbox automaton tested allow executing transitions oe oen reset 
path oe input automaton needs terminate accepting state second path oe starting state needs terminate 
pair apply second path times 
try execute path oe oe 
succeed means cycle intersection state accepting component ways pair state case infinite accepting path intersection 
correctness consider unknown state intersection automaton iteration oe experiment oe oen component state occur twice accepting component state states intersection component 
path oe include cycle accepting state guarantees infinite accepting run exists intersection 
conversely easy see intersection nonempty guess exists 
complexity nondeterministic time 
deterministic strategy nondeterministic case strategy finds path consisting components oe oen joe joe smaller equal done running different possible paths systematic way 
complexity deterministic time mn 
mn choices paths 
length bounded mn repeat times 
comments noted ffl complexity strategy grows exponentially number states typically small fixed talking fixed property 
ffl properties specified automata finite strings depend essentially finite computations safety properties need search string oe complexity 
ffl searching strings oe oe need consider strings extended accepting strings property automaton 
furthermore start limiting length subpaths explore gradually increase length proceed search 
way actual size automaton smaller error occurs earlier exhaustive strategy required 
strategy learning testing show factor exponent removed 
provide strategy complexity exponential term pn 
furthermore black box error time complexity exponential actual size minimized version black box automaton 
conformance testing procedure strategy procedure algorithm conformance testing finite automaton black box automaton chow 
testing computational time complexity algorithm pn gamma assumed bound size black box automaton size automaton alphabet size 
intuitively algorithm check states transition relation black box automaton error follows combination lock occurs nodes 
give brief description chow algorithm 
assume loss generality automaton minimized states 
construct spanning tree automaton rooted initial state characterizing set input strings pairwise distinguish states set strings property distinct states string produces different output starting states recall outputs correspond disabled enabled transitions 
set strings length constructed efficiently classical automata minimization algorithms 
chow algorithm applies black box automaton strings form reset ff ranges input strings corresponding paths starting root fi ranges input strings length gamma fl ranges strings produces outputs test strings states equivalent choices string ff pn gamma choices fi choices fl 
length test string total length test pn gamma 
general different test strings applied arbitrary order far correctness concerned 
efficiency purposes advantageous apply increasing order substrings fi empty string fi combined ff fl strings fi length input symbols length manner actual size black box conform discrepancy discovered fi length gamma test length pl gamma 
discrepancy length fi equal string fffl test complexity 
automata learning algorithm procedure strategy algorithm learning automaton reset membership tests questions oracle teacher angluin 
learning algorithm teacher answers equivalence tests proposed machine provides counterexample case 
replace teacher experiments black box automaton 
starting trivial automaton angluin algorithm generates successively larger candidate automata mi number states conjectured automaton monotonically increasing 
asks teacher equivalence 
equivalence hold uses counterexample provided teacher queries strings generates conjectured automaton states reaches correct number states 
point conjectured automaton correct 
basic data structure angluin algorithm consists finite sets finite strings automaton alphabet sigma table set prefix closed contains particular empty string 
rows table strings sigma columns strings sequence transitions vw enabled starting initial state 
entry computed performing experiment vw automaton define equivalence relation mod strings sigma lambda follows mod sequence transitions enabled sequence enabled strings corresponding rows table equivalent mod rows 
easy check equivalence relation 
denote equivalence class includes table closed va sigma va mod 
table consistent mod sigma mod 
notice table consistent sigma mod aw aw vice versa 
means add aw order separate 
closed consistent table sets construct proposed automaton mf fs sigma ffi follows ffl set states jv 
ffl initial state empty string 
ffl transition relation ffi defined follows sigma transition input enabled iff case ffi va 
ffl definition entries table 
alternatively defined output sequence produced application string starting state reached bit string indicating transition enabled corresponding state 
may result smaller set entries table longer 
facts table closed consistent guarantee transition relation defined 
particular transition relation independent state equivalence class choose equivalent states sigma va coincides consistency equal closure 
basic steps learning algorithms extending table add rows add update table adding row va sigma setting va result experiment 
add column add update table adding column set sigma experiment vw 
define subroutine angluin accepts data consisting sets strings table corresponding previous guess automaton counter example oe current guess agree 
loss generality assume disagreement occurs symbol oe truncate oe 
algorithm updates sets table new consistent closed table returns corresponding automaton denoted automaton 
subroutine adds table rows corresponding prefixes counter example oe plus prefixes extended single letter sigma subroutine adds rows columns table closed consistent 
subroutine appears 
black box checking algorithm purpose black box checking modify angluin algorithm follows 
modification kinds counterexamples provided teacher 
simple counterexample form oe sigma lambda meaning oe belongs checked automata 

pair words oe oe sigma lambda oe oen belongs checked automata 
case truncate counterexample string disagreement automata black box conjectured automaton 
construct sequence automata attempt converge black box automaton membership queries just experiments black box equivalence queries suppose conjectured automaton mi black box 
check mi generates word accepted specification automaton mi 
intersection empty contain ultimately periodic word form oe oe 
input reset oe oen black box experiment succeeds error contains oe oe empty 
fails gives counterexample equivalence mi 
subroutine oe empty add rows prefix oe add rows inconsistent closed inconsistent find sigma mod add column aw lambda closed lambda find sigma va add rows va return automaton angluin angluin algorithm special case safety properties properties depend finite computations bit simpler 
case automaton finite words find witness finite string oe mi input reset oe black box check allows signifies error allow provides counterexample equivalence mi 
experiment fails resulted counterexample oe oe oen truncated discrepancy angluin algorithm generate candidate automaton states 
mi generate word accepted check mi conforms number states mi 
start conformance test mi assuming states apply chow vc algorithm 
conformance test fails counterexample angluin learning algorithm generate mi 
conformance test succeeds repeat note earlier description vc algorithm start round algorithm scratch simply extend testing strings form increasing lengths middle substring fi 
bound reached discrepancy declare black box satisfies checked property 
strategy described 
procedure test takes black box automaton state bound property terms automaton specifies erroneous computations 
determines satisfies property provided states 
procedure call activates chow algorithm conformance testing current conjectured automaton black box automaton assuming states 
returns true conformance test succeeds 
fails returns proc test black box prop 
automaton state bound empty table angluin empty gamma states theta number states repeat conforms oe conforms conforms win oe oe strings oe oe allows reset oe oen win oe maximum prefix oe oen allowed angluin oe return black box states test strategy learning testing fail oe oe finite word automata 
procedure angluin accepts current table counterexample updates table returns new attempted automaton states 
call angluin strategy executed empty table second parameter counterexample ignored 
simplicity show case property automata infinite strings 
property automata finite strings take oe counterexample 
possible outcomes procedure test win indicates satisfy property counterexample returned desired win indicates states satisfies property case equivalent fact automaton constructed algorithm results test imply definitely states occurs outer loop completes normally statement procedure reached 
implementation algorithm illustrated 
mention 
simplicity kept calls vc angluin algorithm separate 
subroutines compute lot common information practice combine data structures eliminate redundancies 
recall vc algorithm uses paths spanning tree access states automaton characterizing set strings distinguish states 
angluin algorithm set strings access states set strings corresponding columns table distinguish states 
call vc procedure test choice set strings access states string equivalence class constructing tree current set strings constructed calls angluin procedure corresponding columns table 
advantage doing construction conjectured automaton know succeed equal number states relevant experiments run construction current table skip call continue 
possible disadvantage strings may longer necessary 
opposite choice replace table spanning tree initial state example shortest path spanning tree new characterizing set objective making short strings find 
furthermore call vc simply extend tree previous call reach new states extend characterizing set similarly 
conformance test succeeds number states fails higher bound option angluin call ignore old data structure paths new set characterizing set column set entries table known test executed vc call 
may lead shorter subsequent test sequences angluin procedure 
variant algorithm suppose iteration model checking determines conjectured automaton satisfy property produces example string accepted black box string oe long feeding angluin procedure may try find shorter counterexample equivalence conjectured automaton calling vc procedure bound number states vc procedure succeeds finding counterexample counterexample finds ff string corresponding path spanning tree fi string length fl shown strings form fffi fi prefix fi lead states inequivalent states previously states reached paths tree calling angluin algorithm counterexample fffi result states 
complexity strategy discuss testing complexity length test 
computational complexity similar 
suppose minimum equivalent automaton black box states 
suppose black box error 
error discovered time conjectured automaton reaches size iteration conjectured automaton states possibly minimum automaton equivalent possibly inequivalent fewer states model checking algorithm produce string intersection allowed clearly vc procedure called state bound greater calls vc performed incrementally explained earlier extending tree characterizing set reusing previously performed test sequences total time spent vc calls pl 
analyze cost angluin calls 
simplicity purposes worst case complexity assume vc angluin algorithms common set access distinguishing strings 
employ variant mentioned allow string produced model checking call angluin directly counterexample string oe run vc algorithm find short counterexample 
practice counterexample model checking long worst case length 
mentioned vc algorithm finds counterexample string form fffi ff path tree fi length strings fffi prefixes fi fi lead new inequivalent states extend spanning tree state reached path ff hanging path new states labeled fi 
call angluin procedure counterexample string fffi include string fffi prefixes note ff prefixes ff path access tree 
strings fffi give new inequivalent states 
true strings added angluin consequence table closed 
note strings form va sigma extend tree add va remarks follows set times elements length angluin calls perform tests length total cost 
clearly dominated bound vc calls 
vc angluin calls remaining tests black box apply strings model checking determine execute 
property characterized automaton finite strings states counterexamples provided model checking algorithm length ml 
strings total length 
typically size property automaton small constant 
dominated pl 
general case large purpose bounding worst case complexity trick amortize test model checking test execute string oe provided model checking apply prefixes oe doubling length time interleaved tests vc algorithm approximately equal time 
time tests dominated vc calls test conjectured automaton may correct automaton 
cost test lm 
properties depend finite executions total complexity test case faulty black box pl lm 
note depend priori bound property characterized automaton infinite strings model checking give strings oe oe length lm 
allow oe oe failure occur repetitions oe black box inequivalent states oe repetition oe 
tests length execute completely showing faulty length lmn 
regarding tests cost dominated vc calls typically small constant apply trick described 
consequently case total testing complexity algorithm pl lmn 
case complexity depends bound linearly 
black box satisfies property strategy generate minimum equivalent automaton time pl spend pn gamma time verify black box equivalent conformance checking 
noted bound estimate actual size precisely complexity dominated check confirms conformance conjectured automaton 
theorem black box checking black box automaton states unknown smaller bound property automaton states done testing time ffl pl lmn error intersection nonempty time pl lm automaton finite strings ffl pl pn gamma error 
bound number states automaton run algorithm long time permits 
consider property characterized automaton finite strings deadlock freedom safety properties 
encounter error find string oe accepted black box property automaton true error test 
error size smallest counterexample length sure find error time pl lm 
conversely allocated time error means black box correct smallest possible counterexample size black box exceed certain bound depends time spent test 
suppose uchi automaton depends infinite behaviors 
suppose point conjectured black box automaton mi nonempty intersection property automaton oe oe string intersection 
conjectured automaton states point states strings oe oe length lm 
input black box followed repeated applications oe black box accept run time 
described interleave application successively longer prefixes oe oe running vc algorithm approximately equal amounts time find counterexample run time 
case new state continue algorithm 
second case run time executing repetitions oe conclude error size implementation machine exceeds conjectured automaton empty intersection property automaton perform conformance testing increasingly larger values bound black box 
place lower bound size black box conclude correct 
comment exponential lower bound derived combination lock automata 
obviously pathological worst case examples 
average automata better behaved exhibit nasty performance bottleneck 
formalized considering probabilistic model machines output 
formally extensive studying properties random machines 
usual model random mealy machine states defined follows 
state input symbol choose state output uniformly random 
average machine polynomial time suffice find error 
statement machines means probability tends size goes infinity 
theorem black box mealy machines states error test length lp log lmn respectively length lp log lm properties described automata finite strings 
shown nice properties random machines state reach state reach logp steps states distinguished input strings length logp logq 
course error want sure automaton hand states need conformance testing cost exponential difference gamma order certain correctness 
defined problem black box checking showed lower bounds provided strategies solving problem 
lower bound theorem implies worst case complexity black box checking exponential estimated size unknown automaton 
comparison checking emptiness intersection automata structures nlogspace complete 
conformance testing checks known automaton length equivalent black box automaton length bounded chow showed lower upper bound pn gamma conformance testing reliable resets 
actual size black box automaton known tractable complexity black box checking 
model design available feasible construct strategy developer system separately conformance test design system model check design respect various properties 
model available considerably bigger worst case avoid exponential complexity 
quite clear line strategy suboptimal take advantage property hand 
hand fly strategies exponential may practice important cases 
case error exists estimate higher actual size checked system size portion system provides counterexample 
case specification automaton limits possible bad executions considerably 
example helpful specification specifies sequences form ff lambda fi fl 
example unhelpful specification lambda ff allows letter sigma ff 
strategy conformance testing learning uses property trying learn structure error may completing construction minimized automaton equivalent possible explicit bound size black box automaton 
case strategy long willing spend time 
pointed exponential lower bound occurs certain pathological examples combination lock automaton fact machines probabilistic sense error strategy find surely polynomial time 
number issues black box checking deserve investigation 
open problems finding strategies partially specified automata known automata actual implementation deviates known design changes implementation errors 
problem develop algorithm black box checking reliable reset moves available 
possible similar techniques combining learning algorithm conformance testing algorithm machines reset capability 
run experiments black box checking 
implementation programmed alex cmu 
verify communication protocols states 
currently experimenting additional heuristics increasing number states handle 
alur courcoubetis yannakakis distinguishing tests nondeterministic probabilistic machines symposium theory computer science acm 
angluin learning regular sets queries counterexamples information computation 
uchi decision method restricted second order arithmetic proceedings international congress logic methodology philosophy science palo alto ca usa 
chow testing software design modeled finite state machines ieee transactions software engineering se 
clarke grumberg peled model checking mit press 
gerth peled vardi wolper simple fly automatic verification linear temporal logic protocol specification testing verification chapman hall warsaw poland 
godefroid model checking programming languages verisoft proc 
th acm symp 
progr 
lang 
sys 
holzmann model checker spin ieee transactions software engineering 
fault detecting experiments sequential circuits proc 
th ann 
symp 
switching circuit theory logical design 
holzmann peled state spin th international conference computer aided verification springer verlag lncs new brunswick nj usa 
kohavi switching finite automata theory mcgraw hill 
kurshan computer aided verification coordinating processes approach princeton university press 
lee yannakakis principles methods testing finite state machines survey proceedings ieee 
maler pnueli learnability infinitary regular sets information computation 
moore experiments sequential machines automata studies princeton university press 
myers art software testing wiley international 
pnueli temporal logic programs th ieee symposium foundation computer science 
reif complexity player games incomplete information journal computer system sciences 
pnueli rosner synthesis reactive module proc 
th acm symposium principles programming languages austin tx rivest schapire inference finite automata homing sequences information computation 
leung formal methods protocol testing detailed study ieee trans 
sw eng 
thomas automata infinite objects handbook theoretical computer science mit press van leeuwen ed 
trakhtenbrot barzdin finite automata behavior synthesis north holland 
vardi wolper automata theoretic approach automatic program verification proceedings symposium logic computer science cambridge uk 
failure diagnosis automata 
yannakakis lee testing finite state machines fault detection computer syst 
sci 

