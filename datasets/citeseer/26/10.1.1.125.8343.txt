unifying tables objects documents erik meijer wolfram schulte gavin bierman microsoft usa 
microsoft com microsoft research usa 
schulte microsoft com microsoft research uk 
gmb microsoft com 
proposes number type system language extensions natively support relational hierarchical data statically typed object oriented setting 
approach sql tables xml documents class citizens benefit full range features available modern programming language java 
allows objects tables documents constructed loaded passed transformed updated queried unified typesafe manner 
important current open problem programming language research increase programmer productivity easier faster write correct programs 
integration data access mainstream programming languages particular importance millions programmers struggle day 
data sources sinks typically xml documents sql tables currently poorly supported common objectoriented languages 
addresses integrate tables documents modern objectoriented languages providing novel type system corresponding language extensions 
need unification distributed web applications typically structured tier model consists middle tier contains business logic extracts relational data data services tier processes hierarchical data displayed user interface tier alternatively scenario hierarchical data simply transferred application 
middle tier typically programmed object oriented language java consequence middle tier programs deal relational data sql tables object graphs hierarchical data html xml 
unfortunately different worlds integrated 
ado net example shows access database usually involves sending string representation sql query explicit connection stateful api iterating weakly typed representation result set conn new cmd new select name hp conn conn open rdr cmd html xml documents created emitting document fragments string form separating model presentation rdr read response write tr td response write rdr response write td td response write rdr response write td tr communication different tiers untyped strings obviously fragile lots opportunities silly errors possibility static checking 
fact representing queries strings security risk called script code injection problem 
due poor integration performance suffers badly 
previous attempts easy task gracefully unify worlds objects documents tables come surprise main stream programming language emerged realizes vision 
language integration deals sql xml 
alternatively start completely new language xquery xduce luxury afford 
approaches language binding kind pre compiler xsd exe castor achieve real semantic integration 
impedance mismatch different type systems leads strange anomalies unnatural mappings 
popular route integrate xml sql means domain specific embedded languages typically functional language scheme haskell host :10.1.1.37.5006:10.1.1.17.2599:10.1.1.11.4048:10.1.1.46.8937
experience embedded domain specific language approach scale particularly difficult encode domain specific type systems syntax host language :10.1.1.37.4929
xen solution examples demonstrate foundational level impedance mismatch xml sql object data models 
opinion impedance mismatch big attempt complete integration 
impedance mismatch object xml data models treated detail companion 
problems approach take starting point type system object data model middle tier programming language 
computational model programmers familiar supported underlying execution engine 
look xml fidelity terms able serialize deserialize possible documents expressible xml schema language closely match xml data models programming language parsed xml document 
words consider xml simply syntax serialized object instances enriched host language 
sql fidelity take approach require sql tables passed back forth having need introduce additional layers ado net 
trying blindly integrate xml sql data models enrich type system object oriented host language case small number new type constructors streams tuples unions 
carefully designed integrate coherently existing type system 
top type system extensions add new forms expressions base language generalized member access provides path expressions traverse hierarchical data comprehension queries join elements different collections 
limiting comprehension queries tabular data path expressions hierarchical data allow forms expressions collection matter data memory remotely stored database 
seamlessly handle queries remote data sources local data sources similar deferred execution implementation techniques :10.1.1.17.2599
depending data source result query materialized collection sql program sent database 
result xen superset seamlessly blends worlds objects tables documents 
code fragment shows xen able express functionality seen previously 
tr select tr td name td td hp td tr table table tr th name th th hp th tr table response write xen strongly typed xml values class citizens xml literal table table type static table sql style select queries built 
xen allows static checking sql xml type systems integrated language compiler better job generating efficient code run client sent server 
xen design support entirety xml stack advanced features sql believe type system language extensions rich support potential scenarios 
example able program complete set xquery cases xsl stylesheets serialize classic xml hamlet document running significant fidelity problems 
sections show grown modern object oriented language take host language approach java visual basic encompass worlds tables documents adding new types expressions 
xen type system section shall cover extensions type system streams tuples discriminated unions content classes briefly consider new query capabilities 
contrast nominal types classes structs interfaces new xen types structural types arrays java introduce type system extensions example 
formal details xen type system companion 
streams streams represent ordered homogeneous collections zero values 
xen streams commonly generated yield return blocks 
stream generators ordinary methods may yield multiple values returning single time 
method generates finite stream integers static int int int yield return view host language streams typed refinements iterators 
iterators encapsulate logic enumerating elements collections 
stream iterate elements existing foreach statement 
instance loop prints integers foreach int console streams generators new concepts 
supported wide range languages various forms 
approach little different classify streams hierarchy streams different length 
automatically flatten nested streams 
identify value null empty stream 
keep type checking tractable restrict stream types denotes possibly empty unbounded streams denotes streams element denotes streams exactly element 
represent optional values non existence represented value null analogously represent non null values 
different stream types form natural subtype hierarchy subtyping corresponds stream inclusion write denote type subtype type write denote equivalent xen observes axioms 
instance reflects fact stream element stream zero elements 
non stream types subtype hierarchy placing non null values possibly null values 
allows example assign value type int 
arrays streams covariant 
unbounded streams elements identity conversion 
restriction guarantees streams constant time object identity stream maintained 
suppose button subclass control rule says button subtype stream controls control 
conversion identity explicitly copy stream 
example convert stream xs type int stream type object expression xs return object 
optional non null types covariant respect arbitrary conversions element types 
xen streams flattened nested streams streams 
theoretical level implies number type equivalences example 
reflects fact stream zero elements flattens single stream zero elements 
flattening stream types essential efficiently deal recursively defined streams 
consider recursive variation function defined previously int int int yield break yield return yield return recursive call yield return yields stream forcing type nested stream 
non recursive call yield return yields single integer forcing return type normal stream 
type system treats types int int equivalent type correct 
flattening forced copy stream produced recursive invocation leading quadratic linear number yields int int int yield break yield return foreach int yield return flattening stream types imply underlying stream flattened coercion element stream yield ed 
iterating stream effectively perform depth traversal ary tree produced stream generators 
non 
type denotes streams exactly element identify null empty stream implies values type null 
able express value null type system allows static checking null pointers see examples :10.1.1.19.162
turns potentially unhandled dynamic errors compile time errors 
methods net base class library throws argument null function parse 
consequently implementation parse needs explicit null check public static parse string null throw new 
dually clients parse prepared catch 
apparent type parse method java signature parse show possibly throws exception 
cleaner type parse indicated expects string argument non null public static parse string 
type checker statically rejects attempt pass string null parse 
anonymous structs tuples anonymous structs call encapsulate heterogeneous ordered collections values fixed length 
members anonymous structs optionally labelled labels duplicated different types 
members anonymous structs accessed label position 
anonymous structs value types object identity 
function returns quotient remainder arguments tuple contains named integer fields struct int div mod struct int div mod int int return new div mod members anonymous struct may unlabelled example create tuple consisting labelled button unlabelled follows struct button enter new enter new button new unlabelled member nominal type shorthand member implicitly labelled type 
mentioned earlier members tuples accessed position label 
example int new button enter streams tuples covariant provided conversion applied identity 
subtyping lifted field declarations expected 
means assign new enter new button new variable type struct control enter 
streams anonymous structs tables relational data stored tables sets rows 
sets represented streams rows anonymous structs streams anonymous structs model relational data 
table contains basic facts characters name strength kind evolved see www com details interesting creatures 
name hp kind evolved normal fire fire plant water plant fire table modelled variable enum kind water fire plant normal rock struct string name int hp kind kind string 
evolved fact basic evolutions shows evolved column type string 
discriminated union value discriminated union holds different times values members 
anonymous structs members discriminated unions labelled unlabelled 
discriminated unions appear content classes see 
type address uses discriminated union allow member street type string member type int class address struct choice string street int string city string 
state int zip string country second situation discriminated unions result types generalized member access see 
example type wildcard expression selects members returns stream containing members type choice string int kind string subtype rules choice streams equivalent choice string int kind 
unions variant records pascal users keep track type values discriminated unions xen implicitly tagged static type chosen alternative unions algol 
words discriminated unions xen essentially pair value static type 
type component tested conformity test expression true exactly union 
invariant maintained type system 
get value component discriminated union value 
labelled members discriminated unions just nested singleton anonymous structs example choice int fahrenheit int celsius shorthand verbose choice struct int fahrenheit struct int celsius 
discriminated unions idempotent duplicates removed associative commutative nesting order ignored 
values non discriminated unions injected discriminated union 
rule allows conveniently inject values discriminated union example choice int fahrenheit int celsius new fahrenheit streams distribute nested discriminated unions essential recursively defined streams example returns stream integers terminated true choice int bool int yield return true yield return yield return content classes introduced streams anonymous structs discriminated unions type system rich model large part xsd schema language aim cover essence xsd possible whilst avoiding complexity 
correspondence xsd particles sequence choice local element declarations type constructors struct choice labelled fields intuitively clear 
likewise relationship xsd particles occurrence constraints streams 
attribute pair minoccurs maxoccurs unbounded 
content class address defined corresponds xsd schema address element name address complextype sequence choice element name street type string element name type integer choice element name city type string element name state type string minoccurs element name zip type integer element name country type string sequence complextype element xen content class simply normal class single unlabelled member zero methods 
consequence content accessed individually named children allows compiler choose efficient data layout 
example schema defines top level elements author book book elements zero author members element name author complextype sequence element name name type string sequence complextype element element name book complextype sequence element name title type string element ref author minoccurs maxoccurs unbounded sequence complextype element case local element modelled unlabelled field elements mapped type declarations class author string name class book struct string title author groups schema complex type name element name name complextype element name type string element name type string complextype element mapped ordinary fields containing type class name string string examples show top level element declarations named complex type declarations mapped top level types 
allows unify derivation complex types substitution groups elements standard inheritance 
details relationship xml xen companion 
xen expressions previous sections concentrated xen type system 
section consider new xen expression forms construct transform query combine xen values 
xml constructors xen xml serialized objects language conveniently allowing programmers xml fragments object literals 
instance create new instance address object xml object literal address address street microsoft way street city redmond city address xen compiler contains validating xml parser analyzes xml literal compile time code construct correct address instance 
allows xen programmers treat xml fragments class values code 
xml literals placeholders describe dynamic content 
xquery convention arbitrary expression statement block embedded inside element escaping curly braces author string name return author name toupper author embedded expressions return yield values required type case string 
validation xml literals placeholders non trivial subject forthcoming 
note xml literals treated xen just object constructors special content classes 
fact write xml literals construct values type example assignment button button text click text button creates instance standard button class sets text field string click 
stream generators iterators lifting creation streams concise possible allow anonymous method bodies expressions 
example assign conceptually infinite stream positive integers variable nats int nats int true yield return stream constructors functors implicitly lift operations element type stream member property access method calls stream 
instance convert individual string stream ss strings uppercase simply write ss toupper 
restrict lifting member access 
xen generalizes apply block 
write previous example ss return toupper 
implicit argument refers successively element stream ss 
fact apply block yield stream case resulting nested stream flattened appropriate way 
example nats stream integers int rs nats yield return apply block returns void new stream constructed block eagerly applied elements stream 
example print elements stream just write nats console apply blocks stateful reductions functional community called folds 
example sum integers integer stream xs follows int sum int xs int xs return need careful lifting non null types fact receiver object null imply members null button 
button control parent parent null return type lifting non null type guaranteed return non null type 
optional types provide standard implementation null design pattern receiver type null accessing members returns null string 
null int 
length null objective standard behaviour object null 
member access lifted streams structural types 
example expression xs return stream true type choice bool int xs defined struct bool struct int xs new true yield return new yield return new lifting discriminated unions introduces possibility members alternatives 
suppose type choice int string 
string length member type length int 
reflects fact case dynamic type int result length null 
int string member gettype return type gettype type choice int string int 
length null type gettype system int case alternatives union member different type common result type union types respective members 
binary unary operators lifted element wise streams 
example add optional integers get optional integer 
null result adding null 
lifting optional types implements sql value logic 
want filter stream predicate elements stream 
example construct stream odd numbers filter numbers stream nats natural numbers filter expression nats 
element stream filtered predicate evaluated element bound 
predicate true element part new stream 
int odds nats fact filters encoded apply block int odds nats yield return generalized member access seen xen elegantly generalizes familiar member access resulting compact clear code 
provide flexible forms member access xen provides wildcard transitive type access 
forms similar concepts abbreviated relative location paths name filters xpath adapted uniformly object graphs 
wildcards provide access members type needing specify labels 
example suppose want fields address choice string int microsoft wildcard expression returns content accessible fields properties variable microsoft declaration order 
case microsoft way redmond usa 
transitive member access written returns accessible members transitively reachable depth order 
declaration authors lazily returns stream containing authors books source stream books book book title faust title author author book book book title de title author jac 
author book book books yield yield string authors books author transitive member access abstracts concrete representation tree long mentioned member reachable accessible value returned 
looking just field name sufficient especially transitive queries reachable members name different type 
case allow additional type test restrict matching members 
type test selects members static type subtype instance interested microsoft number zip code write transitive query microsoft int 
comprehensions previous sections solutions querying documents 
accessing relational data model streams anonymous structs simple sql queries natural flexible 
consider integration sql select clause defer discussion advanced features data manipulation transactions 
fundamental operations relational algebra selection projection union difference join 
simple sql style comprehension queries ps select kind normal struct string name kind kind ps select name kind practice result types sql queries quite involved painful programmers explicitly specify types 
compiler knows types sub expressions result types queries inferred automatically 
providing type declarations method local variables necessary simply write ps select name kind having declare type ps 
union difference difficulty framework 
easily handled existing operations streams 
union concatenates streams single stream 
difference takes streams returns new stream contains values appear second stream 
real power comprehensions comes join 
join takes input streams creates third stream values composed combining members input streams 
example expression selects pairs evolved select name name evolved emphasize elegant integration data xen 
select expression works arbitrary streams memory hard disk streams simply virtualize data access 
strong typing data access secure 
excessive syntactic burden programmer result types queries inferred 
language extensions proposed support sql xml schema type system large degree dealt sql features unique keys esoteric xsd features redefine 
similarly capture expressive power xpath xquery xslt support full set xpath axis 
able deal smoothly namespaces attributes blocking facets 
currently investigating additional features need added language 
summary shown possible sql tables xml documents class citizens object oriented language 
bridge type worlds needed 
building bridge mainly engineering task 
available offers best worlds 
acknowledgments acknowledge support encouragement feedback mike barnett nick benton don box luca cardelli bill gates steve lucco chris lucas todd dave reed clemens hard languages team consisting william adams joyce chen david hicks steve chris frank wolfgang herman matt warren 
written whilst bierman university cambridge computer laboratory supported eu ii 

chamberlin fernandez kay robie simeon 
xml path language 
www org tr xpath 

bierman 
formal type system odmg oql 
technical report university cambridge computer laboratory 

chamberlin fernandez florescu robie sim 
xquery xml query language 
www org tr xquery 

christensen muller schwartzbach 
static analysis dynamic xml 
proceedings 

clark 
xsl transformations 
www org tr xslt 

connor 
projector partially typed language querying xml 
proceedings 

fahndrich leino 
declaring checking non null types objectoriented language 
proceedings oopsla 

flanagan leino lillibridge saxe stata 
extended static checking java 
proceedings pldi 

pierce 
regular object types 
proceedings ecoop 

graunke krishnamurthi felleisen 
programming web high level programming languages 
proceedings ase 

griswold griswold 
icon programming language 
prentice hall 

hosoya pierce 
xduce typed xml processing language preliminary report 
proceedings webdb number lncs pages 

hudak 
building domain specific embedded languages 
acm computing surveys 


xml objects 
proceedings 

krishnamurthi 
manipulation language xml 
proceedings padl 


programming objective sams 

krall vitek 
extending java 
proceedings 

lahiri abiteboul widom 
ozone integrating structured semistructured data 
proceedings dbpl 

leijen meijer 
domain specific embedded compilers 
proceedings usenix conference domain specific languages 

liskov atkinson bloom moss schaffert snyder 
clu manual 
springer verlag 

liskov day herlihy johnson leavens 
argus manual 
technical report mit 

meijer 
server side web scripting haskell 
journal functional programming 

meijer leijen hook 
client side web scripting 
proceedings padl 

meijer schulte bierman 
essence xen 
submitted publication 

meijer schulte bierman 
programming circles triangles rectangles 
proceedings xml 

meijer shields 
xm functional language constructing manipulating xml documents 
unpublished 

meijer van 
haskell server pages 
proceedings haskell workshop 

omohundro stoutamire szyperski 
iteration abstraction sather 
acm toplas 

proebsting 
disruptive programming language technologies 
unpublished note 

shields meijer 
type indexed rows 
proceedings popl 

simeon wadler 
essence xml 
proceedings popl 

thiemann 
wash cgi server side web scripting sessions typed compositional forms 
proceedings padl 

welsh glover 
schemeunit schemeql little languages 
proceedings workshop scheme functional programming 
