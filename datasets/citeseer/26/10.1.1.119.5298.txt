reconsidering custom memory allocation emery berger dept computer science university massachusetts amherst ma emery cs umass edu programmers hoping achieve performance improvements custom memory allocators 
depth study examines applications custom allocators 
surprisingly applications state art general purpose allocator lea allocator performs better custom allocators 
exceptions regions deliver higher performance improvements 
regions reduce programmer burden eliminate source memory leaks 
show inability programmers free individual objects regions lead substantial increase memory consumption 
worse limitation precludes regions common programming idioms reducing usefulness 
generalization general purpose region allocators call reaps 
reaps combination regions heaps providing full range region semantics addition individual object deletion 
show implementation reaps provides high performance outperforming allocators region semantics 
case study demonstrate space advantages software engineering benefits reaps practice 
results indicate programmers needing fast regions reaps programmers considering custom allocators lea allocator 
categories subject descriptors programming languages dynamic storage management general terms algorithms experimentation performance reliability 
programmers seeking improve performance incorporate custom memory allocators applications 
custom allo supported nsf itr ccr darpa 
done emery berger research intern microsoft research doctoral student university texas 
emery berger supported microsoft research fellowship 
opinions findings recommendations expressed material authors necessarily reflect sponsors 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
oopsla november seattle washington usa 
copyright acm benjamin zorn microsoft research microsoft way redmond wa zorn microsoft com kathryn mckinley dept computer sciences university texas austin austin tx mckinley cs utexas edu aim take advantage application specific allocation patterns manage memory efficiently general purpose memory allocator 
instance parser specint benchmark suite runs faster custom allocator windows xp allocator 
numerous books articles recommend custom allocators optimization technique 
custom memory allocators widespread including apache web server gcc compiler specint benchmarks standard template library examine :10.1.1.111.8237
language provides language constructs directly support custom memory allocation overloading operator new delete :10.1.1.32.6278
key contributions 
perform comprehensive evaluation custom allocation 
survey variety applications wide range custom allocators 
compare performance memory consumption general purpose allocators 
surprised find contrary conventional wisdom custom allocation generally improve performance case leads performance degradation 
state art general purpose allocator lea allocator yields performance equivalent custom memory allocators benchmarks 
results suggest programmers seeking faster memory allocation lea allocator writing custom allocator 
custom allocators provide higher performance regions 
regions provide high performance force programmer retain memory associated region object region dies :10.1.1.23.5498:10.1.1.32.6278
show performance gains regions come expense excessive memory retention 
importantly inability free individual objects regions greatly complicates programming server applications apache rely regions avoid resource leaks 
programs regions memory allocation patterns 
programs intensive memory reuse producer consumer allocation patterns dynamic arrays regions consume large unbounded amounts memory 
generalization regions heaps call reaps 
implementation reaps provides performance semantics regions allowing programmers delete individual objects 
show reaps nearly match speed regions way provide additional semantics generality 
reaps provide reusable library solution region allocation competitive performance potential reduced memory consumption greater memory management flexibility regions 
demonstrate individual object deletion reaps case study add new module apache 
orig inal version program uses malloc free 
show modifying lines reap interface get region semantics individual object deletion reduce memory consumption significantly 
remainder organized follows 
discuss related section 
describe benchmarks section 
section analyze structure custom memory allocators benchmark applications explain regions provide sufficient support applications particular server applications apache 
section describe reaps implementation detail 
describe experimental infrastructure methodology section 
section experimental results including comparison previous allocators region semantics case study 
discuss results section explaining believe programmers custom memory allocators despite fact provide performance promise conclude section 
related numerous articles books appeared trade press presenting custom memory allocators optimization technique 
mayhew devote entire chapters development number custom memory allocators 
meyers describes detail freelist class custom allocator effective returns topic custom allocators sequel 
discusses class allocators optimization technique 
hanson devotes chapter implementation regions arenas citing speed software engineering benefits regions motivation 
ellis stroustrup describe syntactic facilities allow overloading operator new simplifying custom allocators stroustrup describes class allocators facilities :10.1.1.32.6278
hanson authors custom memory allocation widely effective optimization results suggest regions yield performance improvements 
generalization custom allocators reaps show reaps capture high performance region allocators 
region allocation variously known arenas groups zones attracted attention alternative garbage collection 
definitions literature programmers allocate objects region delete objects region delete individual objects :10.1.1.23.5498:10.1.1.32.6278
tofte talpin system provides automatic regionbased memory management ml 
gay aiken describe safe regions raise error programmer deletes region containing live objects introduce rc language extension reduces overhead safe region management :10.1.1.32.6278
authors benefits regions investigate hidden memory consumption cost limitations regions alternative avoids drawbacks combines individual object deletion benefits regions 
compute memory cost region allocation measure memory consumed regions objects freed immediately 
binary instrumentation determine objects referenced post process combined allocation trace obtain peak memory consumption object drag elapsed time reclamation object 
definition drag differs slightly original term runciman 
drag time unreachability object garbage collected environment defines availability reclamation 
kolodner sagiv measure drag performing periodic object reachability scanning context java garbage collected language 
literature general purpose memory allocators extensive see wilson survey comprehensive description :10.1.1.111.8237:10.1.1.111.8237
describe windows xp lea allocators study widespread lea allocator forms basis linux memory allocator 
windows allocator best fit allocator exact size linked list freed objects multiple bytes optimize case requests small sized objects 
objects larger bytes obtained sorted linked list sacrificing speed fit 
lea allocator approximate best fit allocator different behavior object size 
small objects bytes allocated exact size 
requests medium sized object certain events trigger lea allocator coalesce objects combining adjacent free objects hope reclaimed space reused object 
medium sized objects lea allocator performs immediate coalescing splitting breaking objects smaller ones approximates best fit 
large objects allocated freed mmap 
lea allocator best allocator terms combination speed memory usage aware 
addition standard malloc free interface windows provides windows specific memory allocation interface refer windows heaps function calls 
windows heaps interface exceptionally rich including multiple heaps region semantics nested regions individual object deletion 
memory allocation infrastructure provides non nested regions permit individual object deletion 
show section implementations match performance regions reaps reaps capture semantics 
previous evaluating impact custom memory allocators zorn authors 
zorn compared custom domain specific allocators general purpose memory allocators 
analyzed performance benchmarks cfrac gawk ghostscript perl applications custom allocators slightly improved performance ghostscript custom allocator outperformed general purpose allocators tested 
zorn custom allocators generally little impact memory consumption 
study differs number ways 
comprehensive study custom allocation including benchmark suite covering wide range custom memory allocators zorn benchmarks include essentially variety 
address custom allocators semantics differ general purpose allocators regions zorn benchmarks semantically equivalent custom allocators 
findings differ zorn find certain custom allocators especially regions consistently yield performance improvements existing generalpurpose memory allocators despite fact general purpose allocators faster 
previous held custom memory allocators idea articles trade press waste time zorn find true 
custom allocators impact performance regions particular high performance software engineering benefits 
show inability programmers delete objects regions may allocators variants call class allocators section 
benchmarks custom allocation parser english parser test boxed sim balls box simulator breeze optimizing compiler espresso vpr fpga placement routing test placement gcc optimizing compiler apache web server see section lcc retargetable compiler mudlle mud compiler interpreter time mud general purpose allocation gzip gnu zip data compressor test input compressed mcf vehicle scheduler test input crafty chess program test input eon ray tracer test chair control cook perlbmk perl interpreter perfect pl gap groups language interpreter test vortex object oriented dbm test raw twolf cad placement routing test net espresso optimizer plas test lindsay hypercube simulator script mine table benchmarks inputs :10.1.1.32.6278:10.1.1.111.8237:10.1.1.111.8237
include generalpurpose benchmarks comparison custom allocation section 
programs written breeze eon written 
lead substantial increase memory consumption limits applicability 
develop generalized memory allocator preserves high performance regions providing greater flexibility potential reduction memory consumption 
regions incorporated real time java allow real time guarantees provided existing garbage collector algorithm implementation 
regions somewhat different traditional region allocators associated computations suffer problems traditional regions 
particular threads producer consumer relationship region allocation causing unbounded memory consumption 
believe adapting reaps setting real time java fruitful topic research 

benchmarks list benchmarks table including general purpose allocation benchmarks comparison custom allocation section 
benchmarks come specint benchmark suite :10.1.1.111.8237
custom allocation benchmarks include number programs prior memory allocation 
programs include gay aiken apache lcc mudlle boxed sim chilimbi :10.1.1.32.6278
breeze compiler infrastructure 
breeze intensive standard template library stl implementations stl custom allocators including study officially recommended ibm 
largest inputs available custom allocation benchmarks vpr parser 
general purpose benchmarks spec test inputs 
overhead imposed binary instrumentation runtimes inputs resultant trace files intractable 
excluded just spec benchmark bzip process test inputs 
describe inputs drive benchmarks table apache 
drive apache follow gay aiken run computer program fetches large number static web pages 
test unrealistic serves purposes 
isolates performance usual network disk bottlenecks magnifying performance impact custom allocation 
second benchmark gay aiken facilitates comparison 
emulating custom semantics custom memory allocators support semantics differ memory allocation interface 
order replace custom allocators emulate semantics top standard allocation calls 
wrote tuned region emulator provide full range region semantics benchmark applications including nesting see section 
region emulator uses general purpose allocator allocated object records pointer object application deletes region region emulator allocated object 
record pointer information allocated objects band dynamic array associated region allocated objects 
method ensures access allocated object client program region emulator 
technique means region emulator impact object drag elapsed time reclamation object measure section 
region emulation impact space 
allocated object requires bytes memory record dynamic array addition object overhead bytes 
eliminating overhead advantage regions inability free individual objects may greater impact space explore section 
custom allocators section explain exactly mean custom memory allocators 
discuss reasons programmers survey wide range custom memory allocators describing briefly 
term custom memory allocation way denote memory allocation mechanism differs generalpurpose allocation ways 
custom allocator may provide object allocated chunk memory 
second may immediately return objects system general purpose allocator 
instance custom allocator may obtain large chunks memory generalpurpose allocator number objects 
custom allocator defer object deallocation returning objects system long object unreachable 
definition custom memory allocators excludes wrappers perform certain tests null return values returning objects obtained general purpose memory manager 
exclude consideration memory allocators serve primarily infrastructures implementing object layout optimizations 
programmers custom allocators variety reasons programmers custom memory allocators 
principal reason cited programmers authors books programming runtime performance 
operation cost generalpurpose memory allocators order magnitude higher custom allocators programs intensive runtime parser time spent memory operations boxed sim memory operations breeze vpr gcc apache lcc mudlle average time spent memory management operations custom allocation benchmarks allocators replaced windows allocator see section 
memory management operations account program runtime average indicating substantial opportunity optimization 
space mb parser space custom allocator benchmarks boxed sim breeze vpr gcc apache memory consumption custom allocation benchmarks including memory allocated custom allocators 
consume relatively small amounts memory modern hardware suggesting little opportunity reducing memory consumption 
runtime space consumption custom allocation benchmarks 
allocator may see performance improvements custom allocators 
improving performance shows amount time spent memory management operations applications wide range custom memory allocators custom memory allocator replaced windows allocator 
region emulator section gcc apache lcc mudlle 
applications spend large percentage runtime memory allocator average demonstrating opportunity improve performance optimizing memory allocation 
nearly benchmarks custom allocators improve performance 
goal explicitly stated documentation source code 
instance apache api interface documentation claims custom generally faster malloc implementation stl runs breeze refers custom allocator optimized node allocator engine parser allocator described working best stack operations allocation gcc usually fast long objects usually small mudlle region allocator fast easy hanson cites performance benefits regions book assume intended benefit 
lcc includes class custom allocator intended improve performance observable performance impact 
class freelist custom allocator boxed sim appears intended improve performance 
reducing memory consumption programmers primarily custom allocators improve performance occasionally reduce memory documentation gnu library 
hanson private communication indicated intent class allocator performance 
results disabled custom allocator isolate impact region allocators 
lcc mudlle consumption 
benchmarks vpr uses custom allocation exclusively reduce memory consumption stating custom allocator allocating fairly small data structures memory efficiency crucial gcc partially motivated space considerations 
source documentation silent subject documentation gnu library suggests benefit 
shows amount memory consumed custom allocators benchmark applications 
parser gcc consume significant amounts memory modern hardware mb mb respectively 
recall small input sizes order able process trace files 
improving software engineering writing custom code replace general purpose allocator generally software engineering practice 
memory allocated custom allocator managed allocator including general purpose memory manager 
inadvertently calling free custom allocated object corrupt heap lead segmentation violation 
result significant bookkeeping burden programmer ensure objects freed correct allocator 
custom allocators difficult understand sources memory consumption program 
custom allocators precludes memory leak detection tools purify 
custom allocators precludes option substituting parallel allocator provide smp scalability garbage collector protect memory leaks shared multi language heap 
custom memory allocators provide important software engineering benefits 
region custom allocators parsers compilers gcc lcc mudlle simplifies memory management 
regions provide separate memory areas single call deletes entirety 
see comment chunk malloc space overhead object padding needed start object suitable boundary 
motivation policy mechanism performance space software api region nested multiple chunks stack type benchmark allocator engineering delete lifetimes areas optimized optimized parser custom pattern boxed sim class breeze class stl vpr region gcc region apache nested region lcc region mudlle region reaps table characteristics custom allocators benchmarks including reaps 
performance motivates custom allocators possibly motivated space concerns see section 
api means allocator allows individual object allocation deallocation chunks means custom allocator obtains large blocks memory general purpose allocator see section 
multithreaded server applications regions isolate memory spaces separate threads sandboxing reducing likelihood thread accidentally maliciously overwrite thread data 
server applications apache web server regions prevent memory leaks 
connection terminated fails server tears memory associated connection simply freeing associated region 
regions allow individual object deletion entire region retained long just object remains live 
policy lead excessive memory consumption prevents regions certain usage patterns explore section 
taxonomy custom allocators order outperform general purpose memory allocator programmers apply knowledge set objects 
instance programmers regions manage objects known dead time 
programmers write custom allocators take advantage object sizes allocation patterns 
break allocators custom allocation benchmarks terms characteristics table 
divide categories motivation programmer custom allocator policies implemented allocators mechanisms implement policies 
notice case vpr performance motivating factor 
explain meaning characteristic descriptions custom allocators 
class allocators 
class allocators optimize allocation type size object eliding size checks keeping freelist objects specific type 
implement api malloc free provide individual object allocation deletion optimize size type 
regions 
regions allocate objects incrementing pointer large chunks memory 
programmers delete regions entirety 
allocation freeing fast possible 
region allocator includes function deletes memory operation includes support multiple allocation areas may managed independently 
regions reduce bookkeeping burden programmer reduce memory leaks allow individual objects deleted 
example region memory allocation 
regions allocate memory incrementing pointer successive chunks memory 
region deletion reclaims allocated objects en masse freeing chunks 
custom allocators survey variants regions nested regions 
nested regions support nested object lifetimes 
apache uses provide regions connection basis sub regions execution user provided code 
tearing memory associated connection requires just call memory region 
extended version region allocator adds deletion object allocated certain object :10.1.1.111.8237
extension supports object allocation follows stack discipline name comes object stack 
custom patterns 
catch category refers essentially general purpose memory allocator optimized particular pattern object behavior 
instance parser uses fixed size region memory case mb allocates block bumping pointer 
freeing block marks free block allocator resets pointer back new block 
allocator fast parser stack memory object lifetimes follow discipline exhibits unbounded memory consumption 
problems regions description shows custom allocators lattice apis showing reaps combine semantics regions heaps 
regions 
regions performance software engineering advantages general purpose memory allocation considerably increase memory consumption 
importantly regions allocation patterns 
particular regions implementing unbounded buffers dynamic arrays producer consumer patterns 
programmers reclaim individual objects regions programs allocation patterns consume unbounded amounts memory 
limitations practical problem 
instance apache api manages memory regions pools prevent resource leaks 
programmers add functionality apache writing modules compiled apache server 
regions constrain way programmers write modules prevent natural allocation patterns producer consumer 
general programmers rewrite applications written general purpose allocation 
restriction unintended consequence regions satisfy apache need heap teardown high performance 
ideally combine general purpose allocation region semantics allowing multiple allocation areas cheaply deleted en masse 
extension region semantics individual object deletion satisfy needs applications apache increasing allocation pattern coverage 
interface comprises semantics provided custom allocators surveyed excluding deletion 
high performance implementation reduce need conventional regions custom allocators 
goals allocator describe section 

reaps generalizing regions heaps designed implemented generalization regions general purpose memory allocators heaps call reaps 
reaps provide full range region semantics including nested regions include individual object deletion 
depicts lattice api showing reaps combine semantics regions heaps 
provide interface reap sbrk bl ro diagram heap layers comprise implementation reaps 
reaps adapt acting regions heaps see section 
layer adds metadata enable heap subsequently manage memory obtained region 
description api implementation reaps 
example reap allocation deallocation 
reaps add metadata objects freed heap 
allocation including operations reap creation destruction clearing freeing object reap destroying reap data structure individual object allocation deallocation void void reap void parent void void reap void void reap clear void void reap size size void void reap void object built implementation reaps heap layers 
heap layers infrastructure allows programmers compose allo layers build high performance memory allocators easily modifying code existing memory allocator 
layers implementations mixins classes superclass template argument :10.1.1.156.4510
mixins programmer creates allocators composable layers compiler implements efficiently 
design implementation implementation reaps includes region allocator support nested reaps 
reaps adapt behaving regions heaps 
initially reaps behave regions 
allocate memory bumping pointer geometrically increasing large chunks memory initially thread doubly linked list 
regions reaps add object headers allocated object 
headers boundary tags contain metadata allow object subsequently managed heap 
reaps act region mode call deletes individual object 
reaps place freed objects associated heap 
subsequent allocations reap memory heap exhausted point reverts region mode 
example reap allocation appears 
depicts design reaps graphical form heap layers 
memory requests malloc come proceed upwards class hierarchy 
adapt heap layer approximates behavior lea allocator order take advantage high speed low fragmentation 
addition wrote new layers 
layer provides support nesting heaps 
second layer optimizes case memory freed allocating memory quickly bumping pointer adding necessary metadata 
takes heaps arguments maintains boolean flag initially true 
flag true allocates memory heap bumping pointer adding object metadata side effect allocating 
require header information subsequently free memory heap 
bypassing case little impact general purpose memory allocation speeding initial allocation heap items dramatically improves performance region allocation 
object freed placed heap flag set false 
allocates memory second heap 
heap empty region deleted flag reset true 
layer maintains linked list allocated objects provides region deletion operation clear iterates list frees objects 
region heap layer manage memory geometrically increasing chunks efficient 

evaluating custom memory allocators provide allocation statistics benchmarks table 
general purpose allocation benchmarks include completeness 
particular mcf crafty eon gap allocate objects entire lifetime including large objects 
certain trends appear data 
general programs general purpose allocators spend relatively little time memory allocator average programs custom allocators spend average time memory operations 
programs custom allocators tend allo cate small objects 
kind allocation behavior stresses memory allocator demonstrates programmers custom memory allocators generally correct pinpointing memory manager significant factor performance applications 
evaluating regions identified custom memory management policies api regions nesting multiple areas regions unique requiring programmer tailor program choice allocation policy 
regions programmers give ability delete individual objects 
objects region die time restriction affect memory consumption 
presence just live object ties entire region potentially leading considerable amount wasted memory 
explore impact memory consumption inability reclaim dead objects section 
measure impact regions binary instrumentation tool wrote binary instrumentation system 
link program region emulator instrument tool track allocations accesses heap object 
object deleted explicitly free region deletion tool outputs record indicating object touched allocation time 
post process trace compute amount memory program freed individual object soon possible 
highly aggressive freeing may reasonable show measurements programs general purpose memory allocators 

results section compares execution times different memory allocation policies number programs compares original custom allocators general purpose allocation reaps 
find region allocators consistently outperform lea general purpose allocator 
compare space consumption options find regions may unnecessarily consume additional space 
systems provide similar semantics reaps show implementation reaps faster 
case study shows combining object deletion region semantics reaps yield reduced memory consumption maintaining software engineering protection benefits regions 
runtimes best runs real time priority warm run variation percent 
programs compiled visual run mhz pentium iii system mb ram unified cache data instruction caches windows xp 
compare custom allocators windows xp memory allocator refer graphs win version doug lea allocator refer implementation reaps 
non region applications gcc reaps substitute region emulation gcc 
remaining benchmarks reaps direct replacement regions 
runtime performance compare runtime performance custom allocation generalpurpose allocation simply reroute custom allocator calls general purpose allocator reaps region emulation needed 
study compare custom allocators win nesting requires different programming style experience nesting occurs conjunction regions 
benchmark statistics benchmark total objects max objects average object size total memory max total max mem mgmt 
ops 
bytes bytes bytes runtime custom allocation parser boxed sim breeze vpr gcc apache lcc mudlle general purpose allocation espresso lindsay gzip mcf crafty eon perlbmk gap vortex twolf table statistics benchmarks replacing custom memory allocation general purpose allocation 
compute runtime percentage memory management operations default windows allocator 
xp memory allocator version lea allocator implementation reaps 
second bar shows windows allocator degrades performance considerably programs 
particular parser mudlle run slower windows allocator original custom allocator 
boxed sim vpr apache run slower windows allocator 
results taken justify custom allocators programs 
picture changes look third bar showing results replacing custom allocators lea allocator 
applications lea allocator provides nearly performance original custom allocators slower average 
lea allocator slightly improved performance breeze turned stl internal custom allocators 
benchmarks lcc mudlle run faster region custom allocators lea allocator 
result shows state art general purpose allocator eliminates performance advantages custom allocators 
fourth bar shows results reaps 
results show reaps general purpose allocation intended role perform quite nearly matching lea allocator parser breeze 
remaining benchmarks lcc mudlle reaps nearly match performance original custom allocators running slower compared lea allocator runs slower 
results show reaps achieve performance comparable region allocators providing flexibility individual object deletion 
memory consumption measure memory consumed various memory allocators running benchmarks custom allocation lea allocator reaps linked slightly modified version lea allocator 
modify sbrk mmap emulation routines keep track high water mark memory consumption 
include windows xp allocator study provide equivalent way keep track memory consumption 
experiments reap versions individual object deletion reap acts region 
modifying programs deletion requires applicationspecific information labor intensive 
section shows case study reaps uses individual object deletion reducing memory requirement new apache module 
shows results memory consumption quite mixed 
custom allocators lea allocator reaps consistently yield space advantage 
gcc allocates small objects object overhead reaps lea allocator bytes leads increased memory consumption 
despite overhead reaps lea allocator reduce memory consumption parser breeze apache 
custom memory allocator parser allocates fixed sized chunk memory compile time constant set mb lea allocator reaps just memory 
worse custom allocator brittle requests fixed limit result program termination 
apache region allocator reaps region emulator accounting difference space consumption 
hand increasing chunk sizes reaps causes increased memory consumption mudlle 
allocators implicitly explicitly intended reduce memory consumption gcc achieves goal saving memory compared lea allocator vpr provides savings 
custom allocation necessarily provide space advantages lea allocator reaps consistent observation programmers generally custom allocation reduce memory consumption 
results show custom allocators achieve performance space advantages 
region allocators normalized runtime runtime custom allocation benchmarks parser boxed sim breeze original win reaps non regions regions averages vpr gcc apache lcc mudlle non regions regions normalized runtimes smaller better 
custom allocators outperform windows allocator lea allocator fast faster custom allocators 
region benchmarks reaps come close matching performance custom allocators 
normalized space parser space custom allocator benchmarks boxed sim breeze original reaps non regions regions averages vpr gcc apache lcc mudlle non regions regions normalized space smaller better 
omit windows allocator directly measure space consumption 
custom allocators provide little space benefit occasionally consume memory general purpose allocators reaps 
normalized runtime memory consumption custom allocation benchmarks comparing original allocators windows lea allocators reaps 
normalized runtime runtime region benchmarks original reaps lcc mudlle normalized runtimes smaller better 
reaps fast original custom allocators faster previous allocators similar semantics 
provide advantages see lcc mudlle 
space advantages somewhat misleading 
lea allocator reaps add fixed overhead object regions tie arbitrarily large amounts memory programmers wait objects dead free region 
section measure hidden space cost region interface 
evaluating region allocation binary instrumentation tool describe section obtained curves allocation time benchmarks memory consumed region allocator memory required dead objects freed immediately access 
dividing areas curves gives total drag measure average ratio heap sizes immediate object deallocation 
program immediately frees dead object minimum possible total drag 
intuitively higher drag program memory consumption ideal 
shows drag statistics wide range benchmarks including programs general purpose memory allocators 
programs non region custom allocators minimal drag bulk programs general purpose allocation indicating programmers tend aggressive reclaiming memory 
drag results vortex show programmers careful programming practices may preclude aggressive reclamation 
programs regions consistently exhibit drag including gcc mudlle lcc high drag 
drag corresponds average times memory consumed required 
cases programmers concerned peak memory footprint consumed application average amount memory time 
table shows footprint regions compared immediately freeing objects 
increase peak caused regions ranges vpr lcc average 
shows memory requirement profile lcc demonstrating regions influence memory consumption time 
measurements confirm hypothesis regions lead substantially increased memory consumption 
programmers may willing give additional space exchange programming convenience believe forced 
experimental comparison previous results comparing previous allocators provide semantics similar provided reaps see section 
windows heaps windows specific interface providing multiple non nested heaps custom allocation infrastructure provides functionality 
results lcc mudlle allocation intensive region benchmarks 
windows heaps parser boxed sim breeze vpr gcc apache total drag non regions regions general purpose lcc mudlle gzip drag statistics applications general purpose memory allocation average non regions average region custom allocators average excluding lcc 
mcf crafty eon perlbmk vortex twolf espresso lindsay bytes allocated memory requirement profile lcc allocation time regions free immediately memory requirement profile lcc 
top curve shows memory required regions bottom curve shows memory required individual objects freed immediately 
effect memory consumption immediately freeing objects 
programs region allocators especially 
lcc particular consumes times memory time required peak 
peak memory benchmark regions immediate free increase vpr gcc apache lcc mudlle table peak memory footprint region applications bytes 
regions leads increase footprint average 
place regions lcc take twice long mudlle take longer run 
slows execution lcc times slows mudlle 
reaps slow execution just showing reaps best implementation functionality aware 
benchmarks replacing custom allocator lea allocator yields comparable performance 
reaps imposes runtime penalty compared original region allocators 
addition reaps provide flexible interface regions permits programmers reclaim unused memory 
believe applications greater flexibility reaps justifies small overhead 
reaps apache case study built new apache module demonstrate space consumption advantages provided allowing individual object deletion region allocation framework 
apache module api incorporated bc arbitrary precision calculator language uses malloc free 
apache implements pool region api including pool allocation creation destruction 
reroute calls reap add ap call routed enabling apache modules utilize full range reap functionality 
way existing apache modules reap naturally take advantage individual object deletion 
preprocessor directives redefined calls bc 
modification affected just lines lines total bc 
incorporated bc module bc 
module clients execute bc programs directly apache benefiting usual memory leak protection provided pools 
compared memory consumption test cases 
example computing th prime consumes megabytes memory ap 
ap calculation consumes kilobytes 
experiment shows best approaches 
reap functionality prevents memory leaks offers module protection region interface currently apache furthermore reaps enable richer range application memory usage paradigms 
reaps practical standard malloc free programs apache modules minor modifications 

discussion shown performance frequently motivates custom memory allocators provide performance promise 
offer explanations programmers custom allocators effect 
recommended practice reason believe programmers custom allocators improve performance recommended influential practitioners perceived inadequacies system provided memory allocators 
examples allocators class allocators boxed sim lcc 
premature optimization software development programmers discover custom allocation outperforms general purpose allocation microbenchmarks 
observation may put custom allocators place allocation may eventually account tiny percentage application runtime 
drift case suspect programmers initially right decision choosing custom allocation performance software evolved custom allocator longer performance impact 
allocator gcc performs fast object reallocation believe difference parsing dominated runtime optimization passes dominate gcc runtime 
improved competition performance general purpose allocators continued improve time 
windows lea allocators optimized performance number programs wide range allocation behaviors 
instance memory allocators perform quite requests objects size rendering class custom allocators superfluous including standard template library 
certainly programs unusual allocation patterns lead allocators perform poorly suspect programs increasingly rare 
feel programmers find system allocator inadequate try reaps lea allocator writing custom allocator 

despite widespread belief custom allocators improve performance come different 
examine benchmarks custom memory allocators including apache web server applications specint benchmark suite 
find lea allocator fast faster custom allocators 
exceptions region allocators outperform generalpurpose allocation 
show regions come increased cost memory consumption support common programming idioms 
reaps generalization general purpose region allocators 
reaps combination regions heaps providing full range region semantics addition individual object deletion 
demonstrate reaps combine increased flexibility high performance outperforming allocators region semantics 
show reaps yield significant reductions memory consumption 
plan build ways 
reaps currently limited single threaded plan integrate reaps hoard scalable memory allocator 
believe extended scalable memory allocator eliminate need custom memory allocators 
investigating integration reaps garbage collected setting 

stephen making boxed sim benchmark available sam daniel jim nez providing access guidance breeze compiler infrastructure david gay making available region benchmarks 
dave hanson martin doug lea ken pierce ran helpful discussions andy edwards rest team 
software benchmarks described may downloaded fromhttp www cs umass edu emery 

apache foundation 
apache web server 
www apache org 
william martin rinard 
implementation scoped memory real time java 
pages 
emery berger kathryn mckinley robert blumofe paul wilson 
hoard scalable memory allocator multithreaded applications 
international conference architectural support programming languages operating systems asplos ix pages cambridge ma november 
emery berger benjamin zorn kathryn mckinley 
composing high performance memory allocators 
proceedings acm sigplan conference programming language design implementation pldi pages snowbird utah june 
greg james gosling benjamin peter steve mark turnbull 
real time specification java 
addison wesley 
gilad bracha william cook :10.1.1.156.4510
mixin inheritance 
norman meyrowitz editor proceedings conference object oriented programming systems languages applications oopsla proceedings european conference object oriented programming ecoop pages ottawa canada 
acm press 
dov david mayhew 
efficient 
addison wesley 
chilimbi 
efficient representations abstractions quantifying exploiting data locality 
proceedings acm sigplan conference programming language design implementation pldi pages snowbird utah june 
chilimbi mark hill james larus 
cache conscious structure layout 
proceedings acm sigplan conference programming language design implementation pldi pages atlanta ga may 
margaret ellis bjarne :10.1.1.32.6278
annotated manual 
addison wesley 
boris 

www org 
christopher fraser david hanson 
retargetable compiler design implementation 
addison wesley 
free software foundation 
gcc home page 
gcc gnu org 
david gay alex aiken :10.1.1.32.6278
memory management explicit regions 
proceedings acm sigplan conference programming language design implementation pldi pages montreal canada june 
david gay alex aiken 
language support regions 
proceedings acm sigplan conference programming language design implementation pldi pages snowbird utah june 
wolfram 
dynamic memory allocator implementations linux system libraries 
www dent med uni muenchen de malloc slides html 
dan grossman greg morrisett trevor jim michael hicks wang james cheney 
region memory management cyclone 
proceedings acm sigplan conference programming language design implementation pldi pages berlin germany june 
sam daniel jim nez calvin lin 
breeze compiler infrastructure 
technical report tr university texas austin november 
david hanson 
fast allocation deallocation memory object lifetimes 
software practice experience number pages 
wiley january 
david hanson 
interfaces implementation 
addison wesley 
reed hastings bob joyce 
purify fast detection memory leaks access errors 
proceedings winter usenix conference pages december 
mark johnstone paul wilson 
memory fragmentation problem solved 
international symposium memory management pages vancouver canada 
doug lea 
memory allocator 
edu dl html malloc html 
scott meyers 
effective 
addison wesley 
scott meyers 
effective 
addison wesley 

action industrial strength programming techniques 
addison wesley 
philip nelson 
bc arbitrary precision calculator language 
www gnu org software bc bc html 
jeffrey richter 
advanced windows developer guide win api windows nt windows 
microsoft press 
gustavo rodriguez rivera mike spertus charles 
conservative garbage collection general memory allocators 
international symposium memory management minneapolis minnesota 
ross 
aed free storage package 
communications acm 
colin runciman niklas 
lag drag heap profiling 
implementation functional languages workshop sweden september 
sgi 
standard template library allocators 
www sgi com tech stl allocators html 
ran elliot kolodner mooly sagiv 
heap profiling space efficient java 
proceedings acm sigplan conference programming language design implementation pldi pages snowbird utah june 
standard performance evaluation :10.1.1.111.8237
spec 
www spec org 
standard performance evaluation 
spec 
www spec org 
lincoln stein doug maceachern linda mui 
writing apache modules perl reilly associates 
bjarne stroustrup 
programming language second edition 
addison wesley 
suzanne pierce 
microsoft tool box 
research microsoft com research asp 
mads tofte jean pierre talpin 
region memory management 
information computation 
dan truong fran ois andr 
improving cache behavior dynamically allocated data structures 
international conference parallel architectures compilation techniques pages october 
phong vo 
general efficient memory allocator 
software practice experience number pages 
wiley 
mark weiser alan demers carl hauser 
portable common runtime approach interoperability 
twelfth acm symposium operating systems principles pages december 
wilson johnstone neely boles :10.1.1.111.8237
dynamic storage allocation survey critical review 
lecture notes computer science 
benjamin zorn 
measured cost conservative garbage collection 
software practice experience 
