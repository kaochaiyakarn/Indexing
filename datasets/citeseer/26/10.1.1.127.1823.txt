properties gray binary representations jonathan rowe rowe cs bham ac uk computer science department university birmingham birmingham tt uk darrell whitley whitley cs colostate edu laura barbulescu laura cs colostate edu jean paul watson cs colostate edu department computer science colorado state university fort collins colorado usa representations formalized encodings map search space vertex set graph 
define notion bit equivalent encodings show encodings corresponding walsh coefficients conserved 
focus gray codes particular types encoding review properties related gray codes 
gray codes widely conjunction genetic algorithms bit climbing algorithms parameter optimization problems 
new convergence proofs special class unimodal functions proofs show steepest ascent bit climber reflected gray code representation reaches global optimum number steps linear respect encoding size 
fact different gray codes 
shifting defined mechanism dynamically switching gray code representation order escape local optima 
theoretical results substantially improve understanding gray codes shifting mechanism 
new proofs shed light number unique gray code neighborhoods accessible shifting neighborhood structure changes shifting 
show shifting improve performance local search algorithm best genetic algorithms currently available 
choosing representation vital component solving search problem 
wolpert macready free lunch nfl theorem wolpert macready proves search algorithm better possible discrete functions 
radcliffe surry extended notions showed representations equivalent behavior considered possible functions 
evolutionary computing community long concerned binary encodings gray codes real valued representations parameter optimization problems 
arguments representation better largely limited empirical data practical experience historical bias 
primarily concerned gray binary representations parameter optimization 
results relate local optima defined local search results relate genetic algorithms 
set function ir seek maximize minimize massachusetts institute technology evolutionary computation rowe whitley barbulescu 
watson local search algorithm problem defined assigning neighborhood structure 
point assign subset called neighborhood local search algorithm minimizing 
pick random point 

find point 
point terminate 

assign 
go 
local search restarted locate multiple local optima 
understand behavior algorithm need understand relationship neighborhood structure objective function neighborhood structure represented directed graph points vertices edges 
neighborhood structure symmetric case binary hypercube undirected graph 
graph objective function thought function vertices called landscape 
particular encoding map set vertex set graph 
especially interested different encodings arise choosing different maps graph 
particular look different landscapes arise binary strings represent points hamming neighborhood structure 
labeled binary string hamming neighborhood nh set generated changing exactly bit string remainder organized follows 
section introduces formal description representations encodings map search space vertex set graph 
define notion equivalent encodings graph automorphisms prove properties equivalent bit encodings 
section explains gray codings introduces examples different gray encodings 
relates equivalent bit encodings walsh coefficients 
prove dimensional unimodal function steepest ascent bit hamming distance neighborhood reflected gray encoding converge steps order total evaluations 
investigate functions unimodal gray space solved efficiently local search algorithms 
section introduce shifting rana whitley mechanism changing set restricted gray codes effort escape local optima 
theoretical results substantially improve understanding shifting mechanism 
new proofs shed light number unique gray code neighborhoods accessible shifting neighborhood structure changes shifting 
show shifting improve performance local search algorithm best genetic algorithms currently available 
representations local search representation modeled various ways 
current representation encoding maps search space graph induces search neighborhood 
specifically search space graph vertices 
encoding respect bijection search space vertices graph 
elements neighbors encoding edge evolutionary computation volume number gray binary representations equivalence encodings encodings equivalent neighbors neighbors 
encodings equivalent local neighborhood search algorithm perform identically encoding 
definition help characterize equivalence encodings 
definition graph bijection maps vertices vertices edge edge vertices 
set automorphisms graph forms group function composition called automorphism group graph 
subgroup group permutations vertices theorem encodings respect graph equivalent automorphism 
proof encoding automorphism encoding 
neighbors edge happens edge equivalently neighbors 
conversely equivalent define recall encodings bijections inverse encoding defined 
clearly bijection 
vertices follows edge edge neighbors neighbors edge 
automorphism notion equivalent encodings forms equivalence relation set possible encodings 
equivalence class corresponds orbit group automorphisms acting set encodings 
label vertices numbers encoding identified permutation equivalently permutation vertices sets equivalent encodings correspond cosets subgroup automorphisms means things automorphisms divides 
equivalence class contains encodings equivalence classes 
words exactly distinct ways encoding vertices example bit encodings example suppose integer dimensional hypercube vertices binary strings length 
strings edge differ bit position 
automorphisms arise ways 
bit string call mask consider map indicates exclusive 
hard see edge edge 
bit string mask gives rise automorphism way 
second way getting automorphism permute bit positions strings 
suppose permutation set 
binary string consider map evolutionary computation volume number rowe whitley barbulescu 
watson easy check map gives automorphism 
harary proven automorphism described unique combination mask permutation 
masks 
permutations 
unique automorphisms altogether 
total number permutations number distinct encodings respect 
objective functions vectors fitness function ir encoding define fitness function respect encoding fc ir fc vertices pick arbitrary encoding 
fitness function defined respect encoding written vector fn fk fc note fk letting fb denote binary encoding fk fb example suppose fitness function 
graph hypercube pick ordinary binary encoding fitness vector respect binary encoding 
encoding fitness vector 
important note role standard binary coding fc encoding inverted map backs bit string point domain allows function evaluated 
case coding happens behave gray code 
think fitness vectors living dimensional vector space 
changing encodings changes fitness vector permuting entries different codes stand different elements search space 
encoding define matrix encoding 
thought fitness vector respect evolutionary computation volume number gray binary representations fj encoding words fitness vector encoding fitness vector encoding obviously just identity matrix 
example encoding automorphism define matrix relative encoding say matrix representation group element easy verify automorphisms 
case equivalent encodings theorem encoding respect graph automorphism proof gray codes section focuses gray codes 
main results 
prove functions identical hamming distance neighborhoods similar walsh coefficients 
second prove function unimodal natural encoding unimodal hypercube gray encoding 
third prove dimensional unimodal function steepest ascent bit hamming distance neighborhood reflected gray encoding converge steps evaluations 
show exist functions unimodal gray space solved efficiently local search algorithms 
evolutionary computation volume number rowe whitley barbulescu 
watson standard binary reflected gray code gray codes encoding called gray code sequence forms hamiltonian cycle canonical example gray code hypercube standard binary reflected gray code 
reflected gray code defined recursively 
gray code sequence 
gray code bits construct new sequence bits scheme note reflection point new hypercube neighborhood structure folds reflection point 
note define different reflected gray code defining gray code sequence 
general encoding gray code adjacent integers represented bit strings hamming distance words differ single bit 
way contrast standard binary encodings hamming cliffs complementary bit strings representing adjacent integers example 
obviously gray codes property maximal distance strings hamming space hypercube difference integers strings represent 
distance typically set integers strings moves away corresponding hypercube 

define interval addition modulo number elements mod standard binary reflected gray code easy compute construct standard binary bit representation integer apply logical exclusive binary bit representation duplicate binary bit representation shifted bit right 
bits exclusive operation standard binary reflected gray code integer 
exists matrix transforms string length binary reflected gray representation 
exists matrix maps gray string back binary representation 
bit vector representing standard binary vector integer produces gray coding integer dn produces de gray coding bit column vector 
matrix bits diagonal upper minor diagonal bits upper triangle diagonal 
example evolutionary computation volume number gray binary representations recall gray code conjunction genetic algorithm local search algorithm string de grayed evaluation 
transformation matrices gray codes produced permuting columns 
gray codes produced adding constant integer addition mod generating binary representation permutation 
exact number gray codes unknown 
exponentially gray codes 
induce exactly neighborhood structure permutations columns gray transform matrix reflect space different dimension hypercube changing actual connectivity search space 
effect permuting bits string search space 
permuting bits creates new gray code change actual neighborhood structure 
possible apply different conditional transforms submatrices gray matrix produce gray codes different connectivities 
yields different gray codes method complex cumbersome 
simple way produce different gray codes shift integer domain 
results reflected gray codes different connectivity shifting change number local optima 
retain advantages properties reflected gray code 
bit string decoded string mapped integer value appropriately scaled function domain 
shifting simply integer offset applied intermediate integer generated decoding process 
shifted result wrapped ends valid integer domain 
precise shifting accomplished de bit string converting resulting bit string binary representation converting integer shifting integer constant addition mod 
integer mapped actual discretized domain 
provides examples different ways produce different gray codes 
rows bit strings represent different circular shifts bits strings 
corresponds part group permutes bit positions 
set shifts automorphism subset set permutations 
bit shift produces different gray code change neighborhood connectivity hypercube 
rows integers different shifts integer sequence 
note start reflected gray code shifts integer sequence remain reflected gray code 
note blurs distinction transforming function versus transforming encoding effect difference 
pairing gray sequence bit strings different shift integers produces different gray code combinations change neighborhood structure local search 
important understand encodings equivalence formal properties associated equivalence encodings 
walsh transform equivalent encodings automorphism hypercube written product mask permutation 
means matrix corresponding automorphism form matrix representing permutation evolutionary computation volume number rowe whitley barbulescu 
watson circular shift bit strings create different gray codes circular shift sequence integers create different gray codes rows bit strings represent different circular shifts bits strings 
bit shift produces different gray code change neighborhood connectivity hypercube 
rows integers different shifts integer sequence 
pairing row bits strings row integers yields standard binary reflected gray code 
represents application mask define walsh matrix respect encoding wi view strings dimensional vectors 
constant place current form simplifies inverse 
walsh transform vector ir wx walsh transform matrix wmw walsh transform vector produces vector composed known walsh coefficients 
similar fourier transform representation function transformed polynomial representation function walsh coefficients 
whitley particular set transforms map function function way preserve local search neighborhood 
furthermore transformation appeared conservative effect walsh coefficients function 
particular observed magnitudes walsh coefficients change coefficients move change signs 
moving mean coefficient associated subset bits may associated different subset bits 
example helps clear 
way transform function preserve neighborhood shift integer sequence corresponding decode bit strings fi index th element construct new function shift indexing fi 
addition modulo 
viewing vector permutation evolutionary computation volume number gray binary representations table walsh coefficients function shifting 
set integers obtained absolute value walsh coefficients identical functions 
shift shift moves elements permutation permutation 
fi 
define fi gray code ith component permutation standard binary reflected gray encoding integer means walsh coefficients computed respect fitness vector decoding fi fc 
inspection functions identical neighborhoods gray code 
table shows strong similarities walsh coefficients functions gray code 
practical implications shifting examined detail 
prove transformation preserves neighborhood structure similar conservative impact walsh coefficients 
lemma permutation bit positions strings length 
strings proof think permutation set strings uk vj jvj evolutionary computation volume number rowe whitley barbulescu 
watson theorem matrix representing permutation proof kwk theorem matrix representing action mask diagonal matrix th diagonal entry proof wi write diagonal matrix 
fitness vector respect encoding equivalent encoding 
exists permutation mask fitness vector encoding wf contains walsh coefficients fitness function encoding walsh coefficients new encoding wf diag evolutionary computation volume number ith walsh coefficient encoding fj fj fb gray binary representations means walsh coefficient associated string new encoding magnitude string old encoding sign change odd number ones common 
example standard binary encoding 
walsh transform vector consider automorphism mask 
know equivalent encoding original 
fitness vector respect new encoding 
walsh transform vector 
case automorphism just mask permutation bit positions theory indicates coefficients retain positions magnitudes change sign string odd number ones common 
local optima gray encodings known local search terminate local optimum point points neighborhood improve objective function 
say problem unimodal exactly local optimum bimodal exactly multimodal local optimum 
course neighborhood structure problem depends coding scheme section look effect gray encoding local optima 
suppose objective function defined unit interval 
way optimize function discretize interval local search 
select points interval identify points 
natural encoding map graph edges points 
function periodic may include edge 
simplicity assume functions periodic property 
choose encode points binary strings length 
choice gray encoding nice property 
evolutionary computation volume number rowe whitley barbulescu 
watson local search moves horizontal vertical directions 
finds diagonal stuck 
local search blind fact gradient information moving diagonal 
theorem function ir local optima gray encoding natural encoding 
proof point local optimum natural encoding 
mod modn better points neighbors gray code 
local optimum gray encoding 
original proof appeared whitley rana 
theorem states gray code local optima objective function considered function unit interval destroyed new local optima created 
particular corollary function unimodal natural encoding unimodal gray encoding 
corollary begs question functions unimodal real space multimodal gray space natural encoding multimodal 
function dimensional answer 
function dimensional answer 
consider dimensional function 
simple representation function appears 
changing variable time move local search diagonal 
looking dimension dimension parameter time point diagonal appears local optimum local search 
gradient information looks diagonal requires changing variables transforming ordinate system sampling search space expose gradient information 
winston classic ai text winston describes ridge problem points basic limitations simple hill climbing 
surprisingly problem received little attention local search community 
convergence local search unimodal functions shown natural encoding function unimodal gray encoding unimodal 
proven convergence time steep evolutionary computation volume number gray binary representations dashed lines connect gray encoded neighbors 
neighbors adjacent quadrants move away 
quadrant moves away 
est ascent local search linear dimensional bijective unimodal functions 
functions dimensional number optima real space number optima gray code natural encoding 
function bijection evaluation unique plateaus flat spots local search stuck 
proof looks adjacent quadrants search space 
key ideas proof illustrated 
gray code generates circuit critical neighbors 
neighbors reflecting folding search space reflection points constructing reflected gray code 
standard binary reflected gray code point neighbor differs bit 
point second neighbor position 
binary neighbor neighbor gray code reached flipping bit neighbor reached flipping second bit 
circuit exists traversed changing bits 
sketch proof convergence linear time unimodal dimensional functions whitley 

proof fills critical details requires explicit sampling 
search space function ir 
consider arbitrary intervals search space 
dimensional function range interval search space continuous region search domain point 
qi denote interval 
define partition search space set intervals qi qj qi 
qi qi denote adjacent intervals 
indices adjacent intervals start addition modulo 
wraps neighbor 
mainly concerned partition search space quadrants quadrants search space corresponding hyperplanes shown 
preliminary concepts apply arbitrary intervals 
function max qi return maximum value qi 
definition critical interval 
interval dimensional bijective function intervals indexed identify unique critical interval qi evolutionary computation volume number rowe whitley barbulescu 
watson max qi max qj 
immediately follows definition critical interval property 
qi critical exists nq qi np qi ni qi np ni nq 
lemma ir unimodal dimensional 
qi critical interval partition 
qi contains optimum neighboring intervals qi qi contains optimum 
furthermore exists neighboring interval qj qi qi qj proof qi qi results hold 
exists qj max qi qj adjacent interval 
recall neighbor 
think search space equivalent concatenation subfunctions 
monotonically increases left global minimum global maximum monotonically increases right global minimum global maximum 
consider point qj max qi 
function bijection associate points evaluation 
know max qj max qi follows global optimum lie points associated max qj max qi function unimodal 
global maximum function lie qi max qi occur interval qi function unimodal 
global maximum lies outside qj starting points associated max qj max qi function climb monotonically global maximum 
max qj max qi points outside qj qi worse max qi 
global maximum lies inside qj max qj global maximum 
case start point associated max qi functions climb monotonically global maximum 
points outside qj qi worse max qi 
corollary qi critical interval partition exists neighboring interval qj qi qj max qi intervals explicitly quadrants 
lemma qi interval corresponding quadrant exists points ni qi cyclic path 
point reachable moves gray encoding 
proof ri gray code reflection point neighbors ni ni 
neighbors equidistant neighbors equidistant neighbors equidistant 
construction entire search evolutionary computation volume number gray binary representations space folds reflection folds folds neighbor 
forms circuit denotes move hamming space 
theorem dimensional unimodal bijective function steepest ascent local search reflected gray code neighborhood function converges global optimum moves evaluations 
total number moves 
total number evaluation proof function bijection unique optimum single best point neighborhood 
step assume current point optimum 
current point optimum identified immediate neighbors left right gray code neighbors evaluating proves optimality 
search space broken quadrants 
start point ni know lemma part circuit neighboring points 
assume search starts quadrant qi neighbors ni evaluated 
case 
assume best neighbor inside qi 
mi represent point 
ni mi ni 
gray code neighbors ni outside qi ni ni 
case mi ni function unimodal 
know mi min max qi max qi max qi max qi means mi max qc critical quadrant qc 
note determination moving 
finding best move possible corollary implies quadrants strictly worse best move search space cut half 
case 
move point nj ni ni denote quadrant qj 
move ni evaluated 
assume best move inside qj 
move case exactly case 
case 
move second move required point ni 
know ni ni ni 
move inside qi 
moves case exactly case 
cases 
show local search gray encoding recursively decomposes search space eliminating half space moves 
reflected construction single bit set eliminates quadrants consideration 
bit need eliminated explicitly moves flipping eliminated bit produces inferior neighbor 
lemma proves eliminated quadrants adjacent 
quadrants quadrants eliminated bit set 
quadrants quadrants eliminated second bit set 
cases 
lemma lemma prove moves key bit implicitly fixed search space cut half 
implicitly describes recursive process defines new unimodal bijective dimensional unimodal function 
evolutionary computation volume number rowe whitley barbulescu 
watson search space reduced points global optimum automatically sampled verified 
provides necessary basis step reduction search space necessary inductive proof 
means maximum possible number neighborhood moves neighborhood evaluation having cost 
limitation dimensional unimodal functions restrictive 
generalize result various ways 
multiparameter separable function viewed composition real valued dimensional subfunctions 
real valued subfunction unimodal encoded bits specialized form steepest ascent hamming distance local search reflected gray code representation converge global optimum steps dimension 
dimensions exactly bits dimension note ql convergence bounded 
theorem sphere function xi denotes minimum steepest ascent local search bit hamming distance neighborhood reflected gray code representation converge global optimum steps 
directly follows proof dimensional case dimension independent unimodal 
empirical data proof obviously shows steepest ascent neighbors checked converge steps order total evaluations 
set experiments different unimodal sphere functions encoded varying number bits shows behavior consistent proof 
number steps steepest ascent local search needed reach optimum linear respect string length 
shown 
shows number evaluations steepest ascent order respect string length 
ascent 
best case ascent pick exactly neighbors selected steepest ascent number steps needed reach optimum 
worst case adjacent point real space chosen move number steps needed reach optimum 
linear time best case exponential time worst case little obvious happens average 
advantage ascent course multiple improving moves time neighborhoods evaluated 
davis random bit climber rbc ascent algorithm 
rbc randomized order bits checked 
bit tested order bits tested randomized 
randomization may important avoiding worst case behavior 
empirical data suggest convergence time ascent nearly linear 
rightmost graph shows empirical behavior ascent bit climbing algorithm appears bound log average 
fact better behavior characterizes number evaluations required steepest ascent 
variance steepest ascent rbc algorithms small seen graphs shown 
evolutionary computation volume number number steps steepest ascent number evaluations gray binary representations ascent steepest ascent leftmost graph shows number steps needed reach global optimum various sphere functions 
rightmost graph shows number evaluations needed reach global optimum various sphere functions regular steepest ascent ascent algorithm rbc 
rbc requires far fewer evaluations 
finding gray unimodal functions function unimodal natural encoding unimodal hypercube gray code 
functions unimodal hypercube 
number unimodal bijective functions constructed dimensional function sort points search ways place point 
point placed ways left right 
assume search space wraps 
position point determined 
construct examples unimodal functions reflected gray code 
define division interval form point contained divisions uniquely specified 
reflected gray code property division containing point division neighbor split division half points half neighbors half 
halves divisions point half evolutionary computation volume number rowe whitley barbulescu 
watson reflected neighbor half 
select threshold value 
start division split 
choose new threshold value 
assign fitness values randomly half 
repeat process half choosing new lower threshold 
repeat process recursively dividing set reach single point assign value lower 
functions defined unimodal gray space steepest descent algorithm find global minimum linear number steps 
obviously construction 
different functions unimodal solved linear number steps standard binary reflected gray code neighborhood 
example define thresholds randomly generating function scheme gives gray unimodal function create functions optimized efficiently 
take function know solved efficiently local search algorithm gray code 
gray code automorphism define fitness function equivalent encodings neighborhood structure means new function solved just efficiently local search methods 
example previously defined function automorphism defined swapping bit get new gray unimodal function optimized linear number steps 
functions illustrated 
evolutionary computation volume number gray binary representations fitness functions unimodal reflected gray encoding 
functions identical landscapes neighborhood structures equivalent local search optimize linear number steps 
long path problems functions unimodal reflected gray space local search algorithms solve efficiently 
example class long path problems problems unimodal number local steps required find optimum exponential respect 
functions correspond class functions set gray code unimodal real valued encoding 
badly multimodal 
consider construction horn 

path defined recursively 
path sequence search space 
path length construct new formula pr pr pr pr example path dimensional hypercube construct path hypercube shown 
recursive construction long path problems showing decomposition paths 
assign fitness values increase maximizing path 
point path gets fitness value path 
easy see path designed impossible take short cut point 
evolutionary computation volume number rowe whitley barbulescu 
watson th stage construction path length notice addition bridging point 
know 
solving recurrence gives string length increases step 
odd number see path length exponential 
formula constructing path shows close connection structure reflected gray code 
points left central bridge point quadrant points right third quadrant 
bridge point second quadrant 
level recursion structure imposed quadrant split points existing third quarters quadrant 
third quadrant similarly split 
recursive procedure gives rise fractal pattern 
splitting means step twice local optima previous step plus extra bridge point 
number local optima construction step recurrence path length 
holds construction step bridge point happens contiguous left side path 
value 

see number local optima exponential 
fact exactly half points path correspond local optima 
seen shows long path construction 
suggest long path problems somewhat unusual construction correspond functions highly multimodal real space 
shifting gray code representations section introduce shifting rana whitley mechanism changing set restricted gray codes effort escape local optima 
shifting conjunction simple hill climbing algorithm state art genetic algorithm 
algorithms evaluated test functions empirically demonstrated resistant simple hill climbing algorithms pose challenge genetic algorithms whitley 
results show shifting improves algorithms 
shifted gray codes reflected gray code 
define shifted code ck mod evolutionary computation volume number gray binary representations construction long path problems 
interpret problems reflected gray encodings functions unit interval 
number local optima maximizing increases exponentially string length 
obvious shifted code gray code 
shifting provides mechanism switching gray code way possible change number location local optima 
dimensional function single dimension multidimensional function gray codes form circuit 
circuit represents possible discretized inputs real valued function 
circuit shifted points pass points different reflections 
seen 
neighbors north south east west graph torus 
order reflection strings differ rd bit connects north south neighbors rows rows 
directional arrows show points move opposite directions shifting occurs neighbors flow past 
order reflection th bit differs north south connections rows toroidal north south wrap rows 
local optima pass shifted gray encoding optima collapse 
example positions neighbors integer mapping induced standard binary reflected gray code 
integer space shifted positions neighbors mapping 
local optima positions optima collapse search space shifted 
shift get equivalent code 
fact shift corresponds automorphism mask followed swapping bits 
means set shift codes divides equivalence classes size codes giving distinct neighborhood structures 
seen studying shift multiple leaves neighborhood structure unchanged 
numbers powers smaller shifts change neighbors 
note shift implies changes neighbors 
largest number neighbors change evolutionary computation volume number rowe whitley barbulescu 
watson hamming neighborhood integer mapping gray gray mapping shifted simple example shifting 
note integers associated corresponding positions hamming neighborhood 
neighbors arrows map surface real valued function 
points neighbors standard reflected gray code neighbors gray code shifted 
gray code 
numbers powers viewed combination large small shifts 
theorem gray encoding shifting result change exactly neighbors point search space 
proof consider arbitrary gray coding 
divide positions continuous blocks equal size starting position 
block contains exactly positions see 
consider arbitrary block arbitrary position exactly neighbors contained periodicity binary gray bit encodings ensures neighbors change shifting remaining neighbors contained blocks preceding respectively 
adjacency blocks change shifting neighbors adjacent blocks stay 
remaining neighbors contained blocks adjacent prove rest neighbors change 
consider block contains neighbor fundamental property reflected gray code reflection point exactly halfway pair neighbors 
neighbors outside block contained adjacent blocks reflection points separated positions 
shifting move closer reflection point moved exactly positions farther away reflection point see 
point new neighbor closer reflection point block reflection point location previous neighbor neighbor reflection point exactly impossible neighbors outside block contained adjacent blocks reflection points separated positions 
similar argument goes case shifting moves farther away reflection point moved closer 
previous neighbors neighbors shifting corollary theorem reflected gray code representation dimensional function parameter multidimensional function unique shifts 
exactly neighbors change 
evolutionary computation volume number shift 


gray binary representations shifting unwound representation gray codes circuit 
arbitrary position block arbitrary neighbor position block shifting neighbor moves block block bimodal objective functions suppose function bimodal respect natural encoding gray encoding local search gray encoding stuck non global optimum 
points better current point form interval containing global optimum 
call interval target move target interval able find global optimum local search 
question find shift representation current position neighbor theorem current point 
contain points points aim 
point neighbor encoding ck integer 
proof contains points find integer 
mod setting means points mod mod neighbors respect reflected gray code reflections center point 
neighbors respect ck 
theorem means shifts set guaranteed neighbor target interval 
generally theorem exists mod neighbor target encoding ck 
proof consider interval mod evolutionary computation volume number rowe whitley barbulescu 
watson point previous theorem neighbor encoding cj neighbor encoding ck mod 
set distinct shifted gray codes divides intervals quadrants size shift code partition induces neighbor target interval 
picking shift code random gives probability choosing shift enables search process continue 
counts shifts result neighbors created reflections point depending close target local optimum may shifts create neighbors reflecting points 
see chance finding shift enables search continue twice probability randomly finding point target interval 
alternative strategy local search stuck simply restart random point 
successful shift strategy depend relative sizes basins attraction optima 
assumption local optimum bimodal problem just ease understanding 
saw earlier lots shapes functions unimodal respect shifted gray code 
targets aim 
assume target contained points 
get neighbor able balance neighbors evenly side reflection point 
target contains just point optimum isolated guaranteed 
current point target number points interval odd points neighbors shift 
size possible 
algorithms test functions investigate utility incorporating shifting simple hill climbing algorithm rbc state art genetic algorithm chc 
shift values uniformly sampled set unique shifts 
test functions described whitley 
shown table associated variable domains 
test functions range simple separable functions easily solved hill complex non linear non separable functions 
rbc random bit climber davis descent hill climbing algorithm 
search begins random bit string proceeds testing hamming neighbors randomized order 
equal improving moves accepted 
search stuck local optimum re started new random bit string 
new random visitation sequence neighbors generated 
local optimum detected rbc representation shifted try escape local optimum 
search proceeds new bit string convergence re established 
types restarts soft hard 
soft re start merely changes representation changing current point search space 
hard re start search new random point search space 
depending experiment perform soft restarts hard re start 
evolutionary computation volume number gray binary representations hamming neighborhood bit string level translates neighborhood capable step altering single parameter value 
restriction suggests rbc perform separable test functions perform worse non separable non linear test functions may require simultaneous manipulation multiple parameters yield improvements evaluation function 
hypotheses supported experimental results 
table test functions described whitley 

xi rastrigin xi cos xi xi schwefel xi isin xi griewangk xi cos powell ef sin rana ef cos cos sin chc genetic algorithm eshelman maintains parent population size experiments 
chc randomly pairs members parent population reproduction 
paired reproduction permitted hamming distance parents greater threshold value resulting child population size 
crossover operator ensures child maximal hamming distance parents 
best individuals form parent population generation 
chc guarantees survival best individuals encountered search 
chc uses re start mechanism parent population remains unchanged number generations 
re start population containing copies best individual formed copy undergo extensive mutation bits 
shifting applied time chc converges 
best individual re encoded new randomly selected shift value 
selecting shift values general interested locating global optimum arbitrary multimodal real valued functions 
terms algorithm design question best method select value shifting 
corollary theorem indicates 
shown section values interval redundant multiple values collapse particular local optimum 
consider set shifts 
optimal value clearly depends function consideration 
analyze potential impact performance shifting apply rbc dimensional versions rastrigin griewangk schwefel test functions see table 
bit encodings rastrigin schwefel functions bit encoding griewangk function shift able collapse local optima bit encodings griewangk function barbulescu 
vary increments execute trials rbc test function soft restarts hard re start 
table report mean number evaluations trials required locate global optimum 
results evolutionary computation volume number rowe whitley barbulescu 
watson indicate particular value significant impact performance optimal value expected dependent test function 
test functions consider small values prevent selection values necessary collapse particular local optima 
priori identification optimal intractable 
consequently adopt conservative strategy uniform shifting subsequent experiments 
table mean number function evaluations trials locate global optimum rbc 
mean number evaluations optimal rastrigin griewangk schwefel experimental results discussion ran trials rbc chc test function allowing maximum evaluations run 
exception powell function dimension fixed dimensional versions test function variable encoded bits powell function bit encodings 
rana ef ef functions dimension versions constructed weighted wrap expansion method described whitley 
versions chc shifting considered 
tested rbc shifting addition versions soft restarts hard restarts denoted shift shift respectively 
results rbc chc reported tables respectively 
solved column indicates number times algorithm optimal solution total trials 
statistics solution quality number evaluations taken trials 
statistical comparisons algorithms tailed tests significance level 
rbc soft restarts table shift shifting yields statistically significant improvement solution quality number evaluations rastrigin schwefel ef test functions rana function improvement applies solution quality 
powell griewangk test functions statistically significant difference measure observed 
chc table shifting fails yield significant differences mean solution quality 
shifting significantly reduce number evaluations required rastrigin griewangk powell test functions 
substantially improving performance rbc chc significant performance differences algorithms exist 
increase number soft restarts rbc shift compare resulting performance chc 
rastrigin schwefel functions versions rbc shift shift chc global optimum trials 
functions separable 
statistical difference rbc shift chc required significantly fewer evaluations chc simpler problems 
evolutionary computation volume number gray binary representations table rbc results test functions shift attempts hard re start performed 
results averaged independent trials function evaluations 
functions minimized 
function experiment mean sol 
mean evals 
solved rastrigin shift shift shift schwefel shift shift shift griewangk shift shift shift powell shift shift shift ef shift shift shift rana shift shift shift soft restarts reduces variance rbc results 
performance improvement explained local optima shift 
soft restarts sample maximum possible unique shifts respectively 
sampling shifts increases chances collapsing particular local optimum 
explanation supported empirical evidence shift schwefel trials required hard restart find global optimum rastrigin trial required single hard re start 
griewangk function simplest non separable test function considered function easier parabolic dimensionality increased whitley 
intuitively highly parabolic structure easily solved hillclimbing algorithm 
chc significantly outperforms versions rbc number evaluations 
furthermore increasing number soft restarts resulted poorer rbc performance 
explain apparent anomaly examined shifting properties dimensional version griewangk function 
local optimum enumerated possible shifts recorded shifts able collapse local optimum 
best local optima shift global optimum 
addition local optima flank global optimum find global optimum initial starting point rbc attraction basin relatively small 
precision fixed bits shifting futile hard restarts way find global optimum 
powell ef functions performance rbc shift shift indistinguishable increase number trials identifying global optimum ef function statistical artifact strongly outperformed chc 
run chc rbc solved rana function optimality rbc shift significantly outperformed rbc shift terms solution quality 
chc slightly outperform rbc shift difference minimal evolutionary computation volume number rowe whitley barbulescu 
watson table chc results test functions shifting attempt time algorithm restarts 
results averaged independent trials function evaluations apiece 
functions minimized lowest mean solution lowest mean number evaluations bold 
function experiment mean sol 
mean evals 
solved rastrigin shift shift schwefel shift shift griewangk shift shift powell shift shift ef shift shift rana shift shift statistically significant 
result particularly interesting rana function proved difficult chc 
results demonstrate deeper understanding shifting significantly improve performance rbc 
looking solution quality number evaluations rbc shifting statistically outperforms chc rastrigin schwefel separable functions nearly equals performance chc nonlinear non separable problems griewangk rana 
powell ef chc outperforms rbc 
developing representation key part search 
long questions evolutionary computation community relationship gray code representations standard binary real valued representations 
number basic results related bit representations 
concept equivalent encodings important resulting equivalence classes impact behavior different search algorithms different ways 
presents results related gray codes 
convergence proofs special classes unimodal functions local search 
results significance evolutionary computation community reasons 
relationship local optima hamming space dynamic behavior genetic algorithms example defined 
second convergence proofs motivate construction hybrid genetic local search algorithm proven effective regular rbc steepest ascent hybrids whitley 
different gray codes explored 
dynamic representations alternative mechanisms escape local optima mechanisms include local search restarts tabu search simulated annealing 
shifting uses multiple gray code representations escape local optima 
new upper bounds number unique gray code neighborhoods shifting established 
characterized neighborhood structures similar shifted gray codes 
augmenting simple hill climber dynamic representation scheme achieve improved performance evolutionary computation volume number gray binary representations test functions difficult simple hill climbing algorithm challenge chc state art genetic algorithm 
acknowledgments jonathan rowe funded university birmingham pilot research 
support supported national science foundation number iis air force office scientific research air force materiel command usaf number 
government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation 
barbulescu watson whitley 

dynamic representations escaping local optima 
proceedings seventeenth national conference artificial intelligence 
ehrlich reingold 

efficient generation binary reflected gray code applications 
communications acm 
davis 

order genetic algorithms graph coloring problem 
davis editor handbook genetic algorithms pages van nostrand reinhold 
eshelman 

chc adaptive search algorithm safe search engaging nontraditional genetic recombination 
rawlins editor pages morgan kaufmann 
harary 

automorphism group hypercube 
journal computer science 
horn goldberg deb 

long path problems 
schwefel 
editors parallel problem solving nature pages 
radcliffe surry 

fundamental limitations search algorithms evolutionary computing perspective 
van leeuwen editor lecture notes computer science springer verlag 
rana whitley 

bit representations twist 
ck editor proceedings seventh international conference genetic algorithms pages 
morgan kaufmann 
whitley 

functions permutations regarding free lunch walsh analysis summary statistics 
schoenauer editors parallel problem solving nature pages springer 
whitley garrett watson 

genetic quad search 
gecco 
pages 
springer 
whitley rana 

representation search genetic algorithms 
proceedings fourteenth national conference artificial intelligence 
evolutionary computation volume number rowe whitley barbulescu 
watson whitley barbulescu watson 

local search high precision gray codes 
foundations genetic algorithms 
morgan kaufmann 
whitley mathias rana 

building better test functions 
eshelman editor proceedings sixth international conference genetic algorithms morgan kaufmann 
whitley mathias rana 

evaluating evolutionary algorithms 
artificial intelligence journal 
winston 

artificial intelligence nd ed 
addison wesley 
wolpert macready 

free lunch theorems search 
technical report sfi tr santa fe institute 
wolpert macready 

free lunch theorems optimization 
ieee transactions evolutionary computation 
evolutionary computation volume number 
