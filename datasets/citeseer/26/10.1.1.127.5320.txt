lisp symbolic computation international journal kluwer academic publishers manufactured netherlands organizing programs classes david ungar craig chambers bay wei chang urs lzle self self stanford edu computer systems laboratory stanford university stanford california 
organizational functions carried classes accomplished simple natural way object inheritance classless languages need special mechanisms 
single model dividing types prototypes traits supports sharing behavior extending replacing representations 
natural extension dynamic object inheritance model behavioral modes 
object inheritance provide structured name spaces known objects 
classless languages express class encapsulation 
stylized uses object inheritance instantly recognizable idioms extend organizing principles cover wider range programs 
researchers proposed object models prototypes delegation classes static inheritance 
proposals concentrated explaining prototype languages allow flexible arrangements objects 
flexibility certainly desirable felt large prototype systems difficult manage lack organizational structure normally provided classes 
organizing large object oriented system requires capabilities 
foremost ability share implementation state instances data type related data types 
ability define strict interfaces data types hide protect implementation useful organizing generously supported national science foundation presidential young investigator ccr sun microsystems ibm apple computer cray laboratories tandem computers ncr texas instruments dec author address sun microsystems garcia avenue mountain view ca 
ungar chambers chang lzle large systems 
ability global names refer data types categorize large name spaces structured parts easier browsing important managing huge number objects exist large object oriented system 
argue programs languages classes able accomplish tasks just programs class languages 
particular show organizational functions carried classes accomplished natural simple way classless languages organizational functions expressed objects inheritance need special mechanisms layer data structures additional flexibility prototype languages natural extension possibilities provided class systems exploiting additional flexibility need lead unstructured programs 
ideas lessons learned ways organize code self dynamically typed prototype language 
accordingly illustrate ideas examples self ideas applied classless languages providing similar inheritance models 
sharing programming object oriented language largely revolves specifying sharing relationships code shared instances data type code shared similar data types 
intra type sharing classes traits objects principal activity object programming defining new data types 
define simple data type programmer needs specify state behavior specific instance data type state behavior common shared instances type 
example way define simple polygon data type specify polygon instance contains list vertices polygons share operation draw 
typical class language class object defines set methods class variables shared instances class set instance variables specific instance 
example polygon data type implemented class polygon defines draw method specifies instances single instance variable named vertices polygon metaclass contain new method create new polygon instances organizing programs classes instance variables vertices methods draw draw display class vertices list points polygon traits draw copy polygon instance 
data types class language 
draw display return copy receiver prototypical polygon parent vertices vertices list points data type prototype traits 
data types classless language 
polygon class see 
initialize new instance list vertices polygon class define wrapper method named vertices just assigned argument vertices instance variable 
wrapper method required languages smalltalk limit access object instance variables object 
classless language polygon data type defined similarly 
prototypical polygon object created instance polygon type see 
object contains slots assignable data slot named vertices corresponding vertices assignment slot constant parent slot pointing object contains draw method copy method 
smalltalk trademark parcplace systems data slots self may assignable constant 
data slots assignable virtue associated assignment slot changes data slot contents invoked 
assignment slot name constructed appending colon data slot name 
parent slots indicated self syntax asterisks slot name 
parent slots figures indicated asterisks 
ungar chambers chang lzle vertices slot prototype initialized convenient default list vertices list points defining triangle making usable serving programming example 
new polygons created sending copy message existing polygon prototypical polygon clones shallow copies receiver polygon copies internal vertex list 
prototype slots contain default values clones prototype automatically initialized values 
particular parent object shared new polygon providing common behavior polygons system 
call shared parent objects traits objects 
traits objects classless language provide sharing capability classes just class language making changes behavior instances type simple common behavior factored single shared object 
general data types may defined classless language dividing definition type objects prototypical instance type shared traits object 
prototype defines instance specific aspects type representation type traits object defines common aspects instances type 
special language features need added support traits objects traits object regular object shared instances type normal object inheritance 
traits objects regular objects may contain assignable data slots shared instances data type providing equivalent class variables 
classless languages gain descriptive power class languages dividing implementation data type separate objects 
data type concrete type instances data type created traits object initial prototype object defined 
type existing simply define reusable behavior shared types prototypical instance need defined 
alternately instance particular data type unique objects nil true false traits object need separated object 
traditional class languages implicitly specify shared behavior format class instances extra language mechanisms distinguish concrete singleton data types corresponding loss descriptive organizational power 
inter type sharing subclasses refinements object oriented languages inheritance support differential programming allowing new data types defined differences existing data types 
implementor new data type may specify type equivalent combination existing types possibly additions changes 
example filled polygon type identical polygon type organizing programs classes drawing filled polygons different drawing unfilled polygons filled polygon instance needs extra state hold fill pattern 
typical class languages class may defined subclass classes 
methods new class union methods superclasses possibly methods added changed instance variables new class union instance variables superclasses possibly instance variables added 
example filled polygons implemented class subclass polygon class see 
class overrides draw method specifies additional instance variable named filled polygon instances vertices instance variable automatically provided subclass polygon 
initialize new instance fill pattern class define wrapper method named assigned argument instance variable 
filled polygons defined similarly language classes 
new filled polygon traits object created refinement child existing polygon traits object see 
traits object defines draw method 
complete definition new data type prototypical object created inherits filled polygon traits object 
object contain vertices data slot data slot plus corresponding assignment slots 
revise representation avoid unnecessary repetition vertices data slot subsection 
general new data type classless language may defined terms existing data types simply refining traits objects implementing existing data types new traits object child existing traits objects 
object inheritance specify refinement relationships needing extra language features 
representation sharing instance variable extension data parents defining data type extension pre existing data types frequently instance specific information existing data type combined extra information particular new data type construct instance specific information new data type 
example filled polygon instance needs polygon information list vertices plus new filled polygon specific information fill pattern 
ideally new data type wouldn need repeat instance specific information inherits existing data types share information enhance malleability resulting system changing data type representation causes data types inherit changed data type updated automatically 
ungar chambers chang lzle instance variables methods class vertices list points superclass instance variables methods class vertices list points fill pattern vertices draw draw display polygon instance draw parent vertices vertices list points fill pattern filled polygon instance polygon class class draw fill display assign variable 
differential programming class language subclassing implicit representation extension 
polygon traits draw copy prototypical polygon parent vertices list points vertices prototypical filled polygon filled polygon traits draw display return copy receiver parent draw draw fill display differential programming refining traits objects 
differential programming classless language 
organizing programs classes prototypical polygon parent vertices list points vertices prototypical filled polygon fill pattern polygon traits draw copy filled polygon traits draw display return copy receiver parent draw draw fill display copy copy data parent representation extension data parents 
representation extension classless language 
class languages 
subclass defined automatically inherits instance variable lists superclasses instance variables specified subclass interpreted extensions superclasses instance variables 
feature illustrated example class extends instance variables polygon superclass instance variable see 
classless language multiple inheritance provide similar functionality data parents 
manually repeating data slot declarations prototypes parent data types done implementation filled polygons new prototype may share representation parent data types inheriting 
better way implement filled polygons define prototype child traits object polygon prototype object see 
new copy method defined traits object copy receiver filled polygon data parent polygon object instance ungar chambers chang lzle filled polygon data type implemented objects containing instance fill pattern containing list vertices 
data parents explicitly implement representation extension mechanism implicit traditional class languages 
data parent objects parents data slots defined data parent transparently accessed defined receiver object defining explicit forwarding methods 
relying ability inherit state initialize new object parents computed values special language mechanisms needed concatenate representations 
problem class representation extension surfaces languages multiple inheritance 
superclasses define instance variables name subclass contain different instance variables superclasses instance variables merged shared instance variable subclass 
programming situations may correct keep different instance variables situations may necessary share single instance variable 
different class languages support multiple inheritance answer difficult question differently languages provide programmer option doing cost extra language complexity :10.1.1.26.9545
classless languages don face dilemma 
prototypical instance data type defined explicitly programmer complete control type representation 
new type contain version data slot prototype just contains data slot 
versions need maintained parent data type data parents may keep versions data slots name 
representation sharing class languages automatically extend representation subclass include superclasses instance variables 
automatic extension may desired 
example application want define rectangle data type subtype polygon data type 
representation rectangle numbers list vertices draw routine optimized special case 
class languages define rectangle class subclass polygon class rectangle class extended automatically polygon class vertices instance variable 
fix problem additional class instance variables defined common superclass polygon rectangle behavior common polygons moved concrete self includes message lookup rule sender path rule automatically disambiguates internal accesses data slots 
organizing programs classes polygon class class see 
creates problem code polygons longer access vertices instance variable polygon instances 
instances polygon subclasses know vertices instance variable 
possible solution define wrapper methods access polygon class vertices instance variable class rectangle class define method construct list vertices numeric instance variables 
avoid problems altering representation class subclass leaf classes concrete define instance variables 
nonleaf classes defining instance variables code written invoke wrapper methods explicit variable accesses 
programming style support reuse code allowing representation subclass different representation superclass 
sacrifice ability share representation information concatenating instance variables class ancestors require definition wrapper methods access instance variables 
programs awkward write modify 
prototype languages change representation refinements easily 
rectangle example prototypical rectangle object contains data slots parent slot pointing rectangle traits object doesn include data parent slots see 
including data parent prototypical polygon object implementation explicitly deciding base representation rectangles representation polygons 
rectangle traits object overrides polygon traits object draw method tuned drawing rectangles representation specific rectangles 
preserve compatibility polygons rectangle traits object defines vertices method construct list vertices numbers define rectangle 
particularly convenient self vertices message sent method polygon traits object access vertices data slot polygon receiver invoke vertices method rectangle receiver extra wrapper methods needed vertices data slot modifications invoking methods 
convenience afforded self uniform messages access state behavior adopted classless class languages achieve similar flexibility 
trellis owl class language accesses instance variables messages able change representation subclass overriding instance variables inherited superclasses methods defined subclass 
implementation data type classless language specify extend parent types representations forming new type representation including data parents refer parent types repre ungar chambers chang lzle superclass inst vars methods class methods vertices access vertices variable polygon class vertices vertices vertices class vertices list points access vertices variable assign vertices variable polygon instance superclass instance variables methods rectangle class top left right bottom draw optimized draw vertices construct list inst vars class top top coord left left coord right right coord bottom bottom coord rectangle instance 
representation modification class language 
sentations filled polygon example rectangle example 
natural structured programming styles fostered classless languages 
class languages typically difficult time handling cases differ strict representation extension 
mentioned trellis owl notable exception 
languages powerful metaclass facilities clos able define metaclasses subclasses inherit instance variables superclasses solution complex probably verbose simple solution classless languages 
organizing programs classes prototypical polygon parent vertices vertices list points rectangle traits parent draw draw rectangle efficiently vertices construct list coords prototypical rectangle parent left left right right top top bottom bottom polygon traits draw copy draw display return copy receiver representation modification data parents 
representation modification classless language 
dynamic behavior changes changing instance class dynamic inheritance behavior instance data type divided different modes behavior implementation state instance determining mode behavior 
example boxed polygon straight lines different drawing methods smoothed polygon splines 
situations distinction behavior may completely internal implementation data type reflecting different ways representing instance depending current past states object 
self reorganizing collection radically different representations depending access patterns insertion frequent indexing external interface collection remains unchanged 
common way capturing different behavioral modes include flag instance variable defining behavior mode testing flag ungar chambers chang lzle method depends behavior mode 
obscures code behavior mode merging behavior modes shared methods sprinkled tests case statements 
code analogous programs simulating object oriented method dispatching tests case statements determine type receiver message surprisingly flag tests behavior modes suffer problems flag tests receiver types hard add new behavior modes modifying lots code error prone write difficult understand particular mode code intermixed code behavior modes 
better way implementing behavior modes define mode special subtype general data type method dispatching inheritance eliminate flag tests 
example collection data type refined empty collection data type non empty collection data type inheritance relate types 
behavior mode instance may change state changes empty collection non empty element added 
correspond class language changing object class dynamically prototype language changing object parent dynamically 
class languages allow object change class face hard problems 
class object implicitly specifies representation happens object changes class specifies different representation 
object restricted change class identical representations wouldn allow different behavior modes different representations 
classless languages hand naturally extended handle dynamically changing behavior modes allowing object parents change run time object inherit different behavior mode traits objects depending state 
representations behavior modes differ data parents behavior mode specific data slots changing behavior mode require changing traits parent data parent simply having behavior mode data parent inherit directly behavior mode traits object changing just data parent 
self dynamic inheritance comes free basic object model 
data slot may parent slot data slot may corresponding assignment slot parent slot may assignable object parents changed simply assigning 
polygon example boxed draw method draw method defined polygon traits object smooth draw method treat vertices polygon spline control points 
polygon prototype parent slot assignable alternate boxed polygon traits object smooth polygon traits object see 
organizing programs classes boxed polygon traits behavior modes naturally implemented classless languages dynamic inheritance choose small set parents 
style programming compromise structure system contrary structure organization system clearer separating various modes behavior 
contrast close coupling class representation prevent class languages extended naturally handle behavior modes 
encapsulation polygon traits parent draw draw boxed polygon copy return copy receiver prototypical polygon parent parent vertices vertices list points smooth polygon traits parent draw draw smooth polygon multiple behavior modes dynamic inheritance 
multiple behavior modes classless language 
languages user defined data types usually provide means data type hide attributes types 
encapsulation may specify external interface abstraction unaffected internal implementation changes improvements isolating dependencies data type clients 
encapsulation may protect local state implementation data type external alterations violate implementation invariant 
encapsulation improve structure organization system identifying public interfaces ungar chambers chang lzle remain unaffected implementation changes allowing implementation preserve internal invariants 
existing encapsulation models objects types 
languages object encapsulation smalltalk trellis owl eiffel accessible private members receiver languages type encapsulation private members instance type accessible methods defined type 
type encapsulation significantly flexible supporting binary methods need access private data arguments initialization methods need access initialize private state newly created objects 
receiver encapsulation situations require initialization methods wrapper methods external public interface type largely defeating purpose encapsulation place 
classless languages explicit classes types appear type encapsulation impossible support severely weakening encapsulation provided language 
surprisingly self visibility rules support form type encapsulation 
method may access private slots descendants ancestors method defined traits object may access private slots instances trait clones prototypes inheriting traits object just methods defined class may access private members instances class subclasses 
effect traits object defines type descendant objects considered members type 
example polygon example polygon prototype object vertices slot declared private slot 
prevent outside objects modifying polygon list vertices allow copy method defined polygon traits object send vertices method new copied polygon object new object descendant polygon traits object 
similarly assignment slots rectangle objects marked private prevent unwanted external modification 
class prototype languages may provide features encapsulation type encapsulation 
features dependent individual languages language includes classes 
naming categorizing system structured programs name known objects data types programmers find objects types 
objects eiffel includes selective export clauses allow object encapsulation extended type encapsulation particular members 
organizing programs classes globals nil true false lobby lobby globals prototypes traits prototypes polygon rectangle list traits polygon rectangle list integer boolean 
name spaces global 
object inheritance support tasks explicit support classes environment structures 
naming objects global variables name spaces normal parent programs need refer known objects different places system 
example data type may need referenced places order create new instances type define subtypes 
class languages associate unique name class may uttered program refer class normal instance objects explicit names 
classless language prototypes traits objects need globally accessible clone new objects define new refining traits objects objects implemented regular objects internal names 
classless languages normal object inheritance may define name space objects sole function provide names known objects 
name object name space simply name slot refers object 
object inherits name space object may refer known objects defined name space sending message accesses appropriate slot name space object 
scope name space set objects inherit 
designers eiffel encourage similar strategy handle shared possibly global constants different language mechanisms handle global names class names 
self approach just concise global variables state known objects may accessed messages defining wrapper functions messages sent self written self keyword omitted 
polygon really message sent self accesses data just concise global variable access 
ungar chambers chang lzle lobby globals prototypes traits shapes prototypes polygon rectangle prototypes shapes collections illustrates name spaces part inheritance graph self system 
lobby object root inheritance graph objects inherit expressions typed self prompt evaluated lobby self 
prototypes parent object inherited objects provides succinct names prototypes standard data types 
traits object contains slots naming traits objects system typically name name data type prototypical instance 
example expression polygon names polygon prototype expression traits polygon names polygon traits object 
case prototypes name space object inherited lobby polygon yields contents polygon slot name space object second case sending traits lobby gives traits name space object sending polygon object gives polygon traits object 
organizing names categories collections prototypes list array traits shapes collections system normal parent 
categorizing name spaces 
large flat name spaces globals convenient programs awkward programmers 
systems provide features help organize name spaces smaller categories names break name spaces chunks 
example smalltalk environment supports level structure browsing classes dividing classes class categories 
classless systems name space objects similarly broken categories subdividing name spaces multiple parents 
example organizing programs classes integer traits parent arithmetic comparing functions addition subtraction division factorial fibonacci 
categorizing traits objects 
factorial function fibonacci function prototypes name space object broken name space subobjects kind prototype 
original prototypes name space object contains parent slots referring name space subobjects name slot name category 
composite name spaces behave just flat name space point view program referring global objects categories parents original name space object 
example message polygon yield prototypical polygon name space broken categories 
name spaces structured multiple objects programmer may browse facilities available browsing objects slot names object structure locate objects interest understand organization system 
composite name spaces may number levels structure need balanced categories may 
single object may categorized different ways simultaneously simply defining slots multiple categories refer object 
flexibility natural consequence normal objects categorization 
global variables name spaces need broken programmers 
individual data types sort name space methods name spaces may large require categorization 
smalltalk environment provides level structure organizing methods class method categories 
classless languages techniques organizing large name space objects may applied organize large traits objects 
traits object may refer parent subobjects define category slots traits object equals greater ungar chambers chang lzle name parent slot name subobject category see 
composite traits objects extend number levels structure 
extensional vs intensional names categorization name space objects message passing access global objects object name sequence message sends needed reach 
call extensional name derived structure system 
languages internal class names hand intensional names classes explicit names programmer may related structure system 
similarly categorizing name spaces traits objects object structure extensional categorization browser data structures describe categorization classes methods intensional categorization 
extensional names number advantages intensional names extra language environment features needed support extensional names categories 
extensional names additional interpretations expressions evaluate named object may program access object paths reach named object may browser navigate object 
data structures defining intensional names programmers inconsistent global variable names programs 
example internal names classes data structures environment find class subclasses incorrect global variable referring class renamed inheritance hierarchy changed updating browser data structures 
inconsistency exist extensional names derived actual structure system 
restriction associated extensional names legal expressions language object name described object structure 
restriction problem system feel advantages extensional naming intensional naming important 
classes necessary structure objects provide traits objects provide behavior sharing facilities instances refinements encapsulation mechanisms provide type encapsulation needing explicit types classes structured name space objects provide names programs people browse 
traits objects name space objects organizing programs classes different objects stylized idiom instantly recognizable programmer 
languages classes structure programs languages classes 
additionally certain properties traditional class systems conspire hinder kinds useful structures handled naturally classless systems 
class implicitly extends superclasses representations hard define subclass alters representation defined superclasses 
classless languages define type representation explicitly prototype objects able implement representation extension representation alteration naturally 
representation object class system tied object class difficult implement dynamic behavior modes 
classless languages may dynamic inheritance structured way implement behavior modes natural extension static inheritance 
languages classes structure programs better languages classes 

bobrow demichiel gabriel keene kiczales moon common lisp object system specification 
published sigplan notices 

borning classes versus prototypes object oriented languages 
proceedings acm ieee fall joint computer conference 

chambers ungar customization optimizing compiler technology self dynamically typed object oriented programming language 
proceedings sigplan conference programming language design implementation 
published sigplan notices 

chambers ungar lee efficient implementation self dynamically typed object oriented language prototypes 
oopsla conference proceedings 
published sigplan notices 
lisp symbolic computation 

chambers ungar chang lzle parents shared parts objects inheritance encapsulation self 
lisp symbolic computation 

goldberg smalltalk interactive programming environment 
addison wesley reading ma 
ungar chambers chang lzle 
goldberg robson smalltalk language implementation 
addison wesley reading ma 

lalonde designing families data types exemplars 
acm transactions programming languages systems 

lalonde thomas pugh exemplar smalltalk 
oopsla conference proceedings 
published sigplan notices 

lee object storage inheritance self prototype object oriented programming language 
engineer thesis stanford university 

lieberman prototypical objects implement shared behavior object oriented systems 
oopsla conference proceedings 
published sigplan notices 

schaffert cooper trellis object environment language manual version 
dec tr digital equipment hudson ma 

schaffert cooper kilian trellis owl 
oopsla conference proceedings 
published sigplan notices 

stein delegation inheritance 
oopsla conference proceedings 
published sigplan notices 

stein lieberman ungar shared view sharing treaty orlando 
kim editors object oriented concepts applications databases addison wesley reading ma 

stroustrup programming language 
addison wesley reading ma 

stroustrup evolution 
usenix workshop proceedings 

ungar smith self power simplicity 
oopsla conference proceedings 
published sigplan notices 
lisp symbolic computation 
