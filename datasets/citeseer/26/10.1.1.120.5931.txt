science computer programming april revised basic polymorphic typechecking luca cardelli bell laboratories murray hill nj current address dec src lytton ave palo alto ca polymorphic means forms 
related programming languages refers data programs types operate types 
arbitrary ways programs types interested particularly orderly form polymorphism called parametric polymorphism 
property programs parametric respect type identifiers 
major ways achieving parametric polymorphism conceptually related pragmatically different explicit implicit polymorphism 
parametric polymorphism called explicit parametrization obtained explicit type parameters procedure headings corresponding explicit applications type arguments procedures called 
case parametric polymorphism reduces notion having parameters type type necessarily adopting notion type type type 
definition polymorphic identity explicit type parameters fun stands abstraction application integer boolean id fun type fun id int id bool true parametric polymorphism called implicit type parameters type applications admitted types contain type variables unknown determined types 
procedure parameter type variable term containing type variables type procedure applied arguments different types 
implicit version polymorphic identity type variable application integer boolean 
id fun id id true page considerable interplay theoretical practical explicit implicit polymorphism understanding help understanding 
largely concerned implicit polymorphism important dedicate rest section relationships kinds parametric polymorphism 
implicit polymorphism considered abbreviated form explicit polymorphism type parameters applications omitted rediscovered language processor 
omitting type parameters leaves type denoting identifiers unbound precisely type variables 
omitting type arguments requires type inference recover lost information 
fact implicit polymorphism totally omit type information interpreting resulting programs having type variables associated parameters identifiers 
programs appears type free rigorous type checking performed 
appealing properties implicit polymorphism particularly appealing interactive systems na users 
type free definition polymorphic identity type information omitted 
page id fun explicit polymorphism expressive type programs typed implicit polymorphism verbose 
practice explicit polymorphism may want omit type information creates grey region fully explicit fully implicit polymorphism 
grey region type inference techniques implicit polymorphism useful reason studying implicit polymorphism context explicit polymorphism 
example reasonable compromise adopt explicit style function declarations implicit style function applications inference recover missing information id fun type fun id id true implicit polymorphism understood right semantic levels 
sense ambiguous implicitly polymorphic program may correspond different explicitly polymorphic programs 
ambiguity critical extensions basic type system noticeably presence side effects 
critical ambiguities arise context understanding relations implicit explicit polymorphism may necessary extending implicit polymorphic systems certain ways 
bit history polymorphic typing programs envisioned strachey lecture notes fundamental concepts programming languages strachey contains notation terminology today 
polymorphic types known type schemas combinatory logic curry 
extending curry collaborating hindley introduced idea principal type schema general polymorphic type expression showed combinatorial term type principal type hindley 
doing result robinson existence general unifiers unification algorithm robinson 
results contained polymorphic typechecking including basic algorithms 
existence principal types means type inference algorithm compute unique best type program unification perform computation 
results immediately influence programming language community theoretical setting 
influenced strachey independently hindley milner rediscovered ideas context lcf proof generation system gordon included version ml language milner 
introduced crucial extension hindley notion generic non generic type variables essential handling declarations polymorphic functions 
milner implemented practical polymorphic typechecker showed type system sound milner 
milner damas proved principal type property extended system damas implies type system decidable 
minor refinements state art exposed rest 
style polymorphic typechecking soon adopted hope burstall incorporated functional languages 
initial development ml side effects type system unsafe gordon 
resolved ad hoc way situation improved damas smooth merging side effects implicit polymorphic typechecking considered open problem 
theoretical followed 
coppo showed define coherent type system flexible ml coppo type system undecidable 
ideal model types macqueen model directly embodies idea implicit polymorphic types roots scott milner original 
explicit polymorphism story see bruce extensive treatment cardelli examples 
relations implicit explicit polymorphism actively investigated see example mccracken 
page pragmatic motivation parametric polymorphic type systems share algol properties compile time checking static typing treatment higher order functions flexible ability define functions uniformly arguments types 
polymorphism languages comes interaction contrasting programming language design goals static typing reusability 
static typing ability determine absence certain classes run time faults static inspection program 
static typing firmly established fundamental tool building large highly structured reliable software systems 
reusability ability write routines open ended collection applications particular may want write routines reused new data types defined 
reusability important aid building large programs helps defining abstractions leads better system structuring 
design goals contrast static typing tends prevent reusability reusable programs easy check statically 
pascal routine sort integers generalized sort strings ordered sets pascal type system allow parametrize type ordered sets 
hand lisp routine sort integers reused different kinds ordered sets misused just data structure unpredictable results 
polymorphic type systems try reconcile goals providing safety statically typed languages flexibility untyped languages 
discuss milner polymorphic typechecking algorithm proved successful sound efficient supports rich flexible type system 
great progress polymorphic languages feature remains unique milner algorithm ability infer types absence type declarations 
feature comes free 
attempt deal programs reused types algorithm searches best type program 
best type independent type declarations reduce generality type 
property milner algorithm particularly suitable interactive languages ml interactive compiled language 
interactive users rarely bother writing type information automatically inferred checked 
strongly contributes ml feel care free quick turnaround language wrongly associated interpretive untyped languages 
pragmatics polymorphic typechecking far restricted small group people 
published description algorithm milner technical oriented theoretical background 
hope making algorithm accessible larger group people implementation form modula program close lcf hope page ml gordon burstall milner 
clarity preferred efficiency implementation reasonably efficient quite usable practice typechecking large programs 
basic cases typechecking considered extensions common programming language constructs fairly obvious 
major non trivial extensions known far discussed concern overloading data types exception handling updatable data labeled record union types 
extensions studied 
views typing system type equations type inference system attempt relate informally implementation 
simple applicative language deal ml directly full size programming language considered simple typed calculus constants constituting considered kernel ml language 
evaluation mechanism call name callby value immaterial purpose typechecking 
concrete syntax expressions ide identifiers exp expressions decl declarations fun stands 
identifiers declared decl distinct 
corresponding syntax types exp decl program appendix parsers printers provided 
exp ide exp exp exp fun ide exp exp exp decl exp exp decl ide exp decl decl rec decl decl data types introduced language simply having predefined set identifiers initial environment way need change syntax importantly typechecking program extending language 
example program defines factorial function applies zero assuming initial environment contains integer constants operations page page rec factorial fun zero succ times factorial pred factorial types type type variable standing arbitrary type type operator 
operators int integer type bool boolean type nullary type operators 
parametric type operators function type cartesian product type take types arguments 
general forms operators type function type pair values replaced arbitrary types give specialized function pair types 
types containing type variables called polymorphic types containing type variables monomorphic 
types conventional programming languages pascal algol monomorphic 
expressions containing occurrences type variable express contextual dependencies case domain codomain function type 
typechecking process consists matching type operators instantiating type variables 
occurrence type variable instantiated occurrences variable instantiated value legal instantiations int int bool bool contextual instantiation process performed unification robinson basis polymorphic typechecking 
unification fails trying match different type operators int bool trying instantiate variable term containing variable circular structure built 
situation arises typechecking self application fun considered illegal 
trivial example typechecking 
identity function id fun type maps type 
expression id type int matched domain type id yielding int int specialized type id context 
type id codomain type id int context 
general type expression determined set type combination rules language constructs types primitive operators 
initial type environment contain primitives booleans integers pairs lists function type operator cartesian product list list operator true false bool int succ pred int int zero int bool pair fst snd nil list cons list list hd list tl list list null list bool type list type homogeneous list elements type 
type length describing typechecking algorithm discuss type simple recursive program computes length list rec length fun null succ length tl type length list int polymorphic type length lists kind 
way deduce type described ways 
principle typechecking done setting system type constraints solving respect type variables 
practice typechecking done bottom inspection program matching synthesizing types proceeding root type expression computed type subexpressions type constraints imposed context type predefined identifiers known contained initial environment 
deep property type system typechecking algorithm order examine programs carry matching affect final result solves system type constraints 
system type constraints length null list bool tl list list int succ int int null bool succ length tl null succ length tl null null page tl tl length tl length tl succ length tl succ length tl null succ length tl fun null succ length tl length fun null succ length tl lines express constraints predefined global identifiers known 
conditional construct imposes result test boolean branches conditional type type conditional expression 
function applications program determine case function symbol functional type argument type domain function result type codomain function 
fun expression type parameter type body type 
definition construct imposes variable defined length type definition 
typechecking length consists verifying system constraints consistent imply int bool ii solving constraints respect 
expected type length list int inferred follows page list int considerably needed show completely unconstrained system consistent 
typechecking algorithm described section systematically performs functioning simple deterministic theorem prover systems type constraints 
bottom derivation type length closer typechecking algorithm really consistency constraints absence type errors checked process null bool bool list int int tl list list list length tl list succ length tl int int null succ length tl int fun null succ length tl list int list int length list int list int note recursion taken care types instances length program definition recursive function call compared 
typechecking basic algorithm described follows 
case 
new variable introduced fun binder assigned new type variable meaning type determined context occurrences 
pair stored environment searched time occurrence yielding intervening instantiation type occurrence 
case 
conditional component matched bool branches unified order determine unique type expression 
case 
abstraction fun type inferred context associated new type variable 
case 
application type unified type type new type variable 
implies type function type domain unifiable instantiation returned type application 
order describe typechecking expressions variables introduced binders need introduce notion generic type variables 
consider expression fun pair true ex milner type system expression typed algorithm described produce type error 
fact occurrence determines type int page second occurrence determines type bool unified 
type variables appearing type fun bound identifier called non generic example shared occurrences instantiations may conflict 
try find typing ex example assigning compute correctly situations ex fun result pair 
typing unsound general example succ type matches accepted argument ex wrongly applied true 
sound extensions milner type system type ex scope discussion 
basic problem typing heterogeneous occurrences fun bound identifiers 
forbidding occurrences turns tolerable practice expressions ex extremely useful necessary different mechanism provided 
going try better typing heterogeneous occurrences identifiers 
consider page fun ex pair true essential able type previous expression polymorphic function applied distinct types context making polymorphism quite useless 
better position ex know exactly information deal separately occurrences 
case type type variables occur type bound identifiers occur type enclosing fun bound identifiers called generic property able assume different values different instantiations bound identifier 
achieved operationally making copy type distinct occurrence making copy type careful copy nongeneric variables shared 
expression example illegal ex non generic type propagates fun ex pair true unsound accept expression type consider applying succ bound 
definition generic variables type variable occurring type expression generic respect iff occur type binder fun expression enclosing note type variable non generic typechecking fun expression may generic outside 
case ex assigned nongeneric assigned generic 
determine variable generic maintain list non generic variables point program type variable list generic 
list augmented entering fun leaving fun old list automatically current type variable generic 
copying type copy generic variables non generic variables shared 
unifying nongeneric variable term type variables contained term non generic 
consider recursive declarations rec treated rec expanded fixpoint operator type fun 
evident instances type variables type recursive definition non generic instances generic 
case 
typecheck typecheck declaration part obtaining environment identifiers types typechecking body 
case 
declaration treated checking definitions xi ti introduces pair xi ti environment ti type ti case mutually recursive declarations xi ti create environment containing pairs xi xi defined new non generic type variables inserted list non generic variables scope declaration 
ti typechecked environment types ti matched instantiations 
digression models inference systems algorithms basic approaches formal semantics types 
fundamental concerned devising mathematical models types normally mapping page type expression set values values having type basic difficulty finding mathematical meaning operator scott milner macqueen 
complementary approach define formal system axioms inference rules possible prove expression type 
relationship models formal systems strong 
semantic model guide defining formal system formal system self consistent shown exhibiting model 
formal system prove nearly know true intuition true model 
formal system forget models usually simpler syntactic framework system 
typechecking strictly related formal systems models syntactic nature 
typechecking algorithm sense implements formal system providing procedure proving theorems system 
formal system essentially simpler fundamental algorithm simplest presentation typechecking algorithm formal system implements 
looking typechecking algorithm better define formal system 
formal type systems admit typechecking algorithms 
formal system powerful prove things undecidable decision procedure 
typechecking usually restricted decidable type systems typechecking algorithms 
cases undecidable systems treated incomplete typechecking heuristics done practice far attempt prove theorems system may point give 
acceptable practice limits complexity program meaning get hand long limits typechecking heuristics reached 
decidable type systems typechecking algorithms exponential requiring heuristics deal 
successfully attempted hope burstall treatment overloading presence polymorphism 
section presents inference system kind polymorphic typechecking described 
distinct views typechecking solving system type equations seen previous sections proving theorems formal system going see 
views interchangeable provide insights connection type semantics side algorithms 
page inference system inference system syntax types extended type quantifiers 

milner type system type variables occurring type intended implicitly quantified top level 
example really 


quantifiers nested inside type expressions 
type called shallow form quantifiers occur 
inference system allows construction non shallow types unfortunately typechecking algorithms able cope 
interested inferences involve shallow types 
chosen type quantifiers inference system helps explain behavior generic nongeneric type variables correspond exactly free quantified type variables 
slightly different inference system avoids non shallow types see damas 
set inference rules 
ide axiom scheme rules proper inferences 
horizontal bar reads implies 
assumption association variable type 
set assumptions uniquely mapping variables types associated 
sets assumptions 
xn set assumptions 
xn notation means set assumptions deduce expression type 
notation means set assumptions deduce declaration introducing variables xn determines set assumptions form 
xn 
expression result substituting free occurrences 
ide bool cond abs fun comb gen free 
page page 
spec bind rec rec example deduce general type identity function fun 
ide fun abs fun 
gen specialized type identity function deduced general type directly fun 
fun int int spec int int ide fun int int abs extend inference show fun int int int int ide int fun int int abs int int ide int fun int comb example forbidden derivation non shallow types give type fun algorithm able type 
ide spec ide comb fun abs note 
gets instantiated 

spec substituting 

want show fun pair true int bool 
take int true bool pair 

ide int int spec int ide int comb ide bool bool spec true bool ide true bool comb pair 
ide pair 
int int spec pair int bool int bool spec pair int bool int bool int pair bool int bool comb true bool pair true int bool comb fun pair true int bool fun pair true int bool bind note assumption 
independently instantiate int bool generic type 
fun pair true fun function application version expression shallow type deduced fun pair true 
variable generic appear type variables enclosing 
binders occur set assumptions discarded abs create enclosing fun 
variable generic appear set assumptions 
variable generic apply gen introduce quantifier 
determines precise relation generic variables quantifiers 
page formal way relating inference system typechecking algorithm previous sections 
shown algorithm succeeds producing type expression type deduced inference system see milner result involving closely related inference system 
going take different informal approach intuitively justify typechecking algorithm 
going show algorithm extracted inference system 
view typechecking algorithm proof heuristic strategy determine order inference rules applied 
proof heuristic succeeds determined type inferred 
fails may possible infer type 
particular heuristic unable cope expressions require non shallow type manipulation deduction fun fun 

fact heuristic simply ignore type quantifier treat type variables free variables 
aspects heuristic 
determine sets assumptions second order apply inference rules 
language requires type declarations identifiers trivial obtain sets assumptions type inference 
carrying type inference fun bound identifiers initially associated type variables information gathered typechecking process determine type identifier place 
start initial broad assumptions build proof applying inference rules order 
rules require types subexpressions equal 
usually case equal unifying respective types 
results specializing types identifiers 
point imagine repeating proof starting refined set assumptions just determined time types subexpressions mentioned come equal proceed 
inference rules applied order allows build expression trying type left right bottom 
example earlier wanted show fun 

take set assumptions 
deduce type fun bottom start type obtain ide build fun abs 
proceed left right bottom exception gen spec point rule applied depending syntactic construct trying obtain 
problem reduces choosing gen spec done conjunction rule 
simplify discussion consider special case derived combining bind rules 
page applying derive refer rule apply possible gen rules obtaining quantified type 
start deriving time need ide quantified immediately spec strip quantifiers replacing quantifier variable fresh type variable 
new variables subject instantiation discussed determines refined ways spec 
exercise try apply heuristic infer type length observe corresponds typechecking algorithm case 
note list non generic variables corresponds set assumptions application gen spec rules 
pragmatic knowledge polymorphic typechecking trying relate informally theoretical background 
ideas developed number people number years transmitted discussions luis damas mike gordon dave macqueen robin milner ravi sethi 
page bruce bruce meyer semantics second order polymorphic lambda calculus semantics data types lecture notes computer science springer verlag 
appear title mitchell 
burstall burstall macqueen sannella hope experimental applicative language proceedings lisp conference stanford august pp 

cardelli cardelli wegner understanding types data abstraction polymorphism appear computing surveys 
coppo coppo extended polymorphic type system applicative languages lecture noted computer science pp 
springer verlag curry curry feys combinatory logic north holland amsterdam 
damas damas milner principal type schemes functional programs proc 
popl pp 
girard girard une extension de interpr tation de del analyse son application des coupures dans analyse la th orie des types proceedings second scandinavian logic symposium fenstad ed 
pp 
north holland 
gordon gordon milner wadsworth edinburgh lcf lecture notes computer science springer verlag 
hindley hindley principal type scheme object combinatory logic transactions american mathematical society vol 
dec pp 

macqueen macqueen plotkin sethi ideal model recursive polymorphic types proc 
popl 
appear information control 
mccracken mccracken typechecking programs implicit type structure semantics data types lecture notes computer science pp 
springer verlag 
milner milner theory type polymorphism programming journal computer system sciences 
milner milner proposal standard ml proc 
acm symposium lisp functional programming aug 
robinson robinson machine oriented logic resolution principle journal acm vol jan pp 

scott scott data types lattices siam journal computing 
strachey strachey fundamental concepts programming languages lecture notes international summer school computer programming copenhagen page appendix program modula program implements polymorphic typechecking algorithm types exp decl form syntax language 
type expressions typeexp type variable type operator 
type variable uninstantiated instance field nil instantiated 
instantiated type variable behaves instantiation 
type operator bool name list type arguments bool 
function prune type expression inspected return type expression uninstantiated type variable type operator skip instantiated variables prune expressions remove long chains instantiated variables 
function checks type variable occurs type expression 
type type lists non generic variables 
copy type expression duplicating generic variables sharing nongeneric ones 
function checks variable occurs list non generic variables 
note variables list may bec instantiated type term case variables contained type term considered non generic 
type unification easily defined 
remember unifying non generic variable term variables term non generic 
handled automatically lists non generic variables explained 
special code needed unification routine 
type environments defined 
note creates fresh types copying unnecessary eliminated 
typechecking routine maintains type environment list non generic variables 
recursive declarations handled passes 
pass simply creates new set non generic type variables associates identifiers 
second pass analyzes declarations calls ensure recursive type constraints 
implementation modules provided 
page definition modules definition module procedure msg msg array char print error message 
definition module type ide procedure new string array char ide create new identifier string procedure equal ide ide ide boolean compare identifiers 
definition module import import ide type exp pointer parse tree expressions decl pointer parse tree declarations record case class ide ide test iftrue iffalse exp binder ide body exp fun arg exp decl decl scope exp defclass record case class defclass binder ide def exp second decl rec decl allocation routines exp decl procedure ide ide exp procedure test iftrue iffalse exp exp procedure binder ide body exp exp page procedure fun arg exp exp procedure decl decl scope exp exp procedure binder ide def exp decl procedure second decl decl procedure rec decl decl 
definition module import import ide type typeexp pointer internal representation type expressions record case class instance typeexp ide ide args typelist typelist pointer record head typeexp tail typelist procedure typeexp allocate new type variable procedure ide ide args typelist typeexp allocate new type operator var empty typelist empty type list procedure extend head typeexp tail typelist typelist allocate new type list procedure typeexp typeexp typeexp boolean compare types identity pointer equality procedure prune typeexp typeexp typeexp eliminate redundant instantiated variables top typeexp result prune non instantiated type variable type operator procedure typevar typeexp typeexp typeexp boolean uninstantiated type variable occurs type expression procedure typevar typeexp list typelist boolean uninstantiated type variable occurs list procedure typeexp typeexp typeexp unify type expressions procedure list list typelist unify lists type expressions 
definition module page import import typeexp type lists non generic type variables instantiations var empty empty list procedure extend head typeexp tail extend list procedure typevar typeexp list boolean uninstantiated type variable generic list non generic type variables procedure typeexp typeexp list typeexp copy type expression generic copied non generic variables shared 
definition module import import ide import typeexp import type env environments associating type expressions identifiers var empty env empty environment procedure extend ide ide typeexp typeexp tail env env extend environment identifier type pair procedure retrieve ide ide env env list typeexp search identifier environment return fresh copy associated type 
identifier bound environment 
definition module import import exp decl import typeexp import env import procedure exp exp env env list typeexp typecheck expression environment return type procedure decl decl env env list env typecheck declaration environment return extended environment containing types identifiers introduced declaration page 
page implementation modules implementation module import procedure typeexp var typeexp new class instance nil return procedure ide ide args typelist typeexp var typeexp new class ide ide args args return procedure extend head typeexp tail typelist typelist var typelist new head head tail tail return extend procedure typeexp typeexp typeexp boolean return typeexp typeexp procedure prune typeexp typeexp typeexp case typeexp class typeexp instance nil return typeexp typeexp instance prune typeexp instance return typeexp instance return typeexp prune procedure typevar typeexp typeexp typeexp boolean typeexp prune typeexp case typeexp class return typevar typeexp return typevar typeexp args procedure typevar typeexp list typelist boolean list nil return false typevar list head return true return typevar list tail page procedure typeexp typeexp typeexp typeexp prune typeexp typeexp prune typeexp case typeexp class typeexp typeexp typeexp typeexp msg type clash typeexp instance typeexp case typeexp class typeexp typeexp equal typeexp ide typeexp ide typeexp args typeexp args msg type clash procedure list list typelist list empty list empty return list empty list empty msg type clash list head list head list tail list tail empty nil 
implementation module import typelist type typelist procedure extend head typeexp tail return extend head tail extend procedure typevar typeexp list boolean return typevar list type pointer page record old new typeexp tail procedure old new typeexp tail var new old old new new tail tail return procedure typevar typeexp scan var env typeexp var typeexp scan nil env typevar env return elsif typevar scan old return scan new return typevar scan tail var env procedure fresh typeexp typeexp list var env typeexp typeexp prune typeexp case typeexp class typeexp list return typeexp env var env return typeexp return typeexp ide typeexp args list var env fresh procedure args typelist list var env typelist args empty return empty return extend fresh args head list var env args tail list var env procedure typeexp typeexp list typeexp var env env nil return fresh typeexp list var env empty empty 
implementation module page import type env pointer record ide ide typeexp typeexp tail env procedure extend ide ide typeexp typeexp tail env env var env new ide ide typeexp typeexp tail tail return extend procedure retrieve ide ide env env list typeexp env empty msg unbound ide return nil elsif equal ide env ide return env typeexp list return retrieve ide env tail list retrieve empty nil 
implementation module import import import var typeexp procedure dom cod typeexp typeexp return new extend dom extend cod empty procedure exp exp env env list typeexp var typeexp env case exp class return retrieve exp ide env list exp test env list exp iftrue env list exp iffalse env list page return extend exp binder env extend list exp body return exp fun env list exp arg env list return exp decl env list return exp scope list procedure decl decl env env list env case decl class defclass return extend decl binder decl def env list env return decl second decl env list list decl rec var env var list decl rec env list return env procedure decl decl var env env var list var typeexp case decl class defclass env extend decl binder env list extend list decl var env var list decl second var env var list decl rec var env var list procedure decl decl env env list case decl class defclass retrieve decl binder env list decl def env list decl env list page decl second env list decl rec env list new bool empty 
page 
