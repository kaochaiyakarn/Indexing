finite state transducers language speech processing mehryar mohri labs research finite state machines various domains natural language processing 
consider type transducers supports efficient programs sequential transducers 
recall classical theorems give new ones characterizing sequential string tostring transducers 
transducers output weights play important role language speech processing 
give specific study string weight transducers including algorithms minimizing transducers efficiently characterizations transducers admitting determinization corresponding algorithms 
applications algorithms speech recognition described illustrated 

finite state machines areas computational linguistics 
justified linguistic computational arguments 
linguistically finite automata convenient allow describe easily relevant local phenomena encountered empirical study language 
lead compact representation lexical rules idioms clich appears natural linguists gross 
graphic tools allow visualize modify automata 
helps correcting completing grammar 
general phenomena parsing context free grammars dealt finite state machines rtn woods 
underlying mechanisms methods parsing related automata 
computational point view finite state machines mainly motivated considerations time space efficiency 
time efficiency usually achieved deterministic automata 
output deterministic machines depends general linearly input size considered optimal point view 
space efficiency achieved classical minimization algorithms aho hopcroft ullman deterministic automata 
applications compiler construction shown deterministic finite automata efficient practice aho sethi ullman 
finite automata constitute rich chapter theoretical computer science perrin 
applications natural language processing range construction lexical analyzers compilation morphological phonological rules kaplan kay karttunen kaplan zaenen speech processing mohri pereira riley show usefulness finite state machines areas 
provide theoretical algorithmic bases application devices support efficient programs sequential trans mountain avenue murray hill nj usa 
electronic version includes corrections appear printed version 
association computational linguistics computational linguistics volume number 
extend idea deterministic automata transducers deterministic input machines produce output strings weights addition accepting deterministically input 
describe methods consistent initial reasons finite state machines particular time efficiency deterministic machines space efficiency achievable new minimization algorithms sequential transducers 
time space concerns important dealing language 
trends clearly come new studies language large increase size data 
lexical approaches shown appropriate areas computational linguistics ranging large scale dictionaries morphology large lexical grammars syntax 
effect size increase time space efficiency probably main computational problem needs face language processing 
finite state machines natural language processing certainly new 
limitations corresponding techniques pointed advantages 
reason probably field described computer science textbooks 
sequential finite state transducers areas computational linguistics 
give extended description devices 
consider case string string transducers 
transducers successfully representation large scale dictionaries computational morphology local grammars syntax 
describe theoretical bases transducers 
particular recall classical theorems give new ones characterizing transducers 
consider case sequential string weight transducers 
transducers appear interesting speech processing 
language models phone lattices word lattices objects represented transducers 
give new theorems extending characterizations known usual transducers transducers 
define algorithm string weight transducers 
characterize unambiguous transducers admitting determinization describe algorithm test 
give algorithm minimize sequential transducers complexity equivalent classical automata minimization efficient practice 
certain restrictions minimization sequential string weight transducers performed determinization algorithm 
describe corresponding algorithm give proof correctness appendix 
algorithms speech processing 
section describe applications determinization minimization string weight transducers speech recognition 
illustrate results show efficient 
implementation determinization fly necessary part transducer needs expanded 
plays important role space time efficiency speech recognition 
reduction word lattices algorithms provide sheds new light complexity networks involved speech processing 

sequential string string transducers sequential string string transducers various areas natural language processing 
determinization mohri minimization algorithms mohri defined class subsequential transducers includes mohri transducers language speech sequential string string transducers 
section theoretical basis sequential transducers described 
classical new theorems help indicate usefulness devices characterization 
sequential transducers consider sequential transducers transducers deterministic input 
state transducers outgoing arc labeled element alphabet 
gives example sequential transducer 
notice output labels strings including empty string empty string allowed input 
output sequential transducer necessarily deterministic 
distinct arcs output labels instance leave state example sequential transducer 
ba sequential transducers computationally interesting input depend size transducer input 
consists path corresponding input string writing consecutive output labels path total computational time linear size input consider cost copying output label depend length 
definition formally sequential string string transducer tuple set states initial state set final states finite sets corresponding respectively input output alphabets transducer state transition function maps output function maps functions generally partial functions state necessarily admit outgoing transitions labeled input side elements alphabet 
functions extended mappings computational linguistics volume number classical recurrence relations string accepted iff transducer case output subsequential subsequential transducers sequential transducers generalized introducing possibility generating additional output string final states sch 
application transducer string possibly finish concatenation output string usual output 
transducers called subsequential transducers 
language processing requires general extension 
ambiguities example subsequential transducer encountered language ambiguity grammars morphological analyzers pronunciation dictionaries instance taken account sequential subsequential transducers 
devices associate single output input 
order deal ambiguities introduce subsequential transducers mohri transducers provided final output strings final state 
gives example subsequential transducer 
input string gives distinct outputs find reasonable case language number ambiguities infinite subsequential transducers sufficient describing linguistic ambiguities 
number ambiguities large cases 
notice subsequential transducers exactly subsequential transducers 
transducers considered representing mappings strings strings 
admit composition operation defined mappings 
operation useful allows construct complex transducers simpler ones 
result application string computed considering output strings associated input transducer applying strings 
output strings obtained application represent result fact waiting result application completely gradually apply output strings completed 
basic idea composition algorithm allows directly construct transducer define sequential resp 
subsequential functions functions represented sequential resp 
subsequential transducers 
noticed previously result composition transducers transducer directly constructed 
exists efficient algorithm general case composition transducers transducers subsequential having transitions outputs mohri pereira riley 
mohri transducers language speech theorem gives specific result case subsequential subsequential functions expresses closure composition 
expression subsequential ways 
means finite number ambiguities admitted closure composition matches case second indicates number equals exactly theorem sequential resp 
subsequential sequential resp 
subsequential function sequential resp 
subsequential 
proof prove theorem general case subsequential transducers 
case sequential transducers proved derived general case trivial way 
subsequential transducer representing representing denote final output functions map respectively represents instance set subsequential trans final output strings final state define subsequential transducer transition output functions final output function defined clearly definition composition transducer realizes definition shows admits distinct output strings input 
ends proof theorem 
gives example subsequential subsequential transducer example subsequential transducer result composition transducers shown 
states transducer correspond pairs states composition consists essentially making intersection outputs inputs transducers admit useful operation union 
input string transducer union gives set union strings obtained application denote union theorem specifies type transducer implying particular closure union acyclic subsequential transducers 
proved way similar composition theorem 
computational linguistics volume number subsequential transducer obtained composition theorem sequential resp 
subsequential sequential resp 
subsequential function represented acyclic transducers subsequential resp 
subsequential 
union transducer constructed way close union automata 
introduce new initial state connected old initial states transitions labeled empty string input output 
transducer obtained construction sequential contains transitions input side 
exists algorithm construct union subsequential subsequential transducers directly subsequential transducer 
ba subsequential transducer union direct construction consists considering pairs states state additional state denote underscore state additional state denote underscore 
transitions leaving obtained union transitions leaving keeping underscore state similarly keeping underscore state 
union transitions performed way aaa aab bbb bba ba aa mohri transducers language speech transitions labeled input label transition labeled associated output label transition longest common prefix output transitions labeled leaving see mohri full description algorithm 
shows subsequential transducer obtained constructing union transducers way 
notice theorem result priori subsequential transducers share common accepted string 
cases resulting transducer subsequential 
characterization extensions linear complexity sequential subsequential transducers mathematically computationally particular interest 
transducers realize functions rational functions admit equivalent sequential subsequential transducer 
transducer equivalent sequential representation 
consider instance function associated classical transducer represented 
defined function sequential realized sequential transducer 
order start writing output associated input string odd needs finish reading input string arbitrarily long 
sequential functions functions represented sequential transducers allow unbounded delays 
generally sequential functions characterized rational functions theorem 
theorem ginsburg rose rational function mapping sequential iff exists positive integer denote length string 
computational linguistics volume number words string element alphabet equal concatenated bounded string 
notice implies prefix generally sequential preserves prefixes 
fact rational functions sequential reduce interest sequential transducers 
theorem due elgot shows transducers exactly compositions left right sequential transducers 
theorem elgot partial function mapping rational iff exist left sequential function right sequential function left sequential functions transducers previously defined 
application string proceeds left right 
right sequential functions apply strings right left 
theorem considering new sufficiently large alphabet allows define sequential functions decomposing rational function result considerably increases importance sequential functions theory finite state machines practical transducers 
left right sequential transducer berstel gives constructive proof theorem 
finite state transducer easily construct left sequential transducer right sequential transducer intuitively extended alphabet keeps track local ambiguities encountered applying transducer left right 
distinct element alphabet assigned ambiguities 
right sequential transducer constructed way ambiguities resolved right left 
figures give decomposition non sequential right left sequential transducer transducer 
symbols alphabet store information mohri transducers language speech size input string output ends iff odd 
right sequential function easy construct 
sequential transducers offer theoretical advantages 
particular important tests equivalence undecidable general transducers sequential transducers decidability property 
theorem transducer mapping decidable sequential 
constructive proof theorem 
efficient polynomial algorithm testing transducers proof weber 
gave characterization subsequential functions definition metric denote longest common prefix strings easy verify defines metric theorem describes characterization subsequential functions 
theorem partial function mapping subsequential iff 
bounded variation metric defined 

rational subset rational 
notion bounded variation roughly understood way small prefix share sufficiently long compared lengths true images theorem extended describe case subsequential functions defining metric define theorem subsequential iff partial function mapping 
bounded variation metric 

rational subset rational 
proof assume subsequential subsequential transducer realizing transducer realizing component obtained simply keeping outputs final state subsequential construction component subsequential 
previous theorem implies component bounded variation definition bounded variation 
conversely condition holds fortiori bounded variation 
combined second condition implies subsequential 
transducer computational linguistics volume number realizing obtained union subsequential transducers ing component view theorem subsequential 
give characterization subsequential transducers irrespective choice components 
semi metric defined theorem gives characterization 
theorem rational function mapping subsequential iff bounded variation semi metric 
proof previous theorem condition sufficient conversely subsequential subsequential transducer representing output function mapping defined denote set strings accepted exists bounded variation ends proof theorem 
application language processing briefly mentioned theoretical computational properties sequential subsequential transducers 
devices areas computational linguistics 
areas determinization algorithm obtain subsequential transducer mohri minimization algorithm reduce size subsequential transducer mohri 
composition union equivalence algorithms subsequential transducers useful applications 
mohri transducers language speech representation large dictionaries 
large scale dictionaries represented subsequential dictionaries number entries ambiguities contain finite 
corresponding representation offers fast look recognition depend size dictionary input string considered 
minimization algorithm sequential subsequential transducers allows reduce minimum size devices 
experiments shown obtain efficient way compact fast look representations large natural language dictionaries 
example french morphological dictionary mb compiled subsequential transducer size mb minutes mohri 
compilation morphological phonological rules 
similarly context dependent phonological morphological rules represented finite state transducers kaplan kay 
phonological morphological rules correspond subsequential functions 
result computation described kaplan kay necessarily subsequential transducer 
determinization algorithm transducers 
increases considerably time efficiency transducer 
minimized reduce size 
observations extended case weighted rewrite rules mohri sproat 
syntax 
finite state machines currently represent local syntactic constraints roche karlsson mohri 
linguists conveniently introduce local grammar transducers disambiguate sentences 
number local grammars language specific domain large 
local grammar transducers subsequential 
determinization minimization time efficient reduce size 
subsequential transducers closed composition result composition local grammar transducers subsequential transducer 
equivalence local grammars tested equivalence algorithm sequential transducers 
detailed overview applications sequential string string transducers language processing see mohri 
time space efficiency suggest sequential transducers extended natural language processing connected areas 
consider case string weight transducers areas computational linguistics 

power series subsequential string weight transducers consider string weight transducers transducers input strings output weights 
transducers various domains language modeling representation word phonetic lattices way reads follows path corresponding input string outputs number obtained combining weights path 
applications natural language processing weights simply added path interpreted negative logarithms probabilities 
case transducer sequential deterministic input proceeds way paths corresponding input string 
natural language processing specifically speech processing keeps minimum weights associated paths 
corresponds viterbi approximation speech recognition computational linguistics volume number related areas hidden markov models hmm 
applications looks best path path minimum weight 
definitions section give definition string weight transducers useful presentation theorems sections 
addition output weights transitions string weight transducers provided initial output weights 
instance input string transducer outputs initial final weight 
example string weight transducer 
definition formally string weight transducer defined finite set states input alphabet set initial states set final states finite set transitions initial weight function mapping final weight function mapping define transition partial function mapping output function mapping path set successive transitions extend definition paths denote set paths labeled input string definition extended path mohri transducers language speech exists path labeled define minimum outputs paths input successful path path initial state final state 
string accepted iff exists successful path labeled output corresponding accepted string obtained minimum outputs successful paths input label transducer said trim states belong successful path 
string transducers clearly realize functions mapping operations need consider addition semiring call functions formal power series 
adopt terminology notation formal language theory berstel reutenauer kuich salomaa salomaa image formal power series string called coefficient notation coefficients support language defined denoted define power series fundamental theorem sch analogous kleene theorem formal languages states formal power series rational iff recognizable realizable string weight transducer 
semiring optimization problems called tropical semiring functions consider precisely rational power series tropical semiring 
string weight transducer said unambiguous string exists successful path labeled examine specifically efficient string weight transducers subsequential transducers 
transducer said subsequential input deterministic state exists outgoing transition labeled element input alphabet subsequential string weight transducers recall semiring essentially ring may lack negation operation necessarily admit inverse 
respectively identity elements non empty set respectively identity elements examples semirings 
terminology specifically set restricted natural integers 
computational linguistics volume number called weighted automata weighted acceptors probabilistic automata distance automata 
terminology meant favor functional view devices view consider 
string weight transducers subsequential define algorithm non subsequential transducers possible 
definition formally string weight subsequential transducer tuple set states initial state set final states input alphabet transition function mapping extended string case map output function maps extended initial weight final weight function mapping string exists accepted subsequential transducer output associated definition characterizing transducers admit determinization 
definition states string weight transducer necessarily subsequential said twins words twins reached initial state string minimum outputs loops labeled string identical 
say twins property states twins 
notice definition states cycles string twins 
particular states belong cycle necessarily twins 
acyclic transducer twins property 
section consider subsequential power series tropical semiring functions realized subsequential string weight transducers 
rational power series defined tropical semiring considered practice subsequential particular acyclic transducers represent subsequential power series 
introduce theorem giving intrinsic characterization subsequential power series irrespective transducer realizing 
algorithm allows string weight transducers 
give general mohri transducers language speech presentation algorithm semirings 
particular algorithm string string transducers transducers output labels pairs strings weights 
twins property define set transducers determinization algorithm applies 
give characterization unambiguous transducers admitting determinization 
characterization define algorithm test transducer 
minimization algorithm applies subsequential string transducers 
algorithm efficient 
determinization algorithm cases minimize subsequential transducer 
describe algorithm give related proofs appendix 
characterization subsequential power series recall define metric denote longest common prefix strings definition gave subsequential power series depends transducers representing 
theorem gives intrinsic characterization unambiguous subsequential power series theorem rational power series defined tropical semiring 
subsequential bounded variation 
represented unambiguous weighted automaton converse holds 
proof assume subsequential 
subsequential transducer 
denotes transition function associated output function initial final weight functions 
output labels maximum lengths upper bound output differences final states define definition exists extension characterization theorem string string functions 
extension straightforward length output string natural integer 
deal real numbers 
computational linguistics volume number notice proves fortiori bounded variation 
conversely suppose bounded variation 
rational theorem sch recognizable exists string weight transducer realizing assume trim unambiguous transducer 
describe sections determinization algorithm 
show algorithm applies transducer twins property 
order show sufficient show twins property 
consider states trim exists notice bounded variation unambiguous path corresponding 
twins property 
ends proof theorem 
resp 
implies particular subsequential power series tropical semiring define shows theorem continuous functions topology induced metric replace bounded variation 
mohri transducers language speech general determinization algorithm power series describe section algorithm constructing subsequential transducer equivalent non subsequential algorithm extends case transducers outputting weights determinization algorithm string string transducers representing subsequential functions mohri 
gives pseudocode algorithm 
algorithm general case semiring transducer defined 
algorithm describing applies transducers representing power series defined semirings describe algorithm case tropical semiring 
tropical semiring replace 
pseudocode exists enqueue new state dequeue algorithm determinization transducer representing power series defined semiring algorithm similar powerset construction determinization automata 
outputs transitions bearing input label differ output minimum outputs resulting transducer needs keep track residual weights 
subsets consider pairs states weights 
initial weight minimum initial weights line 
initial state subset pairs initial state line 
queue maintain set subsets particular algorithm applies string string transducers transducers output pairs strings weights 
come back point 
similarly interpreted computational linguistics volume number examined classical powerset initially contains subset construction subsets states resulting transducer 
final state iff contains pair final state lines 
final output associated minimum final outputs final states combined respective residual weight line 
input label exists state subset admitting outgoing transition labeled outgoing transition leaving input label constructed lines 
output transition minimum outputs transitions input label leave state subset combined residual weight associated state line 
destination state transition leaving subset pairs state reached transition labeled corresponding residual weight line 
computed minimum transitions input label leave state reach combined residual weight minus output weight enqueued iff new subset 
denote destination state transition sets algorithm defined denotes set pairs elements subset having transitions labeled input denotes set triples pair admits transition input label set states reached transitions labeled states subset algorithm illustrated figures 
notice input admits outputs outputs smallest kept transducer tropical semiring interested minimum outputs string 
notice transitions reach state priori different residual weights 
interested best path path corresponding minimum weight keep minimum weights state element subset line algorithm 
give section set transducers determinization algorithm terminates 
theorem shows correctness algorithm terminates 
theorem assume determinization algorithm terminates resulting transducer equivalent proof denote struction minimum outputs paths con algorithm works queue discipline chosen mohri transducers language speech transducer representing power series defined 
transducer obtained power series determinization define residual output associated subset weight associated pair containing hard show induction subsets constructed algorithm sets notice size subset exceeds card belongs pair subset paths reaching minimum residual outputs kept 
notice definition subset exists state residual output equal string accepted iff exists equations accepted iff contains pair exactly definition final states line 
accept set strings 
string accepted definition algorithm state computational linguistics volume number line gives denote power series realized power series determinization algorithm equivalent usual determinization automata initial weight final weights output labels equal 
subsets considered algorithm exactly obtained powerset determinization automata residual outputs equal 
space time complexity determinization algorithm automata exponential 
minimal deterministic automata exponential size respect equivalent non deterministic 
fortiori complexity determinization algorithm weighted case just described exponential 
cases degree nondeterminism initial transducer high determinization algorithm turns fast resulting transducer states initial 
cases appear speech recognition section 
minimization algorithm allows reduce size subsequential transducers representing power series 
complexity application subsequential transducers linear size string applies 
property worthwhile power series determinization order speed application transducers 
transducers power series determinization 
section define set transducers admit determinization characterize unambiguous transducers admit application algorithm 
determinization apply transducers 
important able test transducer 
section algorithm test property case unambiguous trim transducers 
proofs theorems sections complex skipped reading 
transducers transducers determinization halt 
generates infinite number subsets 
define transducers transducers algorithm terminates 
show large set transducers admit determinization 
give characterization unambiguous transducers admitting determinization 
states transducers considered assumed accessible initial 
lemma useful proof theorems 
string weight transducer labeled lemma path state path input string assume lengths greater exist strings states factored way mohri transducers language speech proof proof cross product transducers 
transducers define cross product transducer outputs transition iff define consider cross product lengths greater paths length greater exactly states admits cycle state path labeled non empty input string shows existence factorization proves lemma 
theorem string weight transducer defined tropical semiring 
twins property 
proof assume twins property 
determinization algorithm halt exists subset algorithm generates infinite number distinct weighted subsets necessarily mentioned previously subset exists state residual output subset contains state set strings infinite number distinct subsets states weighted subset exists null residual infinite output exist infinite number strings infinite set strings loss generality assume number subsets infinite exists distinct infinite number strings loss generality assume infinite set strings distinct 
define finite set differences weights paths leading labeled string computational linguistics volume number show yield contradiction infinity prove algorithm terminates 
consider shortest path state labeled input string total cost similarly consider shortest path labeled input string total cost definition subset construction assume lemma exists factorization type twins define cycles factorization sub paths shortest paths shortest cycles labeled induction find paths resp 
extracted deletion cycles length equal finite 
ends proof theorem 
transducers twins property 
characterize transducers needs complex conditions 
describe conditions 
case trim unambiguous transducers twins property provides characterization transducers 
theorem trim unambiguous string weight transducer defined tropical semiring 
iff twins property 
proof previous theorem twins property 
assume twins property exist states twins 
exists consider weighted subsets constructed determinization algorithm 
subset contains pairs show subsets distinct 
prove determinization algorithm terminate twins property 
trim unambiguous transducer exits path input string similarly cycles labeled unique 
exist mohri transducers language speech defined equations show subsets distinct 
test characterization transducers provided theorem leads definition algorithm testing trim unambiguous transducers 
describing algorithm introduce lemma shows suffices examine finite number paths test twins property 
lemma trim unambiguous string weight transducer defined tropical semiring 
twins property iff proof clearly twins property holds 
conversely prove holds holds induction proof similar berstel string string transducers 
consider assume assume trim unambiguous transducer exists unique path labeled input string unique path view lemma exist strings states factored way lemma exist strings induction assume states factored way induction trim unambiguous transducer completes proof lemma 
similarly computational linguistics volume number theorem trim unambiguous string weight transducer defined tropical semiring 
exists algorithm test proof theorem testing equivalent testing twins property 
define algorithm test property 
algorithm close weber testing string string transducers 
construction automaton similar cross product 
finite set real numbers defined define set states defined set initial states set final states set transitions construction states reached string iff exists reached set exactly transitive closure transitive closure determined time linear size states twins iff exists path exactly equivalent existence cycles input label distinct output weights 
lemma suffices test twins property strings length gives algorithm test twins property transducer 
compute transitive closure 
determine set pairs distinct states 
compute transitive closure contains twins property 
operations algorithm computation transitive closure determination set states done polynomial time respect size classical algorithms aho hopcroft ullman 
provides algorithm testing twins property unambiguous trim transducer useful knows unambiguous 
practical cases transducer wishes ambiguous 
possible construct unambiguous transducer unweighted acyclic 
complexity construction exponential worst case 
complexity test exponential worst case 
eilenberg mohri transducers language speech notice wishes construct result determinization input string need expand result determinization necessary part transducer 
restricted finite set function realized transducer bounded acyclic transducers twins property 
variation possible expand result determinization algorithm finite set input strings 
determinization semirings determinization algorithm previously applies transducers mapping strings semirings 
gave pseudocode algorithm general case 
algorithm applies instance real semiring 
transducer outputs ba aa verify denotes longest com mon prefix operation concatenation new element string defines left semiring call semiring string semiring 
algorithm string semiring exactly determinization algorithm string transducers defined mohri 
cross product semirings defines semiring 
algorithm applies semiring cross product allows transducers outputting pairs strings weights 
determinization algorithm transducers illustrated figures 
subsets algorithm triples state initial transducer residual string residual output weight 
minimization define minimization algorithm subsequential power series defined tropical semiring extends algorithm defined mohri case proof theorem previous section easy convince oneself assertion generalized rational subset bounded variation 
restriction function realizes left semiring semiring may lack right distributivity 
computational linguistics volume number sequential transducer outputs obtained determinization 
string string transducers 
subset string define recall regular language iff exists finite number distinct nerode 
similar way power series define new power series subsequential power series define relation easy show equivalence relation 
defines equivalence relation regular languages 
finer relation 
additional condition definition restriction power series constant 
lemma shows exists subsequential transducer computing number states equal number equivalence classes minimal transducer computing lemma subsequential power series defined tropical semiring finite number equivalence classes 
number bounded number states subsequential transducer realizing proof subsequential transducer realizing clearly prove power series defined field rational iff admits finite number independent paz 
equivalent power series nerode theorem regular languages 
mohri transducers language speech proves lemma 
theorem proves existence minimal subsequential transducer representing theorem subsequential function exists minimal subsequential transducer computing 
number states equal index proof subsequential power series define power series define subsequential transducer index finite defined 
definition de pend choice element implies definition independent choice definition exists notice definition implies subsequential realizes ends proof theorem 
subsequential transducer define state denote equivalence class computational linguistics volume number definition define new operation pushing applies transducer particular subsequential result application pushing new subsequential transducer weights way differs output definition implies defined lemma transducer obtained pushing 
realizes function proof subsequential follows immediately definition 
proves lemma 
theorem defines minimization algorithm 
subsequential transducer theorem subsequential transducer realizing power series tropical semiring 
applying operations 
pushing 
automata minimization leads minimal transducer 
minimal transducer exactly defined proof theorem 
automata minimization step theorem consists considering pairs input labels associated weights single label applying classical minimization algorithms automata aho hopcroft ullman 
give proof theorem 
proved way similar indicated mohri 
mohri transducers language speech iff general distinct minimal subsequential transducers realizing function 
pushing introduces equivalence relation minimal transducers resp 
denotes transducer obtained resp 
pushing 
minimal transducers realizing function equal unique minimal transducer equivalent defined theorem 
equivalent minimal transducers differ output labels topology 
differ way output weights spread paths 
notice introduce new super final state final state connected transition weight definition exactly length shortest path obtained classical single source shortest paths algorithms dijkstra cormen leiserson rivest 
case transducer acyclic classical linear time algorithm topological sort graph allows obtain function linear time complexity general case defined transformation done linear time denote set transitions complexity pushing linear transducer acyclic 
general case complexity pushing classical heaps fibonacci heaps efficient implementation priority queues thorup 
case maximum output weight small algorithm ahuja 

complexity pushing case transducer acyclic specific automata minimization algorithm efficient implementation hopcroft algorithm aho hopcroft ullman leads complexity minimization subsequential transducers classical automata minimization acyclic case general case 
transducer figures illustrate minimization algorithm 
represents subsequential string weight transducer 
notice size reduced algorithm extended case weights negative 
negative cycle bellman ford algorithm 
computational linguistics volume number transducer obtained pushing 
minimal transducer obtained automata minimization 
automata minimization 
represents transducer obtained pushing minimal transducer realizing function tropical semiring 
transducer obtained algorithm defined proof theorem minimal number states 
ask exists subsequential transducer minimal number transitions computing function subsequential transducer corollary brings specific answer question 
corollary minimal subsequential transducer minimal number transitions subsequential transducers realizing function 
proof generalizes analogous theorem holds case automata 
proof similar 
subsequential transducer minimal number transitions 
clearly pushing change number transitions automata minimization consists merging equivalent states reduces change number 
number transitions minimal transducer equivalent previously defined equal proves corollary previously pointed equivalent minimal transducers topology particular number states transitions 
mohri transducers language speech subsequential transducers wish test equivalence 
importance problem pointed hopcroft ullman page 
corollary addresses question 
corollary exists algorithm determine subsequential transducers equivalent 
proof algorithm theorem associates unique minimal transducer subsequential transducer precisely minimal transducer unique renumbering states 
identity subsequential transducers different numbering states tested way deterministic automata 
done instance testing equivalence automata equality number states 
exists efficient algorithm test equivalence deterministic automata aho hopcroft ullman 
minimization subsequential transducers shown efficient proves corollary efficiency test equivalence 
sch gave algorithm minimizing representation power series 
algorithm semiring considered field 
particular tropical semiring string semiring language speech processing semirings field 
precisely result states minimization defined transducers defined tropical semiring 
furthermore implemented algorithm sch case semiring 
important disadvantages practice creates transitions generate transitions negative weights initial machine 
negative weights interpreted terms probability 
section describe applications algorithms speech recognition 

application speech recognition previous sections gave theoretical description determinization minimization algorithms string weight transducers 
indicate practice 
algorithms interesting applications speech recognition 
briefly point 
speech recognition finite state transducers string weight transducers stages speech recognition 
phone lattices language models word lattices typically represented transducers 
weights graphs correspond negative logarithms probabilities 
added path 
string different paths transducer 
minimum total weights paths considered relevant information 
main operations involved interpretation transducers addition tropical semiring 
algorithms defined previous sections apply speech recognition 
automata minimization step fact omitted uses equivalence algorithm affect equivalence subsequential transducers considered automata 
computational linguistics volume number domain speech recognition systems signal processing represented composition finite state transducers outputting weights strings weights pereira riley mohri pereira riley represents acoustic observations acoustic model mapping sequences acoustic observations context dependent phones context dependency model mapping sequences context dependent phones context independent phones pronunciation dictionary mapping sequences phones words language model grammar mapping sequences words sentences 
general cascade compositions explicitely expanded due size 
needs approximation method search 
beam pruning paths weights beam difference weights minimum weight far certain predefined threshold kept expansion cascade composition 
furthermore interested best path set paths cascade transducers lowest weights 
set paths lowest weights represented acyclic string transducer 
path transducer corresponds sentence 
weight path negative probability sentence sequence acoustic observations utterance 
acyclic string weight transducers called word lattices 
word lattices utterance word lattice obtained way contains paths labeled possible sentences associated weights 
word lattice contains lot redundancy paths correspond sentence different weights 
word lattices directly searched find probable sentences correspond best paths paths smallest weights 
corresponds word lattice obtained speech recognition word arpa atis task 
corresponds utterance flights leave detroit arrive saint petersburg am clearly lattice complex 
contains paths 
usually consider best path word lattice 
needs correct best path approximation considering best paths value large need consider paths 
transducer contains states transitions 
determinization applies lattice 
resulting transducer sparser 
recall equivalent realizes exactly function mapping strings weights 
sentence recognized different paths different total weights 
contains path labeled total weight equal minimum weights paths insist fact pruning heuristics approximation 
lattice contains paths 
hard realize search stage speech recognition greatly simplified applied admits states transitions 
transducer minimized 
minimization algorithm described previous section leads transducer contains states transitions course number paths 
effect minimization appears depends task considered 
notice case mohri transducers language speech flights flights flights flights flights flights flights flights flights flights leave flights leave leave leave leave leave flights leave detroit flights leave detroit flights leave detroit leave flights detroit flights leave leave detroit leave leave leave leave leave leave leave leave detroit detroit detroit detroit detroit detroit leave detroit leave detroit detroit detroit arrive arrive arrive arrive arrive arrive arrive arrive arrive arrive arrive arrive arriving arrive arrive arrive arrive arrive arrive arrive arrive arrive arrive arrive arrive arrive arrive arrive arrive arrive arrive arrive arrive arrive arrive arrive arrive arrive arrives arrives arrive arrive arrive arrive arrives arrives saint petersburg saint petersburg saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint saint petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg petersburg word lattice atis task utterance flights leave detroit arrive saint petersburg am important 
determinization includes large part minimization reducing size lattice 
explained degree computational linguistics volume number flights leave detroit arriving arrive arrives arrive saint saint saint saint saint petersburg petersburg petersburg petersburg equivalent word lattice obtained determinization flights leave detroit arrive arrives arrive arriving saint saint saint petersburg petersburg equivalent word lattice obtained minimization petersburg non determinism word lattices states reached set strings 
states grouped single subset determinization 
complexity determinization exponential general case lattices considered speech recognition case contain lot redundancy resulting lattice smaller initial 
fact time complexity determinization expressed terms initial resulting lattices denote sizes clearly restrict determinization cases complexity polynomial terms size initial transducer applies space complexity algorithm 
practice algorithm appears efficient 
example took silicon graphics indy mhz processor mb ram transducer 
determinization lattices faster 
state exists transition labeled word considered finding weight associated sentence depend size lattice 
time space complexity operation simply linear size sentence 
dealing large tasks speech recognition systems rescoring method 
consists simple acoustic grammar model produce word lattice reevaluate word lattice sophisticated model 
size word lattice critical parameter time space efficiency system 
determinization minimization algorithms allow considerably reduce size word lattices seen examples 
experimented determinization minimization algorithms notion ambiguity finite automaton formalized conveniently tropical semiring 
important studies degree ambiguity automata done connection study properties semiring simon 
specific determinization cases encountered natural language processing graph admits loop initial state elements alphabet mohri 
part time corresponds independent algorithm 
mohri transducers language speech rescoring 
table word lattices atis task 
cheap models approximate lattice determinization determinization minimization objects states reduction factor reduction factor transitions paths rescoring detailed models atis task 
table illustrates results 
shows algorithms effective reducing redundancy speech networks task 
reduction illustrated example atis task 
example example word lattice atis task 
states transitions paths number paths word lattice determinization larger largest integer representable bit machines 
experimented minimization algorithm applying word lattices obtained word arpa north american business news task nab 
table subsequential word lattices nab task 
minimization results objects reduction factor states transitions lattices 
table shows average reduction factors obtained minimization algorithms subsequential lattices obtained utterances nab task 
reduction factors help measure gain minimization lattices subsequential 
figures example correspond typical case 
example reduction obtained 
example example word lattice nab task 
transitions states computational linguistics volume number fly implementation determinization important characteristic determinization algorithm onthe fly 
determinization algorithm subset representing state resulting transducer definition transitions leaving state depends state equivalently states subset transducer 
particular definition construction transitions depend directly previous subsets constructed 
produced implementation determinization allows completely expand result expand demand 
arcs leaving state transducer expanded needed 
characteristic implementation important 
instance step fly cascade composition transducers speech recognition expand necessary part lattice transducer pereira riley mohri pereira riley 
essential implications implementation contributes saving space search stage 
useful speeding best decoder speech recognition determinization minimization algorithms string weight transducers applications speech processing 
new experiments done algorithms different stages recognition 
lead reshape methods field particular providing new success theory automata transducers 

briefly theoretical bases algorithmic tools practical set devices fit complexity language provide efficiency space time 
theoretical point view understanding objects crucial 
helps describe possibilities offer guide algorithmic choices 
new theoretical issues arise precision sought 
notion determinization generalized determinization instance chapter exercise salomaa requiring general algorithms 
extended local determinization determinization states transducer admit predefined property having large number outgoing transitions 
important advantage local determinization applied transducer restriction 
furthermore local determinization admits fly implementation 
new characterizations rational functions shed new light aspects theory finite state transducers reutenauer sch 
started generalization operations notions semiring power series 
help simplify problems algorithms various cases 
particular string semiring introduced conceptually easier describe algorithms properties 
subsequential transducers admit efficient algorithms 
determinization minimization algorithms case string weight transducers complete large series algorithms shown give remarkable results natural language processing 
sequential machines lead useful algorithms areas computational linguistics 
particular subsequential power series allow achieve efficient results indexation natural language texts crochemore describe application determinization 
mohri transducers language speech mohri 
briefly illustrated application algorithms speech recognition 
precision acoustic modeling finer language models large lexicon grammars larger vocabulary lead near networks larger sizes speech recognition 
determinization minimization algorithms help limit size networks keeping time efficiency 
algorithms text speech synthesis 
fact operations composition transducers sproat important size issues field 

appendix determinization algorithm power series minimize transducers cases 
consider case automata 
brzozowski showed determinization minimize automata 
nice result proved elegant papers bauer 
authors refine method obtain better complexities theorem brzozowski non deterministic automaton 
automaton obtained reversing applying determinization obtained automaton minimal deterministic automaton equivalent generalize theorem case string weight transducers 
say rational power series subsequential power series subsequential subsequential transducers 
shows transducer representing power series 
transducer subsequential subsequential 
reverse bounded variation 
give characterization power series defined tropical semiring way similar string string transducers 
particular theorem previous sections shows iff bounded variation 
define similarly transducers transducers defined tropical semiring admitting applications determinization way reverse 
denote transducer 
see watson taxonomy minimization algorithms automata 
string denote reverse 
resulting computational linguistics volume number subsequential power series non 
reverse 
denote resulting transducer 
definition assume reverse operation performed simply reversing direction transitions exchanging initial final states 
definition extension theorem brzozowski transducers theorem transducer defined tropical semiring 
trans obtained reversing applying determinization obtained transducer minimal subsequential transducer equivalent proof denote pushing 
transducer obtained double reverse determinization algorithms clearly change function subsequential transducer equivalent need prove minimal 
equivalent showing minimal number states 
result determinization trim realizes 
subsequential transducer 
show minimal trim subsequential transducer 
notice theorem require subsequential 
states equivalent sense automata 
prove distinct states merged 
prove minimal 
pushing affects output labels theorem holds case string string transducers 
give proof complex case string weight transducers 
mohri transducers language speech set states states states viewed weighted subsets state elements belong obtained determinization pair subset trim exists equivalent subsequential exists state admitting path labeled state state member pair member pair symmetry reverse true 
exactly states members pairs exists prove weights set strings labeling paths weight output corresponding string consider accumulated weights determinization instance corresponds weight output paths reaching needs added weights path rev final state 
terms determinization algorithm assign weight path labeled reaching final state obtained pushing weight path similarly weight path labeled string considered equivalent equal 
weights paths noticed proof determinization theorem minimum weight pairs subset 
ends proof theorem 
figures illustrate minimization string weight transducers determinization algorithm 
transducer obtained reversing 
application determinization results 
notice subsequential theorem transducer minimal 
reversed 
resulting transducer minimal equivalent compare transducer transducer minimal realize function 
provides output weights soon possible 
obtained pushing 
computational linguistics volume number transducer obtained reversing transducer obtained determinization minimal transducer obtained reversing applying determinization 
mohri transducers language speech acknowledgments michael riley cl reviewers comments earlier versions fernando pereira michael riley discussions andrej providing word lattices cited phil useful advice dominique perrin help bibliography relating minimization automata determinization 
aho alfred john hopcroft jeffrey ullman 

design analysis computer algorithms 
addison wesley reading ma 
aho alfred ravi sethi jeffrey ullman 

compilers principles techniques tools 
addison wesley reading ma 
ahuja kurt mehlhorn james orlin robert tarjan 

faster algorithms shortest path problem 
technical report mit operations research center 
bauer 
minimizing finite automata 
eatcs bulletin 
berstel jean 

transductions context free languages 
teubner stuttgart 
berstel jean christophe reutenauer 

rational series languages 
springer verlag berlin new york 
brzozowski 
canonical regular expressions minimal state graphs definite events 
mathematical theory automata 
paz 

realizations stochastic finite automaton 
journal computer system sciences 
christian 

contributions tude de quelques de fonctions 
ph thesis th se de doctorat etat universit paris paris france 
cormen leiserson rivest 

algorithms 
mit press cambridge ma 
courcelle bruno damian andreas podelski 

geometrical view determinization minimization finite state automata 
math 
systems theory 
crochemore 

transducers repetitions 
theoretical computer science 
eilenberg samuel 

automata languages machines volume 
academic press 
elgot 

relations defined generalized finite automata 
ibm journal research development 
ginsburg rose 

characterization machine mappings 
canadian journal mathematics 
gross maurice 

finite automata lexical representation natural language 
lecture notes computer science 
hopcroft john jeffrey ullman 

automata theory languages computation 
addison wesley reading ma 
kaplan ronald martin kay 

regular models phonological rule systems 
computational linguistics 
karlsson fred voutilainen juha 

constraint grammar language independent system parsing unrestricted text 
mouton de gruyter 
karttunen lauri ronald kaplan annie zaenen 

level morphology composition 
proceedings fifteenth international conference computational linguistics coling nantes france 
coling 
daniel 

equality problem rational series multiplicities tropical semiring undecidable 
journal algebra computation 
kuich werner salomaa 

semirings automata languages 
number eatcs monographs theoretical computer science 
springer verlag berlin germany 

mots 
hermes paris france 
mohri mehryar 

compact representations finite state transducers 
meeting association computational linguistics acl proceedings conference las cruces new mexico 
acl 
mohri mehryar 

minimization sequential transducers 
lecture notes computer science 
mohri mehryar 

applications finite state automata theory natural language processing representation morphological dictionaries compaction indexation 
computational linguistics volume number technical report institut monge noisy le grand 
mohri mehryar 

syntactic analysis local grammars automata efficient algorithm 
proceedings international conference computational lexicography complex 
linguistic institute hungarian academy science budapest hungary 
mohri mehryar 

matching patterns automaton 
lecture notes computer science 
mohri mehryar 
finite state devices natural language processing chapter sequential transducers natural language processing 
mit press appear 
mohri mehryar 

applications finite state automata theory natural language processing 
journal natural language engineering 
mohri mehryar fernando pereira michael riley 

weighted automata text speech processing 
ecai workshop budapest hungary 
ecai 
mohri mehryar richard sproat 

efficient compiler weighted rewrite rules 
th meeting association computational linguistics acl proceedings conference santa cruz california 
acl 
nerode anil 

linear automaton transformations 
proceedings ams volume 
pereira fernando michael riley 
finite state devices natural language processing chapter weighted rational transductions application human language processing 
mit press appear 
perrin dominique 

finite automata 
van editor handbook theoretical computer science volume formal models semantics 
elsevier amsterdam pages 
reutenauer christophe marcel paul sch 

vari fonctions 
theoretical computer science 
dominique 

minimisation acyclic deterministic automata linear time 
theoretical computer science 
roche emmanuel 

analyse du fran ais par 
ph thesis universit paris 
salomaa 

automata theoretic aspects formal power series 
springer verlag new york 
sch marcel paul 

definition family automata 
information control 
sch marcel paul 

sur une des fonctions 
theoretical computer science 
sch marcel paul 

polynomial decomposition rational functions 
lecture notes computer science volume 
lecture notes computer science springer verlag berlin heidelberg new york 
max 

analyse automatique de le syst 
masson paris france 
simon 

nondeterministic complexity finite automata 
technical report rt map instituto de matem tica da universidade de paulo 
sproat richard 

finite state architecture tokenization grapheme phoneme conversion multilingual text analysis 
proceedings acl sigdat workshop dublin ireland 
acl 
thorup 

ram priority queues 
proceedings soda atlanta georgia 
acm siam new york 

minimizing finite automata 
eatcs bulletin 
watson bruce 
taxonomy finite automata minimization algorithms 
technical report eindhoven university technology netherlands 
weber andreas reinhard 

economy description single valued transducers 
information computation 
woods 
transition network grammars natural language analysis 
communications association computational machinery 
