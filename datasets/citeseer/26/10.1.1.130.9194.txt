ieee transactions systems man cybernetics part cybernetics vol 
february formal framework positive negative detection schemes anomaly detection normal behavior process characterized model deviations model called anomalies 
behavior approaches anomaly detection model normal behavior constructed observed sample normally occurring patterns 
models normal behavior represent set allowed patterns positive detection set anomalous patterns negative detection 
formal framework analyzing tradeoffs positive negative detection schemes terms number detectors needed maximize coverage 
realistically sized problems universe possible patterns large represent exactly positive negative scheme 
partial matching rules generalize set allowable patterns choice matching rule affects tradeoff positive negative detection 
new match rule introduced called chunks generalizations induced different partial matching rules characterized terms crossover closure 
permutations representation achieve precise discrimination normal anomalous patterns 
quantitative results recognition ability contiguous bits matching permutations 
index terms detection artificial immune systems intrusion detection negative detection 
nomenclature fernando stephanie forrest paul helman length string pattern packet typically bits 
size sliding window 
window specification adjacent symbol positions string 
window length understood suffices specify start position 
number windows string length possible strings length alphabet 
subset denote sample normal strings 
subset denote complete set normal strings 
string packet generated time legitimate packet generating process 
manuscript received july revised march 
supported national science foundation dbi office naval research defense advanced projects agency agr intel santa fe institute nacional de ciencia 
recommended editor cook 
authors computer science department university new mexico albuquerque nm usa mail cs unm edu 
digital object identifier ieee malicious packet generating process 
random variable indicating generated hidden process governing generation packet sample dynamic sample instant string detector 
set detectors 
crossover closure generation rule window size projected window matches match rule scheme set strings windows scheme set strings window scheme set strings windows scheme set strings window anomaly detection normal behavior process characterized model deviations model called anomalies 
behavior approaches anomaly detection model normal behavior constructed observed sample normally occurring patterns 
models normal behavior represent set allowed instances positive detection set anomalous instances negative detection 
real problems set positive instances smaller set complementary ones 
wise derive representation smaller set enormous complement 
reasons negative detection merits consideration 
successfully engineering applications naturally occurring biological systems 
second assume closed world information theory perspective normal abnormal sets contain amount information suggests equally compact representations negative patterns 
third point negative detection allows detection process distributed multiple locations virtually communication required distributed components 
property allows forms distributed processing checking small sections large object independently independent detector sets running separate machine ieee transactions systems man cybernetics part cybernetics vol 
february fig 

self nonself discrimination 
universe data points partitioned sets self nonself 
negative detectors cover subsets nonself 
evaluating individual detector detector set independently 
scale anomaly detection problems increases need distributed processing grow 
original inspiration negative detection approach came natural immune system uses negative detection massively distributed environment body 
negative detection approach anomaly detection originally published negative selection algorithm modeled method natural immune system prevent 
immune system certain cells known cells undergo multistage maturation process isolated environment organ called thymus 
thymus cells censored normally occurring peptide patterns body called self 
cells react self deleted thymus active cause 
cells allowed mature leave thymus survive censoring operation 
cells circulate body freely independently eliminating material bind 
censoring process material implicitly assumed foreign known nonself 
translation mechanism algorithm computers straightforward 
assume anomaly detection problem posed set real self strings fixed length access sample time 
universe length strings referred set anomalous patterns detected set consider strings binary analysis generalizable larger alphabet 
candidate detectors generated randomly censored fail match strings retained active detectors 
detectors known negative detectors sample negative detector cover match subset nonself 
idea generating sufficient numbers independent detectors coverage nonself set obtained 
fig 
shows relationship sets pictorially 
algorithm learns distinguish set normally occurring patterns self complement nonself positive instances class available 
machine learning literature studied problem mature cells survived censoring operations involving genetic rearrangements involving positive selection 
learning examples single class concept learning positive examples 
principle learning problem solvable noise free classes certain formal domains practical cases problem known computationally intractable lead substantial overgeneralization 
statistical community examined closely related problems outlier detection robust statistics finding effectiveness learning system depends critically domain dependent assumptions distributions self nonself data 
example computer security context lane employed time series models user behaviors prior bias false alarms differentiate intruders authorized system users 
known change detection check sum algorithms solve restricted form anomaly detection problem known change detection 
self known exactly small stored single location remains constant time unambiguously distinguished nonself 
cases assumptions hold discrimination task challenging situations negative detection approach may appropriate 
interest negative detection growing especially applications noticing anomalous patterns important including computer virus detection intrusion detection industrial milling operations 
categories applications proposed including color image classification collaborative filtering evolutionary design 
underlying question negative versus positive detection advantageous negative detection scheme straightforward positive detection scheme 
date little theoretical analysis relative merits positive versus negative detection primary goal 
analysis complicated factors address 
important choice representation match rule 
set normal patterns represented 
anomaly detectors represented 
criteria determining detector detected pattern 
analysis complicated self set large distributed observe completely nonstationary self sets change time detectors changing time 
formal framework analyzing tradeoffs positive negative detection schemes terms number detectors needed maximum coverage 
earlier analyses focused cost generating detectors see section ii coverage provided complete set detectors 
discuss need partial matching rules generalization implies comparing positive negative detection 
review contiguous bits rcb matching rule common match rule negative detection 
introduce related match rule called chunks discuss advantages characterize generalizations induced terms concept known crossover closure see fig 
giving expected size crossover closure chunks 
formal framework positive negative detection schemes position compare quantitatively positive negative detection schemes chunks 
consider method increasing diversity coverage known permutation masks show permutation masks reduce number strings nonself set fixed detection threshold give quantitative results permutations required maximize effect 
consequence approximate scheme representing class explicit instances self set class implicitly contain instances original sample 
approximation advantage approximation said generalize set observed patterns useful class 
case anomaly detection new observations similar original sample self classified part self false positives reduced 
generalization poor new observations frequently misclassified leading high false positives false negatives 
partial matching rules specify approximation parameter controls large approximation interested characterizing precisely possible kinds generalizations induced partial match rules 
discuss entire set covered approximation refer generalization 
discuss individual strings generalization original sample refer holes strings valid fixed detectors generated 
ii 
related outlier detection problem arising machine learning data mining contexts 
abstractly families approaches identified 
outlier detection respect probability distributions attempts identify events low density regions probability distribution governing generation normal events 
approach refer statistical anomaly detection degree suspicion attached event inversely proportional frequency event observed historically 
second family approaches outlier detection attempts define measure distance event space 
common distance measures include classic norm hamming distances manhattan distance known rectilinear generalizes hamming distance nonbinary coordinate systems vector cosine measure salton 
approach degree suspicion attached event directly proportional distance event example nearest observed normal event center mass clusters normal events 
main difficulty applying statistical anomaly detection probability distribution known exactly estimated sample 
sample sparse making density estimation highly error prone 
applications majority events judge appear sample classified suspect main difficulty applying distance criteria construction measure reflects useful metric similarity 
poor choice measures results meaningless classifications 
implicitly explicitly approaches combined 
example data reduction transformations feature selection value aggregation collapse distinct events clusters events treated indistinguishable 
event assigned composite density cluster falls 
way events clustered classified suspect cluster composite density 
suspect events cluster previously encountered events forming low density cluster 
statistical anomaly detection problem intrusion detection computer security example 
intrusion detection systems vary widely seek protect information system single computer database server network computers violations system security policy 
case anomaly intrusion detection systems protection provided building model normal legal operation system treating discrepancies model anomalies 
model normal behavior observable behavior system 
audit logs patterns network traffic user commands system calls common choices 
approach anomalies normal operation correlated security violations 
extent true topic current debate intrusion detection community 
negative selection algorithm introduced method representing generating distributed sets detectors perform change detection 
negative selection algorithm demonstrated analyzed context rcb match rule partial matching rule strings similar hamming distance 
probabilistic expected case analysis algorithm performance case protected data detectors assumed static protected data randomly generated 
analysis relied assumption independently generated detectors independent detection capabilities 
algorithm illustrated problem computer virus detection noted observed performance real data sets significantly better predicted expected case analysis 
improved performance ascribed regularities protected data self 
reported linear time algorithm generating detectors linear number protected strings uses space threshold value length strings 
new algorithm addressed important limitation cost generating detectors original algorithm increased exponentially size protected data 
limits precision coverage possible plausible matching rules identified 
limits arise partial matching rules obscure boundary self nonself sets 
number gaps called holes certain partial matching rules counted lower bound size detector set needed achieve probability detecting abnormal strings estimated 
developed low space complexity algorithm generating optimal ieee transactions systems man cybernetics part cybernetics vol 
february repertoire detector strings included analysis holes coverage associated algorithm 
assumed protected data detectors unchanging time 
likewise projects focused problem generating detectors efficiently problem detectors needed maximal performance 
question addressed 
lamont applied negative selection problem computer virus detection focusing different match rules 
developed prototype implementation demonstrate approach scalable effective 
part evaluated different match rules including hamming distance rcb concluding rogers tanimoto rule extension hamming distance best fit application best job balancing generality specificity individual detector 
hofmeyr described network intrusion detection system incorporated modified form algorithm mechanisms including permutation maps achieve diversity representation 
experiments line consider dynamically changing data sets definition normal behavior incomplete nonstationary distributed environment 
setting network intrusion detection local area network detectors monitored flow tcp syn packets network 
original negative selection algorithm modified accommodate dynamic data sets detectors generated asynchronously allowed undergo negative selection live environment network 
intrusion detection system featured rolling sets detectors sense detectors generated different times potentially exposed slightly differing patterns self 
kim bentley implemented network intrusion detection system incorporates negative selection 
implementation significantly complicated representation larger alphabet shorter strings general matching thresholds lower contiguous bits matching 
hofmeyr original random generation method producing detectors 
reported difficulties generating valid detectors concluded negative selection infeasible realistic network intrusion detection 
propose explanations results largely analysis parameter settings selected 
williams report positive results negative selection network intrusion detection problem 
results approach closely parallel taken hofmeyr 
implementation goes monitors udp icmp packets tcp packets 
dasgupta gonzalez negative detection network intrusion detection problem 
worked lincoln labs data set real valued representation divided lincoln labs data overlapping intervals 
interesting compares performance positive negative characterization self reporting positive approach accurate computation ally expensive 
obvious meaningful comparison positive negative methods quite different 
positive detection method simply memorizes set training attack free points classifies test point normal distance memorized self point 
negative detection method uses genetic algorithm evolve complex rules detecting nonself 
study properly viewed comparing evolved rules simple memory approach 
addition intrusion detection authors interested negative detection applications 
negative detection color image classification finished wooden components specifically kitchen cabinets 
bradley tyrrell describe hardware implementation field programmable gate arrays fpgas 
detectors monitor transitions input output information finite state machines detect faults 
implementation uses negative detection rcb match rules 
detectors generated offline entire self set known time detectors generated 
chao forrest describe negative detection approach interactive search algorithms subjective evaluations drive exploration large parameter spaces 
algorithm learns parts search space useful negative detection strategy natural immune system 
algorithm capable finding consensus solutions parties different selection criteria 
set anomalous patterns known thought known exactly set signatures cover dangerous parts nonself precisely 
examples approach signature scanners intrusion detection commercial virus scanners 
iii 
statistical modeling framework section cast anomaly intrusion detection problem statistical framework 
unrestricted version framework quite complex useful view 
helps rigorous certain notions required allows evolve meeting broader objectives 
basic unit analysis length binary string called packet 
time step packet generated 
assume generated legitimate process malicious process reality number subprocesses contributing processes legitimate users different behaviors proceed single single precisely sequence length binary strings packets generated 
hidden process governs generation packet time random variable process generates process generates general may case distribution random variable depends sequences random variables identity particular time step remainder assume formal framework positive negative detection schemes distribution independent referred prior probabilities processes respectively unchanging time 
typically unknown packet distributions potential interest estimating distributions various assumptions introduced major focus 
pair distributions specify packet distributions respectively conditioned knowledge packets generated plus specification values process generated estimating distributions data amounts supervised learning problem label training data indicating process generated packet 
note probabilities related bayes theorem posterior distribution process generated current packet see section iii details 
note mixture distribution packet generated applications studied direct knowledge values random variables know certainty processes generated previous packets sequence leaving unsupervised learning problem 
particular concerned estimating pair distributions knowledge process priors knowledge distribution hidden process estimating pair distributions knowledge process priors 
problems ultimate objective identify short temporal groupings anomalous packets time intervals contain packets generated problems quality formulation supports analysis 
important special cases analysis shifts sequences packets single packets focus 
packet distribution process may depend current time step pattern packets generated time steps prior allows possibility nonstationary distribution depends actual time step identity packets previously generated processes 
nonstationarity reflect example 
composite user behavior changes time different populations users 
user behavior time depends behaviors times single user action depends prior actions 
nature attacks changes time 
changes environment new computer added network 
away question true distributions change time specifying posterior packet generated instant time dynamic sample instant focus situations suffices replace sample sample unordered set packets 
sample may include subset packets restricted packets deemed generated packets deemed restricted criteria recency random sampling 
sample may seeded initial population packets 
sample reflects current state knowledge time packet generated dependent knowledge sample distribution conditionally independent information previously generated packets 
sample changes time see packet distribution changes 
process changing time example state knowledge simply changing immaterial model 
sample unordered assumed generated representative detection question interest decide packet generated model address problem deciding subsequence embedded generated remainder consider simple family distributions sample modeling generates packet 
intuitively assume distance measure arbitrary packet current sample closer packet sample greater probability sample notions distance possible 
example distance packet sample minimum hamming distance member sample note measure distinguish members sample assigning string distance differentiate packets sample alternatively distance frequency counts distance sample reciprocal number instances sample defined large constant distance measure fails distinguish packets sample assigning ieee transactions systems man cybernetics part cybernetics vol 
february string distance differentiate packets sample course develop hybrid measures distance hamming distance strings outside sample distance frequency counts strings sample adopt simple categorical division similar sample versus dissimilar sample distinguish distance categories means generation rule attempts characterize underlying set sample drawn 
distance measures mentioned earlier generation rule allows distinction strings simplifies detection task considerably 
experimental studies shown simplifications capture sufficient detail process behavior provide effective detection 
definition generation rule mapping set length strings set length strings containing generalization discussed section generation rule wish specify distribution reflect member sample generated time 
simple alternatives exist care taken ensure proper probability distribution results 
example applications may appropriate probability set sample large multiplicative factor probability complement set 
construct probability distribution capturing relative frequency setting sample sample noting sample sample normalizing obtain proper point probabilities individual strings sample sample sample assuming strings complement sample set point probability member string greater string 
alternatively contexts sample larger complement necessary specify directly common point probability member sample large multiple common point probability normalize proper probabilities account number members nonmembers 
method set distribution assume sample specified sample sample sample satisfy final comment note modeling generation rule measure distance member set assumed fixed known exactly opposed dependent data probabilities assigned change sample changes time 
particular sample typically dependent previously observed packets evolving knowledge true image process distribution packet generated changes data changes 
example generating rules sample generation rules characterize underlying set sample drawn 
hamming radius generalizes sample strings hamming distance strings sample 
consider crossover closure generalizes sample strings constructed pasting windows strings appearing sample examine gram matching generalizes sample strings grams observed sample example hamming radius hamming distance measure discussed simplified categorical measure threshold particular generation rule defined set strings hamming distance member generation rule detection considered section vi 
hamming distance match rules negative detection context immunological modeling 
example crossover closure generation rule consider detail called crossover closure show subsequent sections crossover closure closely related match rules commonly conjunction negative detection 
set strings fixed crossover closure defined terms length windows consecutive string positions windows words string crossover closure windows exactly matches corresponding window member say closed crossover closure 
see class sets closed crossover closure central role methods 
interesting motivation crossover closure comes relational database theory 
strings sample sample viewed tuples current instance relation scheme attribute corresponds packet position domain 
example sample represented relation scheme current instance shown variety reasons reduce redundancy enhance data integrity advantageous represent relation scheme decomposition collection smaller relation schemes 
consider representing scheme decomposition schemes instance formal framework positive negative detection schemes projection equivalently exactly set strings comprising length window sample previous example instances follows order reconstruct original instance projections computes natural join case join projection recovers original instance fact join projected instances precisely crossover closure set tuples strings original instance example join instances shown results instance seen crossover closure strings original instance relational database theory exactly characterized projections join recover original instance see section vii 
known lossless join condition 
lossless join condition characterizes exactly set packets equal crossover closure 
interpretation correspondence naturally occurring collections information fact satisfy lossless join condition plausible contexts set strings generated closed crossover closure 
case sample representative sample strings generated interpreted sample drawn sample larger set containing sample closed crossover 
situations appropriate deem packets members sample relatively example grams gram matching rule wide variety settings including natural language processing document classification program monitoring intrusion detection 
application grams applied behavior protected process example executing computer program represented sequence letters taken alphabet 
sample normal behavior collection sequences called trace collected normal operating conditions 
different traces different lengths parsed sliding window size substring length gram stored program profile 
profile complete new execution analyzed terms grams composing trace 
gram occurs execution appear profile constitutes anomaly 
gram method described lookahead pairs method described 
order characterize generation rule grams restrict attention generalization induced traces length create directed acyclic graph dag levels level node distinct observed gram 
node label level connected node label level symbols match symbols akin previous example 
similar graphical construction determining multiple length grams 
set protected traces length retrieved traversing possible paths level graph 
write generalization induced traces size grams crossover closure see example 
restricting traces specific lengths generalization achieved gram matching expressed set acceptable lengths 
differences generation rule section iii 
considered strings specific length small assumption easily relaxed 
importantly section iii accept patterns previously observed particular window position grams disregard information window location 
computing posterior probabilities intrusion events general deciding generated requires distributions process priors previous considered models sample uniform strings versus models specific types malicious behavior 
modeling sample uniform conservative approach consistent view little prior information forms attack 
modeling uniform places constant numerator likelihood ratio sample sample equates posterior probability sample sample sample sample degree 
numerator expression posterior sample fixed constant sample varies varies 
identified approach literature commonly refers anomaly detection reported experimental results examples anomaly detection sufficient specific models malicious behavior necessary satisfactory detector performance 
ieee transactions systems man cybernetics part cybernetics vol 
february assume uniform 
assumption specify process priors detection threshold posterior sample simply prioritize packets likelihood generated rank packets values likelihood ratios gives ordering equivalent ranking posterior sample regardless values priors constant numerator likelihood ratio process modeled described previous section ranking packets likelihood ratios reduces partitioning packets classes generated generated interested compact schemes allow distinguish quickly low high probability anomalous packets 
family distributions proposed task equivalent distinguishing generation rule current sample sample packets contained sample outside set 
sections positive negative detection schemes addressing problem 
compare time space efficiencies variants schemes 
schemes simple efficient string matching rules deciding packet member sample iv 
taxonomy detection schemes section explores detection schemes framework outlined 
generation rule current sample sample instance detection scheme known simply detection algorithm able decide packet member sample detection algorithm viewed protecting subset sample strings sample regarded part self sample anomalous 
perspective formal languages detection scheme language recognition model analogous issues arising study formal languages interested construct detection scheme protect class languages implied particular generation rule interest determining class languages various detection schemes protect 
detection schemes constructed simple building blocks outlined far simple string matching rules alternative interpretations associated match 
proceeding analyze specific cases interest outline systematic taxonomy schemes 
taxonomy consists dimensions form single detector match rule binary relation detectors packets specifying single detector single packet match positive negative detection employed disjunctive versus conjunctive matchings single match sufficient trigger decision positive negative multiple matches required 
sections study relative power detection schemes constructed different choices dimensions 
compare classes languages protected schemes consider resources time space required schemes protect languages 
form detector matching rule single detector considered element chunk length binary string specified window position 
detector element interested primarily rcb match rule refer detectors rcb match rule rcb detectors 
section vi contrast rcb match rule hamming distance alternative match rule detectors chunk window matching rule consider detector operation set rcb chunk detectors assume corresponding matching rule previous subsection 
consider interpretation match packet detector 
particular match mean packet language positive detection denoted outside language negative detection denoted 
require single match packet disjunctive matching denoted match packet window positions conjunctive matching denoted 
combinations possible answers specify corresponding detection schemes denote choice choice specified collection detectors rcb chunk acts parameter instantiating detection scheme scheme particular interpretations scheme exactly defines set allowable strings scheme protects recognizes set flagging strings anomalous outside scheme language subset accepted detection schemes instantiated fixed set rcb chunk detectors defined follows negative disjunctive detection scheme scheme set strings windows positive disjunctive detection scheme scheme set strings window positive conjunctive detection scheme scheme set strings windows negative conjunctive detection scheme scheme set strings window formal framework positive negative detection schemes chunks matching subsumes rcb matching say language recognized scheme chunks rcb detectors exists set chunks rcb detectors scheme perspective language recognition necessarily efficiency chunk detectors subsume rcb detectors demonstrate 
lemma rcb detector exists collection chunk detectors proof take immediately 
result follows illustrate construction proof previous lemma contiguous bit detector shown equivalent set chunk detectors follows lemma detection schemes defined set strings recognized set rcb detectors recognized set chunk detectors 
particular theorem 
theorem set rcb detectors choices detector dimensions scheme scheme proof follows lemma membership predicates associated detection schemes scheme string satisfies satisfies converse theorem true general chunk detectors finer granularity rcb detectors proper subset may match fewer strings rcb example consider detection scheme scheme consider pair strings 
claim strings language scheme set rcb detectors string 
see note rcb detector matching pattern pattern way patterns completed specifying bit results rcb detector matching 
consequently scheme excludes language recognizes exclude 
contrast chunks detector set consists single detector scheme includes excluding 
results section imply result holds scheme class languages recognized scheme chunks detectors properly contains class recognized scheme rcb detectors 
detection schemes crossover closure theorem established simple set theoretic arguments helps clarify relationships classes languages recognized various detection schemes 
theorem set rcb chunks detectors denote complement relative universe rcb chunks detectors alphabet length detectors similarly complement set scheme subset taken relative scheme scheme scheme scheme scheme scheme scheme scheme subset containment proper follows scheme scheme class languages recognized scheme identical class recognized scheme rcb chunk detectors considered 
similarly follows scheme scheme class languages recognized scheme identical class recognized scheme rcb chunk detectors considered 
discussed section iii important detection applications protect crossover closure sample sample strong relationship crossover closure schemes scheme scheme chunk detectors 
sample subset denote set windows sample union projections sample window window size fixed understood 
denote set windows sample theorem 
theorem scheme scheme scheme sample proof scheme sample sample crossover closure exactly characterizes class languages recognized scheme scheme chunk detectors 
theorem 
theorem class languages recognized scheme scheme chunk detectors exactly class sets closed crossover closure 
proof set closed crossover closure construct set detectors windows follows theorem scheme scheme definition scheme scheme windows arbitrary set detectors 
construct set detectors window scheme projections follows scheme scheme theorem scheme scheme scheme scheme ieee transactions systems man cybernetics part cybernetics vol 
february results previous section imply rcb detectors scheme scheme recognize sets closed crossover closure sets closed crossover closure class languages recognized schemes rcb detectors properly contained class recognized chunks 
consider schemes scheme scheme chunks 
schemes recognize sets closed crossover closure recognize sets closed crossover closure 
see observe exist sets closed crossover 
example closed crossover 
contains length strings 
scheme scheme recognize sets closed crossover scheme recognizes set closed crossover closed crossover scheme scheme implies scheme recognizes scheme scheme recognize sets closed crossover scheme recognize set closed crossover closed crossover scheme scheme partial matching generalization section devoted scheme scheme chunks matching rule 
schemes recognize sets closed crossover different properties terms implementation requirements 
differences include distributivity scalability algorithm efficiencies 
section explores size detector set determines expected size function number strings randomly generated sample expected number unique detectors chunks set straightforward compute exactly detectors generated maximal protection positive negative detection schemes scheme scheme obvious generation method 
scheme requires counting number distinct patterns windows comprise strings scheme enumerating distinct patterns window result number detectors 
provide estimate average number detectors cases function size 
note number strings specific pattern window size probability selecting random string assuming small compared approximate probability randomly generated self set unique strings contain specific pattern fig 

number positive negative detectors function size self set assuming self set generated randomly 
plot shows complete reduced detector sets 
equation approximate considers trials independent sampling take place replacement 
previous item expected number distinct patterns window size approximated equation denotes expected size set detectors having property member matches window windows matched conversely expected number detectors possible negative detection scheme detectors match window pattern establish scheme requires smaller set detectors maximal coverage determine number strings schemes yield number detectors see fig 
solving primarily concerned binary strings worthwhile note arbitrary size alphabet equation generalizes affects point scheme preferable terms size detector set 
worst case scenario scheme may require detectors similarly scheme yield detectors self strings whatsoever 
reduced detector set negative detection number detectors needed scheme protect smaller full set described significant redundancy detectors may 
formal framework positive negative detection schemes examine property detail case binary alphabet 
number windows left right 
regardless composition detector generated pattern window window size starting second window pair patterns window 
self generate detector 
need generate detectors preceding window missing prefix detector previous window match strings pattern 
say generate detector string contains 
mind average number detectors needed minimal set previous rationale set upper bound number detectors required minimal set 
maximum number self strings creating crossovers reducing number required detectors exhibit pair patterns window 
results maximum distinct self strings detector set size fig 
shows plots expected number detectors full reduced detector sets 
reduced detector set size positive detection similar reasoning section find significant amount redundancy detectors form implicit matches 
consider case window contains patterns window patterns bits string matched window patterns matched window call match implicit match eliminate detector repertoire 
number detectors resulting set expressed size sample yield number detectors full repertoire 
subtlety analysis positive detectors represented explicitly additional information required identify implicit matches 
stored explicitly requiring bit implicit match derived runtime determining match implicit match window established absent window plot different information stored explicitly extra bits recovered decrease execution time 
fig 

crossover closure sample real self data 
sample sizes fig 
regard extra information required determine implicit matches 
crossover closure expected size useful way visualize generalization induced chunks detectors construct dag number distinct bit patterns length windows strings vertices labeled pair represents window number number edges edge stands bit pattern 
bits pattern match bits pattern representation crossover closure exactly set strings formed traversals graph levels take instance self set comprised strings see fig 

corresponding graph visual depiction graph omitting window number vertex labels recovering strings traversing preceding graph find order determine size randomly generated sample note number substrings length contain pattern window double number substrings length contain pattern window strings exhibit window stays exactly 
terms dag representation number paths include node label doubles labels window numbers recovered level topological sort 
ieee transactions systems man cybernetics part cybernetics vol 
february node outgoing edges 
write recurrence number windows solving recurrence yields 
probability node having outgoing edges 
order establish value consider gadget probability edge approximated absence likelihood node having outgoing edge independent probabilities related second node graph node level differing bit position consider probability node having outgoing edge similarly node gadget outgoing edges node absent probability individual node having outgoing edges number holes derived simply subtracting size generalization calculated size size detector set obtaining estimate substituting 
important note actual size depend structure specific self set 
analysis provides insight behavior see fig 
enables ascertain impact allowing novel strings sample 
useful determining dynamic scenario rate detectors added deleted working set 
vi 
permutations diversity additional mechanism introduced improve discrimination self nonself 
mechanism loosely modeled diversity major fig 

number holes function self sample size parameter settings 
graph left illustrates fast generalization increases small compared string length 
graph right shows generalization reached maximum number holes slowly decreases strings added sample 
complex mhc molecules natural immune system 
artificial setting multiple permutations length strings data detectors stored 
combined contiguous bits match rules provides system diversity representation improves discrimination abilities system 
permutation maps reducing number holes set holes large accurate discrimination unachievable 
hofmeyr introduced concept permutation masks way control size permutation mask reversible mapping specifies reordering bits strings network intrusion detection data set reported improvement detection ability factor permutation masks 
controlling number permutations able achieve greater control contiguous bits generalization 
interesting property transformation consider nonredundant permutation masks contiguous bits matching rule able protect strictly sets hamming distance 
theorem class languages recognized contiguous bits permutation masks properly contains recognized hamming distance 
proof strings length detector 
rcb function returns length longest run contiguous bits match strings string said match string rcb function returns hamming distance strings string matched string hamming distance rule differ bit positions hofmeyr dataset collected variant pure permutations computationally efficient 
formal framework positive negative detection schemes denote permutation string rcb denote class languages recognized rcb permutation masks detector set denote class languages recognized set detectors class languages recognized rcb permutation masks contains class languages recognized rcb permutations valid detector implies matches member rcb rcb permutation 
matches string show exists permutation matches rcb rcb 
label bits differ bits match define clearly valid permutation rcb valid detector rcb matches language recognized set detectors shown construct associated set permutations set detectors recognizes exactly rcb 
contrast recognize languages recognized rcb permutation masks detector match matches single permutation rcb fail valid detector example rcb generate valid detector match potential detectors hamming distance strings undetectable detectable rcb permutation masks rcb sets hamming distance recognize rcb rule may require multiple sets detectors transformation mechanism suitable detection scheme requires precise control generalization distributed 
illustrate permutation masks fact reduce number holes consider self strings crossover strings detector generated string distinctive window separates self apply permutation third bit position bit picture depicts generate detectors able match respectively 
table undetectable strings permutation set rcb matching rule table ii undetectable strings permutation set chunks matching rule completeness ask languages recognized rcb permutation masks 
strings nonself go undetected permutation mask employed 
answer question pointed practical match rules constant matching probability exhibit holes 
show construction languages recognized rcb matching permutations consider hole table lists possible permutations substrings detector constructed permutation 
seen table permutation available templates templates match string rcb scheme rcb scheme accept strings excluding construct examples difficult characterize set holes permutations 
lifting restriction detectors length enables chunk detector match string previous example 
languages recognized chunks matching rule scheme scheme augmented permutation masks 
consider scenario table ii lists permutations possible chunks detectors needed match general string detected scheme scheme permutation template combinations self 
template combinations string templates strings unspecified bits result possible ways specifying bits 
instance template combinations denotes don care easy see template exist exist permutation places bit positions contiguously creating contiguous bit pattern ieee transactions systems man cybernetics part cybernetics vol 
february vii 
discussion preceding sections developed formal framework studying tradeoffs negative positive detection theoretical results believe important wide variety practical problems 
section explore implications potential extensions theoretical results 
computer security applications past years number anomaly intrusion detection systems developed computer security explore different instances detection schemes described 
systems reviewed section ii positive detection negative detection 
likewise systems contiguous bits matching chunks gram matching variant gram matching known lookahead pairs 
negative selection strategy immune system received great deal attention noted immune system uses positive selection combining advantageously negative selection 
cases experimental evidence preferring scheme 
example grams outperformed lookahead pairs early data sets terms absolute discrimination ability unpublished 
efficiency matters case online detection lookahead pairs method clear winner paying small penalty terms discrimination ability 
second example occurred compared rcb detection chunks network intrusion detection task 
results anecdotal sense obtained experimentally testing methods limited number data sets 
theory guide difficult determine result depends particular data set depends choice method 
likewise difficult determine aspects detection scheme responsible success failure negative detection match rule parameter settings 
results allow approaching questions theoretical perspective 
particular notion crossover closure relation rcb chunks matching allow understand deeply matching methods preferable familiar methods hamming distance 
likewise closed form expressions detector set sizes positive negative detection allow time predict large problem pays negative detection scheme 
negative detection approach somewhat curiosity notorious immunological metaphor demonstrated advantages methods 
results form basis objective evaluation 
relational databases section iii introduced relationship crossover closure relational database theory 
specifically showed crossover closure set strings equivalent natural join strings interpreted tuples projected relational decomposition scheme 
aspects equivalence find interesting 
characterize set strings closed crossover closure terms studied structural properties known database dependencies 
set strings closed crossover closure exactly decomposes relation schemes induced length windows showed section iii 
structural characterization lossless join decomposition complex general case specialized form decomposition simplifies condition considerably characterization reduces adherence collection simple multivalued dependencies original relation scheme order decomposition lossless multivalued dependencies hold note example multivalued dependency asserts contains tuples contain tuples condition describes semantics collections information occur naturally vast number diverse application domains 
dependencies arise naturally sets strings wish protect remains investigated 
connection step investigate correspondence schemes scheme scheme recognize class sets closed crossover closure query systems relational databases 
particular able recognize set detectors possibly significantly pruned remove redundancy described section set closed crossover closure represent means instance relation scheme obeying dependencies specified 
negative detection scheme scheme appropriate membership queries scheme appropriate queries requiring enumeration formal framework positive negative detection schemes member tuples 
conversely known results database theory regarding minimal representations translate lower bounds time space requirements detection schemes 
dynamic samples mentioned section iii expect samples distribution packet generated change time 
factors contributing include 
sample may part sample sample properly contains sample consequently distribution string generated time differs assumes mechanism deciding generated despite fact flag low probability string passes investigative step 
want delete packets sample occurred 
alter sample distribution string generated time extending analytical treatment include dynamically changing samples raises number questions 
principle new sample created time new set detectors generated de novo 
extremely inefficient 
area investigation analyze techniques update detector set response specific types perturbations sample 
distance measures define metric match rule detection schemes rewritten terms distance measure 
instance chunks scheme scheme scheme scheme number windows string string interested exploring schemes intermediate conjunctive disjunctive detection positive negative 
intermediate schemes string may treated self window patterns observed scheme threshold 
intuitively strings differ small amount sample part differ lot 
extending idea step imagine distance measures assign uniform value match take account structural statistical properties sample order weigh relative merits distinct matches 
implementation issues emphasized representational power different detection schemes important implementation considerations affect choice match rule detection scheme 
briefly discuss chunks match rule contrast rcb shown section iv class languages recognized distinct 
comparison highlights important properties chunks 
far described detection schemes set detectors find useful visualizing analyzing properties second consider applications benefit distributing nodes assumptions location 
important note large body regarding string matching suggests efficient representation detectors algorithms operate impose additional restrictions ease distributing 
mind consider implementation issues cost generating detectors cost storing detectors cost locating detectors 
detector generation self set straightforward method generating appropriate chunks detectors search entire sample determine patterns window requiring time space 
note detector set sorted generation extra cost bin sort assuming 
algorithms proposed generating detectors rcb match rule report linear generation time extra space 
detector storage intuitively chunks requires space rcb rcb detector bits decomposed chunks detectors bits 
depending particular structure significant number repeated patterns window set rcb detectors 
chunks represents distinct pattern lead smaller space requirements cases 
general space required chunks detector location having detectors specific window chunks allows stored sorted order window 
checking see string belongs self requires time inserting deleting detector just potential hashing schemes reduce search time 
crossover closure genetic algorithms tantalizing connection crossover closure described crossover operator genetic algorithms 
crossover closure contains subset possible point crossovers self set generalization achieved contiguous bits identical space coordinate hyperplanes defined crossover operator 
likewise chunks matching rule restricted form schema notation explain genetic algorithm behavior 
additional area investigation connections precise determine schema theorem genetic algorithms bears relation processing performed contiguous bits match rules 
ieee transactions systems man cybernetics part cybernetics vol 
february viii 
formal framework analyzing different positive negative detection schemes context approximate matching 
framework quite general primary application mind anomaly intrusion detection example detecting anomalous tcp connections local area network detecting anomalous patterns system calls executing processes 
gave examples different partial matching rules fit scheme including hamming distance contiguous bits grams 
characterized generalization induced contiguous bits relative chunks defining crossover closure sample length strings 
showed crossover closure related concept lossless join relational database theory 
formal apparatus place able give theoretical results relative power different detection schemes matching rules 
particular showed chunks match rule subsumes contiguous bits matching rcb chunks class languages recognized negative disjunctive detection positive conjunctive detection crossover closure sample exactly characterizes class languages recognized negative disjunctive detection positive conjunctive detection chunks matching 
considered number detectors required provide maximal discrimination fixed scheme scheme gave closed form expressions schemes allowing time estimate large self set negative detection computationally advantageous strategy 
discussed expected size crossover closure explored permutations representation reduce size crossover closure 
showed class languages recognized contiguous bits augmented permutation masks properly contains recognized hamming distance showed permutations languages recognized contiguous bits matching 
theoretical results significant address large quickly expanding body experimental intrusion detection uses detection schemes 
hope theoretical results easier understand experimental results predict approaches promising problems 
acknowledgment authors holland tyrrell langdon anonymous reviewers comments greatly improved presentation 
forrest perelson allen self nonself discrimination computer proc 
ieee symp 
research security privacy los alamitos ca 
forrest hofmeyr somayaji longstaff sense self unix processes proc 
ieee symp 
computer security privacy 
haeseleer forrest helman immunological approach change detection algorithms analysis implications proc 
ieee symp 
computer security privacy 
dasgupta forrest novelty detection time series data ideas immunology proc 
int 
conf 
intelligent systems 
hofmeyr somayaji forrest intrusion detection sequences system calls comput 
security vol 
pp 

smith forrest ackley perelson variable efficacy repeated annual influenza vaccination proc 
national acad 
sciences pnas vol 
pp 

hofmeyr forrest immunity design artificial immune system proc 
genetic evolutionary computation conf san francisco ca pp 

architecture artificial immune system evol 
comput 
vol 
pp 

somayaji forrest automated response system call delays proc 
usenix security symp 
forrest glickman lisys parameters normal behavior proc 
congr 
evolutionary computation 
forrest glickman coverage generalization artificial immune system proc 
genetic evolutionary computation conf 
chao forrest aesthetic immune system tentative title proc 
artificial life viii th int 
conf 
simulation synthesis living systems may 
haeseleer immunological approach change detection theoretical results proc 
th ieee computer security foundations workshop 
hofmeyr immunological model distributed detection application computer security 
albuquerque nm univ new mexico press 
williams anchor lamont cdis computer immune system detecting network intrusions proc 
fourth int 
symp adv 
intrusion detection lee wespi eds berlin germany pp 

kim bentley evaluation negative selection artificial immune system network intrusion detection proc 
genetic evolutionary computation conf san francisco ca pp 

generating optimal repertoire antibody strings artificial immune system intelligent information systems michalewicz eds 
heidelberg germany new york physica verlag pp 

discriminative power receptors activated contiguous bits rule comput 
sci 
technol vol 
pp 

deriving concise description nonself patterns artificial immune system new learning paradigm soft computing jain eds 
heidelberg germany new york physica verlag pp 

lee stolfo data mining approaches intrusion detection proc 
th usenix security symp 
agent architecture computer virus immune system proc 
gecco workshop artificial immune syst dasgupta ed 
lamont van veldhuizen distributed architecture self adaptive computer virus immune system new ideas optimization 
london mcgraw hill advanced topics computer science series pp 

burgess measuring system normality scales characteristics 
characterizing behavior program grams proc 
new security paradigms workshop cork ireland 
kearns vazirani computational learning theory 
cambridge ma mit press 
schlimmer concept acquisition representational adjustment 
irvine ca univ california press 
learning regular sets queries counterexamples inform 
comput vol 
pp 

lane machine learning techniques computer security domain anomaly detection 
west lafayette purdue univ press aug 
formal framework positive negative detection schemes lincoln laboratories 
darpa intrusion detection evaluation 
online www ll mit edu ist ideval index html bradley tyrrell architecture hardware immune system third nasa dod workshop evolvable hardware stoica eds 
long beach ca ieee computer society press july pp 

hardware immune system benchmark state machine error detection proc 
congr 
evolutionary computation honolulu hi may 
novel finite state machine architectures built self test self nonself differentiation ieee trans 
evol 
comput vol 
pp 
june 
dasgupta gonzalez immunity technique characterize intrusions computer networks ieee trans 
evol 
comput vol 
june 
artificial immune systems approach real time color image classification problem proc 
ieee int 
conf 
syst man cybern 
statistical anomaly detection httpd data analysis comput 
statist 
data anal published 
tan maxion defining operational limits stide anomaly intrusion detector proc 
ieee symp 
security privacy 
oakland ca ieee press 
cell tolerance clonal elimination thymus cell vol 
pp 
apr 
perelson predicting size antibody combining region consideration efficient self nonself discrimination proc 
nat 
acad 
sci vol 
pp 

probability self nonself discrimination theoretical experimental insights immunology perelson eds 
new york springer verlag 
brown della pietra de souza lai mercer class gram models natural language proc 
ibm natural language itl paris france 
denning intrusion detection model ieee trans 
softw 
eng vol 
se feb 
teng chen lu adaptive real time anomaly detection inductively generated sequential patterns proc 
ieee symp 
research computer security privacy los alamitos ca 
javitz valdes sri ides statistical anomaly detector proc 
ieee symp 
research security privacy pp 

javitz valdes lunt tyson generation intrusion detection expert system nides 
menlo park ca sri int 
helman liepins richards foundations intrusion detection proc 
fifth computer security foundations workshop nh pp 


snort 
online www snort org damashek gauging similarity grams language independent categorization text science vol 
pp 

agrawal raghavan linear method deviation detection large databases proc 
nd knowledge discovery data mining pp 

barnett lewis outliers statistical data 
new york wiley 
eskin anomaly detection noisy data learned probability distributions proc 
th int 
conf 
machine learning san francisco ca pp 

fisher knowledge acquisition incremental conceptual clustering machine learning vol 
pp 

freedman statistics 
new york norton 
garcia molina ullman widom database systems complete book 
englewood cliffs nj prentice hall 
hanson bauer conceptual clustering categorization machine learning vol 
pp 

helman liepins statistical foundations audit trail analysis detection computer misuse ieee trans 
softw 
eng vol 
pp 
sept 
helman statistically system prioritizing information exploration uncertainty ieee trans 
syst man cybern vol 
pp 
july 
helman gore prioritizing information discovery phenomena intell 
inform 
syst vol 
pp 
sept oct 
mosteller tukey understanding robust exploratory data analysis 
new york wiley 
jain dubes algorithms clustering data 
englewood cliffs nj prentice hall 
kaufman rousseeuw finding groups data 
new york wiley 
knorr ng unified approach mining properties computation proc 
rd knowledge discovery data mining pp 

algorithms mining distance outliers large databases proc 
th vldb pp 

maier theory relational databases 
new york computer science press 
ng han efficient effective clustering methods spacial datamining proc 
th vldb pp 

salton mcgill modern retrieval 
new york mcgraw hill 
tou gonzalez pattern recognition principles 
reading ma addison wesley 
gusfield algorithms strings trees sequences computer science computational biology 
cambridge cambridge univ press 
pf smola learning kernels 
cambridge ma mit press 
carla 
characterizing behavior program multiple length grams 
proc 
new security paradigm workshop 
online ftp ftp com documents pdf fernando received degree computer engineering instituto aut de mexico city soon receive masters degree instituto de en matem sistemas unam mexico city 
currently pursuing ph degree university new mexico albuquerque 
research interests biologically inspired adaptive systems machine learning 
stephanie forrest received degree st john college santa fe nm ph degrees university michigan ann arbor 
currently professor computer science university new mexico unm albuquerque member residential faculty santa fe institute 
joining unm palo alto ca director fellow center nonlinear studies los alamos national laboratory los alamos nm 
research interests adaptive systems including genetic algorithms computational immunology biological modeling computer security 
paul helman born brooklyn ny 
received degree dickinson college carlisle pa degree stanford university stanford ca ph degree university michigan ann arbor 
currently professor computer science university new mexico albuquerque 
research interests include bioinformatics machine learning data mining database theory combinatorial optimization 
authored computer science text books walls mirrors intermediate problem solving data structures menlo park ca benjamin cummings science database management burr ridge il richard irwin 
