code reuse polymorphic variants jacques november support code reuse object oriented languages popular 
succeed equally areas particularly data complex structure making hard keep parallel data code 
hand functional programming languages separate data code better handling complex structures provide direct ways reuse code different datatype 
show way achieve code reuse data code separated 
method illustrated detailed example 
design complex programs bump difficult dilemma privileged type safety code reuse 
maintaining complete type safety forces specialize code making difficult reuse similar situations 
decrease reuse may mean difficult maintenance tracing logical bugs 
hand trading safety reuse means weaker help type system maintenance potential runtime type errors 
typical instance dilemma variant types 
way supported typed functional languages strong typing pattern matching tremendous help maintaining program 
type checker able detect potential type errors match compiler warn forgotten redundant cases particularly useful modifying variant type 
means support code reuse 
textual copying subtyping 
want duplicating code working incompatible types weaken discipline allow potential match failures 
object oriented languages support variant types instanceof statements visitor patterns 
case means type checking deferred runtime second case rigid typed functional approach 
cases lack exhaustivity checking available functional languages force scatter code various objects program harder understand functional approach 
objective caml typed functional language object oriented extensions provides solution problem polymorphic variants flexible form variant types 
show applied concrete example incremental construction evaluator lambda calculus extended arithmetic operations 
japan idea example originally comes post phil wadler java genericity mailing list proposed solution expression problem problem extending variant type new constructors recompiling code old ones 
similar problem solution kff untyped 
appeared wadler solution supposed extension generic java extension java typed 
didier vouillon came typable solution object oriented extension rd order typed lambda calculus checked correct haruo hosoya rec 
hand provide shorter solution lines objective label polymorphic variants merged objective caml 
solution standard ml polymorphism weakened nd order typed lambda calculus inferred automatically 
presenting solution expression problem point view polymorphic variants toy example choose full problem addressing issues functionals iterators multiple inheritance shared base class 
hopefully give better idea expressive power polymorphic variants 
variants functional programming algebraic datatypes known sums variants essential features strongly typed functional programming languages 
usually type defined functions defined handle program 
example frequently variant type lists type list nil cons list defines constructors nil cons different arities argument types 
type parametric type elements list 
list integers cons cons nil val int list define functions datatype instance computing length list 
rec length function nil cons hd tl length tl val length list int length depend type elements function naturally polymorphic type 
applied instance list 
interesting functions class easy define various kind iterators functionals take function argument apply appropriately contents type 
iterators build new list polymorphic type list type result 
examples processed objective caml caml inria fr ocaml 
examples lines starting val printed italic part program type information output compiler 
mixed input help understanding programs contain little type information 
rec map function nil nil cons hd tl cons hd map tl val map list list functionals play important role avoiding code duplication factoring operations structural logical part 
may get wrong idea variant types defined admit form inheritance difficult extend 
fact power type checking match analysis just contrary easily add case existing variant type compiler help step step find places modified 
instance suppose want extend lists handle concatenation 
add new constructor conc type list nil cons list conc list list try recompile functions get warning 
warning pattern matching exhaustive 
example value matched conc warnings just add missing cases needed scattering definitions program problem 
rec length function nil cons hd tl length tl conc length length val length list int polymorphic variants variants proved powerful tool program development maintenance strength weakness 
allows thorough checking means possible way reuse code textual copy 
experience shows practical cases point view software engineering prefer able share code different extensions variant type 
polymorphic variants gar introduced permit flexible variants 
main conceptual difference constructors longer tied single type exist independently type definitions 
instance value var previous definition 
var val var string objective caml polymorphic variant constructors distinguished usual variants backquote front name 
types written similar way wrapped square brackets type descriptions may appear directly type var var string table variables common languages eval var sub var var try list assoc sub val eval var string var string list var inside normal type expressions function types tuples 
left type means type fully specified may contain constructors 
course may define fully specified types appears table constrain partially specified values 
symmetrically values pattern matchings partially specified types allow polymorphism 
function var string length num val var string num int int type means accepts var num input polymorphic way 
pattern matching extended order allow dispatching sets constructors individual basis 
combination mechanisms uses patterns refine types allows directly type names patterns 
function var num val var string num var string num var derived type definition var stands shorthand var string 
explains string appears type num specified argument type 
magic part split var num cases independent types passed functions main example 
application modular evaluator extended lambdacalculus example intended illustrate expressive power polymorphic variants respect traditional variants typed object oriented languages 
demonstrates capacity system kept simple fit operation eval expression decorated 
real size example multiple operations dependencies cleanly encoded objective caml class system variant dispatch works decorated tree 
code complete tables include code program directly compiled objective caml 
just remove phrases starting val output compiler 
table lambda calculus type lambda var string abs string app gensym ref fun incr string int eval lambda eval rec subst lambda function var eval var subst app eval rec subst match eval rec subst abs body eval rec body app abs gensym abs eval rec var subst val eval lambda string var string abs string app list string list lambda rec eval subst eval lambda eval subst val eval string lambda list define basic language containing variables table 
evaluation language means looking environment binding associated variable name keeping 
notice dispatch single case type eval var var string var 
form denotes type shared environment list result eval var 
define lambda calculus extending basic language table 
notice careful define lambda open recursive type subterms type open recursion eval lambda able extend definition 
case eval lambda just delegating eval var 
return type eval var polymorphic compatible branches may return abs app 
see pattern eval var input type eval lambda lambda output type var string abs string app extensible version lambda 
build specific evaluator eval lambda closing recursion 
notice closes recursion type level input output types lambda eval app abs var var val lambda var lines define expr language adds numbers addition multiplication basic language table 
traditional variants comes handy define map function uniformly applies function subterms expression 
table expr language arithmetic expressions type expr var string num int add mult map expr expr function var num add add mult mult val map expr var string num int add mult expr eval expr eval rec subst expr match map expr eval rec subst var eval var subst add num num num mult num num num val eval expr string var string num int add mult list string list expr rec eval subst eval expr eval subst val eval string expr list see evaluation quite different lambda evaluate subterms redexes apparent pattern match 
define evaluator eval closed language expr eval add mult num num var val expr add num var take union lambda expr create full evaluator table 
types inferred compiler takes lines eval dispatch constructors lambda eval lambda constructors expr eval expr 
simple may overlook doing multiple inheritance shared common ancestor var language 
languages share semantics variables causes complication 
language extensible 
evaluator language eval 
eval add app abs mult var var num num val num table language lambda expr type var string abs string app num int add mult eval eval rec subst function lambda eval lambda eval rec subst expr eval expr eval rec subst val eval string num int abs string add app mult var string list string list rec eval subst eval eval subst val eval string list comparison approaches interesting see hard encode example traditional variants 
standard way produce union types embed type containing constructor 
table give types encoding sample code 
problem see immediately looking type definitions approach support multiple inheritance properly contains type variables lambda expr vare 
due fact traditional variants provide disjoint sum union polymorphic variants provides coalesced sum required handle sharing common ancestor multiple inheritance 
problem need lot wrapping unwrapping types working pyramid languages var directly compatible expr lambda turn incompatible 
basically functions extra arguments wrap unwrap doing administrative 
contrary problem multiple inheritance solved uniformly coalesced sums workaround cost verbosity 
instance eval omitted help understanding requires lines code polymorphic variants just lines 
comparing object oriented languages say 
difficult typecheck simpler version expression problem rd order type system required stated example adds large number difficulties 
independently problem types translation example object oriented style visitor pattern going verbose extent giving snippets code difficult 
table encoding normal variants type var string type lambda var abs string app type expr vare var num int add mult type lambda lambda expr expr eval var wrap sub var try list assoc sub wrap val eval var var var list var eval expr eval rec wrap unwrap subst map expr eval rec subst match map expr unwrap vare eval var fun wrap vare subst add num num wrap num mult num num wrap num wrap val eval expr var list expr expr option var list expr demonstrated polymorphic variants allow combine benefits algebraic datatypes clean separation code data pattern matching refined type checking code reuse level simplicity comparable objectoriented languages 
added expressive power significant encoding traditional variants object oriented style incur problems ranging loss clarity major increase verbosity type theoretical limits absence coalesced sums traditional variants need higher order typing object oriented style 
gar jacques 
programming polymorphic variants 
ml workshop baltimore september 
kff shriram mathias felleisen daniel friedman 
synthesizing object oriented functional design promote re 
technical report department computer science rice university april 
preliminary version european conference object oriented programming 
xavier leroy damien doligez jacques didier vouillon 
objective caml system release documentation user manual 
projet inria april 
philip wadler expression problem 
discussion java genericity mailing list december 

