playing rules rewriting practical optimisation technique ghc simon peyton jones andrew tolmach tony hoare microsoft research st george house st cambridge cb nh england dept computer science portland state university box portland usa describe facility improving optimization haskell programs rewrite rules 
library authors rules express domain specific optimizations compiler discover 
compiler generate rules internally propagate information obtained automated analyses 
rewrite mechanism fully implemented released glasgow haskell compiler 
system simple effective optimizing real programs 
describe practical applications involving short cut deforestation lists rose trees document substantial performance improvements range programs 
optimising compilers perform program transformations improve efficiency program 
compiler relatively shallow reasoning guarantee correctness optimisations 
contrast programmer deeper information program intended behaviour 
example programmer may know integer type infinite precision integers int bit integers compiler little chance working 
programmers write expressions email simonpj microsoft com performed part visiting microsoft research email apt cs edu email microsoft com peyton jones tolmach hoare easily appear aggressive inlining brings code written separately 
explore simple idea allow programmer specify program properties compiler improve performance treating property rewrite rule 
effect give programmer ability extend compiler domain specific optimisations giving specialised knowledge particular vocabulary functions heavily particular program 
setting purely functional language haskell lack side effects possible state properties simply complex side conditions exploit local information 
contributions describe concrete design fully implemented released glasgow haskell compiler optimising compiler haskell section section 
describe practical applications technique perform list fusion haskell standard prelude section perform tree fusion application specific library section 
show rewrite rules generated automatically result compiler analyses constitute useful way exploit specialised versions functions section 
idea allowing programmer specify domain specific compiler extensions new section widely successful 
principal selling point simplicity 
rewrite rules expressed declaratively syntax haskell separate meta language 
simple order pattern matching side conditions applied trivial strategy 
effective real programs assuming cooperation library writers 
currently attempt verify programmer specified rules consistent underlying function definitions purport describe 
programmer adds rule implicitly incurs proof obligation way user ghc unsafeperformio 
addition rule effect program performance tricky predict 
reasons rules mechanism form primarily intended expert programmers library authors understand ghc optimization behavior 
having rules explicitly codified raise possibility feeding program theorem prover having prove rules consistent implementation human assistance explored avenue far 
adding explicit equational properties programs advocated purposes 
serve document intended behavior program independently implementation peyton jones tolmach hoare explore efficient algorithms design methodology reduces incidence programming error 
advantage may testing debugging programs play role test oracle :10.1.1.47.1361
additional incentive efficiency gains compilation help convince world equational specification worthwhile part programming process 
basic idea consider familiar map function applies function element list 
written haskell map looks map map xs map xs suppose compiler encounters call map map map xs know expression equivalent map xs function composition know expression efficient intermediate list 
compiler knowledge 
possible compiler smarter expert programmer know things compiler 
suggestion allow programmer communicate knowledge directly compiler 
direction explore 
glasgow haskell compiler ghc allows programmer add rule program rules map map forall xs 
map map xs map xs 
brackets enclose pragma ignored compiler 
rules keyword identifies pragma defining rewrite rule 
map map part arbitrary string names rule name reporting rules fired compilation run diagnostic mode 
body rule expresses identity map map xs map xs forall part identifies variables rule body universally quantified xs case constants bound map case 
peyton jones tolmach hoare general form programmer specified rule name forall 
vm tm 
en 
name string identifying rule described 
vi bound variables associated types ti types omitted required rule type check entire forall clause omitted bound variables 
unquantified function constant identifier forall variables ei arbitrary haskell expressions 
rules pragma occur top level program free variables rule sides equation scope 
regard rules function extra redundant equations defining function map map xs map xs map map xs map xs ordinary defining equations course rules restricted having constructors patterns left hand side 
rewrite rules express identities programmer knows true ghc assumes oriented right hand side preferable left 
compilation ghc tries spot instances left hand side rule rewrite call right hand side 
assumptions ability add rewrite rules program pretty powerful weapon raises host issues 
particular ghc attempt verify rule consistent underlying function definitions apart ensuring left right hand sides rule type 
point rule asserts ghc smart 
rule implementation disagree implementation just wrong rule 
want rule true concrete sense 
example consider data type sets 
sound give rule expressing fact union sets commutative 
suppose implementation represents set unordered list 
concrete representation union may differ union represent sets 
ghc attempt ensure right hand side efficient left hand side 
say simply write true properties compiler optimise program offer 
discuss section peyton jones tolmach hoare rely fallible programmer specify oriented rewrite rules simple rewrite strategy 
rules effectively requires understanding ghc works 
ghc attempt ensure set rules confluent terminating 
example rule send ghc infinite loop encounters call foo 
rules commute forall foo foo considerable literature proving confluence termination sets rewrite rules particular commutativity associativity received special study 
matters seriously complicated automatic rewrites compiler performs beta reduction inlining case switching floating able take direct advantage 
optimising compiler confluence strong suggest canonical optimised form program 
termination certainly important proved problem practice 
restrictions noted pattern left hand side rule function application fixed function constant 
example plausible rule write rules forall 
illegal 
rule illegal left hand side function application 
restriction advantages 
underpins idea introduced rewrite rule simply extra redundant equation defining function 
second rule matching efficient rules indexed function left hand side 
call ghc need check matches rules left hand side rule arbitrary expression matching efficient 
function application restriction mean rules replace ghc built transformations 
inlining floating beta reduction case swapping case elimination complex explain restricted language rules 
compiler transformations specialisation rules prove directly useful discuss section 
peyton jones tolmach hoare library writers library clients reading assumptions restrictions reasonably ask rewrite rules going practical 
certainly easy shoot oneself foot 
reason regard set rewrite rules domain specific compiler extension general programming paradigm 
expect rewrite rules written mainly author library 
authors go great lengths craft efficient data structures algorithms 
rewrite rules give ability explain deep truths code compiler extend ability optimise client programs 
assume willingness cooperate optimisation extent adapting library code take advantage optimisation rules way round 
return hope preserve level simplicity correctness optimisation rules effectiveness unfortunately easy establish clauses declarative program 
ghc rewrite rules defined module embedded meta data hi file accompanies module object code 
client library sees rules ghc optimise compositions calls functions supplied library 
rules explicitly exported imported 
compiling module ghc see rules module imported module imported imports transitively 
haskell instance declarations exactly property 
rule required module function definition extends 
example map map rule module defined map 
rules incrementally extend function definition 
important rule may describe interaction imported function defined locally 
rules class member function case corresponding function class instance 
rewrite rules perfect sense library written language case rules express facts foreign library 
example reid graphics library haskell provides section user manual devoted algebraic optimisation laws satisfied library interface 
rules practice rest report experience applying rewrite rules practice 
main classes applications programmer written rules library code 
initial motivation achieve list fusion section ambitious peyton jones tolmach hoare tree fusion section 
automatically generated rules derived kind program analysis invisibly programmer section 
unexpected persuasive practical benefit implementing rewrite rule technology 
short cut deforestation initial motivating example adding rewrite rules case list fusion 
earlier gill launchbury peyton jones described socalled short cut deforestation technique eliminating intermediate lists programs 
centre method single rewrite rule foldr build foldr foldr foldr xs foldr xs build forall 
build rules foldr build forall forall foldr build definition foldr conventional 
function build takes list functionally abstracted cons nil constructors applies ordinary list constructors return ordinary list 
type rank polymorphic type discussed specify explicitly order rule type check 
rule states foldr consumes result call build eliminate intermediate list applying directly give example applying rule write list consuming producing functions foldr build respectively 
example sum sum int int sum xs foldr xs int int build cons nil nil cons nil cons cons nil peyton jones tolmach hoare definition sum terms foldr conventional :10.1.1.100.9674
function returns list integers argument 
express call build auxiliary function abstracted functions uses construct result 
called functions cons nil old times sake simply formal parameters names insignificant 
somewhat inconvenient write sum way task author list library 
try fusion call sum sum inline sum foldr build apply foldr build rule intermediate list eliminated arithmetic directly 
real albeit small example list fusion works programmer bulk operations lists effective 
example taken verbatim code small program computes list hydrocarbon size partitions int int int int partitions div div test harness main print length partitions form haskell notation list integers list comprehension builds list triples drawn list div drawn similar list computed directly test harness prints length applying partitions 
ghc translates range notation application build 
translates list comprehension build foldr consume sub lists 
prelude library function length implemented foldr 
program intermediate lists removed leading dramatic drop allocation 
fusion program allocates mbytes peyton jones tolmach hoare fig 

distribution fusion effects programs real spectral divisions nofib benchmark suite ghc 
fusion enabled allocates mbytes 
allocation fused version stack length computation properly tail recursive stack grows activation records 
benchmark results broader range programs nofib benchmark set effect enabling list fusion shows 
fusion measurable effect programs gives useful reduction allocation 
programs worse worst 
program parser called parstof shows reduction turns fusion transforms artificial outer loop benchmark causing sample text input parsed times 
geometric mean improvement omit parstof low 
compiler optimisations therapeutic drugs 
antibiotics effective programs optimisations tend built compiler 
targeted particular diseases effective effect programs 
rules mechanism allows library authors add targeted domain specific optimizations modifying internals compiler 
hope programmers may adopt modular programming style expect fusion take place 
example clearer write concat map xs write foldr xs peyton jones tolmach hoare programmers write form build intermediate list 
section gives extended example way fusion modular programming practically efficient 
note measurements relate un modified benchmark programs 
functions programs build fusion occurs compositions functions standard prelude functions re implemented foldr build 
compiler transform user written functions foldr build see greater benefits scope case certainly require compiler modification 
theory practice sticky details far implied simply needs add rewrite rule reimplement key functions foldr build 
practice encountered number obstacles discuss section explaining implementation rewriting 
implementation implementation rule rewriting mechanism ghc largely straightforward 
front extended handle rule parsing type checking translation core intermediate language 
ghc optimiser structured number separate passes core expressions 
fundamental pass iterated times simplifier performs inlining case simplification eta expansion course single top bottom traversal program 
support rewriting just modified simplifier check function application encounters list active rules application matches rule lhs pattern replaced suitably instantiated version rhs 
matching performed modulo eta reduction application matches rule head need take little care sure rule remains attached right function alpha renaming takes place 
including rules adds modest overhead ghc compilation time 
example list fusion rules described section increases compilation times average nofib benchmark suite 
increase probably due performing conventional optimisations enabled rule rewrites 
case serious attempt analyse optimise aspect compiler performance probably sped prove important 
peyton jones tolmach hoare phases obstacle faced defining rules subtle interaction function inlining transformation ghc aggressively rule application 
returning sum example see sum inlined rule fire 
hand foldr build inlined 
example inlining build firing rule give foldr lost fusion opportunity 
run opportunities foldr build rule inline build 
recall definition small higher order build inlining function beneficial explicit lambda 
considerations led initially phase strategy black list function appears left hand side rule 
run simplifier applying rewrite rules refraining inlining black listed functions 
ii empty black list repeat exercise previously functions inlined 
alas phases necessarily 
general program uses layers data types implemented layer 
want apply rewrite rules top level adt want expose implementation compiler course inlining apply rewrite rules layer want inline layer apply rewrite rules layer 
organising rules phases form rewriting strategy subject received considerable attention merits rewrite rules simple declarative nature true fact please possible :10.1.1.35.1581:10.1.1.35.1581:10.1.1.51.9254:10.1.1.51.9254
resist polluting story elaborate rewrite strategies 
simple strategy phase organisation necessary 
gain experience implemented simple scheme 
compiler runs simplifier repeatedly run having smaller phase number previous 
function may inline pragma pragma tell compiler phase inline function 
example implementation uses increasing phase numbers plan reverse shortly 
peyton jones tolmach hoare inline build build means inline build phase smaller appears lefthand side rule 
scheme clearly crude 
requires programmer know ghc phases undesirable assigning phase numbers modular requiring global view program 
question better annotate inline pragmas rules 
various elaborate schemes occurred module hierarchy example taken view refine scheme light practical experience implement elaborate scheme right away 
backing suppose fusion take place 
suppose isolated call 
bad implement build doing involves run time function passing straightforward implementation 
unacceptable programs run slower common places fusion fails original library 
solution rewrite non recursive inline vigorously int int build cons nil go go nil go cons go suppose inlined call alas fused foldr 
inline follows build fuse inline build inline go go go go code original straightforward implementation original straightforward implementation 
trouble effectively complete copy straightforward code call site 
acceptable function small quite undesirable larger functions 
peyton jones tolmach hoare alternative solution generally adopt library author add new definition rewrite rule int int rules forall isolated call transform follows inline build inline build apply rule rule spots special case applied standard list constructors transforms call directly coded function 
shot lambdas definition map terms foldr build map xs build foldr xs suppose find application map build 
want transform call map build inline map danger 
build foldr build apply foldr build rule build difficulty step marked danger 
substitute build xs body map occurrence xs lambda abstraction 
general program run arbitrarily slowly substituting redex inside lambda abstraction ghc usually conservative map build inline map safe 
xs build build foldr xs alas foldr build rule fire 
peyton jones tolmach hoare solution observe abstraction 
lambda function called 

argument build build simply calls argument passing 
substituting inside shot lambdas perfectly safe 
right thing analyse program shot lambdas act accordingly 
type analysis achieves things described wansbrough fully implemented ghc 
temporary hack spots special case application build 
sharing consider function sum filter expect intermediate lists eliminated function ghc correctly spots expression floated sum filter alas filter consumer fuse producer 
floating transformation producer case expensive 
worth losing fusion order share computation calls case better lose sharing gain fusion 
problem turned central elliott tried rewrite rules optimise pan programs 
pan crucial inline absolutely caring sharing apply rewrite rules aggressive common sub expression code motion transformations loss 
problem cut solution exploring idea virtual data types 
programmer declares data types virtual meaning data structures virtual type eliminated 
particular compiler ignore loss sharing considering inlining value virtual type 
remains seen usable feature 
dynamically generated rules far concentrated rewrite rules written programmer useful compiler generate rewrite rules dynamically 
give examples section 
peyton jones tolmach hoare specialisation haskell type classes give rise overloaded functions types invert num elt matrix elt matrix elt overloaded functions somewhat inefficient invert takes tuple dictionary functions extra argument give arithmetic operations values type elt 
optimising compilers haskell allow programmer write specialise pragma specialise invert matrix int matrix int pragma encourages compiler build specialised version invert matrix elements known type int giving efficient code 
ghc infer pragmas types invert called single module 
suppose compiler constructed specialised function called say invert int 
task sure suitable calls invert replaced calls invert int 
rules come 
compiler dynamically generates rewrite rule rules invert int forall num int 
invert int invert int earlier programmer specified rules rule written ghc explicitly typed intermediate language called core 
core binder explicit type polymorphism expressed explicit type abstraction application 
rules written user haskell source code translated core language typechecker adds type information followed converts haskell rich syntax core limited forms 
case invert polymorphic takes type argument indicated int left hand side rule 
takes argument corresponding num elt constraint tuple arithmetic operations referred earlier 
rule simply says call invert applied type int tuple rewritten invert int 
haskell type system ensures possible value tuple methods num int numeric operations int values methods baked invert int rule simply discard argument evaluated arguments array intensive code encounters loop peyton jones tolmach hoare int int int ghc represents values type int data type data int int int type unboxed bit integers 
ghc compile int int int case xv fw xv fw int int int fw xv xv case yv case fw xv yv rv yv rv turned mere wrapper evaluates calling worker fw 
sure evaluate certain evaluate evaluation branch conditional worker fw 
means worker re box calling yv common case immediately un boxed 
bad 
done 
matter specialisation 
recognising recursive call fw second argument constructor application ghc specialised version fw generate appropriate rule fw int int int fw xv yv yv original rhs fw 
rules forall xv yv 
fw xv yv fw xv yv simplifying right hand side fw rule get just want fw int int int fw xv yv xv case fw xv yv rv yv rv peyton jones tolmach hoare fw remains impedance matcher embodying iteration loop calling fw 
rule remains transform call evaluated second argument call fw 
done invisibly compiler programmer involved 
transformation fully implemented ghc enabled 
analysis generation specialised code generation rewrite rule takes lines haskell 
rewrite rule infrastructure automatically takes care applying rule relevant propagating rule separate compilation boundaries 
usage types exploring example pattern 
wansbrough usage types suggests considerable efficiency gains specialising functions usage patterns 
example consider map map map xs map xs map called context result list consumed thunks map xs need self updating updates omitted 
express ghc adds extra arguments map definition call sites 
done specialised version map compiled case usage type argument rule generated match calls exactly way specialising overloading 
summary example discern pattern pragmas program analysis perform local transformation generating specialised version invert 
generate rule explains transformation useful rest program 
cases rule looks type arguments value arguments 
apply rule rest program 
may sound extremely helpful single consistent way propagate benefits transformation rest program 
example generate specialised versions function find appropriate call sites specialised function 
may calls invert type int runs 
calls may show exposed 
may modules altogether rule propagated module boundaries relatively easily peyton jones tolmach hoare done 
programmer defined rules pragmas allowed top level purely syntactic restriction 
rewrite rules perfect sense nested functions bound local letrec ghc generate dynamic rules ideas section local functions 
important practice inlining generates nested function definitions 
application constraint satisfaction problems give example user application solving constraint satisfaction problems csps rewrite rules help support high level modular programming style 
added rules describe short cut deforestation rose trees confined library representative kernel application run times faster eliminating essentially overhead due modular style 
modular search interesting algorithms solving csps conceptually trees nodes represent states search space 
solutions search problem locating nodes represent complete consistent states 
conventional imperative recursive implementation search trees merely notional correspond tree procedure activation histories 
haskell state tree explicit lazy data structure :10.1.1.100.8004:10.1.1.100.9674
approach permits search algorithms modularized separate functions really coroutines communicate lazily constructed tree labeled consistency information 
component functions perform generation possible states consistency labeling pruning inconsistent states collection solutions 
earlier nordin tolmach showed large variety useful algorithms look quite different written imperatively obtained lazy framework just varying labeling pruning functions :10.1.1.34.4704
underlying algorithm simple composition functions intermediate results trees lists 
solver labeler csp state solver labeler csp filter complete csp map fst leaves prune 
labeler csp csp csp type describing instances constraint satisfaction problems example function queens int csp generate instances familiar queens problem 
state type peyton jones tolmach hoare partial solutions 
function csp tree state constructs tree possible partial solutions csp 
tree type ordinary rose trees node value arbitrary number children 
labeler argument solver type type labeler csp tree state tree state specifies attach consistency annotations node tree 
argument type type state bool says inspect annotations determine node consistent prune removes subtrees rooted inconsistent nodes 
leaves returns leaves tree list left right order 
subsequent list operations throw away annotations weed nodes representing incomplete solutions 
obtain simple back tracking search provide labeler checks consistency node individually annotates node boolean result check 
csp tree state tree state bool csp maptree consistent csp csp state solver snd sophisticated algorithms labelers may look node time store information annotations 
example known algorithm called forward checking implemented labeler stores lazily constructed cache table consistency information node 
csp tree state tree state cache state cache bool csp state solver interesting new combinations algorithms obtained appropriate composition labeling functions giving mix match approach algorithm construction 
modular algorithms result simpler read write modify imperative counterparts asymptotic behavior space time 
peyton jones tolmach hoare modular haskell code slower equivalent code constant factor 
measured performance representative kernel code implements standard backtracking search queens problem counts number solutions 
modular version function written int int length queens queens problem runs times slower conventional recursive algorithm doesn trees 
strikingly times slower non modular haskell transliteration algorithm 
difference suggests try fuse tree traversals avoid building nodes intermediate trees 
remainder section describe short cut deforestation rose trees discuss experience rules application 
full code kernel modular code corresponding monolithic function appendix 
fusion rose trees treat rose trees data type public functions maptree prune leaves 
internal representation data type operation standard data tree tree tree go go ts map go ts introduce analogous build lists corresponding fusion rule forall 
forall 
tree rules forall forall take care tree producing functions tree consuming functions 
tree adt don need worry client code constructor directly 
peyton jones tolmach hoare function generates tree function computes children node maptree analogue familiar functions lists :10.1.1.100.8004
tree go go map go maptree tree tree maptree ts ts prune removes subtree root value matches predicate represent empty trees require return false root node entire tree appropriate applications 
prune bool tree tree prune head ts concat ts leaves extracts values leaves tree list left right order 
leaves tree leaves leaf leaf ts concat ts ideally leaves written list build fuse list consumers pipeline 
unfortunately require doing higher order tree fold produces intermediate list function closures ghc doesn handle lists effectively proves efficient stick simple definition shown 
mark functions inlined possible 
short cut deforestation pays definitions ghc able completely fuse away rose trees constructors applied 
modifying implementation rose tree adt perform cheap deforestation improves performance factor bringing running time hand fused non modular haskell imple peyton jones tolmach hoare mentation 
improvement comes requiring changes search application code 
quite straightforward may 
problems examined context list fusion appear trees effective application fusion law requires ghc inline normally 
example pipeline tree operations generates fusion opportunities require inlining underneath lambda argument 
fact safe thing lambda shot ghc doesn know thinking trees user defined library obviously inappropriate hack fact compiler way list build 
happens particular kernel code show ghc fact lambda representing entire program shot deduce repeated iteration inlining lambdas shot 
general need linearity analysis 
fusion fails tree library sure resulting code worse fusion attempted 
lists ensure inlining produces code provide back mechanism appropriate attention phasing inlining section 
full effectiveness need sure inlining list functions lists children nodes occurs inlining tree functions section 
arrange attaching earlier phase number tree function inlining directives 
seriously easily write programs fusion fails legitimate reasons consumers producer simply mistake writing rule 
ll get feedback compiler failures 
clearly crucial area 
related basic concepts rules system far new 
great attempts build frameworks user directed applicationspecific optimization adding additional semantic specifications functions 
ideas particular interest high performance computing community 
scientific codes established high level libraries linpack plapack 
libraries need efficiently wide range machine architectures data sets typically multiple implementations complex interface 
portability maintainability client code written peyton jones tolmach hoare portable high level library calls leaving compiler determine appropriate low level calls optimizing client code accordingly 
achieve library interfaces annotated additional specification information 
systems proposals lines include broadway active libraries 
set systems developed algebraic specification community 
example opal language combines functional programming algebraic specification uniform framework 
opal laws justify guard rewrites functional code laws order predicate formulas equality functional expressions system powerful course undecidable 
unclear extent existing implementation opal supports automated optimization 
compared existing systems proposals notable primarily leaves 
precisely identify contrasts systems meta language 
left hand right hand sides rules just haskell source expressions 
exception tools known operate internal program representations syntax trees control flow graphs typically allow righthand sides defined kind meta programming facility 
choice meta programming language delicate 
specialized language notation metal concise learned scratch library author unduly constraining general purpose programming language lisp early aspect oriented programming flexible requires author take great care maintain essential invariants 
simple rewrite strategy rely simple built strategy modified phases determining rules applied 
rule sets elaborate authors may need exercise explicit control strategy stratego :10.1.1.35.1581
simple pattern matching 
rely programmer high level operators foldr encapsulate control flow 
don need provide sophisticated contextual pattern matching identify loops recursions systems khepera 
deal unpredictability possible high cost higher order matching mag 
side conditions 
purely functional language means useful optimizing transformations context independent don require elaborate side conditions 
contrast useful transformations imperative programs justified non syntactic non trivial analysis control flow dependence aliasing tools imperative languages focus specifying analyses addition transformations examples include dfa opt peyton jones tolmach hoare sharlit genesis intentional programming de moor 
termination guarantees ac rewriting 
rules directed easily express commutative laws causing endless rewriting 
modern algebraic transformation system maude equations entirely symmetric left right hand sides arbitrary terms transformation direction :10.1.1.51.9254
common algebraic properties operator declared builtin keywords assoc comm executing transformations program pattern matching conducted modulo properties shorter elegant programs 
summary offer simplicity exchange limited functionality 
simplicity important implementors library authors 
implementation point view experience simple ideas seldom easy implement full scale optimising compiler complex ideas require hard sustain long term 
programming point view simplicity important 
particularly fact transformations expressed entirely haskell necessarily different indirect meta language huge advantage 
know optimising compiler widespread supports domain specific extensions suspect partly due complexity meta programming mechanisms 
course ghc rules widespread programmers scenes run ghc list fusion section specialisation section 
possible approach just simple know tradeoff simplicity expressiveness play 
described simple fully implemented deployed way write domain specific extensions compiler haskell means rewrite rules 
demonstrated simple rewrite rules useful practice 
list fusion rules deployed prelude released ghc compiler years 
chakravarty keller ghc rewrite rules perform array fusion nested data parallel programming application sophisticated described :10.1.1.27.3139
previous section described directions imagine making system expressive plan develop experience practical elaborating 
pressing area mentioned section question best provide feedback programmer rules fired peyton jones tolmach hoare especially 
rewrites done core quite far haskell providing comprehensible feedback hard problem 
status report progress 
hope attract interest writers library packages encourage experiment feature report inadequacies 
longer term wish promote principle programmer supply declarative information code program suggest compilers programming tools take maximum advantage declarations 
gratefully manuel chakravarty andy gill oege de moor eelco visser anonymous referees helpful feedback earlier versions 
aitken de moor richter transformation intentional programming proc 
th international conference software reuse 
uniformly specify program analysis transformation graph rewrite systems proc 
compiler construction lncs pp 

baader nipkow term rewriting cambridge university press 
bird moor algebra programming prentice hall 
bird wadler functional programming prentice hall 
boyle winter program transformation system design applications arge editors modern software tools scientific computing birkhauser chakravarty keller functional array fusion acm sigplan international conference functional programming icfp :10.1.1.27.3139
claessen hughes quickcheck lightweight tool random testing haskell programs acm sigplan international conference functional programming icfp pp :10.1.1.47.1361

clavel eker lincoln meseguer principles maude meseguer editor proceedings international workshop peyton jones tolmach hoare rewriting logic electronic notes theoretical computer science pp :10.1.1.51.9254

de moor generic program transformation proc 
rd international summer school advanced functional programming lncs pp 

pepper opal design implementation algebraic programming language gutknecht editor programming languages system architectures international conference zurich switzerland march lncs pp 

elliott finne de moor compiling embedded languages proc 
semantics applications implementation program generation lncs 
engler chelf chou hallem checking system rules system specific programmer written compiler extensions symposium operating systems design implementation osdi san diego ca 
faith prins khepera system rapid implementation domain specific languages proc 
usenix conference domain specific languages pp 

pattern languages prototyping compiler optimizers ph thesis university california berkeley technical report csd 
gill launchbury peyton jones short cut deforestation acm conference functional programming computer architecture fpca acm pp 

lin annotation language optimizing software libraries proceedings nd conference domain specific languages pp 

lin optimizing high performance software libraries proc 
th international workshop languages compilers parallel computing 
hughes functional programming matters computer journal pp :10.1.1.100.8004

kennedy cooper dongarra fowler gannon johnsson mellor crummey torczon telescoping languages strategy automatic generation scientific problem solving systems annotated libraries journal parallel distributed computing appear 
peyton jones tolmach hoare kiczales lamping mendhekar maeda lopes 
loingtier irwin aspect oriented programming ecoop object oriented programming th european conference lncs pp 

kirchner kirchner vittek implementing computational systems constraints kanellakis 
lassez saraswat editors proceedings workshop principles practice constraint programming brown university providence usa pp 

klein knoop steffen dfa tool kit program analysis optimization proc 
nd international workshop tools algorithms construction analysis systems tacas lncs pp 

de moor imperative program transformation rewriting proc 
compiler construction lncs pp 

launchbury sheard warm fusion acm conference functional programming computer architecture fpca acm la jolla california pp 

wilhelm language system specification program transformations system overview experiences proc nd workshop compiler compilers high speed compilation lncs pp 

mendhekar kiczales lamping rg case study aspectoriented programming technical report spl xerox palo alto research center palo alto ca usa 
nordin tolmach modular lazy search constraint satisfaction problems journal functional programming appear :10.1.1.34.4704
partain nofib benchmark suite haskell programs launchbury sansom editors functional programming glasgow workshops computing springer verlag pp 

peyton jones launchbury unboxed values class citizens acm conference functional programming computer architecture fpca pp 

peyton jones marlow secrets glasgow haskell compiler inliner workshop implementing declarative languages paris france 
peyton jones santos transformation optimiser haskell science computer programming pp 

reid hugs graphics library technical report school computing university utah 
peyton jones tolmach hoare tjiang hennessy sharlit tool building optimizers proc 
acm sigplan conference programming language design implementation san francisco ca pp 

veldhuizen gannon active libraries rethinking roles compilers libraries proceedings siam workshop object oriented methods inter operable scientific engineering computing oo 
visser strategic pattern matching rewriting techniques applications rta trento lecture notes computer science 
visser :10.1.1.35.1581
benaissa tolmach building program optimizers rewriting strategies proceedings international conference functional programming icfp pp 

wansbrough peyton jones polymorphic type th acm symposium principles programming languages popl pp 

soffa design implementation genesis software practice experience pp 

appendix constraint satisfaction problems complete code constraint satisfaction problem csp search kernel described section problem definition csp characterized number variables vars number values vals consistency relation rel pairs assignments values vars 
represent assignments infix constructor 
solve csp assign value variable pairwise combinations assignments rel 
known example queens problem standard optimization try place queen column modeled csp variables columns values rows relation permits assignments provided corresponding positions different rows different diagonals 
type var int type value int data assignment var value type relation assignment assignment bool data csp vars vals int rel relation peyton jones tolmach hoare queens int csp queens vals vars rel safe safe col row col row row row abs col col abs row row search states model state space possible solutions sequence assignments number assigned variable 
states built repeated extensions takes state constructs list extended states formed assigning possible value variable 
data state assignment var csp state vars vars extensions csp state state extensions vars vars vals vals val vars val vals complete csp state bool complete vars vars vars consistent csp state bool consistent true consistent rel rel rel solution complete state consistent level 
rose trees sample library code rose trees written concern fusion 
convenience definition prune leaves 
data tree tree tree go go map go tree go peyton jones tolmach hoare go ts map go ts maptree tree tree maptree ts map maptree ts prune bool tree tree prune head ts concat ts leaves tree leaves leaf leaf ts concat ts rose trees supporting fusion code shown section backtracking search csps csp tree state csp extensions csp csp type labeler csp tree state tree state type state bool labeler bool csp maptree consistent csp solver labeler csp state solver labeler csp filter complete csp map fst leaves prune 
labeler csp csp csp state solver snd int int length queens peyton jones tolmach hoare hand fused code hand fused version haskell int int csp csp queens state complete csp state extensions csp state rest consistent csp rest rest rest 
