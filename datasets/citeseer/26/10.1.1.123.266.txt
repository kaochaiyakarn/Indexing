dependently typed assembly language hongwei xi department computer science engineering oregon graduate institute science technology hongwei cse ogi edu robert harper department computer science carnegie mellon university cs cmu edu dependently typed assembly language dtal type system supports restricted form dependent types benefits dependent types assembly level 
dtal overcomes significant limitations proposed low level languages including java bytecode language typed assembly language prevent handling certain important compiler optimizations run time array bound check elimination 
mention compiler generate dtal code compiling high level programs 
certifying compiler generates object code readily checked compliance specified safety policy constrains run time behavior 
ensuring compliance checkable code recipient need concerned origin code augmented code 
typical safety policies include type safety excludes examples programs attempt add integer floating point number memory safety excludes stray memory accesses 
examples certifying compilers property include various ones compiling java java virtual machine language jvml touchstone compiling safe form proof carrying code call necula lee til successor tilt compiling standard ml milner tofte harper macqueen typed intermediate language tarditi morrisett cheng stone harper lee compiling restricted set ml portion type safe tolmach oliva :10.1.1.126.9884:10.1.1.33.6545
certifying compilers number benefits including facilitating safe exchange code untrusted environment improving robustness compiler thinking transformation phase separate certifying compiler subsequent stages may check compliance safety policy 
specific approaches certification include proof carrying code necula adopted touchstone type safety memory safety expressed order logic assertions program variables checked vc generator theorem prover code certified explicit representation proof type systems adopted til type safety expressed type annotations checked type checker additional certification required :10.1.1.40.2507
touchstone approach draws established results verification order imperative programs studied approach readily extend higher order languages 
til approach draws established methods designing implementing type systems making unclear priori extended low level languages account memory safety 
typed assembly language tal formed morrisett walker crary glew form type system designed assembly level suitable compiling functional languages compilation system tal 
tal provides type safety memory safety cost making critical instructions array subscripting atomic ensure memory safety 
instance array subscripting instruction tal involves checking array index lower upper bounds array fetching data item 
goal enrich tal allow fine grained control memory safety support array bound check elimination hoisting bound checks loops draw formalism dependent types extend tal concept 
rely directly standard systems dependent types languages computational effects 
instance entirely unclear means say array length mutable variable update different value changes type unchanged 
drawing experience restricted form dependent types dml xi pfenning introduce clear separation ordinary run time expressions distinguished family index expressions linked singleton types form int integer expression type int value equal index expressions chosen integer domain 
expression dml checking type int written int involves non trivial equational reasoning run time behavior instance int means evaluated evaluates 
clearly int int general undecidable arbitrary possibly effectful type int 
theorem proving constraint satisfaction comes picture 
crucial feature dml adopted existential dependent types possible avoid difficult constraints type realistic programs 
formed dependently typed assembly language dtal supports limited form dependent type system capturing type safety memory safety 
designed language xanadu syntax prototyped compiler compiles xanadu dtal 
concentrates dtal occasionally programs xanadu notation facilitate presentation notions dtal 
xanadu program implements copy function arrays 
notice simplicity example solely sake illustration purpose interpreted limitation approach 
function header program states natural numbers satisfying function takes integer arrays sizes respectively returns value 
note nat nat universal quantifier explained xi pfenning int src int dst means src dst integer array size :10.1.1.36.3970
var start variable declaration ends 
function returns size array 
dtal code basically corresponds xanadu program 
double slash starts comment line 
note 
registers 
instruction non standard means store size array points 
branch instruction finish jumps label finish integer greater equal zero 
load means store content ith nat nat void copy int src int dst var int length length src length dst src return copy function xanadu 
copy nat nat int array int array 
obtain size source array 
mov initialize loop count 
loop nat nat nat int array int array int int 
sub 
finish 
load safe load 
store safe store 
add increase count 
jmp loop loop 
finish 
halt return caller shown copy function implemented dtal element array points integer stored 
store instruction interpreted similarly 
label code associated dependent type 
dependent type associated label loop basically means exist natural number natural number satisfying natural number types int array int array int int respectively integer array size integer array size integer value integer value enables state instance type depends value 
type system dtal guarantees properties satisfied code execution reaches label loop 
dtal code typed guarantees integer natural number value size array points load store instruction executed 
words statically verified need run time array bound checking case 
simple example impossible infer store instruction safe dependent type associated label loop 
dtal array access separated array bound checks type system dtal guarantees execution typed dtal perform bounds array access 
separation array bound check elimination possible 
case impossible prove type system dtal array access may bounds run time array bound checks inserted ensure safety 
main contribution formulation dependent type system imperative assembly level language non trivial reasons outlined previously generalizes tal allow capturing significant loop optimizations yields application dependent types managing low level representation sum types provides approach certification type checking 
trade presume constraint solver part trusted computing base order recipient verify code receives 
include means formally representing proofs constraints constraint solver moved trusted computing base 
briefly mention certain aspects compilation xanadu dtal allows construct toy compiler generating sample dtal code 
details xanadu xi compilation xanadu higher level languages dtal reported 
organize follows 
syntax dtal section 
form evaluation typing rules assign dynamic static semantics dtal respectively 
postpone section treatment constraints generated type checking programs dtal 
section give detailed example explaining type checking performed dtal 
soundness type system dtal stated proven section extension dtal handle sum types section 
section mention type checker dtal compiler compiles xanadu language resembling safe necula lee popcorn morrisett syntax dtal :10.1.1.126.9884
rest discusses closely related directions 
dependently typed assembly language section typed assembly language restricted form dependent types available 
closely relates typed assembly languages morrisett walker crary glew morrisett crary glew walker substantial differences point 
name dtal dependently typed assembly language 
syntax address stack overflow issue 
assume fixed number nr registers stack infinite depth 
type state consists pair finite mapping set 
nr types stack type 
intention capture type information register file stack respectively 
syntax dtal 
intuitively speaking dependent types types depend values language expressions 
instance may form type int array mean heap pointer type points integer array size expression type depends 
name type index expression expression 
restrict type index expressions integer domain 
justification choice previously domain eliminate array bound checks effectively xi pfenning :10.1.1.36.3970
type variables type states state types state regfile types 
rnr nr stack types variables stack types types top int array prod 
type erasures top int array prod 
type variable contexts tv registers 
rnr instructions ins aop rd rs bop rd rs mov load rd rs store rd vs newarray jmp pop push halt constants values instruction sequences jmp halt ins blocks arithmetic ops aop add sub mul div branch ops bop beq bne blt bgt labels label mappings 
ln programs 
ln bn syntax dtal syntax type index expressions range type index variables fixed integers 
note language type index expressions typed 
sorts types language order avoid potential confusion 
empty index context omit standard sorting rules language 
certain transparent abbreviations stands subset sort stands sort elements sort satisfying proposition example nat abbreviation int 
postpone treatment constraint satisfaction type index language section simplicity exposition 
informally explain need constraints dtal code 
notice register assumed type int index expressions index propositions index sorts int index contexts syntax type index expressions copy loop finish copy loop finish copy loop finish halt nat nat nat nat nat halt state nat nat state nat nat nat state explanation program natural number execution reaches label loop 
type changes int execution instruction add 
execution jumps back label loop 
jump requires verified requirements type int natural number 
need prove natural number condition natural number 
constraint trivial case 
general type checking dtal involves solving great number constraints form 
prod 
product types 
usually written notation allows clearly distinguish prod 
unit empty product prod 
may notation risks confusion 
top type uninitialized registers assume register initialized type top 
block roughly means polymorphic 
order execute block machine need find substitutions respectively current machine state entails state execute 
entailment state basically means type assignment registers stack correctly reflects types registers stack current machine 
instance indicates integer top stack integer stored top stack machine 
state type associated label means substitutions respectively current machine state entails execution reaches label 
note state type constructor constructing state types 
general instruction sequence presentation consists sequence instructions labels 
block write state define functions program 
ln bn follows 

ln bn 
ln bn refer label mapping require labels distinct 
valid program labels declared 
examples dtal code attach state type label label explicitly type unit purpose represent value type unit null pointer implement data structures linked list 
program label mapping program immediately extracted code necessary 
explain definitions program sequences instructions labels copy loop labels loop finish respectively 
convention may omit quantifying stack type variables concrete syntax mapping maps int array int array respectively top maps int array int array int int respectively top top domain 
note write int int int int sum singleton types int ranges integers 
erasure function transforms types type erasures non dependent types 
top top int int unit array array prod 
prod 
readily verified presentation dtal dtal tal language erases syntax related type index expressions 
tal language erasure program typed typed dtal 
respect dtal generalizes tal 
dynamic semantics machine assigning operational semantics dtal standard approach 
machine state triple finite mappings stand heap register file respectively list representing stack 
domain dom set heap addresses domain dom 
nr 
specify heap address represented reader simply assume natural number 
dom tuple hc 
hcn 
hci constant heap address 
dom heap address constant 
list form hc 
hcn heap addresses constants hc 
hcn list constructor empty list 
write sp stack pointer points top stack 
hc 
hcn write sp hci 

program associates label state type 
length length sequence counting instructions labels 
ith item instruction label 
write 
defined labels program distinct 
define snapshot halt pair ic ic length 
relation ic ic means current machine state transforms executing instruction ic instruction counter set ic evaluation rules dtal 
consider garbage collection machine heap affected memory allocation instructions newarray 
define 
integer label ith register ri 
prod 
ic dom hc 
hcn ic hc 
hcn ic eval array ic newarray dom ic hc ic hc 
hc eval newarray ic rd rs rs hc 
hcn ic ic ic add rd rs rs ic ic rd ic sub rd rs rs ic ic rd ic mul rd rs rs ic ic rd ic div rd rs rs ic ic rd ic beq ic ic beq ic ic ic bne ic ic bne ic ic eval eval add eval sub eval mul eval div eval beq true eval beq false eval bne true eval bne false ic jmp ic eval jmp ic mov hc ic ic hc eval mov ic load rd rs rs hc 
hcn ic ic rd hci eval load ic store rd rs rd hc 
hcn rs hc ic ic hc 
hci hc hci 
hcn eval store ic pop ic hc ic hc eval pop ic push hc ic ic hc eval push ic halt ic halt eval halt evaluation rules finite mapping element domain value maps mapping clearly meaningful domain case simply extend domain notation hc mean update content register hc hc hc numbering register hc hc 
evaluation rules instructions rest readily constructed closely related ones 
notice rules eval load eval store imply bounds array access stalls machine 
rules indicate length tuple determined dom run time 
soon design type system dtal prove holds eval load eval store applied evaluation typed dtal program 
need determining length tuple dom evaluate typed dtal programs 
case determined type system dtal subscript bounds array array subscripting instruction ill typed rejected 
sounds severe restriction insert run time array bound checks instruction typable dtal give example section 
order perform array bound checking efficiently group array size allocation 
stressed interaction dynamic semantics dtal type index expressions 
erasing type index expressions program alter execution behavior program 
omitted evaluation rules blt bgt readily formulated rules beq bne 
notice instruction jmp jumps instruction immediately evaluates current machine state 
notice rules eval eval newarray non standard 
form prod 
allocates new word memory heap stores pointer points allocated memory 
moves content sp 
decrease sp example follow code allocates pair heap stores pointer ends type nat prod int int pair integers value 
note nat concrete syntax nat dtal code 
mov push push int int int similarly form array newarray allocates new word memory heap value integer stored sp stores pointer points allocated memory 
copies content sp 
decrease sp 
example code allocates array type nat int array array size elements natural numbers 
mov push mov push newarray nat int emphasize new rules eval eval newarray domain typing consequences malloc instructions explained section typing rules type type newarray introduced 
definition program defined snapshot holds machine state reflexive transitive closure say program structured snapshot halt evaluates snapshot 
words evaluation structured program stuck 
notice program type safe memory safe evaluation rules dtal 
certainly undecidable precisely determine program structured relevant 
intend find conservative approach examining program structured 
approach sound accept structured programs 
instance straightforward approach adopt method tal type safety insert run time checks array operations 
unfortunately approach conservative making impossible eliminate array bound checks 
notice essentially case jvml verifiers 
section conservative approach type system supports restricted form dependent types 
approach accept highly optimized programs binary search example array bound checks removed 
static semantics typing rules dtal section 
type state array representation list representation list ends stack variable 
presence dependent types longer trivial type formed 
instance disallow occurrence type int array typing rules dtal readily lead inconsistency type system 
words prove natural number forming type int array 
type formation rules write mean formed type context 
similarly write formed mean formed context 
formedness types type states derived application rules 
assume types type states formed presentation 
judgment form mean value assigned type context label mapping 
label mapping fixed type check program omit causes confusion 
rules typing unit integers labels registers 
typing rules dtal 
judgment form means instruction sequence typed context 
int int formed prod 
formed state nr formed unit type unit type label nat array int formed formed formed formed formed type formation rules dtal int type int nr ri type reg type sub typing rules integers labels registers stack cells 
notation means update type register ith register update content 
rules type type newarray typing tuples arrays allocated heap respectively 
explained previous section memory allocation performed 
give explanation rule type beq 
suppose type check beq check type int type check added jump taken case verify state type entails state type added jump taken case 
typing rules conditional jumps similar 
sketch case dtal program type check modified typecheck insertion run time array bound check 
assume want type check load rd rs verified rs types array int respectively prove insert subscript entry routine handles errors front load instruction insertion guarantees added load instruction type checked making sure provable 
rs sub subscript dual case remove redundant array bound check similar omitted 
typed mean program 
ln bn typed type open reg prod 

array int newarray rs array rd int rd rs mov rs int int rd int add rd rs rs int int rd int sub rd rs rs int int rd int mul rd rs rs int int rd int div rd rs typing rules dtal type type newarray type type mov type add type sub type mul type div rs prod 
rd load rd rs rs array int rd load rd rs rd array int rs store rd rs pop type pop push state jmp type load tuple type load array type push type store array type jmp int state beq int state bne halt type halt typing rules dtal ii type beq type bne judgment form judgement meaning proposition holds context integer domain 
types equivalent context modulo constraint satisfaction 
type coerces type context modulo constraint satisfaction 
ri type context dom modulo constraint satisfaction 

form 
derivable means derivable 
type ri context coerces dom modulo constraint satisfaction 

form 
derivable means derivable 
value type context label map 
value type context coerces 
instruction sequence typable 
summary various forms judgments derived follows label mapping typed bn typed typed type program block rule deriving typed follows 
typed type block far introduced various forms judgments defined 
summarize meaning judgments informally 
type equality coercion mentioned novelty dml separation language expressions type index objects 
notion separation indispensable intend form dependent type system imperative language dtal 
instance completely unclear moment register type index object mutable 
separation allows simply avoid problematic issue 
advantage separation enables choose relatively simple domain type index objects constraints type index objects generated type checking efficiently solved 
crucial design practical type checking algorithm 
section rules type equality coercion exhibit clearly involvement constraints type checking 
presence dependent types longer trivial check types 
instance prove constraint holds order claim int equivalent int 
words type equality modulo constraint satisfaction 
similarly type coercion involves constraint satisfaction 
syntax constraints follows 
index constraints satisfiability relation satisfiability relation means formula satisfiable domain integers defined 
int int instance satisfiability relation nat int holds formula true integer domain 
int int write mean types equal context 
similarly write mean type coerces type context 
rules type equality coercion respectively 
obvious restrictions rules 
instance require index variable premise rule type eq exi ivar free occurrences rule 
notice replace rule coerce array 
array array coerce array rule readily type system unsound demonstrated example 
note int array stands state type state int array unit dom 
start int array mov jmp int array int array store 
seemingly natural rule allowed coerce type int array type int array 
type instruction sequence 
notice points pair value heap store instruction executed type int array 
leads unsoundness system 
summary array types covariant dtal 
plain reason arrays mutable data structure allocated heap pointers arrays may shared 
notice product types dtal covariant 
reason tuple heap mutable dtal 
intend support tuples components mutable type eq tvar int int type eq int array array type eq array prod 
prod 
type eq prod type eq exi ivar type eq exi tvar state state type eq state ri type eq reg stack type eq reg type eq stack empty type eq stack var type eq stack type equality rules dtal top coerce top unit unit coerce unit coerce type var int int coerce int array array coerce array prod 
prod 
coerce prod coerce exi ivar coerce exi ivar coerce exi tvar coerce exi tvar state state ri coerce reg stack coerce reg coerce stack empty coerce stack var coerce stack type coercion rules dtal coerce state modify rule coerce prod 
instance type constructor prod forming types pair component mutable second need coercion rule 
prod prod need type coercion immediate 
foremost need type coercion type jumps demonstrated rules type jmp type beq type bne 
need type coercion type code sequence show type int int coerces type nat int int 
start int int jmp nat int int 
noticeable coercion rule coerce state 
informally speaking state type stronger state weaker 
intuitive explanation state type roughly represents notion code continuation 
elaborate point establish soundness type system dtal section 
define substitutions index type variables follows 
index variable substitutions type variable substitutions omit details substitution performed standard 
term type state result applying 
introduce forms judgments follows rules deriving judgments 
tv subst subst subst ivar subst prop formed subst tvar subst svar lemmas establish expected properties type equality coercion 
lemma 

derivable derivable 

derivable derivable 

derivable derivable 
proof follows inspection rules 

subscript nat int sp int array sp 
pop sp 
blt error negative 
pop sp 
obtain array size 
sub 
error 
load safe load 
pop sp 
push push stack 
jmp done lemma 
dtal array subscript function 
derivable derivable 

derivable derivable 
proof follows inspection rules 
lemma assume derivable 

derivable derivable 

derivable derivable 
proof structural induction derivations respectively 
far finished presentation type system dtal involved 
concrete examples section provide explanation type checking proceeding establish soundness type system 
examples simply overwhelming formally explain type checking dtal performed tiny example type system 
informal manner type check dtal code facilitate comprehension 
code sketches implementation array subscript function run time array bound checks performed 
nat int sp int array sp state nat int int array 
int int array int int array int int array int int array int int array int int int array int int int array int int array int int int int int contexts 
unit dom state type state state 
notice numbers inserted code readily identify instruction code 
label error entry code reporting bound violations 
instruction stores size array points 
intuitively speaking code execution reaches label subscript sp points stack top cells store integer pointer array label respectively 
type label states sp type execution jumps label 
type system dtal guarantees part stack typed read written subsequent code execution 
simple reason pop push instructions involving stack applied type stack stack type variable 
ith instruction ii 
ins halt 
argue derivation 
int int array need derive derivations di form ii 

list contexts 
note derivable 
implies derivable 
straightforward verify ii derivable 

notice need prove deriving trivial assume context 
sophisticated example 
xanadu program implements binary search function integer array 
type system xanadu guarantees implementation memory safe unnecessary perform array bounds checking run time 
syntax keyword invariant basically state type stating exist integers satisfying variables low high types int int respectively program point 
treated loop invariant loop follows 
explanation xi 
dtal code loosely corresponds xanadu implementation binary nat int bsearch key int vec int array var int low mid high low high vec invariant int int low int high int low high mid low high vec mid key return mid key high mid low mid return implementation binary search xanadu search 
verified dtal code memory safe 
give intuitive informal explanation follows 
code execution reaches label loop integers stored size array points 
readily inferred integer equals holds load instruction executed 
clearly load instruction memory safe 
guarantees memory safety code load instruction memory operation code 
notice types attached labels example intractable synthesize practice 
supports view order generate memory safety proofs large programs necessary high level source language xanadu programmer supply type annotations 
currently investigating compile annotations low level language dtal 
soundness recall machine state triple finite mappings representing heap register file respectively list stands stack 
heap address tuple hc 
hcn hci constant heap address 
judgment form hc mean heap address constant hc bsearch nat int array int int stores key value trying find mov stores lower bound sub stores upper bound jmp loop loop nat int int loop invariant int array int int int sub bgt notfound add div load sub blt bgt greater mov key jmp finish nat int int nat int array int int int int sub jmp loop greater nat int int nat int array int int int int add jmp loop notfound mov jmp finish finish int contains index key halt program halts dtal code binary search integer array int heap int tv hc unit heap unit hc hc heap exists hc 
hcn hc hcn prod 
hc 
hcn hc hcn array nr heap stack empty hc hc heap label heap register heap stack heap state rules modeling states heap prod heap array type heap label map 
judgment means machine state entails models state 
judgment mean context satisfied machine state derived rule 
tv lemma substitution tv derivable tv derivable 
proof follows careful inspection type equality rules type coercion rules typing types dtal 
lemma 
assume hc derivable 
tv derivable hc derivable 
proof proceed structural induction derivation hc derivation tv 
state type form 
tv heap label lemma tv derivable 
derivable 
assume state type interesting cases 
tv tv array array hc array derivable deriva tion form hc 
hcn hc hcn hc array heap array lemma derive tv 
induction hypothesis derive hci leads conclude case 
hc 
hcn hc hcn hc array tv tv heap array note 
form 
hc hc heap exists lemma derive tv 
induction hypothesis hc derivable 
tv tv note 
hc derivable induction hypothesis leads 
hc hc rest cases treated similarly 
heap exists lemma assume derivable 
derivable derivable derivable 
proof lemma follows straightforward application lemma derivation 
notice derivation form 
tv 
lemma find tv tv derivable 

note derivable derivable 
words derive nr 
notice tv derivable nr tv derivable 
lemma nr 
derivable 
similarly derive derivation obtained follows 
yields derivation 
heap state assume derivation typed block list instructions ins 
insn 

insn suffix 
greatest subderivations form ii 
notice may exists subderivations righthand side ii application type open reg alter righthand side 
reason need word greatest definition 
assume derivation typed program 
ln bn bi ii di derivations bi typed 

notice ic length ic label instruction block bk ik write ic dk ic ik ic ik presentation 
lemma machine state 
derivable derivable 
proof follow structural induction derivation order establish soundness type system dtal need prove holds ic ic derivable ic ic ic ic respectively 
words justify typing rules respect effects machine states resulted execution instructions 
unfortunately succeed impose regularity condition derivation ic 
main reason follows 
suppose pointers stored registers point address heap integer stored 
possible moment type int array int array respectively 
update address integer pointer update seen 
update leads inconsistency type int array 
formal description follows 
state int array int array 
heap address empty 
readily verified derivable 
typing rules allowed execute instruction store type int array 
changes 
obviously derive int array int array hold 
definition regularity heap mapping 
dom tuple hc 
hcn represent heap address hci stored ranges 

partial mapping heap addresses closed types derivation 
applications rules hc 
hcn hc hcn array heap array tv derivable regular 
say regular regular call regularity mapping 
argue regular derivation 
note derivation form order int array derivable integer 
int int array similarly derivation form deriving int array 
int int array find regularity mapping tv int tv int derivable imply derivation tv int int clearly impossible 
inspect proof lemma observe derivation regular derivation regular 
lemma main lemma assume program 
derivation typed 
ic instruction count ic derivation ic 


derivable machine state ic ic derivable ic ic halt derivable 

ic ic derivable ic derivation ic regular derivation derivation regular 
proof proof follows inspection typing rules evaluation rules 
lemma assume applied rule ic type open reg type open stack prove 
cases 
derivation ic form 
rs int int rd int div rd rs type div available rs integers holds 
evaluation rule eval div 
ic ic rd clearly rd rd derivable 
derivation ic form applied rule type beq 
int state beq available rd integer cases 
holds 
evaluation rule eval beq false yields 
ic ic trivial derivable 
holds 
note know label derivable state type 
means defined 
ic derive evaluation rule eval beq true holds 
ic ic note state 
implies state type tv state 
assume state 
derivable derivable 
lemma readily derive derivation ic form 
rd array int rs store rd rs type store array available exist rd heap address hc 
hcn hc 
hcn 
evaluation rule eval store hc rs 
ic ic hc 
hci hc hci 
hcn derivation hc 
hci hc hci 
hcn straightforward readily proven hc place need regularity condition 
derivation ic form 
pop type pop available form hc 
hcn 
evaluation rule eval pop 
ic hc 
hcn ic hc hc 
hcn derivation hc hc 
hcn straightforward 
ic form 
halt type halt obviously derive ic halt evaluation rules eval halt 
rest cases handled similar manner 
theorem progress 
ln bn program 
assume typed derivable 
ic ic halt ic ic ic words execution typed program dtal halts normally runs forever 
proof derivation derivation 
clearly regular derivation 
theorem follows lemma 
extension sum types programmer declare xanadu polymorphic union type representing lists implement length function 
concrete syntax list type lists elements type type variable 
note union types xanadu correspond datatypes ml values union types decomposed pattern matching 
instance informally explain meaning switch statement xs matches pattern nil value returned xs matches pattern cons xs wildcard update xs tail increase 
union type internally represented sum type 
case tag indicate constructor list nil cons 
compile function essentially manner initialize start loop list xs perform tag check see nil return know constructor xs cons unnecessary perform tag check simply update xs tail increase loop 
unfortunately inferred type system tal tag indicate nil indicate cons case difficult tal handle optimization pattern compilation 
general type system tal contains limitations handling sum union types 
possible tal macros handling case constructors difficult handle general case involving constructors 
union list nil list cons int length xs list var int true switch xs case nil return case cons xs length function lists xanadu choose 
type eq choose choose 
type eq choose choose 
choose 
type eq choose choose 
choose 
coerce choose additional type equality coercion rules coerce choose extend system dtal handle sum types 
implementation pair heap represent sum type sum 
written literature 
element pair integer second element type choose 
stand type 
determined value type additional rules handling type coercion involving sum types rules type equality omitted 
note sort int natural number define sum 
int choose 
value type sum 
represented pair part tag determining type second part 
need typing rule choose 
choose 
type choose length sp list sp int sp int represents state type return address label pushed stack caller 
note list represented dependent type internally program type check tal pop store list argument mov initialize loop int list sp sp int unfold unit list load load list tag beq finish goto finish empty load list load move list tail add increase jmp loop loop finish int sp sp int pop return address pops push result pushes stack jmp return implementation length function lists dtal example illustrate sum types 
usual list type constructor represented unit abstracts types fixed point operator types 
note type variable 
usual rules needed handling operator 
type fold type unfold provide auxiliary instructions fold unfold indicate need folding type unfolding type respectively 
dtal code corresponds xanadu program 
state type label length indicates top element stack list second label list argument function label return address pushed stack caller type label states top element stack integer return value function rest stack current stack excluding top elements 
note code type check translated tal 
dtal code unsatisfactory reason 
practice list constructors usually represented tags efficiency memory concern 
words interpret list nat choose unit list 
reason readily tested practice value equals commonly represented null pointer need tag 
instance introduce int list upto int var int list xs xs nil xs cons xs return xs upto int sp int pop push push int list jmp loop loop int int int list sp blt finish push push int int list push push int list int list sub jmp loop finish int list halt implementations upto function standard ml dtal unit state type false typing rules instruction upto nat sp int pop mov jmp loop type true loop nat int int list sp blt finish push push int int list sub jmp loop finish int list halt implementation upto function dtal branch instruction branches label value equals typing rules listed 
leads concise dtal code 
example adopted necula lee clearly involved :10.1.1.40.2507
list element integer pair integers code sum integers list 
instance list answer 
declare datatype single pair homogeneous list ml 
optimized list representation dtal code 
treatment sum types extends harper stone 
indexed sums introduced types addition standard sum 
typing rules indexed sums essentially state ini derivable ini indicate rule applied 
relate indexed sums sum subtyping rules making subtype 
dtal interpreted int choose subtyping relation derived type coercion rules 
union single pair int single int int pair int sum single pair list var int single pair true switch case nil return case cons switch case single case pair return start int int int list mov loop int int int list int finish empty load int int int load load tag bne pair load sum int int int add load load tail int int int list jmp loop pair int int int list int sum int int int load sum int int int load int int add load int int add load load tail jmp loop finish int halt tallying numbers appearing list implementation type checker dtal prototyped type checker interpreter dtal verified examples 
implementation examples available line xi 
certain amount non determinism typing rules dtal 
implementation impose restriction eliminate non determinism 
instance rules coerce exi ivar coerce exi ivar applicable choose 
rule type open reg currently apply applicable 
alternative provide auxiliary instruction open indicate need application rule register notice explained obtain type index expressions premise rule type jmp 
practice impose certain syntactic restriction forming state types type index expressions inferred unification 
subject studied chapter xi :10.1.1.41.548
strategy adopted current implementation 
point view type checking reasonable require dtal program annotated type index expressions 
instance form instruction jmp 
xn indicate 
xn type index expressions needed typing jmp rule type jmp 
conditional branching instructions similar form 
currently accept linear constraints integers solve method fourier motzkin variable elimination dantzig 
linear integer programming problem np complete general typical constraints generated typechecking dtal code simple effectively solved 
relevant experience xi pfenning :10.1.1.36.3970
verified dtal examples including ones type checker available line xi 
compilation dtal briefly mention compiler produces dtal code source programs xanadu language syntax top level functions supported pointers allowed 
xanadu shares common features languages safe necula lee popcorn morrisett :10.1.1.126.9884
significant feature xanadu type system supports restricted form dependent types 
please see xi details 
compilation essentially compiling typical untyped assembly language need construct state types labels time 
compiled examples 
currently perform register allocation compiling xanadu dtal execute generated dtal code interpreter 
typability dtal code unaffected register allocation spill 
argument arguing proof carrying code unaffected register allocation spill necula 
restriction state type state variable declared single type index expression index type 
currently pretty printer generated dtal code took liberty dtal code leaving raw versions xi 
synthesis approach generating dtal code synthesize state types labels 
function copy map variables src dst length respectively readily generate code excluding state types labels copy loop finish exactly compilation typical assembly language 
briefly explain form state types 
state type copy directly translation type function copy 
synthesize state type loop informal reasoning 
execution reaches label loop know natural numbers satisfying types int array int array int int respectively 
readily verified analyzing loop body values stay integer value increase 
initial value value natural number execution loop 
yields state type loop 
state type finish trivial 
general identify integer variables loop values increase decrease execution loop name monotonic variables 
suppose initial value monotonic variable mapped register assume state type attached loop type int integer increasing decreasing 
simple widely applicable heuristic 
heuristic touchstone compiler array bound check elimination 
clear heuristic limited handle sophisticated cases binary search non monotonic array index heuristic ineffective trivial program 
annotation xanadu allow programmer provide loop invariants form dependent types significantly array bound checks handled practice 
top part program xanadu initializes array zeros rest dtal code compiled program 
various larger examples unwieldy xi 
function header nat unit initialize int vec indicates natural number initialize takes integer array size returns value 
type keyword invariant essentially states types int int respectively natural numbers satisfying note size array vec 
xanadu sound type system proven xi rely fact 
merely assume type annotations xanadu hints compiler 
xanadu program compiled dtal code excluding state types labels standard manner 
part exactly compiling corresponding program 
briefly mention construction state types 
notice state type attached loop essentially translated type annotation source program 
simply modify annotation include types variables mentioned replace variables registers variables mapped 
compile program xanadu expect generated dtal code guaranteed type check assuming compiler implemented correctly rigorously proven 
case source program xanadu may typed ignore nat unit initialize int vec var int vec invariant nat nat int int vec init nat sp int array sp pop mov loop nat nat nat int array int int sp sp finish store add sub jmp loop finish sp sp pop jmp implementations initialization functions xanadu dtal type annotations compile synthesis approach generated dtal code type check experimented option 
related dtal designed top tal dependent type system overcome limitations 
inheriting features tal dtal alters 
instance type tal annotated flag indicate initialization status value type adopt different strategy dtal handle initialization 
simply top represent type uninitialized values 
strategy works tuple array initialized allocation 
dtal readily transformed tal language erases syntax related type index expressions 
respect dtal generalizes tal 
notion proof carrying code introduced necula address memory safety issue mobile code follows :10.1.1.40.2507
essential idea generate proof asserting memory safety property code attach code 
proof carried code verified execution 
attractive approach challenging question remains generate proof assert memory safety property large complex program 
touchstone compiler necula lee compiles programs written type safe subset proof carrying code touchstone pcc handles question general vc generator floyd generating verification conditions type safety memory safety :10.1.1.126.9884
performs loop invariant synthesis eliminating array bound checks 
bit heavy handed handling type safety compared tal needs studied readily handle higher order functions uses essentially order logic capture invariants 
instance may desirable express function call called function takes integer returns natural number 
property readily expressed dependent types require higher order logic expressed predicates 
dml functional programming language enriches ml restricted form dependent types xi pfenning allowing programmer capture program invariants types detect program errors compile time 
particular programmer refine datatypes type index expressions dml capturing invariants various data structures 
instance form datatype dml precisely red black trees program type 
type system dml studied array bound check elimination xi pfenning :10.1.1.36.3970
dtal stands alternative design choice extending tal form dependent types largely adopted dml 
design dtal partly motivated attempt build certifying compiler dml 
proofs attached dtal code 
verifier dtal code dependent type checker consisting constraint generator constraint solver 
general proof verification easier proof search startup overhead dtal code difficult stage perform meaningful comparison 
view dtal type theoretic approach reasoning memory safety assembly level 
stronger type system tal dtal expected capture program errors slip type system tal 
supported fact dml capture program errors practice type system ml 
tal typed assembly language type system assembly level 
type system tal contains limitations prevent certain important loop optimizations array bound check elimination tag check elimination 
enriched tal restricted form dependent types enrichment leads dependently typed assembly language dtal overcomes limitations 
includes establishing soundness type system dtal implementing type checking algorithm 
constructed prototype compiler compiles xanadu programs dtal xanadu programming language syntax supports dependent type system similar dtal significantly involved 
intend continue study compiling xanadu dtal expect straightforward 
similar challenging task construct compiler dml dtal 
larger scale interested types capture program properties high level languages constructing certifying compilers translate properties low level languages 
acknowledgment gratefully acknowledge discussion jim hook subject chad brown proofreading draft providing valuable comments 
dantzig 
fourier motzkin elimination dual 
journal combinatorial theory 
floyd 

assigning meanings programs 
schwartz ed mathematical aspects computer science volume proceedings symposia applied mathematics providence rhode island pp 

american mathematical society 
harper stone 
type theoretic interpretation standard ml 
plotkin stirling tofte eds robin milner 
mit press 
appear 
milner tofte harper macqueen 
definition standard ml 
cambridge massachusetts mit press 
morrisett 

talx realistic typed assembly language 
proceedings workshop compiler support system software 
morrisett crary glew walker march 
stack typed assembly language 
proceedings workshop types compilation 
morrisett walker crary glew january 
system typed assembly language 
proceedings acm symposium principles programming languages pp 

necula 

proof carrying code 
conference record th annual acm symposium principles programming languages pp 

acm press 
necula 
september 
compiling proofs 
ph 
thesis carnegie mellon university 
available technical report 
cmu cs 
necula lee 
proof carrying code 
technical report cmu cs carnegie mellon university 
necula lee june 
design implementation certifying compiler 
acm sigplan conference programming language design implementation pp 

acm press 
tarditi morrisett cheng stone harper lee june 
optimizing compiler ml 
proceedings acm sigplan conference programming language design implementation pp 

tolmach oliva july 
ml ada strongly typed language interoperability source translation 
journal functional programming 
xi 

dependent types practical programming 
ph 
thesis carnegie mellon university 
pp 
viii 
available www cs cmu edu dml thesis ps 
xi 

dependent types imperative programming 
current version www uc edu academic papers xanadu ps 
xi 

implementations examples xanadu dtal 
available www uc edu xanadu dtal 
xi pfenning june 
eliminating array bound checking dependent types 
proceedings acm sigplan conference programming language design implementation montreal pp 

xi pfenning january 
dependent types practical programming 
proceedings acm sigplan symposium principles programming languages san antonio pp 


