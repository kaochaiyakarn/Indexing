nesc language holistic approach networked embedded systems david gay intel research net matt welsh intel research net sourceforge net philip levis pal cs berkeley edu eric brewer brewer cs berkeley edu robert von behren cs berkeley edu david culler culler cs berkeley edu eecs department intel research berkeley university california berkeley ave suite berkeley ca berkeley ca nesc programming language networked embedded systems represent new design space application developers 
example networked embedded system sensor network consists potentially thousands tiny lowpower motes execute concurrent reactive programs operate severe memory power constraints 
nesc contribution support special needs domain exposing programming model incorporates event driven execution flexible concurrency model component oriented application design 
restrictions programming model allow nesc compiler perform program analyses including data race detection improves reliability aggressive function inlining reduces resource consumption 
nesc implement tinyos small operating system sensor networks significant sensor applications 
nesc tinyos adopted large number sensor network research groups experience evaluation language shows effective supporting complex concurrent programming style demanded new class deeply networked systems 
categories subject descriptors programming languages general general terms design languages keywords programming languages concurrency data races components modules order nesc tinyos permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
pldi june san diego california usa 
copyright acm 

advances networking integration enabled small flexible low cost nodes interact environment sensors actuators communication 
single chip systems emerging integrate low power cpu memory radio optical communication substantial mems onchip sensors nodes colloquially referred motes smart dust 
target costs single chip motes cents unit enables networks potentially tens thousands motes 
target power consumption means motes years low bandwidth communication battery free fueled ambient power heat environment 
nesc systems programming language networked embedded systems motes 
nesc supports programming model integrates reactivity environment concurrency communication 
performing program optimizations compile time data race detection nesc simplifies application development reduces code size eliminates sources potential bugs 
key focus nesc holistic system design 
mote applications deeply tied hardware mote runs single application time 
approach yields important properties 
resources known statically 
second employing general purpose os applications built suite reusable system components coupled application specific code 
third hardware software boundary varies depending application hardware platform important design flexible decomposition 
number unique challenges nesc address driven interaction environment traditional computers motes data collection control local environment general purpose computation 
focus leads observations 
motes fundamentally eventdriven reacting changes environment message arrival sensor acquisition driven interactive batch processing 
second event arrival data processing concurrent activities demanding approach concurrency management addresses potential bugs race conditions 
limited resources motes limited physical resources due goals small size low cost low power consumption 
expect new technology remove limitations benefits moore law applied reduce size cost increase capability 
current motes measured square centimeters version built measures mm reliability expect individual motes fail due hardware issues enable long lived applications 
example environmental monitoring applications collect data human interaction months time 
important goal reduce run time errors real recovery mechanism field automatic reboot 
soft real time requirements tasks time critical radio management sensor polling focus hard real time guarantees 
experience far indicates timing constraints easily met having complete control application os limiting utilization 
timing critical aspects sensor networks radio communication fundamental unreliability radio link necessary meet hard deadlines domain 
nesc synthesis existing language concepts targeted problems provides broad contributions 
nesc defines component model supports eventdriven systems model provides bidirectional interfaces simplify event flow supports flexible hardware software boundary admits efficient implementation avoids virtual functions dynamic component creation 
second nesc defines simple expressive concurrency model coupled extensive compiletime analysis nesc compiler detects data races compile time 
combination allows applications exhibit highly concurrent behavior limited resources 
third nesc provides unique balance accurate program analysis improve reliability reduce code size expressive power building real applications 
addition static data race detection nesc compiler performs static component instantiation program inlining dead code elimination 
prohibit features hinder static analysis including function pointers dynamic memory allocation capable supporting complex applications substantial user community 
nesc programming language tinyos small operating system sensor network applications research groups worldwide 
significant sensor network applications implemented nesc including tinydb sensor network query processing engine mat small virtual machine allows rapid reprogramming sensor networks 
section presents background material sensor networks introduces surge sample nesc application running example 
section presents nesc design section summarizes experience nesc evaluates effectiveness data race detection inlining 
conclude survey related section discussion nesc directions section 

background wireless sensor networks composed large numbers tiny resource limited devices motes 
application networks data collection uncontrolled environments nature reserves threatened structures 
key features emerged networks deployed interaction local environment sensors communication wireless network lifetime requirements months year physical 
table presents generations motes designed uc mote type rene rene dot mica date microcontroller type ls atmega atmega prog 
mem 
kb ram kb communication radio rfm tr rate kbps modulation type ook ook ask table family tinyos motes 
berkeley 
resource constrained motes reactive participate complex distributed algorithms data aggregation spatial localization 
combination requirements traditional operating systems programming models inappropriate sensor networks 
mote hardware evolves rapidly table covers platforms years different sensors varying levels hardware support operations radio messaging 
sensor network operating system programming language easy applications adapt changes 
tinyos tinyos operating system specifically designed network embedded systems 
tinyos programming model tailored event driven applications small footprint core os requires bytes code data memory combined 
motivations designing nesc support evolve tinyos programming model reimplement tinyos new language 
tinyos important features influenced nesc design component architecture simple event concurrency model split phase operations 
component architecture tinyos provides set reusable system components 
application connects components wiring specification independent component implementations application customizes set components uses 
os components software modules thin wrappers hardware distinction invisible developer 
decomposing different os services separate components allows unused services excluded application 
nesc support components sections 
tasks event concurrency sources concurrency tinyos tasks events 
tasks deferred computation mechanism 
run completion preempt 
components post tasks post operation immediately returns deferring computation scheduler executes task 
components tasks timing requirements strict includes nearly operations low level communication 
ensure low task execution latency individual tasks short lengthy operations spread multiple tasks 
lifetime requirements sensor networks prohibit heavy computation keeping system reactive 
events run completion may preempt execution task event 
events signify completion split phase operation discussed event environment message reception time passing 
tinyos execution ultimately driven events representing hardware interrupts 
discuss refinement inclusion tinyos concurrency model nesc sections 
split phase operations tasks execute non preemptively tinyos blocking operations 
long latency operations split phase operation request completion separate functions 
commands typically requests execute operation 
operation split phase command returns immediately completion signaled event non split phase operations toggle led completion events 
typical example split phase operation packet send component may invoke send command initiate transmission radio message communication component signals event transmission completed 
component implements half split phase operation calls wiring connects commands events component boundaries 
discuss nesc captures split phase operations section 
resource contention typically handled explicit rejection concurrent requests 
example communication component handle multiple concurrent send operations signals error concurrent send attempted 
alternately communication component queue request processing 
simple concurrency model tinyos allows high concurrency low overhead contrast thread concurrency model thread stacks consume precious memory blocking contended service 
concurrent system concurrency non determinism source complex bugs including deadlock mars rover data races 
primary benefits nesc helping programmer concurrency safely ensuring absence data races 
discussed section 
surge sensor network application common application sensor networks sample sensor periodically light temperature report readings base station typically node wired network connection power source 
running example surge simple application performs periodic sensor sampling uses ad hoc multi hop routing wireless network deliver samples base station 
surge intentionally simple perform advanced functions network data aggregation 
surge motes organize spanning tree rooted base station 
mote maintains address parent depth tree advertising depth radio message sensor sample forwarded message transmits 
node selects initial parent listening messages choosing node smallest depth seed creation spanning tree base station periodically broadcasts beacon messages depth 
nodes estimate parent link quality link quality falls threshold nodes select new parent neighbor set link quality estimates depth 
second mote samples light sensor sends sample parent 
parents acknowledge received packets 
surge uses acknowledgments provide reliable transport layer parent link quality calculated fraction transmitted messages acknowledged 
node receives message node forwards message parent 
sensor samples collected base station analyzed visualized 
shows components surge interfaces wired 
example shows important advantages components 
surge application needs include parts tinyos needs system boot code timer clock timer multihop surge sendmsg sendmsg sendmsg leds leds adc photo simplified view surge application 
nodes represent components edges represent interface wiring 
edges labeled corresponding interface name 
main timer timer sensor photo access leds leds multi hop message routing multihop 
secondly application code surge component explicitly specifies environmental dependencies terms interfaces 
surge requires timer timer interface sensor adc interface leds leds interface communication send interface 
code independent particular sensor hardware 
example adc easily wired temperature sensor light sensor long provide interface 

nesc design section discuss primary concepts nesc design 
nesc applications built components defined bidirectional interfaces 
second nesc defines concurrency model tasks events detects data races compile time 
basic principles underlie nesc design nesc extension produces efficient code target microcontrollers sensor networks 
provides low level features necessary accessing hardware interaction existing code simplified 
programmers familiar significant disadvantages provides little help writing safe code structuring applications 
nesc addresses safety reduced expressive power structure components 
new features nesc tied ideas added imperative programming languages modula 
program analysis nesc programs subject program analysis safety optimization performance 
consider separate compilation nesc design 
limited program size motes approach tractable 
nesc static language dynamic memory allocation call graph fully known compile time 
restrictions program analysis optimization significantly simpler accurate 
sound onerous practice nesc component model parameterized interfaces eliminate needs dynamic memory allocation stdcontrol timer module provides interface stdcontrol interface timer uses interface clock clk 
specification graphical depiction component 
dynamic dispatch 
far implemented optimization analysis simple program inliner data race detector 
details section 
nesc supports reflects tinyos design nesc concept components directly supports tinyos eventbased concurrency model 
additionally nesc explicitly addresses issue concurrent access shared data section 
practice nesc resolved ambiguities tinyos concepts components concurrency tinyos evolved nesc versions reimplemented 
component specification nesc applications built writing assembling components 
component provides uses interfaces 
interfaces point access component 
interface generally models service sending message specified interface type 
shows component part tinyos timer service provides stdcontrol interfaces uses interface shown 
provides logic maps hardware clock clock tinyos timer abstraction timer 
interfaces nesc bidirectional contain commands events essentially functions 
providers interface implement commands users implements events 
instance timer interface defines start commands fired event 
provided interfaces shown component interfaces downward pointing arrows depict commands upward pointing arrows depict events 
interaction timer client provided separate interfaces start fired grouping commands events interface specification clearer helps prevent bugs wiring components 
split phase operations cleanly modeled placing command request event response interface 
shows examples 
interface command event packet send section 
adc interface similarly model split phase sensor value reads 
separation interface type definitions components promotes definition standard interfaces making components reusable flexible 
component provide interface type interposing component client service provide interface multiple times 
cases component give interface instance separate name notation shown 
components clean way boundary hardware software 
instance sensor board temperature sensor accessed component named temp hardware temp thin layer software accessing chip hardware registers 
accessed interface stdcontrol command result init interface timer command result start char type uint interval command result event result fired interface clock command result char interval char scale event result fire interface send command result send tos msg msg uint length event result tos msg msg result success interface adc command result getdata event result uint data interface types 
module provides interface stdcontrol uses interface adc uses interface timer uses interface send implementation uint command result stdcontrol init return call timer start timer repeat event result timer fired call adc getdata return success event result adc uint data data send message data return success 
simplified excerpt 
bus temp implemented number interacting components including generic access component 
subtle important point bidirectional interfaces easy support hardware interrupts 
contrast way interfaces procedure calls force hardware polling having separate interfaces hardware operations corresponding interrupts 
component implementation types components nesc modules configurations 
modules provide application code implementing interfaces 
configurations wire components connecting interfaces components interfaces provided 
nesc application described toplevel configuration wires components 
body module written code straightforward extensions 
command event interface named command call regular function call prefixed keyword call similarly event signal function call prefixed signal 
definition commands event stdcontrol timer clock stdcontrol timer clock configuration provides interface stdcontrol interface timer implementation components stdcontrol stdcontrol timer timer clk clock tinyos timer service configuration 
stdcontrol adc photo main stdcontrol stdcontrol stdcontrol timer adc timer sendmsg leds stdcontrol multihop sendmsg leds configuration top level configuration 
named prefixed command event 
require annotations improve code clarity 
simplified excerpt part surge application 
defines stdcontrol init command called boot time events handled surge firing timer timer fired sensor data acquisition adc 
code calls timer start command setup periodic timer events adc getdata command request new sensor sample 
modules private state example variable 
tinyos timer service implemented configuration shown 
built wiring subcomponents declaration access chip clock 
maps stdcontrol timer interfaces stdcontrol stdcontrol timer timer connects hardware clock interface provided clk clock 
shows elaborate example toplevel configuration surge application 
interface component may wired zero times 
result arbitrary number command call expressions may wired single command implementation fanin single command call expression may connected arbitrary number command implementations fan 
instance shows calls init connected different implementations photo 
nesc allows fan degree zero wires module implementer provides default implementation command 
fan degrees greater allowed long return type command associated function combining results calls 
case stdcontrol init result type result represents success failure 
combining function implements logical results result call stdcontrol init main success exactly implementations succeed 
analogous situations event signal expressions handled identically 
explicit wiring components interfaces combined removal function pointer types control flow components explicit 
module variables private design style tinyos discourage sharing data components 
taken easier write correct components understand behavior wired application 
components tinyos represent services timer pieces hardware leds exist single instance 
useful create instances component 
nesc achieved declaring component optional parameters components created compile time configurations 
instance component multi hop communication component takes maximum retransmit count parameter module int 
configuration multihop provides interface send implementation components 
send send send 
concurrency atomicity data races occur due concurrent updates shared state 
order prevent compiler understand concurrency model determine target update 
section concurrency model key invariant compiler enforce avoid data races 
achieve tractable target analysis reducing expressive power language performing alias analysis 
particular nesc dynamic memory allocation function pointers 
tinyos code runs asynchronously response interrupt synchronously scheduled task 
facilitate detection race conditions distinguish synchronous asynchronous code asynchronous code ac code reachable interrupt handler 
synchronous code sc code reachable tasks 
run completion rule sequential execution tasks lead immediately key invariant invariant synchronous code atomic respect synchronous code 
atomic mean shared state updated atomically 
essentially provides atomicity default tasks 
code includes split phase operations definition include tasks atomic point implementation issues warning function pointers 
half atomic 
discuss larger units atomicity section 
non preemption allows avoid races tasks potential races sc ac ac ac 
claim claim update shared state ac potential race condition 
claim update shared state sc updated ac potential race condition 
reinstate atomicity cases programmer options convert sharing code tasks sc atomic sections update shared state 
atomic section small code sequence nesc ensures run atomically 
syntax implementation issues atomic sections section 
require update shared state potential race condition claims occur atomic section 
gives basic invariant race free invariant update shared state potential race condition sc occurs atomic section 
nesc enforce invariant compile time avoids data races 
note invariant guarantees individual accesses race free incorrect atomic sections lead race conditions 
concurrency nesc concurrency central nesc components events commands may signaled directly indirectly interrupt asynchronous code 
handle concurrency nesc provides tools atomic sections tasks 
illustrates showing core logic surge application 
timer fired asynchronous code 
fired event signaled periodically 
surge busy adc getdata called get new sensor value 
busy accessed asynchronous code protected atomic statement performs test set 
sensor value available adc event signaled 
sending message sensor reading time critical operation tinyos communication layer designed executed asynchronous code 
posts task sends sensor reading message 
posted tasks executed tinyos scheduler processor idle 
currently implement atomic disabling enabling interrupts low overhead cycles 
leaving interrupts disabled long period delays interrupt handling system responsive 
minimize effect atomic statements allowed call commands signal events directly called function 
confines code executed anatomic statement single module making possible module implementer bound atomic statement execution time 
discussed section atomic prevents concurrent access shared data accessed statement 
atomic sections define key rule enforces race free invariant variable accessed ac access outside atomic statement compile time error 
compiler reveals specific conflict addition signaling error 
remove error programmer add atomic section move offending code task 
module 
implementation bool busy uint event result timer fired bool atomic busy busy true call adc getdata return success task void send data call send send sizeof data return success event result adc uint data data post return success 
concurrency atomicity 
changes highlighted 
cases potential data race variable programmer knows actual data race 
declaration reading includes qualifier suppress errors particular false positive 
avoids protecting accesses statements 
section shows effectively detect large number data races 
parameterized interfaces parameterized interfaces nesc mechanism introducing runtime command event dispatch order language 
component declares interface parameter list creates separate interface tuple parameter values 
parameterized interfaces model active messages tinyos active messages packets contain numeric identifier specifies event handler executed 
shows simplified definition communication component 
wires parameterized interface specify specific interface compile time constant multihop message routing uses active message communication wires send 
module implemented commands events parameterized interface receive extra parameters specifying selected interface send module select specific interface invoking command event parameterized interface see 
construction translates runtime dispatch functions connected send application configurations 
set possible dispatch targets explicitly specified program configurations 
additional benefit ram needed store active message dispatch table 

evaluation section evaluate nesc component model concurrency model program inlining respect set representative tinyos applications including surge tinydb module id active message id provides interface send uint id provides interface receive uint id implementation tos msg msg command result send send uint id uint length tos msg data data id msg data 
void tos msg packet signal send msg msg success configuration multihop 
implementation components send active messages parameterized interfaces 
mat 
implemented compiler nesc generates single source file application resolving interface connections direct function calls 
results file compiled gcc atmel atmega bit risc microprocessor mica mote table 
component model anecdotally nesc component model invaluable event driven sensor applications 
success component model shown way components tinyos code applications small large number reusable components 
nesc component model possible pick choose parts os included application 
purposes discussion divided tinyos source application code core os code 
consider core os code fundamental things tinyos scheduler radio stack commonly support routines timers sensor management code considered application specific 
additionally restricted calculations hardware platform avoid double counting hardware support routines 
core tinyos source consists components code modules configurations 
number modules application tinyos release ranges average 
modules generally quite small average lines code 
small size indicates expressive power nesc components programmers needed break model producing large monolithic components difficult analyze error prone 
illustrates effectiveness component model sample applications 
shows total number modules lines code application number modules lines code come os components 
include os numbers fraction os application ended including 
numbers show small portion os application 
nesc component model restricts code included application bare minimum reducing application memory footprint 
nesc bidirectional interfaces excellent fit event driven systems provide clean syntax grouping related computation presence split phase asynchronous operations 
evidence bidirectional interfaces pervasive application modules os modules lines os lines full os full os surge mat tinydb application component os breakdown 
application task event interrupt count count code surge mat tinydb application concurrency summary 
tinyos components tinyos core bidirectional interface 
concurrency nesc component model simple express complex concurrent actions sensor network applications 
gives number tasks event handlers sample application represents potentially concurrent activity 
gives percentage code measured bytes reachable interrupt context 
numbers demonstrate applications high degree concurrency 
implementation race detection uses simple type alias analysis detect variables accessed asynchronous code 
report errors variables accessed outside atomic sections 
initially nesc included statement analysis detect potential race conditions tinyos applications data races 
race detection implemented analyzed application tinyos source tree finding variables potentially race condition 
false positives discussed genuine race conditions frequency code statements 
fixed bugs moving code tasks atomic statements 
tested tinyos application verified presence atomic sections interfered correct operation 
shows locations data races tinyos tree 
component type data race variables system system system system application application system application system system application system application application application system system system application total component locations race condition variables 
contains race fixed version state idle uint state sending atomic count state send packet state idle state sending idle count send packet fixing race condition state transition 
half races existed system level components applications half application specific 
disproportionate number races due amount internal state maintain complex concurrent operations 
tracks node interactions records flash periodically sends basestation complex concurrency lots state written concurrency issues understood 
finite state machine style decomposition tinyos led common form bug non atomic state transition 
state transitions typically implemented read modify write state variable atomic 
canonical example race shown fix 
original versions communication eeprom components contained large numbers variable accesses asynchronous code 
large atomic sections decrease responsiveness promoted offending functions synchronous code posting additional tasks 
false positives fell major categories state guards buffer swaps causal relationships 
class state guards occurred access module variable serialized run time state variable 
state transition example illustrates function variable count safe due monitor created 
tinyos communication primitives buffer swapping policy memory management 
network packet received radio component passes buffer application application returns separate buffer component receive event 
raises problems alias analysis component buffer time components swap back forth 
alias analysis conclude components concurrently read write buffer swapping ensures component time 
resolve issue annotated message buffers qualifier 
class false positives causal relationships comes split phase operation tinyos components 
command event pair split phase operation share variable causal relationship means event fire command executing 
event fire command tinyos component accessed underlying hardware violate tinyos programming model nesc enforce limitation 
classes false positives high risk worth verifying hand 
absence data races depends strict idioms easy access message buffers concurrently accident possible split phase operation running concurrently breaking assumption phases overlap 
app code size code data size cpu inlined reduction reduction surge mat tinydb effect inlining application footprint performance 
sizes bytes 
cpu reduction column shows reduction cpu cycles spent executing tasks optimizations enabled 
cycles optimized unoptimized reduction boundary crossing non interrupt interrupt total optimization effects timer event handling 
shows breakdown cpu cycles boundary crossing timer event handling requires module crossings 
optimization reduces cycle count 
hope able reduce number false positives extending nesc ideas static checking software protocols vault 
optimization data race detection nesc exploits restrictions component model perform static analysis optimization 
nesc compiler uses application call graph eliminate unreachable code module boundary crossings inline small functions 
allows extensive cross component optimizations including constant propagation common subexpression elimination performed back compiler 
optimizations greatly reduce memory footprint execution overheads key savings embedded systems 
evaluate effectiveness inlining giving reductions code size cpu usage representative applications including detailed component component code size breakdown surge 
show analysis single important code path inlining effective reducing overhead nesc component system 
shows applications code size bytes optimizations data sizes decrease execution cycles spent tasks obtained inlining 
networking stack dominates execution time applications show reduction cpu cycles time spent executing tasks nearly application level code 
nesc optimizations lead reduction execution time reduction footprint 
gives breakdown cpu cycle reduction handling timer event requires crossing module boundaries 
nesc optimizations save boundary crossing overhead required handle timer event total savings 
increase boundary crossing overhead interrupt occurs inlining requires handler save registers total time spent handler goes 
provides detailed breakdown code data size component surge application 
tinyos row represents core tinyos initialization code task scheduler fits bytes 
runtime represents necessary runtime component code size data size sizes bytes inlined runtime tinyos runtime application components multi hop communication radio stack sensor acquisition miscellaneous hardware presentation totals breakdown code data size component surge application 
inlined column indicates corresponding component entirely inlined 
routines including floating point libraries currently multihop routing 
note inlining increases code size slightly components reduces eliminates leading reduction footprint 

related module systems languages modula plus descendants ada explicitly import export interfaces 
systems flexible nesc explicit binding interfaces exported interface automatically linked standard ml module system offers similar functionality nesc circular component structure assemblies expressed 
nesc module system close mesa coincidentally uses essentially terminology modules contain executable code configurations connect components configurations modules binding interfaces interface types match 
esterel lustre signal frp languages target embedded hard real time control systems 
explicitly model concept input events output control signals offer stronger time guarantees nesc 
general purpose programming languages implement multi hop radio stack 
vhdl hardware description language assembling components architecture defined interfaces 
architectures specified independent processes architectures built components encapsulate inner components 
contrast nesc configurations encapsulate components concurrency crosses component boundaries 
vhdl model matches actual hardware nesc inspired hardware 
language targeted generating hardware order functional language 
allow hardware generation recursion static data allocation 
distributed systems including corba component model microsoft com software engineering model systems interacting sets components 
components specified interfaces provide 
focus different nesc components large scale database dynamically loaded linked possibly accessed remotely 
component models heavyweight nesc include features required tinyos 
bidirectional interfaces ports 
interface types port connections match methods name signature fan limited methods result dispatch port methods dynamic 
support events classes interfaces 
directions asymmetric registration event handler event producer dynamic 
languages languages commonly programming embedded systems ada forth offer set features desired nesc interrupt concurrency model low level hardware access component programming static concurrency checking 
number operating systems explored component architectures 
flux oskit collection components building operating systems provided components target workstation machines 
flux subsequently reimplemented help knit language constructing linking components implemented knit component model units similar nesc components provide interfaces new components assembled existing ones 
nesc knit lacks bidirectional interfaces data race detection 
think takes flux model step allowing explicit modeling calls components 
allows clean linking think components protection domains networks 
think employ optimization relies dynamic dispatch 
believe model associated runtime cost appropriate network embedded systems 
component oriented systems include click scout kernel 
systems specialized nesc support optimization apart optimizations click bidirectional interfaces 
traditional real time embedded operating systems vxworks qnx differ tinyos number respects 
systems generally larger provide greater functionality tinyos intended larger scale embedded systems 
refer reader tinyos thorough discussion differences systems 
attempts static detection race conditions 
esc type checker program verifier verify user supplied associations locks variables enforce ordering constraints lock acquisition 
sun statically checks inconsistent locks lock ordering 
expected tools trouble class functions aliasing tend report subset errors false positives 
focus locking atomicity chose enable freedom implementation particularly important interrupts 
section covers monitors mesa 
tools dynamic detection races 
eraser detects unprotected shared variables modified binary :10.1.1.161.222
fly race detectors serialize accesses variable verify serializability 
approaches catch errors occur test run 
addition dynamic approaches appealing motes due number resource limitations ui constraints 
race detection systems including nesc validate individual variable accesses 
detect read modify write temporary variable read write occur distinct atomic sections 

discussion nesc language suited unique challenges programming networked embedded systems 
nesc originally designed express concepts embodied tinyos reimplementing operating system nesc concepts refined 
nesc component model supports holistic system design making easy assemble applications include necessary os support 
component model allows alternate implementations flexible hardware software boundary 
nesc concurrency model allows write highly concurrent programs platform limited resources bidirectional interfaces atomic statements permit tight integration concurrency component oriented design 
careful restrictions programming model including lack dynamic allocation explicit specification application call graph facilitate program analyses optimizations 
aggressive inlining reduces memory footprint cpu usage static data race detection allows developer identify fix concurrency bugs 
nesc design opens key areas 
broadly fall areas concurrency support enhancements language features application domains networked embedded systems 
concurrency support nesc concurrency model provides short atomic actions build higher level synchronization mechanisms semaphores condition variables atomic queues locks 
mechanisms imply blocking language se prevents support blocking need prohibit blocking calls atomic sections treat blocking calls yield points task scheduling 
current implementation atomic sections works embedded systems disable interrupts 
acceptable part prevent blocking limit length atomic sections 
depends assumption uniprocessor lack virtual memory page fault occur atomic section 
assumptions relaxed considering alternate implementations atomic sections example non blocking synchronization primitives 
monitors mesa directly comparable concurrency model 
mesa authors considered rejected atomicity non preemption reasons including desire support multiprocessors virtual memory 
non preemption handle interrupts atomic sections handle asynchronous updates shared state 
mesa unable prevent calls atomic sections yielding processor 
issue nesc 
language enhancements number idioms common tinyos expressed nesc 
multi client services client state supported 
example consider general timer service client wishes receive timer events different frequency 
components purpose currently limited internal state instance private instance 
currently parameterized interfaces implement multi client services parameter corresponds client number wholly satisfied approach plan investigate better mechanism 
split phase operations provide high concurrency low overhead difficult program convenience threaded model greatly simplify programming 
automatically transforming blocking operations split phase calls preserve expressive lightweight concurrency forcing programmer manually build continuations components 
stands components written small finite state machines atomic state transitions result replicated control flow separating state transitions corresponding actions 
direction nesc provide explicit support fsm style decomposition simplifies component design allows properties fsm behavior statically verified 
application platforms believe nesc limited domain embedded systems 
nesc component oriented structure focus concurrency bidirectional interfaces valuable concepts programming larger systems enterprise class applications internet services 
effectively support broader class applications extensions nesc needed 
nesc compile time analyses need extended handle dynamic memory component allocation patterns message buffer swap 
static checking software protocols vault may provide approach solving problems may help reducing false positives data race detection 
nesc concurrency model extended admit multiprocessors blocking operations general notion threads discussed 
approach lead rich set concurrency primitives specifically tailored programming large scale systems 
supported part defense department advanced research projects agency national science foundation california micro program intel 
research infrastructure provided national science foundation eia 

aldrich chambers notkin 
architectural reasoning 
european conference object oriented programming ecoop june 
bass buhrman long robert 
volume ii technical concepts component software engineering nd edition 
technical report cmu sei tr carnegie mellon software engineering institute may 
benveniste guernic 
synchronous programming events relations signal language semantics 
science computer programming sept 
de simone 
esterel language 
proceedings ieee sept 
de bruin 
langage controlling component interactions 
journal supercomputing 
accepted publication 
deline fahndrich 
enforcing high level protocols low level software 
proceedings acm sigplan conference programming language design implementation pages june 
detlefs leino nelson saxe 
extended static checking 
technical report palo alto usa 


stefani lawall muller 
think software framework component operating system kernels 
proceedings usenix annual technical conference june 
flatt felleisen 
units cool modules hot languages 
proceedings acm sigplan conference programming language design implementation pages 
ford back benson lepreau lin shivers 
flux oskit substrate kernel language research 
proceedings symposium operating systems principles pages 
halbwachs caspi raymond pilaud 
synchronous data flow programming language lustre 
proceedings ieee september 
harbison 
modula 
prentice hall 
henzinger horowitz kirsch 
embedded control systems development 
proceedings acm workshop languages compilers tools embedded systems pages june 
herbert 
ansa overview 
ieee network 
herlihy 
methodology implementing highly concurrent data objects 
acm transactions programming languages systems november 
hill szewczyk woo hollar culler pister 
system architecture directions networked sensors 
architectural support programming languages operating systems pages 
tinyos available webs cs berkeley edu 
hutchinson peterson 
design kernel 
proceedings sigcomm pages aug 
ieee standard 
vhdl language manual 
intanagonwiwat estrin govindan heidemann 
impact network density data aggregation wireless sensor networks 
proceedings international conference computing systems icdcs july 
international organisation standardization 
ada manual jan 
iso iec international standard 
odp model architecture 
jones 
really happened mars rover pathfinder 
risks digest 
kernighan ritchie 
programming language second edition 
prentice hall 
kohler chen kaashoek morris poletto 
programming language techniques modular router configurations 
technical report mit lcs tr mit laboratory computer science aug 
lab notes research college engineering uc berkeley 
smart buildings admit faults 
coe berkeley edu html 
lampson redell 
experience processes monitors mesa 
proceedings th acm symposium operating systems principles sosp pages 
leveson turner 
investigation accidents 
ieee computer july 
levis culler 
mat tiny virtual machine sensor networks 
proceedings acm conference architectural support programming languages operating systems asplos oct 
madden franklin hellerstein hong 
tag tiny aggregation service ad hoc sensor networks 
proceedings acm symposium operating system design implementation osdi dec 
mainwaring polastre szewczyk culler anderson 
wireless sensor networks habitat monitoring 
proceedings acm international workshop wireless sensor networks applications sept 
mellor crummey 
fly detection data races programs nested fork join parallelism 
proc 
supercomputing pages 
microsoft language specification 
microsoft press 
isbn 
microsoft 
windows ce 
www microsoft com 
ole programmer volume 
microsoft press 
mitchell 
mesa language manual 
technical report csl xerox parc 
morris kohler jannotti kaashoek 
click modular router 
proceedings acm symposium operating systems principles sosp pages 
mosberger peterson 
making paths explicit scout operating system 
operating systems design implementation pages 
mycroft sharp 
statically allocated parallel functional language 
proceedings internal conference automata languages programming icalp pages 
netzer 
race condition detection debugging shared memory parallel programs 
technical report cs tr 
object management group 
common object request broker architecture 
available www omg org 
object management group 
corba component model ccm specification 
available www omg org 
qnx software systems canada 
www qnx com 
reid flatt stoller lepreau eide 
knit component composition systems software 
proceedings th acm symposium operating system design implementation pages oct 
savage burrows nelson sobalvarro anderson :10.1.1.161.222
eraser dynamic data race detector multithreaded programs 
acm transactions computer systems 
sun microsystems 
enterprise java beans 
available java sun com ejb 
sunsoft 
sun workshop collection chapter lock analysis tool 
von eicken culler goldstein schauser 
active messages mechanism integrated communication computation 
proceedings international symposium computer architecture pages 
wan taha hudak 
event driven frp 
proceedings internation symposium principles declarative languages padl volume pages 
andl liebowitz pister 
smart dust communicating cubic millimeter computer 
ieee computer magazine pages january 
culler 
calibration parameter estimation sensor networks 
proceedings acm international workshop wireless sensor networks applications sept 
wind river systems ca usa 
www vxworks com 
wirth 
programming modula 
springer verlag 
wirth reiser 
programming oberon steps pascal modula 
addison wesley 
isbn 
