proving john hughes correctness reactive systems sized types lars pareto amr sabry department computer science chalmers university goteborg pareto sabry designed implemented type analysis proving properties reactive systems 
analysis manipulates rich type expressions contain formation sizes recursively defined data struc tures 
sized types useful detecting deadlocks non termination errors embedded programs 
establish soundness analysis developed appropriate semantic model sized types 
embedded functional programs reactive system control software continu ously react inputs environment 
distin class systems embedded programs naturally expressed functional programs ing streams 
class programs appears large purposes core ex formalisms accommodate asynchronous events non determinism fundamental criterion correctness pro grams embedded reactive systems ss 
considering properties output en sure output place program continuous react input streams producing elements output streams 
property may fail various ways computation stream element may depend creating black hole computation output streams may demand elements input stream different rates requires unbounded buffering computation stream element may exhaust physical resources machine diverge 
supported swedish national board rid technical development 
permission copies part material personal classroom granted fee provided copies distributed profit commercial advantage copyright notice title publication date appear notice copyright permission acm copy republish post servers lists requires specific permission fee 
popl st petersburg fla usa acm chalmers 
se support high level functional languages embedded systems developed analysis checks fundamental correctness property embed ded functional program computation stream element terminates 
main component analysis non standard type system express bounds sizes recursive data structures 
experience implementation indicates system works remarkably small realistic programs 
section motivates sized types reasoning reactive systems 
section introduces syntax semantics small functional language sized types 
sections type inference rules establish soundness wit respect semantic model types give examples illustrate strengths weaknesses 
sections deal wit details implementation experience 
concluding review related 
sized types various basic properties reactive systems notion sized types informally moti notion reasoning stream com examples 
productivity conventional lazy functional language dat atype streams natural numbers defined data st mk nat st declaration introduces new constructor natural number stream produces new stream type nat st st sample programs datatype head type st nat type st st interesting program letrec ones mk ones ones computes infinite stream words natural number request elements stream guaranteed processed finite time 
slight modification program ones mkl ones productive compute elements stream 
understand problem sume unfolding recursion times obtain stream elements 
recursive call com elements adds element produce stream elements recursive call attempting construct stream elements previous call new elements added stream 
intuitive analysis behavior programs formalised non standard type system 
system includes new family types st streams elements express informative type vi 
nat st st constructor con previous programs get intuitive types vi 
sti nat vi 
st st head tad respectively 
type ones vi 
st indicates stream infinite number elements 
program ones rightly rejected 
memory leaks sized types guarantee streams productive establish func tions unsafe computation requires unbounded space 
example consider program mk nl mk mk nz fits js stream add fits fil function fil represents idealised digital filter type vi st st requires ele ments input stream compute element output stream 
diagram infor mally calculate lower sizes streams program reveals output elements need input elements 
elements consumed bottom path 
elements con sumed top path remaining elements buffered 
size information reveals pro gram unsafe reactive system impossible implement buffer size termination example claimed type jd st sti 
words claimed elements function gum produce ele ment finite time 
inspection definition apparent claim justified prove function avg terminates 
general prove arbitrary func tion natural numbers terminates 
system include approximations nat datatype nat natural numbers 
intuitively approximation nat represents numbers constructors 
new family sized types prove type aug rz type guarantee termination function provides useful information 
syntax semantics purpose presentation restrict attention small prototypical lazy functional language syntax program consists number global declarations user defined datatypes followed term 
distinguish kinds datatype declarations data 
codata 
declaration introduces datatype name possibly parametrised vector type variables right hand side declaration introduces number term constructors dat ype con con specifies types arguments 
example possible rations natural numbers streams lists data nat zero succ nat data fmk codata stream mk stream data list nil cons list codata ilist ilist intuitively data declaration signals user inter elements datatype 
contra codata declaration signals user interested elements datatype 
nat set natural numbers set finite streams empty set stream set finite infinite streams list set finite lists ilist set finite infinite lists 
datatype name nat stream system associates family types nato nat 
nato stream types natural indices represent elements datatype size bound 
types special dex represent limit natural approximations 
example type nats represents natural numbers represents entire set natural num bers 
similarly type stream represents streams elements type infinite productive streams elements type current experiments inductive definition natural numbers built succ prove termination arithmetic functions addition basic principles 
versions system intend provide library common arithmetic functions appropriate types 
precise set type expressions inductively gener ated infinite sets dat atype names type variables var size variables ff vt type schemes tl ii mm addition usual quantification type variables type schemes may quantify size variables 
type expres sions include type variables function types indexed datatype names 
size indices special index function size variables 
get precise types tempting allow arbitrary functions size variables 
example precise type factorial vi 
nat 
nat 
get workable system restrict linear relationships size variables 
restriction size indices linear func tions st ze gn best type express function vi 

set terms inductively generated infinite sets variables var constructors con con iz az 
mi mm icon 
case mof iw letrec xn patterns full language allows mutually recursive definitions consider remainder pa 
require patterns case expression exhaustive 
language context sensitive tions introduced motivated de velopment semantics 
semantics expressions specify semantics terms conventional denotational model 
universe denotations iso morphic coalesced sum domains uj uj uj domain flat domain constructors 
definitions domain operations lifting separated sum coalesced sum cartesian product continuous function space standard 
ary pro abbreviations sequences binary ones 
symbol denotes approximation ordering universe values 
universe values semantic function maps term environment element environments map variables denotations 
semantic models types include element wrong formalises run time errors 
exclude element universe values type system rejects strictly expressions conventional accept expression evaluation causes errors 
sample semantic types definition meaning function st env vam cori mn con 
xz uj jp app iv app uj 
mi ww tf th app app universe types type subset special properties 
moti special properties examine meaning stream ones 
semantics previous section denotation stream limit chain ones sto mk sto st 
mk mk sto st 
conventional semantics types set corresponding stream dat ype set include elements appear chain 
purposes family sets corresponding types sti set contains part chain 
example set st include compute second element streams finite time 
consequence property types clude immediately invalidates standard seman definition clause case expressions ss explicit isomorphisms mapping elements summands universe vice versa 
tics types ideals intervals contrast systems define universe types collection upward closed subsets set upward closed example illustrate approximations data codata declarations natural numbers 
proposition types ut complete ordered subset relation upper bound operation set theoretic union greatest lower bound operation set theoretic intersection 
order give semantics type expressions associate upward closed set type expression language 
composite type expressions func tions sums products introduce corresponding type operations universe types set defined 
operation regular cartesian product 
set tz defined vx ti 
app 
continuity ordinals precise definition universe types associated operations study semantics user datatypes 
motivate definitions examine semantics datatypes data nat zero succ nat codata st mk nat st data sp null put sp get sp tz datatypes familiar 
datatype sp datatype stream processors fudgets library 
datatype describes kinds stream processors 
uii processor 
processor put tz sp output element type tz new stream processor 
processor get tl sp tl tz expects value type ti new stream processor 
datatype associate set approximations 
conventional way explaining meaning recursive datatype declarations fixed point functional universe types 
functional easily derivable declarations function definition omitted 
nat st sp ti tz fp semantic models retracts appropriate reason support form implicit polymorphism common programming languages 
fp zero succ mk xr null put get calculate datatype meaning approximations 
straightforward manner 
simply put meaning ith approximation fold application functional bottom element fj top element lattice types 
choice initial element depends datatype declared data codata 
meaning ignoring injections tags fn fn zero succ fn zero qi fn zero zero succ zero zero succ zero invite reader trace calculation meaning st 
point expect meaning wth approximation datatype simply data greatest codata fixed point corresponding functional 
complete lattice lattice types fixed point functional calculated follows 

functional monotone limit may exist 
functional monotone continuous fixed point ordinal ex 
fo fi fa uj fj limit ordinal greatest fixed point calculated similar argument dual lattice 
functional continuous ordinal previous case limit ordinal words expect meaning wth approximation coincide greatest fixed point continuous 
running examples functional fs continuous meanings nat 
st computed lj fj ok 
uj respectively 
contrast functional fp monotone contin uous wth approximation correspond fixed point 
technical point important practical consequences 
example consider term letrec rid case zero null succ put get 
rid represents stream processor num ber outputs elements null processor 
evaluation stream processor clearly terminates argument type system handle term argument shows 
note example stream processors manipulate natural numb ers types oft construct ors follows abbreviate spi nat 
nato 
null put vi natu spn get vi 
spn spn types note meaning null 
general meaning set stream processors terminate put get operations 
set union sets spn 
words set processes terminate fixed number operations regardless oj inputs 
clearly get rid set spn 
hand natu 
follows get jn 
rid functional fp continuous identical 

alternatives 
allow declaration datatype sp accept term get 
rid 
means prepared handle indices range ordinals 

allow declaration ype sp reject programs require ordinal indices reject term get 
rid 

reject declaration datatype sp defines non continuous functional 
simplicity reasons opted third alternative 
choice demands find simple syntactic criteria ensure datatype declarations yield continuous functional 
identifying problematic positions declaration 
definition type expression occurs non continuous af ul occurs argument argument codata name occurs argument data name occurs non continuous right hand oj declaration type expression occurs non continuous occurs left argument occurs argument data codata name ri non continuous position hand side name 
restriction datatype declarations simple 
restriction data declaration declared type occur non continuous 
codata declaration declared type occur non continuous 
easily verify previous claims regarding continuity nat st sp 
interesting examples consider declarations data ord zero succ ord lim stream ord data tree leaf node list tree data list nil cons list declaration ord occurs argument name violating condition 
ord canonical non continuous type 
declaration tree declared type tree passed argument list potentially violating condition 
ensure condition violated check occur non lj continuous position right hand side declaration list 
ord sp accepted declared data accepted declared codata 
means reason termination stream processors prove deadlock 
major consequence restriction treat infinite sizes identical words identities reasoning programs 
semantics types speci precise semantics type expressions 
definition type semantics maps type expression environments semantic type ux env ut tvar ut env svar clauses value size expression environment functional mg datatype name rk 
proposition function defined 
proof sketch 
easy verify type constructors maps upward closed sets upward closed sets 
testing major property semantic model possible test included type crucial reject programs may diverge 
types upward closed sets test type includes 
quite simple define mutually recursive predicates empty decide denotation type expression empty set universe respectively empty empty notempty ds notempty notempty empty ri empty notempty notempty empty predicates sound complete respect semantic model 
types value large size expressed restricted language give size example type give factorial vi nat nat 
face problem want compute fur ther result 
suppose example want type factorial factor 
type outer application fac need give type instantiating 
size variables range naturals valid 
case result clearly sound 
goal extend system allow instantiation size variables define substitution size variable interesting cases ds ds fv ds iw ds simpli sizes involving directly justified size expressions express strictly mono tonic functions free variables 
immediately encounter problem sound instantiate size variables example suppose type vi 
stream nat unit 
know terminates bounded sequence 
give type stream unit show terminates sequence 
need case consider function searches element value position stream 
aim find syntactic conditions types guarantee proposed extension sound 
ti type expression indexed size variable abbreviate tw 
want guarantee vi ni 
semantically speaking want guarantee rti 
case say 
say monotonic implies anti monotonic dual case 
recognised easily ni monotonic occurs positively antimonotonic occurs negatively 
definitions positive negative occurrences usual extension occurrence size data type considered positive occurrence size codata type considered negative 
clearly monotonic types instantiable instance bigger finite ones hardly interesting 
interesting anti monotonic examples stream bool mixed stream 
monotonicity strong condition impose 
define slightly stronger condition successfully induction hypothesis 
definition indexed type zf ui tf ti ew set overshooting uin 
intuitively says sequence nis tends tu says holds suffix sequence 
clearly types instantiable monotonic types 
converse necessarily true example monotonic anti monotonic types overshooting 
converse true overshooting anti monotonic constant types set cent zero type variables datatype unit overshooting sums products overshooting types respectively overshooting 
definitions motivated result 
proposition overshooting xi 
proof 
show flj rj nj nj 
take arbitrary mm show 
overshooting nj tj 
know fl kit xj 
ma tf check function type instantiable need check argument types overshooting result type 
example nat nat stream inst 
covariant position contravariant position expect dual result hold overshooting function types 
type nat 
nat overshooting ji lj nat 
set bounded functions nat 
nat 
contains unbounded ones 
settle anti monotonicity sufficient condition function types overshooting possible weaken requirement function types finite domains consider worthwhile 
remains find general conditions data codata types properties 
functional types iterated define semantics data codata type question 
functional depend example type stream nat mk rl nat el 
expressible language property needed prove proposition 
lemma fi fl fj fi 
size expression possibly involving constant strictly monotonic 
prove propositions 
proposition types xi fi ni uj nj 

proposition types zf overshooting fl overshooting overshooting 
results give simple way check data codata type data type overshooting 
size irrelevant simply check components property assuming recursive occurrences data codata type 
example nat list nat type built data types 
likewise stream nat conclude overshooting 

subtyping relation set productive streams elements eventually position stream superset stream set productive streams 
fall back anti monotonicity sufficient condition dat type overshooting doubt weaker condition 
type system presenting type inference rules subtype relation crl uj 
motivation infer bounds sizes possible relax current bound accurate 
flexibility impossible type programs mk branches sizes differ 
relation defined 
straightforward show semantic count erp art relation subset relation 
lemma environments qal qm 
main innovation type inference system rule typing recursive declarations 
presenting entire set rules discuss simple version letrec rule include generalisation free type variables 
type environment maps variables constructors type expressions kf vz di zl ru letrec fv rule hae premises 
main middle states functional defining recursive value ought progress recursive call producing values size 
depending size variable indexes data declaration codata declaration size bigger smaller set respectively 
typing rule prove computations data objects terminate computations codata objects productive 
premise bottom check ensures start iteration var abs ru con con tl pat tl mi case mof pl ml 
pn mn rem fv kf rl case gen rfm cj rt lt vi rr ti rl 
ii vi vi letrec functional place 
concludes implicit induction principle recursive object safely size 
motivate importance bottom check example illustrates rule unsound omit 
example consider term head mk true mk false easy verify program diverges stream productive 
assuming type st right hand side type st 
words functional making progress recursive call required main premise letrec rule 
failure bottom check st guarantees program correctly rejected 
rules type inference 
rules variables procedures applications constructors generalisation instantiation type variables exploit affect sizes standard 
notation con refers type constructor con inferred corresponding datatype declaration 
rule uses auxiliary judgement defined follows pat con zl 
zn xl inst provides generic instance type scheme 
rest inference rules rely size tions 
generalise instantiate size variables natural way insts respectively 
second coerce type precise type relaxing sizes 
third size variables index type expressions typing recursive declarations ret ensure resulting computations terminating productive 
rules type inference app ret main technical result soundness type system 
theorem type soundness prove type denotation element type denoted proof 
proof proceeds induction height type derivation proceeds case analysis rule 
inductive hypothesis states relation ir holds 
relation defined iqr ct 
cases proof standard 
subtyping case follows lemma 
soundness typing rule case expression requires patterns exhaustive 
soundness instantiation rule sketched section 
rec case detail assume letrec jf iv 
want show letrec inductive hypothesis get ke 
qk qp nk el wj claim vi fk modulo obligation prove claim result follows 
fk 
types upward closed 
nk 
vi 

inductive hypothesis complete argument prove claim 
proof proceeds induction claim reduces ii immediate consequence ch ck 
ea lp 
type system induct ive hypothesis property definition talking actual implementation attempt gain intuition strengths weaknesses system small examples 
primitive recursion reverse system strong prove termination productivity functions primitive recursive form 
example assuming append function lists type cf 
section append vij vt prove naive follows reverse vi 
vt st list xs case xs nil nil list reverse function typed cons ys append ys cons nil derivation type proceeds follows assume reverse list assume list check nil branch type direct 
assume ys list conclude reverse ys conclude cons nil list list expect constructors 
instantiate type append conclude append se ys cons nil list 
notice append precise type omitting unable draw 
right hand side reverse definition type list list satisfies main premise typing rule recursion 
bottom check verify 
holds empty holds 
ackerman function function defined primitive recursion scheme accepted type system 
includes higher order primitive recursion particular type ackerman 
obliged rewrite primitive recursive form 
consider usual order definition case zero succ succ case zero ack succ zero succ ack type recursion stands argument gets smaller recursive call 
reformulate definition corresponds structure termination proof 
ackerman function proved terminating double induction fixed re express recursive functions recurring higher order recurring ack case zero succ succ ack zero succ zero succ definitions types ack vk nat nat 
nat 
vk 
nato course size expressions express linear functions better give result size notice order type application ack instantiate shuffling lists accept definitions primitive recursive form type system interesting 
example shows accept wider class definitions 
defines function shuffles list shuf le xs case xs nil nil cons cons shuffle reverse xs definition primitive recursive form argument recursive call 
size zs type reverse strong tell 
give le type vi dt 
bs ri accepted system 
problem accumulating parameters showed typecheck se reality course want efficient linear definition accumulating parameter reverse xs rev xs nil rev xs ys case xs nil ys cons rev zs cons ys types give definitions rev ers vi 
vt list rev vij vt unfortunately type rev accepted system 
see trace typing rev assume rev list assume list ys list cons branch assume xs conclude cons ys application rev typed 
constraint unsatisfiable program rejected 
definitions typed ss reverse vt list rev vi 
vt st type reverse definition typed 
solution allow limited form polymorphic recursion sizes types 
typing body rev assume typing rev vj 
list list type recursive call instantiating 
type result matches st instance declared type rev typechecking succeed 
plan extend implementation allow kind polymorphic recursion 
necessary similar problems arise accumulating parameter important programming technique able type accurately 
array bounds check sized types guarantee array indices bounds 
view array function indices contents 
example array oft elements type nat type system guarantees array type elements accessed indices 
implementation get algorithm asserting type correctness programs complement deduction rules rules proof strategy 
want type inference algorithm include equation system solver 
want subtype inference solve systems inequations 
distinguish type inference algorithms type checking rely type annotations address minimality typing 
implemented type checker sized type system 
requires bound variables program annotated sized type signatures infers types expressions 
proof strategy simple 
uses var abs app con case ret structurally determined program 
rules follows inst insts var con 
gen letrec topmost expression 
app con case 
systems inequations arising type system predicates form asn sa sj size expressions 
constraint system said solvable exists substitution system holds 
general constraint system formulation conceivable 
semantic model stops arbitrarily complicated constraint languages 
restriction lies abilities solve corresponding constraint systems 
address problem constraint solving 
exploit developments con straint solving technology omega calculator 
formulation constraint systems large ex tent determined capabilities omega calculator 
reason implementing type checker type inference algorithm twofold want type inference minimal type exist typeable program 
easy formulate constraint language hold 
furthermore suggested prospects con straint solving strongly depend expressiveness constraint language 
constraint language powerful type inference algorithm hopelessly incomplete 
finding right compromise tedious design choices constraint language reflect best available constraint solver regardless language express minimal types 
second inference letrec rule tricky 
general case solve equation system functions size variables unknowns solution respect constraint language minimal 
letting programmer introduce unknown function type signature problems disappear 
initial experiments letrec inference looked promising additional complications distracting worthwhile 
technical overview size inference major steps algorithm hindley milner inference check program type correct terms ordinary types 
size inference typecheck program sized type system assumption type signatures correct 
constraint solving solve constraints verify inferred types match type signatures 
result algorithm syntax tree annotated sized types set error messages 
useful interpreting 
example proceed algorithm step step examine typechecking append function lists 
letrec app lie list app xs ys case xs app ys cons xs cons app ys refer nodes syntax tree names 
write annotation node hindley milner inference step standard hindley milner type inference 
motivate follows 
sized type scheme defined dropping size quantifiers size get ordinary type 
notion extends 
judgement sized proof tree get hindley milner proof tree 
inference annotate node syntax tree hindley milner type hm 
subtree elo example get elo 
hm eu 
list list list els 
hm lista step size inference 
extend ordinary types sized types fresh size variable added type constructor type annotations 
refer sized type annotations sz example elo sz zi sz els 
sz infer sized types traverse syntax tree collect constraints extended types appear corresponding proof tree 
consider typing rule app rl rt fv syntax tree annotations match rule unify codomain type el sz type elo 
sz 
get node elo 
coerce app add inequality equality domain type ei type els nodes els variables expect lookup possibly followed instantiation fresh variables 
nodes type environment includes zs simply unify sz sz corre sponding types 
typing constructors case expressions lambda expressions variations theme consider details 
interesting letrec 
recall typing rule fz fv fv xz 
vi letrec ti note letrec rule built gen rule 
stand strategy algorithm consider general properties subtype inference constrained type generalised capture constraints 
instantiation captured constraints added constraint set typing instantiating 
simplify constraints generalisation avoid unnecessary constraint inst 
thing constraint manipulation costly 
polymorphic subtype systems expression forms bounded quantification example constraint system type system 
conse quence simplification eliminate constraints express type 
letrec rule implementation slightly different appearance deduction rule ru sia letrec iv ft vi 
vk di di sig au fv ft inst polymorphic instantiation function fresh variables quantifiers 
instantiate ft type scheme type recursion approximator 
note formulation letrec fused uses gen lambda approximator judgement rule 
type scheme ft represents type family induction proof 
defined type signature sig variable striking differences letrec deduction rule vs implementation missing conditions bot tom check generalisation 
reason simple checked size inference 
build annotation assumption aa encapsulates needed check conditions 
annotation assumption contains set coercions collected proof free variables inferred type recursion approximator type created type signature 
come back proofs annotation assumptions 
major difference type signature sig typing term continue inference process assuming error lies implementation function failing type specification 
little example gives annotation assumption updated solution system equalities 
la id ld kz cy id kz cu kz cl cu 
cy io 
cv la list la la la note constraints form equality types 
type equalities added letrec nodes occasionally involve equalities size expressions 
constraint solving pass handle equations 
constraints alternatives case rule constructor arguments applications 
constraint solving constraint systems emerging proofs linear inequalities natural numbers 
core constraint solving pass omega calculator tool manipulating presburger formulas 
constraint system integer linear inequations solves system rejects unsolvable 
constraint solving pass stages translation coercions types translated size constraints straightforward implementation relation omega test omega tester rejects constraint system presents solution 
solution consists substitution simplified constraint system ideal case empty 
simplification experience elimination redundant constraints omega tester needs completed simple heuristics 
substitution resulting substitution applied annotation assumptions 
annotation check prove assumption annotation correct unify type signature pseudo inferred type generalise variables respect saved free variables check type schemes identical 
bottom check bottom check annotation straightforward implementation predicate 
possible origins constraint 
due coercions size inference due type equivalences 
annotation check equates body annotation inferred type adding dual coercions type constraints 
constrained size variables range naturals integers constrain positive solved omega calculator 
return example 
coercions annotation assumptions due equivalence letrec 
equate annotation inferred type add 
translating set gives constraints size variables constraints klo lc li klo tl klo constraint system omega calculator derives solution klo applied annotation assumption get solved constraint system list id list iq list ici ia list iq va st list la list la lrs rl la list la free variables captured annotation assumption generalise size variables signature 
finished annotation check 
remaining bottom check 
instantiated type la bottom check holds domain type empty 
implementation concrete syntax language similar syntax haskell 
express richer set type expressions refer index data codata declaration names 
modularity type analyses analysis need manipulate entire program 
possible anal modules separately summarise types exported functions interface file 
uses functions module need look types interface file 
implemented rudimentary module system illustrate small example 
assume modules nat stream include definitions typical functions add tail zap 
previous time system checked contents modules summarised types top level definitions interface file add vij nat tad bt va st st cy vi va py st cy sti write module module fib import nat defines add import stream def 
tall zipwith str am nat stream nat stream nat suml zipwith add forall stream nat mk mk suml tall ib stream nat fib stream nat fib mk fib mk suml fib fib finite impulse response filter processing module rejected system prove application tad succeed 
structure definition match structure termination proof 
rewriting example mutually recursive definitions produces program system accepts 
correctness digital filter digital filters implemented weighted sum samples input signal 
illustrates filter implementation language module filter import defines tail map zipwith import nat defines add mu mu mu suml stream nat am nat suml add stream nat stream stream zi forall forall stream stream forall forall stream forall forall stream stream tail tail tail tail tall tall 
stream nat nat mall stream nat stream nat 
stream nat stream nat map mu map mu map mu fir 
stream nat stream nat fir suml suml suml system accepts program 
type ir establishes points 
output stream productive 
second elements output stream bounded times larger elements input stream 
program environment supplies elements input stream 
related formal notion productivity due 
presents calculus proving productivity recursive definitions streams automatic analysis 
closest analyses ones estimation ex ecution times parallel languages 
system ad gifford include similar notions size subtyping differ significantly regarding main technical contributions 
system includes semantic interpretation sizes proof soundness 
second languages support ed systems different 
ad gifford system handle imperative constructs user defined recursive procedures 
experience extension user defined recursive procedures major affects entire system 
contrast extension imperative constructs appears straightforward 
system related approaches formal development reactive systems synchronous languages temporal logics process calculi 
system distinguished major properties productivity modularity 
comparison formal methods development simple production cell implementors prove liveness productivity production cell modular solution 
furthermore system fo cus combined proof liveness modular solution program actual executable code 
mathematical side approximations sizes recursive data structures apparently related hierarchies recursive functions connection evident point 
designed implemented analysis guarantees termination embedded functional programs 
analysis detect space leaks 
immediate goal analysis reason realistic reactive systems written realistic functional lan guages real time programming 
analysis new notion sized types associated semantic model expect appli cable contexts array bounds checking 
believe theory type checking technology applied programming languages extended verify bounds run times computations 
longer term goals integrate analysis complete compiler yield concrete information run time behavior programs 
aiken wimmers type inclusion constraints type inference 
functional programming computer architecture june acm press pp 

broy design distributed systems focus 
tech 
rep sfb bericht nr 
technische universitat munchen 
types intervals 
tech 
rep trs rice university 
davey priestley order 
cambridge university press 
productivity recursive definitions 
personal wd university texas austin 
hall ren carlsson programming fudgets 
advanced functional programmmg jeuring meijer eds springer verlag lncs pp 

hudak peyton jones report programming language haskell non strict purely functional language version 
notices 
larus aiken run time sizes data structures guide parallel thread creation 
proceedings acm conference lisp functional pp 

kelly omega library version interface 
university maryland college park 
lewerentz lindner formal devel opment reactive systems ase study production cell 
lecture notes computer science 
springer verlag 
macqueen plotkin sethi ideal model recursive polymorphic types 
control 
mac queen sethi semantic model types applicative languages 
proceedings acm conference functional programmmg pp 

pugh omega test fast practical integer programming algorithm dependence analysis 
communications acm 
gifford static dependent costs estimating execution time 
proceedings acm conference functional program pp 

royer case programming systems complexity succinctness 
boston birkhauser 
scott data types lattices 
siam journal computmg 
productivity recursive list definitions 
acm programming languages systems 
new real time programming 
unpublished manuscript 
