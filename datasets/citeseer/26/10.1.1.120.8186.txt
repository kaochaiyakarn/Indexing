multi resolution block storage model database design zhou columbia university cs columbia edu propose new storage model called mbsm multiresolution block storage model laying tables disks 
mbsm intended speed operations scans typical data warehouse workloads 
disk blocks grouped super blocks single record stored partitioned fashion blocks superblock 
intention scan operation needs consult small number attributes access just blocks super block contain desired attributes 
achieve performance physical characteristics modern disks organize super blocks disk fixed size mega blocks blocks type various super blocks stored contiguously 
describe changes needed conventional database system manage tables disk organization 
demonstrate experimentally mbsm outperforms competing approaches nsm ary storage model dsm decomposition storage model pax partition attributes bound decision support workloads consisting scans attributes required 
improved performance comes expense single record insert delete performance quantify trade offs involved 
dsm cost reconstructing record partitions small 
mbsm stores attributes vertically partitioned manner similar pax shares pax cpu cache behavior 
describe methods mapping attributes blocks super blocks order optimize performance show tune super block mega block sizes 
behavior main memory secondary storage dominant factor database system performance 
time architectural advances suggest cpu performance memory resident research supported nsf iis 
kenneth ross columbia university kar cs columbia edu data significant component performance :10.1.1.112.263
particular cpu cache penalty relatively high significant impact query response times 
modern database systems designed sensitive performance cpu performance 
focus particular storage model place data relational tables disk 
goal create scheme yields performance workloads operations table scans frequent relative single record insertions deletions 
transfers memory disk performed units blocks called pages 
volume measured blocks simple measure algorithm complexity 
detailed cost models take account physical characteristics disk devices 
example sequential faster random disk head usually need seek 
relational dbmss typically pack records slotted disk pages ary storage model nsm 
nsm stores records contiguously starting disk page uses offset slot table page locate record 
access page identifier say index record retrieved single page hand scans access just columns retrieve disk blocks table transferred data relevant query 
nsm poor cache behavior loads cache unnecessary data 
decomposition storage model dsm proposed minimize unnecessary queries small number attribute values record 
dsm vertically partitions attribute relation accessed corresponding attribute values needed 
extra record id field surrogate needed component sub relation records 
sybase iq uses vertical partitioning combined bitmap indices data warehouse applications 
table scans involving just attributes dsm requires considerably page header record rec ord record page header page header sub relation sub relation page header info rec rec rec rec rec rec nsm dsm pax nsm 
hand queries involve multiple attributes relation spend additional time join participating sub relations additional time significant 
single record insertions deletions require pages nsm assuming overflow 
address issue low cache utilization nsm ailamaki introduce partition attributes pax new layout data records 
nsm page pax groups values particular attribute 
sequential data access pax fully utilizes cache resources number required attribute values loaded cache 
compared dsm pax doesn optimize disk memory 
nsm pax loads pages belonging relation memory scans regardless query needs attributes 
unnecessary attributes values waste bandwidth disk memory decrease efficiency database buffer pool management 
challenge design storage model better performance compromising nice cache behavior 
introduce new storage model called mbsm multi resolution block storage model takes care address performance cache utilization main memory 
similar pax attributes stored columnwise physically contiguous array segments 
result shares pax cache behavior 
different pax loads pages referenced attributes values disk 
considers disk characteristics placing data carefully disk facilitate fast sequential disk blocks grouped super blocks single record stored partitioned fashion blocks super block 
intention scan operation needs consult small number attributes access just blocks super block contain desired attributes 
achieve performance 
data placement schemes physical characteristics modern disks organize superblocks disk fixed size mega blocks mega block blocks type various superblocks stored contiguously 
cost reconstructing record partitions small 
experiments show mbsm outperforms competing approaches nsm dsm pax bound decision support workloads consisting scans attributes required 
average scan query cost workload tpc benchmark mbsm pax nsm comparable dsm high record reconstruction cost 
insertions deletions single records lineitem table tpc cost mbsm dsm 
rest organized follows 
section surveys current disk technology 
sections explain new storage model detail analyze storage requirements 
section lists changes required conventional database systems mbsm 
section evaluates mbsm synthetic workload workload tpc decision support benchmark 
conclude section 
disk technology access time metric represents composite specifications reflecting random performance positioning hard disk 
common definition access time sum command overhead time seek time settle time rotational latency 
track seek time amount time required seek adjacent tracks 
smaller average seek time random track cylinder 
experimental results state art scsi ultra disks seagate cheetah quantum atlas ii 
table lists specifications disks 
detailed descriptions seagate cheetah quantum atlas capacity gb rpm avg 
rot 
latency ms avg 
seek time ms adjacent track seek ms 
super blocks table 
disk specifications section introduce new strategy placing tables disk fast performance 
assume relation attributes attribute having size 
assume attribute fixed sized 
discuss variable sized attributes section section 
step starting point imagine super block component pages attribute page 
place values attribute pages 
page values stored contiguously array bits stored page keep track free slots 
page structure similar fixed sized dsm page don surrogates records 
record reconstruction cost low matching attributes offsets join needed 
inserting new records superblock component pages full 
shows filled page super block relation attributes 
shaded region represents empty space dashed lines page represent value boundaries 
super block contains records 
super block full page stores largest attribute full 
pages super block accessed independently 
proper information database access pages required attributes 
super block cache behavior due high value density 
record reconstruction cost low matching attributes offsets join needed 
measure quality solution terms average query time space needed represent relation 
space overhead easily measured proportion wasted space page lost due fragmentation 
suppose records store 
space needed table pages 
data fit pages fragmentation fragmentation overhead pages total fragmentation constitutes super block 
query time depends query workload 
scan single attribute requires reading quarter pages pages 
scan attributes requires pages scheme 
note fragmentation query time positively correlated 
disk space cheap days issue extra space resulting fragmentation consumes bandwidth 
result expect solution small average query time primary goal small fragmentation overhead secondary goal vice versa 
second step method section works roughly 
yield large fragmentation blocks super block 
example better put th th attributes values page construct super block pages 
shown reorganized super block fragmentation 
particular fragmentation constitutes just super block 
reorganization change time required queries 
query requires attributes significantly cheaper 
example scan query takes pages pages 
suppose number pages available super block 
optimization problem different place attribute values page superblock balanced way get fragmentation 
unfortunately known np complete problem 
problem usually referred parallel machine scheduling attributes jobs attribute sizes processing time goal minimize schedule length 
approximation algorithms problem 
sort attributes largest size repeatedly place attribute loaded page get approximation 
note addition performing optimization described able optimize find layout scheme 
defer discussion choose section 
number attributes small exhaustive search takes time order min infeasible consider splitting attributes section search space larger 
subsequent sections approximation algorithm basis heuristic attribute placement method 
optimization criteria complex difficult give theoretical bounds quality solutions 
expectation optimization criteria page page page page attr attr super block attr page super block attr page page attr attr page page attr page attr complex underlying nature optimization remains extensions approximation algorithm generate solutions 
third step attribute size larger total size rest attributes optimal placement guarantee small fragmentation 
example tpc database benchmark relations large comment attributes 
attribute size large meaning page full empty space rest pages 
case may choose place largest attribute value page super block 
agiven divide attribute size larger sized sub attributes plus extra smaller sub attribute necessary 
approximation algorithm place resulting attributes 
split large attributes small choosing plans real attribute values split vertically 
pages designed store attribute values filled order 
insertion attribute values placed page full move page 
order important 
discuss section database uses order information compute page specific record attribute stored 
shows results previous relation reorganization 
attribute values stored pages page filled 
super block stores records 
result zero fragmentation overhead 
scan attribute takes pages similar observation holds query scans attributes 
hand query scans attribute expensive requiring pages pages need 
super block structure super block attr attr attr attr attr consulted 
net effect average query time depends query workload 
formulate average query time optimization criterion section 
variable length attributes choose largest possible size size attribute don prior knowledge size distribution 
largest sizes variable length attributes know advance records placed super block avoid having deal overflows 
hand waste space variable length attributes large smaller maximum size 
cost super block change optimization criterion fragmentation average query time 
decision support applications optimize super block placement known workloads 
existing algorithms partition relation attribute affinity graph connects pairs attributes appear queries 
algorithms directly guide super block placement may generate sub relations different size incurring fragmentation super block 
impossible compose plan optimal attribute affinity optimal fragmentation 
attribute affinity heuristics guide partition 
develop score function placement plan workload 
assume workload consists queries access patterns amount scans referenced tables referenced attributes 
choice reasonable decision support application queries common generally expensive 
suppose cost sequential data access proportional number disk pages read 
number records relation total cost read page super block define maximum sum attribute sizes page super block 
total cost multiplied number pages required super block 
equal number pages super block referenced th query workload 
attribute values stored page pages counted 
equal probability th query workload 
score function defined note vary placement scheme varies 
revised algorithm define affinity threshold 
pair attributes having affinity larger threshold merged larger attribute size sum attributes sizes 
attributes may merged way 
approximation method place attributes range 
split large attributes described section 
attribute consists attributes merged affinity criterion big undo step merge procedure attribute rerun placement algorithm 
choose plan minimal score 
mega blocks organize super blocks disk 
suppose single attribute scan query referenced attribute values page super block 
place super blocks contiguously database needs read page super block skip pages read page 
disk performance kind access method compared sequential access 
simulate kind interleaved reading seagate cheetah disk 
define reading block number blocks read sequential access 
simulation reads reading block skips reading blocks reads reading block 
simulation varies reading block size disk page disk pages total number pages read kept 
shows results reading blocks 
takes seconds sequentially read blocks 
similar results obtained quantum disk 
elapsed time seconds size reading block disk pages 
simulation interleaved reading reading block size disk page simulating case single attribute scan page super block 
time taken little sequentially reading super blocks 
time drops significantly reading block larger track pages case 
reading block smaller track dominant cost rotational latency lost benefit sequential optimization 
reading block size increases number skip operations decreases sequential reading reading block time drops 
run run run page page page page mega block page page super blocks page page page 
mega block structure see idea place super blocks contiguously disk 
group super blocks mega block 
corresponding pages stored contiguous run 
shows structure mega block 
size run disk pages 
see lower bound run length track size 
total size mega block disk pages 
attribute stored page super block try arrange pages adjacent runs single attribute scan query answered sequentially reading runs mega block 
define affinity distinct pages super block largest affinity attributes pages 
pair pages higher affinity accessed query 
try arrange pages adjacent runs 
mega block performance issues disk prefetching 
consider query involves attributes 
database systems typically require referenced attributes record available performing operations 
naive scan operator drawbacks 
example attribute scan operator get block run stores required attribute seek block second run stores second required attribute 
scan operator goes back run reads second block 
disk head thrashing damages performance 
disk prefetching buffer pool management useful case 
sequential read come super block mega block blocks current run just block read time buffered memory 
disk heads move run reading run blocks 
updates lookups 
modifying single attribute mbsm requires random disk write block containing attribute value 
inserting deleting record requires min block writes number attributes relation 
blocks belong single super block stored different runs 
fortunately runs mega block close tracks 
update cost random disk write plus min nearby disk writes 
dsm inserting deleting record requires random disk writes different sub relations necessarily stored interleaved fashion 
note handles bulk appends efficiently records placed super block data may written run time 
lookups single record mbsm require number page reads depends number attributes required 
lookups single attribute require page lookups attributes require pages fewer requested attributes reside page super block 
choosing defined size mega block size run size super block 
tempting mega blocks large order get better performance 
forced allocate disk space mega block sized units 
allocation unit disk arbitrarily large disk fragmentation result 
large mega block means disk pages prefetched sequential data access increases memory requirements decreases efficiency database buffer pool management 
different systems may different mega block sizes resources 
single system mega block size may different different tables 
experiments set mbytes upper bound mega block size 
larger run size improves sequential performance 
minimum larger disk track size suggested 
larger super block size gives opportunities attribute placement potentially improving query time fragmentation 
increasing increases cost insertion deletion exceeds number attributes point cost insertions deletions remains constant 
upper bound trade choosing 
experiments considering workload relatively insertions deletions 
considering different disk zones different track sizes choose disk pages little average track size disk pages 
gives upper bound pages 
vary choose plan placement minimum score 
ties broken choosing plan smaller 
database implementation mbsm record identified pair superblock id offset pair page id offset conventional database systems 
super block identified page id block 
super block size stores blocks super block addressed numbers stored catalog table uses mbsm format 
super block id page id query execution engine doesn change record representations 
address mapping happens layer just buffer manager 
layers address mapping essentially unchanged simply illusion larger page size equal super block size 
buffer manager deals pages 
indexes built mbsm addresses knowing mapping 
operator opens mbsm organized table subsequent access provided descriptor 
conventional arguments operator supplies list attributes referenced flag indicate operator performing scan sequential operation 
descriptor remembers flag 
descriptor records set pages super block needed include requested attributes 
information derived catalog 
subsequent operator requests include record identifier pg offset descriptor 
indicates sequential operation pg super block mega block runs pages identified read buffer sequentially 
pages buffer actual happens 
just pages single super block corresponding required pages specified read buffer 
subtle point operation may pages super block containing attribute values operation 
case records offset boundaries corresponding switches page 
value offset compared boundaries locate single page containing attribute requested record 
improved version dsm method support query plans involving intersection physical pointers 
superblock id offset 
plans useful multiple indexes available 
describe additional changes behavior components database system 
buffer manager 
little change buffer manager 
request buffer manager page id mbsm buffer manager needs able allocate mega block scanned table avoid thrashing 
buffer replacement policy aware sequential mbsm access patterns desirable 
disk space manager 
disk space manager needs respond requests allocations mega blocks time 
note tables need mbsm disk space manager may allocating space granularities 
mega blocks allocated contiguous sequence possible required 
mbsm adapt data striping raid increasing run size 
operations data disk array maintain sequential performance 
lock recovery manager 
attributes record stored different pages super block 
traditional page level locking super block level locking mbsm 
generally mbsm updates records touch pages attributes stored pages 
concurrency page level locking 
issue relatively unimportant data warehousing workloads 
query optimizer 
cost model revised considering efficiency sequential scans mbsm 
catalog information optimization 
cost essentially cost retrieving just referenced pages 
experimental evaluation section evaluate compare data placement schemes mbsm nsm dsm pax synthetic tpc workloads 
conduct experiments dell precision pc mhz pentium cpu rambus memory 
computer running redhat linux operating system 
treat scsi disks raw devices 
experiments read write directly directly devices independent filesystem 
operations clear disk cache operating system buffer caches 
size memory page disk page kb 
mbsm stores attributes vertically partitioned manner similar pax shares pax cpu cache behavior thoroughly studied 
pax saves nsm cache stall time better dsm 
due space limitations show experiments 
demonstrates dsm incurs high reconstruction cost 
experiments directly simulate behavior generating operations raw disk devices employ database system 
projectivity analysis demonstrate mbsm works different query projectivity create workload consisting relation variations queries involve different numbers attributes 
relation contains byte attributes populated records 
super block mbsm pages 
values attribute go page super block 
synthetic best case mbsm fragmentation 
example illustration potential performance benefits 
vary query projectivity attribute attributes 
shows disk volume requested answer different queries 
mbsm disk volume requested query 
nsm pax disk pages requested queries 
dsm disk volume request query involves attributes 
note final columns show disk space scheme 
dsm uses space byte logical record id record sub relation 
scheme slightly space pax save space pointers pax pages 
gain better performance assume nsm pax pages stored contiguously disk 
dsm sub relation stored contiguous big file stored 
disk organization favors dsm 
practice dsm sub relations stored different locations disk 
mbsm stores records mega blocks size mb translates disk volume requested disk pages thousands number attributes query nsm dsm pax mbsm elapsed time seconds number attributes query nsm dsm pax mbsm elapsed time milliseconds nsm dsm pax mbsm disk volume query performance single record insert delete run length pages 
compares speed schemes function number attributes query implementation seagate disk 
mbsm requests fewest disk pages queries dsm 
query pages requested dsm sub relation sub relation stored contiguously accessed sequentially 
mbsm records stored mega blocks 
reads run mega block skips remaining runs goes mega block 
slows throughput disk slightly 
number attributes increases mbsm reads tracks mega block speed overhead important fewer disk pages transferred 
similar results observed quantum disk 
don include record reconstruction cost dsm comparison 
number attributes increases expect cost dsm higher 
compares performance inserting deleting record schemes 
nsm pax random disk write block containing new old record required 
mbsm dsm require disk writes 
performance different mbsm random disk write remaining writes adjacent nearby tracks 
tpc workloads section compares different storage models running decision support workload tpc 
conducted experiments factor tpc database generated software distributed tpc 
database includes attributes type integer floating point date fixed length string variable length string 
convert variable length attributes fixed length attributes allocating space equal maximum size 
workload consists tpc queries assume probability execution 
execute queries 

synthetic workloads reformulate actual queries queries 
reformulation allows focus aspects query relevant mbsm relations scanned attributes accessed query 
query set entries form table name column name 
omit table name table clear 
tpc query column syntactically mentioned query part set 
example query tpc reformulated type partkey partkey discount shipdate 
interpret query requiring single scan records referenced tables accessing attributes mentioned set 
queries require scans reasonable assuming workload large fraction records touched queries 
index access usually competitive due random queries require single scans approximation 
conceivable data sufficiently large multiple scans required hash joins example 
believe queries sufficiently descriptive capture important aspects workload 
generate attribute affinity relation workload 
attribute affinity threshold set empirically attributes relation appear queries try assign page super block 
variable length attributes maximum size attribute size 
table shows super block size chosen optimization algorithm largest tpc tables 
tables nation region small partitioned 
recall varied discussed section 
details assignments shows disk space required largest tpc tables different storage models 
dsm uses significantly space table lineitem table consists relatively small disk space required disk pages thousands part supplier partsupp customer orders nsm dsm pax mbsm lineitem disk volume requested disk pages thousands query query query query nsm dsm pax mbsm disk space disk volume requested query table columns pages frag 
super block overhead part supplier partsupp customer orders lineitem table 
tpc table partitions attributes byte surrogate overhead ignored 
scheme uses little space nsm pax reasons 
fragmentation super blocks guarantee page super block exactly full 
second maximum possible size variablelength attributes 
actual average size smaller maximum size pax dsm nsm space required actual attribute value 
layouts table optimized workload queries 
choose tpc queries examples demonstrate individual query performance layout 
queries range queries lineitem table multiple aggregates predicates 
queries lineitem table involve additional selection predicates compute conditional aggregates 
shows disk volume requested queries different schemes 
shows elapsed time queries 
shows average elapsed time queries 
dsm mbsm read fewer disk pages perform faster compared nsm pax 
dsm looks competitive remember excluded record reconstruction cost 
cost included cost dsm higher mbsm 
shows performance single record insert delete operation biggest table lineitem 
nsm pax requires block write dsm mbsm require block writes 
mbsm faster dsm due proximity 
storage performance tpc workloads block need written 
shows quality layout varies adjust keeping mega block size bounded mb 
run size axis shows workload average elapsed time best table layouts 
larger potential speed increases 
smaller means attributes stored page super block 
queries involve attributes may requiring disk pages necessary 
see balance competing aims value previous experiments 
proposed new storage model called mbsm stores records partitioned way super blocks organizes super blocks disk mega blocks 
mbsm suitable decision support workloads frequently execute table scans 
compared nsm pax mbsm requests fewer disk pages uses processing time decision support workload involving table scans 
mbsm shares pax cpu cache behavior 
compared dsm mbsm scan performance comparable 
mbsm cache performance better surrogates involved mbsm better insert update performance 
mbsm doesn require join reconstruct records dsm high reconstruction cost 
plan investigate directions research 
queries seldom large variable length attributes comment better idea store attributes separately dsm mbsm results qualitatively similar quantum disk larger value optimal 
elapsed time seconds average elapsed time query seconds query query query query nsm dsm pax mbsm elapsed time milliseconds insert delete record lineitem nsm dsm pax mbsm query performance single record insert delete performance tpc workload queries nsm dsm pax mbsm average elapsed time seconds tpc workload queries run size disk pages average query performance mega block design trade fixed sized attributes surrogate 
alternatively store variable length attributes way heap avoid wasted space 
second option needs method handle page overflows may able uniquely identify physical page containing required attribute 
conceivable probabilistic analysis attribute size query patterns reasonable job ensuring performance wasting space 
ailamaki dewitt hill 
weaving relations cache performance 
proceedings vldb conference 
ailamaki dewitt hill wood 
dbmss modern processor time go 
proceedings vldb conference 
kersten 
database architecture optimized new bottleneck memory access 
proceedings vldb conference 
copeland khoshafian 
decomposition storage model 
proceedings acm sigmod conference pages 
cornell yu 
effective approach vertical partitioning physical design relational databases 
ieee transactions software engineering 
graham lawler lenstra kan optimization approximation deterministic sequencing schedul 
performance tpc workloads ing survey 
annals discrete mathematics 
graham 
bounds multiprocessing timing anomalies 
siam journal applied mathematics 
kersten 
happens join 
dissecting cpu memory optimization effects 
proceedings vldb conference 
maxtor atlas ii overview 
available www maxtor com 
neil quass 
improved query performance variant indexes 
proceedings acm sigmod conference 
ramakrishnan gehrke 
database management systems 
mcgraw hill edition 
dewitt su 
case mirrors 
proceedings vldb conference 
seagate cheetah product manual volume 
available www seagate com 
kant naughton 
cache conscious algorithms relational query processing 
proceedings vldb conference pages 
transaction processing performance council 
tpc benchmark available www tpc com 
zhou ross 
multi resolution block storage model database design 
technical report cucs department computer science columbia university 
