elk new protocol efficient large group key distribution secure media broadcast internet poses unique security challenges 
problem access control large number subscribers public broadcast 
common solution encrypt broadcast data disclose decryption key legitimate receivers 
securely efficiently establish shared secret legitimate receivers 
importantly efficiently update group key securely receivers join leave 
provide reliability key update messages way scales large groups 
research substantial progress address challenges 
current schemes feature efficient key update mechanisms assuming key updates communicated reliably receivers 
practice principal impediment achieve scalable system distribute key updates reliably receivers 
designed implemented elk novel key distribution protocol address challenges features joins 
elk features perfectly reliable super efficient member elk uses smaller key update messages previous protocols 
elk features mechanism allows short hint messages key recovery allowing tradeoff communication overhead member computation 
elk proposes append small amount key update information data packets majority receivers recover lost key update messages 
publication part defense advanced re search projects agency darpa contract supervision space naval warfare systems center san diego national science foundation fd united states postal service usps 
views contained document authors necessarily represent official opinion policies expressed implied government agencies darpa nsf usps 
adrian perrig dawn song tygar university california berkeley cs berkeley edu perrig tygar elk allows trade security communication overhead 
introduces elk efficient scalable secure method distributing group keys 
elk widespread applications access control streaming multimedia broadcasts 
common solution controlling access broadcast information encrypt data distribute secret decryption key group key legitimate receivers 
general approach central server key management 
key management complicated dynamic groups members may join leave time 
members able decrypt data members group key server needs update group key member join leave events 
changing key large groups scalable robust efficient manner particularly challenging 
solution deal arbitrary packet loss including lost key update messages 
general previous approaches built reliable multicast high communication overhead large scale queries central server request retransmission keys introduces substantial load central server 
general system designer faces variety tradeoffs scalability security efficiency reliability 
scenario consider put premium scalability 
interested situations widespread video audio streaming network large number receivers 
interested moderate security 
consider case receivers commodity hardware pcs tamper resistant hardware 
note absence tamper resistant hardware limits ultimate security keys 
key server broadcasts key update messages group members communication overhead prohibitively high large dynamic groups 
due continuous increase computation power design elk trade computation lower communication overhead 
concretely design member join protocol require broadcast requires server computes oneway function keys time interval 
elk introduces hints technique key updates smaller requires receiver computation 
provide high reliability assume build reliable multicast system 
designed implemented elk novel key distribution protocol addresses issues 
particular elk addresses reliability key update messages prior 
elk allows content provider directly trade security communications 
features elk protocols 
elk depend reliable multicast 
elk uses smaller key update messages previous elk features perfectly reliable super efficient mem ber joins 
elk addresses reliability short hint messages 
improves reliability allows tradeoff communication overhead member computation 
study application elk consider different types information goods low cost goods information goods 
apply new ways assess desired level security 
low cost goods consider system secure long cost attacker break key larger cost information 
information goods require minimum time break key surpasses lifetime value data 
security requirements group key distribution consider dynamic groups users join leave group time 
main security properties group key management system dynamic groups 
group key secrecy guarantees computationally infeasible adversary discover group key 

forward secrecy confused perfect forward secrecy pfs key establishment protocols guarantees passive adversary knows contiguous subset old group keys discover subsequent group keys 
property ensures member learn new group keys leaves group 

backward secrecy guarantees passive adversary knows subset group keys discover preceding group keys 
property ensures new member joins group learn previous group keys 
properties commonly secure group communication 
steiner tsudik waidner give formal definition 
notation background notation 
encrypt message key write concatenate messages write description different pseudo random functions prfs varying input output lengths 
notion prf family proposed goldreich goldwasser micali 
defining prf purpose define family prfs key input length bits output bits function write returns significant bits assuming longer bits 
number key derivation functions ensure keys arguments various places independent 
keys derived follows note arguments prfs 
key derivation solely ensure independence keys security reasons 
simplify understanding protocols advise ignoring greek superscripts reading 
review previous key distribution schemes receiver storage 
receiver stores number member specific keys group key 
number keys store usually small receiver storage issue 
key server storage 
key server stores member specific keys 
current schemes number member specific keys groups millions receivers key server storage order multiple megabytes 
researchers investigated schemes reduce server storage overhead 
assume key server sufficient storage broadcaster sends data millions paying subscribers ample key storage 
receiver key server computation 
processing speed workstations continues increase computation overhead important 
bandwidth constrained resource 
particular key update information broadcast receivers needs small possible 
assume abundant storage computation resources goal trade computation storage lower communication cost 
put premium broadcasts try limit unicasts 
review logical key hierarchy lkh ensure forward backward secrecy group setting key needs updated distributed member joins leaves group 
elk key tree extends logical key hierarchy called broadcast key distribution assume central key lkh way function tree oft distribution server authenticate authorize approaches achieve efficient secure key receivers 
model receiver wishing tion system 
include brief review lkh 
decrypt broadcast content contacts key server lkh key distribution center key server maintains unicast requests decryption key 
key server au key tree group key updates receiver standard authentication 
shows sample key tree 
node tocol sets secure channel offering confidentiality tree represents cryptographic symmetric key 
key integrity authenticity 
server sends key information distribution center associates group member client consists group key decrypt leaf node tree invariant content set member specific keys key hold group member knows keys leaf management purposes 
node root node node key tree 
broadcast information encrypted group call set keys member knows key path 
key achieve confidentiality access control 
en members know key root node key sure forward backward secrecy receivers join group key denote illus leave broadcast defined section key server key path member nodes broadcasts encrypted key updates legitimate associated keys member members decrypt 
joins group receives keys path analyze overhead key distribution schemes leaf node root key distribution center sent consider resources 
note total num secure channel 
ber receivers 
psfrag replacements member leaves group keys member knows including group key key path need updated 
main reason key tree efficiently update group key member joins leaves group 

sample hierarchical key tree member joins group key server authenticates member assigns leaf node key tree 
key server send keys key path member 
preserve backward secrecy keys new member receives need independent previous keys new member able issues member authentication secure channel setup orthogonal main thrust assume secure mechanisms 
decrypt traffic sent joined group 
key server replaces keys new member fresh random keys sends new keys group need know basis 
illustrate protocol example 
assume setting depicted simplicity assume new member joins group 
assuming leaf tree empty key server places new member leaf chooses new keys key path sends secure link 
update key paths previous members server broadcasts key update message group member needs update keys key path 
knows decrypt part key update message recover soon knows decrypt new group key members know decrypt new group key final part key update message 
show improve join protocol broadcast message necessary 
group leave difficult perform efficiently 
challenge replace current group key legitimate members receive new key leaving member 
fact keys leaving member knows need changed ensure forward secrecy 
keys replaced sequentially leaf root key 
protocol best explained example 
assume group shows member leaves group 
key server dates keys generates new keys broadcasts message member knows decrypt obtain know directly obtain new group key allows obtain members leaves efficient require updating assuming key tree balanced 
keys number group members reliability key update messages members join leave group key server updates group key broadcasts key update message group 
group member receive key update message able decrypt subsequent messages encrypted new group key 
exception proposed keystone protocol wong lam previous systems addressed problem lost key updates marginally 
previous schemes assume recover lost key updates mechanisms 
naive approach members request key update unicast key server 
clearly naive unicast recovery mechanism scale conjunction techniques fallback recovery mechanism 
fact elk keystone protocol unicast fallback mechanism 
sketch recovery protocol appendix 
approach replicate key update packets multi send 
replication powerful method achieve robustness known packet loss internet correlated 
implies key update packets sent close succession risk loss lost 
strategy separates redundant packets cause client wait replicated key update messages receives data decrypt 

reliable multicast schemes srm storm may achieve reliable delivery key updates 
schemes add substantial complexity scale tv size audiences 
furthermore systems designed robustness adversarial environment opportunities denial service attacks exist 
similarly reliable group communication toolkit small group key agreement protocols totem horus prohibitively expensive scale large groups 

wong lam forward error correction error correcting codes key update packets 
specifically idea scheme rabin ida reed solomon codes digital fountain codes split key update packet packets receiver gets packets reconstruct key update 
scheme receiver needs receive sufficient packets reconstruct desired information 
packet loss correlated packets sent close succession may dropped 
wong lam assume statistical independent loss cover correlated packet loss due temporary congestion 
combination new mechanisms achieve reliable key updates 
motivated observations 
member joins free model broadcast necessary 
member join protocol require broadcast message 
large number members join concurrently key server may need distribute message length bits en code location joining node number group members 
member join events usually require broadcast information information get lost 

case key update message member leaves half members need single key key update message assuming key tree balanced 
similarly quarter members need keys update key path 
general members need keys update key path 
way viewing sending keys help members update key path 
call keys help members maximum impact keys mik 

key management protocols separate key update messages encrypted data packets 
receiver receive read encrypted data 
elk add key update directly data packets 
space data packets limited add small amount key update information 
previous protocols lengthy key update messages approach 
elk features method compress key updates trading key update message size receiver computation 
resulting key update small sender piggyback data packets 
details described 
mechanisms place majority group members recover lost key update receive hints data packet 
remaining small fraction needs contact key server unicast 
elk efficient large group key distribution protocol elk stands efficient large group key distribution protocol 
describe elk section 
describe basic key update mechanism followed join leave protocols 
analyze security elk discuss elk advantages 
show elk allows member joins requiring broadcasts 
unicasts adjacent members new member required 
see section details 
basic elk mechanisms elk members leaves logical key hierarchy 
elk composed basic mechanisms key update key recovery hints assume key length bits 
child contribution parent key update discuss section server updates keys key tree members leave group 
new key update protocol elk left right child keys contribute update parent key 
approach similar nature oft protocol construction allows small hints allow legitimate members reconstruct key key update shall see section 
consider case want update key child keys new key derived contributions 
left child key contributes bits new key derived pseudo random function key applied call left contribution bits long 
similarly bits long derived right child key follows contributes bits right child key bits long 
concatenate contributions form new key length compute compute pseudo random function key pre loss vious key data generality assume security key distribution scheme bit key length key update message needs contain infor mation members left know recompute members right know left members derive need key update message contains bits long 
similarly members right key update contains bits long 
details key update listed box labeled procedure 
construction allows construct compact hint messages enable legitimate receivers reconstruct updated key see 
key recovering hints broadcasting key update message length bits legitimate members know recover new key hint smaller key update message trading computation communication 
assume member perform smaller key update call hint 
consider right hand members know computations construct derive right contribution bits long 
checksum brute force missing bits left side con left hand contribution right hand contribution new key recall section purpose key derivation independent 
update key server broadcasts key update message length bits 
members know derive decrypt key update compute applies members know procedure key update tribution 
hint message contains key verification length bits 
right hand members com derived new key pute candidate keys 
possibility obtain candidate key compute member verifies candidate key checking key verification see equals left hand members compute key way right hand members 
usual case left hand members need obtain bits right contribution need brute force bits 
hint message contains bits encrypted help left hand members compute possibilities obtain candidate key verify candidate key checking key verification see equals 
description simplified see box labeled procedure details 
clear correct key output procedure 
problem procedure deliver candidate key case false positives 
key verification bits long expect receive false positive key correct key 
member recomputes multiple keys receive additional key level false positive key produces average just false positive key correct key result correct key level false positive key 
prevent set generally setting results half false positive key average works practice 
hint message composed key verification partial right contribution recall key reconstruction slightly different members left right sub tree 
recall updated key members left know derive decrypt part right key contribution know bits compute members exhaustively try verify resulting guess key verification candidate 
possibilities match key members right know com pute bits need exhaustively try combinations hint information verify validity key 
procedure key recovery hint advantage hint bits shorter key update general hint bits shorter full key update 
ideal case hint half size key update 
determined security parameter discuss section 
discuss security appendix elk key distribution protocol previous subsection introduces mechanisms construct elk 
mechanisms describe elk detail 
show protocol works member join leave events 
protocol description assume large number members group discuss boundary cases group members 
group key distribution protocols allow users join leave group time general considered practice aggregate join leave requests occur time interval group key update 
see key update message smaller key server aggregates multiple membership events 
assume system key server divides time intervals 
key server aggregates membership events occur time interval group key update 
duration aggregation interval application specific discuss 
member join event member join event key server assigns new member node key tree new member receives keys path leaf node root 
preserve backward secrecy keys new member receives independent previous group keys 
looking independence computational perspective require computationally infeasible new member derive previous group keys 
previous schemes updated keys need broadcast affected group members 
key server broadcasts key update messages group members communication overhead prohibitively high large dynamic groups 
due continuous increase computation power design elk trade computation lower communication overhead 
support efficient member join events propose novel approach broadcast messages needed requires server computes way function keys time interval 
elk entire key tree updated time interval procedure 
derived update key key tree new key current group key 
update group key derivation member update key path independently time interval 
broadcast messages needed member join event 
computation prf efficient computational overhead receiver negligible 
overhead server larger tractable 
server pre compute keys tree low priority background process 
second approach recompute keys fly need 
major advantage approach broadcast information necessary members join 
broadcast messages necessary members join key server need send unicast messages members moved new locations key tree new nodes added key tree 
rest section describe complete join protocol single members join give example 
joins 
member join event protocol 
single member join 
key server updates keys key tree new group key 
empty leaf node available server assigns new random key leaf node sends secure channel new member updated keys key path 
join event done exchanges broadcasts necessary 

leaf node available key server assigns new member new leaf node key tree assigns new random key 
key server picks node key tree insert new member 
assume key node server node generates new parent node leaf node node left child node right child key value parent comes 
key server sends new member updated keys key path leaf node root secure channel 

key server sends joining location members node allows independently update key paths 
general case leaf node key server unicasts message member 
larger number members server includes key update message takes bits 
shows example join event member joins group server decides insert leaf node illustrate steps elk join protocol example 
step server updates keys key tree 
step apply empty leaf nodes available 
step key server generates new leaf node assigns new random key step server decides merge node generates parent node computes new key server server sends message step server sends joining location new member unicast tells update key tree compute multiple member join events equally 
possibilities exist deal 
way 
members placed empty leaf nodes overhead generated registering new members key server 
empty leaf nodes exist key server generate smaller key tree new members join tree node current group key tree 
case server needs communicate location single node members live joining node 
member leave event step member leave event complicated member join event keys leaving member knows need replaced new keys leaving member able compute forward secrecy see section 
key server uses child contribution scheme outlined section update keys path leaf node leaving member root 
server broadcasts key update message containing updated keys attach hint messages data packets enable key recovery case key update message lost 
protocol 
member leave 
server deletes leaf node corresponding leaving member parent node leaf node promotes sibling node 

remaining nodes key path leaving member need updated 
keys update procedure key follows 
new key left right child keys respec tively 

server broadcasts key update message keys updated previous step 
key update message contains leaves 
member leave event 
server attaches hint message data packets 
new key server may send clearer example 
see box labeled example 
multiple member leave events write ways realize multiple member join events 
multiple member leave events subtlety sketch approach slightly greater detail 
case multiple members leave interval key server aggregates leaving members creates joint leave key update message 
elk aggregate concurrent member leave events particularly pro vides addition current savings oft keys children change 
reason oft inefficiency child keys change oft needs key updates child elk needs 
elk factors fresh contributions child keys parent key leave key update regardless children changed 
size key update message elk number updated keys number leaving members 
number updated keys sum keys key path advantageous aggregate multiple member leave events 
savings pre computation attack possible pre compute image keys case server publishes adversary look pre images candidates key 
prac tice larger bits attack 
note size elk key updates remains regardless length keys 
discuss oft section 
oft derive keys binary tree members represented leaves 
consider example 
member leaves group 
step key server deletes nodes cor respond keys server promotes node step server updates keys key path leaving member server computes new key follows update key key server computes step server broadcasts key update con tains subsequent data packets contain hint step example member leave protocol leaves leaves joins joins 
member leave event contrast size oft key update message bits 
illustrate multiple member leave events example 
assume setting 
example assume leaving member nodes collapsed key server replaces leaving member nodes new members 
members leave new members take spot keys need updated 
member leave events processed sequentially update message leaving bits long message bits long 
server aggregates leaves message bits long 
security analysis sketch security analysis appears appendix show observations hold overwhelming probability passive adversary needs perform operations brute force elk group key 
overwhelming probability active adversary needs perform operations brute force elk group key preceeding time joins group 
active adversary leaves group probability needs perform operations derive new elk group key 
show pre computation reduce effort brute force elk group key 
advantages elk provides advantages previous solutions multicast group key distribution protocols 
join protocol uses key server computation achieve member joins require broadcast message greatly improving scalability 
advantages reduced size group key updates reduced hint messages allow legitimate members recover lost key updates 
hint messages drastically reduce number members need contact key server recover lost key update messages 
small footprint hint message data packet may carry hint 
receiver missed key update receives corresponding data packet able recover group key hint high probability decrypt message 
encrypted data decryption key useless key corresponding data useless combining natural 
linking hint message powerful mechanism elk possible due small footprint hint 
innovation elk distribute partial key tree update information 
key update information provides diminishing returns 
idea disseminate small amount information enables majority members recover lost update message 
remaining members small fraction dealt individual basis 
applications practical issues section discuss choice parameters elk arguments security 
parameters discuss number bits key left contribution right contribution size key verification respectively number levels keys added hint 
choice parameters driven tradeoff efficiency communication computation security 
security model attacker model assumes reasonable attacker breaks system breaking weakest link 
main application broadcast environment receivers tamper resistant security devices 
implies user access decryption keys stored memory 
attacker obtain current group key subscribing service 
perspective secret group key shared members 
judge key distribution protocol secure considerably difficult expensive get key breaking key distribution protocol means 
system requirements security requirements system requirements 
want key update protocol low computation communication overhead 
hint messages require receivers recover key hint message 
implies hint message includes keys levels 
hint key level may help fraction members case single member leave event assuming key tree balanced 
members 
furthermore require key reconstruction faster requesting key update unicast key server 
assume request message may take ms requirement fast mhz pentium workstation reconstruct keys levels sufficient reach ms discuss implementation section test workstation computes prf functions second 
parameters parameter choose group key size instance assume elk environment choose key size bits 
want achieve key reconstruction hint takes ms allows compute worst case member needs reconstruct keys 
considering compute prfs second leaves prf computations key 
key guess prf computations necessary compute key verify key hint 
chose bits translates computations key 
discussed previously hint message bits long member expects get additional false positive key level 
implies member computes keys candidate keys group key requires times compute group key 
reason key hint bits long reduces false positives 
table shows number candidates different levels 
recommended parameters number false positives averages compute number bits sample scenario 
protecting information goods information goods loose value time 
example live pay view media transmissions sports event video feed 
consider example data want protect minutes 
security requirements dictate attacker needs computers break key minutes 
assume attacker fast machines com prfs second 
computers pute compute prfs minutes 
know attacker needs key derive bits 
key update key bits long total size key hint bits 
savings hint message key hint encode position hint key tree additional bit left right 
cost key hints bits translates bytes 
advantages operations break computers get faster savings elk improve 
achieve largest savings hint messages case hint half size key update 
case legitimate members perform operations attacker perform operations 
merkle similar argument construct public private key encryption algorithm 
merkle puzzle system assumes legitimate users perform operations attacker need perform operations break encrypted message 
brute force search parameter dwork naor fight spam mail 
similarly manber abadi lomas needham brute force search improve security unix way password function 
examples demonstrate elk trade security efficiency 
allows content distributor choose desired level security fine grained scale lower security directly translates smaller key update messages 
note previous protocols offer feature 
desires lower security margin safe shorten key length new attacks exploit short key lengths possible 
instance attacker may perform pre computation memory lookup tables break short group key 
elk suffer attacks show security analysis appendix comparison related introduced gkmp centralized server approach distributes group keys unicast 
refer approach secure key distribution center 
iolus aims scalability distributed hierarchical key servers 
molva involve routers multicast distribution path security 
logical key tree hierarchy independently discovered wallner wong gouda lam 
call algorithm logical key hierarchy lkh 
optimization halves size key update message described canetti 
optimization lkh called lkh harder described detail internet draft 
reduce overhead join current approach simply compute way function key new member obtains proposed framework lkh protocol 
method halve size key update message way function tree protocol oft sherman 
oft key node derived sibling keys 
protocol resembles oft approach 
lkh protocol greatly diminishes overhead group key change number group members constant key change resulting key update messages result unscalable protocol large dynamic groups 
members join leave frequently resulting key update traffic overwhelm group 
setia jajodia attempted solve problem 
proposed periodic rekeying results aggregating members join leave short time interval 
address issue reliability key updates 
approach scalability uses hierarchy key servers similar iolus aggregate join leave events 
subgroup kronos protocol minimize communication overhead elk protocol 
briscoe designed marks protocol 
marks scalable require key update messages protocol works leaving time member fixed member joins group members expelled 
observed key updates distributed data 
fact propose key updates embedded data example techniques similar watermarking 
focus different 
elk key updates encode key encrypt data proposed embedding keys current data 
wong lam designed keystone addresses reliable delivery key update messages primary motivation 
reliable multicast transport protocols scale large groups propose key server uses forward error correction fec encode key update message 
long member receives sufficient fraction key update packets reconstruct information 
packets lost member uses unicast connection key server recover missing keys 
authors assume independent packet loss scheme quite effective 
practice packet loss internet correlated means probability loss packet increases drastically previous packet lost 
means key update packets replicated sending close succession introduces considerable vulnerability correlated packet loss 
comparison focus broadcast overhead consider important quantity 
unicast cost memory overhead key server computation overhead lesser concern 
broadcasting paying customers afford server suf ficient memory store keys 
reducing size key updates higher level redundancy assuming constant fraction bandwidth dedicated key updates results higher reliability 
table shows comparison standard key distribution protocols 
number users group height key tree 
assuming tree balanced location information single member join broadcast size multiple member join members broadcast size single member leave broadcast size lkh oft keystone elk binary full hint hint multiple member leave members broadcast size table 
comparison current key distribution schemes 
quantities number bits account tree location information needs passed key 
parameters explained text 
node tree takes bits 
quantity determines number keys change tree members join leave 
protocol simplest protocol key trees clearly scale large groups 
keystone protocol key trees incorporate developments reduce size key update messages expensive lkh oft 
clearly see elk efficient protocol case elk security parameter protocols 
new join protocol require broadcast message entire tree changes interval 
particular case leaving members elk provides savings factor factor oft factor 
display overhead hint message list cases hint helps half members reconstruct group key helps fraction members 
simplify table marked size hint message case members leave group size hint message difficult give 
expected number keys allows half members recover group key formula case fraction member wish recover group key hint hint size hint size implementation implemented elk protocol 
section discuss choice cryptographic primitives report measured performance numbers 
savings real multicast group communication environment 
prf pointed section savings hint increases speed members 
function relevant hint computation speed prf prf function repeatedly derive lost key exhaustive search 
mac function construct prf 
prfs needed required input size equal bits output size equal bits 
application chose bits 
compared speed variety mac functions hmac hash function cbc mac block cipher 
functions provided openssl library fast rijndael advanced encryption standard implementation provided nist 
hmac hash functions slower fastest cbc macs 
rijndael performed mhz pentium workstation macs second input output key sizes bits 
rc faster macs second bit input output size 
need bits input output size rc times faster rijndael encryption rc prf function 
encryption function path length reconstruction ms candidates member fraction table 
reconstruction time number candidates paths varying length 
row lists fraction members recomputes key path length 
save space key updates hints afford data expansion caused block cipher 
stream cipher 
speed encryption important prf function rc prf function rc ofb mode stream cipher 
group key iv 
secure encrypt twice key iv pair 
results implemented elk parameters bits bits bits prevent increase false positive candidate keys 
report performance results key reconstruction algorithm 
table shows average number milliseconds reconstruct path certain length 
summarize major contributions elk 
elk features smaller key updates previous protocols 
notably elk member join events require data broadcast current group members general case 
elk generates small hint messages trades communication overhead member computation 
small hints enable legitimate receivers derive group key computation case missed key update message 
elk protocols provide reliability key update messages relying reliable multicast protocols 
elk uses small key update footprints composed hints carried data packets 
approach allows majority members recover new group key key update message lost 
exception encryption part hint message part key update message 
case key iv pair encryptions plaintext data 
acknowledgments david wagner helpful fruitful discussions 
ran canetti kim radha gene tsudik helpful discussions 
indebted anonymous referees detailed insightful comments 
martin abadi mark lomas roger needham 
strengthening passwords september 
src technical note 
sherman 
key management large dynamic groups way function trees amortized initialization 
internet draft internet engineering task force march 
progress 
borella brewster 
internet packet loss measurement implications qos 
international conference parallel processing august 
bob briscoe 
marks zero side effect multicast key management arbitrarily revealed key sequences 
international workshop networked group communication november 
john byers michael luby michael mitzenmacher 
digital fountain approach reliable distribution bulk data 
proceedings acm sigcomm conference applications technologies architectures protocols computer communication 
canetti garay micciancio naor pinkas 
multicast security taxonomy efficient constructions 
infocomm march 
ran canetti tal malkin nissim 
efficient communication storage tradeoffs multicast encryption 
jacques stern editor advances cryptology eurocrypt number lecture notes computer science 
international association research springer verlag berlin germany 
waldvogel sun weiler plattner 
framework versatile group key management 
ieee journal selected areas communications september 
chang robert engel dilip kandlur dimitrios saha 
key management secure internet multicast boolean function minimization techniques 
infocom september 
dwork naor 
pricing processing junk mail 
ernest editor advances cryptology crypto pages berlin 
springer verlag 
lecture notes computer science volume 
floyd jacobson mccanne liu zhang 
reliable multicast framework lightweight sessions application level framing 
proceedings acm sigcomm pages boston ma august 
oded goldreich shafi goldwasser silvio micali 
construct random functions 
journal acm october 
li gong 
enabling secure collaboration internet 
proc 
th usenix unix network security symposium 
harder 
logical key hierarchy protocol 
internet draft internet engineering task force april 
progress 

group key management protocol gkmp specification architecture 
request comments rfc rfc internet engineering task force july 
li radha 
optimization key storage secure multicast 
th annual conference information sciences systems ciss johns hopkins university march 
sloane 
theory error correcting codes 
north holland amsterdam 
udi manber 
simple scheme passwords way functions harder crack 
computers security 
david alan sherman 
key establishment large dynamic groups way function trees may 
www cs umbc 
edu sherman papers ps 
merkle 
secure communication insecure channels 
communications acm 

iolus framework scalable secure multicasting 
acm sigcomm september 
molva alain 
scalable multicast security dynamic groups 
proc 
th acm conference computer communications security pages nov 
moser melliar smith agarwal papadopoulos 
totem fault tolerant multicast group communication system 
communications acm april 
nist 
advanced encryption standard aes development effort 
csrc nist gov encryption aes october 
openssl 
openssl project 
www 
openssl org 
paxson 
internet packet dynamics 
ieee acm transactions networking june 
huffman editors handbook coding theory volume page 
elsevier amsterdam netherlands 
rabin 
information dispersal algorithm applications 
sequences combinatorics compression security transmission pages 
springer verlag 
irving reed solomon 
polynomial codes certain finite fields 
journal society industrial applied mathematics 
sanjeev setia samir sushil jajodia 
kronos scalable group re keying approach secure multicast 
proceedings ieee symposium research security privacy oakland ca may 
steiner tsudik waidner 
cliques new approach group key agreement 
ieee transactions parallel distributed systems appear 
wade jie song radha ray liu 
key distribution secure multimedia multicast data embedding 
ieee icassp salt lake city utah may 
robbert van renesse kenneth birman maffeis 
horus flexible group communication system 
communications acm april 
wallner harder 
key management multicast issues architectures 
request comments informational internet engineering task force june 
wallner eric harder ryan 
key management multicast issues architectures 
technical report ietf draft july 
wong gouda lam 
secure group communications key graphs 
technical report tr university texas austin department computer sciences august 
wong gouda lam 
secure group communications key graphs 
proceedings acm sigcomm conference applications technologies architectures protocols computer communication pages 
appeared acm sigcomm computer communication review vol 
oct 
chung kei wong simon lam 
keystone group key management service 
international conference telecommunications ict 
wool 
key management encrypted broadcast 
th acm conference computer communications security pages san francisco california november 
rex xu andrew myers hui zhang raj yavatkar 
resilient multicast support applications 
nossdav 
yajnik moon kurose towsley 
measurement modelling temporal dependence packet loss 
ieee infocom march 
bennet yee doug tygar 
secure coprocessors electronic commerce applications 
proceedings usenix workshop electronic commerce new york new york july 
bennet yee 
secure coprocessors 
phd thesis carnegie mellon university 
unicast key recovery protocol case group member receive key update message unlucky part key tree recover group key hint message 
case needs request keys key server 
request protocol straightforward design 
important requirement protocol efficient scales 
contrast previous wong lam find tcp appropriate protocol key request protocol 
reason tcp requires round trip message just set connection implementations data sent initial syn packet 
slows request unnecessarily 
advantage tcp receiver keep connection open key requests 
approach scale large number receivers tcp connection requires considerable amount state server 
propose light weight key update protocol udp receiver achieves reliability timeout request retransmissions 
security analysis perform security analysis computational complexity framework 
attacker model distinguishes passive active adversaries 
passive adversaries eavesdrop group communication particular group members active adversaries may group members 
cases analyze computation complexity adversary derive group key group member 
clarify subsequent description refer passive adversary eve active attacker mallory 
security analysis passive adversary look difficulty passive adversary eve compute group key 
assume eve traffic loss receives data packets session eve group member know keys key tree 
clearly exhaustive search attack find group key takes operations bit length group key 
eve better brute force search key update messages hint messages know keys decrypt key update keys pseudo random function compute hints 
observation clearly holds possibilities proposition 
overwhelming probability eve needs perform operations determine group key exhaustive search 
security analysis active adversary turn attention mallory assume group member previous time period 
analyze computation complexity derive group key group 
look backward secrecy 
mallory joins group receives keys key path derive previous group keys 
mallory recorded earlier key update messages hints data packets encrypted previous group keys derive group key better brute force decryption keys keys pseudo random function compute hints 
obtain observation possibilities proposition 
overwhelming probability mallory needs perform operations brute force group key preceeding time joins group 
analyze forward secrecy mallory tries derive group keys leaves group 
assume mallory just left knows keys key path scenario gives mallory greatest advantage 
mallory leaves group server updates group key key tree section describes 
show scenario observation true proposition 
mallory leaves group overwhelming probability needs perform operations derive new group key 
argument sketch 
new group key updated key server description section 
mallory ways derive new group key key update messages published hints brute force possibilities computation generating new group key 
group key distributed encryption keys key tree mallory described lkh 
mallory better trying possibilities 
similarly mallory gain advantage published hints keys pseudo random function computation 
note new group key derived left right child keys respectively 
updated depending side tree mallory 
mallory know mallory knows needs brute force possibilities bits long 
best mallory brute force operations compute new group key 
note mallory needs try possibilities smaller simply pre compute table entries derive new group keys 
reason new group key computed pseudo random function previous group key input keeps changing 
mallory wants derive new group key group needs recompute table entries latest group key input 
amount computing possibilities 
mal gain advantage doing precomputation saving result 
