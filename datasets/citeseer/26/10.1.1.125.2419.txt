query algebra optimization relational top queries li kevin chen chuan chang song department computer science university illinois urbana champaign cli uiuc edu cs uiuc edu uiuc edu school computer science university waterloo uwaterloo ca introduces system provides systematic principled framework support efficient evaluations ranking top queries relational database systems rdbms extending relational algebra query optimization 
previously top query processing studied middleware scenario rdbms piecemeal fashion focusing specific operator sitting outside core query engines 
contrast aim support ranking class database construct 
key insight new ranking relationship viewed logical property data parallel membership property relational data model 
membership essentially supported rdbms support ranking clearly lacking 
address fundamental integration ranking rdbms way similar membership boolean filtering supported 
extend relational algebra proposing rank relational model capture ranking property introducing new extended operators support ranking class construct 
enabled extended algebra pipelined incremental execution model ranking query plans expressed traditionally fundamental ranking principle 
optimize top queries propose dimensional enumeration algorithm explore extended plan space enumerating plans dual dimensions ranking membership 
propose sampling method estimate cardinality rank aware operators costing plans 
experiments show validity framework accuracy proposed estimation model 

ranking queries top queries dominant emerging applications similarity queries multimedia databases searching web databases middlewares data mining 
top material partially supported nsf iis iis ibm faculty award 
opinions findings recommendations expressed publication author necessarily reflect views funding agencies 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
sigmod june baltimore maryland usa 
copyright acm 
queries aim providing top query results user specified ranking function cases aggregate multiple criteria 
increasing importance top queries warrants efficient support ranking relational database management system rdbms gained attention research community 
available solutions supporting ranking queries middleware scenario rdbms piecemeal fashion focusing specific types operator queries sitting outside core query engines :10.1.1.112.869:10.1.1.55.2172:10.1.1.31.9882
top queries treated class query type losing advantages integrating top operations relational operations 
fundamental support ranking queries lacking mainly relational algebra notion ranking 
supporting ranking queries rdbms class query type significant research challenge 
system aims providing seamless support integration top queries existing sql query facility relational database systems 
example top query 
example consider user amy wants plan trip chicago 
wants stay hotel lunch italian restaurant condition cuisine italian walk museum lunch hotel restaurant cost price price museum restaurant area area area 
rank qualified results specifies ranking criteria predicates low hotel price cheap price close distance hotel restaurant close addr addr matching interests museum collections related collection dinosaur 
ranking predicates return numeric scores scoring function sums values 
query shown postgresql syntax 
select hotel restaurant museum order limit current relational query processing capabilities way execute previous query consume records inputs join inputs materialize join results evaluate predicates valid join result sort join results report top results user 
processing query way suffers problems inputs arbitrarily large joining inputs expensive 
may infeasible assume consume inputs inputs external sources web databases 
user interested total order possible combinations hotel restaurant museum 
aforementioned processing overkill unnecessary overhead 
ranking predicates expensive compute evaluated affect order rank results 
current query processing evaluate predicates valid join result able sort results 
proposed general approach supporting ranking relational query engines extending relational algebra rank aware 
rest show ranking account basic logical property efficient query processing optimization techniques devised efficiently answer top queries example 
summarize contributions follows extended algebra propose rank relational algebra extending relational algebra capture ranking firstclass construct 
ranking query execution model pipelined incremental execution model enabled rank relational algebra efficiently process ranking queries 
rank aware query optimization rank aware query optimizer addressing key challenges plan enumeration cost estimation construct efficient ranking query plans 
conduct experimental study initial implementation postgresql verifying effectiveness extended algebra enabling generation efficient ranking plans evaluating validity cardinality estimation method query optimization 
rest organized follows 
start section defining motivating ranking queries class construct 
section introduces rank relational algebra 
section introduces execution model physical implementation ranking query plans 
proposed rank aware query optimization section 
describe experimental evaluation section review related section 
conclude section 
ranking query model section defines rank relational queries section motivates need supporting ranking class construct section 
rank relational queries rank relational query illustrated example traditional spj query augmented ranking predicates 
conceptually queries canonical form eq 
terms relational algebra pn cm rh product base relations 
rh types operations performed top tuples denote projected attributes indicates returned results 
filtering boolean function 
cm filters results selection operator example ranking monotonic scoring function 
pn ranks results sorting operator example 
formally returns top tuples ranked qualified tuples rb cm rh 
tuple predicate score pi pi query score 
pn 
pn 
result returns sorted list top tuples ranked scores standard assumption monotonic 
xn yn xi yi 
note summation scoring function monotonic functions multiplication weighted average 
observe example shows rank relational query types predicates filtering traditionally supported query boolean selection predicates predicates 
ranking proposal rank selection predicate rank join predicate 
note new ranking predicates boolean counterparts various costs evaluate predicates may relatively cheap may simply attribute expression price 
general predicates expensive user defined built functions 
instance may require accessing line sources web hotel database current price may involve comparing addr addr geographical data may perform information retrieval style operation evaluate relevance 
goal support rank relational queries efficiently 
discussion reveals queries add ranking dimension query processing optimization ways parallels traditional dimension filtering filtering restricts tuple membership applying function boolean selection join predicates ranking restricts order applying function corresponding ranking predicates 
boolean predicates various costs ranking predicates share concern 
ask conceptually parallel supported rdbms 
ranking class construct boolean filtering constructs essentially supported rdbms support ranking clearly lacking 
motivate observe eq 
shows relational algebra provides selection operator filtering sorting operator ranking 
see significant gap support current systems 
relational algebra models boolean filtering cm class construct query processing 
filtering includes selections single table joins 
algebraic support optimization boolean filtering virtually processed canonical form eq 
consider instance selection join condition note sorting defined extended relational algebra model order sql 
rigorously returns min rb tuples 
algebra framework supports splitting selections interleaving operators 
algebraic equivalences enable query optimization transform canonical form efficient query plans splitting interleaving 
clear contrast algebraic support optimization completely lacking ranking pn 
sorting operator monolithic scoring function pn boolean counterpart 
cm evaluated entirety rest query materialized essentially na canonical form 
na materialize sort scheme choice fact cases prohibitively expensive 
want top results full materialization may necessary 
shall see section ranking predicates significantly cut cardinality intermediate results 
ranking predicates evaluated results full materialization na scheme 
various costs may beneficial cases evaluate ranking predicates interleave boolean filtering 
clear departure monolithic sorting believe rank relational queries call essentially supporting ranking class construct parallel filtering 
essential support observed consists requirements 
splitting ranking evaluated stages predicate predicate monolithic 

interleaving ranking interleaved operators filtering 
major challenges supporting ranking firstclass operation 
foundation extend relational algebra handle ranking define algebraic laws equivalence transformations section 
realize algebra define corresponding query execution model physical operators rank relations processed incrementally section 
second need generalize query optimization techniques integrating parallel dimensions boolean filtering join order selection ranking section 

rank relational algebra enable rank aware query processing optimization extend relational algebra rank relational algebra relations operators algebraic laws respect take advantage essential concept rank 
section define model section extend relational algebra section 
new rank relational algebra enables determines query execution model operator implementations 
discuss laws section new algebra lay foundation query optimization 
rank relations ranking principle fundamentally support ranking notion rank captured relational data model 
start extend semantics relations rank aware 
extended model define rank relation relation tuples scored ranking function ordered accordingly 
model rank relation note algebra extension support rank relational queries scoring function 
pn query eq rankings tuples progress processing 
consider base relation conceptually illustrates query tree 
ranking intermediate relations 
ranking predicate pi evaluated tuples disk arbitrary order 
splitting requirement section motivates ranking predicates generally processed stages 
ask predicates say 
pj evaluated cloud ranking 
note final results ranked 
pn stage complete scores predicates 
want define partial ranking tuples current incomplete scores resulted order consistent desired order processing 
queries evaluated incrementally iterators section ranking order output tuples subsequent operations cloud 
refer tuple ranked 
turns ranking principle 
property ranking principle respect scoring function 
pn set evaluated predicates pj define maximal possible score upper bound tuple denoted 
pn pi pi pi pi tuples processed necessarily process query answering 
proof straightforward 
intuitively maximal possible score tuple defines achieve evaluated assuming unknown predicates perfect scores 
monotonic substitution result upper bound 
score achieve possibly better 
refer subsequent operation process 
desirable draws outputs order precede 
ranking principle definition formalizes 
definition rank relation rank relation rp respect relation monotonic scoring function 
pn 
pn relation augmented ranking induced scores score tuple maximal possible score predicates evaluated 
implicit attribute rank relation 
order order relationship defined tuples rp ranking scores rp iff 
rigorously application specific value pi 
assume losing generality 
rigorous notated omit simplicity 
tid tid tid tid tid tid examples rank relations 
note ties scores arbitrary deterministic tie breaker function determine order unique tuple ids 
extended rank relational algebra generally operates 
base relations intermediate relations results rank relations 
rank relations closed algebra operators section define operators account new ranking property addition membership 
note base intermediate relation predicates evaluated consistently denoted simply hand 
pn partial score effectively complete resulting final ranking respect example running example show base relations schemas tuple ids ranking predicate scores 
note tuple ids predicate values shown pedagogical purpose 
predicate values unknown evaluated 
discussion illustrate various operators assume schema unioned predicates 
show join operator 
suppose scoring function 
show rank relations tuples ranked maximal possible scores 
operators extend relational algebra operators manipulating rank relations 
recall definition rank relation rp essentially possesses logical properties membership defined relation order induced predicates respect scoring function 
manipulating properties extend relational algebra adding new rank operator generalizing existing operators 
summarizes definitions operators illustrates examples continued example explain details 
new operator supporting ranking class construct propose add new operator rank 
section motivated goal satisfy requirements splitting interleaving 
essentially able evaluate ranking predicates pi time ranking effectively split interleaved operations 
new rank operator critical basis algebra 
defines rp evaluates additional predicate rank relation rp ordered evaluated predicate set definition states produces new order rank ranking predicate rp iff rp rp selection boolean condition rp iff rp satisfies rp iff rp union rp sp iff rp sp rp sp iff intersection rp sp iff rp sp rp sp iff difference rp sp iff rp sp rp sp iff rp fp join join condition rp sp iff rp sp satisfies rp csp iff operators defined algebra 
definition rp 
instance operates result rank relation shown equals 
note final result ranking 
extended operators extend original semantics existing operators rank awareness enable interaction new traditional boolean operations 
see extended algebra operations aware compute dual logical properties membership boolean predicate order ranking predicate 
note omit projection obvious 
omit discussion cartesian product similar join 
unary operators selection shown process tuples input rank relation original semantics simply maintains order input 
notation rp cr selection rp manipulates membership applying maintains order induced example shown 
binary operators union intersection join perform normal boolean operations time output tuples aggregate order operands aggregate order induced evaluated predicates operands 
instance rp sp similarly holds 
examples shown 
difference outputs tuples order outer input operand effectively discarded 
rp sp 
example shown 
algebraic laws query optimizers essentially rely algebraic equivalences enumerate transform query plans search efficient ones 
tid tid tid tid tid tids 
results operators 
extended rank relational model algebra dual logical properties dictate algebraic equivalences result membership order 
definition algebra just discussed assert algebraic equivalence laws 
extended algebra specifically support ranking gives equivalences relevant ranking 
essentially laws concretely state new freedom splitting interleaving achieving motivating requirements section rank relational algebra supports ranking class parallel boolean filtering 
laws directly definition algebra save space leave proof extended version briefly discuss usage query optimization 
particular explain laws specifically centering requirements rank splitting proposition allows split scoring function predicates pn series rank operations 
splitting useful processing predicates individually splitting requirement satisfied 
second interleaving propositions assert rank operations swap operators achieving interleaving requirement 
particular proposition deals swapping unary operators schedule freely 
proposition handles swapping binary operators push 
new algebraic laws lay foundation query optimization ranking queries algebraic equivalences define equivalent plans search space query optimizers 
see section algebraic laws guide designing transformation rules rule optimizers plan enumeration heuristics bottom optimizers 

ranking query plans execution model physical operators common database query engines query execution plan tree physical operators iterators interface methods allow consumer operator physical operator fetch result tuple time 
basic interface methods open method initializes operator prepares internal state getnext method reports result request close method terminates operator performs necessary cleanup 
execution query results drawn root operator draws tuples proposition splitting law pn pn proposition commutative law binary operator rp sp sp rp proposition associative law rp sp tp rp sp tp proposition commutative laws rp rp rp rp proposition pushing binary operators rp sp rp sp attributes rp sp rp sp rp sp rp sp rp sp rp sp rp sp rp sp rp sp rp sp proposition multiple scan join columns available 
algebraic equivalence laws 
underlying operators recursively till scan operators 
provides efficient pipelining evaluation strategy flow tuples stopped blocking operator sort blocking join implementation case intermediate results materialized 
nature ranking query lends pipelined incremental plan execution 
desire small number reduces size results users allows done want execution cost proportional interactive applications may estimate desired result size specified 
essentially desirable support incremental processing returning top results progressively user requests 
unfortunately traditional implementation ranking sticking sorting operation top execution plan overkill solution problem prohibitively expensive 
materialize sort scheme undesirably blocking result reported results general produced sorted 
cost independent startup cost equal total cost 
fortunately rank relational algebra advocates enables non blocking plans 
section show ranking query plans consisting new extended operators execute ranking principle property section physical implementations section 
incremental execution model realize rank relational algebra extend common execution model handle ranking query plans differences traditional plans 
operators incrementally output rank relations rp definition tuple streams pass operators order maximal possible scores upper bounds respect associated ranking predicate set ranking principle indicates desirable precedes processing 
second query explicitly requested result size execution stops results reported results available 
operator output intermediate result rank relation definition requires output order associated predicate set 
tuple output upper operator upper bound score guaranteed higher output tuples 
key capability rank aware operator decide information obtained input tuples order incrementally produce ranked output tuple 
illustrate consider operator input rp result preceding operator order produce outputs correct order immediately output tuple obtained may exist drawn 
evaluate get buffer ranking queue implemented priority queue maintains tuples order 
time top tuple queue output drawn tuple note definition 
conclude output example continue running example example show ranking query plans execute differently traditional plans 
consider simple top query base table ranking function example select order limit 
illustrates equivalent plans 
plan traditional plan consisting sorting sequential scan operator 
scans tuples evaluates predicates tuple buffers sorts scores till tuples scanned 
plan new plan enabled rank relational algebra index scan followed operators 
index scan accesses tuples order values simple attribute complex external built function 
index supported dbms postgresql 
plans rank relation operator op contains tuples processed op 
portion gray color incremental output rank relation op upper operator op incremental input rank relation op rank relation op contains tuples gray portion may different order op apply predicate result new order 
example consider plan 
processed tuples execution 
drawn processed tuples output top answer top operator plan tree 
note order tuples rank relations decided semantics definition rank relation definition operators section 
example output tuples order accessed underly ing operator evaluated 
precede output 
illustrate tuples flow plan example 
operator draws evaluates gets 
point output refer explanation paragraph right example 
buffers ranking tid tid tid tid tid tid tid tid seq scan ranking query plans vs traditional plan 
queue draws tuple 
sure point output top answer refer paragraph example 
evaluating getting buffered 
execution goes way get query results 
operators plan way plan tree executed pipeline recursively drawing tuples resulting diagram 
binary operators join principle obtain inputs streams combine scores inputs get updated upper bound scores seen unseen output tuples 
illustrated previous example execution model indicates rank aware operators selective reduce cardinality intermediate results output processed tuples 
instance selectivity rank relation clearly shows 
contrast traditional operators selectivity rank aware operators context sensitive 
reason selectivities operators dependent furthermore assumed independent locations plan assumed selection join selectivities traditionally 
instance plan similar plan order reversed 
selectivities plan respectively plan remember tuples 
selective enables operators reduce evaluation predicates various costs reduce cost join ranking query plans need materialize query contrast traditional materialize sort scheme processing ranking queries 
ranking query plans efficient traditional ones prohibitively expensive 
different scheduling interleaving operators result different number tuples processed query optimizers non trivially explore new type ranking plans section 
furthermore selectivities indicate cardinality estimation ranking plans challenging section 
example continuing example example shows ranking query plans outperform traditional plans different ranking plans different costs calls query optimization 
assume costs predicates predicate evaluation cost plan evaluate predicates tuples 
needs scan tuples 
tuples scan 
plan evaluates tuples evaluates tuples 
predicate evaluation cost plan 
needs scan tuples 
predicate evaluation cost plan needs scan tuples similar analysis 
implementing physical operators implement new physical operators order realize execution model 
fortunately previous works top queries middleware relational settings provide basis leverage 
briefly discuss implementation operators 
implementation straightforward example special case schedules predicate algorithms upper scheduling random object accesses middleware top query evaluation 
implementation adopts hash rank join nested loop rank join algorithms built symmetrical hash join hash ripple join 
new algorithms operators similarly implemented 
set semantics example 
traditionally exhaust input streams ensure duplicate tuple output 
input streams ranked judge duplicates tuple may appeared may seen predicate values tuple 
output ranked results incrementally 
example scan provided physical operator relational algebra 
index scan access tuples table order predicate exists index tree 
name rank scan 
index available attribute expression function supported practical dbms postgresql 
scan selection combine scan operator selection operator selection condition multi key index available 

generalized rank aware opti task cost query optimization transform parsed input query efficient execution plan passed query execution engine evaluation 
transformation task usually accomplished examining large search space plans 
optimizer utilizes plan enumeration algorithm efficiently search plan space prune plans estimated execution costs 
estimate cost plan optimizer adopts cost model 
extending relational algebra support ranking introduced section section direct impact query optimization 
section motivate need extending query optimizer support ranking study significant challenges associated extension 
show incorporate ranking practical query optimizers real world database systems 
rank relational algebra enables extended plan space plans expressed traditionally 
instance query example traditional optimizers allow sort plans 
contrast algebra enables equivalent plans 
equivalence guaranteed algebraic laws 
ranking function sort operator split definition proposition 
operators pushed join operators proposition 
note combined scan operation nested loop join sort merge join traditional plan 
ranking plan 
alternative plans example 
form 
splitting interleaving may achieve significant improvements performance discussed section 
order fully incorporate rank relational algebra cost query optimizer address impact extended search space plan enumeration costing 
plan enumeration desirability splitting interleaving ranking predicates requires optimizer fully explore extended plan space generating efficient query plans 
plan costing cardinality estimation performed rank aware operators costing pruning plans 
categories cost query optimizers real world database systems top rule optimizers exemplified volcano cascade system style bottom dynamic programming optimization framework 
volcano cascade transformation implementation rules key constructs searching plan space 
transformation rules transform equivalent algebraic expressions implementation rules map logical operators physical implementations realize plan tree 
extending rulebased optimizers rank relational algebra algebraic laws section naturally enable new transformation rules enumerate ranking plans 
implementation rules devised trigger mapping physical algorithms section 
cost estimation top optimizers apply similar techniques extending bottom optimizers costs complete plans subplans 
extending bottom optimizers incorporate ranking challenging plans constructed pruned bottom fashion global information complete plan 
focusing bottom optimizers show extend system style bottom dynamic programming dp approach plan enumeration section cost prune plans enumeration section 
dimensional plan enumeration take principled way extend dp plan enumeration treating ranking predicates dimension enumeration addition boolean predicates insight ranking order relationship logical property data parallel membership section 
recall definition rp essentially possesses logical properties boolean membership ranking order 
ranking query plan new ranking predicates introduced operators 
predicate set subplan operators subplan determines order just join conditions operations determine membership 
logical algebra expression optimizer able procedure dimension enumeration st dimension join size sr rh sr pair sr sr sr sr sr sr sr sr nd dimension ranking predicates predicates evaluable sr sp sp lan pseudo plan cost pair sp sp sp sp sp sp sp plan pseudo plan cost sr plan sr sp sr sp sr sp plan sr sp sp sp plan sr sp cost plan cost lan lan plan sr sp lan return rh pn dimension enumeration algorithm 
produce various plans schedule interleave operators select efficient plan just able select best join order 
dimensional enumeration approach reflects fact order membership dual logical properties rank relational model takes advantages dynamic programming paradigm reducing searching costs 
furthermore dimensional enumeration subsumes conventional plan enumeration join order selection affect optimization non ranking plans 
concept dimensional enumeration general extensible naturally including dimensions ordering operators selection union intersection example scheduling selection predicates traditionally considered important join order selection handled heuristics selection pushdown 
situation necessary handle task motivated dimensional enumeration incorporate scheduling selection ranking predicates treating boolean predicates dimension :10.1.1.169.1761:10.1.1.20.9548
due space limitations focus integrate scheduling ranking predicates join order selection omit consideration operators 
dp dimensional enumeration algorithm shown 
subplan define signature sr sp pair logical properties set relations sr set ranking predicates sp subplan 
subplans signature result rank relation 
algorithm enumerates number joined relations sr number ranking predicates sp 
plans signature sr sp generated joining plans signature sr sp sr sp adding plan signature sr sp scan operator 
principle optimality sub optimal subplan part optimal execution strategy plans signature best plan kept 
example illustrate algorithm optimizes simple query tables plan enumeration 
select order limit row contains best plans signatures size best plan signature 
instance row show best plans respectively 
show pruned plans crossed single table omit joined relations due space limitations 
enumeration starts signature size find scan plans signatures 
assume kept signatures pruned 
enumeration continues size look plans 
example plans built adding top 
comparing estimated costs pruned 
enumeration proceeds way final plan generated 
important detail system algorithm multiple plans logical properties may kept different physical properties 
example physical properties interesting orders potentially beneficial subsequent operations 
instance kept sorted access useful sort merge join joined dimensional enumeration algorithm support physical properties affected 
keep multiple plans different physical properties signature 
note interesting order possessed plans empty predicate set sp definition rank relations output order respect kind order useful operators sort merge join 
dimensional enumeration algorithm exponential number ranking predicates number relations procedure dimension enumeration heuristics replace line pair sr sr sr sr sr sr sr sr insert line sr sp pu pv pv sp rank pv rank pu continue line heuristics improving efficiency 
system style algorithm exponential number relations 
common practice query optimizers apply heuristics reduce search space 
example query optimizer choose consider left deep join trees avoid cartesian products 
heuristics effective improving efficiency able find comparably query plan 
propose heuristic reduce space dimension ranking predicates shown 
algorithm modifies incorporating left deep join heuristic line new heuristic ranking predicate dimension line 
ranking predicate scheduling heuristic greedily appends operators sequence considering valid permutations operators 
subplan plan suppose plan built adding plan 
optimizer pu build plan exists applicable pv appending pv better appending pu 
goodness appending pu plan selectivity cost defined rank pu card plan card plan cost pu cost pu evaluation cost pu card plan card plan output cardinalities plan plan 
rank confused concept rank algebra 
pu appended plan exists applicable pv higher rank 
intuitively rank higher cost lower selectivity smaller power reducing cardinality higher 
formula cost pu component cost model pu defined implementation 
techniques estimating cardinality subplan section 
greedy scheduling heuristic ranking predicates inspired rank metric scheduling independent selection predicates adaptive approach ordering correlated filters streaming data processing 
rank metric guarantees optimal fixed order independent selection predicates selection predicate applied higher rank 
property guaranteed scheduling operators simply context sensitive selectivities section 
adopt rank metric heuristic just applying left deep join heuristic sacrifices optimality efficiency common practice query optimizers 
costing ranking query plans optimizer prunes plans estimated execution costs cost model 
cost model various operators real world query optimizers quite complex depends parameters including cardinality inputs available buffers type access paths system parameters 
cost model complex key ingredient accuracy cardinality estimation intermediate results 
cardinality estimation ranking query plans difficult traditional ones cardinality information propagated bottom way 
conventional query plans input cardinality operator independent operator depends input subplans 
output cardinality depends size inputs selectivity logical operation 
ranking query plans operator consumes partial input actual input size depends operator operator decides obtained information inputs generate outputs 
input cardinality depends number results requested operator unknown subplan plan enumeration 
note number final results known complete plan 
imposes big challenge system style optimizers build subplans bottom fashion propagation value specific subplan depends location subplan complete plan 
address challenge propose sampling cardinality estimation method rank aware operators 
score th query result tuple 
technique intuition tuples upper bound scores lower need output operator 
unknown plan enumeration sampling method estimate estimate output cardinality subplan 
optimizer randomly samples small number tuples table evaluates predicates tuple 
note step necessarily performed time possible re predicate values succeeding queries 
estimate plan enumeration optimizer evaluates original query sample conventional execution plan retrieve top results proportional sample size 
suppose sampling ratio tables ti original size ni sample size ni ni 
transforms top query database top query samples 
score th topmost answer estimation intuition proportional sample size respect database size 
plan enumeration optimizer estimates output cardinality subplan card executing small samples 
results kept need execute estimating output cardinality plan built suppose outputs answers upper bound scores card estimated way card operator scan operator base table 
card card cards top operator unary operator top subplan output cardinality cards execution sample estimated output cardinality card previous steps plan enumeration 
card card cards card cards top operator binary operator inputs subplans 
output cardinality cards cards respectively execution sample estimated output cardinalities card card respectively previous steps plan enumeration 
experimental study section shows simple sampling method small sample ratio gives accurate cardinality estimates 
small sample size sampling method introduce overhead query optimization 
accurate random sampling joins known difficult 
plan investigate possibilities techniques improve sampling method 

experiments build prototype system postgresql 
extend internal representation tuples include implicit ranking score attribute rank relational model implement rank operator rank aware join rank scan operators 
section sets experiments conducted system 
set compares different execution plans demonstrate performance diversity plan space motivates need query optimization 
illustrates general circumstances performance plans possible extended plan space new algebra superior traditional plan evaluating top queries 
second set experiments verifies accuracy sampling method estimating cardinalities rank aware operators 
experiments conducted pc having ghz pentium cpu kb cache mb ram gb disk running linux operating system 
shared buffers shared memory buffer size sort mem internal memory sorting hashing settings postgresql configured mb mb respectively 
synthetic data set database tables having size schema 
table boolean attribute selectivities 
tables ranking predicates respectively 
ranking predicates cost 
implemented user defined functions attributes tables parameters 
scores different ranking predicates range independently generated different distributions including uniform normal mean variance cosine distributions 
table attributes jc jc join columns 
simple top query shown postgresql syntax 
summation scoring function select jc jc jc jc order limit illustrates execution plans query 
lan conventional materialize sort plan filter physical selection operator sort merge join physical join operator 
lan new ranking query plans 
implementations operator rank rank aware join operator rank scan operator described section 
plan rank scans accessing base tables scheduled join 
lan uses sequential scan rank scan 
lan applies operators normal sort merge join replace operators 
cost ranking execution plans suite experiments show costs execution plans top queries vary respect factors number final results number tuples table join selectivity number distinct values join attribute ranges cost ranking predicate unit costs 
performed groups experiments 
default values parameters 
group vary value parameter fix values sort sort merge join sort merge join filter jc jc rank filter sort jc jc rank filter rank plan plan rank rank filter sort merge join filter rank rank rank rank plan plan filter filter jc jc execution plans query parameters 
execute plan parameter settings measure execution time 
results shown 
note axes logarithmic scale 
figures illustrate plans best situations 
different plans orders magnitude differences costs 
diversity plan costs verifies need query optimization choosing efficient plans 
apparently traditional plan plan far outperformed rank aware plans plan 
performance comparable plans size tables requested results small joins selective predicates cheap 
situations traditional plan prohibitively expensive 
specifically shows traditional plan ranking queries blocking new rank aware plans incremental 
illustrates cost difference plans increases shown parallel lines logarithmic scale cost predicates 
predicate cost dominate plan execution cost getting larger number predicate evaluations change plan predicate cost changing 
shows traditional plan efficient joins selective performing join result small intermediate results ranking predicates evaluated 
shows ranking query plans plan efficient large tables 
instance plan relatively acceptable situations efficient plan plan table tuples 
note remove plan takes days finish scale 
cardinality estimation evaluate accuracy sampling cardinality estimation method compare original estimated output cardinalities operator execution plan top operator selection operators need estimation 
output cardinality top operator query 
output cardinality selection operator estimated estimated output cardinality input operator selectivity obtained database statistics 
example plan operators total output cardinalities execution time sec 
execution time sec 
plan plan plan plan number results execution time sec 
plan plan plan plan cost ranking predicate plan plan plan plan join selectivity execution time sec 
plan plan plan table size operators estimated estimate selection operators root operator 
similarly plan plan estimated cardinalities operators respectively 
experiment sample database sample ratio 
original tables contains tuples join selectivity original tables 
number set 
illustrates estimation results plan plan 
result plan similar plan include 
see small sample real estimated output cardinalities majority operators magnitude validating estimation method 

related introduce systematic principled framework extending relational algebra query optimizers support ranking class construct relational database systems 
believe proposed framework piece fully integrate ranking database systems logical algebra level physical implementation level 
previously top query processing studied middleware scenario rdbms piecemeal fashion focusing specific operator sitting outside core query engines 
contrast framework provides principled algebra foundation limited specific operation allows expressing optimizing general top queries 
highlight effort rank processing related 
middleware settings various algorithms proposed rank aggregation set objects merging multiple ranked lists scheduling random accesses efficiently goal minimizing number accesses objects 
different setting works explore concept upperbound scores inspires formalize ranking principle relational top queries 
similar sampling approach applied schedule predicates extend approach performances different execution plans 
output cardinality real estimated operator index operators plan real estimated operator index operators plan estimated real output cardinalities operators 
estimate cost general ranking query plans 
rdbms proposals support answering top queries application level outside core query engines supporting special types ranking queries 
supporting top queries inside relational query engine terms physical query operators proved efficient approach treats ranking basic database functionality 
operator proposed limit cardinality intermediate query result conservatively integrity constraints aggressively risk restarting query plan 
order supported operator columns relations sql queries 
aggregation multiple ranking criteria considered 
new operator devised supporting rank join query rank join predicates coexist boolean join predicates 
conducting normal join algorithms boolean join predicates rank join operator progressively produces join results 
relational query optimizer extended utilize rank join operator generating efficient query plans 
complement provide systematic support relational ranking queries rank join operators time supply algebraic foundation support 
dimensional enumeration framework enumerates plans dual logical properties handle scheduling rank operators join order selection extends interesting order physical property concept deal join enumeration 
interesting order extended support optimizing queries expensive boolean predicates 
concept dimensional enumeration general extensible dimensions including scheduling boolean predicates union intersection operators 
respect approach extending query algebra proposes algebra capturing semantic preference queries 
algebra proposed expressing complex queries web relations model web repositories 
algebra extension focuses capturing semantic application specific ranking order relationships web pages hyperlinks enabling efficient query processing 

introduced system full support ranking class operation real world database systems 
foundation key insight ranking logical property data parallel membership property 
centering insight introduced novel general framework supporting ranking relational query engines extending relational algebra 
extended rank relational algebra captures ranking property rank relational model introduces new extended operators fully express top queries 
defined set algebraic laws allowed rewriting optimizing top queries 
second pipelined incremental execution model ranking query plans realizing fundamental ranking principle extended algebra enabling efficient processing ranking queries 
third insight duality ranking membership properties introduced generalized rank aware optimization framework defines ranking additional plan enumeration dimension enumerating joins allowed generating full space rank aware query evaluation plans 
practical purposes introduced heuristics limit generated space 
introduced novel technique estimating cardinality top operations providing effective plan pruning mechanism get efficient ranking query plans 
experimental results initial implementation system 

babu motwani widom 
adaptive ordering pipelined stream filters 
sigmod pages 
bruno gravano marian 
evaluating top queries web accessible databases 
icde 
carey kossmann 
saying sql 
sigmod pages 

chang hwang 
minimal probing supporting expensive predicates top queries 
sigmod pages 

chang bergman castelli 
li 
lo smith 
onion technique indexing linear optimization queries 
sigmod pages 
chaudhuri gravano 
evaluating top selection queries 
vldb pages 
chaudhuri motwani narasayya 
random sampling joins 
sigmod pages 
chaudhuri shim 
optimization queries user defined predicates 
vldb pages 
krishnamurthy 
open architecture ldl 
vldb pages 
fagin 
combining fuzzy information multiple systems 
pods pages 
fagin naor 
optimal aggregation algorithms middleware 
pods 
graefe 
cascades framework query optimization 
ieee data eng 
bull 
graefe mckenna 
volcano optimizer generator extensibility efficient search 
icde pages 
guha gunopulos koudas srivastava 
efficient approximation optimization queries parametric aggregation constraints 
vldb pages 
guha koudas marathe srivastava 
merging results approximate match operations 
vldb pages 
balke kie ling 
optimizing multi feature queries image databases 
vldb 
haas hellerstein 
ripple joins online aggregation 
sigmod pages 
hellerstein stonebraker 
predicate migration optimizing queries expensive predicates 
sigmod pages 
hong stonebraker 
optimization parallel query execution plans xprs 
pages 
koudas papakonstantinou 
prefer system efficient execution multi parametric ranked queries 
sigmod 
aref elmagarmid 
joining ranked inputs practice 
vldb pages 
aref elmagarmid 
supporting top join queries relational databases 
vldb pages 
shah aref vitter elmagarmid 
rank aware query optimization 
sigmod 
kie ling 
foundations preferences database systems 
vldb pages 

chang smith 
li vitter 
supporting incremental join queries ranked inputs 
vldb pages 
ramakrishna 
query processing issues image multimedia databases 
icde pages 
raghavan garcia molina 
complex queries web repositories 
vldb pages 
selinger astrahan chamberlin lorie price 
access path selection relational database management system 
sigmod pages 
kotidis koudas srivastava 
ranked join indices 
icde 
wilschut apers 
dataflow query execution parallel main memory environment 
pages 
yi yu yang xia chen 
efficient maintenance materialized top views 
icde 
