design implementation certifying compiler presents design implementation com piler translates programs written type safe subset programming language highly optimized dec alpha assembly language programs certifier au checks type safety memory safety assembly language program produced compiler 
result certifier formal proof type safety counterexample pointing potential violation type system target program 
ensemble compiler certifier called certi fying compiler 
advantages certifying compilation previ ous approaches claimed 
notion certify ing compiler significantly easier employ formal compiler verification part generally easier verify correctness result computation prove correctness computation 
approach applied highly optimizing ers demonstrated fact compiler generates target code range realistic programs competitive cc gee compilers op enabled 
certifier drastically improves effectiveness compiler testing test case statically signals compilation errors oth require executions detect 
ap proach practical way produce safety proofs proof carrying code system may useful system safe mobile code 
question compiler correctness old compiler implementations 
published research sponsored part advanced research projects agency title fox project advanced languages systems software arpa order 
issued esc ens contract 

views contained document authors interpreted representing official policies expressed implied advanced research projects agency government 
acm george necula peter lee school computer science carnegie mellon university pittsburgh pennsylvania necula cs cmu john mccarthy refers problem interesting useful goals mathematical science computation mccarthy :10.1.1.141.7869
despite large body area dybjer guttman wand moore morris oliva wand thatcher wagner wright young lack technology prove automatically correctness optimizing compiler 
manual proofs rare tend verify algorithms implementations 
plus correctness proofs need redone slightest modification improve ment compiler 
proving compiler correctness just means actual goal ensuring correct output pro duced compiler 
propose poten tially practical approach goal 
verifying compiler check aspects correctness individual compilation 
ensure compiler bug free signal incorrect compiler outputs soon pro duced 
reduce complexity checking process try check full equivalence source target programs verify target program certain key properties verified small amount information source program 
design implementa tion touchstone optimizing compiler translates strongly typed programming language essentially type safe subset dec alpha assembly language certifier checks type safety assembly lan guage program produced compiler 
result certifier formal proof type safety ample pointing potential violation type system assembly language target program 
refer ensemble compiler certifier certifying compiler 
approach provides advantages method significantly easier employ formal verification compiler formal verification restricted proving type safe code emitted 
easier general verify correctness result computation prove correctness computation self 
furthermore approach compiler revisions improvements require change certifier 
method applied optimizing compilers design certifier restrict type specification annotated code optimizations compiler allowed perform 
optimizing compiler generates code programs matches performance gee cc optimizations enabled difference due optimizations implemented 
suc tested certifier hand optimized bly language 
presence certifier drastically improves effectiveness compiler testing test case statically signals compilation errors require executions detect 
approach ensure full compiler cor experience vast majority com piler bugs lead compiler generate unsafe target programs test cases 
method applicable compilation type safe language certifying prop erties target programs type safety 
significant benefit design requires rel modifications traditional compiler design possible adapt exist ing compilers technique 
practical method producing auto matic manner safety proofs proof carrying code necula necula lee system type safety :10.1.1.142.6054:10.1.1.40.2507
attaching type safety proof emit ted certifier assembly language program enable software system easily ver ify checking attached proof valid applies target program program type safe memory safe 
certifying com piler base system safe execution untrusted mobile code 
organized follows 
section give high level overview certifying compiler implemented compare related systems 
wc details source language compiled prototype compiler 
continue implementa tion details compilation certification phases 
discuss certification phase section design independent interest sets requirements compiler subsystem dis cussed section 
optimizations focus array bounds checking elimination show addi tional output compiler produce certifier check memory safety optimized code sec tion 
conclude experimental results range realistic programs section 
experiments show cost generating checking safety proofs low certifying true optimizing compiler output code performance approaches cc gee 
overview touchstone certifying compiler 
overview touchstone certifying compiler high level certifying compiler shown fig ure pipeline composed compiler certifier 
compiler traditional compiler adapted produce type specifications code annotations addition language target program 
determining target programs type safe memory safe easy matter due fact compiler performs wide range global optimizations 
example compiler performs global register allocation spilling coa register store values different types single code block 
compiler aggressively analyzes removes array bounds checks making nontrivial deduce target code mem ory safe 
full range optimizations performed compiler described section 
purpose code annotations pos sible simple certifier understand code verify type safety memory safety despite opti 
owing design certifier required annotations limited loop invariants declare types live registers loop body 
type specifications declare type argument result registers function code 
type specifications vehicle propagating source level information certification stage allow certifier verify target program retains typing characteristics source program full equivalence 
certifier subsystem pipeline composed subsystems verification condition generator re vcgen prover proof checker shown 
vcgen scans annotated language program type specifications code annotations produces safety predicate function code safety predicate proof assembly language program memory safe type safe typing specifica tion 
due code annotations typing specifications vcgen performed function time basis implemented efficient single pass program 
vcgen phase safety predicate sub prover order predicate logic pro duces formal proof predicate 
safety predicate proof simple proof checker verifies valid proof required safety predicate compiler output memory safe type safe 
important characteristic system small safety critical infrastructure 
code relied guarantee unsafe target programs escape unnoticed includes vcgen proof checker 
compiler prover need correct order guaranteed detect incorrect com piler output 
significant advantage vc vcgen gen proof checker significantly simpler compiler prover 
confidence vcgen proof checker enhanced fact borrowed unchanged proof carrying code sys tem necula lee september :10.1.1.142.6054
source language current prototype implementation certifying com piler strongly typed language essentially type safe subset programming language 
array subscripting operations implicitly guarded bounds checking conditionals 
order simplify elimi nation bounds checking array represented pair values representing base address array length 
length operator refers length component subscripting operation refers base address com ponent 
arrangement compatible common programming practice passing array length value gether base address 
multidimensional arrays length component dimension 
addition safe arrays compiler supports java style exceptions exception handling cleaner treatment array subscript errors dynamic allocation data structures heap booleans separate type arithmetic expression constructs programming language 
common language features currently missing recursive data structures func tion pointers floating point numbers allocation data structures stack 
function pointers expected pose difficulties currently supported certification subsystem 
course implement casts address operator pointer arithmetic explicit memory deallocation safe general safely restricted versions operators added 
implementation language assumes automatic garbage collector 
design details certifier design certifier establishes required code notations type specifications compiler produce 
important aspects certi design 
shall discuss type memory safety certifier general certifying properties handling safety properties languages 
concrete presentation certification pro cess introduce simple example program corre sponding compiler output 
program com sum elements integer array 
com piler compiles function time compiles program annotated code shown figures typing specification shown 
note source level array argument represented target program structure certifier 
int main int af int length aci return base address array length main mov zero mov zero ll ann nv int tl vo sub tl length ao tl ttl add id cil add vo vo br ll ret main pre array int post vo int example source program corre sponding compiler output consisting annotated code typing specification 
values base address register array length register return value returned register vo standard dec alpha calling con 
note compiler successful ing bounds checking operations example 
syntax meaning loop invariant code annotation appearing label ll typing specifica tions described section 
vcgen vcgen verification condition generator dec alpha annotated assembly language 
traditionally tion condition generation implemented backward pass code 
choose different implemen tation technique uses forward symbolic evaluation pass code 
vcgen operates function basis performs main operations 
firstly ensures code satisfies certain simple syntactic conditions branch targets code bound aries recognized instructions occur 
secondly vcgen evaluates code symbolically en counters memory operation emits verification condi tion vc states conditions memory operation considered safe 
example case read operation address condition saferd emitted 
write operation condition safewr rm 
ri expr es se el ez upd el es es types int boo array pred true pi pi vx el el el el saferd el es inv ann inv 
xk spec pre pi post pz syntax safety predicates 
emitted denotes value written 
meaning predicates saferd safewr defined level prover described section allow greater flexibility choosing desired flavor memory safety 
vcgen operate function basis ana code loops having iterate loop body multiple times 
accomplish require function code typing specification form precondition postcondition loop invariant annotation predicate hold time loop 
speci annotations come code trusted general third function vcgen ensure exist valid 
ensure loop ants vcgen verifies backward branch target associated invariant annotation 
order set stage detailed discussion vcgen proceed required notation 
symbolic evaluator operates syn tactic entities shown variables physical dec alpha registers ri 
memory pseudo register rm 
denote contents memory execution 
contents memory address written sel effect updating memory address ex pression modeled assignment rm 
upd 
write cs temp refer callee save tempo machine registers defined dec alpha calling convention 
language predicates contains order pred logic constructors memory safety predicates typing predicate 
types consider integers booleans dimensional arrays 
note array type encodes element type array length guaranteed 
type pointers elements type expressed array 
code annotations need purpose loop invariant annotations 
annotation contains invariant predicate set reg modified loop body see invariant label ll 
simpler presentation show code annotations part code practice stored data segment 
typing specification function pair pre condition postcondition 
precondition essen tially description calling convention declares type argument register function 
show syntax required examples 
practice comprehensive language expressions pred 

val vr 
array int int 
vg int vg int saferd ao oa vg sel rm int safety predicate annotated code 
similar declaration types re sult registers vo rm standard calling convention dec alpha 
function returning result postcondition true 
specifications easily derived type function see 
intuitively precondition predicate sumed true analyzing body function postcondition predicate true body function 
vcgen defined symbolic evaluator result predicate verification condition provable program safe respect typing specifica tion 
label spec type specification entire program represented map function labels typing specifications 
assume target program array ii instructions code annotations 
state symbolic evaluator consists current index target program ii register state list loop invariants encountered path start function 
recall vcgen translates function time 
register state mapping register names expressions vars expr 
write ri denote assigning ri write denote expression obtained ing register names values extend substitution notation predicates 
loop invariant mapping maps indices loop invariants regis ter states corresponding loop body 
states verify set changed registers loop 
core vcgen symbolic evaluator described function sen parameters annotated program ii type specifica tion initial register state postcondition current function po post current values instruction index register state loop state compute safety predicate function precondition pre postcondition post initialize registers new variables io 
machine registers 
memory pseudo register 
po resulting initial register state safety predicate formula spf 
po pre sj po simplify notation omit subscripts se function 
symbolic evaluation function defined formally recursive function described informally se rd rr rz iii add ri rz rd se iii pb se ann inv saferd iii nr se rd sel rs safewr rd iii rd se rm rd pre 
yk post se iii jsr pre post 
yk scramble post po cs 
yk se li re gs iii ann inv 
dam bl yk scramble iii ann inv eom scramble 
zk zl yr 
yk yl 
yk yi new variables po xes definition symbolic evaluator function sen 
th result symbolic evaluation safety predicate true program safe 
rest section 
arithmetic operations evalu ator updates symbolic register state continues instruction 
case conditional branch branches evaluated appropriate sumption outcome conditional 
note implication include control flow information resulting verification condition verification con dition proved code 
backward branch verified point invariant struction 
simple way verify loops invariant ensure termination symbolic evaluator 
memory operation appropri ate safety predicate emitted addition updating register state 
dealing function call evaluator ensure precondition part typing specification target function established prior call 
case memory operations vcgen verify precondition emits ap verification conditions precondition verified prover proving verification condi tion 
symbolic evaluator assumes conservatively temporary registers changed function cation 
unknown effect function call tem registers expressed symbolic evaluator help scramble operation defined bottom 
process code function call symbolic evaluator uses register state produced scramble assumes postcondition component typing specification met return 
note quantification new values temporary registers ensure new logical point view 
symbolic evaluator encounters return struction emits verification conditions provable current function postcondition satisfied callee save registers preserved ning function 
condition encoded conjunction equalities values registers function entry encoded register state po values function exit 
loop invariant annotation dealt manner array cl saf erd proof rules proving safety array accesses 
currently base types occur arrays size array entry bytes 
similar function call return instruction depending time encountered 
loop invariant encountered time symbolic evaluator verifies invariant established loop started 
symbolic evaluator simulates arbitrary iteration loop purpose creates new register values registers de modified loop body 
order process loop body symbolic evaluator uses new values registers assumes invariant holds new state execution loop body 
loop ant encountered second time marks arbitrary iteration initiated occur rence invariant 
time evaluator requires invariant established registers declared modified loop body modified 
conclude presentation vcgen showing safety predicate produces program 
prover proof checker prove safety predicates produced vcgen need theorem prover order logic 
existing theorem provers boyer moore detlefs gor don owre rushby shankar purpose produce proofs checked independently 
impediment long agree rely correctness prover give possibility certifying compiler front proof carrying code systems 
feel important properties re tain implemented theorem prover emits proofs 
theorem prover nelson oppen architecture cooperating decision procedures nelson oppen implemented stanford pascal ver luckham extended static check ing detlefs systems 
theorem provers traditionally viewed logically incomplete systems require human intervention instances 
system theorem prover guaranteed able prove safety predicates automat ically predicates implicitly proved compiler compilation 
example bounds checking elimination compiler eliminates bounds checking conditionals prove true 
tion corresponding array operation prompts sym evaluator emit predicate captures exactly arithmetic facts proved compiler 
theorem prover prov ing arithmetic facts compiler usually case practice theorem provers powerful typical compiler analysis arithmetic 
predicate calculus simple linear arith theorem prover able interpret typing memory safety predicates occur symbolic evaluator output 
done theorem provers specifying collection inference rules 
rules shown 
rule says safe read element array index array boundaries second rule says result read operation type array elements 
rules plus usual predicate cal rules reader verify informally safety predicate shown valid assembly language program memory safe 
role proof checker verify step proof valid proof proves re quired safety predicate 
proof checker proof carrying code system rep resents proofs language lf harper honsell plotkin simple typed calculus 
sev eral engineering advantages lf represent proofs fundamental proof checking accomplished simply type checking lf terms 
encode proof lf expression safety cate lf type 
lf type checking validate proof 
fact approach sound established harper honsell plotkin 
modifications described proved sound necula lee 
advantage arrangement lf type checker independent particular logic able reuse implementation checking proofs logics including memory safety type safety logic 
lf lf type checking simple leads small fast implementation proof checker 
optimizing compiler compiler component system different traditional compiler differences classified ss due changes language semantics due changes requirements output 
class includes enforcement array bounds mentioned 
class includes mechanisms emitting code annotations type specifications 
common task producing loop invariants type specifications conversion variable type declarations typing predicates involving machine regis ters 
done stages 
stage happens compiler front consists generating predicate source level variable type intermediate language temporary variable corresponding chosen type components pred similar source level types stage simple 
second stage done register alloca tion consists replacing temporaries occurring predicates register names chosen allocator 
procedure described necessary producing type specifications 
loop invariants emit typing predicates variables live loop body compute set registers changed loop body 
done separate pass output pro gram 
goals compiler implementation show output optimizing compiler certified type safety 
main optimizations implemented array bounds checking elimination constant propagation algebraic reductions dead code elimination common subexpression elimination loop ant hoisting register global variables induction variable elimination global register allocation 
implementation effort directed array bounds checking elimination bounds checking significant handicap respect ers compiling programs difficult verify memory safety assembly language programs bounds checking code elim 
results area major advantage til tarditi morrisett cheng stone harper lee java gosling joy steele bytecode verification 
type safety aspect certification sensitive optimizations compiler form including 
true memory safety aspect certification 
ous complication memory safety generated array bounds checking elimination 
optimization implemented compiler complicates tion memory safety induction variable elimination instance replaces array indexing running pointer inside array 
discuss array bounds checking elimination 
array bounds checking elimination array bounds checking elimination implemented compiler instance general condi tional elimination elimination condition als boolean expression statically proved true false 
proof attempted simple decision procedure linear arithmetic computing loop residues shostak 
conditional elimination analysis implemented pass intermediate representation 
bounds checking conditional encountered boolean ex pression converted form arbitrary expressions usually variables con stant 
form submitted loop residue decision procedure returns value saying current state boolean true false value determined statically 
cases conditional replaced code appro priate branch boolean expression recorded decision procedure state true branch considered recursively 
true branch finished boolean retracted negation asserted processing false branch 
conditionals involved array bounds checking form loop residue complete fragment arithmetic compiler able practice eliminate bounds checks 
situations analysis succeed eliminating bounds checks 
information required proof external current function 
happens example function int ac int return akl way verify statically valid index situation occur function inlined call site 
cover lack interprocedural analysis extended language allow programmer write simple function preconditions consisting boolean expres sions involving formal parameters 
example elim bounds check function program mer write int sub int int precondition length return il function preconditions assumed true analyzing function checked call site 
tions convenient way hoist bounds checks function call site information eliminating 
experiments checks cases eliminated conditional elimination phase eliminates array bounds checks 
situation conditional elimination anal ysis fail eliminate bounds checks inside loops 
example upper bound index loop termi nation conditional lower bound implicit 
seen loop invariant example compiler discovers lower bound emits part invariant 
deal situations compiler discovers monotone variables 
variable monotone paths loop body expressions positive negative 
detect monotone variables compiler collects set increments variable loop residue decision procedure verifies sign set elements 
monotone variable positive increments compiler generates loop invariant stating value variable greater equal value variable loop entry 
conjunct appeared invariant annotation 
experimental results purposes reporting results exper iments touchstone certifying compiler 
wish support claim applying cation technique optimizing compiler 
second wish show costs certification reasonably low 
purpose compare running times benchmarks compiled touchstone running times programs compiled gnu gee compiler vendor supplied compiler dec cc optimizations enabled 
second purpose measure size proofs time consumed vc generation theorem proving proof checking 
compare code size compilation time respectively 
benchmark programs depend language features currently implemented certifying compiler ruled floating point benchmarks ex ample bias programs array bounds checking elimination significant difference running time 
furthermore preferred programs useful native code components safe mobile code system order evaluate certifying compiler front system safe execution proof carrying code 
considerations led benchmarks 
blur sharpen edge bidimensional image processing filters xv program 
qsort implementation quicksort algorithm array integers 
simplex linear programming gorithm implemented rational numbers 
kmp imple mentation kmp search algorithm unpack gzip decompression algorithms core unix utility name chosen examples cases array bounds checking elimination ef 
bcopy program implementation string copy non overlapping strings 
worth noting programs fairly realistic size complexity required mi syntactic modifications conform safe dialect 
main changes involved replacing pointer arith array indexing 
results average runs dec alpha running mhz 
shows effect optimizations running time benchmark programs gnu gee compiler dec cc compiler certifying compiler 
compilers invoked optimizations enabled 
running times reported speedups run ning time unoptimized code compiled gee 
set bars geometric mean speedups compiler 
average cer compiler performs slightly better gee quite cc difference 
programs certifying compiler quite compilers kmp unpack due bounds checks eliminated bcopy lack loop unrolling certifying compiler 
addition array bounds checking elimination inter procedural register allocation common subexpression elimination played major role making quality code generated touchstone comparable produced compilers 
experiments compilers compile pro grams bounds checking touchstone handicap having implement effect optimizations certifying compiler expressed ratio running time optimized code time code compiled gnu gee 
comparison show benchmark effect optimizations gnu compiler gnu gee vendor compiler cc 
column geometric mean benchmarks 
comparison compilation time touchstone gnu gee dec cc compilers optimizations enabled 
times table shown milliseconds 
average touchstone slower gee slower cc 
note compilation time include vc generation proof generation proof checking 
comparison target code sizes programs compiled touchstone gnu gee dec cc compilers optimizations enabled 
sizes table shown bytes machine code 
average touchstone sizes code emitted compilers 
tla aa relative sizes bytes proofs invariants machine code 
hopefully remove array bounds checks 
array bounds checking elimination described section able eliminate checks proof local current function ineffective elimination requires global information 
weakness problem benchmarks blur edge bcopy 
substitute required global information cases added simple line function preconditions sharpen qsort simplex 
preconditions compiler succeeds eliminating bounds checking op erations kmp unpack benchmarks 
benchmarks special array indices computed contents auxiliary data structures 
formal safety argument array op erations involves proof complicated global program invariants probably reasonable expect compiler able eliminate bounds checks 
preconditions added programs benefit bounds checking elimination compiler feel gives unfair ad vantage compilers 
contrary ditions enable extensive bounds checking elimination job certifier difficult 
formal proof redundancy bounds checks eliminated preconditions global information larger complicated locally provable checks 
experiments show additional bounds checking elimination enabled preconditions leads average reduction code size reduction running time increase proof sizes 
due fact touchstone early prototype compilation time significantly larger compilers performance comparisons 
shows compilation times including time vc generation proof generation proof checking touch stone compilers ail optimizations enabled set benchmarks 
average touchstone slower gnu gee slower dec cc 
shows comparison machine code sizes distribution time spent compilation certification benchmarks 
data table expressed milliseconds 
programs compiled touchstone ers 
compilation times sizes machine code emitted touchstone emitted compilers 
note fundamental reason certifying compiler emit code larger emitted traditional compiler 
re spect compilation time certifying compiler incur extra cost emitting loop invariants type specifications 
cost negligible respect rest compilation effort 
hoping convinced reader certifying optimized assembly language move presentation costs certification 
purpose measured proof size time required vc generation theorem proving proof checking benchmarks discussed 
shows sizes safety proofs annotations compared sizes machine code benchmark 
annotations size code average 
average ratio proof size code size consistent observa tions experiments pcc hand written assembly language 
factor large consider proofs currently compressed 
preliminary measurements show general purpose compression algo rithms decrease size proofs factor 
larger reductions obtained fist optimizing proof representations employing compression algorithm 
discussion proof op section 
displays graphically distribution time spent compilation certification 
average time spent compiling proving rest split evenly vc generation proof checking 
results observations 
cost certification third cost compilation meaning reasonable certifier life compiler just compiler development 
sec ond vcgen proof checker sim compiler theorem prover faster 
safety critical infrastructure small fast 
important situations certifying compiler produce proof carrying code system receiving code needs trust run vcgen proof checker 
related idea checking individual compilations ver compiler appears cimatti 
cimatti simpler stance non optimizing compiler expression lan guage loops function calls rtl lan guage 
hand ambitious goal verifying full equivalence source expression target program 
compilation approach resembles respects compilation strategy til tarditi morrisett cheng stone harper lee compiler standard ml uses typed intermediate language easily type checked achieve independent validation optimizations 
til type system guarantee memory safety presence cer tain optimizations array bounds checking tion furthermore register allocation phase variables registers reused hold values different types body function 
reason types dropped til fore register allocation phase type checking possible level compiler output 
prob lems related register allocation solved morrisett 
morrisett walker crary choosing expressive type system issue memory safety presence optimizations array bounds checking elimination remains problem 
purpose design certifying compiler related java gosling joy steele compiler bytecode verifier lindholm yellin systems 
similarity systems produce code annotated purpose enabling certification system bytecode verifier java case verify type safety 
difference certifier flexible annotation language permits verification arbitrarily optimized assembly language ing fewer annotations 
bytecode verifier works specially designed bytecode intermediate language typing annotations contained instruction codes 
furthermore java bytecode verifier pre compiler doing important optimiza tions array bounds checking elimination global register allocation checks built def byte codes 
discussion approach certifying compiler inspired proof carrying code pcc necula necula lee fact reuses vcgen theorem prover proof checker components implementation pcc :10.1.1.142.6054:10.1.1.40.2507
pcc generality simplicity certifier important chosen alternate implementation approaches 
alternative suggested fact cation conditions emitted vcgen proved auto matically 
incorporate parts prover vcgen prove vcs encountered generating safety predicate proof checked 
particu practical array bounds verified small part prover 
java bytecode verifier lindholm yellin viewed approach type checker typed assembly language morrisett 
morrisett walker crary 
variation method attempt certify output shelf compiler produce annotations type specifications 
suspect achieved interposing loop invariant inference phase vcgen 
source lan guage compiler form aggressive global optimizations possible principle discover typing invariants completely au 
current experimental results show proofs times larger code 
preliminary experiments show standard compression techniques re duce proof sizes factor 
believe biggest gains reduction size obtained designing implementing optimizations repre sentation proofs 
current lf representation provides simple approach type reconstruction lows type information elided necula lee 
currently exploring aggressive tech niques involve finding common subterms essentially kind common subexpression elimination 
manual inspection proofs gives indication approach yield reductions necessary measure effects 
addition general notion certifying tion believe discovered simple correct ness criterion register allocation spilling instruction scheduling 
bugs compiler optimiza tions notoriously difficult find lead subtle errors output tend surface sporadic program failures usually instructions past actual erroneous instruction 
furthermore low level nature output fact errors occur large programs visual inspection output quite tedious 
observed result symbolic evalu ator insensitive global register allocation spilling global code scheduling 
development compiler meant verify run transformations simply comparing safety pred computed transformation 
see example consider annotated code 
code register tl hold values different types body loop 
observe independent uses rl renamed safety predicate change renaming bound variables predicate 
similar experiment shows phenomenon case instruction scheduling 
preserve invariance property presence register spilling symbolic evaluator extended interpret portion stack frame extension register file consider read write operations stack frame moves pseudo registers 
simplify symbolic evaluator memory addresses computed immediate offsets dedicated stack pointer frame pointer register intercepted memory proved heap allocated arrays 
strongly suspect observation form basis general correctness criterion global register allocation instruction scheduling useful compiler certifying compilers 
formal proof claim 
hope formal statement proof correctness criterion 
presents design implementation cer compiler composed traditional optimizing com piler typed language certifier automatically produces proof type safety assembly language program resulting compilation 
main benefit system traditional compiler cer acts effective referee correctness compilation simplifying compiler testing develop ment 
rare compilation errors break type safety target program detected cer compiler 
development certifying compiler encountered error op posed large number errors caught early certifier 
certifier reduced effort required development optimizing compiler formance rivals production compilers man months 
second important benefit certifying compiler serve automatic front system uses proof carrying code enable safe execution untrusted mobile code 
main contribution research design certifier restrict optimizations compiler perform requiring small amount information compiler 
indirect result identified symbolic evaluation technique base certifier leads simple effec tive correctness criterion low level optimizations register allocation code scheduling 
acknowledgments authors gary lindstrom trevor jim helpful comments suggestions earlier drafts 
anonymous refer ees suggestions improve 
boyer moore 
computational logic 
academic press 
cimatti 
june 
provably correct em verifier certification safety critical software 
computer aided verification 
th conference 
proceedings pp 

springer verlag 
luckham 
march 
stanford pascal veri user manual 
technical report stan cs dept computer science stanford univ detlefs 

overview extended static checking system 
proceedings formal methods software practice workshop 
dybjer 

domain algebras prove correctness compiler 
lecture notes computer science 
gordon 
july 
hol machine oriented higher order logic 
technical report university cambridge computer laboratory 
gosling joy steele 
java language specification 
java series 
reading ma usa addison wesley 
guttman wand 
verified implementation scheme 
lisp symbolic computation 
harper honsell plotkin january 
framework defining logics 
journal asso ciation computing machinery 
lindholm yellin january 
java virtual machine 
java series 
read ing ma usa addison wesley 
mccarthy 

mathematical theory computation 
ed proceedings international congress information ing pp 

north holland 
moore 

mechanically verified language im plementation 
journal automated reasoning 
morris 

advice structuring compilers proving correct 
proceedings acm symposium principles programming languages pp 

morrisett walker crary january 
system typed assembly language 
th annual acm symposium principles pro gramming languages 
acm 
appear 
necula 
january 
proof carrying code 
th annual acm symposium principles programming languages pp 

acm 
necula lee october 
safe kernel ex tensions run time checking 
second operating systems design tions pp 

usenix 
necula lee october 
efficient rep resentation validation logical proofs 
technical report cmu cs computer science depart ment carnegie mellon university 
nelson oppen october 
simplification cooperating decision procedures 
acm tions programming languages systems 
oliva wand 
verified compiler 
lisp sym computation 
owre rushby shankar june 
pvs prototype verification system 
kapur ed th international conference automated deduction cade volume lecture notes artificial intelligence saratoga ny pp 

springer verlag 
shostak 
october 
deciding linear ities computing loop residues 
journal acm 
tarditi morrisett cheng stone harper lee may 
til type directed optimizing compiler ml 
con ference programming language design imple mentation pp 

thatcher wagner wright 
advice structuring compilers proving correct 
lncs proceedings workshop semantics directed compiler generation 
young 

mechanically verified code gen erator 
journal automated reasoning 

