accessing nearby copies replicated objects distributed environment greg plaxton rajaraman andr ea richa consider set shared objects distributed network copies object may exist time 
ensure fast access objects efficient utilization network resources desirable access request satisfied copy close requesting node 
unfortunately clear efficiently achieve goal dynamic distributed environment large numbers objects continuously created replicated destroyed 
design simple randomized algorithm accessing shared objects tends satisfy access request nearby copy 
algorithm novel mechanism maintain distribute information object locations requires small amount additional memory node 
analyze access scheme class cost functions captures hierarchical nature wide area networks 
show particular cost model considered expected cost individual access asymptotically optimal ii objects sufficiently large memory objects dominates additional memory algorithm high probability 
address dynamic changes network set object copies 
preliminary version appeared proceedings th annual acm symposium parallel algorithms architectures spaa pages june 
department computer science university texas austin tx 
supported national science foundation 
ccr 
email plaxton cs utexas edu 
college computer science northeastern university boston ma 
part done author university texas austin support national science foundation 
ccr author dimacs center rutgers university 
dimacs nsf science technology center funded contract stc partially supported new jersey commission science technology 
email ccs neu edu 
department computer science engineering arizona state university tempe az 
part done author carnegie mellon university supported national young investigator award 
ccr arpa contract 
email asu edu 
advent high speed distributed networks feasible large number geographically dispersed computers cooperate share objects files words memory 
years seen emergence large distributed databases world wide web 
distributed nature databases rapidly growing demands users turn overloaded underlying network resources links memory space processors buffer space links processors 
attempt minimize communication delays satisfy users possible strategies making efficient network resources providing access shared objects devised 
expect task designing efficient algorithms supporting access shared objects wide area networks challenging practical theoretical perspective 
respect interesting measure performance latency throughput optimal bound achievable network complex function parameters including edge delays edge capacities buffer space communication overhead patterns user communication 
ideally take factors account optimizing performance respect measure 
task may feasible general network parameters interact complex manner 
reason adopt simplified model combined effect detailed network parameter values assumed captured single function specifies cost communicating fixed length message pair nodes 
accessing shared objects 
consider set objects shared network copies object may exist 
shared object may replicated order improve faulttolerance performance example 
consider basic problem reading objects motivated need efficient network utilization seek algorithms minimize cost read operation 
address write operation involves additional consideration maintaining consistency various copies object 
problem consistency important separate main concern studying locality 
results read operation apply write operation scenarios consistency required enforced independent mechanism 
differentiate shared unshared copies objects 
copy shared node read copy unshared node holds copy may read 
say node inserts resp deletes copy object holds declares copy shared resp unshared 
refer set algorithms read insert delete operations access scheme 
access scheme efficiently supports operations incurs overhead memory 
desirable overhead small space considerations low overhead usually implies fast adaptability changes network topology set object copies 
main source difficulty designing access scheme efficient respect time space competing considerations measures 
example consider access scheme node stores location copy object network 
allows fast read operations node easily determine location closest copy desired object 
access scheme impractical incurs prohibitively large memory overhead node network informed copy object inserted deleted 
extreme consider access scheme additional memory 
case insert delete operations fast read operations costly may necessary search entire network order locate copy desired object 
access scheme 
design simple randomized access scheme exploits locality distributes control information achieve low memory overhead 
central part access scheme mechanism maintain locate addresses copies objects 
single object say provide mechanism approach 
embed node virtual height balanced tree network 
node network maintains information associated copies residing set nodes form subtree rooted embedding read operation may easily defined follows 
node attempts read checks local memory copy information copies subtree rooted local check unsuccessful forwards request object parent 
naive extensions approach account objects require significant overhead memory control information individual nodes 
overcome problem designing novel method embed different trees associated different objects 
embedding enables define simple algorithms read insert delete operations prove efficiency class cost functions appropriate modeling wide area networks 
important property access scheme require location dependent naming copies objects 
avoids renaming copy object time copy migrates location network 
keeping track replicated copies object may pose problem location dependent naming objects copies object located different addresses network different names 
properties scheme restricted class cost functions considered due distribution control information shared data scheme expected avoid hot spots network heavily accessed nodes ii due distribution data combined support object replication fast adaptability changes network scheme expected scale 
scalability important problems solved today large scale networks example world wide web spite scalable components clients servers tcp ip connections dns serious problems scalability 
cost model 
indicated assume function determines cost communication pair nodes network 
analysis geared restrictive class cost functions believe practical interest 
precise set assumptions respect cost function stated section 
primary assumption nodes costs ratio number nodes cost node number nodes cost node bounded constants greater entire network cost node case ratio may low 
important observations concerning primary assumption cost function 
number commonly studied fixed connection network families lead naturally cost functions satisfy assumption 
example fixed dimension meshes satisfy assumption cost communication nodes defined minimum number hops constant degree trees satisfy assumption cost communication nodes distance nodes physical layout wide area layout vlsi layout tree 
example fat tree topologies satisfy assumption cost communication nodes determined total cost shortest path nodes cost assigned individual edges grows appropriate geometric rate move higher tree 
fat trees particular interest commonly studied fixed connection network families fat tree captures hierarchical structure wide area networks may provide plausible approximation structure current networks 
probably inappropriate attempt model internet say kind uniform topology including fat tree 
note assumption cost function purely local nature allows possibility network highly irregular global structure 
may important characteristic cost model 
performance bounds 
show access scheme achieves optimality near optimality terms important complexity measures restricted class cost functions discussed 
particular scheme achieves bounds ffl expected cost read request asymptotically optimal 
ffl expected cost insert resp delete operation node resp log maximum cost communicating single word message nodes 
ffl number objects stored node additional memory required log words whp word log bit string 
objects sufficiently large omega log words memory objects dominates additional memory 
ffl number nodes need updated addition removal node log expected log whp 
obvious shortcoming analysis applies restricted class cost functions discussed 
expect existing networks fall precisely restricted class stress access scheme defined functions correctly arbitrary networks ii expect access scheme practical performance existing network 
attempted formalize results lines performance bounds degrade significantly presence large number nontrivial violations cost function assumptions 
related 
basic problem sharing memory distributed systems studied extensively different forms 
earlier area assumes nodes network knowledge hash function indicates location copy object 
examples include pram emulation schemes completely connected distributed memory machines bounded degree networks algorithms providing concurrent access set shared objects 
basic problem locating object arises distributed system formalized mullender vit anyi instance distributed matchmaking problem 
awerbuch peleg subsequently bartal fiat rabani awerbuch bartal fiat give near optimal solutions terms cost related problem defining sparse neighborhood covers graphs 
studies address overhead due control information natural extensions results problem may require additional memory words node 
note schemes designed arbitrary cost functions focused optimizing performance restricted class cost functions 
awerbuch peleg examine problem maintaining distributed directory server enables keeping track mobile users distributed network 
problem viewed object location problem objects migrate network 
access schemes certain internet applications described 
ideas scheme similar schemes differ considerably details 
schemes analyzed 
study results concerning locality assume restricted cost model 
cost model ultrametric different 
algorithms primarily designed problems associated hot spots popular objects 
maggs investigate problem determining placement copies objects network problem devising efficient access scheme main goal keeping edge congestion low :10.1.1.38.1850
considers cost models arise restricted network topologies trees meshes clustered networks 
closely related problem designing dynamic routing scheme networks 
scheme involves maintaining routing tables different nodes network way additional memory 
routing schemes size additional memory function network size problem overhead primarily function number objects 
abbreviation whp mean high probability precisely probability gamma gamma number nodes network constant set arbitrarily large appropriately adjusting constants defined relevant context 
straightforward generalizations routing schemes result access schemes require additional memory words node 
remainder organized follows 
section defines model computation 
section gives informal overview access scheme 
section presents formal description access scheme 
section contains formal statement main results 
section gives informal overview analysis access scheme 
section presents preliminary definitions analysis 
sections formal analysis establish main results 
section discusses directions research 
model computation consider set nodes local memory sharing set poly objects 
define model computation characterizing aspects problem objects ii communication iii local memory iv local computation complexity measures 
objects 
object unique log bit id log ai denote ith bit id object consists words word log bit string 
communication 
nodes communicate means messages message consists word 
assume underlying network supports reliable communication 
define cost communication function 
nodes cost transmitting single word message assume symmetric satisfies triangle inequality 
assume simplicity 
assumption sake convenience essentially loss generality arbitrarily small perturbation cost function break ties 
cost transmitting message length node node 
nondecreasing function 
real denote set fv rg 
refer ball radius assume exist real constants ffi delta node real ng jm delta jm local memory 
partition local memory node parts 
part main memory stores objects 
second part auxiliary memory storing possible control information 
local computation 
cost associated local computation 
model allows arbitrary amount local computation zero cost algorithm perform particularly complex local operations 
complexity measures 
evaluate solution basis different complexity measures 
measure cost reading object 
second measure size auxiliary memory node 
remaining measures concern dynamic nature problem address complexity inserting deleting copy object adding removing network node 
third measure cost inserting deleting copy object 
fourth measure adaptability defined number nodes auxiliary memory updated addition removal node 
notion adaptability analogous 
informal overview access scheme purpose section provide informal high level description access scheme 
formal description access scheme section 
reader interested formal description may skip section loss continuity 
positive integer denote set gamma 
considering simplified version access scheme 
simplified scheme nodes network assigned log bit label uniformly random 
recall node unique log bit id independent label 
node labels construct neighbor table node 
node integer log bit string ff neighbor table node stores log bit id closest node node minimum bit suffix label equal ff 
call node ff neighbor 
node exists largest integer label node matches ff lowest bit positions denote set nodes define ff neighbor closest node 
neighbor table node large number entries theta 
large table size main technical deficiency simplified access scheme ease refer deficiency problem section 
develop non simplified access scheme address problem reducing size neighbor table theta log 
ignore problem moment continue consider simplified scheme 
discussion arbitrary object ffk denote bit suffix unique id object insert copy object node place pointer copy log nodes network 
delete copy remove set pointers 
nodes determined follows log place pointer ffk neighbor probability bit suffix label arbitrary node matches particular bit string ffk gamma consider ball node containing exactly nodes 
note constant probability approximately node matches ffk 
radius lower bound constant factor expected distance ffk neighbor 
radius upper bound 
arbitrary metric example diameter smallest ball containing nodes arbitrarily larger diameter smallest ball containing nodes 
assumption left inequality equation shown radius provides tight bound expected distance ffk neighbor 
furthermore right inequality equation implies expected distance ffk neighbor geometrically increasing observation turns useful implies expected total distance ffi neighbor summed dominated constant factor expected distance ffk neighbor 
describe process read request object node simplified access scheme 
copy processes read request locally 
processes read request follows xk denotes ffk neighbor log consults 
pointer copy constant factor away returns pointer copy retrieves copy read complete 
pointer consults 
general xi pointer copy constant factor away xi xi returns pointer copy retrieves copy read complete 
deficiency scheme may fail locate pointer copies network 
fortunately deficiency may easily rectified making slight modification definition ignore issue informal discussion 
general completes read operation pointer xk total cost read proportional sum distances xi distance copy retrieved 
definition algorithm distance dominate 
furthermore discussed earlier expectation summation dominated expected distance xk 
main objective prove expected cost read operation optimal proportional distance closest copy object sufficient prove distance closest copy object proportional expected distance xk 
denote node holding closest copy integer expected distance xj distance intuition underlying claim expected distance xk proportional distance reasonable chance xi ffi neighbor addition 
approach formalizing intuition involves showing assumption equation sets nodes contained balls radius theta centered nodes apart substantial constant fraction intersection 
argue constant probability read operation terminates successfully successive node xi argument yields desired main theorem expected optimal cost read operation long probability success successive iteration sufficiently close offset geometrically increasing expected cost visiting successive xi 
example expected distance xi success probability strictly greater discussion follows refer problem achieving sufficiently large constant success probability problem 
foregoing completes description discussion simplified access scheme 
sketch design non simplified access scheme 
focus discussion approach overcoming problems main technical problems identified 
mentioned address problem replacing entry neighbor tables defined log entry tables 
basic idea underlying exponential reduction table size straightforward 
consider ball containing set nodes notice log bit string ff log ff neighbors nodes set 
fact bit string ff ff neighbors nodes set 
furthermore extent ff neighbors differ clear differences crucial performance algorithm 
observations suggest may possible reduce table size allowing clusters nodes share common values 
section simple method achieving kind sharing clusters 
interesting important feature method explicitly partition network clusters 
global partition difficult maintain efficiently highly dynamic network 
method completely distributed derives efficiency simple properties randomly assigned node labels 
example exploit fact fixed set nodes expected number occurrences bit suffix follows random node labels partition shared table entries cluster 
reducing table size manner solves problem introduces technical difficulty describe refer problem 
revised tables turns algorithm performing read operation changed significant manner 
simplified scheme described successively contacts nodes cetera suitable pointer desired object 
actual access scheme similar suitable pointer node read request forwarded suitable neighbor opposed neighbor 
placement pointers insertion modified similar manner 
result sequence nodes read request forwarded access scheme different sequence nodes cetera simplified access scheme 
denote ith node new sequence 
unfortunately change access scheme tends increase expected number iterations read operation succeeds 
informally reason increase neighbors defined terms distance purposes read operation originating node distance useful metric distance 
problem bounding increase expected cost read operation due forwarding refer section problem main technical challenges faced analysis 
aside reduced neighbor tables alluded main differences simplified access scheme described section access scheme section 
differences designed help overcome problems respectively 
paragraphs briefly sketch differences provide intuition underlying relevance problems 
difference access scheme section maintain sufficiently large constant number neighbors table entry single neighbor 
words storing id closest node label satisfying certain condition store ids closest nodes satisfying condition sufficiently large constant accordingly copy object inserted place pointers copy times nodes simplified scheme 
furthermore iteration algorithm processing read request search appropriate pointer copy object nodes 
leaving pointers expanding search pointers manner iterations read operation small constant success probability success probability close 
improvement success probability clearly helpful dealing problem 
furthermore cost change access scheme constant factor terms time space 
second difference access scheme section view random node labels base numbers sufficiently large constant base numbers 
example read operation proceeds dlog iterations log iterations 
simplified access scheme ratio expected distance expected distance constant greater distances geometrically increasing 
ratio larger constant 
increasing ratio helpful dealing problem informally effect forwarding negligible distance tends smaller distance ratio distance important analyze bounding cost read distance easier analyze closely related table entries algorithm due forwarding typically close 
consequently able show drift sequence cetera sequence get requests forwarded sent neighbors simplified scheme small increase expected cost read operation due forwarding small 
access scheme section access scheme shared objects 
assume power fixed positive integer specified see section 
node assign label independently uniformly random 
log xi denote ith bit label note label node independent unique log bit id node 
resp define nonnegative integer binary representation gamma delta delta delta resp denotes gamma delta delta delta aib log 
assign total order nodes bijection fi 
partition auxiliary memory node parts neighbor table pointer list node 
ffl neighbor table 
node neighbor table consists log levels 
ith level table log consists primary secondary reverse neighbors 
primary neighbor 
log gamma node minimum node exists ii node largest fi nodes matches largest number rightmost bits 
note primary neighbor node guaranteed exist candidate node 
fixed positive integer specified see section 
primary neighbor wi denote set nodes fyg 
wi empty set 
level level level node minimum node minimum yi xi zi xi nlog zi yi primary neighbor table node 
set secondary neighbors subset minfd jjg nodes minimum wi wi node reverse neighbor primary neighbor illustrate primary neighbors entries neighbor table node suppose level neighbors table 
ffl pointer list 
node maintains pointer list ptr pointers copies objects network 
formally ptr set triples node holds copy upper bound cost 
maintain invariant triple associated object ptr 
pointer list may updated result insert delete operations 
pointer lists initialized inserting shared copy network start computation 
address cost initializing auxiliary memories nodes 
node label matches terms binary representation id largest number rightmost bits 
case tie nodes rk unique node ri maximizing fi ri 
call root node object uniqueness root node crucial guarantee success read operation 
section notation denote sequence ff ffk length 
clear context omitted 
particular primary neighbor sequence maximal sequence uk root node ui primary neighbor ui worth noting sequence label node ui satisfies ui gamma ui gamma give overview read insert delete operations 
ffl read 
consider node attempting read object read operation proceeds successively forwarding read request object originating node primary neighbor sequence hxi forwarding read request node xi gamma informs xi current best upper bound cost sending copy receiving read request associated upper bound node xi proceeds follows 
xi root node tx root root page tree associated object primary neighbor sequence 
xi requests copy associated current best upper bound sent xi communicates primary secondary neighbors check pointer list neighbors entry xi updates minimum smallest value obtained 
constant factor cost hxi xi pi gamma xj xj xi requests copy associated upper bound sent xi forwards read request xi 
relating general description read operation scheme described section tree associated object rule parent node primary neighbor maximum index gamma gamma words parent node node xi primary neighbor sequence hxi 
illustrates tree sequence hxi 
ffl insert 
insert request object generated node updates pointer lists nodes prefix primary neighbor sequence hyi update arrives node yi means insert message yi updates pointer list upper gamma yj yj cost getting object smaller current upper bound associated list 
words yi updates ptr yi delta delta list delta ptr yi greater pi gamma yj yj 
node yi forwards insert request node yi ptr yi updated 
ffl delete 
delete request object generated node eventually removes triples form delta pointer lists ptr yi hyi primary neighbor sequence making copy unavailable nodes network 
receiving request means delete message node yi checks entry associated pointer list form delta 
delete procedure completed need proceed updating pointer lists hyi 
yi deletes entry pointer list checks entries associated pointer lists reverse gamma gamma neighbors 
entry yi updates ptr yi adding entry yi reverse gamma gamma neighbor yi minimum upper bound associated pointer list 
delete message forwarded yi 
read insert delete operations summarized figures 
messages requests respect object read request generated node sends message read delta hold copy read message read indicates read request object generated node ii current best upper bound cost reading copy cost accessing copy insert resp delete request generated node sends message insert resp delete 
insert message insert indicates recipient node best known upper bound cost incurred bringing copy located node assume holds copy copy unshared resp shared insert resp delete request generated action xi receiving message read 
xi gamma gamma log gamma xi root ffl node xi sends message satisfy node delta ptr xi requesting send copy ptr xi entry shared copies ffl set secondary neighbors xi 
node xi requests copy associated upper bound node fxi 
ffl node fxi responds request message received xi follows exists entry qv ptr qv xi pi gamma xj xj sends success message success xi 
ffl set nodes xi receives response message success ku 
empty xi updates kz node minimum ku 
ffl pi gamma xj xj xi sends message satisfy node requesting send copy xi forwards message read xi 
action receiving message read object action yi receiving message insert 
delta delta ptr yi delta ptr yi ffl node yi accordingly creates replaces entry associated ptr yi inserting list 
ffl yi gamma gamma yi sends message insert yi yi yi 
actions receiving message insert object correctness access scheme follows points 
insert delete procedures maintain invariants 
entry associated pointer list holds shared copy hyi primary neighbor sequence entry associated pointer list node hyi ii nodes pointer list entry associated copy form prefix subsequence hyi 
preceding claims follow directly insert delete procedures described 

read request object node successful 
locates brings shared copy copy currently available 
read operation proceeds primary neighbor sequence hxi copy located action yi receiving message delete 
delta ptr yi ffl set reverse gamma gamma neighbors yi 
node yi removes delta ptr yi requests copy ffl responds request message yi sending message success qv yi yi qv ptr 
ffl set nodes yi receives message success ku response request message sent 
ju yi inserts kw ptr yi node kw ku 
ffl yi gamma gamma yi sends message delete yi 
actions receiving message delete object root reached 
point exists shared copy network root pointer 
performance bounds section state main claims regarding performance access scheme 
theorems state bounds cost read cost insert delete size auxiliary memory adaptability access scheme 
theorem node object node minimum holds shared copy expected cost satisfying read request 
denote maxfc node tries read object currently shared copy network expected cost read operation 
theorem expected cost insert operation delete operation log 
theorem number objects stored main memory node 
size auxiliary memory node log words whp 
theorem adaptability scheme log expected log whp 
informal overview analysis section give informal overview analysis access scheme 
section gives overview analysis read operation 
section outlines analysis performance bounds 
reader interested formal analysis access scheme may proceed directly section loss continuity 
read operation suppose node issues read request object closest copy lies node recall closest node node minimum holds copy 
hxi resp hyi denote primary neighbor sequence associated object node resp 
copy inserted prior read request guaranteed node yj sequence hyi pointer copy node closer yj read operation proceeds forwarding request nodes sequence hxi pointer esp ghostscript se con da ry eig rs page read request object forwarded pointer copy 
copy obtained 
fact read request forwarded node xi sequence hxi xi checks auxiliary memory secondary neighbors pointer copy pointer nodes object fetched appropriate node 
request forwarded level 
illustrates neighbor sequences forwarding process 
read request object generated node forwarded hxi pointer copy residing node node secondary neighbor 
important part analysis place upper bound smallest level neighbor sequence pointer object 
course owing randomization access scheme upper bound probabilistic 
words characterize probability distribution probability distribution directly yield cost incurred read operation cost incurred level random variable 
expect cost incurred highest level dominating term cost need formally incorporate intuition 
balls defined primary neighbor sequences 
characterize probability distribution analyzing certain balls defined sequences hxi hyi 
nonnegative integer ai resp di denote ball smallest radius xi resp yi contains xi resp yi 
bi resp ei denote set resp idj 
ci denote ball smallest radius xi contains secondary neighbors xi 
select superset node yo implying upper bound smallest level pointer guaranteed 
cost incurred forwarding request messages constant factor depends constant sum radii ci yo pointer copy node insert operation ensures yo sum radii di total cost read operation constant factor sum radii ci di follows discussion preceding paragraph estimate total cost read operation determining bounds sizes balls ci di 
proceed identifying balls centered resp expected contain balls ai resp di ci set bi resp ei consider balls ci di 
expected size ball theta 
choosing sufficiently large ensure expected size ci resp di grows rapidly expected radius ci resp di greater expected distance xi resp yi 
result sizes balls level close respective expected values see ci superset ball xi subset ball xi consist theta closest neighbors similarly expect di subset ball yi consists theta closest neighbors ball ci includes secondary neighbors xi di defined primary neighbor yi choose sufficiently large xi constant factor bigger yi 
lambda smallest radius xi theta 
equation appropriate choice constants depending delta definitions xi yi implies greater equal lambda xi superset yi 
define smallest lambda ci xi di yi hold 
loosely speaking xi yi may thought expected values balls obtained processing read request insert request respectively simplified access scheme described section 
recall simplified scheme node processes read request repeatedly querying appropriately chosen neighbors lie increasingly larger balls similarly node processes insert request object repeatedly passing pointer new object copy appropriately chosen neighbors increasingly larger balls mentioned section simplified access scheme relatively easy analyze suffers drawback memory required individual nodes high 
analyzing drift balls 
foregoing discussion argued behavior access scheme level close expected behavior ci xi di yi hold quite ball sizes may deviate expected values level 
important part analysis quantify drift balls ci di respect balls xi yi respectively bound increase expected cost due forwarding technical challenge referred problem section 
fact helps analysis quantify drift sets ai bi ei provide accurate characterization access scheme 
main difficulty possible place useful high probability bounds amount drift value obtain approximate probability distribution amount drift 
precisely define nonnegative state variable si resp ti sequence hxi resp hyi captures amount drift balls ai bi ci resp di ei 
larger values state variables si ti larger drift 
example si ci superset xi ci subset 
similarly ti set di subset yi 
defined smallest lambda si ti 
sequence si ti naturally viewed random walk dimensional integer lattice 
key claims concerns characterization random walk defined si ti 
show lemmas random walk biased 
precisely show si resp ti positive decreases probability arbitrarily close selecting constants algorithm sufficiently large 
note sufficiently large value ensures probability ci subset di subset yi close addressing problem section 
similarly sufficiently large value ensures probability ci superset xi close addressing problem section 
bounding expected total cost 
lemmas characterize single step random walk defined si ti 
lemmas standard combinatorial techniques analyzing random walks line establish claim lemma probability smallest index si ti decreases exponentially obvious corollary preceding claim expected value lambda 
importantly allows bound tail probability distribution lemma implies probability read request terminates level lambda decreases exponentially gamma lambda hand expected cost incurred level increases exponentially choosing constants involved judiciously ensure product probability reaching level lambda expected cost incurred level decreases exponentially gamma lambda yielding desired upper bound expected total cost 
performance bounds informal overview analysis performance bounds insert delete operations auxiliary memory size adaptability access scheme 
consider insert delete operations 
insert operation issued node node updates pointer lists nodes prefix primary neighbor sequence hyi 
desired upper bound expected cost insert operation follows directly bounds expected cost incurred level primary neighbor sequence establish analysis read operation 
delete operation issued copy object node additional communication cost needs taken account node primary neighbor sequence hyi may send message reverse neighbors check copy show standard chernoff type arguments number reverse neighbors node log expected log whp corollary leading desired bound delete operation 
mentioned section auxiliary memory node consists parts 
part neighbor table consists primary secondary reverse neighbors 
number primary secondary neighbors node log discussion preceding paragraph number reverse neighbors indicates size neighbor table log expected log whp 
bounding size second part pointer list observe node pointer object lying node primary neighbor ii label node matches id rightmost ib bits 
show means chernoff type argument number nodes satisfy condition ib log whp see lemma 
probability condition ii occurring ib 
number objects lying node log possible values obtain number pointers node log whp 
yields desired upper bound auxiliary memory size 
number nodes need updated removal addition node equal total number neighbors desired bound adaptability access scheme follows directly bound size neighbor table 
preliminaries analysis section preliminary definitions section analysis 
define relationship constants appear model access scheme analysis 
constants ffi delta appear model appear access scheme fl appear analysis 
choose fl inequalities hold 
delta fl fl fl delta maxf delta fl gamma fl delta delta fl 
delta db gamma assignment values constants fl satisfies inequalities may obtained follows set fl equal delta equal delta equal delta 
preceding assignment satisfies equations set sufficiently large 
equations satisfied setting large delta gamma db delta 
note assume ffi model gamma db set arbitrarily large constant choosing sufficiently large 
course analysis frequently study certain local neighborhoods node respect cost function section defined ball radius node 
define ball size node integer follows denote unique set nodes 
convenience greater case balls define radius maximum value 
analysis read operation analysis read operation establishing useful properties balls section 
desired upper bound expected cost individual read operation shown section 
properties balls proofs lemmas section extensive equation fact cost function symmetric satisfies triangle inequality 
consider smallest resp largest ball centered node contains resp contained subset nodes 
subset node resp denote largest resp smallest integer subset resp superset denote respectively 
lemma belong denote positive integers delta 
delta subset delta 
proof obtain lower bound 
denote radii respectively 
delta equation implies gamma 
node maximum 
ball radius gamma contained contained 
gamma 
follows gamma superset 
obtain lower bound follows jm jm delta delta place upper bound 
node maximum 
gamma 
showed gamma preceding paragraph inequality follows triangle inequality 
follows gamma subset 
jm jm delta lemma corollary section 
refer predicate depends label label predicate 
node label predicate denote node holds ii node holds 
null defined 
null 
integers denote set fk bg 
lemma examines relationship set probability distribution labels nodes node label predicate log denote string log gamma ib bits log gamma delta delta delta 
convenience denote 
pi hold 
denote pj 
defined similarly 
note nonnegative integers 
pi pj independent random variables 
predicates defined label predicate 
lemma subsets belong label predicate chosen independently uniformly random 

variables np independent uniformly random ii node fp false 

variables independent uniformly random ii node false 

variables independent uniformly random ii node fp false 
proof consider part lemma 
part follows independence distinct nodes definition holds node fp false 
proves part ii 
parts follow similarly 
part note event equivalent event node false 
part note event equivalent event node fn false 
claim follows repeated application part lemma 
corollary arbitrary subset log gamma subset independently uniformly random 
sequence nodes ui uj uj uj 
variables independent uniformly random 

variable ui uniformly random node uj false 
cost read operation section place upper bounds cost read operation establishing theorem 
introduce notation prove elementary lemmas section 
bulk analysis appears sections 
tools developed sections prove theorem section 
preliminaries consider read request originating node object denote node copy show expected cost read operation 
denotes node minimum set nodes copy preceding bound implies expected cost asymptotically optimal 
hxi hyi primary neighbor sequences respectively 
nonnegative integer ai resp di denote ball smallest radius xi resp yi contains xi resp yi 
bi resp ei denote set resp idj 
ci denote ball smallest radius xi contains secondary neighbors xi 
convenience define gamma gamma 
useful consider alternative view xi yi ai di 
nonnegative xi resp yi root node xi resp yi xi resp yi ai resp di xi resp yi 
fl integer constant satisfying equations 
nonnegative integer integer xji resp ji denote ball flj resp flj 
lambda denote integer radius lambda 
ai resp bi denote radius resp 
lemma lambda superset proof definition lambda ai 
ai superset ai contains fl nodes superset equation jm ai delta jm ai delta jx equation delta jx delta fl fl ai subset ai superset ai superset claim holds 
lemma log gamma bb log delta cai ai db eai bb log delta bi db ebi 
log gamma ai db eai bi db ebi 
ai lambda bi lambda 
proof prove bounds ai ai lambda bounds bi bi lambda follow lines 
fl equation log gamma jx bjx log gamma follows equation bb log delta cai ai db eai 
log gamma jx bjx ai db eai 
lambda ai lambda resp bi lambda db ec 
ai lambda fle ffi fl constants 
define sequences nonnegative integers follows si 
bi ai gamma ci bi ai gamma ci bi ai gamma bi gamma bi gamma gamma 
ti ei ei gamma ei gamma gamma 
intuition underlies definitions si ti 
expected sizes balls ai di expected sizes balls bi ei 
expected size ci constant depends constant fl chosen sufficiently large chosen sufficiently larger fl expected behavior balls ai bi ci ei follows bi ai gamma ci ei value si resp ti indicates degree sizes balls ai bi ci resp di ei deviate expected behavior 
larger value si greater deviation expected behavior 
lemma si xi xi ai 
ti yi yi bi 
proof proof claim follows observation si ai bi proof second claim follows observation ti di ei properties plan determining upper bound cost read operation object follows 
smallest integer lambda si ti 
definitions eo lemma implying superset copy located forwarding steps hxi 
definition primary secondary neighbors total cost messages sent node xi xi xi 
copy located forwarding steps cost messages needed locating particular copy read dc xj xj yj yj 
cost reading copy times preceding cost 
constant cost reading xj xj yj yj remainder proof concerns task showing xj xj yj yj 
key idea establish sequence hsi tii corresponds dimensional random walk biased 
lemmas provide step formalizing notion 
lemma log gamma 
sj tj si gamma probability si si gamma gamma 
sj tj ti gamma probability ti ti gamma gamma 
lemma log gamma 
sj tj si gamma probability si gamma 
sj tj ti gamma probability ti gamma 
order establish lemmas introduce additional notation 
gamma define si ti follows 
gamma gamma si 
si gamma bi ci xi si si gamma bi si si gamma bi gamma si xi gamma si 
ti ti gamma ei ti ti gamma ei gamma ti yi gamma ti 
set si resp ti contains nodes labels need examined determine values si resp ti 
show lemma particular values si ti bias distribution suffix labels nodes si ti 
lemma log gamma 
sj tj 
variables si ti independent uniformly random 

exists subset si size variables independent uniformly random ii node si false 

exists node ti variable uniformly random ii node ti fvg false 
proof prove parts gamma 
proof induction 
induction base set gamma 
part follows directly random assignment labels 
part set gamma desired claim holds gamma 
claim part holds vacuously gamma 
induction hypothesis assume parts lemma hold gamma 
consider different cases depending value si 
si event si equivalent event bi gamma gamma ai gamma 
condition event bi gamma gamma invoking corollary substitution si gamma ti gamma gamma 
condition event ai gamma invoking part lemma substitution xi gamma si gamma ti gamma bi gamma gamma 
combining part invocations variables si gamma ti gamma bi gamma gamma xi gamma independent uniformly random 
combining part ii invocations ii node bi gamma gamma xi gamma false 
set gamma bi gamma gamma xi gamma 
si event si equivalent event bi ai gamma 
condition event bi invoking corollary substitution si gamma ti gamma 
follows preceding invocation definition bi variables si gamma ti gamma bi independent uniformly random ii node bi fxi false 
set gamma bi fxi 
si event si equivalent event bi ai gamma 
condition event bi invoking corollary substitution si gamma ti gamma 
follows preceding invocation definition bi variables si gamma ti gamma bi independent uniformly random ii node bi fxi false 
equal set fv ci xi definition ci js ij 
ci ci xi follows definition ci variables si gamma ti gamma bi ci independent uniformly random ii variables independent uniformly random node bi ci false 
ci ci xi follows part lemma variables si gamma ti gamma bi xi independent uniformly random ii variables independent uniformly random node bi xi false 
obtain definition si variables si ti gamma independent uniformly random 
definitions si ti particular values si ti independent suffix node particular variables independent uniformly random 
follows preceding observation claims ii ii ii ii bits independent uniformly random node si false 
consider cases depending value ti 
ti case similar case 
event ti equivalent event ei gamma gamma di gamma 
condition event ei gamma gamma invoking corollary substitution si ti gamma gamma 
condition event di gamma invoking part lemma substitution yi gamma si ti gamma ei gamma gamma 
combining part invocations variables si ti gamma ei gamma gamma yi gamma independent uniformly random 
combining part ii invocations ii node ei gamma gamma yi gamma false 
ti case similar case 
event ti equivalent event ei invoke corollary substitution si ti gamma obtain variables si ti gamma ei independent uniformly random ii node ei false 
complete induction step consider part statement lemma separately 
definition ti follows sj tj variables si ti independent uniformly random 

part follows directly ii 

ii ii follows arbitrary values sj tj variable yi uniformly random ii node ti false 
lemma places upper bounds sizes si ti 
lemma nonnegative integer 
si si subset si subset set ti subset proof proof induction convenience set gamma induction base 
gamma gamma claims follow trivially 
claims lemma hold si gamma ti gamma 
show si proof ti lines 
induction hypothesis si gamma gamma 
fl equation gamma implying si gamma consider cases depending value si 
si bi lemma xi delta fl 
delta fl equation delta fl follows si gamma bi xi subsets si subset si bi follows si gamma bi subsets si subset si greater bi gamma si xi gamma si subset si subset lemma proof lemma 
lemma log gamma 
sk tk si gamma probability bi gamma gamma subset gamma gamma 
sk tk ti gamma probability ei gamma gamma subset gamma gamma 
proof denote event random variables sk tk take values 
assume holds 
proof claim 
si gamma bi gamma gamma subset gamma bi gamma gamma subset gamma 
part lemma follows variables si gamma ti gamma independent uniformly random 
lemma gamma ti gamma fl ib 
lemma fl delta equation xi gamma gamma gamma fl ib delta probability ai gamma gamma subset xi gamma gamma gamma gamma gamma fl delta gamma fl ib gamma fl delta gamma fl jb second step inequalities fl delta obtained equation ii gamma fl delta gamma fl delta obtained equation 
xi gamma gamma gamma subset gamma probability ai gamma gamma subset gamma gamma 
bi gamma gamma subset gamma gamma bi gamma gamma bi gamma gamma ai gamma gamma obtain bi gamma gamma subset gamma probability gamma 
proof second claim analogous proof obtained substituting 
ready prove lemmas 
proof lemma denote event random variables sj tj take values 
assume holds 
proof claim 
si gamma 
bi gamma gamma subset gamma bi gamma gamma subset gamma 
show bi gamma subset probability gamma 
invoke lemma obtain bi gamma gamma subset gamma probability gamma 
assume event bi gamma gamma subset gamma hold 
show probability bi gamma subset gamma 
follows part lemma variables si gamma ti gamma independent uniformly random 
event bi gamma gamma subset gamma variables si gamma ti gamma gamma independent uniformly random 
lemma si gamma gamma ti gamma gamma 
size set si gamma ti gamma gamma fl fl ib 
lemma fl delta equation xi gamma fl delta probability ai gamma subset xi gamma gamma gamma fl delta gamma fl gamma fl gamma fl delta gamma fl gamma fl jb second step inequalities delta fl delta fl obtained equation ii gamma fl delta gamma fl delta obtained equation 
probability bi gamma subset 
follows probability gamma si si gamma establishing claim lemma 
proof second claim analogous proof obtained substituting 
proof lemma denote event random variables sj tj take values 
assume holds 
proof claim 
si gamma bi gamma subset gamma 
si gamma lemma bi gamma subset gamma probability gamma 
assume bi gamma subset gamma 
show probability bi subset gamma 
part lemma follows variables nodes si gamma ti gamma independent uniformly random 
lemma gamma ti gamma fl ib 
lemma xi gamma delta fl equation xi fl delta probability ai subset xi gamma fl delta gamma fl gamma fl delta gamma fl gamma fl delta gamma second inequality follows inequality fl delta obtained equation 
inequality follows inequalities gamma fl delta obtained equation ii gamma holds equation 
implies probability ai subset gamma 
show probability ai superset gamma gamma 
delta fl equation lemma implies xi gamma delta fl 
lemma variables si gamma ti gamma independent uniformly random ii nodes si gamma ti gamma predicate holds 
probability ai subset xi gamma delta fl 
follows probability ai superset gamma 
show bi subset ai superset gamma probability ci superset gamma 
note events bi subset ai superset gamma variables si gamma ti gamma independent uniformly random ii exist nodes si gamma ti gamma predicate holds 
place upper bound probability ci superset placing lower bound probability ci superset xi superset resp denote xi gamma resp xi 
definition xi gamma fl 
lemma xi delta fl show nodes xi cost delta xi xi 
note xi xi difference radii gamma gamma 
xi subset xi sum radii gamma 
fl fl equation nodes xi cost delta xi xi xi 
follows probability ci superset probability exist nodes xi rightmost bits match certain bit sequence 
probability delta fl delta fl second step follows inequalities delta fl derived equation 
follows probability gamma si establishing claim lemma 
proof second claim analogous proof obtained substituting 
definitions si ti follows si si si si 
addition ti ti equal si si si gamma 
ti tig section analyze random walk corresponding sequence 
random walks analysis random walk corresponding sequence proving useful properties certain random walks line 
properties stated lemmas 
main technical claim section lemma 
directed graph set nodes set edges 
du probability distribution set convenient define 
random walk starting random sequence hvi vi vi vi ii fixed necessarily simple path ui fixed ui pr vi ui vi ui pr vi ui vi ui ui ui 
directed graph node set set nonnegative integers edge set 
subgraph induced edges ng reals define random walks graphs respectively 
node 
walk hwi characterized pr wi gamma wi integer ii pr wi wi equal iii pr wi wi gamma walk hw characterized pr gamma integer ii pr equal iii pr gamma note lemmas imply sequence represented random walk gamma gamma 
analyze random walk showing favorable respect properties interest 
random walk easier analyze exactly characterized lemmas show bias values fixed discussion omit subscript terms convenience 
lemma random walks pr wi pr 
proof prove claim induction base case trivial 
assume claim holds pr pr gamma pr gamma pr gamma pr pr wi pr wi gamma pr wi gamma pr wi gamma pr wi pr pr pr pr pr wi pr wi pr wi pr wi lemma follows induction 
establish probabilistic comparison number steps takes random walks reach node starting node zi oe random variable denoting number steps taken reach node starting node random walk oe 
lemma pr zi pr zi gamma proof induction 
base case trivial 

pr zi gamma pr zi gamma gamma gamma pr zi gamma pr zi gamma gamma gamma pr zi gamma pr zi second step follows induction hypothesis 
pr gamma gamma gamma pr gamma gamma pr gamma pr gamma gamma pr gamma pr gamma gamma pr gamma pr second step follows induction hypothesis 
pr gamma pr gamma pr gamma gamma pr gamma gamma pr gamma pr second step follows induction hypothesis 
lemma argue random variable 
stochastically dominated random variable 
lemma pr zi 
pr zi 
proof proof induction 
base case trivial 
pj pr wi gamma wi qj pr wi wi note inequalities hold pj ii iii pr zi pr zi gamma gamma gamma pr zi gamma pi pr zi gamma gamma gamma pi pr zi gamma pi pr zi gamma gamma qi pr zi gamma gamma pi gamma qi pr zi gamma pi pr zi gamma 
gamma qi pr zi 
gamma gamma pi gamma qi pr zi 
gamma pr zi 
second step holds pi ii pr zi gamma gamma pr zi gamma follows lemma 
third step holds pr zi gamma pr zi gamma lemma 
fourth equation follows induction hypothesis 
pr gamma pr gamma gamma pr gamma pr gamma gamma gamma pr gamma pr 
gamma gamma gamma pr 
gamma pr 
second step holds ii gamma gamma gamma iii pr gamma pr gamma follows lemma 
third step follows induction hypothesis 
pr gamma pr gamma gamma pr gamma gamma pr 
gamma pr 
second step holds 
third step follows induction hypothesis 
established desired claim 
show probabilistic sense time return smaller 
resp denote smallest wi resp 
note letting hwi represent terminating step lambda lambda lemma shows random variable stochastically dominated random variable lemma pr pr 
proof pr pr wi pr zk 
pr wi pr zk pr pr zk pr step follows definitions zi 
second step lemma 
third step invoke lemma invoke lemma substitution pr wi pr pr zk pi qi ni 
note conditions invocation pr zk nonincreasing follows lemma 
fourth step follows definitions zi 
lemma indicates obtain upper bound time taken random walk return deriving corresponding bound random walk 
lemma obtain upper bound length excursion 
excursion length graph node set walk starts node returns start node time wi 
random variable gives length excursion starting time note 
equals 
lemma describes probabilistic recurrence relation length excursion proved classical combinatorial result known lemma 
lemma satisfy inequality gamma gamma 
pr maxf gamma gamma pr 
proof random walk pr gamma ui gamma pr ui gamma remainder proof assume loss generality 
desired claim holds pr pr gamma 
consider 
ej denote event random walk reach node steps 
ej event nonzero 
ffj denote probability ej holds 
convenience assume ff gamma equals gamma 
obtain pr gamma delta ff gamma delta follows ratio pr pr equals ff gamma ff gamma 
remainder proof devoted obtaining upper bound ffj ffj 
fim denote probability conditions hold holds ii iii edge traversed steps 
lemma fim gamma delta gamma definitions ffj fim follows ffj bj fim delta gamma delta ffj gamma gamma bj gamma delta gamma delta ffj gamma gamma prove induction ffj ffj gamma 
induction base holds ff ff gamma 
induction hypothesis assume ffj ffj gamma gamma 
ffk ffk max ffk gamma ffk gamma gamma gamma step follows induction hypothesis 
odd ffk ffk max gamma gamma gamma gamma max gamma ffk gamma ffk gamma gamma maxf gamma gamma gamma second step follows induction hypothesis inequalities gamma gamma gamma claim lemma follows upper bound ffk ffk equation 
ready properties random walks stated lemmas analyze random walk obtained sequence 
set gamma gamma 
lemmas imply characterizes random walk corresponding sequence 
consider random walk 
define sequence hvi associated hw follows vj vj lemma log gamma 
fixed sequence gamma values probability gamma 
proof assume vj probability vi know vk integers interval 
lemma follows probability gamma 
lemma states gamma maxf gamma lower bound probability excursion length gamma starting excursion length gamma starting 
note gamma gamma equation 
fixed sequence gamma pr vi vi gamma uj gamma pr vi vj vi gamma 
holds vi pr vi gamma ui gamma gamma 
main technical claim concerning random walk follows lemmas 
lemma log gamma nonnegative integer probability proof lemma probability desired claim follows lemma 
proof theorem derive upper bounds xi xi yi yi lemma 
recall ai bi denote radii respectively lambda smallest integer ai 
lemma log gamma xi xi ai yi yi bi 
proof observe xi xi resp yi yi ak resp bk sj resp tj belongs resp exist log gamma 
lemma follows probability gamma lemma xi xi ai gamma db gamma ai yi yi bi gamma db gamma bi db equation 
lemmas establish theorem 
proof theorem equation expected cost read operation bounded expected value xi xi yi yi 
recall smallest integer lambda si ti 
upper bound terms lambda xi xi yi yi lambda xi xi yi yi separately 
lemmas term ai lambda bi lambda 
upper bound second term follows 
lambda lambda obtain lemma probability lambda lambda xi xi yi yi ai lambda bi lambda ai lambda bi lambda ai lambda bi lambda second step follows lemma 
third step holds db equation 
fourth step follows lemma analysis performance bounds establishing useful properties neighbors section 
properties derive bounds cost insert delete operations size auxiliary memory adaptability access scheme sections respectively 
properties neighbors section establish certain claims concerning different types neighbors defined section 
differentiate root nonroot primary neighbors 
root primary neighbor primary neighbor log gamma 
primary neighbor root primary neighbor nonroot primary neighbor 
note 
log gamma root primary neighbor equals node equals equals 
illustrate difference root primary neighbor nonroot primary neighbor example 
consider network nodes 
node bit label 
equal 
consider nodes labels respectively 
primary neighbor nonroot primary neighbor 
hand primary neighbor root primary neighbor 
case implies node network label rightmost bits 
note neighbor table constructed matching rightmost bits 
observe log gamma primary delta neighbor root primary neighbor 
lemma denote jm log gamma probability primary neighbor gamma delta gamma ii log probability root primary neighbor gamma proof consider ball 
equation jm jm delta superset jm delta probability node fu vg match label rightmost bits gamma log gamma probability primary neighbor gamma delta gamma gamma delta gamma root primary neighbor equals node equals equals 
probability root primary neighbor ib gamma gamma gamma ib gamma ib gamma corollary log 
primary neighbor ib log whp 
lemma corollary establish bounds number nodes primary secondary neighbor number nodes reverse neighbor respectively 
au denote total number triples belongs log belongs belongs primary secondary neighbor lemma proof theorem corollary proofs theorems 
lemma log 
number nodes ith level primary neighbor log whp 
au log au log whp 
proof node log gamma follows lemma probability root primary neighbor ib gamma node probability root log primary neighbor fix 
equal log gamma log log gamma omega constant omega term chosen sufficiently large 
consider cases 
probability exists root primary neighbor ib gamma ne gamma omega log poly probability root primary neighbor log 
follows chernoff bounds number nodes root primary neighbor log whp 
consider secondary nonroot primary neighbors 
log secondary nonroot primary neighbor nodes minimum lowest ib bits match fix set obtain upper bound probability nodes minimum ib bits match consider node real constant specified 
equals zero probability primary secondary neighbor ib 
consider ball 
low expansion condition right inequality equation jm jm delta superset 
superset obtain jm delta probability primary secondary neighbor delta gamma delta gamma ib bd delta de gamma delta gamma gamma ib bd delta gamma delta ib ib second step holds ib gamma ib gamma ib 
third step follows choosing large respect delta delta delta dd gamma delta 
expected number nodes secondary nonroot primary neighbor log nn ib log log obtain high probability bound number nodes secondary nonroot primary neighbor proceed follows 
theta log follows lemma probability secondary nonroot primary neighbor poly 
theta log probability secondary nonroot primary neighbor number nodes secondary nonroot primary neighbor log whp 
bounds expectation high probability bounds establish au log au log whp 
corollary total number reverse neighbors log whp log expected 
proof desired claim follows directly lemma reverse neighbor primary neighbor lemma proof theorem 
node provides bound number primary neighbor sequences ith position 
log said leaf exists sequence vi gamma vi vj primary vj neighbor vj 
lemma belong log 
number leaves ib log whp 
proof establish lemma showing leaf ib log whp 
corollary vj vj log whp sufficiently large real constant 
prove induction vj jb log whp 
induction base follows trivially 
induction step assume vj jb log 
corollary vj belongs vj jb log whp 
denote vj vj vj respectively 
node contained ball vj 
jm vj delta jb log equation 
jm vj jm vj delta jb log equation 
obtain vj delta jb log 
delta equation obtain vj 
applying inductive claim obtain ib log whp 
completes proof 
insert delete operations theorem follows lemmas 
proof theorem consider insert operation performed object 
expected cost operation bounded log xi xi lemmas log gamma 
consider cost delete operation 
lemma number reverse neighbors xi log whp xi ith node primary neighbor sequence expected cost delete operation executed bounded product log xi xi log 
lemma follows expected cost delete operation log 
auxiliary memory proof theorem place upper bound size neighbor table definition number primary secondary neighbors log log 
corollary number reverse neighbors log whp 
place upper bound size pointer list size ptr number triples form delta exists log leaf ii iii main memory lemma number leaves ib log whp 
probability ib 
number objects main memory node follows whp log log log 
combining bounds sizes neighbor table pointer list obtain size auxiliary memory log whp 
adaptability proof theorem lemma node number nodes primary secondary neighbor log expected log whp 
reverse neighbor log nodes log primary neighbors 
adaptability scheme log expected log whp 
extend study general classes cost functions determine tradeoffs various complexity measures 
interesting consider models allow faults network 
believe access scheme extended perform presence faults distribution control information scheme balanced nodes network 
acknowledgments authors satish rao helpful discussions 
awerbuch bartal fiat 
distributed paging general networks 
journal algorithms 
awerbuch peleg 
routing polynomial communication space tradeoff 
siam journal discrete mathematics 
awerbuch peleg 
sparse partitions 
proceedings st annual ieee symposium foundations computer science pages 
awerbuch peleg 
online tracking mobile users 
journal acm 
bartal fiat rabani 
competitive algorithms distributed data management 
proceedings th annual acm symposium theory computing pages may 
chernoff 
measure asymptotic efficiency tests hypothesis sum observations 
annals mathematical statistics 
dolev kranakis peleg 
bubbles adaptive routing scheme high speed dynamic networks 
proceedings th annual acm symposium theory computing pages may 
graham knuth patashnik 
concrete mathematics 
addison wesley reading ma 
schwartz 
locating nearby copies replicated internet servers 
proceedings acm sigcomm conference applications technologies architectures protocols computer communication pages august 
karger lehman leighton levine lewin panigrahy 
consistent hashing random trees distributed caching protocols relieving hot spots world wide web 
proceedings th annual acm symposium theory computing pages may 
karp luby meyer auf der heide 
efficient pram simulation distributed memory machine 
proceedings th annual acm symposium theory computing pages may 
leiserson 
fat trees universal networks hardware efficient supercomputing 
ieee transactions computers 
maggs meyer auf der heide :10.1.1.38.1850
exploiting locality data management systems limited bandwidth 
proceedings th annual ieee symposium foundations computer science pages october 
mullender editor 
distributed systems 
addison wesley 
mullender vit anyi 
distributed match making 
algorithmica 
plaxton rajaraman 
fast fault tolerant concurrent access shared objects 
proceedings th annual ieee symposium foundations computer science pages october 

emulate shared memory 
journal computer system sciences 

functional composition patterns power series reversion 
transactions american mathematical society 
upfal wigderson 
share memory distributed system 
journal acm 
van steen hauck tanenbaum 
model worldwide tracking distributed objects 
proceedings conference telecommunications information networking architecture tina pages september 
technical lemma lemma nonnegative integer hni sequence nonincreasing reals 
hpi hqi sequences reals pi qi ii pi qi 
proof proof induction induction basis trivial 
induction hypothesis assume statement lemma holds establish claim 
gamma gamma third step follows induction hypothesis inequalities 
note induction hypothesis invoked gamma pi qi gamma pi qi 

