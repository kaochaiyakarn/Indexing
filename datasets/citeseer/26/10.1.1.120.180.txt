presheaf models concurrency gian luca cattani ph dissertation department computer science university aarhus denmark presheaf models concurrency dissertation faculty science university aarhus partial fulfillment requirements ph degree gian luca cattani january parents gian carlo dissertation investigate presheaf models concurrent computation 
aim provide systematic treatment bisimulation wide range concurrent process calculi 
bisimilarity defined abstractly terms open maps joyal nielsen winskel 
inspired thesis suggesting presheaf categories provide models concurrency built notion bisimulation 
show presheaf categories traditional models concurrency embedded deduce congruence properties bisimulation traditional models 
key result shown homomorphisms presheaf categories colimit preserving functors preserve open map bisimulation 
follow observing presheaf categories colimit preserving functors organise considered category non deterministic domains 
presheaf models obtained solutions recursive domain equations 
investigate properties models range concurrent process calculi including ccs ccs value passing ss calculus form ccs linear process passing 
open map bisimilarity shown congruence calculus 
consequences general mathematical results preservation open map bisimulation colimit preserving functors 
case higher order calculus open map bisimulation proved coincide traditional notions bisimulation process terms 
case higher order processes obtain finer equivalence normally expect helps reveal interesting aspects relationship presheaf operational semantics 
fragment language corresponding form calculus open map bisimulation coincides applicative bisimulation 
developing suitable general theory domains extend results notions limit colimit coincidence theorem smyth plotkin case fully categorical situation 
provide domain theoretical analysis open map bisimulation presheaf categories 
fact induction coinduction principles recursive domains works pitts hermida jacobs derive coinduction property bisimulation 
vii personal debts adequately acknowledged 
am especially grateful supervisor glynn winskel 
taught research transmitted enthusiasm 
pleasure source learning discuss ideas thesis owes stimulating guidance 
leaving freedom choosing problems wished involved doing point thesis fact regarded result years joint 
shall friendship 
pino rosolini gave support ways 
guided steps researcher working di 
decided go postgraduate studies put contact suggested study glynn 
followed progresses phd student available needed help advice 
due sassone ian stark marcelo fiore 
showed friendship stimulated research 
marcelo particular influential development important part thesis chapter 
people influenced taught things advice years 
hard list wish mention mogens nielsen john power jaap van oosten alex simpson anders kock carsten butz prakash panangaden 
phd studies funded brics brics phd school 
wish brics management having chance studying aarhus generally wish brics daimi people created perfect environment foreign students greatest go wife love dedication years parents gian carlo thesis dedicated love support life 
ix contents background 
operational semantics 
denotational semantics 
models concurrency 
open map bisimulation 
presheaf models 
synopsis 
categorical background notation 
presheaf categories 
kan extensions 
fibrations 
grothendieck construction 
pseudo concepts 

open map bisimulation traditional models 
bisimulation open maps 
presheaves models 
presheaf models ccs languages general process language categorical models 
denotational semantics proc 
presheaf models proc 
grothendieck construction presheaf models 
semantic constructions groth gamma 
concrete models revisited 
refinement event structures 
xi xii contents profunctors left kan extensions coend formulae 
bicategory prof category cocont 
set theoretic analogy 
domain theoretic analogy 
structure prof 
lifting 
connected colimits 
type theory domains concurrency 
alternative exponential 
open map bisimulation prof 
examples ccs 
term language 
equation synchronisation trees 
decomposition presheaves 
transition relation presheaves 
denotational semantics 
remarks 
ccs value passing 
term language 
map models 
theory recursive domains local characterisation theorem 
coherence 
pseudo algebraic compactness 
recursive types 
examples revisited 
relational structures 
coinduction bisimulation 
covariant functors 
mixed variance functors 
open map bisimulation coinduction properties 
extensional relations 
intensional relations 
presheaf models ss calculus ss calculus 
indexing prof 
creation new names 
tensor presheaves 
equation 
contents xiii decomposition result 
transition relations presheaves indexed late bisimilarity 
constructions 
restriction 
parallel composition 
replication 
interpretation 
late vs early 
ss calculi 
higher order processes category conn 
equation higher order processes 
higher order process language 
operational semantics 
presheaf semantics 
transition relations presheaves 
constructions 
denotational semantics 
soundness result 
characterisation open map bisimulation 
applicative bisimulation recovered 
remarks 
summary 
research 
higher dimensional transition systems hdts 
higher order process languages 
metalanguage process constructors 
weak bisimulation hiding 
action calculi 
presheaves 
basic definitions enriched category theory enriched categories 
categories 
bicategories 
proofs chapter theorem 
xiv contents proofs chapter lemma substitution lemma 
theorem 
bibliography thesis aims provide systematic treatment bisimulation wide range concurrent process languages 
shall investigate called presheaf categories models concurrency built notion bisimulation purpose giving denotational semantics concurrent process languages 
offspring models concurrency see open map bisimulation :10.1.1.21.5791
operations involved semantics process languages range different models unified instances categorical constructions :10.1.1.21.5791
notion bisimulation parametrised notion observation shape computation path introduced accompany models 
shall see presheaf models semantics process languages uniformly allows prove independently specific models chosen particular language key properties bisimilarity congruence properties 
better understand significance possible impact effort unification recall briefly kind computational issues addressing main approaches semantics concurrent process languages kind problems expects face 
shall motivate bisimulation open maps approach show naturally leads consider presheaf categories models concurrency 
highlight main results brief summary content thesis 
background theory concurrency aims model analyse behaviour systems agents simultaneously active able communicate 
difficulties encounters summarised major points firstly presence different threads control may lead subtle nondeterministic unanticipated interactions various components system second concurrent systems operating systems distributed databases behaviour described reactive sense designed engage possibly endless series interactions environment 
impossible set semantic theory systems input output paradigm typical sequential computations 
fact sequential computation concurrent computation general agreement models 
different notion behaviour longer functional paradigm needed 
reasons 
concurrent systems designed non terminating continuously interacting environment semantics stimulus response patterns varying time 
patterns rest recognising existence certain atomic elements behaviour associated level abstraction description system 
central various approaches need satisfactory notion behavioural equivalence systems replace usual extensional equality functions 
equivalences bisimulation roughly relation systems matching patterns actions 
give semantics concurrent processes languages find appropriate bisimulation relation 
major approaches 
operational semantics common way give semantics programming languages terms transition relations specify term language certain state computation steps 
operational semantics syntax directed way 
consider example simple process language described syntax nil set labels stands names communication channels 
process term denote ffl deadlocked process nil 
ffl process perform input action channel process ffl process perform output action channel process ffl parallel composition processes 
ffl process depending environment may behave 
order able denote infinite non terminating processes added possibility recursive definitions process terms 
simplicity leave 
operational semantics language set rules gamma gamma ff gamma ff gamma ff gamma ff gamma ff gamma ff gamma ff gamma ff gamma gamma gamma gamma gamma gamma gamma ff fa lg fo note introduced new action symbol mark communication channels processes emitting outputs processes willing receive inputs 
symmetric relation process terms defined bisimulation satisfies property ff gamma exists process term ff gamma ff fo fa lg 
process terms said bisimilar exists bisimulation relates 
having defined bisimilarity step usually taken proving congruence respect operators language 
pattern usually followed 
unfortunately things smooth process terms complicated ones proposed example 
instance feature possibility passing channel names form values process terms 
new computational paradigms simple input output built language firewalls cardelli gordon ambient calculus 
considerably increase complexity operational semantics consequently bisimulation 
turn hard prove basic facts wants bisimilarity congruence properties 
fact starts definition operational semantics bisimulation aiming congruence result ready tune order able prove 
problem relies fact choices operational semantics bisimilarity taken ad hoc fashion 
drawback semantics syntactic models arises tries relate formally compare different models 
comparison go syntactic translations difficult find justify understand 
denotational semantics denotational semantics concurrent languages obtained enhancing usual domain theoretic tools semantics sequential programming languages constructions able capture non deterministic behaviour 
powerdomain constructions provide suitable domain new domain elements roughly subsets see 
sequential program denoted function gamma suitable domain states instance non deterministic counterpart denote function gamma small process language previous section suitable domain solving recursive domain equation 


construction adds bottom element domain pi di sum domains 
term constructors constants gamma gamma gamma nil denote endofunctions suitable arity domain terms language equated denote element domain 
guarantee relation fact coincide bisimilarity 
contrary reasons believe general case 
recursively defined terms equal denotations finite stage fixed point definitions equal denotations 
known coinductive definition bisimilarity general close way 
restricting degree branching allowed overcome deficiency 
possible way definition bisimulation overcome limitations traditional domain theory came models concurrency 
models concurrency different kinds models concurrent distributed computation studied 
concentrated understanding structure mutual relationships :10.1.1.21.5791
natural tools carrying task provided category theory 
idea turn classes models categories adding suitable notions morphisms models account possibility model simulating behaviour 
main outcomes approach 
semantics process languages different categories models unified sense shown operations denoted term constructors categorical status 
general language called ccs process calculi devised specifications minimal required properties category considered category models language 
means possible give semantics uniformly number different process calculi ccs csp sccs acp 
second possibility formally relating categories models means adjunctions adjoint pairs left adjoint full embedding category 
accounted informal understanding certain models expressive 
exemplify known classes models transitions systems synchronisation trees 
transition system set action act triple tran ffl set states 
ffl distinguished initial state 
ffl tran theta act theta transition relation 
triples tran usually written gamma 
idea action observable parts computation steps system starting evolve transition rules 
transition gamma step computation morphism tell simulate different system 
function transition system morphism tran tran transition systems 

gamma tran implies gamma tran 
resulting category write 
transition systems may loop sequences transitions gamma gamma gamma gamma delta delta delta gamma sn state reached different computations ccc cccc bbb transition systems unfolded unwinding loops duplicating states reachable different ways 
unfolding operation results labelled tree 
labelled trees synchronisation trees called call special transition systems transition graph tree 
synchronisation tree transition system embedding st act 
category st act synchronisation trees act category transition systems act 
unfolding operation results right adjoint left inverse unfolding tree returns tree 
kinds formally precise relationship seeking hope able deduce general properties models uniformity compositional semantics languages different models 
theoretical impact practical issues 
example unfolding result analogous sketched petri nets event structures studied purpose model checking algorithms petri nets 
analysis accounted structure process terms 
behavioural equivalences 
way representing bisimilarity abstractly models 
proposed answer came adopting notion open map originally developed joyal moerdijk topos theoretic purposes context models concurrency 
open map bisimulation morphisms category models understood kinds functional simulations 
natural ask oneself possible distinguish functional simulations fact bisimulations 
example 
consider transition systems set labels act tran tran 
morphism second 
words said function sets states gamma tran gamma tran 
morphism said zig zag morphism satisfies property reachable state label act gamma tran gamma tran words preserves reflects reachable transitions 
takes moments reflection see zig zag morphism graph bisimulation transition systems 
suppose sequence transitions oe ao gamma gamma gamma gamma morphism induces simulating sequence oe ao gamma gamma gamma gamma zig zag extension oe extra transition gamma oe extended sequence ao gamma gamma gamma gamma gamma chosen 
abstracting away finite sequences transitions thought computation shapes observe system morphism oe computation shape transition system computation shape oe observed motivates definition 
category subcategory 
morphism open map satisfies path lifting property commuting square fflffl morphism exists morphism gamma splitting square commutative triangles fflffl definition understood intuitively follows 
recall gives way simulate behaviour 
computation shape describes computation shape 
simulated hand extends computation shape extends pf square commutes qm 
condition tells open able match extension level reason upper triangle commutes consistent computation simulation reason lower triangle commutes 
name open map inherited joyal moerdijk 
define axiomatically classes open maps toposes 
shall see section main example class example terms path lifting property definition 
open maps account functional bisimulation wants express possible bisimulations defines models open map bisimilar connected span open maps eee studied categories models transition systems synchronisation trees event structures choice corresponding path categories natural shown notion bisimulation gets coincides existing ones 
instance example transition systems full subcategory finite transition systems transition graph branch non looping equivalent act lambda partial order finite words act regarded category 
categories models notion bisimulation parameterised choice suitable category computation path shapes path category shall call thesis 
freedom choice path category principle bears particular relationship category subcategories 
extreme examples choosing empty category obtains objects bisimilar choosing isomorphic objects related 
concrete examples transition systems certain path categories immediately suggest natural choices see general expect happen 
problem related proving abstractly properties bisimilarity notably congruence respect term constructors language 
prove results disciplined way providing models path categories needed 
presheaf models important class categories equipped canonical choice path category 
called presheaf categories 
small category category presheaves bc category contravariant functors op set set category sets functions natural transformations 
presheaves central concept category theory especially topos theory 
crucial category bc concrete representation free colimit completion bc extends colimit preserving functor bc category colimits uniquely isomorphism determined action means cocomplete category functor exists unique natural isomorphism functor 
bc preserves colimits triangle yc mmmm mmmm bc 
commute yc known yoneda embedding 
shall property repeatedly thesis 
inclusion bc provided yoneda embedding functor open maps point view bc canonical choice path category 
important example example class open maps sense 
declared map bc open arrow associated naturality square fd fflffl fc fflffl quasi pullback 
shall recall chapter condition yoneda lemma easily seen equivalent path lifting property definition previous section 
observed presheaf categories appropriate path categories fully faithfully embed equivalent traditional categories models embeddings preserve reflect open map bisimulation 
suggested look presheaves categorical models concurrent computation built notion bisimulation 
intuitive reasons considering presheaf categories models concurrency 
objects small category thought finite deterministic computations generate non deterministic possibly infinite processes 
wants add possibility choosing different possible computations adds coproducts category joining computations supposed agree choice branching taken corresponds adding 
altogether adding known result category theory colimits size added coproducts non deterministic choices unbounded adding colimits 
possibility embedding traditional models presheaf categories hope able rich categorical structure presheaves prove properties colimits small diagrams 
open map bisimulation transferred traditional models 
realised category correctly speaking category presheaf categories colimit preserving functors possesses features lead considered category non deterministic domains elements replaced presheaves usual information order replaced detailed natural transformations presheaves 
way building presheaf models concurrent process calculi domain theoretical lines viable 
idea presheaf models concurrent process calculi obtained solving appropriate domain equations path category 
instance lifting construction meaning strict new initial object added represent requirement certain action represented observed observation 
connection prefixing evident instance process language modelled synchronisation trees set act def fo fa lg presheaf model bp solution 


act 
solution equation fact provided partial order act nonempty finite words act regarded category equivalence categories st act act open map bisimulation case corresponds park milner bisimulation 
intuitions precise sense needs develop suitably general theory domains 
axiomatic approach theory domains paves way :10.1.1.17.9542
defines axiomatically classes categories thought categories domains generally order enriched ones axioms guaranteed provide uniform solution recursive domain equations 
perspective presheaf categories thought categories non deterministic domains operation forming presheaf category analogous powerdomain construction 
thesis builds hopes intuitions presheaves 
analyse properties presheaf categories colimit preserving functors 
prove open map bisimulation preserved kinds functors leads congruence results bisimilarity semantics ccs process languages 
develop general theory domains appropriate needs test method non trivial examples process languages ranging ccs ss calculus process passing calculus 
theory developed study open map bisimulation domain theoretical perspective provide knowledge domain theoretic characterisation bisimulation arbitrary trees 
thesis aim reconcile semantics concurrency domain theory 
models possess bisimulation come automatically equipped congruence properties 
synopsis chapters provide background material 
chapter assuming basic knowledge category theory say level adjunctions limits introduces key categorical concepts thesis 
appendix companion chapter provides basic definitions enriched category theory 
chapter essentially summarises definitions results notion open map bisimulation introduced 
definition known categories models concurrency including transition systems synchronisation trees event structures recalled 
original contributions thesis start chapter 
refine axiomatisation categorical models proc general ccs language implicitly extra logical assumptions :10.1.1.21.5791
define presheaf models proc show satisfy axiomatisation 
main highlight chapter proposition proof postponed chapter asserts colimit preserving functors presheaf categories preserve open maps 
reason possible prove presheaf models open map bisimulation congruence respect interpretation operators proc 
result re prove strong history preserving bisimulation event structures congruence 
show refinement functor particular presheaf model extends event structures obtained colimit preserving functor coincides event structures refinement proposed entails strong history preserving bisimulation preserved refinement 
results chapter announced joint glynn winskel appeared proceedings csl 
chapter devoted study bicategory prof profunctors equivalently category cocont presheaf categories colimit preserving functors natural transformations 
explicit categorical folklore prof failing compact closed category just fails category 
known compact closed categories provide degenerate models classical linear logic 
exponentiation pseudo functor provided purpose 
particular way exponential built suggests analogies presheaves powerdomains prof categories non deterministic domains 
technically simple important notion lifting category introduced allows represent prof connected colimit preserving functors presheaf categories 
largest class non trivial functors presheaf categories proved preserve open map bisimulation 
class include functors needed modelling linear process calculi 
summarise investigation structure prof define linear type theory extended lifting interpret 
extended chapter recursive types 
prove full detail horizontal composition open cells open 
entails immediately corollaries colimit preserving functors connected colimit preserving functors preserve open map bisimulation announced earlier 
chapter gives reader break categorical issues provides examples prof category domains deduce presheaf models process calculi 
rework usual synchronisation tree semantics ccs new setting 
recall said category synchronisation trees fixed set labels act fact equivalent presheaf category precisely category presheaves act partial order regarded category finite non empty words act prefix ordering 
second example borrow provide presheaf model form ccs value passing late early semantics 
chapter generalise classical results solution recursive domain equation order enriched case general class categories 
generalisation proceeds directions 
consider adjoint pairs embedding projection pairs 
follows established categorical folklore 

move order enriched categories categories hom categories colimits chains 

consider pseudo limits called bilimits enriched ones 
pay effort general theory domains specialises order enriched case usual 
pseudo version basic lemma considered allows construction solutions recursive domain equations colimits standard chain iterations 
having axiomatic treatment mind pseudo version freyd notions algebraic completeness compactness developed building thesis fiore class categories axiomatically provable pseudo algebraically compact devised :10.1.1.17.9542:10.1.1.17.9542
surprisingly cocont belongs class 
allows extend type theory chapter recursive types formalising intuition cocont category domains 
results provide domain theoretical understanding open map bisimulation means relational structures induction coinduction principles recursively defined domains 
particular define notion intensional relation cocont give domain theoretical characterisation strong bisimulation arbitrary trees 
results chapter part joint marcelo fiore glynn winskel appeared proceedings lics 
chapter tackles task providing presheaf models name passing calculi 
example ss calculus 
bicategory prof indexed category name sets 
model late ss calculus proved processes free names certain set open map bisimilarity fibre coincide late bisimulation open map bisimilarity substitution free names coincide largest congruence included late bisimilarity 
model ss calculus early bisimulation sketched arrow prof maps late interpretation early 
chapter joint ian stark glynn winskel appeared proceedings ctcs 
chapter shows state knowledge far modelling higher order process calculi presheaves concerned part ongoing research 
denotational model linear higher order process language fixed set channels deducible previous chapters 
comes equipped notion bisimulation proof bisimulation congruence respect term constructors 
difficulty reading operational understanding bisimulation 
elements presheaves elements sets pop set presheaf play essential role characterising bisimulation higher order processes abstractions 
bisimulation abstractions characterised pointwise behaviour fact bisimilar inputs mapped bisimilar outputs requires uniformity constraint respect input 
essential trace presheaf elements related instances observation different inputs 
lack proof elements correspond derivation trees operational semantics 
characterise bisimulation operationally led decorate transition arrows expressions account derivation tree allowed transition 
unfortunately see read functorial action presheaf denotations notation derivations 
prove results substitution lemma asserting substitution language amounts application model stability property open terms helps simplify characterisation open map bisimulation 
sub calculus higher order calculus corresponds calculus absence non determinism distinctions derivation trees vacuous 
case open map bisimulation corresponds applicative bisimulation 
chapter concludes thesis gives pointers related possible 
chapter categorical background review chapter concepts category theory need sequel covered important development needs recalled explicitly anyway 
order fix notation subsequent development 
deal chapter quite scattered manner presheaf categories kan extensions fibrations 
bicategories categories shall play important role starting chapter 
proper notions size introductory chapter growing 
knowledgeable reader shall say things concerning terminology decided adopt refer literature definitions concepts 
primer guide reported basic definitions appendix notation shall write indicate small categories categories collection arrows set 
shall write larger categories 
particular consider thesis mainly locally small categories 
mean categories collection objects class objects corresponding hom collection set 
shall write set locally small category sets functions cat locally small category small categories functors 
categories write cat category functors shall write cat cat known small natural transformations functors 
generally shall write cat category locally small categories functors 
functors natural transformation ff indicated general dotted arrow notation ff gamma considering categories functors natural transformations cat op set dot disappear 
natural transformations play role cells category indicated double arrow notation ff chapter 
categorical background important category set lambda category sets partial maps 
arrows set lambda normally indicated notation avoid confusion product sets say objects set lambda indicated theta lambda 
categories bicategories shall employ notation category underlying category objects cells cat stand category small categories functors natural transformations category small categories functors 
context disambiguate possible confusion 
presheaf categories presheaves central notion thesis built 
definition presheaf categories small category define locally small category presheaves bc category contravariant endofunctors set natural transformations 
objects bc functors op set arrows natural transformations functors 
initial object say presheaf rooted singleton set initial object write full subcategory bc rooted presheaves 
observe category rooted presheaves equivalent category presheaves full subcategory consisting initial objects 
presheaf categories important category theory reasons 
hand provide examples grothendieck toposes trivial topologies better grothendieck topos reflective subcategory presheaf category 
hand presheaf constructions yields explicit description free completion small category small colimits 
mainly concerned second way looking presheaf categories occasionally refer topos theoretic concepts terminology 
definition proposition yoneda embedding small category define yoneda embedding functor gamma bc gamma 
ffi gamma gamma presheaves isomorphic yc called 
yoneda embedding full faithful functor 
proposition yoneda lemma small category 
presheaf exists bijection bc bc yc 
presheaf categories natural functor naturally isomorphic yc gamma 
yoneda lemma identify elements presheaf corresponding natural transformation yc gamma state property asserting bc free colimit completion proposition small category 
cocomplete category category small colimits functor 
bc cocomplete exists unique natural isomorphism colimit preserving functor 
yc yc bc proposition important results category theory 
reader look proof 
notation ffl shall indicate empty set symbol initial presheaf presheaf category presheaf maps object empty set 
ffl bc bd colimit preserving functor say 
write cocont category functors bc andb natural transformations 
freeness property described yields proposition 
proposition category cat bd equivalent cocont small categories presheaf categories just cocomplete categories provide examples grothendieck toposes 
proposition small category category bc grothendieck topos bc cartesian closed complete cocomplete sub object classifier 
far concerned thesis main properties bc shall need associated completeness 
going back freeness property calculation see instance pages things inverse order shows functor 
proposition right adjoint lambda restricting hom sets range images objects lambda gamma 
chapter extensive instances functor lambda deserve special terminology 
definition canonical functors locally small category 
small 
define canonical functor bc chapter 
categorical background cf bc cf gamma bc gamma 
ffi gamma gamma embedding 
write cm cf recall functor dense object canonical colimit objects colim gamma proposition situation definition cf full faithful dense 
case functor just inclusion categories talk canonical embedding cm 
functor cf known preserve limits exist contrary cf general preserves colimits colimits certain diagrams preserved proposition shall need section shows 
proposition locally small category small category functor 
delta functor small category satisfying property density respect delta colimiting cone delta exists delta ffl 
ffl factorisation delta www wwww ww exists delta delta cf colim cf delta proposition statement replace condition saying connected chain spans gamma gamma delta delta delta mn gamma dn details density proposition pages 

presheaf categories pi pi delta di gamma mi odd gamma pi gamma odd gamma pi case functor small categories extension 
bc bd functor yd right adjoint lambda right adjoint lambda 
property left adjoints imply lambda preserves colimits seen extension cf triple adjoint functors 
lambda lambda presheaf categories example called essential geometric morphism topos theoretic jargon 
natural question essential geometric morphism presheaf categories arises functor underlying base categories 
answer modulo morita equivalence 
definition morita equivalence small categories said morita equivalent give rise equivalent presheaf categories 
morita equivalent small categories equivalent cauchy completions 
definition cauchy complete categories category said cauchy complete idempotent arrow splits ee exists pi pi case says retract example 
set cauchy complete 

presheaf category cauchy complete 

concerning small categories easy see partial order category cauchy complete 
example category poml pomsets set labels cf 
chapter 
proposition small category completed cauchy complete small 
proof simply indicate cauchy completion category 
small category consider full subcategory bc retracts 
cauchy completion said small categories equivalent cauchy completion morita equivalent 
proposition small category morita equivalent cauchy completion 
chapter 
categorical background go back original problem characterising essential geometric morphisms presheaf categories 
proposition categories 
equivalence categories cat bc bd essential geometric morphisms objects natural transformations leftmost adjoints arrows 
shall employ proposition chapter 
conclude section recalling category elements presheaf construction accounts density yoneda embedding 
definition category elements small category 
bc define category elements el consists ffl objects pairs hc xi theta ffl arrows hc xi hc arrow el arrow obvious projection functor ss el takes pair component identity arrows 
observe yoneda lemma category elements equivalent category yc objects arrows yc bc arrows arrows yc cf 
proposition 
proposition density yoneda small category 
bc naturally isomorphic colim el ss gamma gamma bc kan extensions situation described proposition functor 
bc extending third yc instance general notion left kan extension 
kan extensions places mainly dealing presheaf categories give brief notion 
definition kan extensions gamma gamma span functors says pair ff left kan extension ffl functor ffl ff gamma hf natural transformation satisfying universal property pair fi fi gamma kf exists unique fl gamma fi flf delta ff 
usual abuse language address functor left kan extension write indicate 

fibrations note triangle mmmm mmmm need commute natural isomorphism 
happens cases interest 
proposition full faithful ff exists ff natural isomorphism 
cocomplete small exists computed pointwise see vol 

objects colimit colim el gamma ss gamma gamma return chapter 
example previous section saw functor small category cocomplete category extended colimit preserving functor bc functor left kan extension yoneda embedding yc 
yd lambda cf lambda yd 
left kan extensions compose proposition ff left kan extension gamma gamma fi left kan extension gamma gamma fi delta ff left kan extension sake completeness mention existence dual notion right kan extension definition definition directions natural transformations involved reversed 
deal particularly right kan extensions thesis 
fibrations indexing structures play fundamental role categorical analysis models concurrency :10.1.1.21.5791
context categorical models ccs languages consider presheaf categories indexed category labelling sets 
tight correspondence indexed categories fibrations represent class fibrations definite coherent choice cleavage 
introduce section basic terminology fibred category theory pointers related notion elementary existential doctrine presheaf models chapter example 
chapter 
categorical background definition cartesian arrows ss functor 
arrow cartesian respect ss arrow ss fi ss exists unique ss ff ss ff ss fi ss definition fibrations functor ss fibration fi ss exists cartesian arrow codomain ss fi 
arrow called cartesian lifting respect fi 
definition ss functor arrow said vertical ss said horizontal 
definition ss functor object define fibre respect ss subcategory eb objects arrows ss ss idb 
example presheaf presheaf category bc projection functor el ss gamma fibration 
fact called discrete fibration object fibre discrete category category arrows identity ones 
ss fibration choice cartesian arrows induces cartesian lifting functors fibres proposition cartesian lifting functors ss fibration 
fi arrow object eb fi lambda fi lambda chosen cartesian lifting respect fi 
choice induces cartesian lifting functors fi lambda eb eb ffl objects 
fi lambda chosen ffl arrows 
fi lambda defined unique arrow square commutes fi lambda fi lambda fi lambda fflffl lambda fi lambda choice cartesian arrows fibration called cleavage fibration chosen cleavage called fibration 
choice cleavage functorial 
fibrations lambda ff gamma fi gamma lambda ff lambda fi lambda fibration said split 
extensive dual notion cofibration definition functor ss cofibration dual functor eop bop fibration 
functor fibration cofibration called bifibration 
dually talks cocartesian arrows cocartesian liftings cocartesian lifting functors 
grothendieck construction fibrations equivalent indexed categories fact indexed category gives rise construction due grothendieck fibration vice versa fibration induces indexed category 
definition indexed categories category 
indexed category cat pseudo functor bop cat associates object category arrow fi functor fi lambda natural isomorphisms gamma 
lambda ff fi ff lambda fi lambda gamma 
lambda arrows ff gamma fi gamma satisfying coherence conditions commutativity diagrams ff lambda lambda ff pp ff lambda ff lambda oo ff lambda ff lambda fflffl lambda ff lambda ff ff lambda ff lambda fi lambda fl lambda ff fi fl lambda ff lambda fi fl fflffl lambda fl lambda fl fflffl ff lambda lambda ff lambda fl arrow fl 
definition proposition grothendieck construction indexed category bop cat define category groth ffl objects pairs hc bi ffl arrows pair hf fii arrow hc hc bi fi arrow fi arrow 
hf ffi hc hc see example precise account statement 
chapter summarise basic notions category theory 
include general definition pseudo functor categories 
chapter 
categorical background hg fii hc hc bi composite pair hh arrow gamma ff ff gamma ff fi ff fi gamma coherence conditions definition ensure associativity composition 
obvious projection ss groth projects pair second component fibration 
cartesian lifting hc bi respect fi pair fi fii 
category elements construction definition example application grothendieck construction cf 
example 
main example bifibration lawvere elementary existential doctrine categories attributes presheaf categories 
naturally consider conditions top fibrations 
definition bop cat pseudo functor 
fi arrow write fi lambda fi 
suppose fi fi lambda left adjoint fi 
ffl beck chevalley condition say satisfy beck chevalley condition pullback square fflffl ff fflffl fi fflffl ff fflffl fi ff monic square commutes natural isomorphism ff 
fflffl fi lambda oo ff 
fflffl fi lambda oo ffl fr reciprocity law suppose binary products 
say satisfies fr reciprocity law fi square commutes natural isomorphism fi fflffl fi 
fflffl fi lambda theta gamma oo fi 
fflffl theta gamma oo section listing facts fibrations indexed categories shall 

fibrations proposition bop cat pseudo functor satisfying condition monic arrow fi ae fi lambda fi 
satisfies fr reciprocity law monic arrow fi ae functor fi 
preserves products 
proof statement observe fi mono diagram pullback fflffl fi fflffl fi beck chevalley condition fi lambda fi 
lambda 
lambda naturally isomorphic pb fi lambda fi 
pb second objects fi theta fi fi lambda fi theta property fi theta fi fr reciprocity law result prove proposition chapter prove congruence bisimulation respect product 
need lemma 
lemma bop cat pseudo functor satisfying condition fr reciprocity law 
square pullback monomorphisms fi fflffl ff fflffl fl ffi objects ffi ffi lambda fl fl lambda theta ffi ff ff lambda ffi lambda theta proof theta ffi ffi lambda theta hypothesis ffi ffi lambda theta ffi lambda fr ffi ffi lambda theta ffi ffi lambda proposition theta ffi ffi lambda hypothesis theta ffi ffi lambda fl fl lambda hypothesis theta ffi ff fi lambda fl lambda beck chevalley theta ffi ff ff lambda ffi lambda ffi ff ff lambda ffi lambda theta ff lambda ffi lambda fr ffi ff ff lambda ffi lambda theta ff lambda ffi lambda right adjoints 
chapter 
categorical background proposition bop cat pseudo functor satisfying beck chevalley condition fr reciprocity law 
diagram ssb oo oo oo oo oo oo limiting cone object isomorphism lambda theta lambda ss lambda ai theta ss lambda proof observe limit diagram ssb oo oo oo oo obtained pullbacks limiting cone constructed follows ssb delta gg ffi ffiffiffi ffiffiffi ffiffiffi ffiffi ssd delta ww fl ww sse mmmm mmmm oo oo oo oo vv ff vv 
hh fi hhii iii iii iii iii quadrilaterals diagram pullbacks 
loss generality assume 
deduce natural isomorphism ffi ffi lambda ss lambda ai 
ffi ffi lambda ffi ss lambda beck chevalley ffi ss lambda proposition ss lambda ai 
beck chevalley 

pseudo concepts similarly deduces fl fl lambda ss lambda 
ss lambda 
ss lambda ai theta ss lambda ffi ff ff lambda ffi lambda ss lambda ai theta ss lambda lemma ff lambda ffi lambda ss lambda ai theta ff lambda ffi lambda ss lambda ff lambda ffi lambda ffi ss lambda dx theta ff lambda ff fi lambda ss lambda ey beck chevalley ff lambda ss lambda dx theta fi lambda ss lambda ey proposition lambda theta lambda proposition ss fibration cofibration 
delta class diagram shapes class categories 
suppose object fibre eb limits colimits diagrams shape ffi ffi delta suppose limits colimits diagrams shape ffi ffi delta 
limits colimits diagrams shape ffi ffi delta proof simply give description build limiting cone diagram shape ffi delta ffi functor 
consider ssf ffi assumption exists limiting cone ssf lim ssf ffi fid ssf corresponding edge cone 
fi lambda fi lambda family cartesian arrows 
family induces functor fi lambda gamma ffi eb 
assumption exists limiting cone functor 
fd fi lambda cone post composing corresponding cartesian arrows obtains limiting cone fi lambda fd pseudo concepts mentioned chapter categories bicategories play role thesis especially chapter 
space chapter small reasonably full concepts shall need avoid attempt altogether 
relevant bibliographic supplied section 
small set definitions reported appendix meant essentially fix notation terminology shall thesis 
roughly category category collection arrows objects organises category arrows called cells 
typical examples locally ordered categories rel category sets relations relations sets ordered inclusion order cpo category cpo continuous functions ordered pointwise ordering 
non locally ordered paradigmatic example cat category small categories functors natural transformations 
presence extra structure allows reproduce general category essentially categorical concepts adjoint pairs equivalences particular objects different notion equality categories usual isomorphism cells consider chapter 
categorical background strict notion equivalence 
similarly limits taken isomorphism equivalence categorical properties right notion 
shall interested call pseudo limits dually pseudo colimits 
illustrative example change perspective give explicitly definition pseudo initial object 
definition pseudo initial object object category object equivalent category object morphism 
words initial object exists arrow pair arrows exists unique cell ff pseudo limits just ordinary limits definition terms representability objects functors range set cat 
shall avoid presentation just spell elementary terms conditions suitably enriched cone pseudo limiting 
knowledgeable reader notice small clash terminology pseudo prefix finds literature 
pseudo functors shall talk pseudo natural transformations pseudo limits colimits notably called strong transformations bilimits limits colimits prefix pseudo stricter notion 
said presheaf categories kan extensions 
notion category theory introduced shall occasional remainder thesis 
despite large number involving fibrations knowledge text book available 
valuable paul taylor notes course peter johnstone 
phd theses contains reasonable introductions expand said 
discussion relevance fibred category theory category theory mathematics look 
fr reciprocity law beck chevalley condition introduced instance 
note beck chevalley respect pullback diagrams base categories times respect pullbacks monomorphisms 
kelly book provides excellent enriched categories kelly street gray deal pseudo bi categorical concepts 
bicategories introduced 
street contains definitions results pseudo limits bilimits jargon bicategories 
borceux covers material enriched concepts 
chapter open map bisimulation chapter mainly summarise definitions results notion open map bisimulation defined 
refer relevant part thesis detailed discussion rationale notion bisimulation 
chapter recall definitions basic categories models concurrency extensively studied past years :10.1.1.21.5791
include categories labelled transition systems synchronisation trees event structures 
traditional models transition system structure tran ffl set states initial state ffl set labels ffl tran theta theta transition relation 
usually transition written gamma 
tran tran transition systems 
morphism pair oe ffl oe oe ffl partial function satisfy tran defined oe oe tran tran undefined oe oe chapter 
open map bisimulation synchronisation tree transition system transition graph form tree root initial state 
definition categories st define category objects transition systems arrows transition systems morphisms 
composition arrows defined componentwise 
define st full subcategory synchronisation trees 
transition systems synchronisation trees called interleaving models represent parallel concurrent composition nondeterministically interleaving actions processes 
contrast event structures represent class independence models petri nets concurrency represented directly form causal independence 
define labelled event structure structure con consisting set events partially ordered causal dependency relation consistency relation con consisting finite subsets events labelling function satisfy fe finite feg con con con con feg con events subsets events said concurrent causally independent iff fe con set events said configuration downwards closed consistent finite con 
morphism event structures consists con con event structures partial function events partial function labelling sets ffi ffi ii configuration jx configuration images defined 
definition category event structures define es category objects event structures arrows event structures morphisms 
composition arrows defined componentwise 

bisimulation open maps definition morphism event structures abruptly see motivation :10.1.1.21.5791
categories st es related inclusion functor st 
right adjoint unfolding transition systems trees functor st es identifying synchronisation tree event structure right adjoint event structure synchronisation tree 
inspired analysis axiomatise chapter notion categorical model general ccs language :10.1.1.21.5791
role played adjunctions relating semantics different categories models apparent point 
saw definitions morphism objects defined categories consists components second partial relabelling function 
immediately clear existence forgetful functors pm set lambda fst es sg set lambda category sets partial functions 
proposition implicit functors pt set lambda pst st set lambda :10.1.1.21.5791
functor pes es set lambda cofibration exist cartesian liftings monomorphisms 
described see chapter considering categories models fibred set lambda crucial step description operations associated relabelling restriction semantics ccs languages :10.1.1.21.5791
bisimulation open maps move describing characterisation bisimulation relations open maps 
need model idea computation paths 
instance computation path transition system labelling set reasonably taken finite sequence transitions transition system perform 
takes shape string labels definition finite strings partial order category set 
define lambda partial order category objects finite strings order relation saying string string initial prefix 
convenient identify strings lambda equivalent subcategory st consisting special synchronisation trees consisting finite single branch 
take account added independence structure event structures shape computation paths taken finite pomset 
definition labelled pomsets set 
category poml taken subcategory esl labelling set consisting finite event structures subsets events consistency relation 
words objects poml triples finite set partial order function 
morphism poml injective chapter 
open map bisimulation function preserve labelling send downward closed sets downward closed sets obtain general definition bisimulation open maps roughly speaking morphisms property extension computation path range matched extension domain 
definition open maps assume category models choice path category subcategory 
consisting path objects morphisms expressing extended 
arrow say open map morphism square fflffl commutes ffi ffi meaning path ffi extended path necessarily unique morphism diagram fflffl triangles commute ffi ffi meaning path extended path matches objects said bisimilar iff span open morphisms eee immediate consequence definition 
proposition category subcategory isomorphism open 
isomorphic objects open bisimilar 
case traditional models obtain known equivalences 
st lambda bisimulation coincides park milner strong bisimulation event structures esl poml bisimulation coincides strong history preserving bisimulation due refining ideas van glabbeek goltz 
theorem theorem theorem ffl transition systems synchronisation trees labelling set lambda bisimilar iff strongly bisimilar sense ffl event structures labelling sets poml open bisimilar strong history preserving bisimilar defined section 

bisimulation open maps observe definition open map bisimulation necessarily induce open map bisimilar equivalence relation 
assumption category models particular category order support composition relations normally required pullbacks 
fact category pullbacks possible define bicategory spans generalised relations spn consists ffl objects objects ffl arrows spans arrows arrow span gamma gamma 
ffl cells span gamma gamma span gamma gamma cell second arrow fi 
composition arrows horizontal composition cells rely pullbacks exist order defined 
spans open maps represent particular relations models viz 
bisimulation relations 
case composed pullbacks open map bisimilar equivalence relation objects category proposition proposition pullbacks open morphisms 
open map theta fflffl pullback square open 
products product open morphisms open 
proposition joyal moerdijk suppose products 
open maps 
theta theta theta open 
proof suppose square commutes fflffl theta theta theta need find theta rm theta universality product theta uniquely determined arrows chapter 
open map bisimulation 
consider commutative diagrams fflffl theta theta fflffl ssm theta ssn fflffl theta theta fflffl ssm theta ssn openness exist rim hr rm hr im hr mi ssm pi ssm ip theta hf ssm ssm ir hf ssm ssm ri hf ssn qi steps justified properties ri universal property products 
presheaves models notion open map originally developed applied pre topos 
key example definition small category 
presheaves arrow bc viz 
natural transformation 
say open naturality square quasi pullback set 
means open arrow square fc fflffl fc fflffl 
bisimulation open maps functions quasi pullback fc exists fc difficult see yoneda lemma condition definition equivalent path lifting property proposition small category 
arrow bc open arrow arrows bc square fflffl commutes exists arrow ky category small subcategory path objects possible compare notions open maps canonical functor cm bp cf 
definition 
proposition proposition small dense full subcategory morphism open cm gamma gamma open sense definition 
bisimulation bp related care needed 
fact bp unique arrow initial presheaf presheaf open 
natural way remove anomaly require definition open map bisimulation extra surjectivity condition 
definition open map bisimulation presheaves category 
say presheaves open bisimilar connected span open maps 
presheaf categories epimorphisms natural transformations pointwise surjective reminder shall word surjective synonym 
initial object full subcategory initial objects removed said category rooted presheaves equivalent cp 
particular open maps correspond surjective open maps cp 
immediately see full subcategory rooted presheaves cl lambda equivalent category st turn isomorphic presheaf category cl objects non empty finite strings elements canonical functor esl poml yields rooted presheaf rooted chapter 
open map bisimulation presheaves poml obtained way 
full subcategories rooted presheaves play important role approach 
bisimulation subcategories rooted presheaves coincides bisimulation categories concrete models proposition joyal nielsen winskel synchronisation trees labelling set lambda bisimilar strong bisimilar iff corresponding presheaves canonical embedding related span open maps full subcategory rooted presheaves cl lambda 
ii event structures labelling set poml bisimilar strong bisimilar iff corresponding presheaves canonical embedding related span open maps full subcategory rooted presheaves poml 
established link categories models categories presheaves appropriate path categories 
look general constructions preserve openness bisimulation model process constructions 
left kan extensions right adjoints 
concluding chapter just add simple property straightforward verification canonical embeddings cst cesl shall need chapter 
proposition canonical embeddings cst cesl defined categories rooted presheaves lambda poml preserve coproducts initial objects 
chapter presheaf models ccs languages prompted results proposition chapter take suggestion considering presheaf models concurrent computation 
preliminary stage reasons doing 
reason passes barrier presheaves intuitively appealing model nondeterministic computation 
starting category path objects observations morphisms stand extension path nondeterministic computations represented essentially gluing computation paths manner reminiscent way powerdomain built domain completion finite elements 
accurately saw chapter forming presheaves equivalent adjoining colimits category corresponds just adding directed colimits reason nondeterministic branching introduced 
argued presheaf models promising generalisations existing models fact hand known models synchronisation trees labelled event structures embed fully faithfully appropriate presheaf categories hand general reasons presheaves support operations coming kan extensions cf 
section 
particular kan extension resulting functor presheaves pomsets advanced candidate operation refinement kind proposed event structures 
section shown kan extension acts restricted presheaves associated event structures way refinement operation 
generally working level abstraction yields possibility achieving general congruence results proposition show broad class operations obtained left kan extensions automatically preserve open maps 
interesting specialise concrete cases transfer congruence properties traditional models synchronisation trees event structures 
particular instance specialise show refinement obtained kan extension preserves open maps bisimulation 
chapter 
presheaf models ccs languages general process language categorical models section introduce process language proc template called ccs languages :10.1.1.21.5791
distinctive feature proc parallel composition operator removed favour general product different definitions parallel compositions constructed help restriction relabelling operations 
noted terms proc interpreted categories labelled structures transition systems event structures convenient regard categories fibred labelling system category set lambda sets partial maps :10.1.1.21.5791
doing fact easy recover universal content operators associated restriction relabelling certain extent prefixing terms cartesian liftings 
assume universe labels class elements set define terms proc grammar nil phi theta lambda tf xi rec label lambda set labels xi total function labels labels variable drawn distinguished infinite set indicate ars 
analysis categorical status operations involved semantics proc conducted :10.1.1.21.5791
inspired propose axiomatisation structure required category give model language 
particular emphasise role partial relabelling functions substitution operators impose fr reciprocity law beck chevalley condition introduced chapter definition models proc categorical model proc functor ss set lambda ffl binary products theta 
ffl set fibre ml initial object binary coproducts colimits chains 
ffl inclusion 
sets exists cartesian lifting functor lambda mm ml 
ffl total function exists cocartesian lifting functor 
ml mm ffl set label exists prefixing endofunctor ml ml preserves colimits existing cocartesian lifting functors partial maps defined partial map defined 
exists square commutes natural isomorphism ml 
fflffl ml 
pref mm 
general process language categorical models ffl applicable required cartesian arrows exist fr reciprocity law beck chevalley condition definition hold 
models considered ranging interleaving ones transition systems synchronisation trees non interleaving ones event structures petri nets transition systems independence :10.1.1.21.5791
recall briefly structure required definition give semantics terms proc deduce properties models 
fact model proc described definition cofibration cocartesian liftings deduce corollary proof proposition corollary ss set lambda model proc initial object binary coproducts colimits chains 
denotational semantics proc giving semantics proc terms categorical model introduce operation phi model non deterministic sum 
shall see contrasts categorical sum choice operates respect labelling sets union disjoint sum 
definition ss set lambda model proc ml ml define phi ml phi il il immediately sees sets construction induces functor gamma phi gamma ml theta ml ml 
choice union disjoint set labelling sets lift functor theta defined action arrows 
fact arrows possible define phi 
possible ss ss agree action elements ss ss 
particular true arrows fibres case ss ss identity functions 
generally define bifunctor phi min theta min min min subcategory arrows ss inclusion sets 
ss set lambda model definition 
describe denotational semantics proc inductively structure terms assuming environment function ae ars nil nil ae initial object variables ae ae sum phi ae ae phi ae product theta ae ae theta ae restriction lambda set 
lambda ae lambda ae lambda 
ss ae chapter 
presheaf models ccs languages relabelling xi total 
xi ae xi ae ss ae xi truncation image function xi gamma 
ae xi lx prefixing label ae fag ae ss ae 
fag 
recursion term variable possibly free 
environment ae term variable determine endofunctor min min 
ae chain derivable 

ae nil ae 
ae gamma define recx ae colim constructions involved denotation term colimits preserving functors colim fixed point 
giving interpretation terms proc objects constrained fr reciprocity law beck chevalley condition 
lie 
shall see section equipping models notion bisimulation matter conditions constrain action cartesian arrows objects presheaf models proc saw previous section denotation term proc mainly means universal constructions products cartesian liftings fixed points definition bisimulation mind see previous chapter natural look proofs expected congruence properties term constructors respect bisimulation relation 
generality data required model bisimulation requiring arbitrary choice categories path objects task looks quite impossible achieve 
case contrary manages link path category parametrisation bisimulation defined description model seen choose path category bisimulation small dense subcategory regard full subcategory prefixing ad hoc requirements forms exception general treatment 

presheaf models proc bp cf 
proposition 
saw open maps bisimulation preserved moving bp examples interest bisimulation reflected cf 
proposition 
motivated idea study open map bisimulation presheaf categories help deriving properties congruence property bisimulation setting instantiated specific cases interest 
turned case special role played proposition states preservation open maps bisimulation colimit preserving functors presheaf categories 
proceed order 
start describing need build presheaf model proc definition pre presheaf models proc pre presheaf model proc consists functor gamma set lambda cat category small categories sends pl pm ffl set category pl initial object functors preserve initial objects 
ffl set element explicitly prefixing functor pl pl satisfying commutativity diagram pl fflffl pl pre pl defined process labelling set denote rooted presheaf pl grothendieck construction section mind sees model defines split cofibration set lambda shall return section dealing example provided pomsets event structures 
example examples presheaf models cover synchronisation trees event structures 

define gamma lambda set lambda cat functor associates set partial ordered set regarded category lambda finite possibly empty strings elements partial map monotone map functor pointwise relabel string string sending letter undefined empty string 
prefixing functors defined usual prefixing strings oe aoe 

define pom gamma set lambda cat functor associates set category pomsets labelled poml pomm functor ffl objects pomset fe theta 
chapter 
presheaf models ccs languages ffl arrows arrow poml simply restriction prefixing functors obvious ones prefixing pomset obtained adding new event labelled placed events causal order relation 
recall functor small categories derive triple adjoint functors 
lambda lambda bc 
lambda bd lambda oo data defining presheaf model derive bifibration grothendieck construction 
grothendieck construction presheaf models presheaf model gamma glue fibres consisting categories rooted presheaves pl form fibration set lambda call groth gamma objects pairs hx li lambda rooted presheaf pl arrows pairs hf hx li hy lambda 
composition arrows hg ffi hf lambda ffi ffi clearly projection hx li 
object part functor ss groth gamma set lambda intuitively grothendieck construction various fibres adds arrows presheaves possibly different fibres allow possibility partial relabelling actions 
adjunction 
lambda presheaf categories bpl bpm cuts adjunction fibres rooted presheaves 
adjunctions ensure grothendieck fibration fact bifibration cocartesian lifting respect jx jx lambda component unit adjunction fibres presheaf categories satisfy colimit completions required definition 
applying proposition deduce groth gamma binary products 
functor gamma induces split cofibration fibres categories pl set extended groth gamma property lost 
hand lambda defined composition groth gamma split fibration 
definition presheaf models proc presheaf model proc consists functor gamma definition satisfying extra condition induced bifibration groth gamma satisfies fr reciprocity law condition 

presheaf models proc observe statement proposition consider rooted presheaves assuming base category initial objects 
restriction look slightly odd categorical point view 
decided help early stage development presheaf models give smooth treatment prefixing immediate proof preserves open map bisimulation 
start describing base categories recursive domain equations give detailed account prefixing notion lifting remove anomaly restriction rooted presheaves 
note categorical point view choice rooted presheaves reduce generality approach said times category rooted presheaves category initial object equivalent category presheaves base category initial objects removed 
immediately seen presheaf models proc gamma groth gamma obvious projection functor forms categorical model proc sense definition 
easy equip model notion bisimulation 
bring objects common fibre see open map bisimilar 
definition open map bisimulation groth gamma hx li hy objects groth gamma 
say open map bisimilar il hx li im hy related span surjective pl open maps il im set inclusions 
im notation reminder chapter shall write hx li hy mean open map bisimilar say cpl pl open bisimilar 
hx li hy il im definition immediately see moving objects different fibres cocartesian liftings preserves bisimulation 
deduce deduce bisimulation congruence respect operations denotational semantics processes 
answer relies mainly result corollary 
proposition colimit preserving functors preserve open maps small categories bc bd colimit preserving functor preserves open maps ff gamma open map ff gamma open map 
proof proof postponed chapter proposition reappears corollary general theorem 
chapter 
presheaf models ccs languages category epimorphism gives rise pushout square fflffl colimit preserving functor preserves epimorphisms 
implies corollary 
corollary small categories 
bc bd functor 
open bisimilar presheaves open bisimilar 
proposition corollary deduce hx li groth gamma exists subset inclusion function 
hi lambda hx li 
proposition hx li groth gamma 
inclusions hi lambda hx li hj lambda fflffl obvious pullback square inclusions hl lambda lambda hx li proof need show lambda lambda assumption lambda corollary lambda lambda lambda beck chevalley condition lambda lambda lambda lambda composing lambda lambda lambda square inclusions commutative know lambda lambda corollary hx li groth gamma exists subset hi lambda hx li 
inclusion function 
proof just take equal intersection hi lambda hx li im 
inclusion function 
definition hx li groth gamma say reduces subset hx li hi lambda subset reduced say essentially 
subset say reduced 
notion reduction captures idea presheaf essentially described path objects pl regarding object cpl results yields characterisations bisimilarity groth gamma 

semantic constructions gamma proposition objects hx li hy groth gamma bisimilar iff reduce lambda lambda 
corollary objects hx li hy groth gamma bisimilar iff essentially set 
lambda lambda shall see operations involved semantics proc preserve bisimulation 
going semantics proc presheaf models recall instantiation proposition groth gamma 
proposition gamma set lambda cat presheaf model proc ae monomorphism set lambda injective total function 
facts hold ffl lambda 

ffl 
preserves products fibres rooted presheaves pl theta theta semantic constructions groth gamma analyse constructions groth gamma give semantics proc section show preserve open map bisimulation 
products said category groth gamma products 
constructed cf 
proposition products fibres follows hx li hy gamma define hx li theta hy lambda theta ssm lambda theta lambda ssl theta lambda ssm projections product set lambda proposition hx li open map map bisimilar hx hy open map bisimilar hy product hx li theta hy open map bisimilar product hx theta hy 
proof theta lambda theta lambda 
consider diagram il fflffl fflffl ssm im fflffl fi oo oo ssm ssl oo im oo tend set lambda exception symbol theta indicate product objects category 
irrespective fact time products taken different categories appear expression 
hope reader disambiguate context 
chapter 
presheaf models ccs languages ff fi obvious projecting partial functions 
observe set included theta lambda upper diagram lower limiting cones vertex respectively 
proposition isomorphisms pn ss lambda lx theta ss lambda ff lambda il theta fi lambda im ss lambda theta ss lambda ff lambda il theta fi lambda im means prove assuming il il im im ff lambda il theta fi lambda im ff lambda il theta fi lambda im fact corollary deduce ff lambda il ff lambda il fi lambda im fi lambda im 
proposition combined fact product surjective natural transformations surjective ff lambda il theta fi lambda im ff lambda il theta fi lambda im sum hx li hy gamma define hx li phi hy hil im il 
im obvious set inclusions 
proposition functor phi preserves open map bisimulation hx li open map bisimilar hx hy open map bisimilar hy hx li phi hy open map bisimilar hx phi hy proof 
consider diagram inclusions il fflffl jl fflffl im fflffl jl 
jm oo oo jl oo 
oo im oo assumption il il im im jl jm jl jm 
semantic constructions gamma jl il jm im jl il jm im jl jm jl jm sum construction coproduct choice labelling set sum 
shown il im mediating map coproduct sets hx li phi hy il im hx li hy restriction lambda set hx li gamma consider inclusion map lambda 
define restriction lambda hx li lambda hi lambda lambda li proposition functor gamma lambda preserves open map bisimulation hx li open map bisimilar hx hx li lambda open map bisimilar hx lambda proof consider diagram inclusions lambda lo jl fflffl il fflffl lambda lambda jl oo il oo squares readily seen pullbacks beck chevalley jl lambda lambda il 
jl lambda lambda il 
assuming il il deduce jl lambda lambda il lambda lambda il jl lambda relabelling xi total 
take hx li usual define xi xi ae xi lx consider truncation xi xi image set xi xi ll 
define relabelling hx li xi xi xi lli relabelling preserves bisimulation chapter 
presheaf models ccs languages proposition hx li open map bisimilar hx hx li xi open map bisimilar hx xi proof take commuting diagram xi il fflffl xi ll jl fflffl xi xi xi il oo jl oo knowing il il obtain jl xi xi il xi xi il jl xi prefixing suppose label set element left kan extension extend prefixing functors 
bpl bpl fag 
proposition 
hx li open map bisimilar hx hx li open map bisimilar hx proof definition diagram commutes pl il fflffl pl il pl pre il oo pl il oo il il il il 
semantic constructions gamma recursion letting groth gamma groth gamma functor define rec colimit colim 
groth gamma 
unique isomorphism rooted presheaf 
consists pair xn express colimit pair hx li colimit set lambda ln colimit pl cocartesian liftings xn edges cocone ln noticed operations groth gamma associated term constructors functors gamma phi gamma functorial restricts groth gamma subcategory groth gamma object morphisms pairs hf ii inclusion sets 
having groth gamma groth gamma define rec 
shall ln inclusion sets 
constructions continuous respect chains restrict groth gamma rec determines fixed point deduced denotation term section 
construction yields denotation recursively defined process terms colimit presheaves common path category 
deduce bisimulation recursive processes rec rec bisimulation open terms open terms give rise endofunctors groth gamma includes groth gamma 
start extending notion open map bisimulation functors 
definition start saying mean asserting arrow hf ii groth gamma groth gamma open 
definition arrow hf ii hx li hy groth gamma open transpose respect adjunction 
lambda pm open 
proposition hf ii hx li hy open sense definition pl open reduces proof adjunction lambda jx jx unit adjunction 
lambda know jx isomorphism monomorphism cf 
proposition composite open maps open 
lambda lambda lambda obvious question proposition statement 
intuitive expectation knowledge generally true 
put extra assumption presheaf model 
instance lemma ii get proposition gamma set lambda cat presheaf model injective total function monomorphism set lambda objects pl pm pm ip ip pl chapter 
presheaf models ccs languages dpm essentially counit adjunction 
lambda pm open 
immediately seen proposition induces converse proposition worth noticing presheaf models example satisfy condition required proposition 
back recursion definition groth gamma functors 
ff gamma natural transformation 
say ff open ffc open definition 
consider endofunctors groth gamma bisimilar endofunctor span surjective open natural transformations ff 
fi 
relating 
proposition category initial object 
natural transformation ff gamma endofunctors induces natural transformation ff gamma defined inductively ffl ffl ffl ffl proof define inductively ffl ff def id ffl ff def fff ff ff second equality holds naturality ff 
check ff natural transformation need show square commutes rn ff fflffl rn ff fflffl 
semantic constructions gamma proof goes obviously induction 
base case follows immediately initiality 
assume 
ff ff gamma definition fff ff gamma definition ff fff ff gamma functoriality fff gamma ff gamma inductive hypothesis fff gamma ff gamma functoriality gamma fff gamma ff gamma naturality ff ff definition proposition instantiated groth gamma proves part statement 
second part immediately verified looking definition ff 
proposition endofunctors groth gamma ff 
natural transformation 
natural transformation ff 
ff open preserve open morphisms ff open 
open maps preserved passing colimit particular proposition 
bp functors ff 
natural transformation ffn surjective open map 
map colim ff colim colim uniquely determined universal property colimits surjective open map 
proof commutative square objects fflffl colim colim ff colim colim colim colimits chains exists number arrows pn qn chapter 
presheaf models ccs languages diagram commutes pn fflffl ffn fflffl rn colim colim ff qn fn colim rn fn edges corresponding colimiting cones 
assumption ffn open exists rn splitting leftmost square commutative triangles 
def rn rn arrow colim splits diagram commutative triangles 
ffn natural transformation obviously colimits presheaf categories calculated pointwise colim ff 
calculation colimits chains groth gamma reduced calculating colimiting fibre proposition yields proposition 
groth gamma ff 
proposition ff open adjoint transpose arrow colim ff colim colim uniquely determined universal property colimit open map fibre colimiting labelling set 
proof remarked colimits chains delta delta delta ln delta delta delta groth gamma obtained union ln labelling sets chain calculating colimit chain induced fibre cocartesian liftings xn 
explanation precise order show functor part colim ff arises situation satisfying hypothesis proposition 
need notation 
write hfn 
ini hfn jni simplicity assume rn rn rn fn jn fn fn transposes 

semantic constructions gamma ff take ffn kn rn fn 
naturality ff means square commutes indicated isomorphisms uniquely determined universal property left kan extensions rn kn rn fflffl kn rn kn rn rn ffn fflffl jn kn rn jn ffn fflffl jn fn fn writing ln ln hr li colim calculated colimit chain cpl delta delta delta rn rn rn rn delta delta delta similarly calculates colim commutativity diagram follows diagram commutes 
inclusion function rn fflffl rn rn rn fflffl jn kn 
kin rn fflffl jn kn 
kin rn fflffl jn kn rn fflffl jn ffn jn kn rn fflffl jn ffn jn fn jn jn fn fn fn ff unique mediating morphism colimiting cones connected natural transformation pointwise open map vertical arrow diagram isomorphism open map transformation colimit preserving functor open map open map proposition 
fall hypothesis proposition ff pm open 
consequently endofunctors ranging groth gamma bisimilar preserve open maps colimits rec rec bisimilar 
term free chapter 
presheaf models ccs languages variable built constructions section determine endofunctor groth gamma preserves open maps section propositions 
follows open terms bisimilar induce bisimilar functors recursive definitions rec rec bisimilar 
concrete models revisited wrote motivation moving models hope able deduce general congruence properties setting transfer back concrete cases 
mentioned full embeddings st 
lambda esl 
poml equivalence categories second strict inclusion instance terminal presheaf represented event structure preserves reflects bisimulation see proposition 
consider presheaf models groth gamma lambda groth pom gamma example 
transfer results presheaf models concrete models synchronisation trees event structures noting canonical embeddings fibres st cl lambda esl poml extend full faithful embeddings st es corresponding presheaf models 
particular embedding st 
groth gamma lambda equivalence 
illustrate situation event structures 
recalled proposition functor pes es set lambda cofibration 
provide choice cleavage split cofibration associated pseudo functor cf 
section functorial nose just isomorphism 
con event structure ff partial function 
define ff con follows ffl fe ff ffl theta ffl con fx con ffl ff 
straightforward verify ff event structure pair ffi acting identity defined events belongs event structure morphism 
propositions straightforward verifications 
proposition event structure con partial function ff event structures morphism ffi cocartesian arrow 

concrete models revisited shall write ff ffi 
induced cocartesian lifting functor ff 
esl esl 
observe restrict construction pomsets capture exactly functor ff poml poml example 
easily verifiable proposition event structure con partial function ff holds 
ff ff identity morphism li 
fi partial function fi ff ff corollary exists functor gamma 
set lambda cat induces cofibration pes es set lambda means grothendieck construction 
notation hf ffi structure morphism write fff unique function hf ffi hfff fff restriction elements ff way equal set fe 
call fff transpose notation mind define es groth pom gamma ffl objects con hcl li ffl arrows hf ffi ff hf ffi hc ffi cl esl gamma esl ff gamma ff lambda cl defined composition transposition recall pomsets ff 
name ff ff 
defines functor proposition ep ff fi gf equalities deduces ch li li hg ffi 
form proposition sees arrow hf li acts cl restricted esl 
proposition functor es groth pom gamma dense full embedding 
proof straightforward fact extends cl dense full embeddings fact cocartesian liftings arrow objects groth pom gamma different fibres uniquely determined arrow fibre 
known fact dense full embedding preserves limits 
direct calculation show respects relabelling cocartesian liftings cartesian liftings inclusions 
proposition ff partial function natural isomorphism cm ff 
ff cl 
inclusion map cl lambda lambda cm chapter 
presheaf models ccs languages lambda right adjoint 
defined objects follows lambda con con fe ej theta con fx con unique element 
noticed cl preserves coproducts proposition 
proposition know coproducts category built coproducts fibres cocartesian liftings preserves coproducts 
summarising proposition embedding es groth pom gamma preserves limits exists es coproducts cocartesian liftings cartesian liftings inclusion 
denotational semantics proc es corresponds described abstractly section :10.1.1.21.5791
proposition ensure embedding semantics es correspond groth pom gamma theorem es delta groth pom gamma delta stands corresponding semantics proc ae ars es environment function es ae groth pom gamma proposition ii open maps bisimulation coincide canonical embeddings esl fibre groth pom gamma 
transfer congruence property deduced presheaf semantics deduce particular strong history preserving bisimulation congruence language proc 
theorem strong history preserving bisimulation event structure congruence semantics language proc refinement event structures example application corollary give proof fact refinement operator event structures proposed preserves strong history preserving bisimulation short 
definition cf 
section refinement function pomm gamma map takes element non empty pomset definition refinement functor refinement function definition induces refinement functor poml pomm acting follows 
refinement event structures ffl objects pomset define jx 
ffl arrows poml define 
see inducing refinement functor say res event structures 
con event structure res defined pomsets iff fx xg con 
remarked functor obtained left kan extension candidate extension refinement presheaves including corresponding event structures 
functor 
act operation refinement res event structures 
precisely cl esl poml cm esm pomm denote canonical embeddings square commutes natural isomorphism 
esl res fflffl poml 
fflffl esm cm pomm answer embark proving 
lemma event structure esl pomset res esl esm refinement functor 
res exists pomset pq poml morphism ffl exists morphism pq res res pq 
ffl factorisation ffff ffff res res res exists unique mediating morphism pomsets res pq proof define fe ej order relation induced exist 
verification properties straightforward 
chapter 
presheaf models ccs languages proposition il poml esl im pomm esm inclusion functors res im ffi proof recall poml dense esl esl colim il poml il gamma esl lemma difficult verify res colim il poml gamma pomm im gamma esm deduce res im ffi fact res ffi il im ffi esl esm functor ff ffi il gamma ffi im natural transformation exists unique fi res gamma ff show observe fi natural transformation satisfying esl fie ffi res ffi ffp fact fi ffi res ffi naturality fi ffi ffp equality 
esl holds exists unique fie res satisfying fie ffi res ffi ffp commutativity naturality squares follows universal property colimits 
need prove esl diagram commutes res fi res fflffl fflffl res fi show fie 
follows calculation ffi fie ffi res ffi ffi ffp equality gf ffi ffp functoriality fie ffi res gf equality fie ffi res ffi res functoriality res 
refinement event structures functor poml pomm extended follows poml esl res im fflffl poml fflffl pomm im esm cm pomm want show square right commutes natural isomorphism 
show cm res cm im fact follow left kan extensions compose cf 
section cm res cl full faithful cl cm res cl cm res prove cm res cm im apply proposition 
proposition natural isomorphism cm res cm im proof proof immediate consequence proposition lemma 
fact saw proof proposition im expressed colimit lemma ensures condition proposition met 
corollary deduce 
preserves open map bisimulation 
proposition refinement function pomm associated refinement functor 
poml pomm preserves open map bisimulation poml open bisimilar presheaves pomm open bisimilar 
consequence proposition corollary refinement function pomm associated refinement functor res esl esm preserves strong history preserving bisimulation chapter 
presheaf models ccs languages strong history preserving bisimilar event structures esl res res strong history preserving bisimilar 
proof cl poml open bisimilar cl cl pomm open bisimilar cl cm res pomm open bisimilar cm res res res chapter profunctors seen presheaf categories provide setting proving congruence results transferred traditional models 
study way organise presheaf categories bi category maps respect bisimulation 
result viewed form domain theory traditional domains partial orders replaced domains presheaf categories 
details new domain theory chapter introduce basic bicategory shall serve category domains analyse structure prove important congruence results respect bisimulation relation 
left kan extensions coend formulae start recalling notion coend leads useful way calculating left kan extensions 
coends special kinds colimits defined universal wedges place universal cocones 
notion wedge turn connected dinatural transformation 
definition dinatural transformations page cop theta functors 
dinatural transformation ff gamma consists family arrows ffc jcj arrow hexagonal diagram commutes ff rr mm ff ll chapter 
profunctors notation object gives rise constant functor cop theta returning objects arrows 
definition wedges cop theta functor object wedge dinatural transformation ff gamma words wedge consists components ffc square commutes fflffl ffc ffc definition coends coend functor cop theta universal wedge consists pair wedge wedge ff gamma exists unique arrow ffc usual colimits limits abuse language object call coend written integral notation coend generally reduce existence calculation colimits existence calculation coends 
proposition category small colimits small coends 
particular colimit functor calculated ss ss op theta obvious projection functor 
means allowed write colimit functor coend explicitly mentioning dummy variable shall sequel write colim results show formal advantages integral notation 
theorem parametricity op theta theta functor exists 
choice coends mapping gamma extends uniquely functor gamma 
left kan extensions coend formulae line notation theorem shall action functor arrows theorem op theta theta op theta functor understood meaning coends exists isomorphic 
calculation colimits reduced calculation coends particular give description pointwise left kan extensions terms coends exercise 
simple observation 
proposition category functors bq natural transformations cat bq isomorphic category functors theta op set natural transformations cat theta op set 
functor bq talk exponential transpose indicate functor theta op set corresponds isomorphism 
similarly functor theta op set write corresponding functor bq definition set presheaf category define presheaf 
theta obvious morphism action 
put different way isomorphic pa product theta presheaf constantly objects identities arrows 
suppose functor bq note construction obtain functor pop theta bq defined objects def arrows op def natural isomorphism chapter 
profunctors means object theta action morphisms written theta ff gamma ff theta qi left kan extension functor exists equal identity restate density yoneda embedding see proposition terms density formula yp said coends section coend description kan extension sound cocomplete category extra feature set instance computing colimit point equation compute coends colimits appropriate equivalence relations exactly going describe theta jpj theta equivalence relation generated exists arrow 
means triples say related exists chain morphisms jj bbbb bbb gamma gg hn gamma elements ai ai bi ai ffl bn ffl odd ak hk ak bk hk bk ffl ak hk ak bk hk bk 
see description compute limits colimits set 

bicategory prof category cocont bicategory prof category cocont introduce category presheaf categories colimit preserving functors natural transformations 
fact shall give equivalent presentations define bicategory category 
reason doing presentation gives greater emphasis base categories shall see concerned operations best base categories 
definition prof define bicategory prof profunctors follows ffl objects small categories ffl arrows functors theta op set profunctors ffl cells ff natural transformations functors 
vertical composition cells usual vertical composition natural transformations 
horizontal composition arrows cells described term coends formulae 
arrows define functor theta theta theta rop theta gamma set theta set theta gamma set tuple objects associates set theta obvious actions morphisms derived defines composition arrows prof theta define theta theta theta theta concerning cells suppose situation ff ff ff fi define ff fi hp ri qi theta ri chapter 
profunctors concerning identities just hom functors 
small category define theta pop set 
proposition immediately seen exponential transpose yoneda embedding yp 
associativity morphisms left right identities derived universal property defines coends 
giving definition prof exploited fact small category regarded set category terminology enriched category theory 
implies say rephrased term generic categories cocomplete category 
profunctors subsume presheaf categories proposition states 
proposition presheaf category bp equivalent category prof profunctors object arrow category category proposition proposition give different equivalent definition prof uses left kan extensions define composition arrows 
precisely described prof bicategory ffl objects small categories ffl arrows functors bq ffl cells natural transformations functors composition arrows defined choice left kan extensions ffi ffi second composition usual composition functors 
description kan extensions coends implies jpj jrj ffi theta ensures definition equivalent previous 
description helps understanding tight relationship arrows prof holds respect colimit preserving functors presheaf categories 
formal considering category cocont 
definition define cocont follows ffl objects small categories ffl arrows colimit preserving functors corresponding presheaf categories arrow colimit preserving functor bp bq ffl cells natural transformations functors category particular bicategory sense look functors cf 
relate prof cocont 
terminology 
bicategory prof category cocont proposition exists pair strictly unitary morphisms prof sigma cocont xi oo small categories sigma xi equivalences categories pseudo inverses 
words prof cocont regarded equivalent bicategories class objects equivalences sigma xi send identity arrows identity arrows 
set theoretic analogy said functor relation mapping 
profunctors regarded generalised relations moved level sets categories 
short section uses proposition illustrate result backs claim shall chapter 
recall relation sets function theta elements set 
relation function satisfies conditions totality delta functionality delta delta diagonal relations identity functions 
categorical words regarding rel order enriched category bicategory relation function right adjoint 
state known result category theory shows profunctors right adjoints correspond notion cauchy completion functors underlying base categories 
theorem cc adjoint profunctors cauchy complete category 
exists functor gamma gamma gamma gamma 
proof sketch said profunctors correspond colimit preserving functors adjoint pairs profunctors correspond adjoint pairs colimit preserving functors 
colimit preserving functor presheaf categories right adjoint cf 
section adjoint pairs colimit preserving functors correspond essential geometric morphisms turn correspond proposition functors base categories 
cauchy complete statement modified require functor defined cauchy completion people word distributor bimodule 
adjoint pairs bicategories defined analogy categorical case extra care needed take account coherence isomorphisms 
chapter 
profunctors terms kan extensions theorem saying 
lambda shall see just rel prof better cocont far definitions concerned compact closed sense 
domain theoretic analogy discuss intuition presheaf construction analogue powerdomain 
remarked fact prof described bicategory free algebras pseudo monad categorical analogue category algebraic cpo 
presheaf categories analogues powerdomains prof regarded bicategory non deterministic domains 
proceed 
definition completion filtered colimits small category 
write ep free filtered colimit completion ep colimits filtered diagrams filtered colimit preserving functor ep category filtered colimits uniquely natural isomorphism determined restriction categorical analogue algebraic cpo defined category freely generated categories filtered colimits 
definition gamma acc define gamma acc category ffl objects small categories ffl arrows filtered colimit preserving functors respective filtered colimit completions arrow filtered colimit preserving functor ep eq ffl cells natural transformations functors 
shall write filt ep eq gamma acc 
dealing freely generated categories equivalence proposition functor category cat eq equivalent filt ep eq 
means just profunctors equivalent presentation gamma acc functors eq arrows uses freeness property perform composition arrows 
notion accessible category regular cardinal consult 
want describe endo pseudo functor gamma acc free completion small category finite colimits 
having linear logic mind shall denote exclamation mark symbol 
need preliminary result deduced results chapter vi particular theorem page proposition small category writing free finite colimit completion equivalence 
bicategory prof category cocont definition define gamma acc gamma acc pseudo functor ffl objects returns small description free finite colimit completion ffl arrows ep eq filtered colimit preserving functor define equivalences proposition bp ip bq ip ep iq eq obvious inclusion functors 
ffl cells action cells uniquely determined universal property left kan extensions 
pseudo functor equipped multiplication unit corresponding coherence modifications order form pseudo monad doctrine terminology 
proposition prove result allows represent filtered colimit preserving functors presheaf categories profunctors 
proposition small category equivalence categories prof filt bp bq proof prof cat bq cat filt filt bp bq proposition suggest prof regarded category free algebras kleisli category fact adjoint situation gamma acc prof mm identity objects send arrow ep eq 
ep 
eq 
bq course statement precise consider notion kleisli category pseudo monad 
chapter 
profunctors filtered colimit completion includes bq freeness 
action cells composition inclusions 
side rp uses equivalence proposition map prof filt including freeness construction prof prof 
look monad prof point view obtain comonad prof indicate bang symbol 
section comonad show prof regarded seely model classical linear logic 
structure prof section show prof structure considered called compact closed bicategory need define explicitly pseudo limits definition pseudo products coproducts bicategory objects object equivalence categories theta pseudo natural explicitly pseudo product span arrows ss gamma ss gamma 
span gamma gamma exists isomorphic cells phi ss gamma ss 
arrows cells oei exists unique oe oei 
equivalences isomorphisms shall say product strict 
dually define pseudo coproducts seen illustrative example definition pseudo initial object definition 
dual definition give pseudo terminal 
definition pseudo zero object bicategory pseudo zero object object pseudo initial terminal 
proposition prof strict pseudo products coproducts phi coincide objects 
instance remarked 
recall pseudo limit called contexts limit shortly bilimit 

structure prof proof small categories define def def phi usual disjoint union small categories inclusions inp inq define ssp ssp inp ssp inq symmetrically ssq 
ip phi defined transpose yp ip inp ip inq 
connection proposition worth stating accounts strictness product coproduct 
proposition small categories isomorphic tob theta bq proposition prof strict pseudo zero object proof just take initial category objects arrows 
immediately seen zero object unit product coproduct bifunctor 
pseudo functors definable prof called autonomous bicategory 
definition bicategory write bop opposite bicategory reverses direction cells cells 
definition define tensor prof ffl tensor define omega prof theta prof prof follows objects omega def theta product categories arrows omega theta theta op theta op set 
theta cells ff fi ff omega fi ff theta fi terminal category neutral element omega ffl define gamma lambda prof prof op follows objects lambda pop arrows define lambda lambda lambda lambda 
cells ff ff lambda lambda lambda ff lambda hq qi 
combining tensor yields linear function space 
chapter 
profunctors definition define pseudo functor prof op theta prof prof omega ffi gamma lambda theta categories pop theta proposition categories prof omega prof proof chain natural isomorphisms holds trivially prof omega def cat theta theta rop set cat op theta def cat lambda omega cat theta lambda omega op set def prof lambda omega def prof summarise saying prof compact closed bicategory 
linear logic point view implies omega coincide degeneracy model adding degeneracy phi coincide 
worth remarking correspondence prof omega prof lambda omega lead adjunction proposition small category pseudo functor omega gamma left adjoint gamma proof lack unit counit adjunction immediately defined follows jq theta omega op set 
theta omega theta op set 
theta lifting paragraph draw attention endofunctor prof play crucial role chapters shall see section allows represent connected colimit preserving functors presheaf categories profunctors 

connected colimits definition lifting define gamma 
prof prof pseudo functor ffl object 
category added new strict initial object referred 
objects 
written bp object ffl arrows 
defined bp bqc lambda ffl cells cell ff extended cover new cases identity functions 
observe cat operation 
corresponds free completion colimit empty diagram 
connected colimits section shown represent filtered colimit preserving functors presheaf categories prof exponential regarded functor cat amounts free finite colimit completion monad 
concentrate class colimits important 
colimits connected diagrams 
lifting functor free empty colimit completion freely adds category initial object similarly describe connected colimit preserving functors presheaf categories arrows prof notation small category write inclusion functor 
bp know chapter functor induces triple adjoints 
lambda lambda bp cp 
functor lambda yp universal functor 
bp exists freeness sends non bottom object corresponding representable bottom empty presheaf 
sequel shall write jp lambda yp 
functor lambda takes presheaf returns rooted presheaf bxc bxc bp 
fact restrict lambda range rooted presheaves pair lambda 
bp lambda defines equivalence talking previous chapters 
particular note lambda lambda yp 
yp 
representable rooted presheaf 
back connected colimit preserving functors proposition functor lambda bp cp 
preserves connected colimits 
proposition connected colimit preserving functor bp bq uniquely natural isomorphism determined action bp initial presheaf 
chapter 
profunctors proof presheaf bp 
know colimit colim el pss gamma bp consider connected diagram 
el 
bp extends sending 
clearly colim gx 
colim 
know action need know yp el 
proposition exists equivalence categories prof conn bp bq small categories conn bp bq category connected colimit preserving functors natural transformations 
proof shall prove existence equivalence cocont cp bq gamma conn bp bq cocont cp bq define lambda ff define ff ffl lambda conn bp bq define gl lambda yp fi fi determined universal property left kan extensions 
proposition immediately follows colimit preserving lambda connected colimit preserving 
colimit preserving definition 
defined 
difficult see full faithful presheaves 
expressible sums rooted presheaf objects cocont cp bq preserves colimits sums 
fact px xjx presheaf defined xjx fy jx 
yg natural transformation ff uniquely determined action rooted presheaves 
lambda yp 
lambda lambda yp 
yp 
type theory domains concurrency lambda gl lambda yp lambda observe gl lambda yp lambda yp gl lambda yp bp gl lambda yp lambda gl lambda yp 
proposition full faithful essentially surjective objects equivalence 
connected colimit preserving functors play important role semantics process calculi 
proposition proposition section prove connected colimit preserving functors preserve surjective open maps 
proposition functor lambda bp cp 
preserve surjective open maps 
proof surjective open ensure bf bxc surjective open check new naturality squares bxc bp fp fflffl lambda bxc 
bp lambda bxc 
quasi pullbacks amounts claiming surjectivity granted hypothesis 
type theory domains concurrency put informations previous section give interpretation prof types simple grammar 
basis description presheaf models chapter 
chapter fact prove theorem limit colimit coincidence enable extend grammar recursive types allow recursive definition path categories presheaf models 
grammar phi omega lambda pi ti 
types compact closed categories extended type variables arbitrary sums lifting operator gamma 
list distinct type variables theta write theta indicate formed type free type variables theta type judgements theta interpreted pseudo functors theta prof op theta prof theta gamma prof interpretation terms constructors section inductively follows chapter 
profunctors ffl theta prof op theta prof theta gamma prof terminal bicategory functor picks initial category 
ffl theta prof op theta prof theta gamma prof functor picks terminal category 
ffl theta phi prof op theta prof theta theta theta prof theta prof phi prof ffl theta omega prof op theta prof theta theta theta prof theta prof omega prof ffl theta lambda prof op theta prof theta gamma lambda theta gamma lambda op oe theta prof op theta prof theta theta prof oe prof op theta prof prof theta prof op symmetry functor objects acts follows oe 
ffl theta prof op theta prof theta theta prof prof ffl theta prof op theta prof theta ss gamma prof op theta prof ss gamma prof ss obvious projection functors 
ffl theta pi ti prof op theta prof theta theta ti ii prof prof write pi extended sum functor 
ffl theta prof op theta prof theta theta prof gamma 
prof ffl theta def theta lambda omega prof op theta prof theta theta lambda theta prof theta prof omega prof 
type theory domains concurrency alternative exponential saw previous sections exponential operator 
naturally candidate comonad obtain cartesian closed structure bicategory free coalgebras symmetric monoidal closed prof key fact satisfies seely condition omega attractive feature operator arises domain theoretical considerations gives way describing cocont category equivalent prof notion filtered colimit preserving functor presheaf categories equivalence gamma acc filt bp bq cocont disadvantage objects free finite colimit completion gives rise complicated categories quite difficult handle instance operational characterisation bisimulation induced open maps considered 
sense keep eyes open possibility choices exponential choices sufficient special purposes easier 
example induced free finite coproduct completion construction 
definition finite families small category small category finite families objects ffl objects finite families pi objects ffl arrows pair ffi arrow pi qj function ffi pi qf arrow proposition construction induces just gamma 
monad category cat 
particular objects free completion finite coproducts 
monad induces pseudo comonad prof underlying pseudo endofunctor definition definition define pseudo functor prof prof follows ffl objects ffl arrows pi qj ai pi qj ffl cells pointwise extension definition arrows 
difficult see pseudo functor satisfies seely condition small categories omega chapter 
profunctors tie ups construction categorical powerdomain dual category yielded explored deep connections 
open map bisimulation prof building fact prof pop theta small categories give definition open cells prof open map show horizontal composition open cells gives open cell 
imply corollary colimit preserving functors presheaf categories preserve open maps recall proposition 
definition ff cell profunctors define ff open open arrow pop theta unpack definition see really means 
ff regarded natural transformation presheaves open amounts satisfy condition definition 
suppose hf op gi hp qi hp arrow pop theta square quasi pullback set op fflffl qi fflffl fop instantiate arguments identity arrow respectively immediately implies corresponding natural transformations ffp gamma 
gamma ffq gamma 
gamma open pop open respectively 
converse holds 
proposition ff 
natural transformation presheaves pop theta ff pop theta open object corresponding natural transformations ffp ffq open pop open respectively 
proof discussion proves part 
converse note diagram functoriality rewritten fop fflffl fflffl qi fflffl fop 
open map bisimulation prof immediately seen gluing quasi pullback squares quasi pullback square 
observations having trivial proofs worth mentioning 
proposition ff open cell prof ff lambda lambda lambda open 
proposition regard presheaf category bp hom category prof proposition natural transformation presheaves open open cell corresponding profunctors 
aim proving horizontal composition cells preserves open maps theorem ff ff ff fi consecutive open cells prof composition open cell 
proof need prove pairs objects hp ri hp arrows square quasi pullback theta theta ff hp qi theta ri fflffl theta ff hp qi theta theta theta theta recall pair hp ri theta theta equivalence relation generated arrow suppose equivalence classes theta theta course open maps compose clear vertical composition open cells open cell 
chapter 
profunctors qi theta theta definition equivalence relation means exists chain morphisms ll bb gamma gamma elements ai ai bi ai ffl ffl bn ffl odd ak hk ak bk hk bk ffl ak hk ak bk hk bk step show existence elements ai ai satisfying conditions 

aki ak bk 
odd hk hk 
hk hk words want lift chain elements connects bn chain connects image ff fi bn 
induction showing deal obtain obtain 
consider 
condition define immediately follows aki aki recall decided respectively condition 

open map bisimulation prof condition satisfied 
find consider square choice elements right hand side fflffl fflffl 
fflffl fi open exists def tells satisfies conditions 
suppose gamma odd exist satisfying condition 
define hk 
hk hk hk bk bk find suitable consider square corresponding elements ak hk ak fflffl ak aki fflffl 
fflffl ak hk ak ak ak ki ff open exists ak ak ak hk satisfies conditions 
case treated exactly way substituting argument ff fi vice versa general instance argument base case 
finished proof theorem 
simply need apply openness ff fi 
consider diagram concentrate ff chapter 
profunctors fflffl fflffl 
fflffl ff open exists complete analogy considering ri fflffl fflffl 
fflffl bn openness fi conclude existence ri consider equivalence class theta results immediately verify qi theta ri ri theta instantiating particular situations right left immediately deduce interesting corollaries theorem 
notably corollary seen thesis proposition key result theorem natural generalisation 

open map bisimulation prof corollary colimit preserving functors presheaf categories preserve open maps proof 
bp bq colimit preserving functor ff natural transformation presheaves proposition proposition redraw situation prof follows ff ff know composite prof goes theorem composition ff open regard natural transformation presheaves ff ff 
proposition concludes proof 
corollary ff open cell recall ff proposition seen natural transformation corresponding colimit preserving functors 

ff open bp ffx open map dq op ff lambda pop open map 
proof part trivial proposition 
follows argument analogous corollary applied pictures 
ff ff op lambda lambda ff ff lambda pop corollary deduce preservation surjective open maps connected colimit preserving functors 
theorem bp bq connected colimit preserving functor 
preserves surjective open maps 
proof proposition know lambda lambda bp cp 
cp 
bq colimit preserving functor 
proposition know lambda preserves surjective open maps lambda preserves surjective open maps 
chapter 
profunctors chapter examples chapter develop theory domains categories generalise order enriched categories case deals pseudo functors strict ones 
cocont equivalently prof naturally fall list examples 
motivating examples process languages gives presheaf models deriving suitable base path categories solutions recursive domain equations 
fact solutions fixed points justified intuitively 
results chapter precise terms 
ccs show obtain synchronisation trees presheaf models sketch semantics ccs terms arrows prof corollary proposition entail strong bisimulation congruence respect term constructors language 
analysis shall serve reason introduce standard techniques reasoning presheaf models open map bisimulation 
represented decomposition results see proposition transition relations presheaves see section 
term language briefly recall main definitions process terms transition semantics 
reader unfamiliar process algebra ccs particular advised look detailed explanations 
assume set ch channels including element special symbol elements ch indicated letters ch fa chg set 
define set labels ch ch fo elements denoted greek letters ff fi fl process terms defined grammar nil ff pi ti lambda rec chapter 
examples variable drawn distinguished set vars non empty indexing set nil stands deadlocked process ch ch relabelling function lambda ch set restricted channels 
alternatively avoided explicitly consider nil process extend sums possibility having empty indexing set 
usual recursive expressions rec variable bound binder language 
set free variables process term class closed process terms defined structural induction 
transition semantics defined closed processes ff ff gamma tj ff gamma jp ti ff gamma ff gamma ff gamma gamma gamma gamma ff gamma ff gamma ff gamma lambda ff gamma lambda ff ff ch ff gamma ff gamma rec ff gamma rec ff gamma ch ch convention doing gamma twice doing extension ch ch fo putting equation synchronisation trees clear operational semantics language observed behaviour process sequence actions type classified different classes input actions output actions silent internal ones 
convention input actions represented elements ch input channel output elements ch internal ones represented silent action path category defined def 
ch 
ch 
ff 
shall see detail chapter find solution kind equation prof finding poset locally ordered category partial ordered sets monotone functions regard category usual way 
simplifies considerably description solution 
briefly expected described category finite non empty strings letters morphisms prefix order relation 
written previously synchronisation trees presheaves correspond proposition category st synchronisation trees equivalent toc 

ccs proof describe derive tree presheaf vice versa 
verify induces equivalence categories matter routine verification 
tree special transition system tran define presheaf xt inductively follows xt ff fs ff gamma sg xt ff fs ff gamma sg state reached unique transition map xt ff 
defined 
vice versa presheaf define tran def fig ff gamma 
ff ff ff gamma 
ff ff known ccs terms semantics terms synchronisation trees 
chapter gave description categorical operations involved semantics shown compositional placing st larger category st axiomatic approach assume prefixing operator 
resolve problem employing lifting operation denotations prefixing 
describe parallel composition functor trees left kan extensions 
need preliminary analysis carry sections shall see chapters part standard pattern deducing properties presheaf models 
decomposition presheaves recall 
ch 
ch 
write ino ina ina injection pro functors 
bp appropriate components ino bp yp ino 
yp reminder section shall write generic object proposition presheaf bp inff 
bp ffp 
ff chapter 
examples proof know inff coend formula inff theta inff ff definition inff singleton coend reduces 
initial object 
ffp looking definition inff yp bp coend theta bp yoneda exactly bp 
inff coends induces diagram empty sets colimit obviously empty set 
synchronisation tree finite run uniquely identifies subtree original tree subtree rooted final state run 
fact nicely expressible presheaf terms definition 
definition presheaf write xjx presheaf rooted defined xjx gamma fxg stands concatenation string string recall category finite non empty strings ordered prefix ordering 
terms trees course xjx subtree rooted things quite smooth dealing base categories similar notion subcomponent rooted element presheaf terms slice categories 
definition small category object define slice category category objects arrows domain morphisms arrows hf immediately seen initial object instance fact initial objects isomorphisms domain write full subcategory consisting non initial objects 
definition small category presheaf define resumption presheaf xjx defined xjx gamma fxg point view open map bisimulation interesting preservation property 
definition small category presheaves ff map bc natural transformation 
ffc define xjx 
ccs restriction ff resumption presheaves xjx gamma fxg gamma gamma fyg maps gamma fxg ffd 
theorem small category 
presheaves ff open map 
ffc surjective open map 
proof objects arrow arrow show open need show square quasi pullback set xjx gamma fxg fflffl xjx gamma fxg fflffl gamma fyg gamma fyg suppose gamma fxg gamma fyg definition means ffd 
ff open square quasi pullback ffe fflffl ffd fflffl exists ffe 
conclude shall show xjx hf gamma fxg def xjx 
fact surjective consequence openness ff 
fact object need show surjective function 

ff open quasi pullback ffd fflffl ffc fflffl chapter 
examples assumption ffc holds exists ffd xjx 
fact bc considered presheaves rooted restriction ff preserved openness open respect rooted presheaves equivalent surjective open initial objects removed cf 
chapter different way seeing theorem open map surjective restricted 
special particular satisfies closure property respect slice category construction 
proposition isomorphism categories 
case definition reduces definition 
shall general case chapter 
special case categories strict initial object respect resumptions initial step taken proposition small category 
isomorphism categories 
shall write presheaf 
xjx presheaf defined xjx 
bp gamma fxg proposition decomposition trees presheaf isomorphic presheaf ino ch xj ina ch xk ina proof induction structure path objects length strings proves bijection 
ffl base case length ff ff ff def ff inff ff ff fxg ff ffl inductive step length ffp ffp def ff inff ffp ff xjx ff ff gamma fxg 
ccs bijections natural trivial verification 
way looking decomposition presheaves think terms expansion law process terms ccs 
transition relation presheaves decomposition result natural define transition relation presheaves 
done different ways decorating transition arrow observed action observed action corresponding element presheaf 
turns ccs really matter chooses contrast situation shall encounter chapter essential intensional information characterise operationally bisimulation open maps 
definition transitions presheaves presheaves write xjx 
write gamma mean exists shall concerned exclusively transitions form ff gamma ff require extra effort prefer give definition generally possible paths kinds long steps transitions play big role chapter 
proposition read part concerning synchronisation trees follows proposition presheaves open map bisimilar corresponding transitions systems strongly bisimilar usual park milner sense 
proof hint proof relies recognising fact equivalence st cl takes synchronisation tree presheaf transition system tree 
denotational semantics chapter reviewed general way giving denotational semantics ccs processes mainly relied facts 
category cl included larger fibred category possible sets labels partial relabelling 

distinguished prefix functor available 

parallel composition expressed combining product larger category relabelling restriction 
chapter 
examples take advantage domain equation defines order give description directly bp operations involved semantics 
particular reduce prefixing lifting parallel composition combination liftings left kan extensions 
prefixing ff define ff bp bp lambda gamma cp 
inff gamma bp presheaf bp path object ff inff bxc ff lambda ff lambda preserves connected colimits ff preserves connected colimits preserves surjective open maps open map bisimulation see proposition 
observe decomposition presheaves proposition written xji ch xj xjj ch xk xjk parallel composition parallel composition functor gamma gamma bp theta bp bp defined follows gamma gamma gamma jj gamma 
ffi lambda ffi lambda theta lambda ffl functor lambda cp 
theta cp 
theta 
right adjoint left kan extension wp 
theta 
defined pairing projections 
theta 
ssi gamma yp gamma cp action lambda theta ffl functor gamma gamma 
theta 
bp symmetric functor defined inductively jj 
bp 
yp ae yp fffi yp fi ff ff fiy fffi yp yp shall functor lambda chapters 
shall say little chapter 

ccs ae yp fi fi ff ff fiy fi yp ff bp fi fi ff ff fi ff bp fi bp lemma presheaves ff fi fo ch ch labels holds ffl ff fi complementary fi ff vice versa ff ff fi ff xjy ffl ff fi complementary ff ff fi ff xjy xjy proof chain isomorphisms prove case 
ff xc theta bfi definition bxc theta bxc theta ff fis fi definition bxc theta ff bxc theta fi bin ffr sums distribute coends ff bxc theta fi bxc theta bin ffr ff fi preserve connected colimits ff theta bfi fi xc theta extra non empty contribution ff fi ff xjy definition 
passage marked lambda justified reasons 
coend different inff inff contribution colimit bff xc theta bfi 
bff xc theta bfi singleton lifted paths part diagram induced coend chapter 
examples embeddings 

contribution unique pairs 
subsumed contribution 
proof second case just exception definition ff fi complementary ff fi jjs lemma decomposition result presheaves distribution property sums respect coends immediately entail 
proposition bp decompositions xji ch xj xjj ch xk xjk ch xm ch xn xjy isomorphic tox xji ch xj xjj ch xk xjk ch xm ch xn ch xj xn xjj ch xm xk xjk restriction lambda ch set channels define gamma lambda bp inductively follows ffl ff lambda ae yp ff ff lambda lambda ffl ffp lambda ae ff lambda ff lambda lambda referring back treatment restriction chapter easy see gamma lambda 
gamma lambda lambda 
inclusion map 
shall characterisation left kan extension restriction operator 

ccs proposition bp decompositions xji ch xj xjj ch xk xjk lambda set channels lambda xji lambda ch lambda xj xjj lambda ch lambda xk xjk lambda proposition immediate consequence lemma 
lemma presheaf ch set channel names holds 
lambda lambda 
ff lambda ff lambda ff lambda lambda 
ff lambda ff lambda lambda proof proofs items follow pattern 
case recall ino bxc 
convention write 
bp functor 
bp yp lambda ino lambda definition lambda definition lambda preserves connected colimits lambda lambda lambda 
definition 
proof second case completely analogous third case contribution colimit empty presheaves colimit empty 
relabelling interpretation exactly chapter function ch ch naturally extended function putting 
details gamma bp defined inductively ffl ff yp ff ffl ffp ff yp characterisation decomposition presheaves chapter 
examples proposition bp decompositions xji ch xj xjj ch xk xjk ch ch relabelling function 
xji 
ch xj xjj ch xk xjk ccs term free variables interpretation functor bp defined compositionally follows ffl nil empty presheaf ffl ff bp bp ff bp ffl tjt bp sst ss ti bp theta bp bp ss obvious projection functors sst gamma sends tuple presheaves indexed free variables tuple presheaves corresponds free variables 
ffl bp bp gamma 
bp ffl lambda bp bp gamma lambda bp ffl bp gamma bp ffl rec ty fyg theta gamma bp functor 
ccs ty ty ty define rec ty cf 
theorem 
functors denoted term constructors preserves colimits chain denotation recursively defined process fixed point rec def ty rec categorical version usual substitution lemma holds lemma process term free variables vector free variables vector closed process term matching length functors naturally isomorphic proof sketch compositional semantics proof easy induction structure term case recursively defined process dealt definition rec colimit chain 
observe particular term free variable rec rec fact recursion reason non standard formulation substitution lemma prove say rec rec assumed span rec needs show isomorphism holds ty know ty needs know isomorphisms natural respect relation numbers 
show agreement operational denotational semantics transition relation presheaves 
theorem closed ccs term 

ff gamma implies ff gamma 
chapter 
examples 
ff gamma implies ff gamma proof 
proof goes rule induction 
exemplify looking interesting cases 
fft ff gamma fft gamma definition ff gamma lambda ff gamma lambda ff ff lambda inductive hypothesis ff gamma 
characterisation proposition lambda ji lambda ch lambda xj jj lambda ch lambda xk jk lambda consequently ff ff lambda lambda lambda ff gamma lambda lambda lambda gamma gamma ju gamma ju inductive hypothesis gamma gamma 
definition exist ji jj proposition exists jx jk gamma 
jk jx ju rec ff gamma rec ff gamma know denotation recursively defined process fixed point rec rec 
inductive hypothesis rec rec ff gamma 
ccs value passing 
proof goes structural induction structure straightforward verification 
know proposition presheaves open map bisimilar associated transition systems strongly bisimilar 
combining theorem corollary corollary closed ccs terms strong bisimilar denote open map bisimilar presheaves 
remarks treated easy example full detail little artificial call heavy categorical machinery discuss understood anyway 
reason doing pattern followed sets template shall employ dealing complicated situations see chapter chapter 
suggests particular possibility considering metalanguage recursively defined path categories presheaves connection fragment type theory chapter shall extend recursive types chapter 
hope fragment excluding exponential possible induce definition path category automatically decomposition results transition relations corresponding presheaves especially operational characterisation open map bisimulation 
metalanguage considered 
expand line research 
ccs value passing briefly consider example drawn 
essentially take extension ccs obtained allowing values sent channels 
typical output action represented symbol expression av meaning observing output value channel complicated situation input actions 
shall see fact natural ways thinking input 
fact reflected corresponding notion bisimulation setting captured modification input part domain equation 
illustrative purposes slightly deviate presentation language introducing notion abstraction process 
results shall claim easily derivable shall skip proofs 
advantage having models objects bi category possible formally relate arrows category 
shall sketch chapter 
examples section term language terms language shall consider defined grammar nil ae af pi ti rec ch stands expressions specify saying contain value variables evaluated return element set values process variables drawn set disjoint 
respect ccs omitted relabelling restriction operator put back difficulty 
respect adopted ss calculus notation input output ae 
relevant changes come abstractions function omission matching operator put back problem 
winskel restrict variables recursive expression occur guarded prefixes 
adopt restriction order able refer results shall quote 
announced shall operational semantics differ input clauses 
idea process say performs input action done different ways 
process simply communicate receive input channel gamma 
abstraction function waits input say come proceed substituted ff gamma ff gamma delay input action actual receiving value usually denoted late semantics input actions 
alternatively things occur time early transition rule av gamma observation kind ian stark joint shall report section 

ccs value passing operational semantics language rules gamma ae av gamma tj ff gamma jp ti ff gamma ff gamma ff gamma ff gamma ff gamma rec ff gamma rec ff gamma axiom output actions taken closed evaluating takes rules av gamma av gamma av gamma gamma av gamma av gamma gamma early semantics rules gamma ff gamma ff gamma av gamma gamma 
gamma gamma 
av gamma gamma late semantics 
case late semantics expressions tjt derived application rules understood standing tjt free occurrence renamed avoid capturing 
thinking transitions derived early set rules shall write subscript transition arrows 
analogously late transitions shall write 
consistently different operational semantics different notions bisimulation 
definition symmetric relation closed process terms early bisimulation implies ff ff ff ch theta ch theta fo symmetric relation closed process terms late bisimulation implies ff ff ff ch theta fo rf ch 
chapter 
examples extended abstractions equivalently define late bisimulation consist typed relations rt rf ffl rt symmetric binary relation closed processes far clause concerned second replaced rf ch 
ffl rf symmetric binary relation closed abstractions rf implies ff ff ff ch theta fo rf ch 
shall give denotational semantics language ccs previous section refer details 
simply write necessary equations reflects early vs late approach pe pe 
ch theta pe 
ch theta pe 
pl pl ch theta pl ch fl 
fl set regarded discrete category 
denotational semantics main result obviously early bisimulation correspond pe open map bisimulation late bisimulation correspond pl open map bisimulation 
map models section sketching derive arrow pl pe prof maps late denotation terms early 
functor pe pl solutions equation defining pe pl partial orders inductively defined follows pe roots corresponding silent action output input components ch order relation inductively find pe pe 
ccs value passing pl roots corresponding silent action output input components ch order relation inductively find pl pl 



clear expressions form 
denotes elements fl ordered pointwise implies 


easy define functor monotone map el pe pl early paths late ones defining el el el 
el el el el el 
extension el 
functor map early denotational semantics delta late delta instance process denote cpe ype cpl denote presheaf ypl el ypl right adjoint el lambda el 
map late semantics early 
precise definition semantics impossible give formal proof result 
chapter shall give presheaf semantics ss calculus late early variant prove analogous result case 
argument shall employ simplified form case 
illustrative example anyway sketch claim correct case process fact pe el lambda el el lambda lambda case el lambda el lambda ype colimit preserving functors preserve bisimulation denotational semantics deduce terms late bisimilar early bisimilar 
fact closed process terms late bisimilar denoted late presheaves pl open map bisimilar 
composing el lambda result el lambda delta delta deduce denoted early presheaves pe open map bisimilar terms early bisimilar 
chapter 
examples chapter theory recursive domains chapter introduced bicategory prof think category domains built notions bisimulation open maps 
previous chapter saw examples presheaf models concurrent process calculi base categories provided solving appropriate recursive domain equations 
chapter give generalisation classical results solution recursive domain equations axiomatic approach justify intuitive understanding :10.1.1.17.9542
fact freyd shall consider notion algebraic compactness pseudo version basic lemma see deduce pseudo algebraic compactness class categories include cocont categorical equivalent prof develop domain theoretical approach open map bisimulation relational structures induction coinduction principles recursively defined domains coinduction properties bisimulation 
technical reasons coherence conditions worry shall state results holding categories 
prefer chapter category cocont prof cf 
chapter consider interpretation type theory section cocont 
shall see section coherence results allow generalisations bicategories chosen pursue aim far thesis concerned 
local characterisation theorem denotational semantics domains specified recursive equations 
interested tools solving equations 
scott inverse limit construction category countably continuous lattices continuous functions 
smyth plotkin building previous wand provided categorical framework order enriched categories general version scott result applicable wider class categories 
starting point 
want generalise smyth plotkin results cover chapter 
theory recursive domains cases interest 
generalise directions 
categorical folklore move embedding projection pairs viz 
general categorical terms adjoint pairs 
shall consider chains adjoint pairs arrows categories 
order enriched case issue addressed 

move level order enriched case consider categories hom categories colimits chains 

consequence points shall consider pseudo limits limits 
giving preliminary definitions serve fix notation terminology 
definition category write sub category objects arrows isomorphic cells 
terminology improve readability shall write pseudo cell isomorphic cell 
definition category 
define category adjunctions follows 
objects whilst category objects tuples adjunction unit counit cells pairs cells oe diagrams ae ccc cccc cccc ccc gf ae cc cccc cccc ff commute 
horizontal vertical compositions arrows cells defined follows horizontal ffl arrows horizontal composition tuple gj delta delta gg ffl oe oe cells horizontally composable arrows horizontal composition oe oe vertical oe 
local characterisation theorem oe cells vertical composition oe delta oe delta write full sub category consisting tuples pseudo cell 
concentrate pseudo colimits chains 
definition chains category 
chain indexed family arrows hfn 
write fn inductively defined arrow fn def fn def 
dually op chain indexed family arrows ani gl def gl gn def definition pseudo cones chains pseudo cone chain hfn data ffl object ffl indexed family arrows ai 
ffl indexed family pseudo cells phi fn ni 
dually pseudo cone op chain ani ffl object ffl indexed family arrows ani 
ffl indexed family pseudo cells gamma 
category interested pseudo cones chains 
spell terms data pseudo cone chains amounts 
definition pseudo cones chains pseudo cone chain fn gn gamma ani consists ffl object ffl indexed family fln ani adjoint pairs 
ffl indexed family phi gamma ni pseudo cells phi fn gamma fln squares ff gn fln fn gamma phi chapter 
theory recursive domains jn nfln ff phi gamma gamma gamma nfln ff fln ks commute important observe pseudo cone chain adjunctions induces chains cones obtained diagrams follows ffl chain fn delta delta delta gl gl gl fn delta delta delta cone ff ff fn gn ff delta delta delta delta delta delta fln gn nfln fn ks delta delta delta ks ffl fl phi gamma gamma gamma fl fl phi gamma gamma gamma fl fl delta delta delta cone fl pppp ppp fl ff fl rz delta delta delta delta delta delta purpose chapter shall call cones canonical cones lil fln respectively 
give explicitly elementary description pseudo colimits chains category 
definition pseudo colimits chains pseudo cone phi fn ai chain hfn category said pseudo colimit satisfies universal property 
local characterisation theorem 
pseudo cone psi fn xi exists arrow indexed family pseudo cells ni square fn fn phi ff psi fn psi nff commutes 
pair arrows indexed family cells ni satisfying fn fn phi ff fn phi nff exists unique cell 
shall concentrate categories hom categories categories colimits chains definition cat define cat large category locally small categories colimits chains functors functors preserve colimits chains 
define cat subcategory cat consisting categories initial object initial object preserving functors 
clearly cat cat straightforward generalisations categories cpo cppo 
pointed cpos strict continuous functions 
example cocont cat category 
fact small categories cocont theta op cocomplete category 
arrows cocont colimit preserving functors composition functor preserves colimits chains initial presheaf 
announced generalisation theorem obtained marcelo fiore stated follows theorem local characterisation cat category 
chain adjunctions fn gn ani pseudo cone phi fn ai chain hfn equivalent chapter 
theory recursive domains 
phi fn ai pseudo colimit hfn 
phi fn ai pseudo colimit hfn 

pseudo cone adjunctions phi gamma fln jn fn gn fln canonical cones ida lil fln colimiting 
proof prove chain implications 
clearly implication holds trivially pseudo colimit pseudo colimit 
concentrate remaining 
implies start looking suitable definitions right adjoints fln units coherence pseudo cells gamma showing satisfy commutativity diagram 
define showing commutativity diagram 
verify triangular identities show unit counit adjunction fln 
quantified arbitrary natural number 
colimiting cone hom category am gm gm gm nm qq qq gm gm fm nm ff gm nm qy jjj delta delta delta delta delta delta gm gm fm obtains colimiting cone chain element removed gm fm gm gm fm delta delta delta exists universal pseudo cell fm gm gm fm delta nk nk fm similarly post composing gm gn derives existence universal pseudo cell gm gm gm delta nk gn define gm fm universal pseudo cell delta nk gn fm 
local characterisation theorem follows gm delta fm gn fm delta gm particular nn nn delta jn delta nn gn fn delta jn consider cone chain hfm am am im vertex arrows nim pseudo cells fm gamma im cone phi pseudo colimit exists arrow fln pseudo cells nm fln gm nm delta fln phi fm gamma delta nm fm define def nn gamma delta nn fln deduce existence gamma fln fact phi form pseudo colimit chain hfm am am im 
describe fact family pseudo cells upsilon nm fln upsilon nm delta phi fln phi delta upsilon nm fm follow existence unique gamma fln gamma upsilon nm 
define upsilon nm observe diagram pseudo cells commutes fm gn fm phi ff fm gm gamma fm gn fm gamma ff gamma tt gm nf nm gamma fm fm gamma ff fln fm fln phi ff nfln gm gamma gm nm gamma fln commutativity leftmost rightmost squares provided equation central follows equation 
define upsilon nm bottom cell diagram upsilon nm def nm gamma delta gm gamma delta gn satisfaction condition immediately read diagram 
show commutativity diagram gamma phi delta gn fn delta jn chapter 
theory recursive domains aiming observe gamma phi fln phi delta gamma fn interchange law fln phi delta upsilon nn fn property defining gamma fln phi delta nn gamma fn delta gn gamma fn delta gn fn definition upsilon nn fln phi delta fln phi gamma delta nn gamma delta fn gamma delta gn gamma fn delta gn fn equation nn gamma delta gamma delta gn fn equation nn gamma delta nn definition nn gamma delta gamma delta gn fn delta jn equation nn gamma delta gamma delta gn fn delta gn fn delta jn definition gamma phi delta gn fn delta jn identity fact cone mim fln colimiting immediate consequence fact obtained pasting diagrams nn ff njn fn gn gn gn fn ff delta delta delta gn nn gamma ff fn gamma ks gn gamma gn fn gamma gn gamma fn ff delta delta delta ks fln fn gamma phi gn nfln fn gn gamma phi delta delta delta ks upper equation defines gn colimit lower commutes identity consists pseudo cells 
look definition suitable 
family gamma describe canonical chain hom category gives rise second canonical cone nfln phi gamma gamma gamma nfln fln 
local characterisation theorem nfln ai colimiting cone chain 
aim prove 
induce colimiting cone nfln ai construction diagram commute 
prove obtain adjunctions fln hint proving comes calculation natural number colim nfln colim nfln colim nfln colim nfln colim colim fk colim colim colim colim fact need closer look matrix particular diagonal 
sketched infinite matrix completed colimit points 
interchange law fact delta fn difficult verify xl yl xn phi gamma fk fln phi delta delta nfln phi flk phi delta chain isomorphisms diagonal matrix phi gamma fn phi gamma fn fn delta delta delta colimiting cones trivial cone inverses phi gamma pp fn phi gamma fn phi nff fn phi delta phi fn delta delta delta qy delta delta delta chapter 
theory recursive domains flk flk delta delta delta flk fk flk phi ks flk fk flk phi ks delta delta delta delta delta delta delta delta delta kgk kfk yk ks xk gk fk yk ks xk fk yk ks yk ks xk fk yk ks phi gamma fk jj yk ks phi gamma kkk kk xl delta phi gl fk yl nfln delta phi gamma gamma gamma phi gamma fk nfln delta phi gamma gamma gamma matrix cells phi gamma ff fn phi gamma fn fln phi delta fn ff fn ff delta delta delta nfln ffn tt fln ffn ff fln delta delta delta ffn px ii ii delta delta delta obtained going edges matrix 
exists universal pseudo cell delta ffn delta inverse ffn delta 
conclude existence isomorphism phi form pseudo colimit chain hfn 
local characterisation theorem show family satisfy delta phi phi delta fn deduce equality notice follows diagram fn colimit chain pseudo cells obtained chain phi gamma fn mfn fn im fn 
universality colimit consists isomorphisms prove property establish delta phi delta ffn fn delta fn phi delta fn delta ffn fn delta fn universal property defining see equation right hand side equals phi calculate left hand side delta phi delta ffn fn delta fn delta ffn delta fln phi delta fn interchange law delta ffn delta delta phi see diagram phi equation equation holds exists unique define def delta ffn nfln cone colimiting isomorphism fl ff qq ae cc cccc cccc cccc cccc cccc cccc cccc cccc cc fl ff ff fl ff rz mmmm mm delta delta delta delta delta delta delta ff expanding definition identities obtain triangular identity delta 
chapter 
theory recursive domains follows triangular identity composite fln delta nfln idempotent 
deduce second triangular identity fln delta nfln fln need show composite fln delta nfln isomorphism 
consider chain pseudo cells 
take colimiting cone fln gamma gamma fln pp pppp fln fn gamma gamma fn gamma nff fln fn gamma delta gamma fn delta delta delta qy delta delta delta fln matrix verify cone fln gamma gamma nfln ff gn gamma gamma gamma delta gn fln ff gn nfln ff delta delta delta fln nfln fln ttt fln fln fln ff fln fln delta delta delta fl px ii delta delta delta fln colimiting diagram 
exists automorphism fln fln delta nfln inverse 
implies recall order prove phi fn ai pseudo colimit hfn need show properties definition hold 
proof property order find suitable ae consider chain nfln psi gamma gamma gamma nfln fln upsilon nfln colimiting cone 
need describe family ae diagram commutes ae fk fk ae phi ff fk psi kff ae fix natural number observe matrix 
local characterisation theorem diagram psi gamma ff fk psi gamma fk flk phi delta fk ff fk ff delta delta delta upsilon ss flk upsilon ff flk delta delta delta upsilon kpx jjj delta delta delta yields colimiting cone chain psi gamma fk fk chain pseudo cells admits trivial colimiting cone inverses psi gamma fk psi gamma fk psi kff fk psi delta psi fk delta delta delta delta delta delta define ae universal pseudo cell delta upsilon delta left showing delta ae phi psi delta fk universal property colimits know parallel arrows domain ae equal edges cone 
diagram diagram isomorphisms check property edge 
observe equality holds psi gamma delta delta upsilon delta fk delta ae phi gamma delta upsilon delta fact universal property defining left hand side equality reduces immediately psi gamma 
diagram see upsilon delta upsilon delta flk phi delta fk psi gamma psi gamma fk delta upsilon fk delta fk delta psi gamma fk delta ae phi gamma delta ae phi delta upsilon fk delta fk delta psi gamma fk delta ae phi gamma delta upsilon delta flk phi delta fk psi gamma fk delta ae phi gamma delta upsilon delta chapter 
theory recursive domains psi gamma delta fk delta ae phi gamma 
composing psi left ae phi right sides equations get delta ae phi psi delta fk 
proof property suppose arrows family cells upsilon nn condition definition 
look cell upsilon upsilon upsilon recall colim nfln colim nfln colim nfln 
properties upsilon describe colimiting cones map nfln upsilon nfln ff pi lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda nfln ff ss fln upsilon fln wwww wwww wwww wwww www wwww wwww wwww wwww www 
fln gg gg 
upsilon upsilon unique cell upsilon delta delta upsilon nfln claim upsilon satisfies required property 
fact equalities obtain upsilon delta delta upsilon nfln counit adjunction fln unit sides equation obtain upsilon upsilon delta delta triangular identity delta upsilon nfln delta equation delta delta upsilon interchange law upsilon triangular identity upsilon uniquely determined property upsilon upsilon upsilon upsilon implies upsilon nfln upsilon nfln upsilon delta delta upsilon nfln interchange law delta upsilon nfln property universality colimits exists unique upsilon 
local characterisation theorem case chain cells canonical cones lil fln pseudo cells condition cones colimiting vacuous simplified version theorem corollary local characterisation cat category chain hfn gn ani pseudo cone phi fn ai chain hfn equivalent 
phi fn ai pseudo colimit hfn 
phi fn ai pseudo colimit hfn 

pseudo cone phi gamma fln fn gn fln canonical cone colimiting 
proof thing check case previous proof pseudo cells 
recall definition see equation previous proof def nn gamma delta nn fln nn pseudo cell nn edge colimiting cone gn gn gn njn nn pp pp gn gn njn fn nn ff gn nn qy kk delta delta delta delta delta delta gm case chain diagram consists pseudo cells edges pseudo cells 
familiar smyth plotkin result clear condition canonical cone ida colimiting generalises analogous condition theorem asserting nfln 
dual results theorem corollary respect limit op chain gn obviously hold provide corollary limit colimit coincidence 
corollary limit colimit coincidence cat category equivalent chain adjunctions fn gn ani pseudo cone adjunctions phi gamma fln fn gn fln chapter 
theory recursive domains 
phi fn ai colimit hfn 

gamma fln ani limit ani 
corollary part categorical folklore 
main reason holds attempt direct proof suggest due fact diagrams considering chains colimits enriching categories objects cat functors induced preserve 
fact pointed pino rosolini 
analysis statements proofs theorem corollary suggests possible generalisations chains classes filtered diagrams satisfying certain closure properties 
expand possibility 
seen cf 
proposition adjoint pairs cocont correspond functors cat deduce way calculating pseudo colimits chains cocont 
proposition fn gn ca chain 
chain hfn ca pseudo colimit cocont 
proof sketch known fact full embeddings cat 
cocont 
yd small categories extend pseudo functor locally full embedding cat 
cocont preserves pseudo colimits 
chapter proved proposition equivalence categories cat add equivalence colimit preserving functor presheaf categories right adjoint cf 
section 
chain adjoint pairs hfn gn ca consider associated chain functors hhn cn cn ha kn cn colimit cat chain hn 
ca ba phi fn colimit preserving functors natural transformations induced equivalences ca gamma ca cn cf 
proposition cat 
cocont 
families phi forms pseudo colimit chain hfn ca 
coherence reminder chapter sub category cocont play role respect analysis open map bisimulation mind 
definition define sub category cocont objects cocont cells monomorphic natural transformations arrows colimit preserving functors preserve monomorphic natural transformations 
category cat category 
proposition construction outlined proof proposition produce pseudo colimit chain arrows coherence far proved results concerning cat categories 
order results directly applicable prof extend hold bicategories cat property 
way doing means coherence results 
roughly speaking results state isomorphism situation replaced strict losing property interest 
category theory literature abounds examples results 
notable mac lane coherence result monoidal categories see 
primary importance theorem see bicategory pseudo equivalent category 
definition cat bicategories cat bicategory bicategory cat property bicategory objects hom category colimits chains composition functors preserve 
similarly defines cat bicategories 
theorem key result prove theorem cat bicategory cat bicategory pseudo equivalent cat category cat category 
proof case cat analogous 
cat bicategory pseudo equivalent category exists theorem 
show fact cat category 
pseudo equivalence pseudo inverse 
pseudo equivalence locally equivalence categories objects object cat cat property 
left showing composition functors cat functors 
chapter 
theory recursive domains trivial objects natural isomorphism theta theta fflffl oo theta cb oo ck cb composition functors respectively 
composition functor naturally isomorphic functor preserves colimits chains preserves colimits 
observe fact proved pseudo equivalence preserves cat property example prof pseudo equivalent cocont cat bicategory 
pseudo limits preserved pseudo equivalences result telling statements theorem corollary corollary generalised cat bicategories 
course imply extra care especially treating notion adjoint arrows bicategory 
section shall develop freyd notion pseudo algebraically complete compact categories 
results help simplifying proofs pave way possible generalisation concepts results include bicategories 
john power pointing theorem consequence results 
theorem category category kq pseudo equivalence kq category composing induces pseudo equivalence categories kq hom kq category functors kq pseudo natural transformations modifications hom category pseudo functors pseudo natural transformations modifications 
means pseudo functor categories exists equivalent functor kq fact useful simplifying proof theorem 

pseudo algebraic compactness definition pseudo cat functors pseudo functor regarded categories pseudo cat functor objects functor fa preserves colimits chains arrow cat 
similarly pseudo cat functor preserves initial objects 
propositions immediate consequences definitions abstraction level 
proposition pseudo equivalence cat categories cat categories pseudo cat functor cat functor 
proposition equivalent pseudo functors hom pseudo cat functor cat functor preserves pseudo colimits chains 
pseudo algebraic compactness algebraic compactness notion due freyd canonical fixed points endo functors mixed variance 
common categorical analysis fixed point theorems notion fixed point replaced robust notion initial prefixed point 
fact lemma due lambek category endofunctor initial algebra isomorphism 
dually hold final coalgebra motivates definition algebraic completeness refining step treatment mixed variance functors compactness 
definition functor 
define category algebras alg consist objects arrows arrows arrow arrow square commutes fflffl initial algebra initial object gamma alg 
dually defines category gamma coalg coalgebras final coalgebra terminal object gamma coalg 
chapter 
theory recursive domains lemma lambek functor initial algebra isomorphism definition algebraic completeness category algebraically complete endofunctor initial algebra 
algebraically endofunctor initial algebra final coalgebra 
freyd remarks giving definition phrase endofunctor understood categorical sense refers chosen class functors 
fiore phd thesis tackles considering enriched case defines algebraically complete categories :10.1.1.17.9542
presentation results definitions take relaxed view freyd concrete cases shall explicitly mention class functors referring 
final coalgebra endofunctor isomorphism initial algebra exists unique arrow square commutes fflffl gamma freyd call canonical morphism algebra coalgebra definition algebraic compactness category algebraically compact algebraically canonical morphism initial algebra final coalgebra isomorphism 
immediate consequence definition lemma freyd algebraically compact category inverse initial algebra final coalgebra vice versa 
category algebraically compact mixed variance functors particularly behaving fixed points satisfying minimal invariance property see 
theorem freyd algebraically compact category 
cop theta functor 
exists isomorphism satisfying universal property objects morphisms exists unique pair morphisms gamma gamma 
pseudo algebraic compactness squares commute fflffl fflffl fflffl gamma call free dialgebra properties free dialgebras 
interested fixed points equivalence isomorphism need notion pseudo initial algebras cf 
pseudo algebraic completeness compactness 
definition pseudo initial algebras pseudo initial algebra category algebra satisfying universal property 
algebra exists fflffl 
fflffl fflffl exists unique cell delta delta delta delta phi phi delta delta xt observe universal property immediately follows pseudo cell 
lemma pseudo lambek pseudo functor pseudo initial algebra equivalence sense exists ba ab chapter 
theory recursive domains proof consider algebra universal property pseudo initial algebras exists fi fi fflffl unique cell ab ab tb fi fflffl fflffl fflffl ab ata fflffl clearly unique pseudo cell ab 
show ba observe ba ab isomorphism fi 
terminology equivalence category call ba ab pseudo inverse immediately seen pseudo inverses isomorphic 
dual statement pseudo lambek lemma pseudo final coalgebras equivalences 
pseudo final coalgebra pseudo inverse fflffl shall call canonical arrow pseudo initial algebra pseudo final coalgebra definition pseudo algebraic completeness compactness define category pseudo algebraically complete pseudo endofunctor pseudo initial algebra 
category pseudo algebraically pseudo endofunctor pseudo initial algebra pseudo final coalgebra 

pseudo algebraic compactness category pseudo algebraically compact pseudo algebraically canonical map pseudo initial algebra pseudo final coalgebra equivalence 
shall interested pseudo algebraic compactness respect pseudo 
generalisation lemma basic lemma pseudo case due marcelo fiore 
provides tool finding pseudo initial algebras pseudo functors iterating application functor starting pseudo initial object 
lemma pseudo basic lemma category pseudo initial object pseudo functor 
consider chain ht 
phi fn pseudo colimit 
phi phi tfn fn fn pseudo colimit chain ht 
mediates pseudo cones phi ni phi pseudo initial algebra 
embark generalising part definitions results chapter 
fact identify class cat categories pseudo algebraic compactness guaranteed results cf 
definition 
definition cat category pseudo initial object pseudo colimits chains 
ensure pseudo algebraic compactness need preliminary results 
theorem cat category fn gn gamma ani chain phi fn ai pseudo colimit chain fn 
pseudo cat functor ht phi tfn fn ai pseudo colimit 
proof observe means coherence results exposed section reduce assume functor pseudo functor 
fact pseudo functor theorem equivalent hom pseudo functor obtained functor kq kq 
know theorem holds functors say kq chapter 
theory recursive domains hold pseudo functors form pseudo equivalence proposition hold pseudo cat endofunctors local characterisation theorem theorem exists pseudo cone adjoints phi gamma fln jn fn gn fln canonical cones lil fln colimiting 
functors preserve adjoints pseudo cone adjoints phi gamma fln jn fn gn fln assumed cat functor preserves locally colimit chains canonical cones ht nt ht gl nt fn lil colimiting 
local characterisation theorem implies pseudo cone ht phi fn ai pseudo colimit 
proposition pseudo initial object pseudo terminal object pair arrows jj forms coreflection proof see pseudo terminal observe object non empty initial object 
arrow initial composition preserves initiality initial just arrow pseudo initial 
particular arrows initiality exists unique cell 
arrows exists initiality unique gf satisfy triangular identities universal property initial objects 
isomorphism just arrow 
closed duals products 
proposition theta 
proof proof straightforward product case 
process observe proposition immediately follows pseudo initial object 
cells reversed cat enriched chain gamma ani 
pseudo algebraic compactness derived chain gn fn gamma ani pseudo limiting cone chain provided limit colimit coincidence pseudo colimit chain op arrows 
definition pseudo cat algebraic completeness compactness cat category said pseudo cat algebraically complete pseudo algebraically complete respect pseudo cat functors 
cat category said pseudo cat algebraically compact pseudo algebraically compact respect pseudo cat functors 
theorem pseudo cat algebraically compact 
proof pseudo cat functor coreflection jj certainly exists proposition unit counit consider chain defined objects arrows fn fn gn gn unit jn counit jn def gamma fn gn delta jn delta tan fn def gamma delta delta fn fnt gn chain pseudo colimit vertex corollary cone left adjoints pseudo colimiting theorem preserved application pseudo basic lemma mediating equivalence pseudo initial algebra limit colimit coincidence dual statement pseudo basic lemma yields pseudo inverse initial algebra pseudo final coalgebra easily seen equivalent pseudo algebraic compactness 
pseudo cat functor theta free pseudo dialgebra chapter 
theory recursive domains characterised universal property fflffl fflffl fflffl uniquely canonical coherent isomorphism defined pseudo initial algebras 
corollary cocont pseudo cat algebraically compact 
definition generalised cat bicategories 
similarly pseudo equivalences related preservation properties section pseudo lambek lemma theorems propositions section restated bicategories 
shall pursue generalisation effort details 
reason concentrate remainder chapter interpretation type theory section cocont shall see prof recursive types results previous sections extend type theory section recursive types parametrisation result cf 
theorem definition 
theorem pseudo cat algebraically complete compact categories theta pseudo cat functor 
write ta object part chosen pseudo initial algebra endo pseudo functor ta defined freezing component object mapping ta extends canonically pseudo cat functor gamma proof proof fact relies analysis properties canonical arrows initial algebras algebra cf 
chapter 
details appendix 
recursive types check pseudo functors involved giving semantics type theory section pseudo cat functors straightforward calculation 
proposition pseudo functors omega gamma lambda gamma gamma 
pseudo 
notation theta pseudo functor 
write theta lop theta defined objects 
clearly ss ss lop theta projection second component 
consider term type theory section extended recursive types 
need provide definition theta theta cocont theta cocont theta set variables including free ones assume theta cocont theta theta cocont theta cocont theta 
define theta ss gamma gamma defined theorem 
examples revisited back examples chapter understand terms uniform fixed points endofunctors cocont give solutions domain equations 
ch 
ch 
stands 
ch 
ch 
ch 
ch theta 
stands 
ch 
ch theta point shall clarify reason equations reduce look solution poset locally ordered category partial ordered sets monotone functions ordered pointwise 
due property embedding poset 
cat takes poset regards category arrow objects elements poset exactly elements order relation 
jargon category called partial order category 
property particularly useful purposes 
chapter 
theory recursive domains proposition category poset small sums small filtered colimits embedding poset 
cat preserves 
corollary cat cat endofunctor preserves colimits chains partial order category partial order category 
exists functor poset poset square commutes poset fflffl poset cat gamma initial algebra initial algebra proof thing note preserves colimits chains initial algebra calculated colimit standard chains obtained iterating starting empty category poset filtered colimit 
poset colimits fact cocomplete category locally finitely presentable preserved embedding cat counterexample learned peter selinger shows 
example consider pair parallel arrows element poset elements respectively pick bottom top element name suggests 
coequaliser pair regard partial orders categories coequaliser monoid natural numbers regarded object category 
clearly cat functors model type theory exponential take partial order categories partial order categories 
looking solution domain equation involving find poset transfer cocont embeddings poset 
cat 
prof cocont cf 
proposition 
relational structures chapters shall consider examples concurrent process calculi give presheaf semantics 
doing want results previous sections study open map bisimulation domain theoretical point view style 
idea equip cat categories relational structures 
admissible relational structure 
relational structures cat category induce grothendieck construction cat category fk rg objects pairs fa rg consisting object relation drawn partial order admissible relations 
important result fk rg 
focusing particular relational structures cocont carry study bisimulation 
particular extra intensional information provided presheaf categories give domain theoretic characterisation bisimulation arbitrary trees 
having defined relational structures carry study induced induction coinduction principles 
definition define cppo lambda category possibly large posets op pointed element complete upper bounds chains monotone functions op op strict element preserving continuous monotone upper bound chains preserving 
definition relational structures relational structure category functor cop 
cppo lambda order relation usually denoted subset symbol ae 
object top element written 
admissible relational structure cat category relational structure ordinary category underlying 
pair morphisms 
morphism element initial 
chain colimit ae fn implies ae 
cppo category pitts relational structure admitting inverse images intersections relation admissible defined admissible relational structure sense vice versa require general preserve greatest lower bounds 
notation relational structure arrow write ae ae admissible relational structure cat category induces category relations definition admissible relational structure cat category cat category relations fk rg objects pairs fc rg chapter 
theory recursive domains hom categories fk rg fa rg fb sg defined full subcategory consisting ae identities compositions fact partial orders regarded categories definition example grothendieck construction recalled section 
theorem proved theorem fiore admissible relational structure cat category forgetful functor fk rg projects pair component faithful cat enriched creates pseudo initial objects pseudo colimits chains 
theorem allows deduce relational structure induced category relations 
corollary admissible relational structure category relations fk rg 
said shall concerned certain specific relational structures cocont defined 
definition 
admissible extensional relations ext defined follows 
small category ext complete meet semilattice relations bc implies pair chains monomorphisms colimits respectively xn yn relations ordered inclusion action ext morphisms inverse image ext bc theta bc jj sg 
admissible intensional relations cocont int defined follows 
small category int complete meet semilattice intensional relations bc triple isomorphisms implies gamma gamma 
coinduction bisimulation span natural transformations chains colimits respectively xn gamma wn qn gamma yn poo colim intensional relations ordered inclusion action int morphisms inverse image int fx gamma gamma bc gamma gamma sg 
relational structure cocont induces relational structure lambda lambda def op lambda def bc bd dd op dc op defined extending corresponding cf 
section example 
coinduction bisimulation theorem derive induction coinduction principles recursively defined domains 
coinduction principle prove coinduction property bisimulation show relational part free pseudo algebra category relations fk rg maximal bisimulation 
eye applications cocont see section consider separately case covariant functors mixed variance ones requiring notion category cf chapter 
covariant functors notation admissible relational structure pseudo cat functors diagram fk rg fflffl fk rg commutes forgetful functor write tr place fa rg 
similarly shall write fa rg 
consequence theorem chapter 
theory recursive domains proposition admissible relational structure consider pseudo cat functors diagram fk rg fflffl fk rg commutes denotes forgetful cat functor 
free pseudo algebra fold unfold exists necessarily unique delta fold fd delta fd delta unfold free pseudo algebra 
proof results previous sections know equivalent vertex pseudo colimit chain delta delta delta pseudo initial object 
theorem exists delta fd delta pseudo colimit 
tr 
delta delta delta delta unique partial order set 
proposition induction coinduction principles hypothesis proposition free pseudo algebra fd delta enjoys induction coinduction principles expressed rules ffl tr ae delta ae ffl ae tr ae delta proof rules immediate consequence universal properties free algebra fold fd delta fd delta unfold look rule case analogous 

coinduction bisimulation fold fd delta gamma fd delta pseudo initial algebra algebra tr 
exists delta 
delta fold fflffl delta fflffl tr algebra definition tr ae arrow delta 
delta ae rule justified 
definition fold fd delta gamma fd delta free algebra 
define relation bisimulation satisfies condition unfold ae tr proposition hypothesis proposition delta bisimulation 
say fact establish coinduction property cf 
establishes delta maximal bisimulation 
proposition hypothesis proposition delta fr proof proposition delta bisimulation 
satisfies coinduction principle proposition unfold ae tr unfold ae delta unfold isomorphic ae bisimulation 
mixed variance functors treat mixed variance functors consider pseudo categories viz 
categories self dual pseudo involution see 
definition pseudo category pair category pseudo functor ffi oop 
main example provided cocont 
example category cocont pseudo involution gamma prof op gamma lambda gamma prof gamma cocont chapter 
theory recursive domains definition pseudo 
admissible relational structure induces composition admissible relational structure ro ro def oc ro def cf 

observe relational structure point definition obtained construction involution example 
proposition admissible relational structure consider pseudo cat functors theta diagram rog theta fk rg theta fflffl rog theta fk rg theta theta theta commutes denote forgetful cat functors 
free pseudo dialgebra fold unfold exist necessarily unique delta od delta unfold fold fd delta fd delta fd delta fd delta fold unfold free pseudo algebra 
proof hint proof proposition ro theta admissible relational structure theta induction coinduction principles proposition assume general form deducible directly form universal property free pseudo dialgebras cf 
theorem 
proposition situation proposition fa fa rg ft ft tr delta od delta satisfy rules ffl oa ae tr ae delta ae delta ae ffl oz ae ae tr ae delta ae delta 
open map bisimulation coinduction properties bisimulations respect pairs relations 
definition define bisimulation pair od theta fold ae unfold ae tr defining property pair delta delta immediately seen bisimulation coinduction principle maximal 
proposition hypothesis proposition pair delta delta bisimulation satisfies coinduction property delta delta open map bisimulation coinduction properties results previous sections study open map bisimulation presheaf categories 
consider relational structures definition defined cocont lift interpretation suitable restrictions type grammar section extg intg lambda theta intg 
extensional relations proposition pseudo functors omega gamma pi gamma 
restricts discrete category 
proof thing needed check colimit monomorphism preserving functor bc bd indexed family fi cc cd functors bv omega pi fi 
monomorphism preserving 
bv omega bv omega omega qv jvj bc jvj jvj bd omega defined cf 
chapter bv omega jvj hf xv iv jvj bv omega jvj hf ffv iv jvj jvj qv jvj bc jvj natural transformation 
bv omega preserves monomorphic natural transformations fi sum defined componentwise trivially preserves 
chapter 
theory recursive domains 
cc 
cc defined px bf xjx objects 
ff gamma cc ff uniquely determined ff 


family xjx gamma 
natural transformations bc particular ff monomorphism ff 
injective map monomorphic natural transformation 
ff natural transformation determined ff 

preserves monomorphisms ff monomorphism ff monomorphism 
consider fragment main type structure pi ti previously provided semantics types prof know equivalent giving cocont get mixed variance pseudo functors theta cocont theta cocont type constructors fragment non trivial situation contravariant part play significant role fact case denotation assumed discrete category def vop theta theta category simplicity discard contravariant components assume interpretation range pseudo cat functors theta theta cocont proposition restrict theta theta jm wish lift interpretation act extg want interpret type free variables theta pseudo functor theta theta extg suffices describe action constants sum lifting discrete function space extends extg 
inductive types case taken care results section extg pseudo cat algebraically compact corollary theorem 
sums consider presheaf pi projection 
open map bisimulation coinduction properties presheaf obtained restriction fa rig def fp rg def ri easy check extension defined fi ri ae si fi ri ae si lifting consider presheaf 
saw chapter decomposes sum px presheaf xjx ba component subtended element gamma functor puts root presheaf 
section transition relation presheaves 
ba write 

xjx 
obvious way extend lifting relations relation presheaves define 
relation presheaves 
iff 



unfortunately relation 
may fail satisfy admissibility requirement definition admissible extensional relations lies ext 
define 
iff chains monomorphisms colimits respectively xn 
yn 
define fa rg 
def fa suppose ae extg 
colimit sum preserving follows 

ae 
proposition admissible extensional relation 
admissible extensional relation 
proof clearly thing check satisfaction admissibility requirement 
say presheaves category compatible arrow compatible presheaves possible define union operation union sets pointwise 
easy see 
satisfies closure property respect union compatible presheaves 
chapter 
theory recursive domains 

compatible compatible 
suppose chain monomorphisms ca colimits respectively xn 
yn 
loss generalities assume natural transformations involved taken monomorphisms chains pointwise inclusions 
definition pair xn 
yn chain generated colimit chain monomorphisms pointwise inclusions presheaves 
matrix natural inclusions 


delta delta delta delta delta delta 
fflffl 


delta delta delta delta delta delta 
fflffl 


delta delta delta delta delta delta 
fflffl delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta wish deduce 
arrows inclusions presheaves compatible 
easily verified colimit chain inclusions gamma 
similarly closure property quoted 
definition 
known fact bisimulation close arbitrary trees known example reported example shows fact reflected 
satisfying admissibility requirement 
restricting suitable class presheaves analogous finitely branching trees 
coincide 
having open map bisimulation closing 

open map bisimulation coinduction properties definition locally finite presheaves presheaf small category said locally finite object set finite 
locally finite presheaves satisfy admissibility property respect open map bisimulation 
lemma small category 
chains monomorphisms bc colimits respectively 
locally finite xn yn open map bisimilar proof loss generality assume monomorphic natural transformations involved chains pointwise inclusions sets 
span surjective open maps generates definable sub presheaf product related presheaves page 
hypothesis assume exists sub presheaf xn theta yn zn projections xn zn yn surjective open maps 
object define theta zn immediately seen defines sub presheaf theta check projections surjective open maps 
look projection ss case analogous 
need check square quasi pullback ss fflffl fflffl ss suppose assumption projection zn xn open definition exist infinitely zn 
exists yn yn yn zn finite includes yn exists appears infinitely pairs 
concerning surjectivity exists number xm 

zk xk surjective map exists ym ym zm 
finite includes yk exists appears infinitely pairs 
result generalises larger cardinals sense statement valid replaces chains chains assumes locally size assumption chains consist monomorphisms crucial example due glynn winskel shows restriction considering extensional relations 
chapter 
theory recursive domains example presheaf partial order category 
tree defined lambda fa bg fcg 
actions arrows uniquely determined cardinality associated sets 
consider chains delta delta delta delta delta delta fn identical corresponding presheaves chains bisimilar colimit colimit second string lambda clearly bisimilar proof similar lemma show relations 

coincide locally finite presheaves 
lemma locally finite presheaves 
suppose chains monomorphisms colimits respectively 
xn 
yn 
consequently 

example consider synchronisation tree recursively defined tree consisting single branch infinite length transitions labelled define tree consisting single branch length transitions labelled define pn 
pn 

define uk pn 
amin vk ak pn 
amin 
clearly colimit uk colimit vk 
uk bisimilar vk bisimilar infinitely long branch branches finite 
discrete function space presheaf corresponds functor ba write xv presheaf resulting functor application define fa rg def def xv extension defined ae ae 
open map bisimulation coinduction properties structural induction closed type grammar associated extensional relation ext 
recursive types interpreted parameterised free pseudo algebras extg specialising pseudo colimit construction pseudo basic lemma theorem 
relation coincides open map bisimulation locally finite presheaves 
theorem closed type grammar 
locally finite presheaves 
iff open map bisimilar 
proof proof proceeds structural induction write sg relation fa sg extg satisfies condition locally finite presheaves open map bisimilar induction hypothesis type judgement delta delta delta take delta delta delta ok delta delta delta fa delta delta delta fa checked constructions lifting sum discrete function space preserve ok property relations 
covers cases induction recursive types 
consider relation interpreting recursively defined type theta fa delta delta delta fa theta sj theta jg environment assume delta delta delta theta sj theta jg relation pseudo colimit fd rg chain fd rng fd def gg fd rn def theta fa delta delta delta fa theta sj theta rng structural induction hypothesis induction shows rng stage suppose projecting rn locally finite fln part coreflection 
open map bisimilar injecting obtain chains monomorphisms bd pseudo colimits maps preserve open map bisimilarity xn yn open map bisimilar meet conditions lemma conclude open map bisimilar 
results section obtain characterisation 
chapter 
theory recursive domains corollary type grammar extg extg interpretation 
presheaves equivalent ffl ffl bisimilar defined definition 
locally finite equivalent statement ffl open map bisimilar 
examples 
pa 
saw cf 
chapter section synchronisation corresponds presheaves admissible version park milner strong bisimulation 
specialises usual strong bisimulation locally finite presheaves finitely branching trees 
corollary bisimulation locally finite presheaves strong bisimulation 
locally finite presheaves 




recall domain value passing late semantics obtained 
pa ch 
pa ch 
sums channels ch values winskel restricted class processes language requiring recursive definitions guarded 
process denoting locally finite presheaf 
corollary bisimilarity locally finite presheaves corresponds open map bisimilarity shown late bisimulation presheaves process terms denote locally finite presheaves relation holds denotations closed terms iff late bisimilar traditional sense 
treatment coincides usually adopted operational semantics process languages provided restrict finitely branching processes denotations locally finite presheaves 
expect extend treatment countably branching processes denotations locally countable presheaves generalise results colimits colimits 
follow pioneering countable nondeterminism described 
course greater degree branching require larger cardinals 

open map bisimulation coinduction properties began explore possibility enlarging class models include colimit completions restricted form retaining preservation properties colimit preserving functors respect open map bisimulation 
restricted forms cases directly provide classes structures bounded degree branching 
intensional relations take larger fragment grammar section 
consider fact extension grammar pi ti 
omega lambda obtained adding tensors duals give interpretation types pseudo cat functors theta int lambda theta intg theta int lambda theta intg gamma operator cf 
sections obtain theta theta cocont theta gamma theta cocont theta theta cocont theta gamma cocont order lift category relations suffices show sums lifting tensor extend pseudo cat functors 
sums indexed family relations hri int ri int follows span pi ri iff restriction ri 
interpretation pi ti done pseudo cat functor int lambda theta intg jij int lambda theta intg sending fa ig fa rig fpi pi ig fpi pi rig 
lifting consider presheaves decompositions 

chapter 
theory recursive domains xjx presheaves natural transformation know uniquely identified 


xjp iw 
ba int define 
int follows 
span 
iff span 
gamma 
gamma 
consists surjections span xjp jw jq int op define 
int op follows 
span 
iff writing canonical inclusion 
span lambda lambda lambda naturality squares 
fflffl oo fflffl oo 
fflffl 
fflffl quasi pullbacks 
interpretation 
uses pseudo cat endofunctor int lambda theta intg int lambda theta intg sending fa fa rg fa 
fa 
tensor int int 
span omega defined omega iff gamma gamma gamma gamma gamma gamma interpretation omega pseudo cat functor int lambda theta intg int lambda theta intg sending fa fa rg fb fb sg fa omega omega fa omega omega sg 
interpretation gamma lambda pseudo cat endofunctor int lambda theta intg int lambda theta intg sending fa fa rg fa op rg fa op 
closed type grammar associated intensional relations ss int int op int proof similar shown coincide open map bisimulation 

open map bisimulation coinduction properties theorem closed type grammar 
ss int sos op sos denotes class surjective open spans bc corollary type grammar int lambda theta intg int lambda theta intg interpretation 
sos fr strong bisimulation revisited 
intensional relations capture strong bisimulation arbitrary trees domain theoretic setting 
fact equation synchronisation trees pa corollary trees connected span connected span surjective open maps strong bisimilar 
far know domain theoretic characterisation strong bisimulation arbitrary trees 
chapter 
theory recursive domains chapter presheaf models ss calculus chapter go back concrete examples address issue giving presheaf models ss calculus 
contrast examples process languages seen far cf 
chapter ss calculus ability communicating channel names express processes communication topology changes time computation evolves 
domain theoretic models partial orders characteristic tackled semantically indexing category domains category finite sets channel names take similar approach index prof result process terms interpreted indexed families presheaves 
open map bisimulation fibre correspond bisimulation language open map bisimulation fibre correspond largest congruence included bisimilarity 
shall mainly deal model ss calculus late bisimulation shall show gets early bisimulation domain theoretic model able capture arrow models mapping late interpretation early arises context 
exist different variants ss calculus people concentrate fragments 
shall consider full calculus 
means possible fragments wish consider modelled directly model cases possible describe simpler domain equations provide models tailored special fragment considering come embedding maps restricted model general 
ss calculus version ss calculus entirely standard 
summarise briefly discussion detail see original papers 
processes chapter 
presheaf models ss calculus syntax xy ranging infinite supply names 
note include match operator unguarded sum unguarded replication selection fairly arbitrary model copes equally mismatch processes defined recursion guarded unguarded 
similarly difference restrict popular subsets asynchronous ss calculus 
simplify presentation identify processes structural congruence smallest congruence relation satisfying fn fn denotes capture avoiding substitution may course require turn ff conversion subexpressions 
equivalence aggressive structural congruence say definition allows name restriction gamma change scope 
cuts operational rules shall need matching replication 
degree matter taste treat process terms concrete syntax structural identification model valid 
completeness model allows read fact ff conversion commuting forth respect bisimilarity replacing example proofs theorems 
operational semantics processes transitions kinds internal silent action input free output xy bound output 
denote general transition ff define free bound names fn fn xy fx yg fn fn fxg bn bn xy bn bn fyg transitions process may perform inductively rules 
late semantics input substitution happens com rule communication occurs cf 
section 
chief difference rules table structural congruence 
symmetric forms right hand rules processes ff converted interact 
course possible transitions derived exactly original definitions 
definition symmetric relation processes bisimulation conditions hold 
ffl ff xy ff gamma exists ff gamma 
indexing prof xy xy gamma sum ff gamma ff gamma gamma par ff gamma ff gamma bn ff fn res ff gamma ff gamma fn ff com gamma xz gamma gamma open xy gamma gamma close gamma gamma gamma transition rules ss calculus processes ffl gamma exists gamma name processes strong late bisimilar bisimulation relating 
check second condition definition necessary ranges free names fresh name 
bisimilarity relation strong actions match late input actions match transmitted value known 
bisimilarity preserved process constructors input prefix bisimilarity assumes names distinct substitution happens input cause names identified 
definition identifies largest congruence included bisimilarity 
definition define processes equivalent bisimilar possible name substitutions 
indexing prof ss calculus process evolves ambient set channel names set names publicly available change 
fact names distinct certain stage get identified new names created public 
take account fact index prof category name sets 
definition define essentially small category finite sets injective functions 
notation finite set shall write generic set obtained adding new element set new element normally indicated lambda chapter 
presheaf models ss calculus omitting subscript necessary 
similarly arrow write function acts element maps lambda lambda 
arrow im write injective function acting elements mapping lambda definition define prof bicategory pseudo functors prof pseudo natural transformations modifications 
recall give pseudo functor prof give indexed family jij small categories coherent families profunctors shorten presentation effort building experience previous chapters shall intentionally gloss coherence details chapter 
shall talk functors natural transformation commutative diagrams precise talk pseudo functors pseudo natural transformation diagrams commuting isomorphism 
similarly giving definitions bother explicit checking necessary coherence conditions met enforced universal property left kan extensions 
usual functor categories structure prof extends prof particular theta omega gamma lambda extend pointwise 
imply symmetric monoidal closed structure prof lifts prof fact open question example know prof closed small pseudo colimits equivalently pseudo limits sufficient condition imply closed structure lifts prof 
anyway exist linear function spaces special objects yoneda lemma need model ss calculus 
definition prof pseudo functor takes gamma gamma pseudo functor return set regarded discrete category 
action gamma arrows composition 
lemma yoneda prof pseudo functor finite set prof proof recall prof category pseudo natural transformation modifications 
means object prof cf 
yoneda lemma enriched setting 

indexing prof family squares ffs iffi gamma fflffl ffi fflffl ff satisfying usual coherence conditions 
discrete category ffs uniquely determined family xi presheaves 
isomorphism ff iffi gamma fflffl ffi fflffl ff xi yj family identified ffs 
isomorphism ff uniquely determined ffs choice presheaf 
similarly modification coherent family natural transformations ffs gamma fis uniquely determined difficult verify functor mapping pseudo natural transformation ff ffs modification equivalence categories prof gamma da lemma cf 
candidate function space prof gamma omega meaningful exhibit actual presheaf 
conveniently case kind function space shall need 
definition object names define prof functor regarded discrete category ys chain embeddings 
set 
cat 
prof chapter 
presheaf models ss calculus turns involved expression sense prof gamma omega expressible presheaf category 
definition pseudo functor prof define theta ae gamma im lambda theta objects sum represented pairs lambda 
proposition pseudo functor prof finite set prof gamma omega proof observe theta theta theta theta means presheaf family presheaves indexed plus presheaf 
similarly arrow presheaves family natural transformations ffx da plus natural transformation fi 
look information needed order identify object prof gamma omega 
definition family squares theta fs iffi gamma theta fflffl fi fflffl theta satisfying usual coherence conditions 
necessarily unique fs fs 
indexing prof im fs lambda 
inclusion 
words uniquely determined isomorphism gamma lambda difficult observations provide equivalence theta prof gamma omega notation objects seen loosely elements graph function 
write object theta component name object component write lambda similar spirit inject presheaf da left component presheaf right component lambda 
notation action written 


component theta lambda 

im 
lambda 
component 
notation action 
characterised follows 
lemma injective function finite sets 

xx lambda 
lambda presheaf 
isomorphic tox 

xx im 

lambda lambda 
lambda proof proof lemma coend calculation xx 
chapter 
presheaf models ss calculus lambda lambda 
considered possible shapes 
xx lambda im 
lambda 


xx im 
lambda lambda 
lambda 

xx im 

lambda lambda 
lambda creation new names handle creation new names shall construction prof cf 
ffi prof gamma prof functor takes gamma ffia ffia action pseudo natural transformations modifications trivial simply rearranges indexing structure ffif fs ffif fi analogous construction terms computational monads stark insists universality presents form function space arising day construction monoidal structure disjoint union sets 
regarded way ffi represents functions accept new name input 

indexing prof tensor presheaves analyse detail family bifunctors lambda bp theta bq gamma theta instance met chapter section 
action definition omitting sub indices lambda theta lambda fp theta gq categorically easy calculation shows seen right adjoint colimit preserving functor obtained kan extending ssq theta defined objects yp ip yp iq ip iq inclusion functors similarly express action morphisms 
lambda preserves colimits argument arguments time 
proposition small categories functor lambda bp theta bq gamma theta defined preserves colimits argument bq functor lambda defined gamma gamma bp theta bq lambda gamma theta preserves colimits bp similarly bp functor lambda preserves colimits bq proof prove show pair bp lambda theta lambda yp colimit preserving functors presheaf categories correspond left kan extension yoneda embeddings want show lambda left kan extension restriction 
express left kan extensions coend formula preservation coends product density formula section lambda yp theta yp theta chapter 
presheaf models ss calculus theta yp theta theta colimit preserving functors preserve open maps corollary consequence proposition corollary corollary small categories functor lambda bp theta bq gamma theta defined preserves surjective open maps surjective open maps bp bq respectively lambda surjective theta open map 
observe action lambda derived monoidal structure prof fact diagram theta bq lambda fflffl theta prof theta oo prof theta prof omega prof theta theta oo lambda realised terms monoidal structure prof lifts pointwise prof observe lambda arises left kan extension 
proposition small categories lambda yp theta equation derive indexed family ss calculus path object prof solving equations 
omega omega 
omega ffip 
omega 
unfolding components represent silent action free output bound output input respectively 
give solution equation stages 
equation describe recursively set corresponding path category specify inductively arrow connects injective function describe inductively coherence isomorphisms 
descriptions constructors ffi think family gamma recursively described 
theta theta 
theta 
theta theta 
category poset fact forest trees 
ffl kinds root lambda 
ffl order relation find respectively lambda lambda lie 
object object 
arrows set rules 
lambda lambda 

lambda qo lambda lambda lambda lambda partial order give inductive structure objects definition action gamma morphisms define prefixing functors extend prefixing notation definition objects 
definition assume fixed finite set suppose usual cf 
section write lambda bc cc embedding takes presheaf rooted presheaf bxc 
ffl ff inff 
inclusion 
appropriate component 
define prefixing functor ff def inff lambda dp gamma dp ffl inx lambda 
inclusion 
appropriate component 
define prefixing functor lambda def inx lambda lambda gamma dp chapter 
presheaf models ss calculus ffl inx 
theta 
inclusion functor sending 

lambda define 
def inx lambda theta gamma dp corollary proposition proposition sufficient deduce functors preserve surjective open maps 
proposition prefixing functors definition preserves surjective open maps open map bisimulation 
elementary characterisation shows doing expected 
proposition ffl functor ff dp dp action objects described ff ff ff 
ffl functor 
dp action objects described lambda lambda lambda 
ffl functor 
theta gamma dp action objects described hf xi 
lambda represent presheaves theta pairs hf presheaf 
equation proof show proof set functors 
calculation cases proceed analogously 
recall ff def inff lambda bxc theta consider cases 
ff chain bijections continues ff bxc rooted 

ff chain continues theta yp bp ff bxc bp density formula full faithfulness lambda 

case 
coend empty set 
notation fact presheaves theta shall move giving notice back forth representation pairs hf lambda dp defined def def xx def def lambda sums 
xx lambda 
lambda prefixing functors give description action gamma morphisms 
induction structure objects 
base cases minimal paths go regarded yoneda presheaves lambda lambda 
inductive steps lambda lambda 

lambda 
lambda 
non trivial action fill input behaviour receiving names im 
chapter 
presheaf models ss calculus concerning coherence isomorphisms clear form definitions yp coherence isomorphism pi ji defined inductively follows 
base cases just equality inductive steps pi pi pi ji ji pi pi lambda ji lambda pj pi ji ji 
pi pi lambda ji decomposition result chapter wish take advantage decomposition results define transition relations presheaves shall deduce denotational semantics late bisimulation terms coincides open map bisimulation denotation 
proposition set category isomorphic 


theta 
proof proof trivial consequence obvious general fact 
category set isomorphism theta expression theta set identified discrete category objects elements seen chapter presheaf lifted category decomposed 
isomorphism family small categories indexed set presheaf pi written omitting obvious inclusion functor xi xi presheaf combining proposition recalling characterisation prefixing functors proposition 
equation theorem decomposition presheaves dp 
isomorphic top pj pk lambda lambda pl lambda defined recursively objects described simultaneous induction derive inductive description resumptions categories associated path object cf 
definition 
proposition finite set holds base cases ffl 
ffl 
ffl lambda 
ffl 
theta 
inductive steps ffl 
ffl 
ffl lambda 
ffl 

ffl lambda 

presheaf element xjx presheaf unique presheaf theta 
decomposition theorem case shall write xjx component xjx associated xjx lambda component 
consequence theorem preservation property resumptions respect decomposition theorem 
proposition presheaves surjective open map 
restrictions surjective open fji xji yji fo fjj xjj yjj fx xjk yjk lambda fx lambda fjl xjl 
fx fjl lambda xjl lambda 
lambda fx fjl fjl lambda components fjl isomorphism theta theta chapter 
presheaf models ss calculus decomposition theorem characterise action 
presheaves 
lemma injective function finite sets hold 




lambda lambda 

xy lambda lambda xw xy lambda 
proof 
definition ino lambda paths give empty contribution lambda lambda colimit connected preserves connected colimits lambda 
similar calculation 

idem 

xy lambda definition inx rh xy lambda paths give empty contribution xy lambda ic lambda 
xy lambda ic lambda colimit connected 
preserves connected colimits lambda bh xy lambda ic xy lambda lambda lemma 
immediate consequence left kan extensions preserve sums theorem injective function finite sets presheaf pj pk lambda lambda pl lambda 
equation isomorphic presheaf xi pj xj pk lambda lambda xk pl lambda defined lemma 
transition relations presheaves indexed late bisimilarity decomposition result define indexed transition relations presheaves 
chapter elements presheaves induce extra information transition arrows 
ccs turns necessary definition presheaf say ffl gamma exists xji 
ffl gamma exists xjj 
ffl lambda gamma exists lambda xjk 
ffl gamma hf exists hf lambda transition relation natural define late bisimulation relations presheaves 
definition late bisimulation family rs symmetric binary relations presheaves dp finite name set presheaves rs gamma gamma rs gamma gamma rs lambda gamma lambda gamma rs gamma hf hg gamma hg rs rs say dp late bisimilar iff rs late bisimulation rs lemma late bisimilarity equivalence relation 
chapter provide language conjecture extra information vital order characterise operationally open map bisimulation 
chapter 
presheaf models ss calculus proposition show late bisimilarity corresponds exactly open map bisimilarity 
lemma suppose presheaves 
surjective open map late bisimilar 
ii rs late bisimulation rs related span surjective open maps 
proof 
define rs follows rs iff exists surjective open map late bisimulation follows directly proposition assumption rs 
suppose rs late bisimulation define pair presheaves rs sub presheaf product 
theta projections surjective open maps 
definition za inductively structure path objects goes follows za rs za rs za lambda rs bjk za rs lambda jl rs lambda jl za theta za theta za lambda bjk theta lambda lambda za 
za jl jl theta 
za lambda 
za lambda lambda jl theta lambda 
need show za presheaf paths element za theta za straightforward inductive proof rules define partial order relation path objects case example shows 

equation za definition theta inductive hypothesis holds aji theta definition aji definition aji theta theta theta definition za theta za shall check projections ssa za ssb 
surjective open maps 
surjectivity symmetry concentrate projections 
proof goes induction structure path objects exemplify considering case similar 

path object 
want show exists za 
definition exists 
rs late bisimulation exists rs 
inductive hypothesis ay jl surjective exists za jl jl definition means za 

proof projection open done induction rules defining partial order relation paths case example shows 
want deduce square quasi pullback za def theta ssa za fflffl ajj fflffl za def theta ss pj ajj inductive hypothesis summand diagram square fflffl ajj ajj fflffl ss ajj ajj chapter 
presheaf models ss calculus quasi pullback diagram quasi pullback 
combining lemma gives theorem presheaves late bisimilar connected span surjective open maps 
moving larger set free names affect late bisimilarity colimit preserving functors preserve surjective open maps corollary 
proposition weakening dp late bisimilar injection 
moving smaller name sets little complicated 
define ei induction follows ei ei ei lambda lambda ei 
ei ei ei ei ei lambda lambda ei ei 

ei ei lambda 
lambda 
ei differs having simpler action input unknowns lambda 
corollary preserves open maps turns left inverse 
lemma injective function finite sets presheaf lambda proof observe lambda yp immediately proved induction structure paths 
preservation property left adjoint functors respect left kan extensions chain natural isomorphisms lambda 
lambda lambda yp allows prove result 
proposition strengthening dp late bisimilar 

constructions proof lemma lambda open map bisimilar lambda lambda colimit preserving preserves open map bisimulation 
lemma lambda open map bisimilar results suggest imposed similar uniformity constraints family rs definition conjecture loss generality require ae pointwise discrete cartesian subobject prof constructions restriction define operator interpret name restriction ss calculus processes 
arises family arrows indexed finite sets elements gamma gamma fyg define simultaneously induction structure paths 
path structure lambda gamma fyg lambda lambda gamma fyg lambda gamma fyg bs lambda lambda gamma fyg 


lambda 
lambda gamma fyg 
chapter 
presheaf models ss calculus bs 
gamma fyg lambda gamma bijection renames lambda gamma fyg 
decomposition theorem characterise action restriction operator presheaves 
lemma finite sets hold 
ff dp ff fo fx zg fx lambda yg ff 
dp lambda bs 

dp 



dp 

lambda 
dp 



lambda 


lambda lambda 
lambda 
proof 
ff ff paths give empty contribution ff lambda ff lambda ff lambda ff preserves connected colimits ff contributes empty presheaf ff definition 
inx yq paths give empty contribution lambda bs lambda inx yq lambda lambda bs lambda lambda preserves connected colimits lambda bs lambda lambda bs lambda lambda 
constructions 



lambda 
lambda paths give empty contribution 
lambda inx 
bpc 


lambda 
preserves connected colimits 
lambda 
lambda lambda 
similar extra restriction component 
induced colimit gives non empty contribution 

similar simply definition moves 
clearly component gives non empty contribution 

consequence fact lambda seen notation presheaf theta pz 
lambda 
lambda 

immediately seen component induced colimit empty presheaf 
lemma decomposition theorem characterise action general presheaf follows theorem dp pj pk lambda lambda pl zl lambda isomorphic xi xj lambda xj lambda lambda xk lambda case 
proof simple proof just uses fact sums preserve coends reduce cases handled lemma 
chapter 
presheaf models ss calculus results show family satisfies naturality property theorem injective function square commutes natural isomorphism fflffl gamma fyg gamma fi gamma fyg 
gamma fi restriction proof prove fact structural induction paths base cases fo fx zg fx 
yg definition fx lambda yg definition lambda lambda gamma fi lambda lambda case composites return empty presheaf 
inductive step sp sp definition sp definition inductive hypothesis definition similar argument proves cases fx zg fx lambda yg fx 
zg fx lambda 
yg sp lambda 
lambda 
definition pz imi 
sp lambda 
sp definition pz imi 
lambda 
inductive hypothesis pz imi 
lambda 

just added empty presheaf point lemma lambda 
lambda 

constructions particular observe family lambda defines pseudo natural transformation ffi 
important feature definition correctly turns free output bound output summarised result directly obtainable lemma lemma presheaf gamma lambda gamma fyg gamma thing worth observing different elements set gamma fyg 
ffi gamma fzg 
ffi suggests definition contravariant pseudo functor prof restriction order elements im 
parallel composition turn parallel composition chapter break definition parallel composition functors js dp theta dp dp theta dp lambda theta lambda theta 
lambda theta 
jjs 
dp functor colimit preserving 
previous general results colimit connected colimit preserving functors shall able conclude js preserves open map bisimulation 
definition finite set elements indicated letters define symmetric jjs 
theta 
simultaneous induction sets structure path objects represented functors reduce number different cases considered follows chapter 
presheaf models ss calculus omitting obvious yoneda embeddings jjs 

ff ff lambda ff lambda lambda bp inff jjs brc bp ino jjs br lambda ci binx 
binx bp inx jjs br lambda ci binx bp inx jjs br lambda ci binx lambda 
lambda bqc jjs bp inx binx lambda bp inx lambda jjs br lambda ci lambda br lambda lambda bqc jjs bp inx binx lambda bp inx lambda jjs br lambda ci binx bq bq lambda jjs bp ci binx bp inx jjs br lambda ci ff ff fo fx sg 
obvious inclusion 
inx define 

similarly define lambda 
action morphisms lesser equal relation inductively determined obvious way 
definition parallel composition finite set define parallel composition functor js def jjs 
ffi wp 
ffi lambda theta lambda decomposition theorem proofs analogous chapter ccs lemma proposition characterise parallel composition follows 
theorem presheaves respective decompositions indexed 
isomorphic 
constructions inductively defined presheaf pj jx pk kx lambda pl lx lambda js xj pj xj pk lambda js yk pl xj sy yl js lambda pj jx pl yl pk kx pl lambda lambda pj pl lx px pk pl lx lambda lambda js yk obvious inclusion function 
announced js arises composite open map preserving functors congruence property theorem presheaves 
maps surjective open proof definition jjs lambda lambda theta lambda proposition lambda lambda surjective open proposition lambda theta lambda surjective open corollary lambda lambda theta lambda surjective open corollary jjs lambda lambda theta lambda surjective open 
characterisation theorem difficult see analogy done restriction cf 
theorem js pseudo natural square commutes natural isomorphism theta dp js theta 
fflffl 
fflffl theta replication saw structural congruences ss calculus process replicated version characterised putting chapter 
presheaf models ss calculus different way achieving effect introduce operational semantics recursive rules ff gamma ff gamma natural way giving analogous presheaf operations dp dp means initial fixed point construction 
recall fact js dp theta dp dp preserves connected colimits argument separately 
particular holds colimits chains 
definition presheaf 
define dp dp said functor preserves colimits chains 
recall dp cocomplete chain presheaves dp colimiting cone 
definition justified 
definition presheaf define def colim jx jx 
dp defined ffl jx jx jx ffl jx unique arrow empty presheaf ni jx defined inductively jx gamma 
preserves colimits chains fixed point xjs usual colimits cf 
choice presheaf induces uniquely functor dp dp 

preserves colimits natural proposition injective function finite sets square commutes natural isomorphism 
fflffl 
fflffl 
interpretation proof colim gamma definition colim gamma 
preserves colimits colim jp gamma naturality 
interpretation ingredients compositional semantics ss calculus terms indexed presheaves 
give interpretation process terms steps 
associate process free names presheaf dp full interpretation take account possible name substitutions giving process free names denotation natural transformation jsj gamma definition set names 
ss calculus processes free names lie inductively define xy sjs fxg fxg hf lambda 
substitution lemma fundamental able index interpretation process terms respect possible substitution free names 
lemma substitution lemma injective function finite sets hx names process free names proof see appendix free names process may bound differently different contexts 
definition process jsj free names 
define interpretation natural transformation gamma defined follows jsj gamma theta delta delta delta theta gamma ha gamma 
chapter 
presheaf models ss calculus denotation process free names carries environment jsj parameter 
proof natural transformation depends lemma establishes gamma interpretation respects name substitution 
show major result bisimulation processes ss calculus coincides obtained model open maps 
theorems establish bisimulation process free names denotation theorem process free names lie ffl xy gamma implies gamma ffl gamma implies lambda gamma lambda ffl gamma implies gamma hf lambda ffl gamma implies gamma proof see appendix lemma crucial establishing converse theorem theorem 
lemma process term free names facts hold 
gamma exists process term xy gamma qj 
lambda gamma exist process term fresh new name gamma lambda 
gamma hf exist process term fresh new name gamma lambda 
gamma holds ffl exists process term gamma qj ffl exist process terms names gamma xz gamma jrj ffl exist process terms name lambda gamma lambda gamma lambda qjr 
interpretation proof proof induction structure uses obviously fact def denotation obtained colimit chain presheaf category colimits computed pointwise 
spell part proof concerns move delicate bit involve communication copies process 
suppose gamma definition exists exists choose jp jp jp sent colimiting diagram 
definition means exists jp jp jp gamma colimit chain js js js js js js characterisation parallel composition theorem chosen cases hold 
exists presheaf gamma gamma jp jp jp 
exist names presheaf pair hf gamma jp jp jp gamma gamma hf 

exist name presheaf pair hf gamma jp jp jp lambda gamma gamma hf js 
symmetric point 
case obviously deduce parallel composition symmetric js gamma jp jp jp chapter 
presheaf models ss calculus particular chains commutative diagrams writing parallel times gamma fflffl gamma js fflffl gamma js fflffl js gamma js js vertical arrows isomorphisms obtained application symmetry associativity js 
said colimit upper chain lower chain js js preserves connected colimits argument 
js inductive hypothesis saying exists gamma sjs qj case know decomposition result parallel composition exist gamma js gamma 
symmetry associativity js assume list chain commutative diagrams vertical arrows isomorphisms js fflffl js fflffl fflffl gamma js gamma js parallel composing js fflffl js fflffl fflffl gamma js gamma definition colimit upper chain symmetry associativity chain commutative diagrams vertical arrows isomorphisms js gamma fflffl js gamma fflffl js fflffl js gamma js gamma js 
interpretation upper chain diagram lower chain lower chain colimit js js inductive hypothesis exist gamma exists xz gamma 
js sjs js sjs js jrj cases treated similarly 
theorem process free names lie ffl gamma implies xy gamma ffl lambda gamma implies gamma lambda ffl gamma hf implies gamma lambda ffl gamma implies gamma proof sketch proof structural induction structure process term depends mainly characterisation theorems 
omit details treatment replication exemplify complicated case gamma case possibilities shown lemma 
gamma js inductive hypothesis gamma 
structural congruence gamma def sjs js 
gamma hf gamma js inductive hypothesis gamma xy gamma structural congruence defining implies application rule com gamma 
jr induces jr js 
case deals bound output treated right uses rule close com 
chapter 
presheaf models ss calculus results relate late bisimulation processes late bisimulation presheaves 
lemma ss calculus processes free names bisimilar definition late bisimilar definition 
proof rs late bisimulation rs define relation closed process terms iff dp rs theorem immediately implies bisimulation includes pair definition 
vice versa bisimulation define family rs follows rs iff theorem immediately deduces rs late bisimulation definition rs note second part proof obtained family large relations sense rs typically small set proper class pair presheaves relation isomorphic pairs 
reduced restricting consider presheaves reachable interpretation unnecessary complication purpose proof 
lemma theorem induce correspondence bisimulation ss calculus open map bisimulation 
theorem ss calculus processes free names late bisimilar connected span surjective open maps 
suppose ss calculus process free names sp larger set names injection sp induces natural transformation sssp 
projects jsj tuples names jsp tuples 
simply inclusion confusion arises write sssp notation substitution lemma induces theorem ss calculus processes free names sp sq respectively 
take sp union sp sq 
late equivalent bisimulation congruent finite set jsp qj tuple elements connected span surjective open maps 
note sufficient take exactly free names sp processes 
result categorical setting model 
late vs early corollary ss calculus processes free names sp sq respectively 
late equivalent ffi sssp ffi connected span modifications components surjective open maps 
late vs early ss calculus late version process carries input stages process prepared send channel transmitted value substituted body alternative early semantics steps happen processes synchronise channel value pairs 
operational consequences choice discussed 
corresponding early bisimulation early equivalence strictly coarser late forms 
follow late early alternatives denotational semantics 
presheaf models synchronisation points marked lifting gamma 
equation path category 
early version ine omega 
means paths lambda lambda lambda 
action ine functions driven function space omega lambda im lambda solving new equation prof gives object pe observe path objects denoted process terms 
fact example path objects denotation process term receive input uniquely channel input terminology wants act process capable performing free input action xy clearly expressible language 
definition restriction section easily adapted relevant clauses ae sp lambda lambda lambda slightly longer treatment parallel composition includes cases 
chapter 
presheaf models ss calculus definition finite set elements indicated letters define symmetric pe 
theta pe 
pe simultaneous induction sets structure path objects omitting obvious yoneda embeddings 
parallel composition presheaves obtained lambda lambda theta lambda definition parallel composition finite set define parallel composition functor jes def 
ffi pe 
ffi lambda theta lambda replication defined fixed point construction iterating parallel composition presheaf 
go details interpretation results analogous theorem establishing correspondence early bisimulation open map bisimulation pe prefer existence arrow prof mapping late interpretation early cf 
section 
definition finite set define functor ks pe inductively follows ks ks ks lambda lambda ks 
ks lambda 
ks ks ks ks ks lambda lambda ks ks 
ks ks lambda lambda 
ks clearly family functors induce pseudo natural transformations 
pe 
lambda 
pe pointwise described ks 
ks lambda respectively 
arrows prof pseudo natural transformations preserves open map bisimulation pointwise lambda maps late interpretation early 
theorem write delta interpretation ss calculus processes pe finite set process term free names hold lambda es proof sketch proof straightforward induction structure shown things hold 
late vs early ff ff brc binx lambda ff binx lambda lambda bpe inff brc binx binx brc binx lambda binx lambda lambda bpe ino brc binx binx binx binx brc brc binx binx brc binx binx lambda binx lambda lambda bpe inx brc binx lambda binx lambda bqc pe binx binx lambda brc binx lambda binx lambda lambda bqc bpe inx lambda lambda bpe inx lambda brc lambda brc lambda bqc bpe inx lambda lambda bpe inx lambda brc binx binx binx binx brc binx binx lambda binx lambda lambda bpe inx brc binx lambda binx lambda lambda bqc bpe inx lambda lambda bpe inx lambda qc brc ff ff fo fx sg 
obvious inclusion 
action morphisms lesser equal relation inductively determined obvious way 
early parallel composition chapter 
presheaf models ss calculus 
lambda fyg ey lambda fyg 
lambda jjs 
lambda yp 
theta lambda yp 

lambda es lambda naturally upper index stands corresponding semantical construct pe prove functors colimit preserving check done induction structure paths 
base cases trivial requires unwinding definition lambda non completely trivial case 
fact lambda fyg lambda ey ey fyg ey fyg lambda fyg similarly inductive step interesting case inductive hypothesis 
goes follows lambda fyg 
lambda ey ey fyg ey fyg lambda fyg 
point check things inductive proof tedious verification definitions agrees 
point follows directly point defined term replicated versions diagonals parallel composition 
move synchronisation point output clause variant omega omega 
turns difference process bisimilarity correspond closely presentation style 
processes synchronise channel names gamma gamma concretions name process pairs omega 
ss calculi abstractions name process functions respectively 
actual communication represented application abstractions concretions ffl believe domain models ss calculus cover early version chiefly rearrangements equation harder express 
domain equation processes uses plotkin powerdomain mark synchronisation equation paths uses simpler lifting operation 
ss calculi development model purely denotational operational manipulation processes expansion laws 
consequence required operators language model remains valid subset ss calculus 
particular sublanguages may fit simpler equations 
example asynchronous ss calculus constrains output form xy suggesting clause outa omega replace 
ssi calculus allows bound output equivalent xy original ss calculus 
communication passes fresh name replace ini outi omega ffip morphism arises category map ei introduced just proposition restrictions section left inverse right adjoint 
gives support sangiorgi claim ssi calculus simpler symmetric version ss calculus 
examples show flexibility approach drawing rich categorical structure prof category theory leads look maps models hope find morphisms late early tie wide selection customised ss calculi proposed years 
mentioned general function space prof exist longer constrained passing just names ground values 
process passing systems chocs full higher order ss calculus fit framework 
difficulties lie just writing plausible equations extracting operational content see semantics arise fit existing scheme shall see chapter 
chapter 
presheaf models ss calculus chapter higher order processes chapter investigation presheaf models process passing languages 
motivation understanding operationally bisimulation induced language terms open maps 
unfortunately shall quite reach objective believe results presenting step 
shall concentrate ccs process calculus 
mean assume existence fixed set channels discard possibility communicating creating new channels ss calculus cf 
chapter 
restriction imposed knowledge treatment higher order name passing time require considering function spaces indexed category prof said chapter believe prof exists functor gamma right adjoint omega gamma function space linear kind constrain process term linearity condition ensures term occurrences variable particular time active 
operational reading constraint roughly speaking process received input run 
main difficulty respect previous case studies cf 
chapters lies defining operational semantics way takes account elements denoted presheaves 
reason elements presheaves crucial characterising operationally open map bisimulation abstractions 
chapter shall identification elements presheaf denotation derivation trees operational semantics 
category conn chapter brief category presheaf categories connected colimit preserving functors motivate choice function space model abstractions tensor model concretions 
experience accumulated chapters suggests main operations chapter 
higher order processes model term constructors connected colimit preserving possibly argument separately case sorted operations parallel composition 
wish represent higher order communication form function application hinted section ground values case cf 
natural look setting category relation main category domains cocont 
definition conn define conn category objects small categories arrows connected colimit preserving functors bc bd cells natural transformations 
recall chapter remarked equivalence categories conn cocont fact conn arises kleisli category comonad cocont induced lifting gamma 
proposition functor gamma 
cocont gamma cocont equipped counit comultiplication ffi defined comonad 
ffl natural transformation gamma 
cocont small category lambda cc 
bc obvious inclusion ffl comultiplication ffi gamma 
gamma 
ss lambda ssc 
projection functor identifies bottom elements 
proposition conn pseudo equivalent kleisli category gamma ffi 
proof kleisli category 
objects cocont arrows colimit preserving functors cc 
bd cells natural transformations 
equivalence conn cocont immediately induces pseudo equivalence conn 
seeking 
embedding cocont conn locally induces reflection cocont 
conn pp generally functors omega gamma lambda pseudo gamma 
easily strict 
drop pseudo terminology 

equation higher order processes category conn completeness properties cocont particular algebraically complete algebraically compact 
symmetric monoidal closed structure need function application 
proposition conn infinite products terminal objects symmetric monoidal closed 
proof products terminal objects inherited cocont 
monoidal structure define gamma omega gamma def gamma 
omega gamma omega category theta initial object removed 
function space gamma gamma gamma 
gamma objects op theta concerning adjunction situation observe small categories equivalences categories hold conn omega conn theta cocont theta cocont theta cocont 
cocont conn general solve recursive domain equations directly conn shall find solutions cocont 
equation higher order processes concern semantics process language processes sent received fixed set channels ch 
derive category paths solving equation 
ch ch 
omega components represent paths silent action output channel resuming concretion input channel resuming chapter 
higher order processes abstraction 
choice path abstractions narrows linear language input process run yield single computation path shall see affects process language 
fact input path lifted cf 
definition implies process received input ignored need run 
variations choices path categories possible course taken allow input process copied arbitrarily exploited fully higher order nature conn give account concretions abstractions interaction lines proposed 
usual involved solutions equations partial orders regard categories 
convenience definitions cases give explicit description objects 
terms 
gamma 

shall write general path form morphisms simple partial order relations induced rules gamma 
hp iq 

categories subcategories 
obtained removing initial objects gamma 
set paths convenient distinguish set atomic paths 
definition define atomic paths path objects non bottom gamma 
expressed grammar ffp 
gamma 
ffc 
fff 
ffp gamma 
shall write ff general atomic path form ffp ffc fff notation shall write 
similarly 

gamma 
ffp 
shall write ffp respectively provided appropriate 

higher order process language higher order process language build process language path objects assume set variables ars processes elements typically written delta delta delta define syntactic categories processes concretions abstractions nil pi pi rep ffl hp ip shall write general term form sum terms assume set tests coercion identifies process paths closed process term replication rep 
replication subsumed general recursive definition processes allowing example rec 
recursive definitions provided consistent linearity condition terms pose significant problems 
mentioned path regarded special term matching type ffl nil 

nil ffl 
henceforth write identifying path corresponding term 
usual term set free variables think terms defined ff conversion 
impose linearity condition multiple presence free variables 
ensure occurrence variable active time 
definition term inductively defined linear proper sub terms linear case ffl form hu iv ffl ffl form rep 
substitution qk xk defined usual ff conversion avoid unwanted capture free variables 
proposition substitution respects linear terms sense qk linear terms pairwise disjoint sets free variables qk xk linear 
operational semantics introduce basic operational semantics calculus 

purpose testing consider possibility checking path capabilities path arbitrary 
cost considerably complicated syntax mixed concretions hf ip worse hhf ip introduced path transitions associated kinds paths 
chapter 
higher order processes atomic transitions 


sums tests pj ff 
ip pi ff 

ff 
ff 
parallel composition 


delta 


delta 




hp ip 
hp 
hp ip 
hp 



replication application rep ff 
rep ff 
ff 
ffl ff 
concretions abstractions ff 
hp iq hffi 
ff 
iff 
delta ff 
ff 
path capabilities ff 
ff 
ff 

ff 

hp iq 

hp iq hpi 

hp iq iq 
delta 
path capability 
need simple extra rule introducing non simple concretion paths form 
basic operational semantics 
presheaf semantics expects operational semantics respects linear terms proposition ff 
linear assume terms linear 
presheaf semantics purpose section provide terms language compositional semantics terms presheaves prove various facts notably substitution lemma lemma relating application model substitution language soundness result theorem presheaf semantics stability cf 
property denotations open terms 
steps operational characterisation open map bisimulation 
lead characterisation open map bisimulation fragment process calculus corresponding form calculus applicative bisimulation 
transition relations presheaves closed terms language denote presheaves know cf 
chapter presheaves transition relation xjd presheaf presheaf resumption category 
operational semantics allow case concretions possibility choosing branch concretion wish observe 
allow testing path capabilities processes 
motivates adjustment definition transition presheaves 
definition presheaves respectively define transition relations ffl ff gamma exists ff ff ffl hffi gamma gamma gamma ff gamma ffl gamma iff gamma gamma ff gamma ffl ff gamma ff ffl ff gamma ff gamma ffl gamma 
ffl gamma 
ffl gamma 
observations concatenated proposition presheaf hold 
chapter 
higher order processes 
gamma gamma gamma 

gamma gamma gamma 

gamma gamma gamma 

ff gamma gamma ff gamma 
constructions preparation denotational semantics processes basic constructions shall need 
accustomed defining embeddings ino 
cp 
bp lifting operator lambda characterisations def ino lambda 
def ina lambda 
def ina lambda presheaf pop set 
channel presheaf presheaf pop set pop set 



usual definition corollary proposition open map bisimulation preserved theorem prefixing functors 

preserve surjective open maps bisimulation 
prefixing operators express decomposition result presheaves theorem presheaf isomorphic tox xji ch xj xjj ch xk xjk 
presheaf semantics concretions concretions modelled presheaves omega 
bp define result application theta bp lambda theta lambda cp theta cp 
lambda theta 
lambda pair bxc theta course know clear open bisimilar presheaves true open bisimilar hw iz 
functor gamma gamma derives tensor operator omega fact corresponds omega conn theta conn conn 
omega omega conn isomorphism conn prof bp empty category objects arrows 
terminal category object arrow 
observations tested branches concretions paired proposition presheaves hold 
gamma gamma gamma 

gamma hpi gamma 

gamma ip gamma 
abstractions 
bp functor 
define eh presheaf 
defined 
hp path action morphisms inherited obvious way similarly presheaf 
define corresponding functor 
bp 
map saw chapter section open hp open ii hq pop open condition expected directly entails bisimilar profunctors pointwise bisimilar 
second condition ii peculiar sight 
shall see condition leads take closer look elements presheaves 
shall think elements representing derivation trees operational semantics 
accordingly think elements ef derivations associated doing transition input derivations associated minimum inputs see theorem effect ii ensure derivations matched chapter 
higher order processes bisimulation enabled minimal inputs 
condition ii important extending hold presheaves input cf 
corollary condition ii imply presheaf bp ef open map bisimilar 
parallel composition order define parallel composition operator bp theta bp gamma bp defining colimit preserving functor theta 
bp functor obtained theta bp lambda theta lambda cp theta cp 
lambda theta 
bp particular composition surjective open map preserving functors preserve open map bisimulation 
define colimit preserving functor theta 
bp say functor 
define 
theta 
gamma bp inductively structure paths calls simultaneous inductive definitions family parallel composition functors pkp 
theta 
bp 
theta 
bp kf theta 
bp 
theta 
bf 
theta 
bf kp theta 
bc pkc 
theta 
bc take account possible matching situation encountered 
sequel shall omit upper indices confusion arises 
convenience introduce notation 
notation sequel shall notation 
ffl lp obvious inclusion functor write jp functor yp 
bp functor sends non bottom path object bpc yp empty presheaf 
observe jp restriction 
lp lambda cp 
bp turn value counit lifting comonad cocont cf 
proposition 
ffl similarly lc lf write jc jf corresponding kan extensions yc yf 

presheaf semantics ffl confusion arises shall write appropriate jp jc jf ffl presheaf object write 
presheaf defined 
ae functors define define case 




abstractions concretions gamma 

ae bqc 
kf gamma 

ae bqc sr 
abstractions paths notation 
introduced 
gamma 
gamma 
pkp 

bqc gamma 
gamma 


bqc concretions paths compose follows kp hj hj action morphisms partial order relation defined inductively similar way 
definition fp fg define jb ba theta bb bd theta bb lambda theta lambda ca theta cb lambda 
theta 
bd fp fg uniquely determined typing parallel composition functors 
chapter 
higher order processes jb composite open map bisimulation preserving functors congruence property theorem fp fg open bisimilar open bisimilar xa jb open map bisimilar jb observe yoneda embeddings yf theta 
yf theta 
similarly symmetric counterpart factorised follows yf theta 
lambda ffi lf lambda theta lp lambda ffi jf theta jp yf theta lambda ffi lf lambda theta lc lambda ffi jf theta jc characterisation jj shall need 
proposition 
functor naturally isomorphic jp ffi jf theta jp 

functor jjf naturally isomorphic jf ffi jf theta jc 
similarly symmetric versions 
kind proof analogous results chapter lemma characterise inductively action jb lemma bp bc bf hold omitting upper indices 
xjy 

xja xja 

xja xja xjc 

hz iz xjc hz xjz 

jx isomorphic functor gamma jx currying functor 
ef bp gamma xi bp theta bp bp 
ja ja jc jc 

hz iz jc ef jz 
analogous results hold symmetric operations 
proof case proof goes exactly lemma 
proof goes follows xjc bxc theta bz theta bz bxc theta bz theta bz hj ip hj bxc theta bz gamma gamma preserves connected colimits argument bz hj xjz hr bz xjz gamma gamma preserves connected colimits argument hz xjz 
presheaf semantics concerning jx def bf theta bxc proposition coends presheaf category computed pointwise 
holds jx jx gamma bf theta bxc jj preserves connected colimits argument bf density formula applied twice jx actions morphisms agree immediately obtained similar calculation involving morphisms 
point proved similarly follows jc bf theta bz theta bz definition bf theta bz theta bz jj proposition bf theta bz theta bz jj definition bf theta bz preserves connected colimits argument ef bz jz definition ef 
density formula 
lemma easily proves theorem fact coends distribute sums 
theorem presheaves decompositions cf 
theorem xji ch xj ch xk xjk yji ch xj ch xk yjk chapter 
higher order processes isomorphic top lambda lambda hx xj lambda gamma lambda lambda hy yj lambda gamma yk ffl xj ffl yj yj path object observed parallel composition xjy exists xjy extract produce observation auxiliary results lemma corollary show case parallel composition lifted path objects possible describe precisely path producing observation chosen shape 
lemma lifted path terms defined 
path suppose exists unique pair element 
observe 
proof proof easy tedious induction structure fact triple uniquely determined immediately entails corollary corollary hypothesis lemma 
recall see chapter coend formula set theta op set bd defines set bya jcj theta 
presheaf semantics equivalence relation generated ffi defined theta ffi theta exists notation lemma immediate consequence lemma corollary 
lemma presheaves defined 
path term appropriate type lifted paths triple bxc theta theta exist necessarily unique triple bxc theta theta 
ffi 

ffi 
proof lemma determine 
define bxc corollary ensures second condition met 
shall lemma proving property open terms theorem reminiscent berry stability condition functions 
replication chapter shall define denotation replicated process rep rep fixed point functor gamma bp bp denotation presheaf define gamma jx bp bp functor sends objects jx morphisms 
unique morphism form initial presheaf define colimit chain jx xj xjx xj xjx jx delta delta delta parametricity theorem induces unique functor bp bp presheaves chapter 
higher order processes denotational semantics suppose process term free variables delta delta delta xn possibly empty list 
denotation context functor bp similarly concretion abstraction term free variables delta delta delta xn denoted functors bc bf respectively 
conciseness readability give semantic definition objects 
usual definition structural induction terms nil empty presheaf pi pi pi pi rep rep ffl pc xi pi hp iq pi set presheaf stand sum times coend formulas seen thesis written sigma sx 
observe important fact linear application amounts substitution 
rests property terms linear ensures viewed denotationally preserve connected colimits free variables 
lemma substitution lemma term language process term 
set variables including free suppose 
pc proof proof induction structure readability assume pc base case nil trivial base case possibilities xi xi component case 
functor constantly returns pi xi pi 
case lambda yp lambda yp 
lambda possibilities treated follows 
presheaf semantics ffl pr preserves connected colimits inductive hypothesis ffl uses similar argument fact 

preserves connected colimits 
ffl free pri hr pri gamma gamma preserves connected colimits argument ai pi inductive hypothesis case free treated similarly 
ffl pr pr currying preserve colimits equivalence inductive hypothesis ffl ffl free rb pcr pqr rb pcr pqr distribute coends rb pcr pr inductive hypothesis ffl case free treated similarly 
ffl rep property trivially holds free variables nil 
chapter 
higher order processes ffl free variable pq theta pq definition coends calculated pointwise free variable pq pq distribute coends inductive hypothesis ffl qjr free variable uses gamma gamma case functor gamma gamma preserves connected colimits argument 
ffl pi pi pi pi pq pi pi pq sums preserve coends pi pi inductive hypothesis pi pi immediate consequence lemma characterisation denotation linear application language 
corollary process terms free variable ffl proof proof calculation ffl pc definition lemma soundness result transition relations presheaves show soundness operational semantics respect presheaf semantics 

presheaf semantics theorem closed term language 
path term gamma gamma atomic gamma exists gamma 
proof proof goes induction rules 
ff ff gamma ff ff gamma 
sums pj ff 
pi pi ff 
pi pi inductive hypothesis pi ff gamma ff gamma definition 
tests 
ff 
ff 

inductive hypothesis ff gamma gamma 
definition exists ff gamma 
parallel composition 


ffl inductive hypothesis gamma gamma 
characterisation result theorem know jq gamma ea xjy ffl ffl 

inductive hypothesis gamma characterisation theorem jq gamma aj jq chapter 
higher order processes passage justified point lemma 
cases concerning parallel composition treated similar way 
replication rep ff 
rep ff 
inductive hypothesis ff gamma 
construction exists ff gamma application ff 
ffl ff 
inductive hypothesis ff gamma 
corollary exists isomorphic ffl ff gamma 
concretions ff 
hp iq hffi gamma inductive hypothesis ff gamma definition hffi gamma gamma abstractions ffl ff 
ff 
inductive hypothesis ffl ff gamma 
recall 
ff ffl ff ff gamma path capabilities ff 

ff inductive hypothesis ff gamma gamma gamma 
proposition ff gamma cases trivial 

presheaf semantics converse result showing gamma gamma atomic gamma exists gamma easily obtainable 
plain induction structure terms encounter difficulties treating application ffl parallel composition jq cases 
refined strategy needed 
problem related unproven conjecture see section stating existence bijections elements presheaf denotation term derivation trees operational semantics characterisation open map bisimulation say presheaves open map bisimilar iff related span surjective open maps 
induces relation closed terms closed terms related iff denotations open map bisimilar bp bc bf depending type relation terms wish characterise 
intertwined definition operational characterisation open map bisimilarity necessary involve characterisation open map bisimilarity 
characterisation poses problems 
fact decomposition results theorem easy prove proposition presheaves open bisimilar conditions symmetric counterpart hold 
gamma exists gamma open bisimilar 
gamma exists gamma open bisimilar 
gamma exists gamma open bisimilar proving proposition introduce purpose section abbreviations open map bisimilarity 
notation reminder section shall write mean presheaf open bisimilar presheaf similarly write mean open bisimilar mean open bisimilar proof proposition need define span surjective open maps 
define yo fi xji yji 
assumption yo empty 
yo xji gamma zo go gamma ji span surjective open maps needs exist assumption 
similarly 

choose spans chapter 
higher order processes xjj gamma za ga gamma jj xjk fa gamma za ga gamma jk ya ya ya ya defined similarly yo define presheaf pop set follows objects theta ji yo ig theta jj ya jg theta jk ya kg xi yo zo xj ya za xk ya za action morphisms action presheaves za za cases 

determined obvious way 
natural transformations determined projections second components base cases open maps go cases 
assumptions immediately deducible surjective open 
direction trivial 
compare proposition 
seen presheaves product category theta theta open bisimilar object ja gamma open bisimilar gamma object jb gamma open bisimilar gamma 
converse hold general 
special case represented denotations concretions 
proposition presheaves open bisimilar open bisimilar open bisimilar proof direction commented prove directly invoke said section functor gamma gamma defined shown preserve open map bisimulation general reasons 
denotation concretions open bisimilarity reduced open bisimilarity 
abstractions presheaves 
op theta 
presheaf semantics things simply 
clearly implies ef uniformity constraints need imposed family spans surjective open maps ef zp jp order able glue single span surjective open maps order match constraints apparently unavoidably led consider elements presheaves explicitly 
proposition presheaves family spans surjective open maps ef zp gp 
jp induces span surjective open maps 


zp implies ef zp 

ef zp implies exists zp 
zp implies exists ef ef zp zp abbreviation exists fp gp 
proof sketch simplicity loss generality assume zp fact pointwise subsets products ef theta zp fact pair ef theta 
define fop set 
zp ef pair 
condition ensures defined conditions provide quasi pullback conditions projections open 
characterise open bisimilarity abstractions language annotate transitions operational semantics expressions accounting extra information required conditions proposition 
conjecture existence tight correspondence derivation trees associated closed process term path elements 
believe fact lack proof bijections fd derivation tree gamma chapter 
higher order processes term path hope describe functorial action presheaves open map bisimulation annotations operational semantics 
room improvement conditions proposition condition satisfied presheaves denoting terms language reminds berry stability condition functions 
theorem term free variables xn 
pn vector lifted paths exists pointwise smaller vector element 

vector satisfying 
proof proof induction structure term essential linearity constraint terms 
cases trivial 
concentrate require looking coend definition semantics operations 
jq free variables respectively 
linearity constraint know 
pp pq corresponding splitting vector hypothesis 
pp theta theta exists triple pp theta theta cf 
section 
lemma know equivalence class minimise result minimisation corresponding triple elements 
empty presheaf 
path ps define pp constantly bottom vector pq obtained applying inductive hypothesis pq ps 
corresponding element pq pq ps define lambda jq pq theta pq theta just symmetric thing non bottom minimise separately pp pq 
complicated case ffl case theta pp split free variables disjoint sets 
theta pp pp 
presheaf semantics minimal representative find inductive hypothesis 
define pq take lambda apply inductive hypothesis pq pr pr bpr obtain pq pq pq pr pq define 
notation situation theorem say minimum 
theorem simplify conditions proposition examining minimum inputs 
corollary presheaves family spans surjective open maps ef gp 
jp induce span surjective open maps 


zp implies ef zp 
path zp minimum implies minimum vice versa minimum minimum 
applicative bisimulation recovered terms process language include fragment form calculus bisimulation open maps characterised simply full process language 
characterisation terms relation applicative bisimulation 
restrict syntactic categories deterministic terms linear terms syntax nil ffl operational semantics restricts fragment language 
presheaves deterministic terms subobjects terminal object 
proposition presheaf category bc terminal object presheaf takes object singleton set lambda presheaf subobject object empty set singleton set 
write 
mean subobject chapter 
higher order processes proposition term restricted language free variables vector matching length closed terms possibly full language pi pi subobject terminal subobject 
proof proof induction structure ffl nil def 

ffl inductive hypothesis 

cf 
definition ffl inductive hypothesis 

ffl inductive hypothesis empty set singleton set 
case 

inductive hypothesis subobject inductive hypothesis 
ffl ffl isomorphism depends corollary 
known subobject inductive hypothesis 
ffl py satisfies condition assumption 
ffl 
object 
subobjects terminal partial orders empty set singleton set inductive hypothesis 
terms fragment path object possible way deriving transition 
open map bisimulation closed deterministic terms characterised relations familiar form terms theorem closed terms restricted language 
denotations presheaves open map bisimilar iff symmetric relations rp closed process terms rf closed abstractions relating terms rp rf ffl rp 

rp 

rf ffl rf rp closed process terms restricted language 

remarks remarks chapter presheaf model linear higher order process language 
comes automatically equipped result open map bisimulation congruence 
outlined problems encountered far trying give characterisation open map bisimulation operational semantics hope obtain purely operational characterisation open map bisimulation 
presently lack informative examples counterexamples probe variations way think characterisation set 
expect hope obtain fruitful operational reading broad range presheaf semantics elements presheaf denotations correspond derivations operational semantics 
chapter 
higher order processes chapter summary building mainly winskel nielsen categorical models concurrency joyal nielsen winskel open map bisimulation thesis studied presheaf categories models concurrency built notion bisimulation :10.1.1.21.5791
research developed directions 
refined axiomatisation models implicit proposed notion presheaf models ccs languages :10.1.1.21.5791
advantage models traditional ones general reasons bisimulation open maps congruence 
shown useful proving similar congruence results traditional models known embeddings presheaf ones 
example presheaf model generalising event structures prove strong history preserving bisimulation event structures congruence respect general process language proc :10.1.1.21.5791
similar way refinement event structures proposed shown preserve strong history preserving bisimulation 
crucial proving result proposition asserting colimit preserving functors presheaf categories preserves open map bisimulation 
second direction took considering category cocont presheaf categories colimit preserving functors category non deterministic domains suggested 
done purpose describing presheaf categories appropriate modelling specific process languages initial solutions recursive domain equations 
connection domain theory formal developing vein axiomatic domain theory suitably generalised versions classical notions results 
notably theorem leading limit colimit coincidence result generalises theorem 
generalisation requires moving order enriched categories categories established folklore moving embedding projection pairs general adjoint pairs 
line defined axiomatically class pseudo algebraically compact categories included cocont 
categories class parametric properties free algebras proved 
just chapter 
formalise intuitions cocont study open map bisimulation domain theoretical point view 
established induction coinduction principles recursively defined domains give domain theoretical characterisation strong bisimulation arbitrary trees 
proposition mentioned generalised proof horizontal composition open cells cocont preserve open map bisimulation show connected colimit preserving functors presheaf categories preserve 
functors needed model process constructors fell class presheaf models immediately deduce congruence property bisimulation 
tested approach examples ranging ccs ccs late value passing done ss calculus form ccs linear process passing 
examples shown notion bisimulation corresponded usual process terms 
exploited monoidal closed structure cocont provide denotational semantics higher order process language 
congruence results highlight substitution lemma lemma proving application model corresponded substitution language 
fragment language corresponding form calculus open map bisimulation shown coincide applicative bisimulation 
succeed doing giving operational characterisation bisimulation induced open maps full language subject see 
research lines research extending 
briefly outline possibilities connections related research 
higher dimensional transition systems hdts joint sassone introduced new category models concurrency building previous intuitions pratt van glabbeek 
open maps give characterisation notion bisimulation devised 
step making harnessing machinery chapter thesis purpose semantics concurrent processes hdts 
way expect obtain automatically congruence results bisimulation 
hdts appropriate modelling called coordination languages linda 
speculatively expect obtain geometric realisation functors help clarifying relationship approach closely related goubault higher dimensional automata :10.1.1.39.1477

research higher order process languages saw chapter monoidal closed structure cartesian closed obtained means exponential prof describe path category suitable higher order process languages 
avoiding exponential designed linear process language test model 
hopes able operationally characterise bisimulation relation induced terms open maps 
requires capability expressing structure derivation trees operational semantics way allows reading functorial aspects presheaves cf 
section 
wrote definite answer problem promising conjectures 
worth noticing linearity constraint language consistent similar cardelli gordon calculus ambients noted winskel 
interesting problem monoidal closed structure prof combine higher order features non interleaving models 
steps hildebrandt panangaden winskel model non deterministic dataflow networks developed 
modelling higher order process calculi include name passing features require advanced enriched categories 
say section 
metalanguage process constructors glynn winskel begun developing metalanguage process constructors parallel composition analogous domain theory continuous functions see 
functor described metalanguage connected colimit preserving open map bisimulation preserving 
chains connected colimits endofunctor described metalanguage fixed point 
respect problem characterising operationally open map bisimulation higher order processes hope structure meta language provide direct reading operational characterisation defined functors 
metalanguage useful proving characterisation results proposition theorem theorem parallel composition lot common 
weak bisimulation hiding thesis concentrated strong bisimulation 
suggested weak bisimulation reduced strong bisimulation monad way imitates milner approach recall 
nielsen cheng tackled question transition systems allowing morphisms weak simulations keeping path category finite strings chapter 
prefix ordering fixed 
seeking structured approach fiore private communication reduced presheaf setting consider quotienting functors category elements construction quotient preserving morphisms 
monad wq depending definable bp general reasons 
case transition systems known milner possible reduce weak bisimulation strong bisimulation 
mean transition systems set labels fo transform say way weakly bisimilar strongly bisimilar 
fact construction functorial category transition systems :10.1.1.21.5791
composing embedding synchronisation trees transition systems unfolding functor transition systems synchronisation trees yields endofunctor synchronisation trees fact underlying functor monad 
turns corresponds endofunctor wq fo fo fo lambda functor removes occurrences letter string 
extends give general treatment weak bisimulation 
pursuing line research collaboration fiore winskel 
points addressed include ffl obvious quotienting functors categories models exist explore induced notion weak bisimulation 
particularly interesting done models clear cut understanding weak bisimulation mean event structures timed transition systems 
ffl find considerations determine define quotienting functors models defined initial solution recursively defined equations 
instance examples treated thesis path categories obtained solution equations looked 

stand possibility observing internal communication proceeds general complicated expression having situations involving inputs outputs 
initial solution equation allow observing silent actions define algebra sends initial presheaf object corresponding representable call previous 
research chapters 
initial solution bigger equation initiality exists universal square profunctors commute natural isomorphism course fflffl believe fact deduce suitable quotienting functors action calculi categorical formalism semantics process calculi order capture abstractly notion bisimulation 
action calculi looks basic ingredients needed define classes communicating systems actions composed 
reduction semantics actions 
order reason behaviour different actions seeks way extracting transition systems reduction semantics 
sewell progresses direction classifying reduction semantics terms properties rewriting systems 
hope able employ open maps paradigm finding ways deriving path categories action calculi vice versa 
presheaves presheaf categories obtained freely completing small categories colimits small diagrams 
results trivial case non small category 
process languages naturally constrains size model little reason consider processes correspond physical machines 
languages presheaf construction 
investigated joint john power glynn winskel restricted forms completions keeping spirit especially possibility congruence results presheaf approach represented endofunctor cat 
constructions characterised axiomatically terms kz monads 
categories non deterministic domains analogous cocont kleisli categories considered kz monads 
just yoneda embedding respect presheaves unit monads provide full embedding category completion canonical choice path category 
open map bisimulation preserved arrows kleisli algebra maps free algebras monad 
observation needs fully checked suggests possibility characterising bounded size event structures set labels chapter 
poml kz monad applied partial order categories returns exactly bounded size free completion category colimits specified size 
mean means monad interleaving non interleaving models characterised kind completion 
speculatively envisage possibility moving prof equivalent cocont prof suitably complete cocomplete 
instance noticed see chapter setting highly possible provide semantics process languages combine higher order features name passing higher order ss calculus 
looking model seti prof prof overcome mathematical difficulties due lack general function spaces prof left verify equations solved seti prof give meaningful solutions 
alternatively consider enriching categories sets probability distributions elements able cope probabilistic markov processes 
suggestions martin hyland currently investigating possibility considering extensions category name sets allow possibility having meaningful solutions equations involving higher order name passing features speculative level mention possibility suggested incorporating fairness constraints models moving presheaves sheaves 
clear approach relates understanding bisimulation provided coalgebras 
hope ongoing research turi plotkin help provide missing links 
recall poml category finite pomsets appendix basic definitions enriched category theory enriched categories appendix review concepts enriched category theory needed chapter 
particular concentrate categories 
definition monoidal categories monoidal category tuple omega category omega theta functor jv object families natural isomorphisms av omega omega omega omega lv omega rv omega subject coherence axioms omega omega omega omega av omega fflffl omega omega omega omega omega omega omega omega omega omega omega omega omega omega omega aw oo omega omega av rv omega omega omega omega pppp omega monoidal category symmetric addition family natural isomorphisms oev omega gamma omega omega satisfying coherence axioms respect associativity identity cf 

appendix basic definitions enriched category theory plenty examples symmetric monoidal categories category finite products 
interesting example symmetric monoidal structure product related thesis analogy section rel cartesian product sets correspond categorical product disjoint union 
definition categories omega monoidal category 
category consists ffl class objects jcj ffl objects jcj hom set object ffl object jcj arrow jc ffl objects jcj composition law arrow cc omega subject coherence laws omitting indices commutativity diagrams omega omega cd omega fflffl omega omega omega cc fflffl omega cc ttt omega cc jj omega cc omega cc omega jd omega oo jj omega tt omega jc oo example ffl locally small category set category monoidal structure set cartesian product 
ffl cartesian closed category enriches hom set objects exponential dc 
particular cat cat category 
ffl category rel sets relations poset category poset category partial ordered sets monotone functions 
monoidal structure product 
definition functors categories functor data ffl function jcj jdj 
categories ffl pair objects jcj arrow fc diagrams commute omega cc fd omega fc fflffl fc omega fd fe fc fflffl jc jfc definition natural transformations functors natural transformation ff gamma consists family arrows indexed objects ffc gc diagram commutes omega ffd omega fc gd omega fd gd uuu gamma pppp pp gamma gd omega omega ffc gc gd omega gc gc gd jj categories special class categories cat categories ignoring size problems cat categories 
go name categories 
fix terminology reformulate definition category referring general definition categories coherence axioms 
definition categories category ffl collection objects jkj ffl objects jkj category ffl object jkj identity arrow jk appendix basic definitions enriched category theory ffl objects composition law functor ck theta satisfying instantiation coherence diagrams definition 
objects called arrows indicated arrows called cells indicated double arrow notation ff cells ff ff ff fi write fi ff talk horizontal composition ff fi 
composition cells arrows say called vertical written interposing delta cells ff delta ff ff cell ff ff arrow write ff ff similarly operation called ff 
consequence definition category property 
proposition interchange law category ff ff ff fi ff ff cells delta fi delta ff fi delta ff means writes diagram ff ff dd ff fi oeoe ff cc ff defines cell unique way 
diagram called pasting diagram 
interchange law basis general coherence result asserts pasting diagram defines uniquely cell 
concerning applications notion pasting give example definition adjoint pair category 
specialise case cat usual notion adjoint pair functors 

categories definition adjoints categories category pair arrows ii adjoint pair exist cells gf equalities hold ff 
ff gamma gamma gamma gamma xi ff 
ff 
ii 
oe said categories special kind enriched categories 
instantiation definitions functor natural transformation yields notion functor natural transformation 
categories general classes functors natural transformations considered practice shows general notions naturally appears 
seen section notion pseudo functor category cat 
concept precise defining pseudo functors categories 
definition pseudo functors categories 
ffl function jkj jlj ffl objects jkj functor fk ffl object jkj isomorphic cell fk ffl triple objects natural isomorphism cf ffi fl theta fk gamma fk ffi ck theta ck fl theta fk fflffl fk theta fl fm satisfying coherence conditions commutativity diagrams triple arrows gamma gamma gamma appendix basic definitions enriched category theory rr kks ff ff lf ll hf gf hf ff hg hg ff hf gf gf sake readability wrote similarly occurrences 
isomorphic cells equality arrows natural isomorphisms commutativity square theta ck fl theta fk fflffl fk fflffl theta fl fm said functor 
case coherence conditions trivially satisfied 
indexed categories defined definition examples pseudo functors category regarded category hom categories discrete categories 
considering categories different notions limits arise generalisations usual cf 
section quick review 
concentrate call consistently terminology pseudo limits 
note called bilimits bi stands prefix pseudo reserved stricter class bilimits 
shall interested particular kinds pseudo limits shall give explicit definitions needed 
section definition pseudo initial object illustrative example change perspective occur moving form categories categories 
repeat definition pseudo initial object object category object equivalent category object morphism 
words pseudo initial object exists arrow pair arrows exists unique cell ff omitted definition pseudo natural transformations strong transformations modifications 
needed defining pseudo limits general decided give explicit description data required particular examples giving general definitions 

bicategories bicategories conclude appendix recalling existence notion bicategory 
roughly speaking bicategory category horizontal composition associative isomorphism 
means diagrams definition specialised cat commute natural isomorphisms isomorphism satisfy coherence conditions 
refer precise definition bicategory definition pseudo functors pseudo natural transformations modifications lifts categories bicategories 
setting pseudo functors called homomorphisms pseudo natural transformations go name strong transformations 
practice bicategories arise naturally categories 
difficult extra coherence conditions carry 
fortunately coherence results permit bicategory category losing relevant properties 
appendix basic definitions enriched category theory appendix proofs chapter theorem pseudo cat algebraically complete categories theta pseudo cat functor 
write ta object part chosen pseudo initial algebra pseudo endofunctor ta defined freezing component object mapping ta extends canonically pseudo gamma prove theorem need couple lemmas brief excursion theory lax algebra morphisms done chapter prove similar result cpo categories 
definition pseudo functor algebras lax morphism pair hf gt pseudo cell say pseudo morphism 
define lax alg category algebras lax morphisms cells ff ff cell ff gt ff delta delta fff lemma cat category pseudo cat functor pseudo initial algebra algebra pseudo morphism universal property terminal lax alg 
proof pseudo lambek lemma know equivalence exists oe aa aa oe chosen appendix proofs chapter unit counit adjunction 
lax algebra morphism 
consider chain ha delta hoe xt ha delta hoe xt delta delta delta formally chain inductively defined objects un un arrows ha delta hoe fn fn un colimiting cone chain 
show pseudo initial show exists pseudo cell xt consider calculation colim fn colim fn colim xt definition fn colim xt fn aa colim fn xt suggests derive isomorphism inspecting universal cells different colimiting cones chain 
consider fact chain aa aa aa aa aa delta delta delta obtained ways 
chain dropping item 

applying chain resulting chain aa 
chain colimiting cones un aa un xt un aa xt exists unique xt delta na xt gamma 
theorem notice delta xt delta delta delta delta delta haa delta property xt delta delta hao delta interchange law xt delta triangular identity 
universal property pseudo initial algebras exists unique necessarily pseudo cell delta xt delta defined def delta conclude need show xt delta delta xt delta xt delta delta definition xt delta xt delta locally functor xt delta delta equality delta delta property delta show unique cell satisfying equation 
assume existence ff xt ff delta delta ffa want show ff 
observe ff generates cone ffn un inductively follows ff def ff ffn def oe gamma delta gamma delta ffn fact proof induction ff oe gamma delta gamma delta ff delta ha delta hoe definition oe gamma delta delta hoe equation ff delta hoe gamma delta hoe interchange law ff def ff ffn fn oe gamma delta gamma delta xt delta xt fn gamma definition oe gamma delta gamma delta xt ffn gamma inductive hypothesis ffn definition appendix proofs chapter def delta un colimiting cone exists unique ff ff delta ffn goal show ff equal 
fact case chain equalities holds ff ff ff done 
show ff shall universal property pseudo initial algebras prove delta ffa xt ff delta exists unique cell satisfying equation imply ff equal 
deduce equation holds universal property colimiting cones shall prove delta ffa delta na xt ff delta delta na fact na una colimiting cone prove equation holds proving holds 
proof induction 
ao oe gamma follows triangular identity ao delta oea oe invertible 
base case delta ffa delta delta ffa definition ff xt ff delta equation xt ff delta xt delta definition ff xt ff delta delta equation def 

theorem inductive step delta ffa delta delta ffn definition delta oe gamma delta gamma aa delta xt definition delta ao delta gamma aa delta xt equality delta gamma delta xt interchange law xt xt ff delta delta definition xt ff delta xt delta interchange law xt ff delta xt delta delta equation xt ff delta delta delta equation xt ff delta delta definition 
lemma pseudo cat functor 
pseudo initial algebra object arrow write chosen pseudo algebra morphism exists pseudo initial 
mapping gamma gamma extends canonically functor say preserves colimits chains 
proof ff arrow cell 
pair fft delta lax algebra morphism fft delta lemma terminal lax alg exists unique cell fft yt fft delta fft delta delta fft 
define ff fft definition functor fact appendix proofs chapter ffl xt delta xt delta delta 
ffl ff fi yt fft delta fft delta delta fft zt fit delta fit delta delta fit zt fit fft delta delta zt fit delta zt fft delta fit delta fft delta locally functor zt fit delta fit delta yt fft delta fft delta interchange law zt fit delta fit delta delta fft delta fit delta fft delta fit fft fi ff 
left showing preserves colimiting cones chains 
suppose chain ff ff ff ff colimiting cone fin xn 
want show cone fin xn colimiting chain ff ff ff ff suppose xn colimiting cone chain 
shall show start observe square commutes defining property ffn xn ffn xn ff xn xn ff xn ff nt ffn xn xn 
theorem chain xn ffn colimiting cones xt fint delta xn xn xt preserves colimits chains na xn exists pseudo cell xt delta na fint delta xn isomorphism universal property pseudo initial algebras exists unique pseudo cell delta xt delta conclude cone fin colimiting show delta fin prove equality holds lemma fact terminal lax alg 
show delta fin morphisms lax alg xn fint xn delta xn necessarily equal 
show equalities delta na xt delta fint xn delta xn delta delta fin xt delta fin delta fint xn delta xn hold concerning equation chain equalities delta na fint delta xn equation xt delta fint xn delta xn interchange law 
equation delta delta fin delta delta fin xt delta delta fin equation xt delta xt fin delta fint xn delta xn property defining fin xt delta fin delta fint xn delta xn appendix proofs chapter proof theorem pseudo functor gamma defined properties pseudo initial algebras 
fact arrow ia ta ta ta ib tb tb tb chosen pseudo initial algebras 
tb ta tb tb gamma tb tb tb consider algebra ta tb tb tb ib universal property exists pair ta square ta ta ta fflffl ta ta tb bt tb tb choice pair ta action cells canonically determined lemma lemma 
coherence isomorphisms uniquely determined universal property pseudo initial algebras lemma ensures defined pseudo functor cat 
appendix proofs chapter lemma substitution lemma injective function finite sets hx names process free names proof induction structure base case trivial inductive step definition delta 
colimit preserving inductive hypothesis definition definition delta inductive hypothesis iy iy definition delta appendix proofs chapter xy xy definition delta definition inductive hypothesis definition delta xy sjs definition delta js naturality js inductive hypothesis definition trivial definition delta naturality inductive hypothesis definition fyg fyg definition delta fyg fyg naturality fyg inductive hypothesis definition 
theorem lambda definition delta pz 
pw im 
lambda lambda 
lambda point lemma pz 
pw im 
lambda lambda lambda lambda 
lambda lambda lambda inductive hypothesis pi 
pw im 
lambda 
lambda pv 
lambda 
lambda lambda definition delta theorem process free names lie 
xy gamma implies gamma 
gamma implies lambda gamma lambda 
gamma implies gamma hf lambda 
gamma implies gamma proof proof simple rule induction rules defining operational semantics ss calculus 
exemplify details cases 

axiom allowing kind transition rule xy definition gamma 
case application rule sum xy gamma inductive hypothesis gamma definition gamma appendix proofs chapter case application par xy gamma inductive hypothesis gamma exists jj 
definition js characterisation theorem sjs sjs jj xjs gamma 
sjs jj xjs sjs case application res xy gamma fx yg 
inductive hypothesis fzg gamma fzg characterisation fzg theorem exists fzg jj fzg fzg jj fzg fzg fzg 
similar cases sum par res 
case application rule open means xy gamma inductive hypothesis fyg gamma fyg 
characterisation theorem fyg fyg lambda gamma bs bs fyg substitution lemma lemma bs fyg lambda 
similar case sum par res 
case application axiom property immediately derived definition 

similar sum par res 
case application rule com means gamma xz gamma 
inductive hypothesis gamma hf lambda gamma characterisation theorem sjs gamma sjs case application close rule gamma gamma 
inductive hypothesis gamma hf lambda lambda gamma lambda 
theorem theorem sjs gamma lambda js conclude observe chain isomorphisms hold fyg fyg definition delta fyg bs lambda substitution lemma lambda lambda naturality theorem lambda lambda js lambda lambda js bibliography samson abramsky 
semantic foundations applicative multiprogramming 
icalp tenth colloquium automata languages programming volume lecture notes computer science pages 
springer verlag 
samson abramsky 
lazy lambda calculus 
research topics functional programming pages 
addison wesley 
samson abramsky 
domain equation bisimulation 
information computation 
peter aczel mendler 
final coalgebra theorem 
pitt editor proceedings ctcs international conference category theory computer science volume lecture notes computer science pages 
ji ri ad amek ji ri 
locally presentable accessible categories volume london mathematical society lecture notes series 
cambridge university press 
baeten weijland 
process algebra 
cambridge university press 
michael barr 
lambda autonomous categories volume lecture notes mathematics 
springer verlag berlin 
appendix po hsiang chu 
marek 
hereditary history preserving bisimulation power perfect program logics 
technical report polish academy sciences 
jean 
bicategories 
reports midwest category seminar volume lecture notes mathematics pages 
springerverlag 
jean 
les 
rapport 
de math ematiques pure institut de math ematiques universit catholique de louvain 
jean 
categories foundations naive category theory 
journal symbolic logic 
van 
correspondence theory 
gabbay editors handbook philosophical logic volume pages 
reidel 
erard berry pierre louis curien jean jacques evy 
full abstraction sequential languages state art 
nivat reynolds editors algebraic semantics pages 
cambridge university press 
bird gregory kelly john power ross street 
flexible limits categories 
journal pure applied algebra 
blackwell gregory kelly john power 
dimensional monad theory 
journal pure applied algebra 
richard blute jos ee desharnais abbas edalat prakash panangaden 
bisimulation labelled markov processes 
lics pages 
francis borceux 
handbook categorical algebra volume encyclopedia mathematics applications 
cambridge university press 
erard boudol 
asynchrony ss calculus 
technical report inria sophia antipolis 
nadia busi roberto gorrieri zavattaro 
process algebraic view linda coordination primitives 
theoretical computer science 
luca cardelli andrew gordon 
mobile ambients 
nivat editor proceedings international conference foundations software science computation structures fossacs volume lecture notes computer science pages 
springer verlag 
gian luca cattani marcelo fiore glynn winskel 
theory recursive domains applications concurrency 
lics proceedings thirteenth annual ieee symposium logic computer science pages 
ieee computer society press 
gian luca cattani john power glynn winskel 
categorical axiomatics bisimulation 
sangiorgi de simone pages 
gian luca cattani sassone 
higher dimensional transition systems 
lics pages 
gian luca cattani sassone 
higher dimensional transition systems 
manuscript preparation 
gian luca cattani ian stark glynn winskel 
presheaf models 
proceedings th international conference category theory computer science ctcs number lecture notes computer science pages 
springer verlag 
gian luca cattani glynn winskel 
presheaf models concurrency 
van dalen bezem pages 
paolo ciancarini jensen daniel 
operational semantics coordination language 
object base models languages concurrent systems volume lecture notes computer science pages 
springer verlag 
brian day 
closed categories functors 
reports midwest category seminar iv number lecture notes mathematics pages 
springerverlag 
eric goubault martin 
detecting deadlocks concurrent systems 
sangiorgi de simone pages 
marcelo fiore 
axiomatic domain theory categories partial maps 
distinguished dissertations computer science 
cambridge university press 
marcelo fiore 
coinduction principle recursive data types bisimulation 
information computation 
marcelo fiore eugenio moggi davide sangiorgi 
fully model ss calculus extended 
lics pages 
marcelo fiore gordon plotkin 
extension models axiomatic domain theory models synthetic domain theory 
van dalen bezem pages 
marcelo fiore gordon plotkin john power 
complete sets axiomatic domain theory 
lics pages 
peter freyd 
algebraically complete categories 
carboni rosolini editors category theory volume lecture notes mathematics pages 
springer verlag 
peter freyd 
remarks algebraically compact categories 
fourman johnstone pitts editors applications categories computer science volume london mathematical society lecture note series pages 
cambridge university press 
peter freyd andre scedrov 
categories allegories volume northholland mathematical library 
north holland publishing amsterdam 
jean yves girard 
linear logic 
theoretical computer science 
jean yves girard 
proofs types volume cambridge tracts theoretical computer science 
cambridge univeristy press 
translated appendices taylor lafont 
rob van glabbeek 
bisimulation higher dimensional automata 
mail message sent concurrency mailing list july 
available theory stanford edu people hda 
rob van glabbeek goltz 
equivalence notions concurrent systems refinement actions 
mathematical foundations computer science number lecture notes computer science pages 
springerverlag 
gordon john power ross street 
coherence 
memoirs american mathematical society vi 
eric goubault 
domains higher dimensional automata 
best editor proceedings concur volume lecture notes computer science pages 
springer verlag 
eric goubault 
geometry concurrency 
phd thesis ecole polytechnique 
eric goubault jensen 
homology higher dimensional automata 
cleaveland editor proceedings concur volume lecture notes computer science pages 
springer verlag 
gray scedrov editors 
categories computer science logic volume contemporary mathematics providence ri 
american mathematical society 
john gray 
formal category theory adjointness categories volume lecture notes mathematics 
springer verlag 
alexandre grothendieck 
rev groupe volume lecture notes mathematics 
springer verlag berlin 
de eom etrie alg du bois marie sga par alexandre grothendieck 
augment de deux expos es de raynaud 
carl gunter 
solutions recursive domain equations 
phd thesis university wisconsin madison 
matthew hennessy 
fully denotational semantics ss calculus 
technical report school cognitive computing sciences university sussex 
matthew hennessy gordon plotkin 
full abstraction simple parallel programming language 
cv editor mathematical foundations computer science mfcs volume lecture notes computer science pages berlin 
springer verlag 
claudio hermida 
fibrations logical predicates indeterminates 
phd thesis university edinburgh 
available technical report daimi pb computer science department university aarhus 
claudio hermida bart jacobs 
induction coinduction subset types quotient types 
dybjer pollack editors informal proceedings joint types workshop categories type theory 
thomas hildebrandt prakash panangaden glynn winskel 
relational model non deterministic dataflow 
sangiorgi de simone pages 
anthony hoare 
communicating sequential processes 
englewood cliffs 
martin hyland 
category theory 
notes taken martin hyland course 
bart jacobs 
categorical type theory 
phd thesis university nijmegen 
jensen 
inductive inference reflexive domains 
technical report csr department computer science university edinburgh 
peter johnstone 
topos theory volume mathematical monographs 
academic press 
peter johnstone 
stone spaces volume cambridge studies advanced mathematics 
cambridge university press 
peter johnstone 
categories 
notes taken paul taylor peter johnstone course 
andr joyal moerdijk 
completeness theorem open maps 
annals pure applied logic 
andr joyal moerdijk 
algebraic set theory volume london mathematical society lecture note series 
cambridge university press 
andr joyal mogens nielsen glynn winskel 
bisimulation open maps 
information computation 
gregory kelly 
basic concepts enriched category theory volume london mathematical society lecture notes series 
cambridge university press 
gregory kelly 
coherence compact closed categories 
journal pure applied algebra 
gregory kelly ross street 
review elements categories 
category seminar proceedings sidney category theory seminar pages 
springer verlag 
anders kock 
monads structures adjoints units 
journal pure applied algebra 
joachim lambek 
fixpoint theorem complete categories 
math 

kim larsen arne skou 
bisimulation probabilistic testing 
information computation 
william lawvere 
equality hyperdoctrines comprehension schema adjoint functor 
applications categorical algebra proc 
sympos 
pure math vol 
xvii new york pages 
amer 
math 
soc 
william lawvere 
metric spaces generalized logic closed categories 
rend 
sem 
mat 
fis 
milano 
daniel lehmann 
categories fixpoint semantics 
phd thesis university warwick 
lics proceedings eleventh annual ieee symposium logic computer science 
ieee computer society press 
lics proceedings twelfth annual ieee symposium logic computer science 
ieee computer society press 
saunders mac lane 
categories working mathematician volume graduate texts mathematics 
springer verlag 
saunders mac lane moerdijk 
sheaves geometry logic topos theory 
springer verlag 
michael makkai robert par 
accessible categories foundations categorical model theory volume contemporary mathematics 
american mathematical society 
mcmillan 
technique state space search unfolding 
formal methods system design 
robin milner 
calculus communicating systems volume lecture notes computer science 
springer verlag 
robin milner 
calculi synchrony asynchrony 
theoretical computer science 
robin milner 
communication concurrency 
international series computer science 
prentice hall 
robin milner 
functions processes 
mathematical structures computer science 
robin milner 
polyadic ss calculus tutorial 
logic algebra specification marktoberdorf volume nato adv 
sci 
inst 
ser 
comput 
systems sci pages 
springer verlag berlin 
robin milner 
ss calculus 
lecture notes course 
robin milner 
calculi interaction 
acta informatica 
robin milner joachim parrow david walker 
calculus mobile processes 
information computation 
robin milner joachim parrow david walker 
calculus mobile processes 
ii 
information computation 
robin milner joachim parrow david walker 
modal logics mobile processes 
theoretical computer science 
eugenio moggi 
notions computations monads 
information computation 
nielsen schmidt editors 
icalp colloquium automata languages programming volume lecture notes computer science 
springer verlag 
mogens nielsen allan cheng 
observe behaviour categorically 
proceedings fst tcs fifteenth conference foundations software technology theoretical computer science volume lecture notes computer science pages 
springer verlag 
mogens nielsen gordon plotkin glynn winskel 
petri nets event domains part theoretical computer science 
peter hearn tennent 
relational parametricity local variables 
proceedings th acm symposium principles programming languages pages 
acm 
robert par 
simply connected limits 
canadian journal mathematics 
park 
concurrency automata infinite sequences 
theoretical computer science th gl conference volume lecture notes computer science 
springer verlag 
du pavlovi 
predicates fibrations 
phd thesis university utrecht 
andrew pitts 
product change base toposes 
cahiers de topologie diff erentielle cat 
andrew pitts 
induction principle recursively defined domains 
theoretical computer science 
andrew pitts 
relational properties domains 
information computation 
gordon plotkin 
powerdomain construction 
siam journal computation 
gordon 
plotkin 
structural approach operational semantics 
technical report daimi fn department computer science university aarhus 
reprinted 
gordon plotkin 
powerdomain countable nondeterminism 
nielsen schmidt pages 
gordon 
plotkin 
domains 
technical report department computer science university edinburgh 
includes pisa notes 
gordon plotkin 
algebraic completeness compactness enriched setting 
invited lecture workshop logic domains programming languages 
darmstadt 
john power 
coherence bicategories finite bilimits 
gray scedrov pages 
john power 
general coherence result 
journal pure applied algebra 
john power 
categorical pasting theorem 
journal algebra 
john power 

information computation 
john power 
elementary definition pseudo monads 
private communication 
vaughan pratt 
modelling concurrency partial orders 
international journal parallel processing 
vaughan pratt 
modelling concurrency geometry 
proceedings th acm symposium principles programming languages pages 
acm press 

behaviour structures nets 
fundamenta informatica 
jan rutten daniele turi 
initial algebra final coalgebra semantics concurrency 
de bakker editor proceedings rex workshop decade concurrency reflections perspectives volume lecture notes computer science pages 
springer verlag 
sangiorgi de simone editors 
proceedings th international conference concurrency theory concur volume lecture notes computer science 
springer verlag 
davide sangiorgi 
expressing mobility process algebras order higher order paradigms 
phd thesis university edinburgh 
davide sangiorgi 
ss calculus internal mobility agent passing calculi 
technical report inria sophia antipolis 
davide sangiorgi 
bisimulation higher order process calculi 
information computation 
sassone mogens nielsen glynn winskel 
models concurrency classification 
theoretical computer science 
dana scott 
continuous lattices 
lawvere editor toposes algebraic geometry logic volume lecture notes mathematics pages 
springer verlag 
dana scott 
domains denotational semantics 
nielsen schmidt pages 
seely 
linear logic autonomous categories cofree algebras 
gray scedrov pages 
peter sewell 
rewrite rules bisimulation congruences 
sangiorgi de simone pages 
harold simmons 
glueing construction lax limits 
mathematical structures computer science 
smyth gordon plotkin 
category theoretic solution recursive domain equations 
siam journal computing 
ian stark 
fully domain model ss calculus 
lics pages 
ross street 
fibrations bicategories 
cahiers de topologie eom etrie diff erentielle cat xxi 
ross street 
cauchy characterization enriched categories 
rend 
sem 
mat 
fis 
milano 
paul taylor 
limit colimit coincidence categories 
manuscript 
bent thomsen 
plain chocs second generation calculus higher order processes 
acta informatica 
daniele turi 
functorial operational semantics denotational dual 
phd thesis cwi amsterdam 
daniele turi gordon plotkin 
mathematical operational semantics 
lics pages 
van dalen bezem editors 
computer science logic 
th international workshop csl annual conference european association computer science logic 
selected papers volume lecture notes computer science 
springer verlag 
mitchell wand 
fixed point constructions order enriched categories 
theoretical computer science 
glynn winskel 
synchronisation trees 
theoretical computer science 
glynn winskel 
category labelled petri nets compositional proof system 
lics proceedings third annual symposium logic computer science pages 
ieee computer society press 
glynn winskel 
formal semantics programming languages 
foundations computing series 
mit press 
glynn winskel 
presheaf semantics value passing processes extended 
montanari sassone editors concur proceedings th international conference concurrency theory volume lecture notes computer science pages 
springer verlag 
glynn winskel 
ambients presheaves 
manuscript 
glynn winskel 
linear metalanguage concurrency 
proceedings amast lecture notes computer science 
springer verlag 
appear 
glynn winskel mogens nielsen :10.1.1.21.5791
models concurrency 
handbook logic computer science vol 
oxford sci 
publ pages 
oxford univ press 
glynn winskel mogens nielsen :10.1.1.21.5791
models concurrency 
pitts dybjer editors semantics logics computation 
cambridge university press 
wood 
ii 
cahiers de topologie eom etrie diff erentielle cat 
oswald 
lecture notes topoi 
world scientific publishing nj 

