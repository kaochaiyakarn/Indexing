structural approach reversible computation samson abramsky oxford university computing laboratory reversibility key issue interface computation physics growing importance miniaturization progresses physical limits 
foundational reversible computing date focussed simulations low level machine models 
contrast develop structural approach 
show high level functional programs mapped compositionally syntax directed fashion simple kind automata immediately seen reversible 
size automaton linear size functional term 
mathematical terms building concrete model functional computation 
construction stems directly ideas arising geometry interaction linear logic understood knowledge topics 
fact serves excellent 
time interesting logical delineation reversible irreversible forms computation emerges analysis 
importance reversibility computation foundational medium term practical reasons established 
quote excellent summary buhrman tromp vit nyi reversible computation landauer demonstrated logically irreversible operations physical computer necessarily dissipate energy generating corresponding amount entropy bit information gets irreversibly erased logically reversible operations principle performed dissipation free 
currently computations commonly irreversible physical devices execute fundamentally reversible 
basic level matter governed classical mechanics quantum mechanics reversible 
contrast possible cost efficiency loss generating thermal entropy environment 
computational device technology rapidly approaching elementary particle level argued times effect gains significance extent efficient operation operation computers requires reversible mismatch computing organization reality express friction computers dissipate lot heat mode operation reversible possibly quantum mechanical 
previous approaches aware proceed showing standard low level irreversible computational model turing machines simulated reversible version model 
approach structural 
firstly define simple model computation directly reversible strong sense automaton model dual automaton op defined quite trivially computations exactly time reversals computations establish connection models functional computation 
show model gives rise combinatory algebra derive universality easy consequence 
method establishing universality potential significance important issue program reversible computations 
quote currently algorithms programs designed reversible principles write reversible programs hand unnatural difficult 
natural way compile irreversible programs reversible ones 
approach seen providing simple compositional compilation high level functional programs reversible model computation 
offers novel perspective reversible computing 
approach conceptual interest constructions quite concrete directly ideas stemming linear logic geometry interaction developed previous author number colleagues :10.1.1.42.8456
seen concrete manifestation foundational developments 
knowledge linear logic geometry interaction required read 
fact serve topics concrete point view 
time interesting logical delineation reversible irreversible forms computation emerges analysis 
related geometry interaction initiated girard sequence papers extensively developed danos regnier malacaria see 
particular danos regnier developed computational view 
gave compositional translation calculus form reversible machine 
note thesis mackie done author supervision develops implementation paradigm functional programming languages 
develops connections mathematical model computation computational schemes emphasis reversibility 
see main contributions follows firstly approach particularly simple direct 
mentioned believe accessible prior knowledge linear logic 
basic computational formalism related directly standard ideas term rewriting automata combinatory logic 
contrast literature technical esoteric outsiders field 
hope may help open ideas field wider community 
interesting new perspectives standard ideas idea biorthogonal term rewriting system linear combinatory logic introduced author 
point view novelties 
particular develop reversible computational structure syntax free fashion 
consider general space reversible automata define linear combinatory algebra structure universe pinning constructions induction preconceived syntax 
allows resulting structure revealed clearly definitions results stated generally 
believe descriptions linear combinators automata application replication constructions automata give particularly clear enlightening perspective approach reversible functional computation 
discussion section boundary reversible irreversible computation relationship pure vs applied functional calculi multiplicative exponential vs additive levels linear logic conceptual interest surely worth exploration 
results section universality consequent somewhat surprising non closure linear application finitely describable partial involutions give rise interesting apparently challenging open problem characterization realizable partial involutions 
computational model formulate computational model kind automaton simple term rewriting capabilities 
assume familiarity basic notions term rewriting may gleaned opening pages standard introductory accounts 
particular shall assume familiarity notions signature term algebras ground terms terms set variables respectively 
exclusively finite signatures 
assume familiarity notion general unifier terms write general unifying substitution unified 
define pattern matching automaton structure qf finite set states qf distinguished initial final states finite set transition rules written 
qn rn sn qi ri si variables occurring si subset occurring ri convenient assume variable appears rule 
stipulate incoming transitions initial state outgoing transitions final state qf qi configuration pair state ground term 
induces relation configurations iff qi ri si 
note pattern ri match term akin pattern matching functional programming languages sml haskell reason choice terminology 
note cost computing transition relation independent size input term working fixed pattern matching automaton means basic computation steps performed constant time space indicating computational model reasonable level granularity 
computation starting initial ground term input sequence computation successful terminates configuration qf tk case tk output 
see pattern matching automaton device computing relations ground terms 
say pattern matching automaton qf qi ri si orthogonal conditions hold non ambiguity qi qj ri rj 
left linearity variable occurs ri 
assumption left linearity see shall shortly standard assumption algorithmics unification immediate sub terms term accessed constant time 
note non ambiguity stated simpler form standard version term rewriting systems advantage fact dealing simple case pattern matching 
clearly effect non ambiguity computation deterministic configuration transition rule applicable relation partial function 
pattern matching automaton define op qf op op si ri qi define biorthogonal aop orthogonal patternmatching automata 
note biorthogonal automaton aop clear computation biorthogonal automata reversible deterministic step step fashion 
computation qf tn biorthogonal automaton computation qf tn aop aop biorthogonal automaton op note biorthogonal automata linear sense rule variables occur variable occurs exactly exactly duplicating discarding sub terms matched variables applying rule op orthogonality standard important condition term rewriting systems 
biorthogonality stronger constraint term rewriting systems usually considered satisfy condition 
fact familiar examples biorthogonal rewriting systems associative commutative rewriting similar usually considered notions rewriting modulo computational rewriting systems right 
model computation class biorthogonal patternmatching automata automata shall consider refer simply automata 
reader surely agree computational model quite simple seen reversible direct immediate fashion 
turn task establishing universality 
possible represent computational model entirely terms standard notions term rewriting systems 
briefly sketch done 
automaton qf expand sorted signature signature sorts values states configurations 
operation symbols arguments results sort state corresponding constant sort binary operation transition rules turn rewriting system standard sense orthogonality standard meaning 
need focus initial terms form normal forms form qf ground 
main reason automaton formulation expose salient structure helpful defining understanding significance constructions follow 
background combinatory logic section briefly review basic material 
details see 
recall combinatory logic algebraic theory cl signature binary operation application written infix constants subject equations application associates left 
note define verify key fact combinators functionally complete simulate effect abstraction 
specifically define bracket abstraction terms tcl theorem fv cl 
combinator defined bracket abstraction defining equation 
combinatory church numerals defined define 
partial function represented combinatory term tcl defined equal cl undefined normal form 
basic result computational universality cl theorem theorem partial functions representable cl exactly partial recursive functions 
linear combinatory logic shall system combinatory logic linear combinatory logic :10.1.1.42.8456
seen finer grained system standard combinatory logic previous section interpreted 
exposing finer structure linear combinatory logic offers accessible insightful path goal mapping functional computation simple model reversible computation 
linear combinatory logic seen combinatory analogue linear logic interpretation standard combinatory logic linear combinatory logic corresponds interpretation intuitionistic logic linear logic 
note combinatory systems considering type free logic free purely equational 
definition linear combinatory algebra consists data applicative structure unary operator distinguished elements satisfying identities associate left write variables ranging 
composition cut 
exchange 
identity 
weakening 
dereliction 
comultiplication 
monoidal functoriality 
contraction notion lca corresponds hilbert style axiomatization fragment linear logic 
principal types combinators correspond axiom schemes name 
computed hindley milner style algorithm equations 







linear function type linearity means argument exactly allows arbitrary copying object type 
standard combinatory algebra consists pair nonempty set binary operation distinguished elements bs cs ks ws satisfying identities ranging 
bs 
cs 

ks 
ws note equivalent familiar definition sk combinatory algebra previous section 
particular ss defined bs cs ws 
linear combinatory algebra 
define binary operation follows define 
note consider elements 
bs 
cs 

ks 
ws theorem linear combinatory algebra 
elements bs cs ks ws defined standard combinatory algebra 
mention special case arise reversible model 
affine combinatory algebra linear combinatory algebra combinator satisfies stronger equation note case define identity combinator affine combinatory algebras fix signature remainder 

shall discuss minimal requirements signature section 
write set partial injective functions 
operations replication linear application lapp frr frl fll flr fij operations relational algebra union composition reflexive transitive closure 
idea terms form correspond interactions functional process represented environment terms form correspond interactions argument functional process represented linear application function interacts copy argument state changes function interacts fresh copies argument necessarily available computation proceeds 
purpose replication operation described previously precisely argument copyable argument constructor tag different copies 
flow control linear application indicated diagram frl frr fll function respond immediately request environment consulting argument frr send message argument frl initiates dialogue fll flr ends response environment flr 
protocol mediated top level constructors consumed operation linear application 
partial involutions note op op relational converse say partial involution op write set partial involutions 
proposition partial involutions closed replication linear application 
proof immediate partial involutions closed replication 
suppose partial involutions lapp show lapp cases 
case case lapp required 
case wk 
wk wk wk wk wk 
involutions implies wk wk wk wk wk 
lapp required 
realizing linear combinators partial involutions partial injective map finitely describable family ti ui ti ui graph symmetric closure ti ui 
ranges ground substitutions 
write finite description partial involution refer expressions rules 
identity combinator simple case consider identity combinator defining equation picture combinator evidently applied argument achieve intended effect tree represents way applicative structure encoded constructors reflected definition lapp 
applied argument branch connected branch connected output 
equation means information leaves tree 
achieved rule yields definition automaton show automaton representing argument lapp ai fa input lapp ai constant combinator consider combinator defining equation defining equation tree diagram defining equation means need information 
accomplished rule 
note second argument get accessed rule 
bracketing combinator turn complex example bracketing combinator defining equation 
arguments applicative structure defining equation applied applying means automaton realizing access argument result positions shown tree diagram 
requires output connected output translates rule 
similarly output connected leading rule 
connected leading rule 
commutation combinator combinator analyzed similar fashion 
defining equation tree diagram need connect inversion left right ordering corresponds commutative character combinator obtain set rules rc note point linear combinatory completeness yields striking terms patterns accessing arguments results arbitrarily nested applicative generated just combinators linear application 
note multiplicative level need unary operators term algebra 
deal exponential binary constructor needed 
dereliction combinator start dereliction combinator defining equation notice combinator expects argument certain form equational rule fire form 
tree need connect output copy input 
constant pick copy obtain rule 
comultiplication combinator comultiplication operator equation tree note typical pattern output form typical pattern input form 
combinator control shape sub term simply unify patterns 
nature replication operator impose structure copy tag knowledge changed argument combinator applied match patterns fact term algebra allows arbitrary nesting constructors write pattern input obtain rule 

note rule embodies associativity isomorphism pairing course free term algebra constructor certainly associative 
functional distribution combinator combinator equation 
expresses closed functoriality respect linear hom 
concretely move application inside achieved commuting constructors connect 
duplication combinator consider duplication combinator connect 
need connect ina ina copy tag field split address space constructors tag tells copy connected second input obtain rules combinatory completeness tells limited stock combinators definable patterns application expressed universal model computation 
affine combinatory algebras theorem fb fc fk fd ff fw affine combinatory algebra subalgebra theorem variation results established see particular propositions combinatory algebra partial involutions studied :10.1.1.42.8456
ideas construction stem linear logic geometry interaction form developed author number colleagues :10.1.1.42.8456
combinatory completeness tells limited stock combinators definable patterns application expressed universal model computation 
automatic combinators seen pattern matching automaton seen device computing relation ground terms 
relation ra set pairs computation qf 
case biorthogonal automaton relation ra fact partial injective function write fa 
note fop converse fa partial injective function 
previous section defined linear combinatory algebra set partial involutions 
want define subalgebra consisting partial involutions realized implemented biorthogonal automaton 
refer combinators automatic analogy automatic groups structures sequences 
operations automata replication automaton qf variable appearing rule define qf qf pf lapp qf int qf rrr qf qf rrl qf rll pf qf pf qf qf rii int int rli pf int ril qf int qf qf int defined linear application 
note condition necessary ensure linearity biorthogonality easily verified 
linear application see 
disjoint union simply assume necessary disjoint 
key result need 
proposition fa 
ii lapp fa fb lapp 
proof fa iff fa iff iff 
ii lapp 
suppose lapp fa fb frr frl fll fll wk wk wk wk flr wk case qf qf 
case qf pf qf pf wk qf wk wk pf wk wk qf qf 
lapp fa fb 
converse inclusion proved similarly 
finitely describable partial involutions automatic suppose finite description partial involution define corresponding automaton qf qf qf qf 
immediate fa note internal states rules special form 
features typical automata corresponding normal forms interpretation functional computation 
automatic universe results previous sections yield theorem immediate consequence 
theorem affine combinatory sub algebra carrier set fa biorthogonal automata affine combinatory sub algebra obtain subalgebra partial involutions realized automata simple behaviours computationally universal 
partial involutions seen copy cat strategies 
minimal requirements pause briefly consider choice particular signature 
fact eliminate unary operators favour constants say representation 
turn eliminate definitions 
binary operation constant pure theory binary trees suffice 
hand signature contains unary operators constants pattern matching automata simulated ordinary automata stack computationally universal 
restricted situation interest 
suffices interpret affine calculus 
recall combinators defining equations bck algebras admit bracket abstraction affine calculus subject constraint applications formed variable occurs free affine calculus strongly normalizing number steps linear size initial term reduction strictly decreases size term 
build bck algebra automata linear standard application defining automata combinators binary operation symbol give set transition rules automata rk linear version rb rc note unary operators appear signature automata seen performing prefix string rewriting 
compiling functional programs reversible computations recall pure calculus rich represent data types integers booleans pairs lists trees general inductive types control structures including recursion higher order functions continuations 
representation database query languages pure calculus developed 
calculus compiled combinators fact extensively studied implementation technique 
combinatory weak reduction capture reduction suffices capture computation concrete data types integers lists shown theorem 
combinator algebras form basic ingredient realizability constructions powerful tool building models expressive type theories textbook presentations see 
results previous section combinator program compiled syntax directed fashion biorthogonal automaton note size linear remains specify read result computation borne mind automaton giving description behaviour functional process corresponding program compiled 
case terms input output computations correspond directly inputs outputs functional computation 
input compiled part functional term evaluated standard functional programming generally 
automaton resulting compiling program input deduce value output provided output concrete value 
focus boolean valued computations result computation true false represent combinatory expressions respectively 
virtue standard results combinatory computability theorem total recursive predicate closed combinator expression holds cl note compositionality program compiled automaton input value compiled linked required 
cl automaton obtained term theorem fa fk fa fk test holds run input term 
obtain result form holds obtain result form 
generalizes immediately predicates tuples lists trees explained 
generally computations integer returned run sequence computations automaton determine value represents 
concretely church numerals sequence look 
firstly run automaton input 
output form term result 
form form successor run automaton input term 
get response form result successor 

effect performing meta computation prima facie irreversible step reversible computation read output 
argued analogous happens implementation functional programming language step result computation converted output side effect placing output device achieved 
aspect recovering output deserves attention hope study detail 
pure vs applied calculus discussion pure calculus cl constants rules 
integers booleans represented terms 
fact calculus combinatory logic represent data control important facet universality usual practice functional programming facility applied calculi 
important note option open wish retain reversibility 
extend calculus constants boolean values conditional usual rules continue interpret terms orthogonal pattern matching automata biorthogonality reversibility lost 
stated fundamentally terms linear logic multiplicative exponential fragment linear logic calculus lives interpreted perfectly reversible fashion possibly loss soundness conversion rules fails additives 
reflected formally fact passage modelling pure calculus multiplicative exponential linear logic modelling pcf property partial injectivity functions fa history free strategies lost non injective partial functions 
appears gives fundamental delineation boundary reversible irreversible computation logical terms 
reflected denotational semantics calculus pure calculus complete lattices arise naturally canonical models formally property lattice preserved constructions function space lifting inverse limit constants added modelled sums inconsistency arises natural models cpo 
suggests pure calculus provides ultimate reversible simulation irreversible phenomena computation 
universality minor variation ideas previous section suffices establish universality computational model 
recursively enumerable set 
closed combinatory term cl normal form 
automaton compiled reduction membership question produces output response input 
immediate consequence result 
theorem termination biorthogonal automata undecidable fact complete 
simple corollary derive result 
proposition finitely describable partial involutions closed linear application 
proof linear combinators interpreted finitely describable partial involutions clear replication preserves finite 
linear application preserved finite combinator terms denote finitely describable partial involutions 
contradict previous theorem termination finitely describable partial involution reduces finite number instances pattern matching decidable 
leads open question characterize partial involutions alternatively arise denotations combinator terms 
abramsky lazy calculus research topics functional programming ed 
turner pp 

addison wesley 
abramsky jagadeesan new foundations geometry interaction information computation 
conference version appeared lics 
abramsky jagadeesan 
games full completeness multiplicative linear logic journal symbolic logic vol 

abramsky jagadeesan malacaria full abstraction pcf extended 
proceedings tacs hagiya mitchell eds 
springer lncs vol 
pp 

abramsky retracing paths process algebra 
proceedings concur springer lecture notes computer science vol 
pp 

springer verlag 
abramsky interaction combinators complexity 
lecture notes siena italy 
abramsky fully complete model ml polymorphic types proceedings csl springer lncs volume pp 

abramsky jagadeesan malacaria full abstraction pcf 
information computation 
extended appeared 
abramsky longley 
realizability models strategies manuscript 
abramsky scott 
geometry interaction linear combinatory algebras 
mathematical structures computer science 

automatic sequences theory applications generalizations 
cambridge university press 
asperti longo 
categories types structures 
mit press 
avron semantics proof theory linear logic 
theoretical computer science 
baader nipkow term rewriting 
cambridge university press 
barendregt lambda calculus studies logic vol 
north holland 
elementary complexity geometry interaction 
fundamenta informaticae 
bennett 
logical reversibility computation 
ibm res 
development 
bennett 
thermodynamics computation review 
int 
theoret 
phys 
buhrman tromp vit nyi time space bounds reversible simulation 
proceedings icalp springer lecture notes computer science vol 

crole 
categories types 
cambridge university press 
danos regnier 
local asynchronous beta reduction 
proceedings eighth international symposium logic computer science ieee press 
danos regnier reversible irreversible optimal machines electronic notes theoretical computer science 
dershowitz 
jouannaud 
rewrite systems 
handbook theoretical computer science volume 
elsevier 
epstein cannon holt levy paterson thurston word processing groups jones bartlett 

girard linear logic 
theoretical computer science 

girard geometry interaction interpretation system logic colloquium ed 
ferro north holland pp 


girard geometry interaction ii deadlock free algorithms 
proceedings martin lof mints eds 
springer lncs vol 
pp 


girard geometry interaction iii additives 


girard lafont regnier eds 
advances linear logic london math 
soc 
series camb 
univ press 

girard lafont taylor 
proofs types 
cambridge university press 

categorical approach linear logic geometry proofs full completeness 
ph thesis university ottawa 
hillebrand kanellakis mairson database query languages embedded typed lambda calculus proceedings lics pp 
ieee computer society press 
hindley seldin 
combinators calculus 
cambridge university press 
hindley basic simple type theory cambridge tracts theoretical computer science cambridge univ press 
hines algebra self similarity applications ph thesis university wales bangor 
hines categorical theory self similarity theory applications categories 
joyal street verity traced monoidal categories 
math 
proc 
camb 
phil 
soc 

khoussainov nerode automatic presentations structures springer lecture notes computer science 
kuhn 
method enumerating cosets group canonical system 
proceedings issac 
klop 
term rewriting systems 
handbook theoretical computer science volume abramsky gabbay maibaum eds pp 

oxford university press 
landauer 
irreversibility heat generation computing process 
ibm res 
development 
lawson 
inverse semigroups theory partial symmetries 
world scientific 

machines de turing 
rendus 
ian mackie geometry implementation ph thesis imperial college university london 
malacaria regnier 
results interpretation calculus operator algebras 
proceedings sixth international symposium logic computer science ieee press 
milner tofte harper 
definition standard ml 
mit press 
minsky 
computation finite infinite machines 
prentice hall 
peyton jones 
implementation functional programming languages 
prentice hall 
peyton jones ed 
haskell non strict purely functional language 
available www haskell org 
plotkin 
call name call value calculus 
theoretical computer science 
troelstra lectures linear logic 
center study language information lecture notes 

