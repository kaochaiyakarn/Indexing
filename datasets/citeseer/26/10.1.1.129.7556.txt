concepts linguistic support generic programming douglas gregor indiana university osl iu edu bjarne stroustrup texas university bs cs tamu edu permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
oopsla october portland oregon usa 
copyright acm 

jaakko rvi texas university cs tamu edu gabriel dos reis texas university gdr cs tamu edu jeremy siek rice university jeremy siek rice edu andrew lumsdaine indiana university osl iu edu bination features allowed generic programming emerged important technique development highly reusable efficient software libraries 
generic programming enabled flexibility templates type parametrization mechanism 
power templates comes price generic template libraries difficult develop non template libraries misuse results notoriously confusing error messages 
currently defined templates unconstrained type checking templates performed late compilation process template combined definition 
improve support generic programming introduce concepts express syntactic semantic behavior types constrain type parameters template 
concepts type checking template definitions separated uses making templates easier easier compile 
improvements achieved limiting flexibility templates decreasing performance fact expressive power increased 
describes language extensions supporting concepts expression standard template library implementation conceptgcc compiler 
concepts candidates inclusion upcoming revision iso standard 
categories subject descriptors programming languages language constructs features data types programming languages language constructs features polymorphism software engineering reusable software reusable libraries different programming paradigms including generic programming generative programming template metaprogramming 
flexibility templates comes unconstrained nature template perform operation template parameters including compile time type computations allowing emulation basic features required diverse programming paradigms 
essential part templates ability provide abstraction performance degradation templates provide sufficient information compiler optimizers especially inliner generate code optimal time space 
consequently templates preferred implementation style vast array reusable efficient libraries built generic programming methodology exemplified standard template library stl 
aided discovery numerous ad hoc template techniques libraries powerful flexible expressive :10.1.1.22.427
improvements come cost implementation complexity authors libraries typically rely grab bag template tricks complex poorly documented 
library interfaces rigorously separated library implementation complexity implementation library problem users 
templates rely absence modular separate type checking flexibility performance 
complexities library implementation leak library users 
problem manifests visibly spectacularly poor error messages simple general terms design languages mistakes 
consider keywords generic programming constrained generics parametric polymorphism templates concepts list int lst sort lst lst 
attempting compile code version gnu compiler produces kilobytes output language supports parametrized types functions form templates 
templates provide unique different error messages 
worse errors reported provide line numbers file names point implementation stl sort function helper functions 
clue provided users error triggered code bug stl implementation innocuous line output sort list cpp instantiated actual error case stl sort requires pair random access iterators iterators move number steps forward backward constant time 
stl sort list cpp function int main sort list cpp error matching function call sort std list iterator int std list iterator int stl algo note candidates void std sort iter iter iter std list iterator int sort list cpp note concept map requirement std std list iterator int 
conceptgcc error message produced attempting compile call stl sort list iterators 
list container provides bidirectional iterators move forward backward step time 
random access iterator bidirectional iterator concepts design documentation stl 
concept describes set requirements generic algorithm implemented function template places template parameters 
concepts representation language user failure meet concept requirements stl algorithm detected compiler attempts instantiate algorithm 
absence modular type checking templates means definitions templates type checked independently uses 
causes serious problems implementers generic libraries bugs go uncaught prior deployment 
particular common inconsistencies exist documented type requirements implementation function template 
form separate type checking somewhat approximated existing language mechanisms 
approach concept checking constraints checking concepts language entities 
result concept checking libraries quite difficult design manually verified suffer portability problems 
modern template libraries rely set naming documentation conventions express fundamental design ideas bidirectional iterator random access iterator abstractions state requirements generic algorithms terms ideas 
root cause problems templates fundamental design ideas directly expressed templates compilers detect errors early report terms library documentation 
direct language support concepts addresses problem 
describes set extensions directly supports notion concepts providing greater expressive power overloading improved modular type checking templates 
example concepts directly support expression checking concepts bidirectional iterator random access iterator 
concepts place constraints template parameters enabling modular type checking templates 
having concepts directly expressible templates easier write 
example kilobytes irrelevant information experimental compiler supporting concepts conceptgcc produces error message shown erroneous stl code 
brevity improvements error message 
importantly error message refers directly user code erroneous call sort 
user informed sort function matches cause failure unsatisfied requirement mutable random access iterator concept list iterator random access iterator sort 
completely typechecking call sort call site problem stl implementation details leaking user error message eliminated 
improvement error messages result fundamental changes way templates specified requirements algorithm arguments explicit 
allows reason template code incidentally gives compiler information needs produce radically better error messages early 
gives information needed improve overloading 
primary challenge designing system constrained generics templates providing language features support current successful uses template system compromising ideal modular type checking templates damaging performance 
focus supporting generic programming paradigm develop generic libraries 
early discussions constrained generics 
time solution stated problem providing constraints unacceptably limiting flexibility performance 
objective standard extended constrained generics explicit report laying main design goals 
existing programming languages support generics form 
early attempts building standard template library focused scheme ada settling 
evaluated languages including java cecil ml haskell ability express ideas generic programming :10.1.1.61.9949
building results experience gained generic programming language designed concepts goals mind provide direct support generic programming programs libraries developed generic programming methodology expressed clearly relying template tricks documentation conventions 
templates easier write easier making template requirements arguments explicit concepts enabling modular type checking making template overloading robust 
provide clear transition path today unconstrained templates templates constrained concepts 
libraries built generic programming methodology concepts breaking source compatibility vast majority user programs 
making programs verbose flexible efficient 
retain compatibility breaking existing code introducing language rules differ significantly existing rules 
reported part large going effort led authors provide concepts iso standard 
reports implementation constrained generics concepts extensive evaluation developing generic libraries 
primary aim resulting language library collectively called gain practical experience concepts 
goals ambitious cases contradictory 
report inherent trade modular type checking generic programming notion specialization 
specialization discussed section part general generic programming 
section presents language extensions section gives overview implementation compiler 
evaluate effective ness language support concepts providing stl implementation perspective library users library developers 
analysis discussion practical impact nearly modular type checking templates discussed section 
generic programming generic programming systematic approach designing organizing software focuses finding general formulation algorithm efficient implementation 
primary goal generic programming algorithms widely applicable generic programming referred algorithm oriented 
lifting abstraction generic programming process derives generic algorithms families concrete non generic implementations exhibit commonality 
lift away unnecessary requirements types implementation raising level abstraction 
consider concrete implementations sum 
computes sum doubles stored array second computes sum integers linked list 
double sum double array int double int array return struct node node int data int sum node node int data return abstractly implementations thing traverse collection elements sum values 
implementations impose additional requirements ones unnecessary purposes summation 
implementation elements type double stored array 
second implementation elements type int stored node representation linked list 
fundamentally summing elements collection requires ability visit elements collection add elements 
generic algorithm able correctly collection elements supporting traversal addition elements 
concepts specify requirements template inputiterator iter addable iter value type assignable iter value type value type sum iter iter iter value type return sum algorithm implemented function template parameter iter iterator type 
algorithm type input iterator supports operation moving element operation accessing value testing iterator positions 
constraint template parameter iter stated template parameter list 
similarly iterator element type iter value type support addition assignment stated separate clause 
section explain syntax semantics concepts constraints detail 
suppose broaden family concrete implementations include computing product list integers int product node node int data return sum algorithm generalized compute products replacing addition parameters arbitrary binary operator initial element 
change arrive implementation stl accumulate algorithm template iter iter value type iter value type op assignable iter value type op result type iter value type accumulate iter iter iter value type op op op return accumulate algorithm arrays linked lists types meet requirements input iterator binary operation double double accumulate plus double node cons cons cons null int accumulate null multiplies int int sum null plus int review replaced requirements particular types double node requirements certain properties inputiterator :10.1.1.10.5121
specified policy specified operations carried 
lifting process summarized graphically follows sum range ts requires iterator range sum array double accumulate range ts requires iterator range op sum list int product list int bottom lie concrete implementations form basis lifting process 
move find increasingly generic implementations subsume concrete implementations step removing unnecessary requirements 
lifting process iterative limit lies ideal algorithm generic implementation subsumes concrete implementations algorithm specifying minimum set requirements achieve maximum reusability sacrificing efficiency 
random access bidirectional forward input output 
refinement relationships stl iterator concepts edge read refines algorithm specialization addition building highly reusable algorithms generic programming concerned building highly efficient algorithms 
natural tension reusability efficiency greater efficiency better algorithm enabled additional requirements adding requirements decreases opportunities reuse 
refer algorithms specialized specialized algorithms provide better performance implement addition generic algorithm provide automatic dispatching appropriate algorithm properties input types 
note give genericity program terms properties types terms particular types 
simple important example algorithm specialization stl advance function moves iterator forward steps 
shows versions advance second specialized 
slow advance iterators provide increment fast advance iterators jump forward arbitrary distances constant time operator 
template inputiterator iter void advance iter difference type template randomaccessiterator iter void advance iter difference type call advance specific overload selected 
consider list int advance dispatches slow advance vector int advance dispatches fast advance call advance dispatches version input iterator overload matches list iterator random access iterator 
second call advance potentially dispatch version vector iterator input iterator random access iterator 
random access iterator includes requirements input iterator second advance specialized algorithm chosen favor 
concepts generic algorithms specified terms properties types terms particular types 
terminology generic programming concept formalization abstraction set requirements type set types integers operations 
type implements requirements concept said model concept 
requirements may syntactic semantic performance related 
requirements operators iterators examples syntactic requirements 
documentation libraries requirements typically expressed form valid expressions called patterns allows expression requirements operations directly language 
second kind syntactic requirement associated types types collaborate concept operations determined modeling type 
example associated value distance types iterator state type value iterator points type measure distances iterators respectively 
example semantic requirement iterator equality imply dereferencing yields value implies requirement operator execute constant time performance requirement random access iterator concept 
include support semantic performance requirements support investigation 
concept may incorporate requirements concept case concept said refine second 
families related concepts called concept taxonomies form strong organizational basis generic libraries 
particular concepts describe essential abstractions entire domain provide common building blocks implementing large number generic algorithms lead uniform interface generic algorithms domain 
illustrates concept taxonomy standard template library iterator concepts 
concept parametrized just type commonly concept involves multiple types specifies relationships 
example algebraic concept vector space involves types vector type scalar type 
similarly concept parametrized integer values operations 

language support concepts translates ideas generic programming small set language extensions 
generic algorithms data structures expressed templates constraints template parameters 
constraints expressed terms concepts clauses template parameter list 
concept interface definition set requirements associated types signatures concept map definition provides mechanism declaring type satisfies concept mapping type requirements concepts providing required operations associated types 
illustrate major concept features standard library min function concept typename bool operator template typename const min const const return 
definition specifies concept comparable type models comparable provide operator objects returns boolean result 
second definition specifies constrained function template min applied types model comparable 
find smaller objects min provided compare 
notions smaller conventionally expressed 
example complex numbers distance abs algorithms suitable comparisons 
map abs complex number required min concept map complex bool operator complex complex return abs abs int min 
definition concept map establishes type model comparable concept supplied 
function illustrates call min call site type bound concept map satisfies min comparable constraint 
constraining templates concepts syntax template declarations definitions extended include clause consisting set requirements 
template contains clause called constrained template 
simple example clause containing requirements template typename assignable void swap tmp copy constructor copy assignment tmp concept name applied type assignable indicates meet requirements assignable concept int int swap int assignable copy constructible 
clause ensures swap instantiated type meets requirements assignable copy constructible concepts 
clause may constrain class templates members class templates 
example list template requires element type model copy constructible 
furthermore sort member function imposes requirement model comparable concept template class list public void sort note conventional abbreviation single type concepts template equivalent template typename concept constraint applies requirements concept template parameter set template parameters 
doing serves roles 
acts predicate template identifier requirements template clause satisfied 
example int meet requirements forward iterator 
provides scope resolution names template 
example value type int acting forward iterator conceptgcc error message shown section result type error concepts role 
call sort compiler determines actual type list iterator meets requirements concept stated sort clause iter case error message shown emitted 
requirements clause second role introduce assumptions context compilation 
example previous swap example line body swap uses copy constructor type existence guaranteed clause 
likewise assignments body swap typecheck assignable 
type checking fails requirements template enclosing scope provide suitable declarations operations template 
example consider erroneous implementation stl find algorithm template inputiterator iter typename val iter value type val iter find iter iter val return error example occurs comparison input iterator concept see provides comparison ordering 
unconstrained templates error go unnoticed find instantiated iterators support 
concepts error detected template definition time conceptgcc produces error message shown 
note iter value type definition find 
abbreviation inputiterator iter value type meaning find name value type concept map inputiterator iter concept maps explained 
type constraints concepts mentioned far user defined defined facilities described section 
built concept requires type expressions produce equivalent types 
concept built plays special role type checking constrained templates 
constraint appears clause arbitrary type expressions type checker assumes denote type 
example stl iter swap template requires value types iterators equivalent 
template iter template iter iter value type iter value type void iter swap iter iter swap find cpp function iter find iter iter val find cpp error match operator concepts note candidates bool std iter difference type operator const iter difference type const iter difference type 
conceptgcc error message produced attempting compile erroneous definition find 
type checker considers call swap knows type type type allows template argument deduction swap succeed 
iter swap function illustrates template may template 
case swap implicitly instantiated iterator value type swap requires copy constructible assignable 
mutable forward iterator concept includes requirement value type satisfy concepts 
clause iter swap introduces assumptions body iter swap allowing instantiation swap typecheck 
negative constraints constraints described far concept constraints satisfied concept arguments model concept 
example constraint inputiterator iter satisfied type iter model input iterator 
negative constraints hand satisfied concept arguments model concept 
negative constraint forwarditerator iter satisfied type iter input iterator iterator 
negative constraints useful directing algorithm specialization selection specializations ambiguous 
example provide different implementations sort different concept requirements template sequence value type void sort vector value type quick sort copy template void sort template value type void sort quick sort sort routine called sorted array models sorted sequence random access sequence concepts compilation fail ambiguity second third sort better 
negative constraints break ties excluding types model certain concepts 
augment clause third sort reject sorted sequences resolving ambiguity template value type void sort quick sort constraint propagation constraint propagation language mechanism gathers constraints type parameters induced constraints type parameter 
constraint propagation allows omission obvious constraints simplifying expression concept constrained templates 
experience lack constraint propagation leads verbose specifications generic functions interfaces 
concepts support constraint propagation propagating requirements concepts templates declaration entity concept generic function generic data structure clause entity 
example consider simple wrapper function sorts list template void sort container list sort list class template shown section requires type parameter model copy constructible concept 
list sort method introduces additional requirement comparable 
constraint propagation sort container function fail compile guarantee model copy constructible list 
copy constructible obvious declaration sort container ift copy constructible user created object type std list pass sort container 
constraint propagation scans declaration constrained function templates identifying places templates adds constraints templates clause 
constraints assumed hold type checking definition constrained function template discussed section 
sort container presence list declaration causes requirements list propagated essentially replacing declaration template void sort container list concepts provide special form constraint propagation types passed returned functions 
type passed value constraint propagated clause 
min value function propagates passed parameter value returned value 
constraint propagation generic function fail compile return statement attempts copy result 
template return 
concept definitions concept definition namespace level entity bundles set requirements names 
concept consists parameter list optional refinement clause optional clause body optionally specifying requirements specific concept 
body specify kinds requirements concept parameters signatures associated types nested clauses 
define concept named forward iterator single type parameter iter follows concept forwarditerator typename iter 
parameter concept placed concept name emphasize parameters mandatory 
template header done class function templates 
class function templates concept parameters sense concepts describe requirements parameters 
typename keyword specifies type parameter concepts template non type integer parameters 
refinement typically define concept terms previously defined concepts form inheritance called refinement 
refinement expressed syntax inheritance emphasize relationship concepts 
define concept bidirectional iterator terms forward iterator concept bidirectionaliterator typename iter forwarditerator iter 
concept may refine number concepts 
concepts contain state repetition refinements problem theoretically practically 
concepts contain sets requirements set union simply ignores duplicates 
associated types design types rely critically related types 
example graph type may refer types edges vertices graph operations 
concept graph express generic graph algorithms may require graph type name edge vertex types concept refer types signatures concept graph typename typename edge typename vertex edge find edge vertex vertex const associated types place holders actual types concept implicit parameters concept 
associated types nested inside concept entirely determined concept explicit parameters 
instance type graph determine edge vertex types part graph definition 
converse true may graph types share vertex edge types particularly common indexing types int opaque pointers void 
concept may provide default associated type 
default type need formed concept map provides type definition default isn 
example define input iterator concept require associated types default nested type definitions iterator concept inputiterator typename iter typename value type iter value type typename iter typename pointer iter pointer typename difference type iter difference type 
possible eliminate associated types replacing associated type new concept parameter 
doing concepts verbose concept need specify type parameters parameters directly generic algorithms :10.1.1.61.9949
instance find algorithm mention pointer difference type parameters unused template typename iter typename value template typename typename pointer template typename difference template value inputiterator iter value pointer difference iter find iter iter nested requirements nested requirements allow concepts express requirements concept type parameters associated types 
consider stl container concept 
associated iterator type satisfies requirements input iterator 
furthermore container value type type iterator value type 
concept container typename typename value type inputiterator iterator value type inputiterator iterator value type note input iterator type associated type iterator 
shorthand typename iterator inputiterator iterator function signatures signatures express requirements specific functions operators 
type checking serve purposes 
checking concept map definition signatures specify functions implemented concept map 
checking template definition signatures specify operations may legally body 
syntactically signature just normal function declaration definition 
signature may followed function body providing default implementation concept map define function see section details example 
definition equality comparable concept includes signatures second default implementation concept typename bool operator const const bool operator const const return operator signature satisfied free function definition global scope namespace concept map member function definition 
operators normally allowed member functions may expressed normal free functions concept requirements 
instance convertible concept describes requirement implicit conversion type concept convertible typename typename operator const requirement operation implemented member function expressed signature qualified type 
example container concept requirement empty member function type constructor requirements expressed similarly 
concept container typename bool empty const int concept may require function template signature template may constrained template 
sequence concept illustrates signature template describe stl sequence constructors allow construct instance vector pair list iterators 
concept sequence typename typename value type template inputiterator convertible value type value type investigating alternative signatures called patterns express operation requirements expressions illustrate concept parameters declarations state concept parameters provide 
design concepts independent syntax describe required operations 
overloading specialization concepts generic programming notion specialization takes different forms 
commonly form specialization concept overloading allows names function templates overloaded clauses 
form specialization referred concept overloading permits expression selection specific algorithm particular task 
revisit discussion advance function section detail 
potential implementations advance depending characteristics iterator input iterators moved forward increments bidirectional iterators moved forward backward steps random access iterators jump forward backward distance constant time 
functions expressed overloaded function templates follows template inputiterator iter void advance iter iter iter difference type iter template bidirectionaliterator iter void advance iter iter iter difference type iter iter template randomaccessiterator iter void advance iter iter iter difference type iter invocation advance function select specific implementation advance function capabilities type provided 
examples input iterator bidirectional iterator random access iterator versions advance invoked respectively void advancement istream iterator int ii void advancement list string iterator void advancement vector float iterator vi advance ii advance advance vi concept overloading particularly interesting overloaded function advance called generic function 
stl lower bound algorithm instance performs binary search value sequence denoted iterators 
implementation lower bound extracted conceptgcc follows 
template forwarditerator iter iter value type iter lower bound iter iter const iter value type value iter difference type len distance iter difference type half iter middle len half len middle advance middle half middle value middle len len half len half return implementation lower bound relies auxiliary functions advance distance advance moves iterator forward number steps find new middle distance determines length sequence 
algorithm operate forward iterators providing logarithmic number comparisons linear number iterator increment operations due linear time implementations advance distance 
algorithm provided random access iterator concept overloading selects constant time versions advance distance effect lower bound algorithm logarithmic number comparisons iterator movements list int lst binary search lst lst movements vector int binary search lg movements mechanism ensures efficient forms advance distance selected similar twophase name lookup facility templates performs type checking template definition time defers final decision instantiation time 
template lower bound initially parsed overload resolution solution resolves calls selecting seed function specific function meets minimal requirements template parsed 
call advance resolves input iterator variant advance lower bound guaranteed pass forward iterator advance 
template instantiated set concrete template arguments overload resolution call performed second time expanded set candidate functions 
set candidate functions includes seed function selected phase template definition time functions meet criteria function occurs lexical scope seed function function template parameters return type argument types identical seed function requirements function clause stricter seed function clause 
criteria represent compromise ideal modular type checking templates need select efficient function operation 
limiting set candidate functions identical signatures ensure type errors occur specific functions 
allowing functions specific seed enter candidate set declared calling function free ordering dependencies allow efficient operations selected vast majority important cases 
note restrictions placing candidate set eliminated sources instantiation time errors ambiguities overload resolution process occur topic discuss separate 
practice instantiation time errors due ambiguities rare 
ensuring efficient form advance selected algorithms written generic style sacrificing performance due genericity 
phase strategy applies selection class template partial specializations 
example define dictionary template selects alternatives lookup balanced binary tree hash table hash table sorted separate chains 
alternatives expressible constrained partial specializations primary dictionary template template key regular value class dictionary template key regular value key class dictionary key value balanced binary tree template key regular value key class dictionary key value hash table template key regular value key key class dictionary key value hash table sorted chains concept overloading specialization crucial support generic programming ideal selecting efficient operation data structure complete type information 
features follow naturally expression constrains clauses integrate seamlessly existing rules governing partial ordering templates 
concept maps strengths generic programming templates allows users instantiate templates types providing variety interfaces 
example sort algorithm accepts pointers user defined iterators vector container hold built types user defined types 
unconstrained templates permit variety interfaces allowing built range variations argument passing style operations declared member vs free functions concepts generalize notion arbitrary user defined mapping type concept established concept map 
concept map definition establishes type model concept defines mapping states type models concept 
mapping include specifying associated types value type iterator providing definitions operations required concept 
concept maps establish modeling relationships concept map called model 
consider example class student record public string id string name string address bool id equal const student record bool name equal const student record bool address equal const student record student record type useful storing information students point view algorithms find lacks way comparing records 
course add comparison ways comparing records prefer define comparison specifically equality comparable concept find concept map student record bool operator const student record const student record return id equal map defined student record type equality comparable concept 
concept map template requires student record equality comparable 
particular algorithm uses parameter declared equality comparable instantiated student record defined concept map student record 
redesign student record match algorithms requirements separately define new type provide mapping 
need define meaning code program 
concept maps allow provide interface data types specific concept interfering interfaces concepts making interface global 
concept map declared definition checked consistency concept 
signatures concept satisfied function definition concept map associated type satisfied type definition concept map nested requirements satisfied 
signatures associated types provided concept map default versions synthesized lexical scope concept map signatures defaults provided concept 
default definitions signatures associated types correct set types concept map definition may empty 
example concept map definition built integer operators satisfy requirements equality comparable concept map int concept maps 
example definition says pointer type mutable random access iterator template typename concept map typedef typedef typedef pointer typedef difference type concept map templates express nontrivial relationships 
instance stl vector class equality comparable type parameter equality comparable template concept map vector possibly important concept map templates compose generic libraries 
libraries provide components related express fundamental idea syntactic differences prevent reuse components 
concept maps adapt syntax concept syntax 
importantly mapping performed concepts represent entities different application domains 
consider graph theoretically view graph zero matrix ai ai concept maps allow express relationship directly data structure model graph linear algebra library expects matrix template graph concept map matrix typedef int value type int rows const return num vertices int columns const return num vertices double operator const int int edge find edge ith vertex ith vertex return return graph read graph vector int eigenvector expressing mapping graph theory linear algebra able immediately reuse algorithms domain linear algebra compute properties graph eigenvalues 
require lightweight mappings expressed concept maps optimized away compiler inliner 
concept maps permit cross domain fertilization composition separately developed libraries 
implicit explicit concepts writing concept maps burden user constrained templates template programmer declare argument types map appropriate concepts 
convenient compiler perform check see mapping necessary 
compiler simply check type required types operations 
unfortunately implicit structural check design take account syntactic properties type significant differences semantic 
introduces potential run time errors innocuous situations 
consider istream iterator int cin vector int initialize vector standard input implicit matching results empty vector run time error 
reason vector defines overloads range constructor slow version grows vector incrementally faster version relies multi pass capabilities forward iterator determine size range resize vector ahead time 
template class vector template inputiterator iter convertible iter value type vector iter iter slow template forwarditerator iter convertible iter value type vector iter iter fast 
istream iterator provide multi pass capabilities structurally syntactically satisfies requirements forward iterator 
constructor call resolve specialized faster version 
read input reserve space vector able fill vector second pass input range input consumed pass 
author concept choose explicit implicit concepts 
concepts important semantic aspects overloading explicit concepts implicit 
implicit concept identified placing auto keyword front concept 
example equality comparable concept specified allow implicit matching auto concept typename bool operator const const bool operator const const return refinements concept maps concept map defined concept refinement clause concept maps refinements concept implicitly defined 
example concept map section pointers model mutable random access iterator pointers model random access iterator bidirectional iterator forward iterator mutable random access iterator refines iterator concepts directly indirectly 
implicit generation concept maps refinements minimizes number concept maps users specify refinement hierarchy 
suffices provide concept map refined concept concept arguments model done pointers iterator hierarchy 
benefits reducing amount effort users expend writing concept maps implicit generation concept maps allows refinement hierarchies evolve breaking existing code 
refinement hierarchies evolve tend move coarse grained approximations finer grained approximations new models behavior fits existing concepts discovered 
example forward iterator introduces new kinds requirements top input iterator concept refines need associated type true multi pass property allows repeated iteration sequence values 
inception stl iterator concepts iterator types provide property counting iterator enumerates values prevalent leading multi pass input iterator concept sits input iterator forward iterator refinement hierarchy 
implicit generation concept maps refinement new iterator concept break code existing hierarchy forward iterator concept map augmented new concept map multi pass input iterator 
implicit generation concept maps refinements concept hierarchy evolve fine grained structure time breaking backward compatibility 

conceptgcc evaluate proposed extensions implemented concepts gnu compiler reimplemented stl concepts section 
concept enhanced version gcc freely available conceptgcc web site provide overview conceptgcc discuss implementation techniques employed 
refer interested reader additional details concept compilation 
aim conceptgcc partially provide tool experiment concepts partially demonstrate concepts integrated real compilers 
concepts accepted part plausible integration possible economical major compilers ensure great deal practical experience concepts prior standardization 
compilation model potential compilation models applied templates 
existing compilers implement called inclusion model templates definition template available template 
particular instance template needed compiler instantiates template substituting concrete types needed instance corresponding template parameters 
result code specific optimized particular template 
coupled compiler optimizations inlining copy propagation template instantiation enables generic libraries produce code efficient hand tuned fortran 
conceptgcc retains template inclusion model compilation 
decision motivated need backwards compatibility need fit existing compilers need provide performance currently delivered unconstrained templates 
benefits improved type checking templates weakened represented trade performance 
adoption template inclusion model compilation precludes separate compilation templates 
constrained generics concepts differ java generics 
java default instances generic method share native code 
flavor instantiation model different code generated different instantiation generic method type arguments value types 
attain apparent separate compilation code generated run time 
language shares syntactic constructs design differs provides separate compilation implements weaker form overloading propose concepts 
overloading resolved exclusively lexical information available prior template instantiation postpone part overload resolution instantiation information available 
powerful facility dispatching prevents separate compilation template definitions prevents completely separate type checking overload ambiguities may occur instantiation 
report issues 
inclusion model templates best match time plan explore interaction specialization separate compilation 
concepts concept maps concept map lookup process shares normal template instantiation process compiling concepts concept maps class templates provides reasonable implementation approach 
concepts compiled class templates concept maps compiled full specializations class templates 
concept map templates compiled partial specializations class templates 
conceptgcc exploits similarity completely representing refinement virtual inheritance function signatures static member functions associated types nested typedefs 
concept maps provide static member functions typedefs concept class 
representation con able directly reuse existing front functionality including qualified name lookup find associated types signatures concepts concept maps name lookup base classes find associated types signatures refinements template instantiation synthesizing concept maps concept map templates implicitly matching concepts partial ordering templates concept map selection concept overloading 
concepts semantically distinct class templates structural similarities greatly reduce implementation cost introducing concepts existing compiler 
shows compilation simple concept concept map definition 
compilation constrained templates definition constrained template compiled expressions refer function signatures clause translated expressions explicit qualified calls class specializations appropriate concept map 
example expression sum example section translated addable value type operator inputiterator iter operator completely transformed version sum algorithm looks template typename iter sum iter iter iter value type typedef inputiterator iter value type value type inputiterator iter operator inputiterator iter operator assignable value type operator ass value type operator operator value type iter operator return value type value type note translation reminiscent dictionary schemes separate compilation generics effect instantiation process acting dictionary lookup resolving addable value type involves finding best matching concept map selecting dictionary extracting operator acts lookup dictionary 
main difference translation dictionary passing lookup performed compile time run time data structure passed generic function 
type checking templates visible benefits concepts come modular type checking templates 
surprisingly implementation challenges 
common misconception template definitions completely unchecked initially parsed 
fact type checking templates stage process 
stage parsing template definition compiler type check non dependent expressions depend template parameters 
dependent expressions depend template parameter stored syntax tree type information 
second stage template instantiation concrete types substituted template parameters concept addable typename operator const const concept map addable big int big int operator const big int const big int return plus syntax tree 
process dependent expressions non dependent type checking entirety template concrete types 
conceptgcc implements modular type checking making dependent expressions non dependent expressions stage entire template definition type checked initially parsed 
conceptgcc generates archetype template parameter archetype type checking lieu corresponding template parameter 
archetypes placeholder types define operations stated concept requirements involving template parameters 
instance archetype template parameter swap function section operations defined copy constructor provided assignment operation provided assignable 
due archetypes making expressions implementation modular type checking conceptgcc required far fewer changes compiler language semantics anticipated 
placing constrained unconstrained template compilation framework non dependent expressions able compile partially constrained templates parameters explicitly marked unconstrained templates useful concepts existing libraries may play role template libraries need break modular type checking localized way perform useful type unsafe operation 
type constraints type constraints requirements contained clause nested requirement concept types equivalent 
type checking definition template type constraints clause affect types considered equal 
consider includes function template template inputiterator inputiterator value type value type value type bool includes bool includes 
body includes type value type considered type value type 
equivalence important consider 
operator defined type symmetric operation iterator value type 
compiler equivalence value types type check function template 
type equality equivalence relation reflexive transitive symmetric 
type constraint may imply type equalities 
template example template typename class addable 
compilation concepts concept maps 
template class addable big int static big int operator const big int const big int return plus transitivity required type checking compiler deduce type template typename typename bool foo return type equality congruence relation 
example vector vector holds 
conversely vector vector implies 
compiler ensure constraints appearing clause conflict 
example clause contains implies constraint int char compiler produce error 
problem determining types equal set type constraints instance congruence closure problem 
congruence closure problem shows modern compilers example common sub expression elimination 
efficient algorithms congruence closure problem algorithm nelson oppen log time complexity average number type nodes 
time complexity worst case 
improved slightly complicated downey sethi tarjan algorithm log worst case 
propagation type constraints affects types 
instance cause concept maps introduced clause duplicated 
particularly common nested requirements 
instance example type constraint iterator difference types equivalent means concept maps single concept map 
conceptgcc remove duplicates list requirements type constraints processed 
concept inputiterator typename iter difference type template inputiterator iter inputiterator iter iter difference type iter difference type void iter iter iter type constraints change notion type equivalence 
efficient implementation type constraints congruence closure provided compiler 
conceptgcc forced implement simple disjoint sets data structure augmented deep type comparisons gcc internal representation types amenable congruence closure algorithms 
class templates specializations generic functions data structures implemented generic data structures 
instance stl mismatch algorithm returns pair iterators template inputiterator iter inputiterator iter iter iter pair iter iter mismatch iter iter iter return pair iter iter type checking body algorithm compiler verify type pair iter iter constructor accepting parameters type iter iter respectively 
compile need look inside definition class template pair definition follows template typename typename class pair public pair const const 
conceptgcc implements type checking uses class templates constrained templates archetypes 
definition mismatch type checked compiler generates archetypes iter iter template type parameters iter iter respectively 
compiler generates type equivalence template type parameters archetypes 
point compiler requires complete type pair iter iter search suitable constructor return statement conceptgcc instantiates template class pair iter iter 
doing creates constructor pair const iter const iter invoked return statement 
instantiating class templates archetypes conceptgcc able type check function templates mismatch class templates 
pitfalls instantiating class templates inside generic function 
definitions class templates required type checking instantiations introduces potential instantiation time failures break modular type checking 
particular possible instantiation algorithm select specialization class template provide precisely members primary template 
pair absurd 
templates simple pair 
example containers provide optimized implementations particular argument types 
particular vector optimizes storage bool single bit value vector bool specialization 
optimization changes interface subtle ways lead instantiation time failures 
consider generic function template regular void vector vec vec front 
definition function template correct typecheck properly conceptgcc 
instantiate properly vectors integers strings lists employees nearly data type 
invoked vector bool instantiation fail compile front method vector bool returns proxy class type vector bool true 
design flaw stl caused inability express perfect proxy 
vector bool specialization manage subvert modular type checking 
defined type checked vector checked primary class template vector front returns vector bool specialization may available compiler time type checking occurred 
instantiation bool compiler selects specialized form vector vector bool 
vector bool provide compatible front method instantiation fails 
myriad workarounds applied fix problem 
provide specialized vector bool 
design sequence concept encapsulates behavior required call vector bool argument fail sequence 
eliminate potential problems placing language restrictions specializations siek lumsdaine proved system language concepts specialization provide modular type checking 
obtain modular type checking restrict specializations breaking principle selecting specific implementation restrict implementations specializations making impossible template meta programming conjunction constrained generics 
solution feasible 

evaluation evaluated ability concept mechanisms express ideas generic programming enhancing gnu implementation standard template library concepts 
developed new idealized stl library kept core ideas stl adapted concepts 
decided model existing stl modulo errors produce implementation conforms closely iso standard 
doing emphasizes evaluation backward compatibility existing code stl compile produce identical results 
unfortunately modeling existing stl inventing new generic library comes price design decisions stl different concepts available time inception compelled model existing design improve 
process upgrading standard template library involves migrating semi formal concept descriptions standard expressed requirements tables concept definitions 
constrain templates algorithms data structures adaptors stl 
defining stl concepts definition stl concepts involves translation requirements tables express current standard concepts 
compares requirements table copy constructible concept left hand side extracted iso standard equivalent right hand side 
requirements table specifies syntax concept valid expressions illustrate allowed uses types concept type column provides information return type valid expression 
introducing concepts shown right hand side preserved semantics closely possible 
reorganization requirements necessary concept translation valid expressions signatures straightforward 
requirements tables simple concepts assignable default constructible comparable equality comparable translate equally implicit concepts 
interesting set requirements tables stl describe iterator concepts 
left hand side illustrates requirements table describes forward iterators 
translation concepts shown right hand side table copy constructible requirements expression return type const type model copy constructible value type value type const auto concept typename const operator const operator const 
requirements table copy constructible compared representation concept 
preserved semantics closely possible reorganization requirements necessary factored common requirements refinements 
valid expressions requirements table described tables default constructible copy constructible assignable equality comparable input iterator 
refinement exist requirements tables implicit requirements table superset requirements table concept associated refines 
refinement explicit 
distinct concepts described requirements table separate forward iterator mutable forward iterator concepts 
natural refinement relationship mutable iterator read written non mutable iterator read 
collapsed iterator traits facility provides access associated types iterator iterator concepts 
doing provide specific meanings pointer associated types required stl iterators unspecified behavior 
translated valid expression corresponding signature 
cases pre increment expression translation direct obvious 
cases introduce special associated type describes return type signature 
valid expressions requirements table specify exact return type operators exact value associated type specified 
place concept requirements associated type state convertible type described requirements table 
instance operator returns value type meet requirements convertible value type return type operator value convertible value type described requirements table 
requirements table modeled precisely differences due errors semiformal specification 
example requirements table forward iterators states return type operator called formulation exactly equal const value type non mutable forward iterators exactly equal value type mutable forward iterators 
requirements mutually exclusive value type identical constant 
assumed stl mutable iterator non mutable iterator mutable iterators refine counterparts adding ability modify values 
remedy situation non mutable iterator concepts provide weaker constraint associated type convertible const value type mutable iterator concepts state associated type exactly equal value type 
weakening non mutable constraint able express necessary refinement relationship mutable non mutable iterators 
translation iterator requirements concepts proved challenging part formalizing stl 
source problems loose specification strategy requirements tables permits proxy objects returned iterator operations tangling non mutable mutable forms concepts presence numerous small errors iterator specifications 
despite challenges resulting concepts express spirit existing stl closely iterators data structures algorithms written existing specification stl changes 
section discusses mapping existing iterators concept enhanced stl iterators detail 
stl algorithm requirements introduce concepts algorithms data structures stl state requirements stl algorithm data structure 
process involves introducing clause covers minimal requirements needed implement algorithm 
focus algorithms process applies generic data structures 
left hand side illustrates informal specification style describe requirements stl algorithms 
convention parameters named concepts model function signatures specification state find find require models input iterator concept function requires model predicate concept 
additionally stated requires clause type parameter find model equality comparable 
na translation requirements concepts shown right hand side incorrect 
attempting compile constrained function template conceptgcc produces error message illustrated 
problem case values comparable required code attempts compare result dereferencing value type tot 
type value type need immediate ways resolve error find require value type iterator equivalent type constraint equality comparable 
options viable unclear dictated specification lefthand side 
decided err side allows uses find algorithm forward iterator requirements operation type xu xu xu convertible bool convertible bool mutable const mutable const convertible const mutable const type model forward iterator values type type value type iterator type name member type non constant object 
concept inputiterator typename iter iter iter assignable iter typename value type iter value type typename iter typename pointer iter pointer difference type iter difference type pointer value type convertible value type operator iter pointer operator iter iter operator iter typename result result operator iter int result value type concept forwarditerator typename iter inputiterator iter iter convertible const value type convertible pointer const value type concept iter forwarditerator iter outputiterator iter value type pointer value type 
forward iterator mutable variant expressed documentation conventions defined concepts 
concept description show definition input iterator encapsulates forward iterator requirements 
template class inputiterator class inputiterator find inputiterator inputiterator inputiterator find const value template class inputiterator class predicate inputiterator find inputiterator inputiterator inputiterator find predicate pred 
requires type equality comparable 

returns iterator range corresponding conditions hold value pred false 
returns iterator 

complexity applications corresponding predicate 
literal translation type check template inputiterator iter iter find iter iter const value value return literal translation complete correct template inputiterator iter predicate iter pred iter find iter iter pred pred pred return 
specification stl find find algorithms described iso standard left literal translation 
including uses existing stl 
definition find contained reads template inputiterator iter typename iter value type iter find iter iter const value value return exercise stating stl algorithm requirements concepts uncovered bugs ambiguities due informal specification style standard 
cases intended requirements clear standard implementation incorrect 
errors due assumptions relationships types specified requirements 
instance gnu library contained implementation replace copy direct translation requirements clause template inputiterator outputiterator value type assignable value type replace copy replace copy const old val const new val result result old val new val return result find cpp function iter std find iter iter const find cpp error match operator value concepts note candidates bool std inputiterator iter operator const iter const iter concepts note bool std operator const const concepts note bool std difference type operator const difference type const difference type 
conceptgcc error message produced attempting compile na translated version find shown right hand side 
clause requires assign values input sequence values type output sequence associated type value type input iterator may different type type checking routine conceptgcc produces error message replace copy cpp error operands different types problem originally noted siek lumsdaine requirements replace copy say value type input iterator equivalent 
vast majority uses replace copy iterator value type equivalent easy see bug gone undetected 
fix easy replace conditional assignment statement 
errors implementation assumed type equivalence guaranteed standard 
particularly vexing example occurred sort heap function definition augmented clause template iter value type void pop heap template iter iter value type void sort heap iter iter pop heap algorithm subtly incorrect 
attempting compile conceptgcc produces error message sort heap cpp error matching function call pop heap iter result problem case operator specified return value associated type result convertible distinct type iter 
call pop heap difference causes failure template argument deduction bound iter parameter pop heap bound result second parameter 
fixing problem detected trivial insert cast iter 
major source errors defining requirements concepts stl due infamous vector bool iterator section 
problems vector bool iterator arise standard incorrectly states vector bool iterator random access iterator 
error occur concepts attempt write concept map definition result compiletime failure type vector bool iterator meet requirements forward iterator concept 
backward compatibility backward compatibility stl programs written existing stl paramount importance reasons 
providing benefits better error messages improved library implementations syntax remapping requiring users port code backward compatibility improves chances adoption concepts real world 
second able apply concepts existing stl significant changes similarly applied generic libraries 
report stl provides excellent backward compatibility 
entirety test suite compiles produces identical results stl existing stl required changes 
stl defined name tests integral requiring test different identifier 

stl pretend vector bool iterators model random access iterator 
test case relied modified 

type output iterator example required addition single concept map stl algorithms 
ran test suites libraries boost library collection including graph iterator adaptor libraries heavy stl constructs 
case type output iterator required concept map stl 
assuming express requirements existing generic library concepts major impediment backward compatibility possibility users need add concept maps 
combination implicit concepts trivial concepts copy constructible comparable concept map templates minimize nearly zero number concept maps users required write 
stl widely concepts require explicit concept maps iterator concepts 
nearly iterator concepts output iterator exception write concept map templates adapt iterators written existing stl new iterator concepts 
process completely transparent user porting boost test suites stl required concept maps various user defined iterator types 
key adapting old style iterators take advantage concepts observation existing stl iterators provide explicit declarations concepts model form traits need query traits 
illustrates old style forward iterators seamlessly mapped iterators stl 
iterator traits concept structural concept extracts types existing fact pretend vector bool iterators random access iterators compiler reject definition concept map 
auto concept typename iter typename iterator category iter iterator category typename value type iter value type typename difference type iter difference type typename pointer iter pointer typename iter template typename iter iter convertible iterator category input iterator tag convertible iterator category forward iterator tag concept map forwarditerator iter typedef iter value type value type typedef iter difference type difference type typedef iter pointer pointer typedef iter 
concept map templates seamlessly map old style stl iterators stl iterators enable backward compatibility 
stl iterator traits trait class 
important iterator category type states concept input iterator forward iterator type models 
implicit generation concept map iter implies iter iterator form 
declare concept map templates take type iter implicit generated concept map iter query iterator category determine concepts models 
generate concept map forward iterator long concept map iterator traits iterator category convertible forward iterator tag 
mapping valid clause forward iterator concept map template matches precisely requirements needed identify type forward iterator existing stl 
exception output iterator types meet iterator requirements existing stl automatically meet requirements stl porting required 
believe upcoming extensions possible provide automatic mapping output iterator concept maps providing nearly perfect backward compatibility existing iterators 
complete backward compatibility requires pre concept generic algorithms written old iterator interfaces iterator traits continue function new iterators expose concepts interface 
instance algorithm counts elements sequence meet specific criteria template typename inputiterator typename predicate typename std iterator traits inputiterator difference type count inputiterator inputiterator predicate pred typename std iterator traits inputiterator difference type pred return require new iterators expose interface provide concept maps pre concept interface specialize iterator traits 
places burden backward compatibility authors iterators 
aside problems maintaining similar incompatible interfaces approach allow concepts interface completely replace existing interface 
template inputiterator iter struct iterator traits iter typedef input iterator tag iterator category typedef iter value type value type typedef iter typedef iter pointer pointer typedef iter difference type difference type 
class template partial specializations seamlessly map new style iterators old style iterator interface 
concepts allow define set class template partial specializations iterator traits provide new concept iterators old style interface 
illustrates partial specializations provides suitable iterator traits definition model input iterator concept 
mapping existing iterators concept system mapping seamless invisible existing generic algorithms able access associated types new style iterators iterator traits 
series concept maps illustrated class template partial specializations illustrated able ensure existing pre concept iterators seamlessly interoperate concept constrained algorithms pre concept algorithms interoperate new concept iterators 
techniques simplify development dual mode generic libraries provide functionality concepts 
conceptgcc implementation standard library library allowing users turn concepts library level provide pre concept compliant library 
ability develop dual mode generic libraries crucial vendors coordinate release compilers libraries supporting concepts users rely mix compilers libraries support concepts 
burden maintaining library concepts significant barrier adoption 
summary evaluated design concepts translating ideas implementation standard template library 
defining requirements stl concepts uncovered errors ambiguities specification implementation stl 
able produce concept enhanced stl demonstrably better original user point view better error messages clearer abstractions implementer point view improved type checking reliance arcane template techniques 
concept enhanced stl provided backward compatibility programs written existing stl 

related concepts extend constraints type parameters modular type checking overloading constraints 
various mechanisms constraining polymorphic types overloading part widely languages 
design influenced prior area 
concepts respect mechanisms languages 
object oriented languages including eiffel java support constrained generics subtyping constraints 
languages interfaces classes describe set requirements method signatures types declared subtypes classes satisfy 
constraints generic methods classes mutually recursive systems subtyping requirements type parameters essentially generalization bounded polymorphism 
significant differences kind constrained polymorphism concepts including treatment associated types subtyping basis constraints constraints overloading compilation model generic definitions 
discuss compilation model section address differences 
associated types requirements essential part concepts 
representing associated types java direct interfaces provide type members serve purpose 
possible express mappings types associated types essentially constraints associated types type members 
accomplished distinct type parameter set constraints associated type 
approach encapsulate associated types constraints interfaces report associated types constraints repeated sites generic interfaces type parameter constraints 
concepts directly support associated type requirements concepts 
note developed language features allow associated types generic interfaces java languages 
type members objects classes extensively studied early virtual types 
review 
interesting language regarding generic programming scala 
particular scala type system provides type members serve associated types concepts 
latest version scala includes feature referred implicit parameters pass models generic programming sense generic functions explicitly implicitly 
plan comprehensive analysis scala respect generic programming 
type set types values operations model concept defined definition type 
retroactive modeling important composing separately developed libraries discussed 
constrained generics subtyping ability retroactive modeling tied ability retroactive subtyping typically provided mainstream object oriented languages subtype relation nominal established subclassing 
known object oriented languages cecil supports retroactive subtyping feature suggested java 
mechanisms specifying structural subtyping relations proposed java 
concepts build subtype relation 
respect concepts similar constraint mechanisms signatures ml type classes haskell 
comparing concepts ml signatures note ml signatures encompass equivalents associated types particular observe correspondence type constraints ml sharing constraints see manifest types translucent sums 
major difference concepts ml signatures granularity parametrization 
ml signatures constrain functors parametrized modules parametrized functions 
generic functions seldom share parametrization requirements function wrapped module 
furthermore functors explicitly instantiated type arguments making quite heavy weight provide implicit instantiation type arguments deduced types actual arguments 
ml checking requirements signature satisfied purely structural conformance 
concept exten sions support structural nominal modeling relations corresponding implicit explicit concepts respectively 
implicit concepts strictly speaking necessary feature reduce number trivial concept maps significantly 
explicit concepts crucial concepts differ semantically illustrated section 
particular concept refinement forward iterator refining input iterator adds semantic requirements having syntactic difference concepts 
structural properties types suffice uniquely determine concepts types model 
details ml generic programming 
similar concepts haskell type classes define set required functions instances models type class provide 
subtyping enter picture 
furthermore type classes constrain individual functions modules 
standard form type classes support associated types research addresses issue 
notable difference haskell support type inference particular inferring constraints generic function body 
ensure constraints generic function uniquely determined significant restriction placed type classes function name occur type classes visible program 
requires foresight problematic importing type class definitions separately defined libraries 
concepts participate overload resolution 
contrary java constraints ignored selecting best matching overload overloads function differ constraints considered ambiguous 
overloading differs ml haskell behavior polymorphic functions languages overloaded 
haskell overloading occurs providing different instance declarations type class functions defined type class 
overloaded function considered specialization concept constraints imply constraints described section 
provide direct support algorithm specialization essential part generic programming approach software library development 
analyze concept overloading specialization detail 

propose new language features concepts provide nearly modular type checking templates directly support generic programming 
addition concepts libraries brings immediate benefit library users drastically shortening simplifying template error messages 
longer term concepts easier design implement template libraries replacing grab bag template tricks single coherent language feature 
conceptgcc built gnu compiler implements concepts associated features described 
conceptgcc reimplemented standard template library concepts 
process formalizing requirements stl concepts uncovered deficiencies semi formal specification detected new bugs gnu implementation 
resulting stl concepts provides functionality existing stl nearly perfect backward compatibility greatly improves user experience 
conceptgcc available online www 
generic programming org software conceptgcc 

current design implementation concepts draw larger going effort led authors 
aim inclusion concepts form similar iso standard 
happen complete conceptgcc implementing remaining features 
furthermore document design extent re implemented commercial compilers practicing programmers 
final word design concepts determined committee iso national representatives 
criteria include completeness simplicity stability design performance smooth integration rest language standard library 
evaluate expressiveness usability port additional generic libraries concepts tune performance conceptgcc 
concepts introduce run time overhead compared unconstrained templates 
evaluate trade offs patterns signatures 
general continue try simplify concept mechanisms easier programmers concepts effectively 
increase scope analysis optimization explore notion attaching semantic properties concepts permit semantic descriptions abstractions aid compilers concept optimization 
acknowledgments effort introduce language support generic programming form concepts shaped including david matthew ronald garcia mat marcus david musser sean parent schupp alexander stepanov 
supported nsf eia ccf ccf endowment 
david aleksey 
template metaprogramming concepts tools techniques boost 
addison wesley 
rus saunders smith thomas amato rauchwerger 
standard template adaptive parallel library 
int 
wkshp adv 
compiler technology high perf 
embedded processors page july 
matthew 
generic programming stl extending standard template library 
professional computing series 
addison wesley longman publishing boston ma usa 
baumgartner ufer 
half half multiple dispatch retroactive abstraction java 
technical report osu tr ohio state university 
gerald baumgartner vincent russo 
signatures language extension improving type abstraction subtype polymorphism 
software practice experience august 
boost 
boost libraries 
www boost org 
alex breuer peter douglas gregor andrew lumsdaine 
effecting parallel graph library composition 
performance optimization high level languages libraries april 
peter canning william cook walter hill walter john mitchell 
bounded polymorphism object oriented programming 
fpca proceedings fourth international conference functional programming languages computer architecture pages 
acm press 
manuel chakravarty keller simon peyton jones 
associated type synonyms 
icfp proceedings international conference functional programming pages 
acm press september 
manuel chakravarty keller simon peyton jones simon marlow :10.1.1.10.5121
associated types class 
popl proceedings nd acm sigplan sigact symposium principles programming languages pages 
acm press 
czarnecki eisenecker 
generative programming methods techniques applications 
addison wesley 
gabriel dos reis bjarne stroustrup 
specifying concepts 
popl conference record rd acm sigplan sigact symposium principles programming languages pages 
acm press 
peter downey ravi sethi robert endre tarjan 
variations common subexpression problem 
journal acm jacm 
fabri 
giezeman kettner schirra sch 
design cgal computational geometry algorithms library 
software practice experience 
special issue discrete algorithm engineering 
ronald garcia jaakko rvi andrew lumsdaine jeremy siek 
comparative study language support generic programming 
oopsla proceedings th annual acm sigplan conference object oriented programing systems languages applications pages 
acm press 
ronald garcia jaakko rvi andrew lumsdaine jeremy siek 
extended comparative study language support generic programming 
journal functional programming 
accepted 
gnu compiler collection 
www gnu org software gcc 
james gosling bill joy guy steele gilad bracha 
java language specification third edition 
addison wesley longman publishing boston ma usa 
douglas gregor 
conceptgcc concept extensions 
www generic programming org software conceptgcc 
douglas gregor andrew lumsdaine 
lifting sequential graph algorithms distributed memory parallel computation 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla pages october 
douglas gregor jeremy siek 
implementing concepts 
technical report iso iec jtc information technology subcommittee sc programming language august 
douglas gregor jeremy siek jaakko rvi ronald garcia andrew lumsdaine 
concepts revision 
technical report iso iec jtc information technology subcommittee sc programming language august 
douglas gregor bjarne stroustrup 
concepts 
technical report iso iec jtc information technology subcommittee sc programming language june 
henning 
rise fall corba 
acm queue june 
international organization standardization 
iso iec programming languages 
geneva switzerland september 
rvi stroustrup dos reis 
auto revision 
technical report iso iec jtc information technology subcommittee sc programming language september 
www open std org jtc sc wg docs papers pdf 
jaakko rvi douglas gregor andrew lumsdaine jeremy siek 
algorithm specialization generic programming challenges constrained generics 
pldi proceedings acm sigplan conference programming language design implementation pages 
acm press 
jaakko rvi howard andrew lumsdaine 
function overloading arbitrary properties types 
users journal june 
jaakko rvi andrew lumsdaine 
associated types constraint propagation mainstream object oriented generics 
oopsla proceedings th annual acm sigplan conference object oriented programming systems languages applications pages 
acm press 
mehdi jazayeri david musser alexander stepanov 
generic programming 
report dagstuhl seminar generic programming schloss dagstuhl germany april 
kapur musser 
framework specifying verifying generic system components 
technical report rpi department computer science rensselaer polytechnic institute troy new york july 
steve james julian cummings scott william humphrey john stephen smith timothy williams 
array design expression evaluation ii 
denis rodney editors 
advanced computing laboratory lanl 
ufer baumgartner russo 
safe structural conformance java 
computer journal 
lie quan lee jeremy siek andrew lumsdaine 
generic graph algorithms sparse matrix ordering 
lecture notes computer science 
springer verlag 
xavier leroy 
manifest types modules separate compilation 
proceedings st annual acm symposium principles programming languages pages 
mark lillibridge 
translucent sums foundation higher order module systems 
phd thesis pittsburgh pa may 
litvinov 
polymorphism cecil practical static type system 
oopsla proceedings th acm sigplan conference object oriented programming systems languages applications pages 
acm press 
madsen moller pedersen 
virtual classes powerful mechanism object oriented programming 
oopsla conference proceedings object oriented programming systems languages applications pages 
acm press 
bertrand meyer 
eiffel language 
prentice hall edition 
microsoft 
generics september 
part gyro distribution generics net available research microsoft com projects 
robin milner mads tofte robert harper 
definition standard ml 
mit press 
david musser atul 
stl tutorial guide 
addison wesley nd edition 
david musser alexander stepanov 
library generic algorithms ada 
ada international ada conference pages 
acm december 
david musser alexander stepanov 
generic programming 

editor symbolic algebraic computation issac rome italy july proceedings volume lecture notes computer science pages berlin 
springer verlag 
david musser alexander stepanov 
algorithm oriented generic libraries 
software practice experience july 
nathan myers 
new useful technique traits 
report june 
nathan myers 
traits new useful template technique 
report june 
greg nelson derek oppen 
fast decision procedures congruence closure 
acm 
martin odersky 
scala language specification version draft march 
scala epfl ch docu files pdf 
martin odersky overview scala programming language 
technical report ic epfl lausanne switzerland 
martin odersky matthias zenger 
scalable component abstractions 
sigplan 
schupp douglas gregor david musser shin ming liu 
user extensible simplification type optimizer generators 
cc proceedings th international conference compiler construction pages london uk 
springer verlag 
jeremy siek douglas gregor ronald garcia jaakko rvi andrew lumsdaine 
concepts 
technical report iso iec jtc information technology subcommittee sc programming language january 
jeremy siek lie quan lee andrew lumsdaine 
boost graph library user guide manual 
addison wesley longman publishing boston ma usa 
jeremy siek andrew lumsdaine 
matrix template library generic components high performance scientific computing 
computing science engineering nov dec 
jeremy siek andrew lumsdaine 
concept checking binding parametric polymorphism 
workshop template programming october 
jeremy siek andrew lumsdaine 
essential language support generic programming 
pldi proceedings acm sigplan conference programming language design implementation pages 
acm press june 
jeremy siek andrew lumsdaine 
language requirements large scale generic libraries 
proceedings fourth international conference generative programming component engineering september 
appear 
jeremy siek 
language generic programming 
phd thesis indiana university august 
alexander stepanov meng lee 
standard template library 
technical report wg iso programming language project may 
bjarne stroustrup 
design evolution 
addison wesley longman publishing boston ma usa 
bjarne stroustrup 
programming language 
addison wesley special edition 
bjarne stroustrup gabriel dos reis 
concepts design choices template argument checking 
technical report iso iec jtc information technology subcommittee sc programming language october 
www open std org jtc sc wg 
bjarne stroustrup gabriel dos reis 
concept design rev 
technical report iso iec jtc information technology subcommittee sc programming language may 
mathias prakash dayal 
iterative template library 
www comp phys org software 
todd veldhuizen 
template metaprograms 
report may 
todd veldhuizen 
expression templates 
report june 
reprinted gems ed 
stanley lippman 
todd veldhuizen 
arrays 
proceedings nd international scientific computing object oriented parallel environments volume lecture notes computer science 
springer verlag 
todd veldhuizen 
compilation models templates 
workshop template programming october 
wadler blott 
ad hoc polymorphism adhoc 
acm symposium principles programming languages pages 
acm january 
