appears proceedings third symposium operating systems design implementation new orleans usa february describes new replication algorithm able tolerate byzantine faults 
believe tolerant algorithms increasingly important malicious attacks software errors increasingly common cause faulty nodes exhibit arbitrary behavior 
previous algorithms assumed synchronous system slow practice algorithm described practical works asynchronous environments internet incorporates important optimizations improve response time previous algorithms order magnitude 
implemented byzantine fault tolerant nfs service algorithm measured performance 
results show service slower standard unreplicated nfs 
malicious attacks software errors increasingly common 
growing reliance industry government online information services malicious attacks attractive consequences successful attacks serious 
addition number software errors increasing due growth size complexity software 
malicious attacks software errors cause faulty nodes exhibit byzantine arbitrary behavior byzantine fault tolerant algorithms increasingly important 
presents new practical algorithm state machine replication tolerates byzantine faults :10.1.1.20.4762
algorithm offers liveness safety provided practical byzantine fault tolerance miguel castro barbara liskov laboratory computer science massachusetts institute technology technology square cambridge ma castro liskov lcs mit edu total replicas simultaneously faulty 
means clients eventually receive replies requests replies correct linearizability :10.1.1.16.9935
algorithm works asynchronous systems internet incorporates important optimizations enable perform efficiently 
significant body agreement research supported part darpa contract dabt monitored army fort contract monitored air force research laboratory part nec 
miguel castro partially supported praxis xxi fellowship 
replication techniques tolerate byzantine faults starting 
earlier concerns techniques designed demonstrate theoretical feasibility inefficient practice assumes synchrony relies known bounds message delays process speeds 
systems closest rampart securering designed practical rely synchrony assumption correctness dangerous presence malicious attacks :10.1.1.112.6123
attacker may compromise safety service delaying non faulty nodes communication tagged faulty excluded replica group 
denial service attack generally easier gaining control non faulty node 
algorithm vulnerable type attack rely synchrony safety 
addition improves performance rampart securering order magnitude explained section 
uses message round trip execute read operations execute read write operations 
uses efficient authentication scheme message authentication codes normal operation public key cryptography cited major latency throughput bottleneck rampart faults 
evaluate approach implemented replication library implement real service byzantine fault tolerant distributed file system supports nfs protocol 
andrew benchmark evaluate performance system 
results show system slower standard nfs daemon digital unix kernel normal case operation 
contributions describes state machine replication protocol correctly survives byzantine faults asynchronous networks 
describes number important optimizations allow algorithm perform real systems 
describes implementation byzantine fault tolerant distributed file system 
provides experimental results quantify cost replication technique 
remainder organized follows 
describing system model including failure assumptions 
section describes problem solved algorithm states correctness conditions 
algorithm described section important optimizations described section 
section describes replication library implement byzantine fault tolerant nfs 
section presents results experiments 
section discusses related 
conclude summary accomplished discussion research directions 
system model assume asynchronous distributed system nodes connected network 
network may fail deliver messages delay duplicate deliver order 
byzantine failure model faulty nodes may behave arbitrarily subject restriction mentioned 
assume independent node failures 
assumption true presence malicious attacks steps need taken node run different implementations service code operating system different root password different administrator 
possible obtain different implementations code base low degrees replication buy operating systems different vendors 
version programming different teams programmers produce different implementations option services 
cryptographic techniques prevent spoofing replays detect corrupted messages 
messages contain public key signatures message authentication codes message digests produced collision resistant hash functions :10.1.1.51.6690:10.1.1.40.5588
denote message signed node digest message follow common practice signing digest message appending plaintext message signing full message interpreted way 
replicas know public keys verify signatures 
allow strong adversary coordinate faulty nodes delay communication delay correct nodes order cause damage replicated service 
assume adversary delay correct nodes indefinitely 
assume adversary faulty nodes controls computationally bound high probability unable subvert cryptographic techniques mentioned 
example adversary produce valid signature non faulty node compute information summarized digest digest find messages digest 
cryptographic techniques thought properties 
service properties algorithm implement deterministic replicated service state operations 
operations restricted simple reads writes portions service state perform arbitrary deterministic computations state operation arguments 
clients issue requests replicated service invoke operations block waiting reply 
replicated service implemented replicas 
clients replicas non faulty follow algorithm section attacker forge signature 
algorithm provides safety liveness ing replicas faulty 
safety means replicated service satisfies linearizability modified account byzantine faulty clients behaves centralized implementation executes operations atomically time :10.1.1.16.9935
safety requires bound number faulty replicas faulty replica behave arbitrarily destroy state 
safety provided regardless faulty clients service collude faulty replicas operations performed faulty clients observed consistent way non faulty clients 
particular service operations designed preserve invariants service state faulty clients break invariants 
safety property insufficient guard faulty clients file system faulty client write garbage data shared file 
limit amount damage faulty client providing access control authenticate clients deny access client issuing request right invoke operation 
services may provide operations change access permissions client 
algorithm ensures effects access revocation operations observed consistently clients provides powerful mechanism recover attacks faulty clients 
algorithm rely synchrony provide safety 
rely synchrony provide liveness implement consensus asynchronous system possible 
guarantee liveness clients eventually receive replies requests provided replicas faulty delay grow faster delay indefinitely 
time moment message sent time moment received destination assuming sender keeps retransmitting message received 
precise definition :10.1.1.16.9935
weak synchrony assumption true real system provided network faults eventually repaired enables circumvent impossibility result 
resiliency algorithm optimal minimum number replicas allow asynchronous system provide safety liveness properties replicas faulty see proof 
replicas needed possible proceed communicating replicas replicas faulty responding 
possible replicas respond faulty responded faulty 
responses non faulty replicas outnumber faulty ones algorithm address problem faulttolerant privacy faulty replica may leak information attacker 
feasible offer fault tolerant privacy general case service operations may perform arbitrary computations arguments service state replicas need information clear execute operations efficiently 
possible secret sharing schemes obtain privacy presence threshold malicious replicas arguments portions state opaque service operations 
plan investigate techniques 
algorithm algorithm form state machine replication service modeled state machine replicated different nodes distributed system :10.1.1.20.4762
state machine replica maintains service state implements service operations 
denote set replicas identify replica integer simplicity assume maximum number replicas may faulty replicas additional replicas degrade performance bigger messages exchanged providing improved resiliency 
replicas move succession configurations called views 
view replica primary backups 
views numbered consecutively 
primary view replica mod view number 
view changes carried appears primary failed 
replication paxos similar approach tolerate benign faults discussed section 
algorithm works roughly follows 
client sends request invoke service operation primary 
primary multicasts request backups 
replicas execute request send reply client 
client waits replies different replicas result result operation 
state machine replication techniques impose requirements replicas deterministic execution operation state set arguments produce result start state :10.1.1.20.4762
requirements algorithm ensures safety property guaranteeing nonfaulty replicas agree total order execution requests despite failures 
remainder section describes simplified version algorithm 
omit discussion nodes recover faults due lack space 
omit details related message retransmissions 
furthermore assume message authentication achieved digital signatures efficient scheme message authentication codes section discusses issue 
detailed formalization algorithm automaton model :10.1.1.16.9935
client client requests execution state machine operation sending request message primary 
timestamp ensure semantics execution client requests 
timestamps requests totally ordered requests higher timestamps earlier ones example timestamp value client local clock request issued 
message sent replicas client includes current view number allowing client track view current primary 
client sends request believes current primary point point message 
primary atomically multicasts request backups protocol described section 
replica sends reply request directly client 
reply form reply current view number timestamp corresponding request replica number result executing requested operation 
client waits replies valid signatures different replicas accepting result ensures result valid replicas faulty 
client receive replies soon broadcasts request replicas 
request processed replicas simply re send reply replicas remember reply message sent client 
replica primary relays request primary 
primary multicast request group eventually suspected faulty replicas cause view change 
assume client waits request complete sending 
allow client asynchronous requests preserve ordering constraints 
normal case operation state replica includes state service message log containing messages replica accepted integer denoting replica current view 
describe truncate log section 
primary receives client request starts phase protocol atomically multicast request replicas 
primary starts protocol immediately number messages protocol progress exceeds maximum 
case buffers request 
buffered requests multicast group cut message traffic cpu overheads heavy load optimization similar group commit transactional systems 
simplicity ignore optimization description 
phases pre prepare prepare commit 
pre prepare prepare phases totally order requests sent view primary proposes ordering requests faulty 
prepare commit phases ensure requests commit totally ordered views 
pre prepare phase primary assigns sequence number request multicasts message piggybacked backups appends message log 
message pre prepare form indicates view message sent client request message digest 
requests included pre prepare messages keep small 
important messages proof request assigned sequence number view view changes 
additionally decouples protocol totally order requests protocol transmit request replicas allowing transport optimized small messages protocol messages transport optimized large messages large requests 
backup accepts pre prepare message provided signatures request pre prepare message correct digest accepted pre prepare message view number sequence containing different digest sequence number pre prepare message view low water mark high water mark condition prevents faulty primary exhausting space sequence numbers selecting large 
discuss advance section 
backup pre prepare accepts message enters prepare phase multicasting message replicas prepare adds messages log 

replica including primary accepts prepare messages adds log provided signatures correct view number equals replica current view sequence number prepared define predicate true replica inserted log request pre prepare view sequence number prepares different backups match pre prepare 
replicas verify prepares match pre prepare checking view sequence number digest 
pre prepare prepare phases algorithm guarantee non faulty replicas agree total order prepared prepared requests view 
precisely ensure invariant true false non faulty including replica true prepared sent pre prepare prepare prepared view sequence number true replicas needs sent conflicting prepares pre prepares primary prepares view sequence number different digest 
possible replica faulty 
assumption strength message digests ensures probability negligible 
replica commit prepared multicasts replicas true 
imply non faulty replicas starts commit phase 
replicas accept commit messages insert log provided properly signed view number message equal replica current view sequence number committed prepared define committed committed local predicates follows true true set non faulty replicas committed local prepared true true accepted commits possibly including different replicas match pre prepare committed local committed commit matches pre prepare view sequence number digest 
commit phase ensures invariant true non faulty true 
invariant view change protocol described section ensure non faulty replicas agree sequence numbers requests commit locally commit different views replica 
furthermore ensures request commits locally non faulty replica commit non faulty replicas eventually 
replica executes operation requested committed local true state reflects sequential execution requests lower sequence numbers 
ensures nonfaulty replicas execute requests order required provide safety property 
executing requested operation replicas send reply client 
replicas discard requests timestamp lower timestamp reply sent client guarantee exactly semantics 
rely ordered message delivery possible replica commit requests order 
matter keeps prepare commit messages logged corresponding request executed 
shows operation algorithm normal case primary faults 
replica primary replica faulty client 
request pre prepare prepare commit reply normal case operation garbage collection section discusses mechanism discard messages log 
safety condition hold messages kept replica log knows requests concern executed non faulty replicas prove view changes 
addition replica misses messages discarded non faulty replicas need brought date transferring portion service state 
replicas need proof state correct 
generating proofs executing operation expensive 
generated periodically request sequence number divisible constant executed 
refer states produced execution requests checkpoints say checkpoint proof stable checkpoint 
replica maintains logical copies service state stable checkpoint zero checkpoints stable current state 
copy write techniques reduce space overhead store extra copies state discussed section 
proof correctness checkpoint generated follows 
replica checkpoint produces checkpoint multicasts message replicas sequence number request execution reflected state digest state 
replica collects checkpoint messages log sequence number digest signed different replicas including possibly message 
messages proof correctness checkpoint 
checkpoint proof stable replica discards pre prepare prepare commit messages sequence number equal log discards earlier checkpoints checkpoint messages 
computing proofs efficient digest computed incremental cryptography discussed section proofs generated rarely 
checkpoint protocol advance low high water marks limit messages accepted 
low water mark equal sequence number stable checkpoint 
high water mark big replicas stall waiting checkpoint stable 
example checkpoints taken requests 
view changes view change protocol provides liveness allowing system progress primary fails 
view changes triggered timeouts prevent backups waiting indefinitely requests execute 
backup request received valid request executed 
backup starts timer receives request timer running 
stops timer longer waiting execute request restarts point waiting execute request 
timer backup expires view backup starts view change move system view 
stops accepting messages checkpoint view change new view messages view change multicasts message replicas 
sequence number stable checkpoint known set valid checkpoint messages proving correctness set containing set request prepared sequence number higher set contains valid pre prepare message corresponding client message matching valid prepare messages signed different backups view sequence number digest primary view new view view change messages view replicas multicasts message replicas set containing valid messages received primary plus message primary sent receives valid sent set pre prepare messages piggybacked request 
computed follows 
primary determines sequence number min latest stable checkpoint highest sequence number max prepare message 
primary creates new pre prepare message view number sequence min max 
cases set component view change message sequence number pre prepare pre prepare set 
case primary creates new message request digest pre prepare message sequence number highest view number second case creates new message digest special null request null request goes protocol requests execution op 
paxos similar technique fill gaps 
primary appends messages log 
min greater sequence number latest stable checkpoint primary inserts proof stability checkpoint sequence number min log discards information log discussed section 
enters view point able accept messages view 
backup accepts new view message view signed properly view change messages contains valid view set correct verifies correctness performing computation similar primary create adds new information log described primary multicasts prepare message replicas adds prepares log enters view 
protocol proceeds described section 
replicas redo protocol messages min max avoid re executing client requests stored information reply sent client 
replica may missing request message stable checkpoint sent newview messages 
obtain missing information replica 
example replica obtain missing checkpoint state replicas checkpoint messages certified correctness replicas correct replica obtain certified stable checkpoint 
avoid sending entire checkpoint partitioning state stamping partition sequence number request modified 
bring replica date necessary send partitions date checkpoint 
correctness section sketches proof algorithm provides safety liveness details :10.1.1.16.9935
safety discussed earlier algorithm provides safety non faulty replicas agree sequence numbers requests commit locally 
section showed prepared prepared true false non faulty replica including implies non faulty replicas agree sequence number requests commit locally view replicas 
view change protocol ensures non faulty replicas agree sequence number requests commit locally different views different replicas 
request commits locally non faulty replica sequence view committed number true 
means set containing true replica set 
non faulty replicas accept pre prepare view having received new view message point enter view 
correct new view message view contains correct view change messages replica non faulty replicas prepared set replicas 
replicas intersect replica faulty 
view change message ensure fact prepared previous view propagated subsequent views new view message contains view change message stable checkpoint sequence number higher case algorithm phases atomic multicast protocol sequence number new view number 
important prevents different request assigned sequence number previous view committing 
second case replica new view accept message sequence number lower case replicas agree request commits locally sequence number liveness provide liveness replicas move new view unable execute request 
important maximize period time non faulty replicas view ensure period time increases exponentially requested operation executes 
achieve goals means 
avoid starting view change soon replica multicasts view change message view waits view change messages view starts timer expire time timer expires receives valid new view message executes request new view executed previously starts view change view time wait starting view change view 
second replica receives set valid messages replicas views greater current view sends view change message smallest view set timer expired prevents starting view change late 
third faulty replicas unable impede progress forcing frequent view changes 
faulty replica cause view change sending view change message view change happen replicas send view change messages cause view change primary sending messages sending bad messages 
primary view replica mod primary faulty consecutive views 
techniques guarantee liveness message delays grow faster timeout period indefinitely real system 
non determinism state machine replicas deterministic services involve form non determinism 
example time modified nfs set reading server local clock done independently replica states non faulty replicas diverge 
mechanism ensure replicas select value needed 
general client select value information example know request ordered relative concurrent requests clients 
primary needs select value independently values provided backups 
primary selects non deterministic value independently concatenates value associated request executes phase protocol ensure non faulty replicas agree sequence number request value 
prevents faulty primary causing replica state diverge sending different values different replicas 
faulty primary send incorrect value replicas 
replicas able decide deterministically value correct service state 
protocol adequate services including nfs occasionally replicas participate selecting value satisfy service specification 
accomplished adding extra phase protocol primary obtains authenticated values proposed backups concatenates associated request starts phase protocol concatenated message 
replicas choose value deterministic computation values state median 
extra phase optimized away common case 
example replicas need value close local clock extra phase avoided clocks synchronized delta 
optimizations section describes optimizations improve performance algorithm normal case operation 
optimizations preserve liveness safety properties 
reducing communication optimizations reduce cost communication 
avoids sending large replies 
client request designates replica send result replicas send replies containing just digest result 
digests allow client check correctness result reducing network bandwidth consumption cpu overhead significantly large replies 
client receive correct result designated replica retransmits request usual requesting replicas send full replies 
second optimization reduces number message delays operation invocation 
replicas execute request tentatively soon prepared predicate holds request state reflects execution requests lower sequence number requests known committed 
executing request replicas send tentative replies client 
client waits matching tentative replies 
receives request guaranteed commit eventually 
client retransmits request waits non tentative replies 
request executed tentatively may abort view change replaced null request 
case replica reverts state stable checkpoint new view message checkpointed state depending higher sequence number 
third optimization improves performance read operations modify service state 
client multicasts read request replicas 
replicas execute request immediately tentative state checking request properly authenticated client access request fact read 
send reply requests reflected tentative state committed necessary prevent client observing uncommitted state 
client waits replies different replicas result 
client may unable collect replies concurrent writes data affect result case retransmits request regular read write request retransmission timer expires 
cryptography section described algorithm uses digital signatures authenticate messages 
digital signatures new view messages sent rarely authenticate messages message authentication codes macs 
eliminates main performance bottleneck previous systems 
macs fundamental limitation relative digital signatures inability prove message authentic third party 
algorithm section previous byzantine fault tolerant algorithms state machine replication rely extra power digital signatures :10.1.1.112.6123
modified algorithm circumvent problem advantage specific invariants invariant different requests prepare view sequence number non faulty replicas 
modified algorithm described 
sketch main implications macs 
macs computed orders magnitude faster digital signatures 
example mhz pentium pro takes ms generate bit modulus rsa signature md digest ms verify signature takes compute mac byte message hardware implementation 
publickey cryptosystems generate signatures faster elliptic curve public key cryptosystems signature verification slower algorithm signature verified times 
node including active clients shares byte secret session key replica 
compute message authentication codes applying md concatenation message secret key 
bytes final md digest significant bytes 
truncation obvious advantage reducing size macs improves resilience certain attacks 
variant secret suffix method secure long md collision resistant :10.1.1.51.6690
digital signature reply message replaced single mac sufficient messages single intended recipient 
signatures messages including client requests excluding view changes replaced vectors macs call authenticators 
authenticator entry replica sender entry mac computed key shared sender replica corresponding entry 
time verify authenticator constant time generate grows linearly number replicas 
problem expect large number replicas huge performance gap mac digital signature computation 
furthermore compute authenticators efficiently md applied message resulting context compute vector entry applying md corresponding session key 
example system replicas system tolerate simultaneous faults authenticator computed orders magnitude faster bit modulus rsa signature 
size authenticators grows linearly number replicas grows slowly equal bytes 
authenticator smaller rsa signature bit modulus systems tolerate simultaneous faults expect true configurations 
implementation section describes implementation 
discuss replication library basis replicated service 
section describe implemented replicated nfs top replication library 
describe maintain checkpoints compute checkpoint digests efficiently 
replication library client interface replication library consists single procedure invoke argument input buffer containing request invoke state machine operation 
invoke procedure uses protocol execute requested operation replicas select correct reply replies individual replicas 
returns pointer buffer containing operation result 
server side replication code number upcalls procedures server part application implement 
procedures execute requests execute maintain checkpoints service state checkpoint delete checkpoint obtain digest specified checkpoint get digest obtain missing information get checkpoint set checkpoint 
execute procedure receives input buffer containing requested operation executes operation places result output buffer 
procedures discussed sections 
point point communication nodes implemented udp multicast group replicas implemented udp ip multicast 
single ip multicast group service contains replicas 
communication protocols unreliable may duplicate lose messages deliver order 
algorithm tolerates order delivery rejects duplicates 
view changes recover lost messages expensive important perform retransmissions 
normal operation recovery lost messages driven receiver backups send negative acknowledgments primary date primary retransmits pre prepare messages long timeout 
reply negative acknowledgment may include portion stable checkpoint missing messages 
view changes replicas retransmit view change messages receive matching newview message move view 
replication library implement view changes retransmissions 
compromise accuracy results section rest algorithm completely implemented including manipulation timers trigger view changes formalized complete algorithm proved correctness :10.1.1.16.9935
bfs byzantine fault tolerant file system implemented bfs byzantine fault tolerant nfs service replication library 
shows architecture bfs 
opted modify kernel nfs client server sources digital unix kernel 
file system exported fault tolerant nfs service mounted client machine regular nfs file system 
application processes run unmodified interact mounted file system nfs client kernel 
rely user level relay processes mediate communication standard nfs client replicas 
relay receives nfs protocol requests calls invoke procedure replication library sends result back nfs client 
client andrew benchmark kernel nfs client relay replication library replica replication library kernel vm replica replication library kernel vm replicated file system architecture 
replica runs user level process replication library nfs daemon refer simple 
replication library receives requests relay interacts making upcalls packages nfs replies replication protocol replies sends relay 
implemented fixed size file 
file system data structures inodes blocks free lists mapped file 
rely operating system manage cache memory mapped file pages write modified pages disk asynchronously 
current implementation uses kb blocks inodes contain nfs status information plus bytes data store directory entries directories pointers blocks files text symbolic links 
directories files may indirect blocks way similar unix 
implementation ensures state machine replicas start initial state deterministic necessary conditions correctness service implemented protocol 
primary proposes values time modified accessed replicas select larger proposed value greater maximum values selected earlier requests 
require synchronous writes implement nfs protocol semantics bfs achieves stability modified data meta data replication 
maintaining checkpoints section describes maintains checkpoints file system state 
recall replica maintains logical copies state current state number checkpoints stable stable checkpoint 
executes file system operations directly memory mapped file preserve locality uses write reduce space time overhead associated maintaining checkpoints 
maintains write bit byte block memory mapped file 
replication code invokes checkpoint upcall sets copy write bits creates volatile checkpoint record containing current sequence number receives argument upcall list blocks 
list contains copies blocks modified checkpoint taken initially empty 
record contains digest current state discuss digest computed section 
block memory mapped file modified executing client request checks write bit block set stores block current contents identifier checkpoint record checkpoint 
overwrites block new value resets copy write bit 
retains checkpoint record told discard delete checkpoint upcall replication code checkpoint stable 
replication code requires checkpoint send replica calls get checkpoint upcall 
obtain value block searches block checkpoint record stable checkpoint searches checkpoint records checkpoints 
block checkpoint record returns value current state 
copy write technique fact keep checkpoints ensure space time overheads keeping logical copies state low 
example andrew benchmark experiments described section average checkpoint record size blocks maximum 
computing checkpoint digests computes digest checkpoint state part checkpoint upcall 
checkpoints taken occasionally important compute state digest incrementally state may large 
uses incremental collision resistant oneway hash function called 
function divides state fixed size blocks uses hash function md compute digest string obtained concatenating block index block value block 
digest state sum digests blocks modulo large integer 
current implementation byte blocks copy write technique compute digest md 
compute digest state incrementally maintains table hash value byte block 
hash value obtained applying md block index concatenated block value time checkpoint 
checkpoint called obtains digest previous checkpoint state associated checkpoint record 
computes new hash values block write bit reset applying md block index concatenated current block value 
adds new hash value subtracts old hash value updates table contain new hash value 
process efficient provided number modified blocks small mentioned average blocks modified checkpoint andrew benchmark 
performance evaluation section evaluates performance system benchmarks micro benchmark andrew benchmark 
micro benchmark provides service independent evaluation performance replication library measures latency invoke null operation operation 
andrew benchmark compare bfs file systems nfs implementation digital unix identical bfs replication 
comparison demonstrates system practical showing latency similar latency commercial system daily users 
second comparison allows evaluate overhead algorithm accurately implementation real service 
experimental setup experiments measure normal case behavior view changes behavior determines performance system 
experiments ran client running relay processes replicas 
replicas tolerate byzantine fault expect reliability level suffice applications 
replicas client ran identical dec alpha workstations 
workstations mhz alpha processor mb memory run digital unix version 
file system stored replica dec rz disk 
workstations connected mbit switched ethernet dec lance ethernet interfaces 
switch dec tx 
experiments run isolated network 
interval checkpoints requests causes garbage collection occur times experiments 
maximum sequence number accepted replicas pre prepare messages plus sequence number stable checkpoint 
micro benchmark micro benchmark measures latency invoke null operation 
evaluates performance implementations simple service state implements null operations arguments results different sizes 
implementation replicated library second unreplicated uses udp directly 
table reports response times measured client read readwrite operations 
obtained timing operation invocations separate runs report median value runs 
maximum deviation median reported value 
denote operation sizes operation argument result kbytes 
arg res 
replicated kb read write read replication table micro benchmark results milliseconds percentage overhead relative unreplicated case 
overhead introduced replication library due extra computation communication 
example computation overhead read write operation approximately ms includes ms spent executing cryptographic operations 
remaining ms overhead due extra communication replication library introduces extra message roundtrip sends larger messages increases number messages received node relative service replication 
overhead read operations significantly lower optimization discussed section reduces computation communication overheads 
example computation overhead read operation approximately ms includes ms spent executing cryptographic operations communication overhead ms protocol execute read operations uses single round trip 
table shows relative overhead lower operations 
significant fraction overhead introduced replication library independent size operation arguments results 
example read write operation large message reply goes network discussed section cryptographic overhead process reply message increased 
overhead higher read write operation large message request goes network twice increases cryptographic overhead processing request pre prepare messages 
important note micro benchmark represents worst case overhead algorithm operations perform unreplicated server provides weak guarantees 
services require stronger guarantees authenticated connections overhead introduced algorithm relative server implements guarantees lower 
example overhead replication library relative version unreplicated service uses macs authentication read write operation read operation 
estimate rough lower bound performance gain afforded algorithm relative rampart 
reiter reports rampart latency ms multi rpc null message mbit ethernet network sparcstation 
multi rpc sufficient primary invoke state machine operation arbitrary client invoke operation necessary add extra message delay extra rsa signature verification authenticate client lead latency ms rsa timings reported 
divide latency ratio specint ratings dec sparcstation algorithm reduces latency invoke read write read operations factors respectively 
note scaling conservative network accounts significant fraction rampart latency rampart results obtained bit modulus rsa signatures considered secure today keys generate refreshed frequently 
published performance numbers securering slower rampart algorithm message delays signature operations critical path :10.1.1.112.6123
andrew benchmark andrew benchmark emulates software development workload 
phases creates subdirectories recursively copies source tree examines status files tree examining data examines byte data files compiles links files 
andrew benchmark compare bfs file system configurations nfs std nfs implementation digital unix bfs nr identical bfs replication 
bfs nr ran simple udp relays client server ran thin veneer linked version checkpoint management code removed 
configuration write modified file system state disk replying client 
implement nfs protocol semantics bfs nfs std 
operations nfs protocol getattr read time accessed attribute files directories set operations read read lookup 
result optimization readonly operations rarely 
show impact optimization ran andrew benchmark second version bfs modifies lookup operation read 
modification violates strict unix file system semantics adverse effects practice 
configurations actual benchmark code ran client workstation standard nfs client implementation digital unix kernel mount options 
relevant options benchmark udp transport byte read write buffers allowing asynchronous client writes allowing attribute caching 
report mean runs benchmark configuration 
sample standard deviation total time run benchmark reported value high individual times phases 
high variance nfs std configuration 
estimated error reported mean individual phases total 
table shows results bfs bfs nr 
comparison bfs strict bfs nr shows overhead byzantine fault tolerance service low bfs strict takes time run bfs phase strict lookup bfs nr total table andrew benchmark bfs vs bfs nr 
times seconds 
complete benchmark 
overhead lower observed micro benchmarks client spends significant fraction elapsed time computing operations receiving reply operation issuing request operations server perform computation 
overhead uniform benchmark phases 
main reason variation amount time client spends computing operations phases higher relative overhead client spends approximately total time computing operations spends approximately phases 
table shows applying read optimization lookup improves performance bfs significantly reduces overhead relative bfs nr 
optimization significant impact phases time spent waiting lookup operations complete bfs strict elapsed time phases elapsed time phase 
bfs phase strict lookup nfs std total table andrew benchmark bfs vs nfs std 
times seconds 
table shows results bfs vs nfs std 
results show bfs practice takes time run complete benchmark 
replace nfs implementation digital unix daily users bfs affecting latency perceived users 
furthermore bfs read optimization lookup operation faster nfs std 
overhead bfs relative nfs std phases 
versions bfs faster nfs std phases slower phases 
phases large fraction operations issued client synchronous operations require nfs implementation ensure stability modified file system state replying client 
nfs std achieves stability writing modified state disk bfs achieves stability lower latency replication harp 
nfs std faster bfs bfs nr phases client issues synchronous operations phases 
related previous replication techniques ignored byzantine faults assumed synchronous system model 
replication paxos views primary backups tolerate benign faults asynchronous system 
tolerating byzantine faults requires complex protocol cryptographic authentication extra pre prepare phase different technique trigger view changes select primaries 
furthermore system uses view changes select new primary select different set replicas form new view 
agreement consensus algorithms tolerate byzantine faults asynchronous systems 
provide complete solution state machine replication furthermore designed demonstrate theoretical feasibility slow practice 
algorithm normal case operation similar byzantine agreement algorithm algorithm unable survive primary failures 
systems closely related rampart securering :10.1.1.112.6123
implement state machine replication order magnitude slower system importantly rely synchrony assumptions 
rampart securering exclude faulty replicas group progress remove faulty primary elect new perform garbage collection 
rely failure detectors determine replicas faulty 
failure detectors accurate asynchronous system may misclassify replica faulty 
correctness requires fewer group members faulty misclassification compromise correctness removing non faulty replica group 
opens avenue attack attacker gains control single replica change behavior detectable way slows correct replicas communication excluded group 
reduce probability misclassification failure detectors calibrated delay classifying replica faulty 
probability negligible delay large undesirable 
example primary failed group unable process client requests delay expired 
algorithm vulnerable problem needs exclude replicas group 
phalanx applies quorum replication techniques achieve byzantine fault tolerance asynchronous systems :10.1.1.12.6256
provide generic state machine replication offers data repository operations read write individual variables acquire locks 
semantics provides read write operations weaker offered algorithm implement arbitrary operations access number variables phalanx necessary acquire release locks execute operations 
published performance numbers phalanx believe algorithm faster fewer message delays critical path macs public key cryptography 
approach phalanx offers potential improved scalability operation processed subset replicas 
approach scala bility expensive requires tolerate faults replica needs copy state load replica decreases slowly 
described new state machine replication algorithm able tolerate byzantine faults practice correctly asynchronous system internet improves performance previous algorithms order magnitude 
described bfs byzantine faulttolerant implementation nfs 
bfs demonstrates possible algorithm implement real services performance close unreplicated service performance bfs worse standard nfs implementation digital unix 
performance due number important optimizations including replacing public key signatures vectors message authentication codes reducing size number messages incremental checkpoint management techniques 
reason byzantine fault tolerant algorithms important allow systems continue correctly software errors 
errors survivable approach mask software error occurs replicas 
mask errors occur independently different replicas including nondeterministic software errors problematic persistent errors hardest detect 
fact encountered software bug running system algorithm able continue running correctly spite 
improving system 
problem special interest reducing amount resources required implement algorithm 
number replicas reduced replicas witnesses involved protocol full replica fails 
believe possible reduce number copies state details remain worked 
acknowledgments atul adya chandrasekhar boyapati nancy lynch mullender andrew myers shrira anonymous referees helpful comments drafts 
bellare micciancio 
new paradigm hashing incrementality reduced cost 
advances cryptology eurocrypt 
bracha toueg 
asynchronous consensus broadcast protocols 
journal acm 
rabin 
optimal asynchronous byzantine agreement 
technical report computer science department hebrew university 
castro liskov :10.1.1.16.9935
correctness proof practical byzantine fault tolerant replication algorithm 
technical memo mit lcs tm mit laboratory computer science 
castro liskov 
authenticated byzantine fault tolerance public key cryptography 
technical memo mit lcs tm mit laboratory computer science 
cristian strong dolev 
atomic broadcast simple message diffusion byzantine agreement 
international conference fault tolerant computing 
deering cheriton 
multicast routing datagram internetworks extended lans 
acm transactions computer systems 

status md attack 
rsa laboratories cryptobytes 
fischer lynch paterson 
impossibility distributed consensus faulty process 
journal acm 
garay moses 
fully polynomial byzantine agreement processors rounds 
siam journal computing 
gawlick 
varieties concurrency control ims vs fast path 
database engineering 
gifford :10.1.1.12.6256
weighted voting replicated data 
symposium operating systems principles 
herlihy tygar 
replicated data secure 
advances cryptology lncs 
herlihy wing 
axioms concurrent objects 
acm symposium principles programming languages 
howard scale performance distributed file system 
acm transactions computer systems 
moser melliar smith :10.1.1.112.6123
securering protocols securing group communication 
hawaii international conference system sciences 
lamport 
time clocks ordering events distributed system 
commun 
acm 
lamport 
part time parliament 
technical report dec systems research center 
lamport shostak pease 
byzantine generals problem 
acm transactions programming languages systems 
liskov replication harp file system 
acm symposium operating system principles 
lynch 
distributed algorithms 
morgan kaufmann publishers 
malkhi reiter 
high throughput secure reliable multicast protocol 
computer security foundations workshop 
malkhi reiter 
byzantine quorum systems 
acm symposium theory computing 
malkhi reiter 
unreliable intrusion detection distributed computations 
computer security foundations workshop 
malkhi reiter 
secure scalable replication phalanx 
ieee symposium reliable distributed systems 
oki liskov 
replication new primary copy method support highly available distributed systems 
acm symposium principles distributed computing 
preneel oorschot 
mdx mac building fast macs hash functions 
crypto 
pu black cowan walpole 
specialization toolkit increase diversity operating systems 
icmas workshop immunity systems 
reiter 
secure agreement protocols 
acm conference computer communication security 
reiter 
rampart toolkit building high integrity services 
theory practice distributed systems lncs 
reiter 
secure group membership protocol 
ieee transactions software engineering 
rivest 
md message digest algorithm 
internet rfc 
rivest shamir adleman :10.1.1.40.5588
method obtaining digital signatures public key cryptosystems 
communications acm 
schneider :10.1.1.20.4762
implementing fault tolerant services state machine approach tutorial 
acm computing surveys 
shamir 
share secret 
communications acm 
tsudik :10.1.1.51.6690
message authentication way hash functions 
acm computer communications review 
wiener 
performance comparison public key cryptosystems 
rsa laboratories cryptobytes 
