isabelle isar isabelle isar manual markus wenzel tu nchen november contents overview 
quick start 
terminal sessions 
proof general 
isabelle isar theories 
document preparation 
write isar proofs anyway 
syntax primitives lexical matters 
common syntax entities 
names 
comments 
type classes sorts arities 
types terms 
mixfix annotations 
proof methods 
attributes theorems 
term patterns declarations 

tagged commands 
basic language elements theory commands 
defining theories 
markup commands 
type classes sorts 
primitive types type abbreviations 
primitive constants definitions 
syntax translations 
axioms theorems 
name spaces 
incorporating ml code 
contents ii syntax translation functions 
oracles 
proof commands 
markup commands 
context elements 
facts forward chaining 
goal statements 
initial terminal proof steps 
fundamental methods attributes 
term abbreviations 
block structure 
emulating tactic scripts 
meta linguistic features 
commands 
diagnostics 
inspecting context 
history commands 
system operations 
generic tools packages specification commands 
derived specifications 
generic declarations 
local theory targets 
locales 
type classes 
axiomatic type classes 
configuration options 
derived proof schemes 
generalized elimination 
calculational reasoning 
proof tools 
miscellaneous methods attributes 
tactic 
simplifier 
classical reasoner 
proof cases induction 
contents iii object logic specific elements general logic setup 
hol 
primitive types 
adhoc tuples 
records 
datatypes 
recursive functions 
definition specification 
inductive coinductive definitions 
arithmetic proof support 
cases induction emulating tactic scripts 
executable code 
holcf 
mixfix syntax continuous operations 
recursive domains 
zf 
type checking 
inductive sets datatypes 
isabelle isar quick proof commands 
primitives basic syntax 
abbreviations synonyms 
derived elements 
diagnostic commands 
proof methods 
attributes 
rule declarations methods 
emulating tactic scripts 
commands 
methods 
isabelle isar conversion guide conversion 
referring theorem theory values 
storing theorem values 
ml declarations isar 
porting theories proof scripts 
theories 
goal statements 
contents iv tactics 
declarations ad hoc operations 
writing actual isar proof texts 
overview chapter isabelle system essentially provides generic infrastructure building deductive systems programmed standard ml special focus interactive theorem proving higher order logics 
olden days users refer certain ml functions goal commands tactics tacticals pursue everyday theorem proving tasks 
contrast isar provides interpreted language environment specifically tailored needs theory proof development 
compared raw ml isabelle isar top level provides robust comfortable development platform proper support theory development graphs single step transactions unlimited undo isabelle isar version proof general user interface provides adequate front interactive theory proof development advanced theorem proving environment 
apart technical advances bare bones ml programming main purpose isar language provide conceptually different view machine checked proofs 
isar stands intelligible semi automated reasoning 
drawing traditions informal mathematical proof texts high level programming languages isar offers versatile environment structured formal proof documents 
properly written isar proofs accessible broader audience unstructured tactic scripts typically provide operational information machine 
writing human readable proof texts certainly requires additional efforts writer achieve presentation formal informal parts text 
hand human readable formal texts gain value right independently mechanic proof checking process 
despite grand design structured proof texts isar able assimilate old tactical style improper sub language 
provides easy upgrade path existing tactic scripts additional means interactive experimentation debugging structured proofs 
isabelle isar chapter 
supports broad range proof styles readable unreadable ones 
isabelle isar framework generic reasonably isabelle object logic conforms natural deduction view isabelle pure framework 
major isabelle logics hol holcf fol zf set users 
existing body theories consist old style theory files accompanied ml code proof scripts legacy gradually converted due time 
quick start terminal sessions isar part isabelle 
low level isabelle binary provides option run isabelle isar interaction loop startup raw ml top level 
basic way isabelle isar follows isabelle hol welcome isabelle hol isabelle theory foo imports main foo nat foo lemma foo simp add foo def note isabelle isar command may retracted undo 
see isabelle isar quick appendix comprehensive overview available commands language elements 
proof general plain tty interaction quite feasible traditional tactic theorem proving developing isar documents really demands better user interface support 
proof general environment david aspinall offers generic emacs interface interactive theorem provers organizes cut paste forward backward walk text neat way 
isabelle isar current position partial proof document equally important actual proof state 
proof general provides canonical working environment isabelle isar getting acquainted replaying existing isar documents production 
chapter 
proof general default isabelle interface isabelle interface wrapper script provides easy way invoke proof general including gnu emacs 
default configuration isabelle smart detect proof general distribution canonical places isabelle home contrib 
capital isabelle executable refer isar interface ado 
isabelle interface script provides options pass 
see usage 
proper isabelle interface setup isar documents may edited visiting appropriate theory files isabelle src hol isar examples summation thy beginners may note tool bar navigating forward backward text depends local emacs installation 
consult proof general documentation basic command sequences particular return 
proof general may configured manually giving isabelle settings see isabelle interface isabelle home contrib isar interface options may change isabelle home contrib actual installation directory proof general 
apart isabelle command line defaults interface options may options setting 
example emacs executable may configured isabelle settings options mule occasionally user emacs file contains code incompatible emacs version proof general causing interface startup fail prematurely 
false option helps get interface process running 
note additional lisp customization code may reside settings el isabelle home isabelle home user symbol package proof general provides native support emacs symbol package handles proper mathematical symbols displayed screen 
pass option chapter 
true isabelle interface script check appropriate proof general menu setting hand 
case symbol package properly installed 
contrary may expect documentation symbol package easy install configures automatically 
default configuration isabelle smart detect symbol package canonical places isabelle home contrib symbol 
proper mathematical symbols isabelle theories convenient readability large formulas 
hand plain ascii sources easily somewhat unintelligible 
example appear default set isabelle symbols 
isabelle document preparation system see happy print non ascii symbols properly 
possible invent additional notation display capabilities emacs symbol 
isabelle isar theories isabelle isar offers main improvements classic isabelle 

new theory format occasionally referred new style theories supporting interactive development unlimited undo operation 

formal proof document language designed support intelligible semiautomated reasoning 
putting unreadable tactic scripts author enabled express reasoning way close usual mathematical practice 
old tactical style assimilated improper language elements 

simple document preparation system typesetting formal developments informal text 
resulting hyper linked pdf documents equally suited www presentation printed copies 
isar proof language embedded new theory format proper sub language 
proof mode entered stating theorem lemma theory level left final qed 
theory specification mechanisms require proof hol typedef demands non emptiness representing sets 
new style theory files may associated separate ml files consisting plain old tactic scripts 
longer ml binding generated theory theorems 
ml functions theory thm chapter 
thms retrieve information context 
migration classic isabelle isabelle isar relatively easy 
users may start benefit interactive theory development document preparation idea isar proof language 
proof general support mixed interactive development classic isabelle theory files tactic scripts isar documents 
isa isar versions proof general handled different theorem proving systems may active time 
manual conversion existing tactic scripts may done running separate proof general sessions replaying old script emerging isabelle isar document 
note isar supports emulation commands methods support traditional tactic scripts new style theories see appendix information 
document preparation isabelle isar provides simple document preparation system existing pdf atex technology full support hyper links local urls bookmarks thumbnails 
results equally suited www browsing printed copies 
isabelle generates atex output part run logic session see 
getting started working configuration common situations quite easy isabelle mkdir tools 
invoke mkdir foo initialize separate directory session foo safe experiment mkdir overwrites existing files 
ensure foo root ml holds ml commands load theories required session furthermore foo document root tex include special atex macro packages required document default usually sufficient start 
session controlled separate crude source dependencies default 
file located level foo directory location 
invoke foo run foo session browser information document preparation enabled 
errors reported isabelle atex output appear inside directory isabelle browser info reported batch job verbose mode 
chapter 
may consider tune options example change output format pdf dvi activate option retain second copy generated atex sources 
see isabelle system manual details isabelle logic sessions theory presentation 
isabelle hol tutorial covers theory presentation issues 
write isar proofs anyway 
key questions course 
tactic script emulation isabelle isar essentially provides clarified version unstructured proof style classic isabelle 
old time users quickly acquainted slightly view isar 
writing proper isar proof texts targeted human readers quite different 
experienced users unstructured style may habits master proof composition isar 
contrast new users experience old style tactical proving understanding mathematical proof general get started easier 
text really manual isabelle isar tutorial 
attempt give clues concepts introduced may put practice 
appendix provides quick card common isabelle isar language elements 
appendix offers practical hints converting existing isabelle theories proof scripts new format restructuring proofs 
issues concerning isar concepts covered literature 
author phd thesis presently provides complete exposition isar foundations techniques applications 
number example applications distributed isabelle available isabelle www library isabelle tum de library 
general rule thumb isabelle applications include separate document pdf consist proper isabelle isar theories proofs 
syntax primitives chapter generic framework isabelle isar syntax emerges main syntactic categories commands top level isar engine covering theory proof elements methods general goal refinements analogous traditional tactics attributes operations facts certain context 
give basic syntactic entities underlying isabelle isar syntax bottom manner 
concrete theory proof language elements introduced 
order get started writing formed isabelle isar documents important aspect noted difference inner versus outer syntax 
inner syntax isabelle types terms logic outer syntax isabelle isar theory sources including proofs 
general rule inner syntax entities may occur atomic entities outer syntax 
example string identifier legal term specifications theory 
old style isabelle theories fake parts inner syntax types complicated rules quotes may omitted 
despite minor drawback requiring quotes syntax isabelle isar somewhat simpler robust respect 
printed theory documents usually omit quotes gain readability matter atex macro setup say see 
experienced users isabelle isar may easily reconstruct lost technical information mere readers need care quotes 
isabelle isar input may contain number input termination characters semicolon separate commands explicitly 
particularly useful interactive shell sessions clear current command intended 
interpreter loop continue issue secondary prompt command clearly recognized input syntax encounter command keyword 
advanced interfaces proof general require explicit semicolons amount input text determined automatically inspecting chapter 
syntax primitives content emacs text buffer 
printed presentation isabelle isar documents semicolons omitted altogether readability 
proof general requires certain syntax classification tables order achieve properly synchronized interaction isabelle isar process 
tables need consistent isabelle version particular logic image running session common object logics may change outer syntax 
standard setup correctly official logic images derived isabelle hol including holcf 
users alternative logics may need tell proof general explicitly giving option zf conjunction zf specify default logic image 
chapter 
syntax primitives lexical matters isabelle isar outer syntax provides token classes coincide inner lexical syntax 
ident letter ident ident sym ident nat digit var ident ident ident nat ident typevar nat string 

verbatim 
letter latin latin latin latin greek isub letter digit latin 

digit 
sym greek alpha beta gamma delta epsilon zeta eta theta iota kappa mu nu xi pi rho sigma tau upsilon phi psi omega gamma delta theta lambda xi pi sigma upsilon phi psi omega syntax string admits characters including newlines double quote backslash need escaped backslash 
alternative strings analogous single back quotes 
body verbatim may consist text containing allows convenient inclusion quotes escapes 
greek letters include lambda differently meta logic 
common mathematical symbols represented isabelle forall 
infinitely legal symbols proper presentation left front tools atex proof general chapter 
syntax primitives symbol package 
list standard isabelle symbols tools appendix 
comments take form 
may nested userinterface tools may prevent 
note 
indicate source comments stripped lexical analysis input 
isar document syntax provides formal comments considered part text see 
proof general handle nested comments properly unable keep apart despite different meaning 
inherent problems emacs legacy 
users overly aggressive nesting alternating delimiters 
common syntax entities subsequently introduce basic syntactic entities names terms theorem specifications factored actual isar language elements described 
note basic syntactic entities introduced name act tokens plain nonterminals sort especially sake error messages 
syntax elements consts referring name type really report missing name type constituent primitive tokens ident string 
names entity name usually refers name types constants theorems declared defined qualified identifiers excluded 
quoted strings provide escape non identifier names ruled outer syntax keywords 
existing objects usually referenced nameref name ident string nat chapter 
syntax primitives name nameref name int nat nat comments large chunks plain text usually verbatim enclosed 
convenience smaller text units conforming nameref admitted 
marginal comment form text 
number may occur isabelle isar commands 
text verbatim nameref comment text type classes sorts arities classes specified plain names 
sorts simple inner syntax single class name list 
cn referring intersection classes 
syntax type arities directly outer level 
classdecl name nameref chapter 
syntax primitives sort arity nameref sort sort types terms actual inner isabelle syntax types terms logic far sophisticated order modelled explicitly outer theory level 
basically entity quoted turn single token parsing type checking performed internally 
convenience slightly liberal convention adopted quotes may omitted type term atomic outer level 
example may just write 
note symbolic identifiers available provided superseded commands keywords 
type nameref typevar term nameref var prop term positional instantiations indicated giving sequence terms placeholder underscore means skip position 
chapter 
syntax primitives inst insts term inst type declarations definitions usually refer left hand side 
models basic type constructor application outer syntax level 
note plain postfix notation available infixes 
name mixfix annotations mixfix annotations specify concrete inner syntax isabelle types terms 
commands types see admit infixes consts see syntax see support full range general binders 
infix infix nat infixl string infixr chapter 
syntax primitives mixfix infix string nat binder string nat mixfix structure nat string specifications refer actual mixfix template see may include literal text spacing blocks arguments denoted special symbol index printed represents index argument specifies implicit structure see 
infix binder declarations provide common abbreviations particular mixfix declarations 
practice mixfix templates degenerate literal text concrete syntax infix symbol infix implicit structure 
proof methods proof methods basic ones expressions composed methods sequential composition alternative choices try repeat restriction sub goals default 
practice proof methods usually just comma separated list nameref args specifications 
note parentheses may dropped single method specifications arguments 
chapter 
syntax primitives method nameref methods nat methods nameref args method proper isar proof methods admit arbitrary goal addressing refer sub goal sub goals uniformly 
goal restriction operator evaluates method expression sandbox consisting sub goals need exist 
example simp simplifies sub goals rule foo simp simplifies new goals emerge applying rule foo originally 
improper methods notably tactic offer separate low level goal addressing scheme explicit argument individual tactic involved 

refers goals goals starting nat nat nat nat attributes theorems attributes proof methods see semi inner syntax sense input conforming args parsed attribute second time 
attribute argument specifications may chapter 
syntax primitives sequence atomic entities identifiers strings properly bracketed argument lists 
atom refers atomic entity including keyword conforming 
atom nameref typevar var nat keyword arg args atom args args arg attributes nameref args theorem specifications come flavors usually refer axioms assumptions results goal statements collects lists existing theorems 
existing theorems thmrefs requires actual singleton result 
forms theorem named facts selections named facts literal fact propositions syntax see method fact 
chapter 
syntax primitives kind theorem specification may include lists attributes left right hand sides attributes applied immediately preceding fact 
names omitted theorems stored theorem database theory proof context attributes applied 
extra pair brackets attribute declarations abbreviates theorem involving internal dummy fact ignored 
effect attribute background context persist 
form place declarations particularly useful commands declare 
name attributes thmrefs nameref selection attributes name attributes name attributes attributes chapter 
syntax primitives selection nat nat nat term patterns declarations explicit propositions term fragments occur proof text casual binding schematic term variables may specified patterns form 
pn 
separate versions available terms props 
provides concl part patterns referring atomic rule 
term prop declarations local variables logical propositions represent different views principle introducing local scope 
practice may usually omit typing vars due type inference naming propositions due implicit current facts 
case isar proof elements usually admit introduce multiple items simultaneously 
vars name type chapter 
syntax primitives props prop treatment multiple declarations corresponds complementary focus vars versus props 
xn typing refers variables 
naming refers propositions collectively 
isar language elements refer vars props typically admit separate typings level iteration explicit separators see fix assume 
theory antiquotation thm antiquotation prop antiquotation term antiquotation const antiquotation abbrev antiquotation typeof antiquotation typ antiquotation thm style antiquotation term style antiquotation text antiquotation goals antiquotation subgoals antiquotation prf antiquotation full prf antiquotation ml antiquotation ml type antiquotation ml struct antiquotation text body formal comments see may contain logical entities theorems terms types final output produced isabelle document preparation system see 
embedding term show types text block cause appear chapter 
syntax primitives final atex document 
note theorem may involve attributes 
example thm sym vars print statement schematic variables replaced fixed ones easier read 
antiquotation antiquotation theory options name thm options thmrefs prop options prop term options term const options term abbrev options term typeof options term typ options type thm style options name term style options name term text options name goals options subgoals options prf options thmrefs full prf options thmrefs ml options name ml type options name ml struct options name chapter 
syntax primitives options option option name name name note syntax may include source comments 
verbatim text 
theory prints name guaranteed refer valid ancestor theory current context 
thm prints theorems note attribute specifications may included see vars operation see particularly useful suppress printing schematic variables 
prop prints typed proposition 
term prints typed term const prints logical syntactic constant abbrev prints constant abbreviation rhs defined current context 
typeof prints type typed term typ prints formed type 
thm style prints theorem previously applying style see 
term style prints typed term applying style see 
text prints uninterpreted source text particularly useful print portions text isabelle atex output style demanding formedness small pieces terms parsed type checked 
chapter 
syntax primitives goals prints current dynamic goal state 
mainly support tactic emulation scripts isar presentation goal states conform actual human readable proof documents 
please include goal states document output really know doing 
subgoals similar goals print main goal 
prf prints compact proof terms corresponding theorems note requires proof terms switched current object logic see proof terms section isabelle manual information 
full prf prf displays full proof terms displays information omitted compact proof term denoted placeholders 
ml ml type ml struct check text ml value type structure respectively 
successful source displayed verbatim 
standard styles thm style term style available lhs extracts argument application form arguments typically meta level object level equality binary relation 
rhs lhs extracts second argument 
concl extracts nested meta level implication prem 
prem extract premise number 
respectively nested meta level implication options available tune output 
note coincide ml flags names see 
show types bool show sorts bool control printing explicit type sort constraints 
show structs bool controls printing implicit structures 
chapter 
syntax primitives long names bool forces names types constants printed fully qualified internal form 
short names bool forces names types constants printed unqualified 
note internalizing output current context may yield different result 
unique names bool determines printed version qualified names sufficiently long avoid overlap names declared back 
set false concise output 
eta contract bool prints terms contracted form 
display bool indicates text output multi line display material small piece text line breaks default 
breaks bool controls line breaks non display material 
quotes bool indicates output enclosed double quotes 
mode name adds name print mode presentation see 
note standard setup atex output default including modes latex symbols 
margin nat indent nat change margin indentation pretty printing display material 
source bool prints source text antiquotation arguments actual value 
note affect formedness checks thm term 
text antiquotation admits arbitrary output 
goals limit nat determines maximum number goals printed 
locale name specifies alternative context evaluating printing subsequent argument 
boolean flags name true may abbreviated name 
flags disabled default changed ml 
note spare author tedious typing logical entities achieve degree consistency checking informal explanations formal developments formedness terms types respect current theory proof context ensured 
chapter 
syntax primitives tagged commands isabelle isar command may decorated presentation tags tags tag tag ident string tags theory proof ml pre declared certain classes commands theory theory proof proof commands ml commands involving ml code isabelle document preparation system see allows tagged command regions specifically fold proof texts drop parts text completely 
example invisible auto cause piece proof treated invisible proof default may show hidden depending document setup 
contrast visible auto force text shown invariably 
explicit tag specifications proof apply subsequent commands level nesting 
example proof visible 
qed force sub proof typeset visible parts tagged differently 
basic language elements chapter subsequently introduce main part pure theory proof commands fundamental proof methods attributes 
chapter describes isar elements provided generic tools packages simplifier part pure isabelle pre installed object logics 
chapter refers object logic specific elements mainly hol zf 
isar commands may proper document constructors improper commands 
proof methods attributes introduced classified improper 
improper isar language elements subsequently marked helpful developing proof documents discouraged final human readable outcome 
typical examples diagnostic commands print terms theorems current context commands emulate old style tactical theorem proving 
theory commands defining theories header toplevel toplevel theory toplevel theory theory toplevel isabelle isar new style theories defined theory files interactively 
theory level specifications proofs handled uniformly occasionally definitional mechanisms require explicit proof 
contrast old style isabelle theories support batch processing proof scripts collected separate ml files 
real command theory theory starts new theory merge existing ones 
just preceding theory may optional header declaration relevant document preparation acts special pre theory markup chapter 
basic language elements command cf 

command concludes theory development command theory file loaded batch mode 
uses header theory uses text name imports name name uses header text provides plain text markup just preceding formal theory 
actual document preparation corresponding atex macro may redefined produce chapter section headings 
see markup commands 
theory imports 
bn starts new theory merge existing theories 
bn 
due inclusion ancestors theory structure emerging isabelle session forms directed acyclic graph dag 
isabelle theory loader ensures sources contributing development graph date 
changed files automatically reloaded processing theory headers interactively explicitly distinguishes update thy thy see 
optional uses specification declares additional dependencies ml files 
files loaded immediately name put parentheses merely documents dependency resolved text typically explicit body text see 
old style theory system isabelle thy may accompanied additional file ml consisting ml code executed context finished theory file included files dependency declaration 
concludes current theory definition context switch 
note command undone theory definition retracted 
chapter 
basic language elements markup commands chapter local theory local theory section local theory local theory subsection local theory local theory local theory local theory text local theory local theory text raw local theory local theory apart formal comments see markup commands provide structured way insert text document generated theory see information isabelle document preparation tools 
chapter section subsection text target text raw text text chapter section subsection mark chapter section headings 
text specifies paragraphs plain text 
text raw inserts atex source output additional markup 
full range document manipulations available 
text argument markup commands text raw may contain formal entities see 
interpreted theory context specified target 
markup elements corresponds atex command name prefixed 
sectioning commands plain macro single argument 
chapter 
text markup results atex environment 
text raw causes text inserted directly atex source 
chapter 
basic language elements additional markup commands available proofs see 
note header declaration see admits insert section markup just preceding actual theory definition 
type classes sorts classes theory theory theory theory axiomatic 
theory theory class deps theory proof theory proof classes classdecl nameref nameref sort classes declares class subclass existing classes cyclic class structures ruled 
states subclass relations existing classes 
done axiomatically 
instance command see provides way introduce proven class relations 
sort new default sort type variables sort constraints 
usually default sort changed defining new object logic 
class deps visualizes subclass relation isabelle graph browser tool see 
primitive types type abbreviations types theory theory typedecl theory theory nonterminals theory theory arities theory theory axiomatic 
chapter 
basic language elements types typedecl type nonterminals arities infix name nameref arity infix types introduces type synonym existing type 
actual type definitions available isabelle hol example type synonyms just purely syntactic abbreviations logical significance 
internally type synonyms fully expanded 
typedecl declares new type constructor intended actual logical type 
note isabelle hol object logic overrides typedecl version 
nonterminals declares ary type constructors act purely syntactic types nonterminal symbols isabelle inner syntax terms types 
arities augments isabelle order sorted signature types new type constructor arities 
done axiomatically 
instance command see provides way introduce proven type arities 
primitive constants definitions definitions essentially express abbreviations logic 
simplest form definition newly declared constant 
isabelle allows derived forms arguments appear left abbreviating string abstractions may written chapter 
basic language elements conveniently definitions may weakened adding arbitrary pre conditions built formedness conditions definitional specifications arguments left hand side distinct variables 
variables right hand side appear left hand side 
type variables right hand side appear lefthand side prohibits nat length list example 
definition recursive 
object logics provide definitional principles express recursion safely 
overloading means constant declared decl may defined separately type instances decl type constructor rhs may mention overloaded constants recursively type instances corresponding immediate argument types 
incomplete specification patterns impose global constraints occurrences lhs means corresponding occurrences rhs need instance general disallowed 
consts theory theory defs theory theory theory theory consts defs name type mixfix unchecked overloaded prop chapter 
basic language elements structs structs structure vars name type mixfix name type name mixfix name prop consts declares constant instance type scheme 
optional mixfix annotations may attach concrete syntax constants declared 
defs name eqn introduces eqn definitional axiom existing constant 
unchecked option disables global dependency checks definition occasionally useful exotic overloading 
discretion user avoid malformed theory specifications 
overloaded option declares definitions potentially overloaded 
option warning message issued definitional equation special type corresponding constant declaration 
provides streamlined combination constants declarations definitions type inference takes care general typing chapter 
basic language elements specification optional type constraint may refer dummies usual 
resulting type declaration needs agree specification overloading supported 
constant name may omitted altogether type syntax declarations 
canonical name definitional axiom constant def specified 
note list specifications processed strictly sequential manner type checking performed independently 
optional initial context structure declarations admits indexed syntax special symbol index printed 
concept particularly useful locales see 
syntax translations syntax theory theory syntax theory theory translations theory theory translations theory theory syntax syntax mode translations translations chapter 
basic language elements mode name output name output nameref string syntax mode decls similar consts decls actual logical signature extension omitted 
context free grammar isabelle inner syntax may augmented arbitrary ways independently logic 
mode argument refers print mode grammar rules belong output indicator productions added input output grammar 
syntax mode decls removes grammar declarations translations resulting decls interpreted manner syntax 
translations rules specifies syntactic translation rules macros parse print rules parse rules print rules 
translation patterns may prefixed syntactic category parsing default logic 
translations rules removes syntactic translation rules interpreted manner translations 
axioms theorems axioms theory theory axiomatic 
lemmas local theory local theory theorems theory axioms prop chapter 
basic language elements lemmas theorems target thmrefs axioms introduces arbitrary statements axioms meta logic 
fact axioms axiomatic theorems may referred just theorem 
axioms usually introduced declaring new logical systems 
everyday typically done hard way proper definitions proven theorems 
lemmas retrieves stores existing facts theory context specified target context see 
typical applications involve attributes declare simplifier rules example 
theorems essentially lemmas marks result different kind facts 
name spaces global theory theory local theory theory hide theory theory hide name open nameref isabelle organizes kind name declarations types constants theorems separate hierarchically structured name spaces 
normally user control behavior name spaces hand commands provide way 
global local change current name declaration mode 
initially theories start local mode causing names automatically qualified theory name 
changing global causes names declared theory prefix local declared 
note global names prone get hidden qualified names base name introduced 
chapter 
basic language elements hide space names fully removes declarations name space may class type const open option base name hidden 
global unqualified names may hidden 
note hiding name space accesses impact logical declarations remain valid internally 
entities longer accessible user printed special qualifier prefixed full internal name 
incorporating ml code ml ml command ml setup theory theory setup theory theory method setup theory theory name ml text ml command ml setup setup text method setup name text text file reads executes ml commands file 
current theory context passed ml session may modified 
furthermore file name checked files dependency declaration theory header see 
ml text ml command text execute ml commands text 
theory context passed way may changed 
note output ml command verbose plain ml 
chapter 
basic language elements ml setup text executes ml commands text 
theory context passed ml session fetched back 
text may change theory side effect 
setup text changes current theory context applying text refers ml expression type theory theory 
setup command canonical way initialize object logic specific tools packages written ml 
text omitted setup value taken implicit context maintained context add setup 
method setup name text description defines proof method current theory 
text ml expression type args src proof context proof method 
parsing concrete method syntax args src input quite tedious general 
simple examples methods explicit arguments list theorems respectively 
method args method method fn facts foobar tac method thms args fn thms method method fn facts foobar tac method ctxt args fn ctxt method method fn facts foobar tac method thms ctxt args fn thms fn ctxt method method fn facts foobar tac note mere tactic may ignore facts parameter 
proper proof methods appropriate list current facts 
single rule methods usually strict forward chaining method multi resolves automatic ones just insert facts method insert tac applying main tactic 
syntax translation functions parse ast translation theory theory parse translation theory theory print translation theory theory typed print translation theory theory print ast translation theory theory token translation theory theory chapter 
basic language elements parse ast translation text parse translation advanced print translation typed print translation print ast translation token translation text syntax translation functions written ml admit arbitrary manipulations isabelle inner syntax 
commands single text argument refers ml expression appropriate type follows default val parse ast translation string ast list ast list val parse translation string term list term list val print translation string term list term list val typed print translation string bool typ term list term list val print ast translation string ast list ast list val token translation string string string string real list case advanced option corresponding translation functions may depend current theory proof context 
allows implement advanced syntax mechanisms translations functions may refer specific theory declarations auxiliary proof data 
see information general concept syntax transformations isabelle 
val parse ast translation string context generic ast list ast list val parse translation string context generic term list term list val print translation string context generic term list term list val typed print translation string context generic bool typ term list term list val print ast translation string context generic ast list ast list chapter 
basic language elements oracles oracle theory theory oracle interface promotes ml function theory term theory thm type user 
acts infinitary specification axioms internal check correctness results 
inference kernel records oracle invocations internal derivation object theorems pretty printer attaches indicate results fully checked isabelle inferences 
oracle name type text oracle name type text turns ml expression text type theory type term ml function name type theory type thm 
proof commands proof commands perform transitions isar vm machine configurations block structured consisting stack nodes main components logical proof context current facts open goals 
isar vm transitions typed different modes operation proof prove means new goal just stated proven command may refine proof method enter sub proof establish actual result 
proof state nested theory mode context may augmented stating additional assumptions intermediate results proof chain intermediate proof state proof prove existing facts contents special register just picked order refining goal claimed 
proof mode indicator may read verb telling writer kind operation may performed 
corresponding typings proof commands restricts shape formed proof texts particular command sequences 
dynamic arrangements commands eventually turn static texts certain structure 
appendix gives simplified grammar extensible language emerging way 
chapter 
basic language elements markup commands sect proof proof proof proof proof proof txt proof proof txt raw proof proof markup commands proof mode closely correspond ones theory mode see 
sect txt text txt raw context elements fix proof state proof state assume proof state proof state presume proof state proof state def proof state proof state logical proof context consists fixed variables assumptions 
closely correspond skolem constants meta level universal quantification provided isabelle pure logical framework 
introducing arbitrary fixed variable fix results local value may subsequent proof variable constant 
furthermore result exported context universally closed wrt 
outermost level expressed isabelle meta variables 
similarly introducing assumption effects 
hand local theorem created may fact subsequent proof steps 
hand result exported context conditional wrt 
assumption 
solving enclosing goal result basically introduce new subgoal stemming assumption 
situation handled depends actual version assumption command assume insists chapter 
basic language elements solving subgoal unification premise goal presume leaves subgoal unchanged order proved user 
local definitions introduced def achieved combining fix version assumption causes hypothetical equation eliminated reflexivity rule 
exporting result yields 
def fix vars assume props presume def def name term fix introduces local arbitrary fixed variables assume presume introduce local theorems assumption 
subsequent results applied enclosing goal show handled follows assume expects able unify existing premises goal presume leaves new subgoals 
lists assumptions may separated resulting list current facts consists concatenated 
def introduces local non polymorphic definition 
results exported context replaced basically def chapter 
basic language elements abbreviates fix assume resulting hypothetical equation solved reflexivity 
default name definitional equation def simultaneous definitions may time 
special name prems refers assumptions current context list theorems 
facts forward chaining note proof state proof state proof state proof chain proof state proof chain proof state proof chain proof prove proof prove unfolding proof prove proof prove new facts established assumption proof local statements 
fact usually involved proofs explicit arguments proof methods forward chaining goal variants composite forms involving note 
elements augments collection facts goal stated 
note special theorem name refers established facts issuing follow claim 
note thmrefs thmrefs unfolding note recalls existing facts binding result note attributes may involved left right hand sides 
chapter 
basic language elements indicates forward chaining current facts order establish goal claimed 
initial proof method invoked refine offered facts appropriate see 
example method rule see typically elimination 
automatic methods usually insert facts goal state operation 
provides simple scheme control relevance facts automated proof search 
abbreviates note equivalent 
abbreviates forward chaining earlier facts current ones 
augments facts currently indicated subsequent refinement step apply proof 
unfolding structurally similar unfolds definitional equations goal state facts 
forward chaining empty list theorems chaining 
effect apart entering prove chain mode bound empty list theorems 
basic proof methods rule expect multiple facts proper order corresponding prefix premises rule involved 
note positions may easily skipped example 
involves trivial rule prop prop happens bound isabelle pure underscore 
automated methods simp auto just insert facts usual operation 
depending kind procedure involved order facts significant 
goal statements lemma local theory proof prove theorem local theory proof prove corollary local theory proof prove proof state proof chain proof prove show proof state proof chain proof prove proof state proof prove proof state proof prove print statement theory proof theory proof chapter 
basic language elements theory context proof mode entered initial goal command lemma theorem corollary 
proof new claims may introduced locally variants available indicate forward chaining facts performed initially final result meant solve pending goal 
goals may consist multiple statements resulting list facts eventually 
pending multi goal internally represented meta level conjunction printed usually split corresponding number sub goals prior initial method application proof apply 
induct method covered acts multiple claims simultaneously 
claims theory level may short long form 
short goal merely consists simultaneous propositions just 
long goal includes explicit context specification subsequent involving local parameters assumptions 
role part statement explicitly marked separate keywords see local assumptions introduced available proof 
kinds shows states simultaneous propositions essentially big conjunction obtains claims simultaneous simultaneous contexts essentially big disjunction eliminated parameters assumptions cf 

lemma theorem target corollary show goal print statement modes goal thmrefs chapter 
basic language elements goal props shows goal obtains case vars case props lemma enters proof mode main goal eventually resulting fact put back theory context specified locale cf 

additional context specification may build initial proof context subsequent claim includes local definitions syntax see definition 
theorem corollary essentially lemma facts internally marked different kind 
discrimination acts formal comment 
claims local goal eventually resulting fact current logical context 
operation completely independent pending sub goals enclosing goal statements may freely experimental exploration potential results proof body 
show plus second stage refine pending sub goal finished result having exported chapter 
basic language elements corresponding context head sub proof show command 
accommodate interactive debugging resulting rules printed applied internally 
interactive execution show predicts potential failure displays resulting error warning 
watch message problem 
local statement fail solve pending goal abbreviates claims local goal proven forward chaining current facts 
note equivalent 
abbreviates show 
note equivalent show 
print statement prints theorems current theory proof context long statement form syntax lemma 
goal statement causes term abbreviations thesis bound automatically see 
furthermore local context non atomic goal provided rule context case 
optional case names obtains twofold meaning claim refer local context introductions resulting rule annotated accordingly support symbolic case splits cases method cf 

isabelle isar suffers theory level goal statements contain unbound schematic variables conform aim human readable proof documents 
main problem schematic goals actual outcome usually hard predict depending behavior proof methods applied course reasoning 
note semi automated methods heavily depend kinds implicit rule declarations current theory context 
result non compositional checking sub proofs local goals allowed schematic 
schematic goals prolog style interactive synthesis proven results usually stepwise refinement emulation traditional isabelle tactic scripts see 
case users know doing 
chapter 
basic language elements initial terminal proof steps proof proof prove proof state qed proof state proof state theory proof prove proof state theory proof prove proof state theory proof prove proof state theory sorry proof prove proof state theory arbitrary goal refinement tactics considered harmful 
properly isar framework admits proof methods invoked places 

initial refinement step proof reduces newly stated goal number sub goals solved 
facts passed forward chaining indicated proof chain mode 

terminal step qed intended solve remaining goals 
facts passed 
proper way affect pending goals proof body show involves explicit statement solved eventually 
avoid fundamental problem unstructured tactic scripts consist numerous consecutive goal transformations invisible effects 
general rule thumb proof style initial proof methods solve goal completely constitute understood reduction new sub goals 
arbitrary automatic proof tools prone leave large number badly structured sub goals help continuing proof document intelligible manner 
explicitly user default initial method rule applies single standard elimination rule topmost symbol involved 
separate default terminal method 
remaining goals solved assumption step 
proof qed method method chapter 
basic language elements method 
sorry method proof refines goal proof method facts forward chaining passed indicated proof chain mode 
qed refines remaining goals proof method concludes sub proof assumption 
goal show pending sub goal solved rule resulting result exported enclosing goal context 
qed may fail reasons fails resulting rule fit pending goal enclosing context 
debugging situation involve temporarily changing show weakening local context replacing occurrences assume presume 
terminal proof abbreviates proof qed backtracking methods 
debugging unsuccessful commands done expanding definition cases proof apply sufficient see problem 

default proof abbreviates rule 
trivial proof abbreviates 
sorry fake proof pretending solve pending claim ado 
works interactive development quick dirty flag enabled 
facts emerging fake proofs real thing 
internally theorem container tainted oracle invocation indicated printed result 
important application sorry support experimentation top proof development 
includes additional strong assumptions introduced assume 
chapter 
basic language elements fundamental methods attributes proof methods attributes refer basic logical operations isar 
methods attributes provided generic object logic specific tools packages see chapters 
method fact method assumption method method rule method method intro attribute elim attribute dest attribute rule attribute attribute attribute attribute fact rule thmrefs thmrefs intro elim dest nat del thmrefs chapter 
basic language elements intro elim dest nat rule del thmrefs insts concl insts name var typevar type term insert forward chaining facts premises goal 
note command proof method performs single reduction step rule method plain proof step proof proof 
fact composes previous fact implicitly current proof context modulo matching schematic type term variables 
rule structure taken account meta level implication considered atomic 
principle underlying literal facts cf 
fact equivalent note provided instance known proof context 
assumption solves goal single assumption step 
facts guaranteed participate refinement means may place 
recall qed see concludes remaining sub goals assumption structured proofs usually need quote assumption method 
chapter 
basic language elements applies current facts directly rules 
recall dot abbreviates 
rule applies rule argument backward manner facts reduce rule applying goal 
rule facts plain facts elimination 
arguments rule method tries pick appropriate rules automatically declared current context intro elim dest attributes see 
default behavior proof 
double dot steps see 
performs intuitionistic proof search depending specifically declared rules context explicit arguments 
chained facts inserted goal commencing proof search means include current prems 
rules need classified intro elim dest indicator refers safe rules may applied aggressively considering back tracking 
rules declared ignored proof search single step rule method observes 
explicit weight annotation may number rule premises taken account 
intro elim dest declare elimination destruct rules rule methods 
note ignore rules declared aggressively 
classical reasoner see introduces variants attributes qualified names access versions isabelle pure pure intro intro 
rule del elimination destruct rules 
applies theorem rules parallel 
corresponds operator ml note reversed order 
positions may effectively skipped including underscore argument 
performs positional instantiation term variables 
terms substituted schematic variables occurring theorem left right underscore indicates skip position 
arguments concl specification refer positions rule 
chapter 
basic language elements performs named instantiation schematic type term variables occurring theorem 
schematic variables specified left hand side 
question mark may omitted variable name plain identifier index 
type instantiations inferred term instantiations explicit type instantiations seldom necessary 
term abbreviations proof state proof state syntax abbreviations may bound explicit statements annotating assumptions goal statements list patterns 
pn 
cases higher order matching invoked bind extra logical term variables may named schematic variables form nameless dummies underscore 
note form patterns occur left hand side patterns postfix position 
polymorphism term bindings handled hindley milner style similar ml 
type variables referring local assumptions open goal statements fixed finished results bound may occur arbitrary instances 
actual polymorphism rarely practice mechanism essential achieve proper incremental user proceeds build isar proof text left right 
term abbreviations quite different local definitions introduced def see 
visible logic actual equations abbreviations disappear input process just type checking 
note def support polymorphism 
term term syntax patterns follows see 
binds text variables patters simultaneous higher order matching terms chapter 
basic language elements resembles matches preceding statement 
note separate command part assume 
automatic term abbreviations goals facts available 
open goal thesis refers object level statement abstracted meta level parameters 
likewise bound fact statements resulting assumptions finished goals 
case refers object logic statement application bound special text variable 
dots 
canonical application calculational proofs see 
block structure proof state proof state proof state proof state proof state proof state isar inherently block structured opening closing blocks handled casually little explicit user intervention 
local goal statement automatically opens blocks closed concluding sub proof qed 
sections different context sub proof may switched just single followed block open 
effect reset local proof context goal focus involved 
slightly advanced applications explicit block parentheses 
typically achieve stronger forward style reasoning 
switches fresh block sub proof resetting local context initial 
explicitly open close blocks 
current facts pass unchanged causes result exported enclosing context 
fixed variables generalized assumptions discharged local definitions unfolded cf 

difference assume presume mode forward reasoning contrast plain backward reasoning result exported show time 
emulating tactic scripts isar provides separate commands accommodate tactic style proof scripts system 
outside orthodox isar proof chapter 
basic language elements language come handy interactive exploration debugging actual tactical proof new style theories benefit document preparation example 
see actual tactics encapsulated proof methods 
proper proof methods may scripts 
apply apply done defer prefer back apply method apply defer prefer proof prove proof prove proof state proof state proof prove proof state proof proof proof proof proof proof nat nat apply applies proof method initial position proof retains proof prove mode 
consecutive method applications may just tactic scripts 
facts passed indicated goal forward chain mode consumed 
apply command purely backward manner 
apply applies proof method terminal position 
basically simulates multi step tactic script qed may proof body 
facts passed furthermore static context enclosing goal actual qed 
proof method may refer assumptions introduced current body example 
done completes proof script provided current goal state solved completely 
note actual structured proof commands sorry may conclude proof scripts 
chapter 
basic language elements defer prefer shuffle list pending goals defer puts goal list default prefer brings goal top 
back back tracking result sequence latest proof command 
basically proof command may return multiple results 
proper isar proof method may tactic script commands apply 
additional actual tactics provided actual structured proofs course 
meta linguistic features oops proof theory oops command current proof attempt considering partial proof text properly processed 
conceptually quite different faking actual proofs sorry see oops observe proof structure goes back right theory level 
furthermore oops produce result theorem intended claim able complete proof 
typical application oops explain isar proofs system conjunction document preparation tools isabelle described 
partial wrong proof attempts discussed logically sound manner 
note isabelle atex macros easily adapted print 
oops keyword 
oops command undo able kill see 
effect get back theory just opening proof 
commands diagnostics pr thm theory proof theory proof term theory proof theory proof prop theory proof theory proof typ theory proof theory proof prf theory proof theory proof full prf theory proof theory proof chapter 
basic language elements diagnostic commands assist interactive development 
note undo apply theory proof configuration changed 
pr thm term prop typ prf modes modes modes modes modes full prf modes nat nat thmrefs term prop type modes modes name thmrefs thmrefs pr goals prems prints current proof state including proof context current facts goals 
optional limit arguments affect number goals premises displayed initially 
omitting limit values leaves current setting unchanged 
chapter 
basic language elements thm retrieves theorems current theory proof context 
note attributes included theorem specifications applied temporary context derived current theory proof result discarded attributes involved permanent effect 
term prop read type check print terms propositions current theory proof context inferred type output 
note commands useful inspecting current environment term abbreviations 
typ reads prints types meta logic current theory proof context 
prf displays compact proof term current proof state theorems 
note requires proof terms switched current object logic see proof terms section isabelle manual information 
full prf prf displays full proof term displays information omitted compact proof term denoted placeholders 
diagnostic commands admit list modes specified appended current print mode see 
output behavior may modified particular print mode features 
example pr latex symbols print current proof state mathematical symbols special characters represented atex source isabelle style 
note cf 
provide systematic way include formal items printed text document 
chapter 
basic language elements inspecting context print commands print theory print syntax print methods print attributes print theorems find theorems thms deps print facts print binds print theory find theorems theory proof theory proof theory proof theory proof theory proof theory proof theory proof theory proof theory proof theory proof theory proof theory proof theory proof theory proof proof proof proof proof nat criterion dups criterion name nameref intro elim dest simp term term thm deps thmrefs commands print certain parts theory proof context 
note ones available set rules declared simplifications 
chapter 
basic language elements print commands prints isabelle outer theory syntax including keywords command 
print theory prints main logical content theory context option indicates extra verbosity 
print syntax prints inner syntax types terms depending current context 
output verbose including grammar tables syntax translation rules 
see information isabelle inner syntax 
print methods prints proof methods available current theory context 
print attributes prints attributes available current theory context 
print theorems prints theorems available current theory context 
interactive mode refers theorems left transaction allows inspect result advanced definitional packages datatype 
find theorems retrieves facts theory proof context matching search criteria criterion name selects theorems fully qualified name matches pattern may contain wildcards 
criteria intro elim dest select theorems match current goal elimination destruction rules respectively 
criterion simp selects rewrite rules left hand side matches term 
criterion term selects theorems contain pattern usual patterns may contain occurrences dummy schematic variables type constraints 
criteria preceded select theorems match 
note giving empty list criteria yields currently known facts 
optional limit number printed facts may default 
default duplicates removed search result 
dups display duplicates 
thm deps visualizes dependencies facts isabelle graph browser tool see 
print facts prints local facts current context named unnamed ones 
chapter 
basic language elements print binds prints term abbreviations context 
history commands undo redo kill isabelle isar top level maintains stage history theory proof state transformation 
basically command undone undo excluding mere diagnostic elements 
effect may revoked redo corresponding undo step crossed proof theory 
kill command aborts current history node altogether proof theory 
operation undo able 
history commands user interfaces proof general takes care stepping forth back 
interfering manual undo redo kill commands quickly result utter confusion 
system operations cd pwd thy update thy display drafts print drafts cd name thy update thy display drafts name print drafts cd path changes current directory isabelle process 
chapter 
basic language elements pwd prints current working directory 
thy update thy preload theory name argument 
system commands scarcely working interactively loading theories done transparently 
display drafts paths print drafts paths perform simple output list raw source files 
symbols require additional atex packages displayed properly left verbatim 
generic tools packages specification commands derived specifications chapter axiomatization local theory local theory axiomatic 
definition local theory local theory defn attribute abbreviation local theory local theory print theory proof theory proof notation local theory local theory notation local theory local theory specification mechanisms provide slightly view underlying primitives consts defs see axioms see 
particular type inference commonly available result names need 
axiomatization definition abbreviation target target target notation notation target fixes specs decl mode mode prop prop decl nameref chapter 
generic tools packages fixes name type mixfix vars specs decl name props type mixfix axiomatization 
cn 
am introduces constants simultaneously states axiomatic properties 
constants marked specified prevents additional specifications issued 
note axiomatic specifications appropriate declaring new logical system 
normal applications definitional mechanisms 
definition eq produces internal definition specification eq turned proven fact 
proposition may deviate internal meta level equality rewrite rules declared defn object logic 
typically covers object level equality equivalence users normally need change defn setup 
definitions may explicit arguments lhs additional conditions unguarded abbreviation eq introduces syntactic constant associated certain term meta level equality eq 
chapter 
generic tools packages abbreviations participate usual type inference process expanded logic sees 
pretty printing terms involves higher order rewriting rules stemming reverted abbreviations 
needs care avoid overlapping looping syntactic replacements 
optional mode specification restricts output particular print mode input achieves effect way abbreviations 
mode may include output qualifier affects concrete syntax declared abbreviations cf 
syntax 
print prints constant abbreviations current context 
notation mx associates mixfix syntax existing constant fixed variable 
robust interface underlying syntax primitive 
type declaration internal syntactic representation entity retrieved context 
notation similar notation removes specified syntax annotation context 
specifications support local theory targets cf 

generic declarations arbitrary operations background context may wrapped generic declaration elements 
underlying concept local theories may subject re interpretation additional dependency morphism tells difference original declaration context wrt 
application context encountered 
fact declaration important special case consists theorem applied context means attribute 
declaration local theory local theory declare local theory local theory declaration declare target target text thmrefs chapter 
generic tools packages declaration adds declaration function ml type declaration current local theory construction 
application contexts function transformed morphisms involved interpretation hierarchy 
declare thms declares theorems current local theory context 
theorem binding involved theorems lemmas cf 
declare effect applying attributes included theorem specification 
local theory targets local theory target context managed separately enclosing theory 
contexts may introduce parameters fixed variables assumptions hypotheses 
definitions theorems depending context may added incrementally 
named contexts refer locales cf 
type classes cf 
name signifies global theory context 
target context theory local theory local theory theory context name name context existing locale class context note locale class definitions allow include keyword order continue local theory immediately initial specification 
concludes current local theory continues enclosing global theory 
note non local different meaning concludes theory 
loc local theory command specifies immediate target definition loc theorem loc 
works local global theory context current target context suspended command 
note produce global result independently current target context 
chapter 
generic tools packages exact meaning results produced local theory context depends underlying target infrastructure locale type class 
general idea follows considering context named parameter assumption 
definitions exported introducing global version additional arguments syntactic abbreviation links long form version target context 
example theory level arbitrary local abbreviation target context fixed 
theorems exported discharging assumptions generalizing parameters context 
example arbitrary 
locales locales named local contexts consisting list declaration elements modeled isar proof context commands cf 

locale specifications locale theory local theory print locale theory proof theory proof print locales theory proof theory proof intro locales method unfold locales method locale name open print locale chapter 
generic tools packages nameref name fixes constrains assumes defines notes includes mixfix chapter 
generic tools packages fixes fixes name type vars constrains constrains name type assumes assumes props defines defines notes notes includes includes prop thmrefs locale loc import body defines new locale loc context consisting certain view existing locales import plus additional elements body 
import body optional degenerate chapter 
generic tools packages form locale loc defines empty locale may useful collect declarations facts 
type inference locale expressions automatically takes care general typing combined context elements may acquire 
import consists structured context expression consisting existing locales renamed contexts merged contexts 
renaming uses positional notation means prefix fixed parameters context named underscore means skip position 
renaming default deletes existing syntax 
optionally new syntax may specified mixfix annotation 
note special syntax declared structure see deleted changed 
merging proceeds left right suppressing duplicates stemming different paths import hierarchy 
body consists basic context elements context expressions may included 
fixes mx declares local parameter type mixfix annotation mx optional 
special syntax declaration structure means may referenced implicitly context 
constrains introduces type constraint local parameter assumes introduces local premises similar assume proof cf 

defines defines previously declared parameter 
close def proof cf 
defines takes equational proposition variable term pair 
left hand side equation may additional arguments defines 
notes facts local context 
notably may include arbitrary declarations attribute specifications included local simp rule 
includes copies specified context statically scoped manner 
available long goal format 
contrast initial import specification locale expression maintains dynamic relation locales referenced benefiting fact declarations obvious manner 
chapter 
generic tools packages note patterns syntax assumes defines illegal locale definitions 
long goal format term bindings may included expected 
default locale specifications closed turning text predicate definition loc axioms deriving original assumptions local lemmas modulo local definitions 
predicate statement covers newly specified assumptions omitting content included locale expressions 
full cumulative view provided export involving predicate loc refers complete specification text 
case predicate arguments locale parameters occur respective piece text 
note predicates operate meta level theory locale packages attempts internalize statements object logic setup replacing hol see 
separate rules loc axioms intro loc intro declared 
open option locale specification prevents current loc axioms cumulative loc predicate constructions 
predicates omitted empty specification texts 
print locale import body prints specified locale expression flattened form 
notable special case print locale loc just prints contents named locale keep mind type inference normalize type variables usual alphabetical order 
command omits notes elements default 
print locale 
get included 
print locales prints names locales current theory 
intro locales unfold locales repeatedly expand rules locale predicates theory 
intro locales applies loc intro rules assumptions unfold locales aggressive applies loc axioms intro 
methods aware locale specifications entailed context target includes statements interpretations see 
new goals entailed current context discharged automatically 
chapter 
generic tools packages interpretation locales locale expressions precisely context expressions may instantiated instantiated facts added current context 
requires proof instantiated specification called locale interpretation 
interpretation possible theories locales command interpretation proof contexts interpret 
interpretation theory proof prove interpret proof state proof chain proof prove print theory proof theory proof interpretation interpret print instantiation inst interp interp name name chapter 
generic tools packages interp instantiation name instantiation prop interpretation expr insts eqns form interpretation interprets expr theory 
instantiation list terms insts positional 
parameters receive instantiation term exception defined parameters 
omitted derived defining equation instantiations 
omit instantiation term 
free variables automatically generalized 
command generates proof obligations instantiated specifications assumes defines elements 
discharged user instantiated facts added theory post processing phase 
additional equations unfolded facts postprocessing may keyword 
useful interpreting concepts introduced definition specification elements 
equations proved 
note equations context expression restricted locale name 
command aware interpretations active theory 
proof obligations generated post processing applied facts 
avoids duplication interpreted facts particular 
note case locale import parts interpretation may active 
command generate proof obligations process facts new parts 
context expression may preceded name attributes 
take effect post processing facts 
name prefix fact names example avoid accidental hiding facts 
attributes applied attributes interpreted facts 
chapter 
generic tools packages adding facts locales effect adding interpreted facts theory active interpretations 
interpretations dynamically participate facts added locales 
interpretation name expr form command interprets expr locale name 
requires proof specification name implies specification expr 
localized version theorem command proof context name 
proof obligation facts expr part locale name derived context elements available context name subsequently entered 
note import dynamic facts added locale part expr interpretation available name 
facts renamed context elements facts obtained interpretation may accessed prefixing parameter renaming parameters separated 
interpretation theories instantiation confined renaming parameters may specified part context expression expr 
defined parameters name may achieve effect similar instantiation 
specification fragments expr part name imported derived derived fragment import considered interpretation 
enables circular interpretations 
interpretations name exist current theory command adds interpretations expr prefix attributes fragments expr interpreted theory 
interpret expr insts eqns interprets expr proof context similar interpretation theories 
free variables instantiations generalized 
print loc prints interpretations particular locale loc active current context theory proof context 
exclamation point argument triggers printing witness theorems justifying interpretations 
normally omitted output 
attributes applied interpreted theorems interpretation may modify context common proof tools simplifier classical reasoner 
behavior automated reasoning tools stable interpretation morphisms manual declarations issued 
chapter 
generic tools packages interpretation theory may subsume previous interpretations 
happens specification fragment interpreted twice instantiation second interpretation general interpretation 
warning issued generalized place 
locale package attempt remove subsumed interpretations 
type classes type class special case locale additional infrastructure notably link type inference 
type classes consist locale exactly type variable corresponding 
gives substantial type classes 
class theory local theory subclass local theory local theory instance theory proof prove print classes theory proof theory proof class subclass instance name print classes target nameref nameref arity prop chapter 
generic tools packages nameref nameref class superclasses body defines new class inheriting superclasses 
simultaneously locale named introduced inheriting locales corresponding superclasses named inheriting corresponding superclasses 
fixes body lifted theory toplevel constraining free type variable sort stripping local syntax 
assumes body lifted constraining free type variable sort instance sets goal stating type arities 
proof usually proceed intro classes establish characteristic theorems type classes involved 
defs correspond class parameters involved arities introduced theory proof 
finishing proof theory augmented type signature declaration corresponding resulting theorems 
instance command extension primitive instance see 
subclass class context class sets goal stating class logically contained class finishing proof class proven subclass locale interpreted simultaneously 
print classes prints classes current theory 
axiomatic type classes theory theory instance theory proof prove intro classes method axiomatic type classes provided isabelle pure definitional interface type classes cf 

object logic may light weight mechanism theories 
tutorial axiomatic type classes isabelle part standard isabelle documentation 
classdecl prop chapter 
generic tools packages instance nameref nameref nameref arity defines axiomatic type class intersection existing classes additional axioms holding 
class axioms may contain type variable 
class axioms implicit sort constraints added bound names 
furthermore class rule generated bound class intro rule employed method intro classes support instantiation proofs class 
axioms stored theorems name specifications adding class name name space prefix facts stored collectively class axioms 
instance instance setup goal stating class relation type arity 
proof usually proceed intro classes establish characteristic theorems type classes involved 
finishing proof theory augmented type signature declaration corresponding resulting theorem 
intro classes repeatedly expands class rules theory 
note method usually needs named explicitly included default proof step proof 
particular instantiation trivial syntactic classes may performed single 
proof step 
configuration options isabelle pure maintains record named configuration options theory proof context values type bool int string 
tools may declare options ml refer values relative context 
global variables easily avoided 
user may change value configuration option means associated attribute name 
form context declaration works particularly commands declare 
historical reasons tools take full proof context account merely refer background theory 
accommodated chapter 
generic tools packages configuration options declared global may changed local context 
print theory proof theory proof name true false int name print prints available configuration options names types current values 
name value attribute expression modifies named option syntax value depending option type 
bool default value true 
attempt change global option local context ignored 
derived proof schemes generalized elimination obtain proof state proof prove guess proof state proof prove generalized elimination means additional elements certain properties may introduced current context virtue locally proven soundness statement 
technically speaking obtain language element declaration fix assume see see soundness proof additional claim 
nature existential reasoning assumptions get eliminated result exported context provided corresponding parameters occur 
obtain vars props chapter 
generic tools packages guess vars obtain defined derived isar command follows shall refer optional facts indicated forward chaining 
facts obtain proof thesis 
thesis thesis proof succeed fix thesis assume intro thesis thesis apply proof qed fix assume typically soundness proof relatively straight forward just canonical automated tools simp blast 
accordingly reduction declared simplification rule 
sense obtain represents level isar proofs meta logical existential quantifiers conjunctions 
concept broad range useful applications ranging plain elimination object level existential conjunctions elimination results symbolic evaluation recursive definitions example 
note obtain parameters acts result treated genuine assumption 
alternative name may parentheses 
improper variant guess similar obtain derives obtained statement course reasoning 
proof starts fixed goal thesis 
subsequent proof may refine form thesis introduce new subgoals 
final goal state reduction rule obtain scheme described 
obtained parameters marked internal default prevents proof context polluted ad hoc variables 
variable names type constraints arguments guess specify prefix obtained parameters explicitly text 
chapter 
generic tools packages important note facts introduced obtain guess may polymorphic type variables occurring fixed context 
calculational reasoning proof state proof state proof state proof chain proof state proof state ultimately proof state proof chain print trans rules theory proof theory proof trans attribute sym attribute symmetric attribute calculational proof forward reasoning implicit application transitivity rules 
isabelle isar maintains auxiliary register calculation accumulating results obtained transitivity composed current result 
command updates calculation involving exhibits final calculation forward chaining goal statement 
commands require valid current facts may occur commands produce theorems assume note finished proof show ultimately commands similar collect results calculation applying rules 
note implicit term abbreviation 
canonical application calculational proofs 
refers argument preceding statement 
argument curried infix expression happens right hand side 
isabelle isar calculations implicitly subject block structure sense new threads calculational reasoning commenced new block opened local goal example 
means apart able nest calculations separate calculation command required 
chapter 
generic tools packages isar calculation proof commands may defined follows note calculation note calculation trans calculation calculation note calculation calculation ultimately calculation thmrefs trans add del maintains auxiliary calculation register follows 
occurrence calculational thread initializes calculation 
subsequent level block structure updates calculation transitivity rule applied calculation order 
transitivity rules picked current context alternative rules explicit arguments 
maintaining calculation way concludes current calculational thread 
final result exhibited fact forward chaining goal 
basically just abbreviates calculation 
note show thesis typical idioms concluding calculational proofs 
ultimately analogous collect results applying rules 
print trans rules prints list transitivity rules calculational commands symmetry rules symmetric operation single step elimination patters current context 
trans declares theorems transitivity rules 
suppress internal bookkeeping proper handling block structure 
chapter 
generic tools packages sym declares symmetry rules 
symmetric resolves theorem rule declared sym current context 
example assume symmetric produces swapped fact derived assumption 
structured proof texts appropriate explicit single step elimination proof assume 
rules known symmetric declared elim 

proof tools miscellaneous methods attributes unfold method fold method insert method method method method succeed method fail method fold thmrefs unfold insert nat thmrefs unfold fold expand fold back definitions goals chained facts provided inserted goal subject rewriting 
insert inserts theorems facts goals proof state 
note current facts indicated forward chaining ignored 
chapter 
generic tools packages similar basic rule method see apply rules elim resolution destruct resolution forward resolution respectively 
optional natural number argument default specifies additional assumption steps performed 
note methods improper ones mainly serving experimentation tactic script emulation 
different modes basic rule application usually expressed isar proof language level implicit proof state manipulations 
example proper single step elimination done plain rule method forward chaining current facts 
succeed yields single unchanged result identity method combinator cf 

fail yields empty result sequence identity method combinator cf 

tagged attribute untagged attribute attribute comp attribute unfolded attribute folded attribute rotated attribute elim format attribute standard attribute vars attribute tagged untagged nameref name comp nat unfolded thmrefs folded chapter 
generic tools packages rotated int tagged name arg untagged name add remove tags theorem 
tags may list strings serve comment tools lemma causes tag lemma added result 
string considered tag name second argument 
note untagged removes tags name 
comp compose rules resolution 
resolves premise alternative position may specified comp version skips automatic lifting process normally intended cf 
rs comp 
unfolded folded expand fold back definitions rule 
rotated rotate premises theorem default 
elim format turns destruction rule elimination rule format resolving rule prop prop prop prop note classical reasoner provides version operation 
standard puts theorem standard form object rules outermost theory level 
note operation violates local proof context including active locales 
vars replaces schematic variables free ones mainly tuning output pretty printed theorems 
tactic improper proof methods emulate traditional tactics 
admit direct access goal state normally considered harmful 
particular may involve numbered goal addressing default dynamic instantiation scope subgoal 
dynamic instantiations refer universally quantified parameters subgoal dynamic context fixed variables term abbreviations static isar context 
chapter 
generic tools packages tactic emulation methods ml counterparts admit simultaneous instantiation dynamic static contexts 
names occur contexts goal parameters hide locally fixed variables 
likewise schematic variables refer term abbreviations static context 
schematic variable interpreted schematic variable left solved unification certain parts subgoal 
note tactic emulation proof methods isabelle isar consistently named foo tac 
note variable names occurring left hand sides instantiations preceded question mark coincide keyword contain dots 
consistent attribute see 
rule tac method tac method tac method tac method cut tac method thin tac method subgoal tac method rename tac method rotate tac method tactic method rule tac tac tac tac cut tac thin tac subgoal tac rename tac insts thmrefs prop name chapter 
generic tools packages rotate tac tactic text int insts name term rule tac resolution rules explicit instantiation 
works way ml tactics res inst tac 
see 
multiple rules may instantiation rule tac resolve tac ml see 
cut tac inserts facts proof state assumption subgoal see cut facts tac 
note scope schematic variables spread main goal statement 
instantiations may see ml tactic cut inst tac 
thin tac deletes specified assumption subgoal note may contain schematic variables 
see thin tac 
subgoal tac adds assumption subgoal 
see subgoal tac subgoals tac 
rename tac renames parameters goal list refers suffix variables 
rotate tac rotates assumptions goal positions right left positive left right negative default value 
see rotate tac 
tactic text produces proof method ml text type tactic 
apart usual ml environment current implicit theory context ml code may refer locally bound values val ctxt proof context val facts thm list val thm string thm val thms string thm list chapter 
generic tools packages ctxt refers current proof context facts indicates current facts forward chaining thm thms retrieve named facts including global theorems context 
simplifier simplification methods opt simp method simp method simp simp opt asm asm simp asm asm lr depth limit nat add del cong add del split add del thmrefs chapter 
generic tools packages simp invokes isabelle simplifier declaring additional rules arguments 
note modifier removes rewrite rules congruences tactics including splits behaves add 
cong modifiers add delete simplifier congruence rules see default add 
split modifiers add delete rules splitter see default add 
works simplifier method properly setup include splitter major object logics hol holcf fol zf 
simp similar simp acts goals backwards 
default simplifier methods take local assumptions fully account equational assumptions subsequent normalization process simplifying assumptions cf 
asm full simp tac 
structured proofs usually quite behaved practice just local premises actual goal involved additional facts may inserted explicit forward chaining 
full context assumptions included bang argument care 
additional simplifier options may specified tune behavior unstructured scripts accidental local facts asm means assumptions ignored completely cf 
simp tac asm simp means assumptions simplification simplified cf 
asm simp tac asm means assumptions simplified simplification cf 
full simp tac 
compatibility reasons option asm lr means assumption simplifying assumptions right cf 
asm lr simp tac 
giving option depth limit limits number recursive invocations simplifier conditional rewriting 
splitter package usually configured part simplifier 
effect repeatedly applying split tac simulated simp split 
separate split method available single step case splitting 
chapter 
generic tools packages declaring rules print simpset theory proof theory proof simp attribute cong attribute split attribute simp cong add split del print simpset prints collection rules declared simplifier known simpset internally 
diagnostic command undo apply 
simp declares simplification rules 
cong declares congruence rules 
split declares case split rules 
simplification procedures setup local theory local theory attribute setup identifier name term text nameref add del name chapter 
generic tools packages setup defines named simplification procedure invoked simplifier term patterns match current redex 
implementation provided ml source text needs type morphism simpset cterm thm option cterm represents current redex result supposed proven rewrite rule generalized version indicate failure 
simpset argument holds full context current simplifier invocation including actual isar proof context 
morphism informs difference original compilation context wrt 
actual application 
optional identifier specifies theorems represent logical content theory 
morphisms identifiers relevant defined local target context locale 
add name del name add delete named current simplifier context 
default add 
note setup adds new subsequent context 
forward simplification opt simplified attribute simplified opt thmrefs simplified causes theorem simplified exactly specified rules implicit simplifier context arguments 
result fully simplified default including assumptions options asm tune simplifier way simp method 
chapter 
generic tools packages note forward simplification restricts simplifier basic operation term rewriting solver tactics involved 
simplified attribute rarely required normal circumstances 
low level equational reasoning subst method method split method subst split asm nat asm thmrefs methods provide low level facilities equational reasoning intended specialized applications 
normally single step calculations performed structured text see simplifier methods provide canonical way automated normalization see 
subst eq performs single substitution step rule eq may meta object equality 
subst asm eq substitutes assumption 
subst 
eq performs substitutions 
numbers indicate positions substitute 
positions ordered top term tree moving left right 
example positions commutativity applicable refers term positions list 
non overlapping 
may assume substitutions performed simultaneously 
behaviour subst specified 
chapter 
generic tools packages subst asm 
eq performs substitutions assumptions 
positions 
refer assumption positions 
assumption 
performs substitution assumption works equations form free bound variable 
split performs single step case splitting rules thms 
default splitting performed goal asm option indicates operate assumptions 
note simp method involves repeated application split rules declared current context 
classical reasoner basic methods rule method contradiction method intro method elim method rule intro elim thmrefs rule offered classical reasoner refinement primitive see 
versions essentially classical version observes classical rule context addition isabelle pure 
common object logics hol zf declare rich collection classical rules qualify intuitionistic ones declarations rule context isabelle pure 
contradiction solves goal contradiction deriving result chained facts guaranteed participate may appear order 
intro elim repeatedly refine goal intro elim resolution having inserted chained facts 
exactly rules arguments chapter 
generic tools packages taken account allows fine tuned decomposition proof problem contrast common automated tools 
automated methods blast method fast method slow method best method safe method clarify method blast nat fast slow best safe clarify intro elim dest del thmrefs blast refers classical tableau prover see blast tac 
optional argument specifies user supplied search bound default 
fast slow best safe clarify refer generic classical reasoner 
see fast tac slow tac best tac safe tac clarify tac information 
chapter 
generic tools packages methods support additional modifiers context classical rules 
semantics analogous attributes 
facts provided forward chaining inserted goal commencing proof search 
argument causes full context assumptions included 
combined automated methods auto method force method method method method method auto nat nat force chapter 
generic tools packages simp add del cong split add del iff add del intro elim dest del thmrefs auto force provide access isabelle combined simplification classical reasoning tactics 
correspond auto tac force tac tac classical reasoner tactics simplifier added wrapper see information 
modifier arguments correspond 
just note ones related simplifier prefixed simp 
facts provided forward chaining inserted goal doing search 
argument causes full context assumptions included 
chapter 
generic tools packages declaring rules print claset theory proof theory proof intro attribute elim attribute dest attribute rule attribute iff attribute intro elim dest nat rule iff del add del print claset prints collection rules declared classical reasoner known claset internally 
diagnostic command undo apply 
intro elim dest declare elimination destruction rules respectively 
default rules considered unsafe applied blindly backtracking single classifies safe 
rule declarations marked coincide isabelle pure cf 
applied single steps rule method 
optional natural number specifies explicit weight argument ignored automated tools determines search order single rule steps 
rule del deletes elimination destruction rules context 
iff declares logical equivalences simplifier classical reasoner time 
non conditional rules result safe elimination pair conditional ones considered unsafe 
rules chapter 
generic tools packages negative automatically inverted elimination internally 
version iff declares rules isabelle pure context omits simplifier declaration 
classical operations swapped attribute swapped turns rule elimination resolving classical swap principle 
proof cases induction rule contexts case proof state proof state print cases proof proof case names attribute case attribute params attribute consumes attribute way build isar proof contexts explicit language elements fix assume see 
adequate plain natural deduction easily unwieldy concrete verification tasks typically involve big induction rules cases 
case command provides shorthand refer local context symbolically certain proof methods provide environment named cases form effect case equivalent fix assume 
term bindings may covered notably case main 
default terminology case value marked hidden way refer parameters subsequent proof text 
original rule parameters stem outside current proof text 
explicit form case proof author able chose local names fit nicely current context 
important note proper case provide means peek current goal state directly observable isar 
goal refinement commands provide named cases goali subgoal 
resulting goal state 
feature requires chapter 
generic tools packages great care bits internal tactical machinery intrude proof text 
particular parameter names stemming left automated reasoning tools usually quite unpredictable 
normal circumstances text cases emerge standard elimination induction rules turn derived previous theory specifications canonical way say inductive definitions 
proper cases available proof method rules involved support 
appropriate attributes case names parameters may declared hand 
variant versions rules derived manually ready advanced case analysis 
case nameref case names name attributes name case params name name name chapter 
generic tools packages consumes nat case invokes named local context provided appropriate proof method cases induct 
command case abbreviates fix assume 
print cases prints local contexts current state isar proof language notation 
diagnostic command undo apply 
case names declares names local contexts premises theorem refers suffix list premises 
case declares names named premise refers prefix arguments logical formula built nesting binary connective 
note proof methods induct provide default name 
need name subformulas arises cases split sub cases common induction rules 
params 
renames innermost parameters premises 
theorem 
empty list names may skip positions leaving parameters unchanged 
note default usage case rules directly expose parameters proof context 
consumes declares number major premises rule number facts consumed applied appropriate proof method 
default value consumes appropriate usual kind cases induction rules inductive sets cf 

rules consumes declaration treated consumes specified 
note explicit consumes declarations rarely needed taken care automatically higher level cases induct declarations 
proof methods cases method induct method method chapter 
generic tools packages cases induct methods provide uniform interface common proof techniques datatypes inductive predicates sets recursive functions corresponding rules may specified instantiated casual manner 
furthermore methods provide named local contexts may invoked case proof command subsequent proof text 
accommodates compact proof texts reasoning large specifications 
induct method provides additional infrastructure order applicable structure statements explicit meta level connectives including facts parameters separately 
avoids cumbersome encoding strengthened inductive statements 
cases induct insts arbitrary rule insts rule rule chapter 
generic tools packages rule type pred set nameref rule name term inst arbitrary arbitrary term insts cases insts applies method rule appropriate case distinction theorem instantiated subjects insts 
symbolic case names bound rule local contexts 
rule determined follows facts arguments chapter 
generic tools packages passed cases method facts arguments rule cases classical case split cases datatype exhaustion type cases 
inductive predicate set elimination 
cases 
explicit rule instantiations may referring suffix premises case rule premise prefix variables instantiated 
situations single term needs specified refers variable premise usually cases 
induct insts analogous cases method refers induction rules determined follows facts arguments rule induct 
datatype induction type induct 
predicate set induction 
induct 
explicit rule instantiations may referring part mutual inductive definition datatype related partial induction rules may 
lists terms 
refers suffix variables induction rule 
enables writer specify induction variables predicates variables example 
instantiations may definitional equations introduce local definitions inserted claim discharged applying induction rule 
equalities reappear inductive cases transformed induction principle involved 
order achieve practically useful induction hypotheses variables occurring need fixed see 
optional arbitrary specification generalizes variables original goal applying induction 
induction hypotheses may sufficiently general get proof 
definitional instantiations may effectively perform induction expressions certain structure 
optional specification provides additional instantiations prefix pending variables rule 
schematic induction rules rarely occur practice 
chapter 
generic tools packages inst analogous induct method refers coinduction rules determined follows goal arguments rule 
type coinduction type 
predicate set coinduction 

explicit rule coinduction dual induction 
induction essentially eliminates generic result coinduction introduces starting suitable bisimulation cases rule typically named predicates sets covered consist alternatives named individual destructor patterns 
instantiation refers suffix variables occurring rule major premise unavailable 
additional specification may required order specify bisimulation coinduction step 
methods produce named local contexts determined instantiated rule text 
induct methods guess instantiations goal specification 
persisting unresolved schematic variables resulting rule render corresponding case invalid 
term binding case provided case provided term fully specified 
print cases command prints named cases current proof state 
despite additional infrastructure cases merely apply certain rule instantiation conforming due usual way monotonic natural deduction context structured statement 
reappears unchanged case split 
induct method significantly different respect meta level structure passed recursive course involved induction 
original statement basically replaced separate copies corresponding induction hypotheses original goal context longer available 
local assumptions fixed parameters definitions effectively participate inductive rephrasing original statement 
induction proofs local assumptions introduced cases split different kinds hyps stemming rule prems goal chapter 
generic tools packages statement 
reflected extracted cases accordingly invoking case provide separate facts hyps prems fact hold inclusive list 
facts method consumed number major premises rule involved usually plain cases induction rules datatypes rules inductive predicates sets 
remaining facts inserted goal verbatim actual cases induct rule applied 
declaring rules spec print induct rules theory proof theory proof cases attribute induct attribute attribute cases induct spec spec spec type pred set nameref print induct rules prints cases induct rules predicates sets types current context 
cases induct attributes augment corresponding context rules reasoning inductive predicates sets types corresponding methods name 
certain definitional packages object logics usually declare emerging cases induction rules expected users rarely need intervene 
manual rule declarations usually refer case names params attributes adjust names cases parameters rule chapter 
generic tools packages consumes declaration taken care automatically consumes specified type rules consumes predicate set rules 
chapter object logic specific elements general logic setup judgment theory theory method attribute rule format attribute attribute starting point isabelle object logic truth judgment links object level statements meta logic minimal language prop covers universal quantification implication 
common object logics sufficiently expressive internalize rule statements language 
useful certain situations rule needs viewed atomic statement meta level perspective versus 
language elements method rule format attribute occasionally required users rest need setup object logic 
case existing formulations isabelle fol isabelle hol may taken realistic examples 
generic tools may refer information provided object logic declarations internally 
judgment rule format full chapter 
object logic specific elements judgment mx declares constant truth judgment current object logic 
type specify coercion category object level propositions prop pure meta logic mixfix annotation mx typically just link object language internally syntactic category logic prop 
judgment declaration may theory development 
method rewrites non atomic premises sub goal meta level equations declared attribute 
result heavily nested goals amenable fundamental operations resolution cf 
rule method proof assumption cf 
assumption 
giving full option means turn subgoal object statement possible including outermost parameters assumptions 
typical collection rules particular object logic provide internalization connectives 
meta level conjunction expressed manner minimal higherorder logic prop 
prop prop covered particularly important locales see 
rule format rewrites theorem equalities declared rules current object logic 
default result fully normalized including assumptions depth 
asm option restricts transformation rule 
common object logics hol fol zf effect rule format replace bounded universal quantification implication corresponding rule statements 
hol primitive types typedecl theory theory typedef theory proof prove typedecl infix chapter 
object logic specific elements typedef abstype name open open name abstype term infix morphisms name name typedecl similar original typedecl isabelle pure see declares type arity type 
type type making actual hol type constructor 
typedef sets goal stating non emptiness set finishing proof theory augmented gordon type definition establishes bijection representing set new type technically typedef defines type set term constant name alternative base name may parentheses 
injection type set called rep inverse abs may changed explicit morphisms declaration 
theorems rep rep inverse abs inverse provide basic characterization corresponding injection surjection pair directions 
rules rep inject abs inject provide slightly convenient view injectivity part suitable automated proof tools simp iff declarations 
rules rep cases rep induct abs cases abs induct provide alternative views surjectivity declared set type rules generic cases induct methods 
chapter 
object logic specific elements alternative name may specified parentheses default indicated 
open declaration suppresses separate constant definition representing set 
note raw type declarations rarely practice main application experimental axiomatic 
theory fragments 
primitive hol type definitions user level theories usually refer higher level packages record see datatype see 
adhoc tuples split format attribute split format name complete split format 
puts expressions low level tuple types canonical form specified arguments refers occurrences premise rule 
complete option causes arguments function applications represented canonically tuple type structure 
note operations tend invent funny names new local parameters introduced 
records principle records merely generalize concept tuples components may addressed labels just position 
logical infrastructure records isabelle hol slightly advanced supporting truly extensible record schemes 
admits operations polymorphic respect record extension yielding object oriented effects single inheritance 
see details object oriented verification record subtyping hol 
chapter 
object logic specific elements basic concepts isabelle hol supports fixed schematic records level terms types 
notation follows record terms record types fixed schematic 

ascii representation 
fixed record field value field value corresponding type assuming record scheme 
contains fields possibly fields indicated 
notation part syntax 
improper field 
record scheme called part 
logically just free variable occasionally referred row variable literature 
part record scheme may instantiated zero components 
example previous scheme may get instantiated 
refers different part 
fixed records special instances record schemes 
properly terminated unit element 
just abbreviation 
key observations extensible records simply typed language hol feasible 
part internalized free term type variable 
field names externalized accessed logic class values 
isabelle hol record types defined explicitly fixing field names types optional parent record 
records may formed syntax obeying canonical order fields declaration 
record package provides standard operations selectors updates 
common setup various generic proof tools enable succinct reasoning patterns 
see isabelle hol tutorial instructions records practice 
chapter 
object logic specific elements record specifications record theory theory record type record defines extensible record type derived optional parent record adding new field components 
type variables need covered distinct parameters 
type constructor new needs specify instance existing record type 
new field specified 
basically field names need belong unique record 
real restriction practice fields qualified record name internally 
parent record specification optional omitted root record 
hierarchy records declared theory context forms forest structure set trees starting root record 
way merge multiple parent records 
convenience type abbreviation fixed record type likewise scheme abbreviation 

record operations record definition form produces certain standard operations 
selectors updates provided field including improper 
cumulative record constructor functions 
simplify presentation assume root record fields 
selectors updates available field including ci 
ci update 

special syntax application updates abbreviates term update notation repeated updates available may written 
note postfix notation order fields shown reverse chapter 
object logic specific elements actual term 
repeated updates just function applications fields may freely permuted far logical equality concerned 
commutativity independent updates proven logic fields general theorem 
operation provides cumulative record constructor function reconsider case non root records derived parent 
general may depend parent resulting list ancestor records 
appending lists fields ancestors results certain field prefix 
record package automatically takes care lifting operations context ancestor fields 
assuming ancestor fields record operations get types ci 
ci update 

operations address extension aspect derived record scheme specifically fields produces record fragment consisting exactly new fields introduced result may serve part extend takes fixed record adds part truncate restricts record scheme fixed record 
fields extend 
truncate 
note fields coincide root records 
derived rules proof tools record package proves results internally declaring facts appropriate proof tools 
enables users reason record structures quite conveniently 
assume record type specified 

standard conversions selectors updates applied record constructor terms part default simplifier context proofs reduction basic operations merely require simp method arguments 
rules available 
chapter 
object logic specific elements 
selectors applied updated records automatically reduced internal simplification procedure part standard simplifier setup 

inject equations form analogous declared simplifier classical reasoner iff rules 
rules available 

rule record equality analogous 
declared simplifier basic rule context intro 
rule called equality 

representations arbitrary record expressions canonical constructor terms provided cases induct format cf 
generic proof methods name 
variations available fixed records record schemes parts generic proof methods sufficiently smart pick sensible rule type indicated record expression users just need apply cases certain proof problem 

derived record operations fields extend truncate treated automatically usually need expanded hand collective fact defs 
datatypes datatype theory theory rep datatype theory theory datatype rep datatype name infix cons chapter 
object logic specific elements cons name type mixfix distinct thmrefs inject thmrefs induction datatype defines inductive datatypes hol 
thmrefs rep datatype represents existing types inductive ones generating standard infrastructure derived concepts primitive recursion 
induction exhaustion theorems generated provide case names constructors involved parameters named types see 
see details datatypes beware old style theory syntax 
apart proper proof methods induction ml tactics case tac induct tac available see admit refer directly internal structure subgoals including internally bound parameters 
recursive functions equation primrec theory theory fun theory theory function theory proof prove termination theory proof prove primrec prop equation fun function function opts fixes clauses chapter 
object logic specific elements clauses prop function opts sequential name default term termination term primrec defines primitive recursive functions datatypes see 
function defines functions general wellfounded recursion 
detailed description examples 
function specified set possibly conditional recursive equations arbitrary pattern matching 
command generates proof obligations completeness compatibility patterns 
defined function considered partial resulting simplification rules named induction rule named guarded generated domain predicate dom 
termination command establish function total 
fun shorthand notation function sequential followed automated proof regarding pattern matching termination 
details see 
termination commences termination proof previously defined function name refers function chapter 
object logic specific elements definition 
proof closed recursive equations induction principle established 
recursive definitions introduced primrec function command accommodate reasoning induction cf 
rule induct name function definition refers specific induction rule parameters named user specified equations 
case names primrec datatypes involved function numbered starting 
equations provided packages may referred theorem list collective name functions defined 
individual equations may named explicitly 
function command accepts options sequential enables preprocessor disambiguates overlapping patterns making mutually disjoint 
earlier equations take precedence ones 
allows give specification format similar functional programming 
note resulting simplification induction rules correspond transformed specification originally 
usually means equation user may result 
note automatic transformation works ml style datatype patterns 
name gives target definition 
enables automated generation rules domain predicate 
needed helpful proofs partial functions 
generates unconstrained recursive equations termination proof provided function tail recursive 
currently works default allows specify default value partial function ensure dom 
feature experimental 
proof methods related recursive definitions pat completeness method relation method lexicographic order method chapter 
object logic specific elements pat completeness relation term lexicographic order pat completeness specialized method solve goals regarding completeness pattern matching required function package cf 

relation introduces termination proof relation resulting proof state contain goals expressing wellfounded arguments recursive calls decrease respect usually method initial proof step manual termination proofs 
lexicographic order attempts fully automated termination proof searching lexicographic combination size measures arguments function 
method accepts arguments auto method uses internally prove local 
modifiers simp intro add hints automated proofs 
case failure extensive information printed help analyse failure cf 

legacy recursion package legacy recdef command deprecated favour function fun 
recdef theory theory recdef tc theory proof prove recdef name permissive term prop hints chapter 
object logic specific elements recdef tc hints hints tc tc recdef simp recdef cong add recdef wf del thmrefs nameref nat recdef defines general founded recursive functions tfl package see 
permissive option tells tfl recover failed proof attempts returning unfinished results 
recdef simp recdef cong recdef wf hints refer auxiliary rules internal automated proof process tfl 
additional declarations cf 
may tune context simplifier cf 
classical reasoner cf 

recdef tc proof leftover termination condition number default generated recdef definition constant note cases recdef able finish internal proofs manual intervention 
hints recdef may declared globally attributes 
recdef simp attribute recdef cong attribute recdef wf attribute chapter 
object logic specific elements recdef simp recdef cong add recdef wf del definition specification decl specification theory proof prove ax specification theory proof prove specification ax specification decl name prop term overloaded specification decls sets goal stating existence terms properties specified hold constants decls 
finishing proof theory augmented definitions constants theorems stating properties constants 
ax specification decls sets goal stating existence terms properties specified hold constants decls 
finishing proof theory augmented axioms expressing properties place 
decl declares constant defined specification 
definition constant bound name def theorem name declaration 
overloaded constants declared 
chapter 
object logic specific elements specification ax specification extent matter style 
specification introduces new axioms construction introduce inconsistencies ax specification introduce axioms user explicitly proven safe 
practical issue considered introducing constants properties specification prove constants fact equal 
problem ax specification 
inductive coinductive definitions inductive definition specifies predicate set closed rules 
applying rule elements yields result 
example structural operational semantics inductive definition evaluation relation 
dually coinductive definition specifies greatest predicate set consistent rules 
element seen arising applying rule elements 
important example bisimulation relations formalise equivalence processes infinite data structures 
package related zf described separate refer case difficulties 
package simpler zf hol extra logical automatic type checking 
types inductive predicates sets determine domain fixedpoint definition package inference rules typechecking 
inductive theory theory inductive set theory theory coinductive theory theory coinductive set theory theory mono attribute appeared cade longer version distributed isabelle 
chapter 
object logic specific elements inductive inductive set target coinductive coinductive set clauses clauses mono monos prop add del fixes thmrefs fixes inductive coinductive define inductive predicates rules section 
optional section contains list parameters inductive predicates remain fixed definition 
optional monos section contains monotonicity theorems required operator applied recursive set rules 
theorem form premise ri rule 
inductive set coinductive set wrappers previous commands allowing definition inductive sets 
mono declares monotonicity rules 
rule involved automated monotonicity proof inductive 
chapter 
object logic specific elements derived rules inductive definition adds definitions theory proves theorems intros list rules proved theorems recursive predicates sets 
rules available individually names theory file 
cases case analysis elimination rule 
induct induction rule 
predicates rn defined simultaneously list rules called 
rn intros case analysis rules called cases rn cases list mutual induction rules called 
rn 
monotonicity theorems theory contains default set theorems monotonicity proofs 
new rules added set mono attribute 
theory inductive shows done 
general monotonicity theorems may added theorems form proving monotonicity inductive definitions rules premises involving terms ri monotonicity theorems logical operators general form 

example case operator corresponding theorem de morgan style equations reasoning polarity expressions 
equations reducing complex operators primitive ones monotonicity easily proved 
ball chapter 
object logic specific elements arithmetic proof support arith method arith split attribute arith arith method decides linear arithmetic problems types nat int real 
current facts inserted goal running procedure 
argument causes full context assumptions included 
arith split attribute declares case split rules expanded arithmetic procedure invoked 
note simpler faster version arithmetic reasoning performed simplifier 
cases induction emulating tactic scripts important tactical tools isabelle hol ported isar 
proper proof texts 
case tac method induct tac method ind cases method inductive cases theory theory case tac induct tac ind cases term rule insts rule prop name chapter 
object logic specific elements rule inductive cases rule prop case tac induct tac admit reason inductive datatypes alternative rule explicitly 
furthermore case tac classical case split booleans induct tac allows variables instantiation 
tactic feature goal addressing dynamic instantiation 
note named rule cases provided proper induct cases proof methods see 
ind cases inductive cases provide interface internal mk cases operation 
rules simplified unrestricted forward manner 
ind cases proof method apply result immediately elimination rules inductive cases provides case split theorems theory level 
option ind cases method allows specify list variables generalized applying resulting rule 
executable code isabelle pure provides generic frameworks support code generation executable specifications 
isabelle hol instantiates mechanisms way amenable user applications framework generates code functional relational programs sml 
see information covers new style theory format 
value theory proof theory proof code module theory theory code library theory theory consts code theory theory types code theory theory code attribute chapter 
object logic specific elements value term code module code library file contains name name imports name name term term name consts code const template types code attachment chapter 
object logic specific elements name const term template template string attachment attach code attachment name text value reads evaluates prints term code generator 
framework generates code functional programs including overloading type classes sml ocaml haskell 
conceptually code generation split steps selection code theorems translation executable view serialization chapter 
object logic specific elements specific target language 
see 
export code theory proof theory proof code thms theory proof theory proof code deps theory proof theory proof code datatype theory theory code const theory theory code type theory theory code class theory theory code instance theory theory code monad theory theory code reserved theory theory code include theory theory code theory theory code exception theory theory print theory proof theory proof code func attribute code inline attribute export code target file module name string string args chapter 
object logic specific elements code thms code deps const term const name nameref class nameref target ocaml sml haskell code datatype const chapter 
object logic specific elements code const target code type target const syntax syntax chapter 
object logic specific elements code class target class string const string code instance class target code monad const const target chapter 
object logic specific elements syntax code reserved code include code code exception target string target string string target string string const string infix nat infixl infixr string print code func code inline del del export code canonical interface generating serializing code list constants code generated specified target language 
code cached incrementally 
constant currently cached code serialized 
serialization instruction code cached 
chapter 
object logic specific elements constants may specified giving literally referring certain theory named name giving name referring executable constants currently available 
default involved theory corresponding name space module generated 
module name may specified module name keyword code placed module 
sml ocaml file specification refers single file haskell refers directory code generated multiple files reflecting module hierarchy 
file specification denotes standard output 
sml omitting file specification compiles code internally context current ml session 
take optional list arguments parentheses 
haskell module name prefix may root argument string classes adds deriving read show clause appropriate datatype declaration 
code thms prints list theorems representing corresponding program containing constants constants currently cached code theorems printed 
code deps visualizes dependencies theorems representing corresponding program containing constants constants currently cached code theorems visualized 
code datatype specifies constructor set logical type 
code const associates list constants target specific serializations omitting serialization deletes existing serialization 
code type associates list type constructors target specific serializations omitting serialization deletes existing serialization 
code class associates list classes target specific class names addition constants associated class may target specific names instance declarations omitting serialization deletes existing serialization 
applies haskell 
code instance declares list type constructor class instance relations target 
omitting deletes existing declaration 
applies haskell 
chapter 
object logic specific elements code monad provides auxiliary mechanism generate monadic code 
code reserved declares list names reserved target preventing shadowed generated code 
code include adds arbitrary named content include generated code 
argument remove added include 
code declares module name 
code exception declares constants required definition defining equations mapped exceptions 
code func selects option del explicitly defining equation code generation 
usually packages introducing defining equations provide default setup selection 
code inline declares option del removes inlining theorems applied rewrite rules defining equation preprocessing 
print gives overview selected defining equations code generator datatypes preprocessor setup 
holcf mixfix syntax continuous operations consts theory theory holcf provides separate type continuous functions explicit application operator isabelle mixfix syntax normally refers directly pure meta level function type application holcf variant consts modifies pure isabelle cf 
declarations involving continuous function types treated specifically 
syntax template transformed internally generating translation rules concrete representation continuous application 
note mixing holcf pure application supported 
chapter 
object logic specific elements recursive domains domain theory theory domain cons cons name type mixfix distinct thmrefs inject thmrefs induction thmrefs recursive domains holcf analogous datatypes classical hol cf 

mutual recursion supported nesting arbitrary branching 
domain constructors may strict default lazy admits introduce infinitary objects typical lcf manner lazy lists 
see general discussion holcf domains 
zf type checking zf logic essentially untyped concept type checking performed logical reasoning set membership statements 
special method assists users task version declared solver standard simplifier setup 
print theory proof theory proof typecheck method tc attribute chapter 
object logic specific elements tc add del print prints collection typechecking rules current context 
note component built simplifier knows rules declared globally theory 
typecheck attempts solve pending type checking problems subgoals 
tc adds deletes type checking rules context 
inductive sets datatypes set definitions zf set 
generic inductive package provides specific view datatype specifications 
coinductive definitions available cases 
inductive theory theory coinductive theory theory datatype theory theory theory theory inductive domains intros hints coinductive domains domains term term intros intros prop chapter 
object logic specific elements hints monos monos monos con defs thmrefs type intros type thmrefs thmrefs thmrefs diagram monos 
datatype domain domain term term con hints chapter 
object logic specific elements con hints name monos term see information inductive definitions hol note covers old style theory format 
primitive recursive functions primrec theory theory primrec prop cases induction emulating tactic scripts important tactical tools isabelle zf ported isar 
proper proof texts 
case tac method induct tac method ind cases method inductive cases theory theory case tac induct tac ind cases prop name chapter 
object logic specific elements inductive cases prop appendix isabelle isar quick proof commands primitives basic syntax fix augment context assume augment context indicate forward chaining facts prove local result show prove local result refining goal indicate additional facts unfolding unfold definitional equations proof 
qed indicate proof structure refinements 
declare explicit blocks switch blocks note reconsider facts abbreviate terms higher order matching theory stmt theorem name prop proof definition 
proof prfx proof method stmt qed method prfx done prfx apply method name unfolding name stmt stmt note name name term term fix var assume name prop goal goal name prop proof show name prop proof appendix isabelle isar quick abbreviations synonyms proof qed rule show note show derived elements note calculation note calculation trans calculation calculation note calculation calculation ultimately calculation presume assume def fix assume obtain 
fix assume case fix assume sorry cheating diagnostic commands pr print current state thm print theorems term print term prop print meta level proposition typ print meta level type appendix isabelle isar quick proof methods single steps forward chaining facts assumption apply assumption apply current facts rule apply rule rule apply standard rule default proof contradiction apply elimination rule order cases case analysis provides cases induct proof induction provides cases repeated steps inserting facts rules intro rules intro classes class rules elim elimination rules unfold definitions automated proof tools inserting facts prems 
rules intuitionistic proof search blast fast classical reasoner simp simp simplifier splitter auto force simplifier classical reasoner arith arithmetic procedure appendix isabelle isar quick attributes operations rule resolved facts skipping rule instantiated terms skipping rule instantiated terms variable name symmetric resolution symmetry rule resolution rule rule format result put standard rule format elim format destruct rule turned elimination rule format declarations simp simplifier rule intro elim dest pure classical reasoner rule iff simplifier classical reasoner rule split case split rule trans transitivity rule sym symmetry rule rule declarations methods rule rules blast simp auto elim 
intro 
pure elim intro pure elim 
intro 
elim intro iff iff elim 
intro 
simp cong split appendix isabelle isar quick emulating tactic scripts commands apply apply proof method initial position apply apply proof method near terminal position done complete proof defer move subgoal prefer move subgoal back backtrack command methods rule tac insts resolution instantiation tac insts elim resolution instantiation tac insts destruct resolution instantiation tac insts forward resolution instantiation cut tac insts insert facts instantiation thin tac delete assumptions subgoal tac new claims rename tac rename suffix goal parameters rotate tac rotate assumptions goal tactic text arbitrary ml tactic case tac exhaustion datatypes induct tac induction datatypes ind cases exhaustion simplification inductive sets appendix isabelle isar conversion guide subsequently give practical hints working mixed environment old isabelle ml proof scripts new isabelle isar theories 
basically ways cope issue 

convert old sources communicate directly level internal theory theorem values 

port old style theory files new style ones easy ml proof scripts isar tactic emulation scripts quite easy 

redo ml proof scripts human readable isar proof texts probably hard depending wrote original scripts 
conversion internally isabelle able handle old new style theories time theory loader automatically detects input format 
case results certain internal ml values type theory thm 
may accessed classic isabelle isabelle isar provided minimal precautions observed 
referring theorem theory values thm thm thms thm list context unit theory theory string theory functions provide general means refer logical objects ml 
old style theories emit ml bindings theorems theories longer done new style isabelle isar theories 
thm name thms name retrieve theorems stored current theory context including ancestor node 
appendix isabelle isar conversion guide convention old style theories bind theorem ml value 
new style theories longer ml code may require thm foo just foo 
context refers current theory context 
old style theories ml binding thy dynamically created ml code generated old theory source 
longer recommended way case 
function context old scripts 
theory name retrieves named theory global theory loader database 
ml code generated old style theories include ml binding name thy part ml structure 
storing theorem values qed string unit bind thm string thm unit bind thms string thm list unit ml proof scripts behaved storing theorems properly current theory context order enable new style theories retrieve 
qed name canonical way conclude proof script ml 
manages entry theorem database current theory context 
bind thm name thm bind thms name thms store theorems produced ml ad hoc manner 
note original lcf system approach binding theorem values ml toplevel long isabelle 
despite old legacy proof scripts occasionally contain code val foo result ill behaved respects 
apart preventing access isar theories omits result www presentation example 
ml declarations isar ml ml setup theory theory appendix isabelle isar conversion guide isabelle isar theories may contain ml declarations 
example old style theorem binding may mimicked follows 
ml val foo thm foo note command undone invalid theorem bindings ml may persist 
note current theory may modified ml setup declarations act current context 
porting theories proof scripts porting legacy theory ml files proper isabelle isar theories advantages 
example proof general user interface isabelle isar robust comfortable version classic isabelle 
due fact generic ml toplevel replaced separate isar interaction loop full control input synchronization error conditions 
furthermore isabelle document preparation system see works properly new style theories 
output old style sources level individual characters symbols proper document markup isabelle isar theories 
theories basically isabelle isar theory syntax proper superset classic 
quirks legacy problems eliminated resulting simpler rules special cases 
main changes theory syntax follows 
quoted strings may contain arbitrary white space span lines requiring 
escapes 
names may quoted 
old syntax occasionally demand plain identifiers vs quoted strings accommodate certain syntactic features 
types terms atomic far theory syntax concerned typically requires quoting input strings 
old theory syntax fake part syntax types order require quoting common cases hard predict 
hand isar require quotes simple terms plain identifiers numerals symbols input forall 
appendix isabelle isar conversion guide theorem declarations require explicit colon separate name statement name usually optional 
cf 
syntax defs theorem 
note isabelle isar error messages usually quite explicit problem hand 
cases doubt input syntax may just tried interactively 
goal statements simple goals ml canonical goal statement complete proof script follows goal tac qed name form may turned isar tactic emulation script lemma name apply meth done note main statement may theorem corollary 
see details convert actual tactic expressions proof methods 
classic isabelle provides variant forms goal commands see details 
second common expands definitions commencing actual proof script 
def 
may replaced unfold proof method explicitly 
lemma name apply unfold def 
appendix isabelle isar conversion guide deriving rules deriving non atomic meta level propositions requires special precautions classic isabelle primitive goal command decomposes statement atomic list assumptions exhibited ml values type thm 
proof finished premises discharged resulting original rule statement 
long format isabelle isar goal statements admits emulate technique nicely 
general ml goal statement derived rules looks val prem 
goal 
tac qed form may turned tactic emulation script follows lemma assumes prem 
shows apply meth done practice actual rules direct consequences corresponding atomic statements typically stemming definition new concept 
case general scheme deriving rules may greatly simplified standard automated proof tools simp blast auto 
follows lemma 
unfold defs blast note classic isabelle support form special case 
atomic statements standard goal command 
special treatment rules applied disturbing simple setup 
occasionally derived rules established proving appropriate atomic statement object logic putting final result rule format 
classic isabelle usually proceed follows appendix isabelle isar conversion guide goal tac qed spec mp name operation performed qed spec mp performed isar attribute rule format see 
corresponding isar text may look lemma name rule format apply meth done note plain rule format performs slightly different operation fully replaces object level implication universal quantification result statement 
right thing cases 
historical reasons qed spec mp operate may get exact behavior rule format asm 
rule format bit unpleasant final result statement shown text 
alternative state resulting rule intended form place initial refinement step turn internal object logic form method indicated 
remaining script unchanged 
lemma name apply full apply meth done situations step unnecessary especially subsequent script mainly consists automated tools 
tactics isar proof methods closely resemble traditional tactics unstructured sequences apply commands cf 

isabelle isar provides major ml tactics classic isabelle sake easy porting existing developments actual isar proof texts demand diversity proof methods 
appendix isabelle isar conversion guide tactic expressions ml isar proof methods provide proper concrete syntax additional arguments options modifiers typical method text usually concise corresponding ml tactic 
furthermore isar versions classic isabelle tactics cover variant forms single method separate options tune behavior 
example method simp replaces simp tac asm simp tac full simp tac asm full simp tac concrete syntax augmenting simplifier context current simpset convenient way 
resolution tactics classic isabelle provides variant forms tactics single step rule applications higher order resolution 
space resolution tactics main dimensions 

mode resolution intro elim destruct forward resolve tac eresolve tac tac forward tac 

optional explicit instantiation resolve tac vs res inst tac 

abbreviations singleton arguments resolve tac vs 
basically set isar tactic rule tac tac tac tac see sufficient cover modes instantiation single multiple arguments 
convenient cases plain rule method see improper variants see 
note explicit goal addressing supported actual rule tac version 
mind plain resolution tactics may ported follows 
rule resolve tac 
rule 
res inst tac 
rule tac 
rule tac resolve tac 
rule tac 
res inst tac 
rule tac 
note explicit goal addressing may usually avoided changing order subgoals defer prefer see 
appendix isabelle isar conversion guide frequently combinations basic resolution tactics may expressed follows 
ares tac 
assumption rule 
simplifier tactics main simplifier tactics simp tac simp tac variants cf 
covered simp simp methods see 
note individual goal addressing available simplification acts goal simp goals simp 
asm full simp tac simp asm full simp tac simp simp tac simp asm asm simp tac simp asm simp full simp tac simp asm asm lr simp tac simp asm lr isar provides separate method modifier syntax augmenting simplifier context see known simpset ml 
typical ml expression simpset changes looks asm full simp tac simpset 
corresponding isar text follows simp add 
del 
global declarations simplifier rules covered application attributes see information 
classical reasoner tactics classical reasoner provides large number variations automated tactics blast tac fast tac clarify tac 
see 
corresponding isar methods usually share base name blast fast clarify 
see 
similar simplifier separate method modifier syntax augmenting classical reasoner context known claset ml 
typical ml expression claset changes looks appendix isabelle isar conversion guide blast tac claset 
corresponding isar text follows blast intro 
elim 

global declarations classical reasoner rules covered application attributes see information 
miscellaneous tactics additional tactics defined various theories isabelle hol isabelle fol isabelle zf 
common ones may ported isar follows 
tacticals subst hyp subst tac strip tac intro strip split tac simp asm simp split tupled simp split tupled clarify classic isabelle provides huge amount tacticals combination modification existing tactics 
greatly reduced isar providing bare minimum combinators sequential composition alternative choices try repeat 
usually sufficient practice fails arbitrary ml tactic code may invoked tactic method see 
common ml tacticals may expressed directly isar follows tac tac meth meth tac orelse tac meth meth try tac meth 
repeat tac meth repeat tac meth 
tac 
meth 
tac 
meth 
changed see usually required isar basic proof methods fail actual change goal state 
try may accept unchanged results 
appendix isabelle isar conversion guide 
see available isar direct goal addressing 
basic methods address goals internally notably simp see 
note may replaced repeat usually different operational behavior solving goals different order 
iterated resolution repeat resolve tac usually better expressed intro elim methods isar see 
declarations ad hoc operations apart proof commands tactic expressions remaining ml code occurring legacy proof scripts global context declarations ad hoc operations theorems rs 
isar covered theorem expressions attributes 
theorem operations may attached attributes place theorems referenced say method argument 
subsequent ml combinators may expressed directly isar follows 
thm rs thm thm thm thm rsn thm thm thm thm comp thm thm comp thm thm 
thm thm thm 
read instantiate 
thm thm 
elim thm thm elim format standard thm thm standard note readable likewise positional instantiation appropriate 
special ml command qed spec mp isabelle hol fol may replaced passing result proof rule format 
global ml declarations may expressed declare command see appropriate attributes 
common ones appendix isabelle isar conversion guide follows 
thm declare thm simp thm declare thm simp del thm declare thm split thm declare thm split del thm declare thm intro thm declare thm elim addds thm declare thm dest thm declare thm intro 
thm declare thm elim 
thm declare thm dest 
thm declare thm iff note explicit declare commands rarely needed practice isar admits declare theorems fly emerge 
consider ml idiom goal qed name name may expressed succinctly isar lemma name simp name may omitted difficult declare theorem simp del 
writing actual isar proof texts porting legacy ml proof scripts isar tactic emulation scripts see mainly technical issue basic representation formal proof script preserved 
contrast converting existing isabelle developments actual human isar proof texts involved due fundamental change underlying paradigm 
issue comparable converting programs written low level programming languages say assembler higher level ones say haskell 
order accomplish needs working knowledge target language understanding original idea piece code expressed low level language 
appendix isabelle isar conversion guide far isar proofs concerned usually easier re definitions main statements arrangement proof scripts loosely 
ideally informal proof outlines available guidance 
worst case obscure proof scripts re engineered tracing forth backwards educated guessing 
possible schedule embark actual conversion legacy proof scripts isar proof texts 

port ml scripts isar tactic emulation scripts see 

get sufficiently acquainted isabelle isar proof development 

recover proof structure important theorems 

rephrase original intention course reasoning terms isar proof language elements 
certainly rewriting formal reasoning isar requires additional effort 
hand gains human readable representation machine checked formal proof 
depending context application indispensable start 
isar tutorial best look existing isar examples see 
bibliography david aspinall 
proof general 
inf ed ac uk 
david aspinall 
proof general generic tool proof development 
tools algorithms construction analysis systems tacas volume lecture notes computer science pages 
springer verlag 
bauer markus wenzel 
computer assisted mathematics hahn banach theorem isabelle isar 
thierry coquand peter dybjer bengt nordstr jan smith editors types proofs programs types lncs 
bauer markus wenzel 
calculational reasoning revisited isabelle isar experience 
boulton jackson editors theorem proving higher order logics tphols volume lecture notes computer science 
springer verlag 
florian 
code generation isabelle theories 
isabelle tum de doc codegen pdf 
florian 
haskell style type classes isabelle isar 
isabelle tum de doc classes pdf 
alexander 
defining recursive functions isabelle hol 
isabelle tum de doc functions pdf 
xavier leroy objective caml system documentation user manual 
caml inria fr pub docs manual ocaml 
robin milner mads tofte robert harper 
definition standard ml 
mit press 
olaf ller tobias nipkow david von oheimb oscar 
holcf hol lcf 
journal functional programming 
wolfgang markus wenzel 
object oriented verification record subtyping higher order logic 
jim grundy editors theorem proving higher order logics tphols volume lecture notes computer science 
springer verlag 
bibliography tobias nipkow lawrence paulson markus wenzel 
isabelle logics hol 
isabelle tum de doc logics hol pdf 
tobias nipkow lawrence paulson markus wenzel 
isabelle hol proof assistant higher order logic 
springer 
lncs 
lawrence paulson 
isabelle 
isabelle tum de doc intro pdf 
lawrence paulson 
isabelle manual 
isabelle tum de doc ref pdf 
lawrence paulson 
isabelle logics 
isabelle tum de doc logics pdf 
lawrence paulson 
isabelle logics fol zf 
isabelle tum de doc logics zf pdf 
lawrence paulson 
fixedpoint approach implementing inductive definitions 
alan bundy editor automated deduction cade international conference lnai pages 
springer 
simon peyton jones haskell language libraries revised report 
journal functional programming jan 
www haskell org definition 
christoph 
emacs package symbol 
symbol sourceforge net 
markus wenzel 
type classes overloading higher order logic 
gunter amy felty editors theorem proving higher order logics tphols volume lecture notes computer science 
springer verlag 
markus wenzel 
isar generic interpretative approach readable formal proof documents 
bertot dowek hirschowitz paulin editors theorem proving higher order logics tphols volume lecture notes computer science 
springer verlag 
markus wenzel 
axiomatic type classes isabelle 
isabelle tum de doc pdf 
markus wenzel 
isabelle isar versatile environment human readable formal proof documents 
phd thesis institut informatik technische universit nchen 
biblio tu muenchen de publ diss wenzel html 
bibliography markus wenzel stefan berghofer 
isabelle system manual 
isabelle tum de doc system pdf 
wiedijk 
mathematical 
unpublished 
www cs kun nl notes mv ps gz 
index method 
command 
command 
variable command command theorem variable abbrev antiquotation abbreviation command command syntax abbrev const full prf goals ml ml struct ml type prf prop subgoals term term style text theory thm thm style typ typeof apply command apply command args syntax arith hol method arith split hol attribute arities command arity syntax theorem assume command assumes element assumption method atom syntax attribute method attributes arith split hol case case names cases code code func code inline comp cong consumes defn dest dest pure elim elim pure elim format pure folded iff induct intro index intro pure mono hol vars params recdef cong hol recdef simp hol recdef wf hol rule rule pure rule format simp simplified split split format hol standard swapped sym symmetric tagged tc trans typecheck unfolded untagged attributes syntax auto method command axiomatization command axioms command syntax back command best method method blast method command calculation theorem case command case variable case attribute case names attribute case tac hol method case tac zf method cases rule context cases attribute cases method cd command chapter command syntax clarify method method syntax class command class deps command classdecl syntax classes command command zf command code attribute code func attribute code inline attribute code class command code const command code datatype command code deps command code exception command code include command code instance command code library command code module command code command code monad command code reserved command code thms command index code type command attribute method coinductive hol command coinductive zf command coinductive set hol command commands abbreviation apply apply arities assume axiomatization axioms back case cd chapter class class deps classes zf code class code const code datatype code deps code exception code include code instance code library code module code code monad code reserved code thms code type coinductive hol coinductive zf coinductive set hol consts consts holcf consts code context corollary datatype hol datatype zf declaration declare def defer definition defs display drafts domain holcf done export code find theorems fix global guess header hide inductive hol inductive zf inductive cases hol inductive cases zf index inductive set hol instance interpret interpretation judgment kill lemma lemmas local locale method setup ml ml command ml setup notation syntax translations nonterminals notation note obtain oops oracle parse ast translation parse translation pr prefer presume primrec hol primrec zf print print ast translation print attributes print binds print cases print claset print classes print print commands print print drafts print facts print induct rules print print locale print locales print methods print simpset print statement print syntax print print theorems print theory print trans rules print translation proof prop pwd qed recdef hol recdef tc hol record hol redo rep datatype hol sect section setup show setup sorry specification hol subsection syntax term text text raw index theorem theorems theory thm thm deps token translation translations txt txt raw typ typed print translation typedecl typedecl hol typedef hol types types code ultimately undo unfolding update thy thy value comment syntax comp attribute cong attribute const antiquotation syntax command constrains element consts command consts holcf command consts code command consumes attribute context command syntax syntax contradiction method corollary command cut tac method datatype hol command datatype zf command declaration command declare command def command default method command defer command defines element definition command defn attribute defs command dest attribute dest pure attribute display drafts command domain holcf command done command method tac method elements assumes constrains defines fixes includes notes obtains shows elim attribute elim method elim pure attribute elim format pure attribute command method tac method export code command index fact method fail method fast method method command find theorems command fix command fixes element fold method folded attribute force method command method tac method full prf antiquotation global command goals antiquotation syntax guess command command header command command hide command method ident syntax iff attribute includes element ind cases hol method ind cases zf method induct attribute induct method induct tac hol method induct tac zf method inductive hol command inductive zf command inductive cases hol command inductive cases zf command inductive set hol command infix syntax insert method inst syntax instance command insts syntax int syntax interp syntax interpret command interpretation command intro attribute intro method intro pure attribute intro classes method method judgment command kill command lemma command lemmas command command order hol method local command locale command syntax method syntax method setup command methods arith hol assumption auto best blast case tac hol case tac zf cases clarify index contradiction cut tac default tac elim tac fact fail fast fold force tac ind cases hol ind cases zf induct induct tac hol induct tac zf insert intro intro classes order hol completeness hol relation hol rename tac rotate tac rule rule tac safe simp simp slow split subgoal tac subst succeed tactic thin tac unfold mixfix syntax ml antiquotation ml command ml command command ml setup command ml struct antiquotation ml type antiquotation mono hol attribute command name syntax nameref syntax nat syntax command notation command syntax command translations command vars attribute nonterminals command notation command note command notes element theorem obtain command obtains element attribute attribute oops command oracle command params attribute syntax parse ast translation command parse translation command index completeness hol method pr command prefer command prems theorem presume command prf antiquotation primrec hol command primrec zf command print command print ast translation command print attributes command print binds command print cases command print claset command print classes command print command print commands command print command print drafts command print facts command print induct rules command print command print locale command print locales command print methods command print simpset command print statement command print syntax command print command print theorems command print theory command print trans rules command print translation command proof default fake terminal trivial proof command prop antiquotation prop command prop syntax syntax props syntax pwd command qed command recdef hol command recdef cong hol attribute recdef simp hol attribute recdef tc hol command recdef wf hol attribute record hol command redo command relation hol method rename tac method rep datatype hol command rotate tac method rule attribute rule method rule pure attribute rule context case rule format attribute rule tac method attribute safe method sect command section command selection syntax setup command show command shows element simp attribute simp method simp method simplified attribute syntax attribute setup command slow method method index sorry command sort syntax specification hol command split attribute split method split format hol attribute standard attribute string syntax syntax subgoal tac method subgoals antiquotation command subsection command subst method command command succeed method swapped attribute sym attribute syntax symmetric attribute syntax args arity atom attributes classdecl comment ident infix inst insts int interp method mixfix name nameref nat prop props selection sort string tags target term text thmrefs type typevar var vars verbatim syntax command tactic method tagged attribute tags syntax target syntax tc attribute term antiquotation index term command term syntax term abbreviations term style antiquotation syntax text antiquotation text command text syntax text raw command attribute command theorem command theorems calculation prems theorems command theory antiquotation theory command thesis variable thin tac method method theorem variable thm antiquotation thm command thm deps command thm style antiquotation syntax syntax syntax thmrefs syntax command token translation command trans attribute translations command txt command txt raw command typ antiquotation typ command type syntax typecheck attribute typed print translation command typedecl command typedecl hol command typedef hol command syntax typeof antiquotation types command types code command syntax typevar syntax ultimately command undo command unfold method unfolded attribute unfolding command untagged attribute update thy command command thy command command value command var syntax variables 
case thesis vars syntax verbatim syntax attribute command 
