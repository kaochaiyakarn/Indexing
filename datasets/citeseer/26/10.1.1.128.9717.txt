path sensitive value flow optimizations programs bod diploma technical university slovakia university pittsburgh submitted graduate faculty arts sciences partial fulfillment requirements degree doctor philosophy university pittsburgh copyright bod ii committee chairperson university pittsburgh faculty arts sciences thesis bod defended november approved prof rajiv gupta prof mary lou soffa prof mark moir dr michael schlansker hp labs iii path sensitive value flow optimizations programs bod ph university pittsburgh current compiler optimizers conservative inflexible 
result highly optimized programs execute half instructions redundantly recompute previously computed values 
ideally values remembered reused removing recomputations 
unfortunately reuse strategy fails 
culprit intermittent reuse exists execution paths leading redundant instruction 
path specific reuse frequent remove optimizer may need pay exponential price optimizing path separately 
thesis describes defeat exponential path explosion various forms analyze paths separately matters demand analysis generate path specific code optimal profiling feedback avoid profiling individual paths adding confidence imprecise profiles 
result path sensitive optimization framework powerful remove nearly cies practical permit industrial strength implementation 
specifically thesis attacks various forms path explosion dividing optimizer stages responsible aspect path sensitivity 
representation exposes reuse values analysis collects paths exposed reuse transformation exploits collected reuse removing redundancies 
representation stage models flow recomputed value 
symbolically naming value reduces hid den value flow exposed data flow 
result recomputation detected essentially reaching definitions 
representation called value name graph obtains path sensitivity forming value names separately path 
paths analyzed separately analyzing hide value reuse 
analysis stage marks paths value reuse weighs marked paths run time profile guide subse quent transformation 
unfortunately perform precise weighing frequencies marked paths known 
profile guiding practical thesis develops family estimator algorithms require edge frequencies cheaper inherently imprecise alternative path frequencies 
estimators bound inherent error providing confidence practicality 
effect complete removal recomputations exponential code growth caused generating path specific code transformation stage combines orthogonal program transformation methods 
expensive path duplication resorted growth free code motion fails transform program profile driven control speculation profitably impair paths optimize paths 
iv want people provided guidance help support working dissertation 
am indebted advisors prof rajiv gupta prof mary lou soffa continuous support motivating encouragement great patience 
rajiv gupta generated initial interest compiler optimization classes presenting challenging problems 
worked hard keeping motivated taught clearly ideas solutions focus important problems 
guidance thesis completed 
am grateful interactions committee members 
mark moir carefully read draft thesis pointed mistakes suggested improvements 
discussions mike schlansker served strong reminder results thesis applicable practice 
stages development dissertation benefited discussions comments glenn ammons tom ball alain deutsch evelyn duesterwald richard johnson jim larus bob rau mooly sagiv sreedhar bernhard steffen frank tip peng tu mark wegman david whalley including anonymous reviewers 
suggestions 
needless say mistakes dissertation responsibility 
empirical evaluation thesis complete availability compiler hp labs impact compiler university illinois 
developers generously provided supported experimental infrastructure offered assistance implemen tation experiments 
particular am indebted advice received ben chung cheng brian dietrich john gyllenhaal scott mahlke 
scientific curiosity greatly boosted teachers classes took grad school 
especially strong motivation pursue teaching career classes kirk john shen 
am grateful career advice encouragement jim larus mooly sagiv 
years grad school great friends office mates colleagues 
returning pittsburgh trip felt coming home 
memories years grad school forever connected dave phil kamp sylvain 
special go answer hardest questions 
want express family love support 
am especially grateful parents values taught environment provided 
am glad supported numerous hobbies eventually lead current interest computer science 
little brother peter able experience early joy teaching watching grow 
importantly peter constantly keeps remind unwittingly fun 
hope maintain attitude life 
want wife care 
unconditional support possible finish dissertation great motivation wish half time management discipline 
vi table contents list figures 
list tables 
xiv 
motivation programs redundantly recompute values 
benefits removing redundant instructions 
compiler optimization program optimization 
path specific optimization opportunities 
challenge exponential path explosion 
thesis 
pathfinder optimization framework 
optimizer stages 
background related 
value flow representation 
data flow analysis 
program transformation 
path sensitive optimization frameworks 
contributions structure thesis 
preliminaries 
value flow program representation 
goals 
value flow 
value flow versus data flow 
formal definition value flow 
program optimization problems characterizable value flow 
existing techniques value flow detection 
dataflow analysis 
value numbering 
symbolic evaluation 
summary need integration 
value name graph 
constructing vng 
initial parameters 
step placing value threads 
step collapsing value threads 
step dataflow transfer functions 
separable vng 
applications vng 
recurrent array accesses 
distributive non linear constant propagation 
related 
experiments 
path sensitive dataflow analysis 
value reuse analyzed property 
vii availability anticipability dataflow problems 
marking value reuse dataflow lattice 
equation system transfer functions 
computing dataflow solution solver 
estimators high fidelity profiling low cost profiles 
motivation related 
problem statement 
applications estimators 
ideal estimator 
program profiles 
related existing estimators 
hierarchy estimators 
overview estimators 
estimators separable 
estimators general vng 
experiments 
correlation profiling 

intra procedural removal redundancies 
overview 
analysis morel algorithm 
pre separable vng 
profile independent pre 
pre code motion restructuring 
pre code motion 
pre restructuring 
code growth experiment 
profile guided transformation 
pre ms code motion speculation 
pre selective restructuring 
pre msr motion selective restructuring selective speculation 
pre arbitrary vng 
code motion speculation 
miscellaneous issues 
reducible restructuring 
spurious exceptions 
experiments 
related 
inter procedural removal redundancies 
demand driven interprocedural dataflow analysis 
application inter procedural branch correlation 
motivation 
demand driven algorithm 
query propagation 
computing procedure summary nodes 
inter procedural transformation example motivation 
inter procedural pre algorithm 
intra procedural branch removal 
inter procedural restructuring 
implementation details 
exit splitting 
entry exit splitting virtual procedures 
application inter procedural conditional branch elimination 
related 
branch elimination 
benefits entry exit splitting 
viii experimental evaluation 
instantiating framework register promotion 
ideal amount value flow 
completeness value flow analysis 
miscellaneous 
methods value flow optimization 

summary contributions 
lessons observations 

bibliography 
ix list figures fragment merge sort 
load compare statement redundant 
redundancies path specific redundant statements simply removed program 
benefits removing value flow redundancies reducing critical path data dependences reducing hardware resource requirements program 
spectrum approaches value flow optimization 
spectrum extends static compile time techniques dynamic run time techniques 
flavors path sensitivity partial diluted 
exponential path explosion analysis transformation 
pathfinder stages function 
program 
benefits optimizing 
instruction schedule loop removal load min 
schedule shows instructions critical path data control dependences 
data flow versus value flow 
procedure instance value reuse 
values computed pairs equivalent statements expressed function procedure parameter 
compared data flow edges value flow edges intangible def edges identified lexically text program value reuse edges require form symbolic manipulation program expose algebraic equivalences 
orthogonal value flow detection techniques 
dataflow analysis path sensitive technique mark paths value recomputed 
recomputation value detected computations involved name value 
strength symbolic evaluation connect means algebraic simplification identical computations compute value different lexical name 
value numbering add symbolic manipulation dimension discovering names synonymous 
value name graph program 
vng graph form program 
vng step right 
thick lines value threads connect equivalent computations 
contrast traditional dataflow analysis left builds threads lexical name computed value 
lexical names killed shown scissors prevents powerful lexical threads connecting equivalent computations 
step collapsing value threads 
steps vng construction 
algorithm constructing value name graph 
step vng construction symbolic back substitution 
step vng construction example 
fails find equivalence 
contrast succeeds higher cost 
step collapse value threads value numbering 
step vng construction example 
vng detect recurrent array accesses 
left cfg source program 
right vng program 
constant propagation vng 
related 
existing techniques value flow detection compared basis orthogonal mechanisms employ extent exploit power 
estimation problem statement amount reuse loads 
constituent sub problems kind program profile collected run time 
combine collected profile static analysis 
running example annotated edge profile 
estimators precision ordering 
pre estimator 
example pre estimator 
computing estimates running example 
cmp estimators separable cmp cmp cmp cmp formulas computing uncertain component estimate 
cmp estimators separable algorithms computing uncertain component estimate 
formulas overloaded mean frequencies corresponding cmp entries exits 
denotes th available entry cmp denotes th entry th connected cmp subregion 
maxflow denotes maximum flow vertices shown networks 
cmp assumes entries exits mutually reachable 
cmp separates connected eliminating false reachability 
cmp exploits intra cmp reachability max flow computation 
cmp exposes maxflow intra cmp edges including actual profile weights 
computing estimate general vng 
figures represent concrete example estimators 
xi cmp estimators bi distributive algorithms computing uncertain component estimates 
algorithms generalize algorithms separable see 
cmp adds amount flow duplicated cmp region denoted produced flow stolen flow 
cmp similar computed connected sub region 
cmp adds flow consumers adding channel super nodes consumers 
flow capacity added node 
dotted lines mark edges inherited separable cmp 
cmp computes bounds generalized version max flow problem nodes duplicate distribute incoming flow 
experimental comparison estimator precisions 
benchmark plot shows precision estimators cmp estimator implemented 
precision dark bar bottom dark bar gives lower bound returned estimator normalized top dark bar upper bound 
benchmarks left integer programs benchmarks right floating point programs 
example loop 
pre integration code motion control flow restructuring control speculation 
principle code motion pre transformation 
reasons failure code motion pre 
design space pre algorithm 
algorithm combination program transformation techniques 
algorithm lie design triangle 
resulting properties depend biased constituent technique 
various variants pre algorithms 
removing obstacles code motion restructuring 
pre algorithm 
pre algorithm continued 
phase pre remove cmp region control flow restructuring 
pre algorithm 
pre algorithm 
code growth profile independent pre algorithms 
pre ms simple version speculation profitability test 
optimal speculation estimators chapter 
pre ms algorithm 
pre algorithm 
example pre 
assume parameterized 
tightening code growth constant results program 
example pre msr optimization 
reducible restructuring 
relative completeness pre algorithms 
xii benefit various pre algorithms lexical value flow representation 
dynamic decrease due strictly partial redundancies 
algorithm completely removes full redundancies 
summary results 
pre extended traditional code motion transformation transformation methods achieving aggressive pre 
model showed code motion restructuring safe optimization model program path impaired 
speculation requires relaxed optimization model path impaired 
profiling showed code motion combined speculation edge profile precise path profile 
restructuring profile guided path profile precise edge profile 
related contributions 
example program gnu library version 
interprocedural static correlation analysis 
interprocedural cfg call site normal form 
example interprocedural correlation analysis 
roll back algorithm 
example program gnu library 
partial inlining fgetc 
intra procedural restructuring 
inter procedural restructuring 
label denotes query answer label denotes query answer 
implementation exit splitting 
characteristics statically detectable branch correlation 
contribution branch removal vs code duplication requirements correlated conditional 
reduction executed conditional nodes vs program code growth various values conditional code duplication limit 
experimental setup 
dynamically detected load reuse 
inlining code growth spec input set train effects symbolic language pointer aliasing amount detected reuse 
spectrum program optimization approaches 
optimization technologies equipped unique strengths replace 
comparing power value flow analysis value prediction 
xiii list tables size name space function characteristics vng relevant analysis efficiency 
control flow profiles 
experience pre control flow restructuring 
benchmark programs 
cost correlation analysis 
sensitivity load reuse level program input 
column gives number executed loads stores 
xiv chapter motivation programs redundantly recompute values thesis develops framework broad class value flow optimizations programs 
com mon optimizations removal program instructions recompute values known computed program instruction prior execution instruction computed compile time 
instructions compute value say value flows 
program value expression flows expression computed iteration expression computed iterations 
redundant value recomputations offer conceptually simple powerful optimization recomputing new value old reused 
common way reuse value keep register needed 
example program expressions redundantly recompute value 
computation involving address computation memory load removed registers carry value iterations shown 
entry loop iteration registers carry values respectively 
redundant recomputations occur frequently 
value flow redundancy elimination current compilers remove executed arithmetic instructions bc executed conditional branches mw 
estimate amount redundancy program refer hard ware run time prediction mechanisms 
remembering old values predicting new ones techniques predict correctly values svs conditional branches yp 
clearly predicted sense redundant 
predicted values compare top top function compare return return compare fragment merge sort 
load compare statement redundant 
redundancies path specific redundant statements simply removed program 
removed compiler high prediction rates suggests programs inherently highly redundant encourages develop techniques improve compiler optimizations 
shows fragment merge sort program 
illustrates redundancy optimizing away trivial task programmer compiler 
loop merges sorted arrays 
loop iteration compares top elements moves smaller accumulator array memory access top elements redundant smaller element moved iteration refers array element 
expression produces value value flow redundancy 
example optimizer remember previous value register reuse remove load 
unfortunately optimization directly applicable produces value path loop 
path incremented refer different array element loaded memory 
merge sort example exhibits redundancy 
observe statement loop branches direction statement function compare 
branch correlation case value flow redundancy conditional expressions compute boolean value 
know direction redundant branch bypass transfer control return points directly branches statement 
simply remove redundant conditional branch 
bypass need know path arrived branch 
compare failed optimizations statement 
optimizable paths optimizable paths path specific optimization path offers different optimization statement 
noteworthy dif ference optimization removes data dependency redundancy removes control dependency 
removal type dependency may speedup program benefit removing data dependencies illustrated section 
summary value flow redundancy exists reasonably written programs hard remove 
programmer removal require awkward error prone usage tem variables 
compiler require distinguishing individual program paths non trivial task elaborated chapter 
fact redundancies merge sort power existing optimizers optimizer thesis remove 
benefits removing redundant instructions general removal redundant instructions may speed program ways 
reduce hardware requirements program 
redundant instruction removed fewer instructions execute 
result contention hardware resources functional units registers cache ports allows scheduling remaining instructions earlier 

shorten critical path data dependences 
reused value available sooner recomputed instructions need value scheduled earlier 
essentially removing instruction breaks paths data dependences instructions 
redundancy removal breaks critical path longest path may possible schedule program fewer machine cycles 
note instruction schedule improved regardless created statically compiler dynamically order processor 
value flow optimization beneficial statically dynamically scheduled processors 
observe resource constraints restriction come wider processors making benefit somewhat important high performance processors critical path constraint manifestation data flow limit program overcome program transformation making second restriction important processors 
illustrates optimization benefits running example 
cycle cycle removed program removed 
diagram compares schedule unoptimized program program redundant iteration loop body depicts operations influence speed loop loads add store 
measure loop speed iteration initiation rate number processor cycles new loop iteration started fewer cycles faster loop execution 
demonstrate effect insufficient hardware resources assume processor issue memory instruction load store cycle 
unoptimized program add instructions subsequent iterations lie critical path data dependences 
iteration iteration length path cycles composed add store load latencies 
critical path allow issuing new iteration faster cycles 
removing load adds communicate value directly register 
length critical path shortened cycle 
result iteration issued cycles 
note optimal issue rate iteration cycle permitted minimized critical path achieved memory instruction execute cycle iteration instructions 
load removed resource requirements reduced 
iteration contains memory operation allowing issue rate cycle 
summary final optimization benefited reducing critical path resource requirements 
resulted value flow optimization 
compiler optimization program optimization previous sections important points note proposed hardware techniques able attack data flow limit svs ss ls 
section argue compiler optimizations form program transformation 
loop iteration cycle unoptimized execution value flow iteration distance critical path reduced hw resources freed benefits removing value flow redundancies reducing critical path data dependences reducing hardware resource requirements program 

programs highly value flow redundant 

removal value flow redundancies important benefits 

current compilers removing redundancies 
redundancy elimination important optimization instruction level parallelism 
come surprise compiler optimization technology program optimization targets value flow 
dynamic program specialization processor architecture 
different principles value reuse compiler optimization represent spectrum places thesis broader research context 
contrasts approaches value flow optimization 
common analyze program transform 
differs optimization labor divided compile time run time 
consider optimize loop contains loop invariant statement statement computes value iteration redundant 
compiler optimization analysis finds redundant statement transforms pro gram run loop invariant value computed stored register reused needed 
dynamic program specialization delays transformation run time apc gmp cn mcb 
reusing value register value known run time hard coded loop means run time code generation 
result loop specialized loop invariant value 
delaying transformation run time important benefit 
known analyze transform compile time run time compiler optimization reuse find redundancies remove compute reuse dynamic program specialization hard code find invariants compute hard code specialized loop processor architecture learn predict predict static dynamic spectrum approaches value flow optimization 
spectrum extends static compile time techniques dynamic run time techniques 
value hard coded program need occupy register scarce resource 
side cost run time program transformation 
processor architecture modern superscalar processors perform fully run time optimization value prediction svs ls 
observe computed values learn change predict ones 
value predicted correctly program effectively transformed instructions execute earlier 
value mis predicted pay penalty having re execute mis predicted instructions 
processor architecture uses instruction reuse non predicting technique avoids recomputation values previous arguments instructions ss 
technologies form spectrum ranging purely static purely dynamic approach optimization 
approaches offers unique advantages 
focus thesis compiler optimization important advantage zero run time cost run time code generation mis predictions 
disadvantage compiler blind run time values 
driving motivations research explore redundancy removed analyzing program text see section 
long run compiler centric research may indicate kind optimization delayed run time performed 
path specific optimization opportunities technologies compiler optimization oldest 
fact prob lem redundancy removal old compilers coc 
reason optimizers far saturating possibilities sufficiently path sensitive 
obstacles posed paths distinct flavors 
optimizer may fail re partial optimization possible program paths 
replace computation simple constant incoming path 
value known path value computed run time 
say partially redundant 

print read partial optimization possible paths 

print diluted optimization visible paths examined separately 
flavors path sensitivity partial diluted 
second flavor path sensitivity tricky shown 
equals paths common analyzers discover fact path analyzed separately 
analyzed fact diluted variable single unique constant value paths considered 
values considered constant 
consequently sum assumed constant 
problem known non distributivity dataflow problem 
non distributive formulations dataflow problems produce imprecise information dilute information individual control flow paths 
challenge exponential path explosion reasons analyzers examine program paths separately tial number paths program loops 
stay practical analyzers treat paths summarizing results paths meet optimization opportunities 
unfortunately paths explode exponentially analysis program transformation want exploit optimizable paths 
enable optimizations paths physically separated code duplication 
duplication may cause exponential code growth obtained copies print node copies contents 
result code may grow exponentially number program nodes 
inevitable exponential cost imperative path sensitive optimization exploit individual program paths far practical 
core thesis battle exponential path explosion adverse effects code growth manage suppress growth practical optimization 
practical path sensitive optimizers exist room improvement experiments document 
thesis advances boundary practical value flow optimizations 
result double benefit existing optimizers see section 
real programs loops unbounded number paths 
optimize cyclic paths pay just exponential cost 

print 
read print print analysis path may offer different optimization opportunities 
thesis print 
print print 
transformation different path may need isolated 
read print 
print print print print exponential path explosion analysis transformation 
goal thesis develop compiler optimization algorithms target value flow problems 
distinguishing feature algorithms path sensitive 
specifi cally want demonstrate path sensitivity 
effective improves optimizer power 
practical path sensitive optimizer immune exponential blow 
broad path sensitivity applicable value flow optimization problems 
chapter pathfinder optimization framework remainder thesis presents pathfinder framework deriving path sensitive value flow compiler optimizations 
term path sensitive denotes optimization performed pathfinder exploits diluted partial path specific optimization opportunities attacks flavors path sensitivity see section 
term value flow describes computations targeted pathfinder 
pathfinder framework derive optimizers value flow class computations include standard optimiza tions removal common subexpressions loop invariants partial redundancies array bound checks conditional branches redundant loads stores dead code constant propagation see sec tion 
pathfinder generalizes optimizations providing uniform framework improves power making path sensitive 
optimizer stages designing path sensitive value flow framework required 
handle path sensitivity flavors 
parameterized tuned various optimization tasks including targeting arithmetic ex memory access operations conditional branches goals accomplished separating optimizer stages shown 
optimizer architecture value flow representation exposes reuse values dataflow analysis collects paths exposed reuse program transformation exploits collected reuse removing redundancies 
finer detail representation builds program model graph connects equivalent computations 
novel representation called value name graph answers questions computations value equivalent path equivalence holds 
representation responsible avoiding dilution path specific value flow recall second flavor path sensitivity shown 
dilution avoided naming value flows program path analyzed sepa 
naming technique improves optimization paths need considered separately symbolic names expose non trivial relationships instructions 
expose value flow representation collect data flow analysis exploit transformation diluted partial model flow values computations equivalent paths traverse representation value reused path 
profiling remove redundancies separate paths move instructions pathfinder stages function 
dataflow analysis stage traverses representation collects value reuse opportunities marking optimizable paths 
analysis answers question path computation reuse value furthermore run time program profiling determines frequently reuse occurs run time 
effectively analysis separates optimizable paths program paths corresponds partial path sensitivity 
transformation takes redundancies collected analysis removes ei ther physical path separation shown moving redundant instructions desirable economical alternative duplicate program structure 
analysis stage transformation handles partial path sensitivity 
analysis marks optimizable paths weighs profile transformation decides transform paths 
important consequence staging separation various goals optimizer various forms exponential path cost representation goals avoid dilution path specific opportunities model possible paths separately 
analysis goals collect reuse exposed representation incur cost 
cost components analysis cost representation models paths separately may larger original program 
profiling cost path specific profile guidance need frequencies optimizable paths may paths requiring profiling 
transformation goals remove redundancies collected analysis completeness cause code growth due duplicating statements paths distinct opti mization opportunities code growth 
trade offs goals costs divided stages manageable 
fact contribution thesis achieve various potentially exponentially exploding goals optimizer keeping cost practical level 
background related component thesis defining class value flow optimizations identifying members 
component characterizing optimization algorithms class isolating issues inherent various optimization algorithms 
goal section describe common value flow optimizations shared properties characterize analyzing approaches underlying optimizations 
class value flow optimizations comprised optimizations analyze flow values program order remove operations compute value redundant previously computed expensive way compute value remainder program 
partial redundancy elimination pre generalization global common subexpressions loop invariant code motion optimization 
aim pre delete expression computations recompute value produced previously expressions expression redundant value flows previous identical computation previous dynamic instance 
scalar replacement register promotion lc remove memory operations access memory cells previously loaded load operation 
called load store elimination optimizations detecting flow expression values concerned value flow identi cal addresses memory operations 
conditional branch elimination eliminates conditional branches redundant outcome known incoming paths mw bgs 
optimization value interest value branch condition 
array bound check optimization special case optimization 
constant propagation removes expressions producing values known compile time 
conceptually constant expressions redundant compile time expression value flows redundant constant expression executed run time 
strength reduction value flow optimization di krs 
reusing flowing value directly find cheaper way compute result expression 
partial dead code elimination krs eliminates statements compute value remainder program 
optimizations share paradigm exploiting value flow redundancies var ious techniques developed perform optimizations differ analyze value flow patterns modify program remove redundancies exist paths 
summarize existing approaches components value flow optimizer identified value flow representation program analysis program transformation 
existing technique uses form value represen tation prescribes algebraic rules modeling value flow 
analysis traverses value representation connect redundant computations identify value flow patterns 
program transformation component modifies program remove redundant computations 
thesis divides process value flow optimization components order sep issues independent 
separation leads better understanding underlying problems cleaner algorithms general parameterization framework 
existing techniques explicitly separate components subsections distill contribution prior respect representation analysis transformation 
elaborating value flow optimizations described discussions analyzes principles important algorithms implementing optimizations 
value flow representation simplest value representation uses lexical expressions computations value equivalent name name invalidated killed path 
example assignments evaluate expressions identical lexical name redefined assignments assignments compute value lexical model 
note actual verification rule left program analysis component section traverses paths assignments 
lexical value representation basic advanced optimizations subexpression elimination loop invariant code motion asu partial redundancy elimination krs 
lexical model overly restrictive 
fails uncover value equivalence different variables carry value 
example assignment expressions value equivalent lexically different 
value numbering method finding equivalences lexical expressions presence copy assignments cs 
value numbering model relaxes lexical identity identity syntax tree representations expressions may equal 
validity rule relaxed equivalent assigned vice versa assignments computed expressions transitively equivalent value numbering model 
value numbering traces value flow copy assignments fails assignment complex right hand side 
example array expressions identical updated computations assignment value equivalence determined symbolic manipulation simple algebraic rules 
various methods symbolic value models proposed 
rau develops conceptual framework rau spirit interpretation cc repeated back substitution names loop back edges detect loop carried value equivalences path path basis 
framework concentrates formalizing problems arise naming comparing symbolic expressions originating different loop iterations develop practical solutions problems 
reif lewis provide formalism back substituted symbolic expression names program control flow graph determining constant values rl 
symbolic back substitution technique gated single static assignment gsa representation bmo tu padua tp 
name values path sensitive fashion assign path predicates symbolic expressions gsa gating functions 
approach effective answering queries pairs symbolic expressions especially resulting symbolic expressions simple gating functions 
order representation data flow analysis powerful boolean symbolic evaluation system may needed 
johnson schlansker describe system constructed utilized solving predicated flow problems js 
briggs cooper propose simple symbolic improves value numbering reordering nodes syntax trees value numbers computed bc 
example transforming canonical ad equivalent data flow frameworks array value flow analysis intended primarily load store elimination bg dgs 
focusing application domains single loops affine functions loop induction variables model flow recurrent array elements 
thesis presents value flow representation called value name graph combines capabilities syntax value numbering symbolic evaluation methods 
data flow analysis data flow analysis bridge value flow representation program transforma tion 
traversing path potentially equivalent computations analysis verifies algebraic rules posed representation example variable redefined 
tool summarizing global program properties data flow analysis identifies value flow patterns value computed incoming outgoing paths guide program transformation phase value flow optimizations 
discussion shows existing technique restricted individual basic blocks uses global data flow information directly indirectly 
elimination redundancies usually requires computation data flow problems guide transformation 
global common subexpression elimination computes availability lexical expressions removes statement value produces available incoming paths asu 
partial redundancy elimination pre code motion redundant statements formulated tional data flow problem 
modern pre formulations decompose bidirectional problem unidirectional problems availability anticipability called busy expressions krs 
determine redundant statements removed approach uses tion dominators computation dominated value equivalent computation removed value computed incoming execution paths 
data flow analysis calculate dominator relation 
global value numbering verifies value model static single assignment form ssa cfr 
ssa encompasses information variable redefined program points connect definitions uses variable 
ssa computed dominator relation contains data flow component 
program analysis navigate transformation process better proving equality computations gives estimate benefit gained optimization 
benefit de rived program profile traditionally represented form execution frequencies control flow graph edges 
ramalingam developed data flow analysis framework computes probability fact occurring boolean existence information ram 
unfortunately framework explain apply frequency problems maximize optimization profitability 
thesis provides methodology 
advanced program analysis costly time prior research developed methods re cost 
hank propose region compiler architecture procedures partitioned disjoint segments analyzed optimized separately hhr 
selecting appropriate region sizes usually quadratic complexity optimization algorithms prevented exploding practicality 
duesterwald developed orthogonal approach limiting analysis scope examines demand program statements may affect result dgs 
thesis uses demand driven approach performing inter procedural value flow analysis 
program transformation long history research implementation value flow optimizations distinct trans formations removing value flow redundancy identified code deletion code motion control flow restructuring control speculation 
interprocedural domain inlining cloning applied enable exploitation opportunities exist interprocedural paths 
code deletion simplest form removing redundant statement value state ment previously computed incoming path statement simply removed 
verify redundancy exists paths optimization restricted basic blocks subexpression elimination asu value numbering cs 
applying deletion globally mul tiple basic blocks data flow analysis applied confirm value available paths global subexpression elimination asu 
alternatively dominators global value num 
deletion impossible statement redundant strict subset incoming paths 
code motion technique partially redundant statement removed paths redundant 
effectively hoisting introduces compensation code non redundant paths chang ing partial redundancy full redundancy enables deleting statement original position 
loop invariant code motion simplest form motion transformation 
morel gener arbitrary control flow graphs formulating code motion problem bi directional data flow analysis problem 
knoop uni directional formulation problem krs 
necessary code motion may blocked change program semantics impair program certain inputs 
code motion fails eliminate partial redundancies control flow restructuring applied 
value flow optimization restructuring separating optimizable paths paths accomplished duplicating statements path needs separated 
simple form restructuring tail duplication hmc separates frequently executed paths improve scheduling separating control flow merge points 
restructuring necessary redundant operations unconditional branches mw conditional branches mw bgs 
gupta apply control speculation transformation inserts computations paths compute computations unoptimized program 
result paths optimized impaired 
control impairment run time program profile gbf 
form speculative pre explored hh ckl 
kinds value flow optimizations built transformations 
elimination partially dead values krs maximizes optimization possible code motion 
dead values removed code motion eliminated restructuring shown bg 
strength reduction extension pre far code motion optimization di krs 
clearly transformations differ power cost bgs 
deletion appli cable fully redundant operations suitable path sensitive optimizations 
code motion economical increase code size powerful restructuring eliminate redundancies may incur significant code explosion 
control speculation remove redundancies impairs paths introduces duplication 
goal dissertation integrate transformations economical transformations possible costly control flow restructuring code duplication resorted result expected result significant run time speed 
path sensitive optimization frameworks path sensitive value flow optimizations developed date highly specific escape stage classification representation analysis transformation 
consequently frameworks 
rosen hr recognize benefit maintaining program assertions specific individual execution paths analysis 
qualified data flow framework control flow paths variable different constants separated virtual code duplication 
path duplication results exposing path specific contexts remove conditional branches outcomes known context primarily improve def computation 
cause removing redundant branches removes paths executed def pairs realizable exclusively infeasible paths spuriously collected expanded control flow graph 
originally developed improve analysis programs ibm register indirect jumps analysis scale general branch elimination variables analyzed 
practical solution multi variable analysis offered bgs means demand branch correlation analysis reduces cost finding redundant value flow patterns 
associating path specific data flow facts execution paths graph theoretic sense johnson schlansker represent execution paths boolean expressions derived predicates conditional branches paths js 
intended optimization programs predicated ex ecution mlc analysis primarily applicable removing spurious dependencies prohibit operation reordering register allocation ed 
relaxing strengthening predicate condi tion guarding execution operation corresponds moving operation control flow graph achieve optimization 
steffen ste presents extension rosen approach 
property oriented ex framework path separation driven constants variables particular assignments previously computed path 
allows elimination branches hr entire assignments 
steffen observes code duplication may essary re merges back unnecessarily split paths finite state automaton minimization 
ammons larus extend rosen qualified analysis separating paths variable assertions frequently executed paths separated maintain hot path specific context 
profile directed graph expansion practical alternative rosen steffen property oriented expansion approaches path contexts sacrificed dynamically important paths preserved 
framework constant prop optimization 
analysis algorithm separated paths useful opportunities 
global view preliminary research conducted part research identified main issues path sensitive value flow optimizations solving non distributive problems approximation non linear constant propagation collecting path specific opportunities variable different constant path exploiting specific opportunities enabling folding path dependent constants restructuring directing analysis effort hot paths 
approach ammons larus attacks issues uniformly separation hot paths subsequent individual analysis recombination 
approach proposed thesis re serve restructuring actual transformation 
implies different strategy non distributive problems solved precisely paths customizing data flow name space ba distinct path specific opportunities collected demand driven analysis branch elimination bgs profitable opportunities exploited economical transformations code motion speculation infrequent program regions avoided profile guided demand driven analysis 
gupta gbf gbf gbf path profiles carry path sensitive optimiza tion 
similar method ammons larus path profiles maintain path specific context hot path 
results analysis integrate code motion control tion 
contrast method ammons larus transformation delayed results analysis known 
contributions structure thesis stages pathfinder framework thesis develops new techniques 
summarize contributions chapter basis 
chapter representation 
chapter develops value name graph vng novel program rep resentation models flow recomputed values 
symbolically naming value interest vng reduces hidden value flow exposed data flow 
result recomputation detected essentially reaching definitions 
representation names value demand set optimized computations 
names formed separately path obtaining path sensitivity paths analyzed separately matters value different name paths 
chapter dataflow analysis 
chapter develops dataflow analysis technique marking optimizable paths 
marking guide subsequent transformation 
enumerating optimizable paths analysis encodes polynomial complexity way transformation recover 
solution lattice informs point value flow exists paths 
chapter shows perform value flow analysis inter procedurally 
chapter dataflow analysis profiling 
assist making transformation trade offs anal ysis weighs marked paths run time profile 
unfortunately precise weighing requires frequencies paths 
profile guiding practical thesis develops family estimator algorithms edge frequencies cheaper inherently imprecise alternative 
weighing reuse estimators bound inherent error adding confidence imprecise profiles 
chapter transformation intra procedural 
chapter develops transformation nearly com pletely removes redundant recomputations zero code growth 
transformation combines orthogonal methods 
resort expensive path duplication technique growth free code motion fails transform program profile driven control speculation prof impair paths optimize 
spectrum algorithms single abstraction code motion preventing cmp region identifies adverse effects control flow desired optimization 
chapter transformation inter procedural 
chapter develops transformation completely removes redundancies interprocedural value flows procedure boundaries 
resorting expensive inlining separate optimizable paths generating multiple procedure entry points multiple exit points may return different points caller 
entry exit splitting paths separated procedure boundaries call site invokes procedures virtual procedure calls 
chapter empirical evaluation 
chapter compares power framework ideal value flow optimizer optimization redundant loads 
developed run time program monitoring algorithm exposed amount value reuse program 
ideal amount compared amount detected analysis 
observed captured reuse program 
techniques thesis improve effectiveness efficiency optimizer 
improvement stems thesis develops generic framework new optimizations derived power representation transformation algorithms results combining techniques orthogonal strengths trade offs program transformation profile directed evaluate power framework performed limit study served ideal point 
preliminaries section presents necessary definitions 
reader assumed background dataflow analysis muc single static assignment program form cfr rest thesis developed principles 
control flow graph cfg underlying program representation commonly intermediate program representation production research compilers 
furthermore pred cfg directly exposes program control flow paths enables intuitive efficient formulation succ code motion standard representation expressing redundancy elimination krs 
definition directed graph directed graph pair node set edge set 
immediate predecessor successors nodes defined maps pred succ 
finite path sequence nodes 
empty path denoted 
length path denoted 
subpath path continuous subsequence starting th element th element denoted 
subpath excludes th th element write 

definition control flow graph control flow graph start directed graph nodes represent individual program statements instructions 
nodes assumed contain address statements operator built variable set program asu 
edges represent non deterministic branching structure program 
nodes start unique start node node assumed predecessors successors respectively 
assumed node lies path start 
chapter value flow program representation value flow representation value centric model program exposes value equivalent instructions 
specifically finds control flow paths value flows instructions comput ing value 
typically analyzing programs value recomputation value identified lex ical name 
expressions match name compute value 
name value flows equivalent expressions different names 
program repre sentation chapter overcomes naming problem synthesizing names fully trace flow value performing data flow analysis synthesized name space 
pathfinder analysis integrates orthogonal techniques symbolic interpretation value numbering data flow analysis 
symbolic interpretation creates necessary names value numbering technique determines names synonymous 
result expressed new program representation called value name graph vng 
vng constructed conven tional data flow analysis answer fundamental optimization questions computations value equivalent control flow paths 
vng path sensitive value reuse detected path requires different names example due conditionally incremented loop induction variables 
vng parameterized redundancy optimizations common subexpression elimination constant propagation load store elimination 
phrasing optimizations vng obtain greater optimization power broader applicability 
chapter begins presenting goals representation section 
section contrasts flow data flow values defines value flow formally 
section briefly de common approaches detecting value flow focusing strengths weaknesses 
section presents construction vng explains vng synergy existing approaches 
section compares vng value flow representations section experimentally evaluates scalability practicality 
goals value flow representation exposes recomputation value program facilitate value flow analyses optimizations 
pathfinder path sensitive value flow optimizer representation distinct goals 
instructions compute value 
value flow goal val min min min load min load load min source program 
value flow min 
program 

paths compute value 
path sensitive goal min goals important perform optimization illustrated program 
program traverses array computes variable min index smallest element array 
close examination program reveals load min redundant due fact value min loaded memory instruction path leading redundant load 
redundancy shown path basis follows 
path taken min expression min current iterations refers memory location load redundant 
path taken min variable min redefined min longer refers array element 
path current iteration equals min iteration 
path offers reuse min 
path taken loop entered value min equals loaded loop 
paths cover possible paths leading load min whichever path taken min value loaded previously reused 
detected redundancy enables removal load turn enables scheduling loop better twice iteration issue rate 
speed due reducing critical path data control dependences loop explained section 
shows schedule critical path loop removal load min 
moral example traditional path insensitive analysis fails discover redundancy leads optimization 
reason failure paths considered impossible detect path different source value reuse source source 
words paths optimizable optimizable different way 
path sensitivity optimization opportunities diluted sources discovered path insensitive analysis 
goals representation necessary powerful optimization 
detect value flow 
detected path sensitive way 
assuming statement compiled conditional move instruction sit 
source program schedule cycle val min min min adr min load adr min val min min min optimization optimization benefits optimizing 
instruction schedule loop removal load min 
schedule shows instructions critical path data control dependences 
value flow 
section explains detecting value flow hard 
properties value flow shows explicitly exposed program text contrasts value flow data flow explicitly exposed program 
section attempts outline properties value flow representation needs order achieve goals stated previous section 
properties relied section explain insufficiency existing value flow representations 
section concludes list practical analysis problems phrased value flow problems solved pathfinder framework 
value flow versus data flow procedure exhibits instances value reuse 
regardless procedure parameter pairs statements compute value 
value equivalence visible value compute expressed terms procedure parameter shown 
contrived example illustrates analyzing value flow harder analyzing data flow 
distinction typically acknowledged simple approximation value flow computed known dataflow problem available expressions described section 
argue flows qualitatively different 
dataflow analysis problems typically examine properties variables 
example problem reaching definitions compute variable program node set definitions may reach 
similarly liveness problem compute data variable instruction path 
dataflow analysis suited variable centric problems definitions uses variables obvious program text 
example note variables distinct live ranges 
example defined actual parameter statement 
duplicate feasible variable name intentional serves demonstrate rely names variables naming value computed statement 
data flow versus value flow 
procedure instance value reuse 
values computed pairs equivalent statements expressed function procedure parameter 
fact live exit statement evident fact defined 
hand value flow problems concerned properties values want know instructions compute value 
compared variables values invisible entities variable unique lexical name value may require multiple names may stored variable flows value equivalent statements 
consider value flow value different lexical name statements versus variable stores value value executes 
summary flow data lexically exposed definitions uses variables program text directly identify value equivalent statements 
qualitative difference illustrated data flow related statements connected def edges left value equivalent statements connected value reuse edges right 
value reuse edges obvious program text 
require form algebraic manipulation 
turn discussion desirable properties path sensitive value flow representa tion state representation add edges program connect equivalent statements reflecting algebraic equivalence 
edges need added physically may represented assigning equivalent computations identical labels form 
equivalence edges placed path sensitive way shown paths represent equivalence edges 
edges path sensitive meaning computations connected edges equivalent paths computa tions 
edges viewed def edges 
view flow values appear flow data 
representation reduces value flow problems data flow problems 
precisely approach taken value name graph 
formal definition value flow framework optimizes problem class value flow optimization problems 
define value flow class need introduce language symbolic names construct value threads value name graph 
definition symbolic language symbolic language tuple set symbolic names represent values computed program statements interest distinguished symbolic name denoting values represented name function maps symbolic name exit cfg node corresponding symbolic name entry node 
symbolic name finite string arbitrary alphabet 
typically alphabet suitable subset program variable names literals constants integers operators 
see section discussion symbolic language selected particular value flow optimization 
simple examples symbolic language 
example language expresses values computed arithmetic statements composed additions subtractions 
symbolic name belongs iff conditions holds program variable integer 
symbolic language value flow program representation represent arithmetic expressions defined grammar nodes cfg paths 
ready symbolic language define flow values 
definition value flow cfg path values computes statements nodes respectively 
say value computed node flows path value computed node path start analysis problem belongs value flow class symbolic language specified allows specify problem means value flow definition 
example value computed flows 
note symbolic name may algebraically simplify source expression 
care taken ensure arithmetic evaluation symbolic name equal machine evaluation source expression particular due overflows finite machine representation integers 
back substitution function extended transform symbolic names cfg paths 
data flow value flow compared data flow edges value flow edges intangible def edges identified lexically text program value reuse edges require form symbolic manipulation program expose algebraic equivalences 
program optimization problems characterizable value flow list common problems fall value flow class solved value flow framework 
value recomputation expression loads branch correlation array bound checking constant propagation type inference problems 
existing techniques value flow detection section reviews existing techniques detecting value flow dataflow analysis value numbering symbolic evaluation 
techniques orthogonal detect different kinds value equivalent statements 
incomparable strengths techniques described primarily value flow representation integrates techniques way preserves advantages removes limitations described section 
dataflow analysis dataflow analysis nature suitable analysis flow data commonly technique detecting approximation flow values ku 
example known dataflow problem available expressions computes approximation value flow problem availability values 
available expressions value identified lexical name typically right hand side assignment 
lexical names match expressions compute identical values lexical name killed path variables appearing lexical name redefined 
analysis uses name value detect computations equivalent different names 
example equivalence min path detected available expressions 
hand dataflow analysis finds equivalence path sensitive fashion 
instance example equivalence min detected result path marked dataflow analysis path expression min available 
summary dataflow analysis path sensitive value sensitive 
value numbering value numbering partially overcomes naming problem dataflow analysis 
value builds syntax tree serves name names equivalent syntax trees match identical shape including operators inner nodes identical variables leaves tree 
value numbering local works basic blocks path sensitive 
global value numbering extends value numbering paths requires equivalence holds incoming paths 
summary value numbering suited discovering names refer value synonymous path sensitive equivalent computations synonymous paths connecting 
furthermore value numbering able perform arbitrary algebraic manipulations value names 
symbolic evaluation various ways symbolically execute computation 
methods perform algebraic simplifications expressions 
constant propagation algorithms methods 
may fold constants expressions evaluate essentially simplifying expressions 
method perform symbolic backward substitution program expressions 
contrast constant propagation algebraic simplification symbolic arithmetic 
symbolic simplification easily extend path sensitivity clear handle paths value different names 
tu padua able symbolic manipulation global working paths version ssa form tp 
summary symbolic manipulation programs suited creating names value expression performing simplification symbolic names 
manipulations path sensitive 
summary need integration techniques described orthogonal detect certain class value redundancies 
strengths summarized integrated representation follows 
symbolic evaluation name value flows program 
names sufficiently describe value resident variable 
value numbering compact symbolic names 
build representation reduce value flow data flow 
dataflow analysis mark paths reuse exists obtaining path sensitivity 
value numbering find synonyms data flow analysis finds paths reuse name value symbolic evaluation algebraic simplification orthogonal value flow detection techniques 
dataflow analysis path sensitive technique mark paths value recomputed 
recomputation value detected computations involved name value 
strength symbolic evaluation connect means algebraic simplification identical computations compute value different lexical name 
value numbering add symbolic manipulation dimension discovering names synonymous 
value name graph preceding sections set stage presentation program representation 
sec tion distilled goals program representation needed effective optimization sec tion explained value flow exposed traditional program representation section showed existing approaches offer sufficient solution offer complementary qualities integration form basis desired representation 
value name graph vng ex integration 
section intuitively explains vng presents steps construction 
representation called value name graph exposes value flow properly naming recomputed values flow equivalent computations 
central idea create sufficient names value identified flows outside scope lexical name originally computed 
original name valid equivalent symbolic name 
symbolic names form value threads conceptually represent value flow arrows 
vng collection value threads 
propagating dataflow facts threads achieves symbolic analysis threads represent symbolic value names path sensitive value flow analysis thread formed individual program path 
synthesized names created symbolic substitutions backwards propagation lexical name value follows 
clearly value computed instruction identified lexical name 
consider value computed statement example value identified name 
want propagate name backwards modify invalid 
lexical name valid entry valid entry value different say invalidates name 
name name propagated value name invalidated assignment variable name symbolic name value synthesized back substitution 
name changes substituted 
long symbolic name expressed selected language symbolic names process identifies value entire flow 
sequence created names forms value thread 
central property vng computations lie thread compute value 
example lie thread name name 
name name name value threads achieve goal identifying identical computations contain symbolic names useful practical representation 
final value name graph compact encodes value threads scalar variables 
computation rewritten refer scalar variable 
computations refer value thread 
vng example equivalent computations refer scalar variable see 
technically vng graph 
program form encodes graph 
graph program form interchangeably effectively scalar variables compacted symbolic names 
value thread requires multiple names compaction 
situation occurs value named path sensitive way value different symbolic name overlapping control flow paths 
collapsing symbolic names single scalar variable names dilute advantage naming 
multiple scalar names required vng connects assignments 
assignments switch compacted names forming compacted value threads 
figures show vng firstname program 
access array renamed refer scalar variable equivalent computations connected assignments 
example value flow manifested def chain 
def chain identifies cfg path computations equivalent 
particular assignments specify chain follows path 
note vng connects equivalent instructions appropriate paths 
general rule computations produce value connected def chain assignments 
flow values appears flow data de definitions uses scalar variable encoded dataflow transfer functions 
assignments introduced scalar representation vng converted ssa form cfr 
ssa form scalar variable defined assigned exactly achieved renaming program variables definition assignments connect control flow paths merge values originating different assignments program variable 
val min min min 
original program transformation value name graph value name graph program 
min load min load load min min vng graph form program 
effect vng converts problem availability values problem reaching def transitive assignments 
summary design value name graph influenced goals section 
result salient properties 
value flow goal 
vng invisible value flow visible data flow level 
transforming value flow data flow vng exposes value recomputations form scalar variables allowing answer question instructions compute value 
path sensitive goal 
vng supports dataflow analysis 
path sensitive technique dataflow analysis mark paths value recomputed 
additionally vng sparse representation similar ssa form im planted existing ssa pre implementations improving precision lck 
constructing vng start overview vng construction 
construction steps cor responding underlying approaches 
symbolic evaluation places value thread traditional lexical name space vng symbolic name space vng step right 
thick lines value threads connect equivalent computations 
contrast traditional dataflow analysis left builds threads lexical name computed value 
lexical names killed shown scissors prevents powerful lexical threads connecting equivalent computations 
synthesizing names necessary trace value flow 
second value numbering compacts value threads determining symbolic names synonyms value 
result steps vng 
third step forms dataflow transfer functions scalar names 
algorithm summarized 
step placing value threads 
symbolic names created propagating lexical name analyzed computation backwards 
assignment invalidates current name assignment right hand side expression substituted current name algebraically simplified 
propagation effectively creates symbolic slice original computation 
example shows value thread value computed completes example 
shows graph form value threads computations program 
graph shown intermediate form vng explicitly constructed 
intermediate stage vng nodes cross product cfg nodes synthesized symbolic names 
vng edges show value name changes forming value threads 
highlighted nodes represent analyzed computations 
note placing computations value threads naming computed values adequate 
consider values computed statements 
values equivalent name 
identically named values may differ name point refers variable different value point 
rely variable names provide global naming values step vng computations safely considered identical name program point 
step removes deficiency providing global naming values 
step collapsing value threads 
step formed threads exposed recomputation 
recomputation detected lie value thread 
note equivalent value thread chain step collapsing value threads 
data flow dependences dataflow analysis fails find equivalent 
lack connecting value thread explained fact lexical name match name propagated back substitution 
names synonyms value seen expressed function procedure formal parameter equal 
problem back substitution process matched names predecessor 
delayed match inherent symbolic back substitution process 
corrected value numbering step collapses threads names synonymous 
names synonymous back substitution reduces symbolic name 
collapsed threads shown 
threads collapsed equivalent computations lie thread dataflow analysis find recomputation 
note change value names 
step synthesized symbolic names second step names value scalar names 
scalar names directly correspond congruence classes formed value numbering 
step dataflow analysis 
graph constructed recomputations value placed collapsed threads 
computations converted accesses scalar names dataflow analysis determines availability value gen kill analysis 
analysis bit vector analysis assignments dataflow facts propagated bits corresponding ed names 
summarizes construction vng orthogonal techniques 
subsections describe construction vng detail 
initial parameters vng parameterizable 
constructed expose value flow arithmetic ex memory load operations conditional branches vng tailored kind recomputation specifying symbolic language generates names values back substitution 
arithmetic recomputations preceding examples required name expression composed variable names operators analysis conditional branches may value numbering data flow analysis symbolic evaluation lexical names solve data flow problems steps vng construction 
vng create value threads collapse synonymous threads require name relational operators example 
language names needed analysis repeated memory accesses pointer data structures 
seed set computations interest 
vng parameter set computations recomputation focus analysis 
analyzed computations serve seed back substitution process value threads start unrolling backwards 
computations interest form seed set pairs name denotes computation interest cfg node 
language symbolic names defined shortly 
note lexical name assume belongs language symbolic names 
example seed set example program consists entire right hand side expressions node program adr adr adr seed set program consists addresses array accesses assuming min sizeof language symbolic names seed set decide symbolic language draw symbolic names creating value threads 
example pattern may restrict symbolic names form program literals scalar variable 
selection mainly issue implementation desires suitable trade issues influence accuracy complexity analysis suitability format symbolic name suit kind computations seed set mentioned arithmetic expressions need arithmetic operators describe values memory accesses describe indirect memory accesses 
certainly permit operators arbitrarily deep nesting expressions freedom expression may create names back substitution process may prove impractical 
practice observed simple names expressive kind seed computations 
semantics symbolic name evaluated 
mean usual addition values 
equal 
canonical form equal expressions representation 
example canonical form may alphabetically sorted enables matching 
interpretation program statements modify name 
words happens back substitution inserts name symbolic name substitution simplification rules 
example willing substitute copy assignments complex ones 
case complexity synthesized names may grow polynomial 
termination symbolic language infinite back substitution may terminate new names continue created 
force termination introduce parameter stops back substitution control flow paths fewer cycles examined 
implementation format name permit efficient implementation 
example symbolic names compared constant time 
simplification performed efficiently 
recall language extended special name denotes values expressed selected symbolic language 
example 
consider problem determining redundant address computations accesses onedimensional arrays 
choosing sufficient represent address expressions array accesses multi dimensional accesses 
set contains address operands load store nodes eventual consumers address computations 
accommodate indirect addressing symbolic language value names enriched pointer dereferencing operator back substitution rules loads stores 
loads increase indirection level name propagated backwards load change stores may reduce indirection store name change memory addresses represented symbolic names literals program variables 
term adds addressing indirection 
actual implementation may want set maximum number indirection levels order limit number symbolic names created back substitution 
experiments level operator address name level operator address 
step placing value threads step synthesizes names analyzed values 
output step set symbolic names value transfer set vt describing value threads transfer switch graph start input control flow seed set substitution function substitute loop iteration window 
output value name graph start set synthesized names 
step route value threads step collapse threads convert threads ssa form collapse threads global value numbering step dataflow analysis define dataflow transfer functions section solve dataflow problem chapter algorithm constructing value name graph 
symbolic names 
vt defined follows vt name back substituted cfg node 
set vt represents value threads explicitly building vng nodes edges shown 
vng represented specifying vng edges connect different names modified propagated name 
accomplished representing symbolic name symbolic variable 
switches names represented assignments variables shown say vt note second step construction transform symbolic names assignments ssa form collapse value numbering see section 
algorithm shown sequence backward traversals cfg 
starting seed computations traversal propagates original lexical names updates accordingly affecting node performing back substitution 
traversal places value threads acyclic paths stops loop back edges 
traversal continues loop back edges extending threads loop iteration boundaries 
multiple traversals create threads model value flow possible paths loop iterations 
setting discover equivalences address computations occur consecutive loop iterations 
describe algorithm detail 
algorithm initializes traversal worklist seed computations line 
note worklist maintains names exit node traversal starts predecessors seed computations 
traversals performed separate worklist lines 
termination similar widening cc 
vng models flow value consecutive loop iterations provides sufficient scope optimizations instruction level parallelism domain 
line forces back substitution fail cfg start node start way asserting conservative assumptions program entered 
function substitute determines name graph start input control flow seed set substitution function substitute loop iteration window 
output synthesized symbolic names value transfers 
worklist worklist empty remove pair worklist start substitute add add pred visited false backedges worklist add worklist add worklist worklist pred visited true add step vng construction symbolic back substitution 
changes node line 
name changes line outputs assignment denoting thread changes names 
lines continue traversal predecessors passing names cross back edges traversal line discussed 
backedges defined set cfg edges backedges depth traversal cfg 
definition marks backedges irreducible loops 
visited flag marks name visited exit node line 
flag prevents propagation name twice line 
lines terminate threads left air back edges traversal sequence forcefully terminated traversals 
unfinished threads grounded asserting conservative assumptions start node start line 
shows step vng program 
shows vng conceptual graph form 
illustrate back propagation address operand load node 
propagating assignment node right hand side substituted current name 
obtain name analyzed load store load store load load load store store load store load store store load global store source program 
conceptual vng 
vng step 
step vng construction example address load 
crossing load node substituted name address address global variable 
name changed nodes 
note shows vng construction path 
address operands remaining memory operations undergo back propagation 
process name creation demand driven necessary names created 
step collapsing value threads second step collapses threads placed step 
collapsing viewed postprocessing back substitution 
places thread computations back substitution equivalent place thread 
computations symbolically reduced name reduction occurred upstream computations case 
technically collapsing performed finding node symbolic names reduce symbolic name 
names synonyms value placed equivalence class effectively collapses threads placed class 
names classes serve symbolic names final vng 
thread collapsing expressed partitioning symbolic name space equivalence classes cfg node 
second step called symbolic value numbering 
fails find equivalence contrast succeeds higher cost 
similarity standard global value numbering discovers names refer value 
compare observe computes value names synonymous representing synonyms partitions computes synonyms globally accounting program paths leading cfg node uses compact ssa encoding names maintain single global partitioning separate cfg node 
detects synonyms symbolic algebraic equivalence structural syntactic equivalence 
uses precise expensive partitioning algorithm explained 
symbolic value numbering sub steps 
step vng transformed static single assignment ssa form 
second ssa ed symbolic names globally partitioned 
recall step vng represented assignments variables denoted 
converted ssa form variable assigned exactly 
ssa form achieved creating multiple copies variable assignment connecting copies assignments inserted control flow merge points reached different assignments variable 
property desired ssa transformation insertion assignments effectively breaks threads largest snippets synonyms relation remains 
result collapsing need expressed node snippets single global partitioning 
variables ordinary scalar variables existing ssa construction algorithm cfr sg 
ssa transformation changes symbolic name space ssa ed name space denoted 
partition ssa ed names employ algorithm 
computes imprecise solution cases may occur vng 
consider 
program fails find equivalence succeeds 
assigned back substituted 
partitioning algorithm represents synonyms graph edges connect equivalent names 
algorithm optimistic 
starts names assumed equal removes edges safely assumed synonymous 
edge removed control flow path reduced back substitution failed reduced non name 
fixed point reached sized graph converted sized equivalence class partitioning save memory 
economical class partitioning fixed point reached graph necessarily represent equivalence relation 
equivalences represented granularity edges partitions 
details algorithm 
input equality graph 
graph optimistically initialized edges connect ssa variables live ranges overlap 
graph live range interference graph 
built ssa construction 
algorithm starts identifying pairs names definitely synonymous propagates inequality def chain ssa variables edges removed 
line finds names failed back substituted node 
line finds names live node 
names different inserted worklist 
edges worklist algorithm removes edge line edge removed line 
removed edge inequality propagated uses forward direction def chain assignments back substitution assignments 
returning running example shows ssa form step vng shown 
example needs ssa subscript node live ranges variables cross control flow merge point 
algorithm partitions names congruence classes shown 
names classes symbolic names final vng shown 
note optimized computations rewritten refer names equivalence classes 
notice step vng find reuse equivalent nodes value thread see 
threads collapsed nodes refer thread represented chain data dependences see 
step dataflow transfer functions previous steps constructed nodes edges vng 
solve dataflow problems vng remains construct dataflow transfer functions equation system computing dataflow problems 
section show compute availability values forward problem 
availability computation path insensitive determines value available paths 
solution problem sufficient performing global common sion elimination global cse vng eliminating fully redundant computations 
chapter presents path sensitive formulation dataflow analysis vng perform partial redundancy elimination 
define vng constructed steps 
recall second step symbolic name defined nodes introduced vng converted ssa form 
definition value name graph start control flow graph name space 
names names congruent class names created step name 
input ig interference graph ssa ed name variables iff live cfg node 
output symbolic name space final vng partitioning ssa ed name space equivalence classes 
live node add worklist worklist empty remove edge worklist remove edge assignment add worklist assignment add worklist partition classes connected subgraph ig class step collapse value threads value numbering 
load store load store store load congruence classes load store store store load load ssa form step vng 
final vng 
step vng construction example value name graph vng graph start set nodes 
set edges iff pred defined node node th immediate predecessor defined 
start node start connected nodes start 
similarly terminates cfg nodes connecting vng nodes vng nodes pred succ functions defined vng usual 
definition thread thread path vng graph 
contrast path path cfg graph 
note relationship threads paths 
thread exactly sibling path obtained function path path 
clearly thread sibling path path multiple threads different value 
vng node corresponds value symbolic name flowing cfg node 
compute availability values 
availability property avail computed binary lattice 
meet operator returns lower element 
computation fully redundant removed 
assume value computed vng nodes seed set 
start avail pred generate value propagate value avail df killing stores 
dataflow analysis vng closely coupled back substitution step 
recall vng threads detect reuse aggressively back substitution may defined ignore may aliasing threads extend uninterrupted potentially killing stores 
result vng detects instructions read location reflect store may change contents location reads 
treating may aliasing kills separately intentional design decision hardware mechanisms enable reuse exploitation presence infrequent kills data speculative load ksr 
may aliasing easily accounted dataflow analysis vng 
running example assume may equal 
belongs congruent class belongs store kill reuse class vice versa 
store node kill reuse load node 
account killing statements modify transfer function avail avail df generate value may aliased value kill value depending optimizer kill may entirely destruct reuse preventing register promotion may mark reuse unsafe 
separable vng section introduces restricted case value name graph 
purpose simplify presentation profiling transformation algorithms chapters 
restricted version called separable behaves just cfg lexical morel style redundancies 
simplification allows algorithms intuitive level extend general vng 
definition separable vng value name graph start called separable symbolic names analyzed separately threads interfere 
formally edge 
start load load vng detect recurrent array accesses 
left cfg source program 
right vng program 
applications vng section shows vng parameterized various value flow analysis problems 
presents detection recurrent array accesses version constant propagation 
recurrent array accesses back substitution traverses consecutive loop iterations vng naturally ex poses redundancy recurrent array accesses 
fact vng generalization stretched loop bg 
contains accesses 
vng loop 
vng equivalent array accesses connected thread extends loop iterations 
analysis transformation stages pathfinder optimizer inter iteration threads different acyclic ones handled uniformly 
distributive non linear constant propagation traditional formulation constant propagation cp distribute meet op erator algorithms data flow problem need trade precision effectiveness gt 
distributive formulation linear version cp 
linear ver sion restricted assignments variable right hand side interpreted 
vng formulate distributive non linear cp algorithm handle arbitrary assignments domain symbolic pattern 
aware algorithm 
vng constant propagation performed product vng con struction grouping names equivalence classes program constants name back substituted constant path operand seed set constant value 
subsequent value numbering step verifies name class constant 

step vng 

ssa form step vng value numbering constant propagation vng 
value equals program paths 
data flow analysis step required value numbering verified name constant incoming paths 
presents example 
value numbering step vng construction congruent class contains symbolic name constant symbolic name 
names synonymous constant 
noted distributivity comes cost exponential worst case complexity due number symbolic names vng may contain 
symbolic approach constant propagation advantages compared existing cp algorithms 
symbolic names find constants value known link time 
example may address array 
second freedom choose permits discovery constants assignments arbitrary right hand side expressions adjusting allows tune tradeoff cost power analysis 
related number approaches detecting equality values developed 
prior best compared representation basis subset underlying mechanisms employs degree power exploited 
dimensional cube serves relate existing techniques 
start techniques lexical names values 
improve power add degree dataflow analysis 
briggs cooper 
effect 
pre steffen 
rosen 
vn pre reif lewis 
global vn cocke schwartz 
local vn value numbering data flow analysis global cse cse pre 
morel renvoise stretched loop 
bodik array analysis 
duesterwald symbolic analysis 
tu padua symbolic evaluation related 
existing techniques value flow detection compared basis orthogonal mechanisms employ extent exploit power 
vng local common subexpression elimination cse 
methods equivalent com identified lexical names 
dataflow analysis restricted basic blocks 
path insensitive local name insensitive lexical technique origin dimensional cube 
global common subexpression elimination global cse 
adding dataflow analysis power verify subexpressions equal paths path insensitive manner coc 
loop invariant code motion 
smarter global dataflow analysis find loop invariant computations 
loop invariants redundant paths technique partially path sensitive 
partial redundancy elimination pre 
pre uses dataflow analysis full extent identifies computa tions equivalent paths 
note paths equivalent computations required lexical name 
techniques value numbering follow analogical historical improvement adding path sensitive power dataflow analysis 
local value numbering local vn 
restricted basic block local value numbering consider program paths 
global value numbering 
method detects syntactic equivalences hold program paths 
commonly algorithm employ dataflow analysis verify paths equivalence uses ssa form essentially encodes result dataflow analysis def chains compact way 
true rl uses precursor ssa form 
value numbering driven pre vn pre 
rosen pre algorithm driven syntactic equivalences lexical ones 
lexical names redundancy elimination approach cli solves data flow problems name space global value numbers 
value flow graph 
steffen skr value numbering fully path sensitive 
graph representation similar vng 
fact viewed placing value threads 
difference threads equivalence syntactic terms algebraic equivalence 
adding path sensitivity lexical syntactic value numbering names systematic techniques performing symbolic evaluation paths 
symbolic analysis 
tu padua gated ssa gsa form reason symbolic expressions program paths simultaneously tp 
projecting symbolic expressions cfg points assign path predicates symbolic expressions gating functions gsa 
approach effective answering queries pairs symbolic expressions especially resulting symbolic expressions simple gating functions 
order representation data flow analysis powerful boolean symbolic evaluation system may needed 
johnson schlansker describe system constructed utilized solving predicated flow problems js 
array analysis 
duesterwald gupta soffa encoded algebraic information array index ex dataflow transfer functions 
result loop carried recurrent loop invariant array accesses detected dgs 
stretched loop 
bodik gupta detect loop carried array accesses path sensitivity 
stretched loop virtually unrolled loop reduces array analysis affine indices scalar variable domain 
simpler domain pre style dataflow analysis applied bg 
application domains dgs bg limited single loops loop indices incremented unconditionally address expressions interest load store operations affine functions loop indices 
vng analyze nested loops arbitrary control flow conditionally incremented induction variables 
effective pre 
briggs cooper perform pre dataflow equations name space uses limited form symbolic evaluation form value numbering 
vng strictly better effective pre technique bc 
expression orthogonal methodology vng 
vng re associated program benefit combined power approaches 
contrast existing methods vng combines power techniques 
authors aware existing technique combine approaches systematic analysis tool 
vng inspired conceptual framework described rau rau spirit interpretation cc 
describes repeated back substitution names loop back edges detect loop carried value equivalences path path basis 
rau presents problems arise naming comparing symbolic expression originating different loop iterations pathfinder framework offers practical solution problems 
experiments practicality vng representation depends largely size symbolic name space 
language symbolic names infinite worst case size name space exponential number cfg nodes number back substitution iterations constant 
translate exponential worst case time space complexity analysis 
fortunately experiments show size practice moderate 
fact value flow analysis array accesses smaller number program variables 
reporting size final name space measure size name space created step construction 
larger size safely estimates complexity analysis vng complexity vng construction ssa transformation value numbering step 
experiments evaluated size vng properties vng tailored elimination redundant loads stores 
seed set contained source operands load store instructions 
language chosen express address expressions dimensional array accesses 
vng implemented hp labs vliw backend compiler 
determine rate name space grows function built vng various values 
column table initial size 
column labeled shows size iterations back substitution 
vng built procedures programs report procedures steepest growth rate benchmarks come spec grep unix utility simple matrix multiplies static dynamic memory allocation respectively 
vng analysis applied classical optimizations asu applied procedures 
majority procedures table growth rate linear rate slightly exceeds linear curve 
exponential growth observed large fraction variables involved analysis back substituted different expression branch statement loop body 
address expression computation programs considered property 
column shows number variables virtual registers referenced procedure 
fol lowing columns give size ratio 
values selected practice opportunities loop carried value reuse iteration distance 
surprisingly name space smaller set 
growth rate may non linear actual size may larger optimizations load store elimination expect size comparable enables efficient analysis 
symbolic patterns permit dramatic name space growth practice size restricted demand driven construction terminating back substitution soon prede number names created 
approach successfully demand driven analysis bgs 
provide intuition symbolic names grow moderately table presents percentage cfg nodes back substitution performed symbolic name column bs 
column gives number cfg nodes procedure 
node contains single intermediate statement 
experiments show nodes influence name analyzed address expressions array accesses 
benchmarks program procedure back substitution iterations bs alvinn initialize input hidden hidden output output hidden hidden input compress main decompress output ear main grep execute mm main mm dyn main average table size name space function characteristics vng relevant analysis efficiency 
chapter path sensitive dataflow analysis section dataflow analysis vng 
analysis path insensitive merely verified property value availability holds paths 
chapter presents dataflow analysis path sensitive 
finds marks optimizable program paths paths value reused 
results analysis guide remaining stages optimizer 
exponentially optimizable paths central issue represent compactly polynomial cost 
compact marking accomplished lattice distinguishes paths node optimizable 
compact encoding transformation stage pathfinder recover individual optimizable paths 
chapter starts defining optimization property value reuse marked vng 
section defines dataflow problems solved identify path optimization property 
section defines lattice allows computing dataflow problems path sensitive way section gives dataflow equations computing problems 
section discusses solvers compute fixed point solution deals issues implementation 
value reuse analyzed property vng representation exposes value flow shows name value changes flows program construction value threads 
purpose optimization interested value flows computations wish optimize 
call reuse threads reflect fact connect computations compute value reused 
reuse threads correspond optimizable paths want identify analysis separate optimization 
reuse threads defined kinds vng nodes generators compute value users compute value reuse kills kill value 
reuse thread kill free generator node user node 
note user node generator generator user 
distinction introduced describe value reuse computations value may flow memory particular load store instructions 
similarly value flow memory requires kill nodes introduced account potential aliases aggressively disregarded back substitution construct vng discussed section 
contrast describe value reuse computations value flow memory arithmetic operations sufficient notion user nodes 
example illustrates kinds nodes 
example value reuse memory operations 
consider problem redundant load removal 
problem load memory location redundant load reuse prior access memory location 
prior access load store computes value memory location placing memory register redundant load operation fetch accessing memory 
describe optimization user nodes load instructions optimizable oper ations consume value generated prior access 
generators loads stores 
kills stores disambiguated 
definition reuse threads tuple vng set generator vng nodes generate value set user vng nodes subset generator nodes generate consume value set kill vng nodes may modify value set reuse threads denoted potentially infinite set finite length vng threads originating generator node sinking user node thread contains generator node kill node condition ensures user node generator user generate value immediate consumption zero length path 
node reuse value value generated past cycle vng situation occurs user node represents loop invariant computation 
availability anticipability dataflow problems reuse threads identified dataflow problems availability anticipability introduced 
value available incoming path value generated path subsequently killed 
value anticipated path path generated killed 
availability forward problem anticipability backward problem 
properties usually defined cfg 
problems defined vng follows 
definition path availability generators value available cfg node cfg path start vng thread start runs path value flowing thread generated kill free suffix 
path anticipability defined analogously 
node lemma start cfg start vng set reuse threads 
belongs reuse thread iff value 
available cfg node cfg path start 
anticipated cfg node path 
marking value reuse dataflow lattice definition introduced dataflow problems path manner computing availability anticipability path give path sensitive dataflow solution exponential cost 
mark reuse threads vng polynomial cost define node characterization problems 
characterization distinguishes value available node paths paths strictly paths 
versions availability anticipability predicates boolean 
take values may mean value holds paths available node paths available paths may available depending path taken 
definition node availability anticipability availability entry incoming paths defined available paths start 
may anticipability entry incoming paths defined anticipated paths 
may paths means strictly paths 
note may don know answer 
signifies node paths property 
values sufficient transformation may stage recover path specific information 
compute valued dataflow solutions define lattice gives partial order may element safe guess computing solution iterative dataflow solver 
definition path sensitive lattice lattice tuple partially ordered set path sensitive meet union operators respectively 
partial order 
may meet operator returns greatest lower bound union operator returns smaller upper bound 
equation system pred transfer functions equation system 
avail forward problems forward problem availability computed transfer function avail backward problems separable vng backward problems set analogously forward ones avail df separable vng defined definition page 
general dataflow facts may merge control flow paths merge threads merge happen arguments node 
thread merge different effect control flow creates may meets combining paths path sensitive way 
contrast thread merge combines threads share sibling path see definition 
sufficient threads property 
meets result 
thread merge uses union operator defined order may example backward dataflow analysis consider example 
threads meet cfg edge 
merge influences computation anticipability 
values computed anticipated 
note solution anticipability change removed anticipated 

original program value name graph 

equipped union operator set equation system 
antic succ succ df antic computing dataflow solution solver maximal fixed point equation systems iterative dataflow solver 
effective alternative iterative algorithm demand driven analyzer dgs 
lattice values efficiently encoded bits 
value represented pair bit true property holds paths second property holds possibly paths meaning hold serves initial guess dataflow solution appears final solution 
may encoding meet operator performs bit wise bit wise 
chapter estimators high fidelity profiling low cost profiles optimizing compiler knowledge run time behavior program execution frequencies statements avoid making transformations result small run time benefit 
common types program profiles edge profiles path profiles measure frequently edges paths executed set inputs 
typical profile directed optimizer works steps 
profiler measures run time behavior program 
second program transformation consults generated profile estimate run time benefit alternative transformation choices 
path sensitive setting steps currently incompatible edge profiles inexpensive collect estimates imprecise path insensitive 
path profiles produce precise path sensitive estimates expensive collect non trivial consult incorporate dataflow analysis 
chapter bridges profiling optimization 
presents technique uses edge profiles inexpensive path insensitive measurement program control flow behavior produces profile weighted dataflow information information informative compatible value flow optimizer practical inexpensive precise 
informativeness dataflow analysis value name graph answers essentially boolean ques tions computation node value flow path question relative terms expected execution frequency value flow program transformations perform cheaper program optimization requires code growth due code duplication shown chapter 
chapter presents set estimator algorithms computing fre quency information combining boolean dataflow information program profile 
dissertation frequency information uses guides program transformation chapter evaluates performance entire framework quantifying amount value flow exposed static analysis chapter 
practicality practicality primary design goal pathfinder estimators achieved novel contributions 
estimators designed edge profiles low profiling cost widely supported 
unfortunately edge profiles inherently imprecise cause reconstruct frequencies individual program paths 
add confidence profile directed optimization estimators bound inherent imprecision surfaces computed frequency 
bound achieved assuming optimistic pessimistic scenario profiling error 
second contribution estimators form hierarchy increasing precision 
hier provides practical solution profile weighted analysis simple estimator returns bounds loose compiler invoke better estimator 
better estimator obtain bounds guaranteed worse reusing information computed simpler estimator decreasing compile time implementation effort 
tunable precision obtained algorithmic prin localizing program regions vulnerable edge profile error reducing error various notions control flow reachability 
contribution experiments edge profiles 
estimators eliminate inherent edge profile error computing bounds restrict quantify fundamental limitations edge profiles 
experiments show inherent error small load reuse 
algorithms error considerably reduces second best estimator able bound error fold improvement simplest estimator 
properly edge profiles provide sufficient precision simple implementation 
chapter starts stating problem motivating ideal estimator reviewing related 
section intuitively introduces principles estimator algorithms 
sections estimator algorithms separable section general section 
section empirically evaluates precision estimators 
edge profile precision limited absolute precision detailed profile needed 
section sketches novel profiling algorithm fully path sensitive require profiling complete program paths 
section concludes summarizing results providing recommendations deployment estimators production compiler 
motivation related describing estimator algorithms section states problem estimating profile run time benefit optimization 
section highlights inherent issues describe tackled existing techniques 
problem statement recall vng value reuse manifested reuse thread kill free vng path connect ing generator user value 
execution reuse thread corresponds exactly reuse opportunity 
note program path may execute multiple reuse threads running paths giving rise multiple opportunities see definition page 
informally estimation problem determine reuse threads executed program input 
notice moment restricting specific profile format measure behavior program input 
fact selecting designing profile inherent part solving estimation problem 
section evaluates existing profile formats justifying selection edge profiles 
hand section designs new profile format 
introduces running example 
estimation problem illustrated program frag ment vng form see chapter loads detected refer memory location denoted symbolic name 
node users generators value 
nodes kill value may write alias analysis 
program executes loads intercepting killing store load redundant eliminated 
load load kill load estimation problem statement amount reuse loads 
constituent sub problems kind program profile collected run time 
combine collected profile static analysis 
estimation problem determine times program input executes reuse thread denotes usual non zero repetition 
time threads taken exactly load removed 
note vng separable symbolic name threads referred paths 
applications estimators 
algorithm solves estimation problem called estimator 
dissertation estima tors fold application profile directed transformation 
chapter develops pre transformation algorithms overcome kill tations traditional pre code motion 
cfg restructuring algorithm called pre expensive achieving optimal re redundancies 
control speculation algorithm called pre ms inexpensive sub optimal 
decide options expected run time benefit known 
restructuring removes redundancies run time benefit restructuring equals amount reuse program exactly precise estimate bounded estimator 
tion turns estimator determine carry speculation transforma tion way benefit equals exactly lower bound estimate 
comparing lower upper bounds estimators identify speculation sub optimal facilitating trade offs restructuring speculation 
evaluation vng 
chapter uses estimators measure accuracy vng finding value recomputation 
incorporating profile dataflow analysis estimator computes dynamic terms amount reuse exposed representation subsequently collected dataflow analysis see section 
chapter compares estimate ideal amount value flow program obtained reuse profiling done input 
algorithm reuse profiling developed chapter 
comparing exposed collected amount ideal amount shows fraction reuse detected reuse profiler static analysis indicates precision framework 
ideal estimator 
process designing estimator involves designing selecting profile format devel oping algorithm combines profile result dataflow analysis 
ideal estimator algorithm properties 
accuracy dynamic optimization opportunities counted estimator equal occurred execution program unaffected profile imperfections estimator approximations 
dataflow independence profile collect measurements independent dataflow facts counted estimator reuse loads constants 
dataflow independence enables reusing profile optimizations eliminates need perform profiling step re analysis estimation stages 
low cost profiling estimator profile format requires simple program tation incurs low execution overhead profiling 
low cost profile processing information needed estimator simple inexpensive extract profile 
sharability requiring specialized algorithms estimator rely algorithms commonly implemented optimizing compilers reduce implementation effort 
profile information general shared parts compiler 
program profiles 
step developing estimator select design run time program profile 
review commonly profile formats describe information collect highlight properties 
profiles profile types program profiling originally developed enhance control flow optimizations 
optimizations profile learn control flow behavior program frequency procedures statements executed 
control flow profiles performing compile time branch prediction ii identifying frequently executed hot program regions profile type edge profile path profile program path profile information collected cfg edges acyclic cfg paths control trace profiling cost overhead profile accuracy size low reported medium mb full processing low medium table control flow profiles 
goal enlarging scope traditional optimizations inlining trace scheduling iii focusing effort static analysis hot program regions bgs 
contrast control flow optimizations estimators focus value flow behavior pro gram 
determining frequency control flow paths compute frequency value flow paths called threads vng representation control flow paths reuse exists 
paths determined static value flow analysis 
accordingly section divides profiles control flow profiles value flow profiles 
control flow profiles received attention 
profile formats relevant solving estimation problem edge profiles path profiles program path profiles 
value flow profiles ob serve values computed program 
common kinds include address profiling value pro filing 
assist static instruction scheduling compiler supported value prediction 
value flow profiles expensive control flow profiles independent dataflow information estimated deliberate decision base estimators control flow profiles 
discuss control flow profiles optimizations developed 
various profile types developed depending optimization different program region profiled 
profile static branch prediction attempts predict direction branch previous program runs mh ff 
optimization requires counts nodes edges control flow graph 
profile capturing information called edge profile 
edge profiling procedure inlining ags requires execution frequencies call site 
sophisticated static branch predictors measure correlation multiple branches re profiling control flow paths ys 
path profiles useful forming instruc tion scheduling region schedulers approximate information edge profiles hmc mlc 
path profiles collect statistics short ys acyclic bl cfg paths 
larus lar developed program path profiling captures entire control flow trace pro gram 
profiling algorithms compresses trace forming grammar string executed trace 
profiling techniques 
control flow profiles summarized table 
briefly review existing approaches collecting control flow profiles 
common technique instrument ing program instructions increment counters 
algorithms differ counters incremented maintained 
edge profiling efficient technique sampling execution program efficient precise technique instrumentation 
profiles sampling edge profiling 
edge profiles 
edge profile collected program instrumentation overhead bl 
hardware sampling approach edge profiles cost head abd 
software sampling approach developed transient removable instrumentation ts transient interpretation native instructions 
cost comparable hardware approach percent 
path profiles 
path profiles collected relatively efficiently compared low cost edge profiling 
path profile obtained overhead bl 
program path profiles 
larus compression technique best complete profiling tech nique 
achieves low memory consumption compressing trace line grammar path frequencies determined decompressing trace 
compared edge path pro files cost collecting program paths relatively high slowdown 
compressed profile size considerable mb gcc 
related existing estimators 
review existing estimators 
related divided kind profile information 
common property control flow profiles 
fore dataflow independent profile program performing value flow analysis estimation 
edge profiles ramalingam ram offers existing systematic method estimating dataflow solution 
edge profiles frequency analysis derives probability data flow fact holding cfg node 
probability replaces informative boolean data flow lattice 
frequency analysis directly applied vng representation value flow converted data flow represented domain frequency analysis handle 
accuracy 
estimators frequency analysis bound inherent edge profile error quantifying error clear close frequency analysis actual estimate 
sharability 
frequency analysis requires elimination style dataflow analysis solver commonly implemented existing compilers estimators rely control flow reachability network flow algorithms easier implement 
processing cost 
operating real numbers bit vectors frequency analysis expected slow 
estimators delay floating point computation value flow patterns abstracted summarized 
estimators offer alternative frequency dataflow analysis general estimators compute node estimate cheaper fit needs pre transformations 
path profiles gupta gbf gbf gbf various versions profile directed pre exploiting various hardware features 
common algorithms guided ball larus path profiles bl bms 
algorithms explicitly compute estimate estimate computed implicitly fly dataflow analysis 
accuracy 
unfortunately path profiles remedy correlation problem partially measure execution frequencies acyclic program paths 
result estimating value flow cyclic paths incurs branch correlation error measured paths may fully overlap detected reuse paths 
capture part correlation needed reconstruct frequency value flow path 
processing cost 
algorithms maintain dataflow information independently executed path program slowdown factor due making optimization profile directed roughly equals number acyclic paths non zero execution frequency 
experiments gbf show procedures subset spec executed paths proce executed paths 
sharing 
algorithms phrased bit vector problems require special dataflow solvers 
collected path profiles reused instruction scheduler procedure inliner 
program path profiles larus program path profiler lar estimator 
provides algorithm determining frequency subpath compressed profile 
accuracy 
path profiles completely eliminate branch correlation error 
represent ideal profile value flow optimizations 
processing cost 
unfortunately currently algorithms determining frequency set sub paths represented regular expression paths 
cyclic paths commonly carry value reuse estimated optimizer 
hope ideal estimator 
summarize discussion existing practical accurate estimator exists 
accurate estimator approaches immediately suggested tical 
follow dataflow analysis complete redundancy elimination chapter followed re profiling obtain optimized dynamic computation count 
complete redundancy removal restructuring cfg approach impractical due code growth incurred restructuring potentially infeasible 
second approach enumerate value reuse paths detected value flow analysis look frequencies trace produced program path profile 
dataflow analysis may detect infinitely reuse threads due loops need enumeration certain threads contained thread 
appears accept deal error inherent program profiling 
section presents estimator algorithms reduce inherent error guarantee bounds 
hierarchy estimators section outlines estimators defines concepts common estimator algorithms 
describe properties estimators show achieve nearly goals ideal estimator 
estimators follow main design choices necessitating 

edge profiles 
pragmatic reasons estimators edge profiles 
edge profiles inexpensive collect store achieve low profiling cost 
measure control flow behavior program achieve dataflow independence profiling 
edge profiles widely procedure inlining instruction scheduling justify amortize profiling cost achieving sharability 
load load kill load running example annotated edge profile 

compute error bounds 
unfortunately edge profiles contain inherent profiling error 
capture branch correlation reconstruct path frequencies accurately actual execution 
consider running example annotated edge profile shown 
paths value reuse 
edge profile precisely determine frequency edge profile path frequency range path contribute count edge large profiling error 
edge profiles prevent estimators achieving true accuracy estimators gain confidence edge profiles computing single imprecise estimate lower upper bound accurate estimate assuming pessimistic optimistic control flow scenario 
bounds limit inherent error accurate estimate lies 
tighter bounds precise estimate obtain 

hierarchy estimators 
amount profiling error appears resulting estimate depends inherent edge profile error 
edge profile imprecise control flow behavior program skewed highly small number paths edge profile may describe dominant paths precisely 
consider extreme example cfg node executed 
program edge profile precise complete trace 
control flow complexity value flow threads 
value flow threads require edge profile 
consider node 
kill reuse value flow paths pattern simpler quantify edge profile load redundant preceded estimate load frequency frequency 
amount error induced estimate varies due factors full power algorithm may needed 
estimators provide scalable solution influence factor focus tighten scalable effort estimator bounds places program threads complex control flow pattern 
scalability achieved estimator algorithms differ error bounding precision run time complexity shown 
practical reason developing hierarchy increasingly better estimators simpler faster estimator yields loose bounds run better slower estimator guarantee new bounds worse 
resorting stronger algorithm necessary results low processing cost 
furthermore estimators share common paradigm rely information algorithms pathfinder stages providing sharability 
having established design choices computing error bounds edge profiles hierarchical manner formulate edge profile estimation problem 
term profile refers edge profile 
start control trace sequence executed nodes occurs number times path occurs trace execution frequency execution 
similarly define occurs value flow thread occurs occurs path 
definition edge profile cfg start profile trace induces profile denoted iff occurs 
conversely trace permitted profile induces 
recall definition value reuse threads page vng sub threads originating generator vng node sinking user vng node crossing kill vng node 
trace determines dynamic amount value flow program 
precisely determines estimate user node executed preceded generator node crossing kill node 
estimation problem bound estimate 
bounds computed considering pessimistic optimistic control flow scenario permitted profile 
words goal find smallest largest amount value flow possible traces permitted edge profile 
definition estimation problem estimation problem tuple start value name graph 
set reuse threads see definition page edge profile control flow graph start occurs minimum assignment 
definition bounds tight relative error occurs estimation problem compute lower upper bounds amount reuse permitted edge profile example illustrates estimation problem 
reuse threads correspond optimization opportunities removal redundant load operations 
program follows reuse thread exactly load operation removed 
reuse threads estimated specified generator loads stores user loads kill stores sets problem compute minimum maximum number reuse opportunities permitted annotated profile 
words want find maximum minimum assignments frequencies reuse threads frequency assignments permitted edge profile 
enumerating reuse threads reader convince example maximum assignment entirely attributed imperfections edge profile error size depends shape value flow threads explained bullet page 
best estimator tight separable vng single symbolic value vng 
general vng estimation problem may np hard estimators compute approximation 
estimators guarantee competitive ratio approximations 
precision measured relative error practice relative error second best estimator 
overview estimators 
computing estimate prescribed definition involve iterating traces permitted profile possible reuse threads 
direct approach impractical may permitted traces infinitely reuse threads denoted 
dealing individual traces threads estimators find summary program points summarize groups paths identical value flow properties 
properties value gener ated incoming paths value generated incoming paths value reused outgoing paths 
lemma summary points vng set reuse threads 
precise pre cmp cmp cmp cmp estimators precision ordering 

producers 
vng edge producer reuse generated generator control flow paths reaching source 


vng edge reuse generated control flow paths reaching source 

consumers 
vng edge consumer value flows edge user control flow paths originating sink 
estimators differ place summary points 
estimator sets producers consumers denoted respectively 
remainder section focuses placement summary points 
compute actual value upper bound estimators determine reuse flow generators set consumers points 
arrive lower bound determine reuse free flow reach consumers stealing bms reuse flowing sources 
note contrast generators users kills definition producers consumers definition 
triple states problem specifying value flow patterns vng triple represents problem statement enable efficient accurate computation estimate bounds 
producers summarize generators consumers summarize users summarize kills reuse free path 
overview estimators 
estimators differ compute sets pre account possible value flow 
differ error ad dition inherent error allow constructing pessimistic optimistic reuse scenarios 
brief overview individual estimators starting conceptually simplest 
estimator hierarchy estimator names explained 
pre simplest estimator 
mirroring closely partial redundancy elimination transformation see section producers taken instructions generate reuse instruc tions consumers partially redundant computations user nodes points operation inserted pre compensate partial 
determine generators may produce steal reuse consumer computation pre uses graph reachability 
pre estimator uses trivial placement summary points 
smarter placement improve bounds exploiting observation reuse threads estimated precisely edge profile 
example producer post dominated followed control flow path consumer intervening kill reuse producer reach consumer reuse stolen 
consequently producer frequency represents precise estimate threads connect producer consumer considering concert 
threads edge profile precise safely excluded worst case control flow scenarios 
central idea remaining estimators isolate reuse threads edge profile precise focus reducing error error containing threads 
effective factoring threads accomplished placing summary points close possible starting pre position summary points producers delayed moved forward consumers hoisted moved backward 
points meet threads represented precisely summarized frequency meeting edge 
conversely points meet error remains minimized lengths considered threads minimizing number branches threads reducing branch correlation error induced solution 
interesting note closest placement summary nodes coincides cmp re described detail chapter identify obstacles complete pre transfor mation 
cmp region smallest multiple entry multiple exit region entry edges divided producers exits consumers strict non consumers 
smallest region finds desired closest placement summary points 
cmp region precisely divides reuse vng uncertain definite 
node cmp error reuse produced incoming paths consumed outgoing paths 
consequently knowledge branch correlation cmp possible determine incoming reuse flowed consumers profiled program execution 
conversely node outside cmp region error free value produced stolen incoming paths consumed outgoing paths case edge profile sufficient 
summarize cmp region contains branch correlation error inherent edge profile 
cmp estimators focus reducing error contained cmp region different variations optimistic pessimistic approach follows cmp estimator conservatively assumes single cmp name entries exits mutually reachable 
false reachability may connect consumers spurious producers yielding loose bounds 
cmp attacks false reachability partitioning cmp region connected cmp subregions graph reachability cmp entries exits 
individual connected treated cmp estimator 
cmp exploits entry exit reachability 
compared cmp removes false reachability connected cmp computing amount value flow network flow problem 
cmp region stands code motion preventing region 
term cmp introduced chapter getting ahead 
chapter follow chapter relies estimators develop transformation algorithms 
name cmp reflects transformation estimation historical reasons transformation algorithms developed earlier bgs estimators bgs 
cmp exposes network flow computation cfg edges cmp just summary entry exit reachability information exploiting refined notion reachability accounts reuse flow cmp entries exits just reachable 
sections detailed estimator algorithms section separable simplify presentation section general 
estimators separable section assumes separable vng vng nodes dataflow transfers value names 
transfers name handled separately slice vng cfg properties 
handle general minor algorithmic extensions needed delay section basic principles clear 
recall notation introduced previous section 
estimation problem estimator algorithm pre cmp cmp cmp cmp returns upper lower bounds accurate estimate denoted respectively 
problem specifies value flow sets vng nodes generators users kills estimate measures frequency free threads 
estimators summarize value flow finding placement summary points producers consumers 
overload edge profile extending domain vng nodes edges straightforward way 
recall definition availability anticipability dataflow properties describe value flow computed incoming path reused outgoing path respectively 
lattice defined definition properties meaning 
available paths 
may anticipability antic defined analogously 
placement summary points computed dataflow solution availability anticipability see definition page 
lemma shows particular selection producers producer available 
similar relationships hold consumers 
lemma proof 
definition producer generates value time executed 
value generated path leading producer 
availability solution 
similar arguments apply consumers 
pre pre pre avail avail may pre pre pre pre estimator 
pre estimator 
pre estimator calculates estimate independently consumer point individual estimates total estimate obtained sum 
pre estimator mirrors pre transformation see chapter consumers vng edges sink optimizable statements user nodes 
producers sources redundancy 
computed independently consumer point producers consumer denoted vng edges emanate generators nodes may reach crossing kill generators backwards reachable kill free thread 
set consumer denoted vng edges computation inserted partially redundant fully redundant 
computed graph reachability 
compute upper bound consumer assume optimistic control flow scenario produced values reach flow scenario frequency reuse threads equals lower frequencies 
lower bound assumes worst case flow reachable flows minimizing frequency executes value flowing producers stealing value flowing producers 
formulas computing pre estimate shown 
note operator pre serves lower bound non negative 
example pre estimator apply pre estimator vng 
see ex ample definition problem 
producers consumers pre estimator load load kill load summary points producer consumer example pre estimator 
pre pre pre pre pre pre bounds consumers trivial redundant reaching producers fully redundant edge profile error affects partially redundant consumer producers yielding bounds consumer total estimate pre pre pre pre error 
smallest tightly bounded error 
cmp estimators 
large error produced pre estimator entirely due error edge profile 
loose bounds caused pre crude placement summary points suffers overbooking producer multiple consumers 
running example node acts producer common consumers consume value flow produce produces units consume units see 
overbooking removed dividing producer contribution paths leading producer different consumers 
cmp estimators contribution divided delaying krs producer 
delaying moves producer forward paths far remains producer definition far path generates value 
shows producer delayed edges new producers effectively dividing contribution consumers 
note consumers cause pre imprecision 
example consumer claims able consume units equal weight units reach due kill node blocks units value flow 
flawed flow accounting fixed hoisting consumers 
hoisting moves consumers backwards far remain consumers delaying moves producers 
producers delayed consumers hoisted summary points optimally placed 
note producers consumers pre placement optimal 
placements optimal sense summary points moved closer forced path contradicts definition definition 
result paths producers consumers short possible minimizing number conditional branches paths branch correlation error appearing estimates 
producers consumers meet creating unit length paths edge profile introduces error 
example frequency unit length producer consumer path trivially precisely determined edge profile 
hand summary points meet error may appear estimate 
put principles solid footing observe summary points enclose vng region 
region multiple entry edges multiple exit edges 
entries divided producers exits divided consumers strict non consumers 
summary points optimally placed region smallest region contains profiling error 
turns region precisely coincides cmp region chapter 
cmp maximizes number paths excluded worst case assumptions branch correlations thread passing outside cmp region estimated precisely edge profile 
conversely path crosses region may profiling error profiles 
rephrase definition cmp region stated definition terminology chapter 
formally cmp subgraph vng delimited entry exit edges node cmp region value generated incoming threads delay producers hoist source program annotated edge profile 
load load cmp estimator control flow reachability 
kill kill load kill load load load actual flow capacity weak link exposed infinite flow capacity cmp region reuse memory location kill cmp estimator frequency reachability 
computing estimates running example 
entries exits cmp cmp region nm nn xn xm avail avail antic antic outgoing threads 
cmp region identified solving problems anticipability availability defined definition 
definition cmp region start vng 
cmp region set nodes cmp region may may lemma entry exit edges cmp region 
cmp region set entry edges exit edges 
entry available denoted acting producers available denoted acting 
similarly exits anticipated denoted acting consumers anticipated denoted participating estimator calculations 
may cmp region divides value flow definite uncertain components 
definite component error equals sum frequencies definite producers defined 
salient property definite producer value flow produces consumed 
bounds uncertain component computed cmp region 
cmp estimators separable cmp cmp cmp cmp formulas computing uncertain component estimate 
example cmp region definite estimate cmp region running vng example shown 
cmp region excludes worst case considerations threads estimate computed edge profile precisely definite producer points definite producers provides units reuse 
producers definite reuse fully consumed respectively 
definite reuse definite reuse remains cmp estimators 
cmp estimators differ compute cmp cmp bounds uncertain component estimate 
cmp estimators uses different notion reachability reducing amount flow may reach consumers producers estimators obtain refine upper lower bounds 
approaches taken cmp estimators compared 
cmp cmp en en en en ex maxflow maxflow cmp en ex ex en ex cmp cmp estimators separable algorithms computing uncertain component estimate 
formulas overloaded mean frequencies corresponding cmp entries exits 
denotes th available entry cmp denotes th entry th connected cmp subregion 
maxflow denotes maximum flow vertices shown networks 
cmp assumes entries exits mutually reachable 
cmp separates connected eliminating false reachability 
cmp exploits intra cmp reachability max flow computation 
cmp exposes max flow intra cmp edges including actual profile weights 
cmp estimator 
simplest cmp estimator 
cmp identifies cmp entries exits minimize computational cost assumes cmp entry exit pair mutually reachable 
upper bound scenario resulting assumption entries producers con 
lower bound follows conservative assumption cmp region fully connected 
bounds computed pre estimator 
gives formulas 
cmp efficient computes antic avail data flow solutions 
entries exits identified examining data flow solutions locally node 
cost computing solutions entries exits amortized needed pre transformation chapter 
example cmp running example cmp yields cmp cmp total estimate cmp cmp improves pre upper bound removing overbooking producer reducing error 
note cmp better pre example strictly superior general indicated hierarchy graph 
cmp estimator 
estimator improves precision cmp eliminating false entry exit cmp cmp reachability assumed cmp identifies connected cmp subregions partitioning pro consumer sets 
smaller sets result overestimation considering worst case scenarios 
bounds computed separately connected cmp summed 
experi ments partitioning cmp region produced highest increase precision 
result cmp recommended estimator practical applications due cost precision balance see section empirical observations 
cmp estimator complex cmp addition computing avail antic identifying cmp entries exits compute reachability cmp entry exit pairs producing reachability graph find connected subgraphs reachability graph find connected cmp subregions 
fortunately analyses needed pre transformation guide speculation see section 
example cmp running example cmp region connected cmp estimate identical cmp cmp estimator 
estimator adds precise handling intra cmp reachability 
cmp region represented bipartite graph entry exit nodes connected thread connecting see 
bipartite graphs connected network super nodes en en ex connect producers consumers respectively 
flow capacities edges connecting super nodes mirror frequency cmp entry exit edges capacity intra cmp edges conservatively set infinite 
equipped network compute upper reuse bound maximum flow en ex 
similarly amount reuse stolen consumers max flow en ex 
compared cmp cmp estimator identify connected sub regions computes costly network flow 
note network construction implicitly partitions cmp connected sub regions 
example cmp network running example shown 
cmp exit edge reachable cmp entry edge reuse stolen cmp improves lower bound cmp en ex cmp maxflow cmp cmp maxflow en ex error 
cmp estimator 
entry exit pair may graph reachable reachable thread may sufficiently frequency reachable 
pair cmp entry cmp exit 
path connecting contains weak link edge low frequency 
value flow entry weak link prevents flow saturating exit units reuse exploited 
account weak links suffices expose max flow computation inside structure cmp edge level including edge frequencies shown 
example cmp weak link accounted upper bound previous estimator improved cmp en ex cmp maxflow cmp cmp maxflow en ex error 
note example cmp estimator produced tight bounds exist control traces induce edge profile estimate equals cmp estimate equals cmp 
control flow paths value threads cfg program 
paths cfg 
vng program cmp region 
computing estimate general vng 
figures represent concrete example estimators 
estimators general vng previous section estimators separable vng 
separable vng threads considered isolation bits separable bit vector problem 
general vng threads may split underlying control flow paths split signifying value identified multiple synonymous names 
thread splitting qualitatively changes vng properties 
particular considered overbooking generator consumers separable vng may considered legal general vng 
section extends estimators handle complications general 
example illustrates issues raised general 
consider control flow paths shown 
paths nodes equivalent vng correctly placed thread 
vng shown 
nodes thread synonymous incoming paths 
differ path result thread going split 
consequence thread splits generator node provide value flow execution frequency 
consider node 
node generator frequency provides value flow consumers frequency 
reason feed value flow duplicated crosses node thread split 
result split incoming value flow duplicated outgoing threads nodes 
general vng kinds thread splits 
split induced control flow just separable vng 
control flow split frequency value flow divided outgoing threads 
second split induced synonyms 
synonym split frequency duplicated 
general vng flow entering region need equal flow leaving region case separable vng 
reason value flow may duplicated region 
consider cmp region 
sum entry edge frequencies sum exit edge frequencies 
difference exit entry frequencies equals amount flow duplication cmp region 
amount duplication important value generalize estimators 
pre estimator 
formulas computing pre estimate separable shown 
algorithm remains consumer finds producers 
compared separable setting difference overbooking legal value flow due flow duplication discussed 
cmp estimators 
extensions needed handle merging threads 
hoisting consumer summary points guaranteed placed points exactly user reachable outgoing control flow path presence thread merging 
second accounted duplication flow region 
frequency cmp exits may greater frequency cmp entries entries tell flow produced stolen 

placement consumers 
hoisting consumer points guaranteed consumers placed points exactly user reachable outgoing control flow path value name thread condition separable setting coincide 
justification refinement multiple users reached single control flow path 
frequency consumer point represents amount users reachable consumer 
consumers hoisted node consumers merged consumer frequency bar summarized users 
better example edges emanating thread merge node anticipated 

flow duplication cmp region 
cmp region sum entry edge frequencies sum exit edge frequencies 
gives amount flow duplicated cmp region 
duplication happens inside region fraction carries value reuse fraction reuse free depending flow originated producer entries entries 
cmp cmp cmp fractions determined inside cmp region examined estimators conservatively increase producers frequencies frequencies 
contrast cmp estimator exposes individual inner edges region account duplicated flow producers versus 
computing cmp reduces estimate generalized version network flow problem defined 
cmp estimators formulas remain valid generalized setting 
formulas uncertain component cmp estimators change shown 
cmp estimator computes entries exits assuming belong connected cmp region 
cmp estimator finds connected sub regions computes th sub region 
cmp estimator accounts duplicated flow adding node network reflects intra cmp reachability 
added node denoted increases amount flow reach consumer exits producer super node super node 
cmp cmp en en en en ex cmp ex cmp maxflow en ex maxflow en ex cmp estimators bi distributive algorithms computing uncertain component estimates 
algorithms generalize algorithms separable see 
cmp adds amount flow duplicated cmp region denoted produced flow stolen flow 
cmp similar computed connected sub region 
cmp adds flow consumers adding channel super nodes consumers 
flow capacity added node 
dotted lines mark edges inherited separable cmp 
cmp computes bounds generalized version max flow problem nodes duplicate distribute incoming flow 
cmp estimator cmp estimator exposes max flow computation inner cmp edges 
account flow duplication introduce generalized max flow problem called max dup flow nodes network preserve incoming flow outgoing edges usual way duplicate 
definition duplicating flow network duplicating flow network directed graph vertices divided flow preserving vertices flow duplicating vertices 
edge non negative capacity 
convenience assign capacity nonexistent edges 
distinguish special nodes source sink network respectively 
definition max dup flow problem duplicating flow network implied capacity function source sink 
flow integer valued function satisfies properties 
capacity constraint 
flow preservation flow preservation nodes 
flow duplication flow duplication nodes reducing estimation problem max dup flow problem 
reduction estimation problem max dup flow problem straightforward 
vng node synonym split node flow duplicating node created 
vng nodes create flow preserving node 
computing max dup flow problem 
algorithm computing max dup flow precisely 
approximation computed reducing max dup flow problem standard max flow 
reduction similar cmp 
reduction adds units flow cmp region compared cmp fine grained fashion 
connecting node cmp region connects flow duplicating nodes cmp region 
accounts weak links cmp region 
experiments compares precision estimators 
benchmark plots weighted reuse obtained estimators cmp implemented 
reuse broken parts left bars represent definite reuse component benchmarks normalized 
third fourth bars lower upper bounds uncertain reuse 
error go ksim gcc compress li ijpeg perl vortex tomcatv pre cmp swim cmp cmp int fp cmp su cor hydro smaller error experimental comparison estimator precisions 
benchmark plot shows precision estimators cmp estimator implemented 
precision dark bar bottom dark bar gives lower bound returned estimator normalized top dark bar upper bound 
benchmarks left integer programs benchmarks right floating point programs 
floating point benchmarks right nearly uncertain reuse due simple control flow 
hand reuse integer benchmarks significant uncertain component 
observed algorithms profiling error greatly reduced 
note theory cmp strictly precise pre precision ordering shows performs better practice 
fact cmp appreciably better cmp 
due simplicity cmp may estimator choice 
average error pre cmp 
important observation estimator precision strongly dependent pointer aliasing information 
interrupting reuse paths killing stores induce cmp regions entries exits increasing amount uncertain reuse 
comparison selected configuration load reuse analysis caused largest estimator errors kill set array pointer store procedure call see section 
correlation profiling cmp correlation profiling estimator edge profiles 
assumes profile information correlates cmp entries exits sufficiently avoid profiling error 
show profile information may fully eliminate profiling error 
cmp region specify information profiler enable computing reuse branch correlation error 
coming back observe precise amount uncertain reuse equals number times producer entry followed consumer exit 
measuring pair wise correlation cmp entries exits captures branch correlation affects amount reuse 
data flow analysis identifies cmp regions profiler instrument program collect pair wise information 
pair wise profiling efficiently performed prior knowing shapes cmp regions profiled program open question 
estimators chapter compute edge profile bounds cumulative frequencies reuse threads detected value flow analysis 
estimators conceptually simple reconstruct path frequencies find program points summarize paths 
points value flow dependent value flow patterns simple value flow holds paths handled code motion pre edge profile errors may appear edge profile 
experimental results suggest imprecise data flow independent profiling followed smart estimation algorithms successful strategy profile directed optimization 
desires precise data flow dependent profiling correlation profiling described section alternative choice 
specifically experiments suggest cmp estimator offers ideal balance tween precision computational cost 
average cmp able bound inherent profiling error sufficient precision profile directed optimization 
compared complex estimators cmp linear asymptotic complexity 
bounding branch correlation error estimators expose inherent imprecision edge profiles 
experiments suggest edge profiles precise load reuse optimization 
result extends value flow prob lems need path profiles exponential factors value flow optimiza tions 
considering inherent edge profile error small suggested experiments maxi mum amount error result ramalingam frequency analysis correspondingly small result analysis falls lower upper bounds 
chapter intra procedural removal redundancies chapter describes stage pathfinder optimizer program transformation task perform actual optimization program 
redundant computations de previous stages program transformation stage modifies program values reused redundantly recomputed 
transformation known partial redundancy elimination pre removes redundancies partial path specific 
partial redundancies include common subexpressions loop invariant computations pre important component global optimizers 
ideally transformation remove computations detected redundant 
complete transformation possible decidable may require different code transformation optimizable program path requires separation individual optimizable paths may turn incur prohibitive growth program code size 
avoid code growth practical pre algorithms restrict toolset code motion method moves redundant instructions separate paths 
price practicality failure remove redundancies completely 
experimental observations show penalty severe 
static terms loop invariant statements eliminated loops code motion 
dynamic terms traditional code motion pre eliminates half redundancies strictly partial 
chapter focuses achieving nearly complete pre incurring acceptable code growth 
goal achieved combining strengths transformation methods code motion control flow restructuring control speculation integrated parameterizable way induces family transformation algorithms built abstraction 
algorithms characterized profile independent profile guided 
main profile independent algorithm integrates economical code motion pow restructuring 
contrast existing complete techniques algorithm resorts restructuring merely remove obstacles code motion carry entire optimization 
large class problems algorithm achieves minimal code growth 
program profile available additional code growth reduction possible sacrificing completeness dynamically insignificant 
profile estimators chapter main profile guided algorithm combines code motion control speculation 
speculation overcomes obstacle code motion separating paths inserting computations program paths execute original program 
estimators ensure potentially counterproductive transformation program improved impaired 
fact estimators maximize optimization benefit speculation 
algorithm balances transformations economical code motion fails unsafe speculation impairs program restructuring 
practice algorithms chapter achieve near complete redundancy removal little code growth 
chapter concerned reuse intra procedural value flow 
inter procedural attacked chapter 
overview pathfinder stages far detected reuse values turn representation exposed value flow threads analysis marked value reuse threads estimators weighted reuse threads profile information 
task stage exploit value reuse transform ing original program values reused redundantly recomputed 
transformation known partial redundancy elimination pre proposed morel 
removing computations partially redundant pre responsible handling partial flavor path sensitivity reuse available paths see section 
formally partially redundant computations vng user nodes reuse detected necessarily paths 
see definition description reuse threads 
definition partial redundancy vng node partially redundant reuse thread 
shown computation partially redundant may see definition pre attractive targeting computations redundant program paths subsumes generalizes important value reuse optimization global common subexpression elimination loop invariant code motion 
furthermore vng uniformly represents kinds value flow value recomputation repeated loads correlated branches pre serves value flow framework unified program transformation technique 
ideal optimization goal remove computations detected redundant 
program transformation possible may require isolation optimizable program paths may cur prohibitive code growth due exponential path explosion shown section 
practical pre algorithms code motion economical transformation reorders instructions change shape control flow graph prohibiting expensive isolation individual paths bc ds ds krs 
price restriction code motion failure remove detected redundancies 
theory optimal code motion algorithm krs breaks loop invariants loops preceded conversion path separation 
practice half dynamic computations strictly par tially redundant redundant paths left unoptimized due code motion obstacles experiments 
chapter achieves nearly complete pre conceptually analyzing morel code motion algorithm systematically addressing limitations 
result family pre algorithms combines strengths transformation methods code motion economical control flow restructuring powerful control speculation potentially harmful 
methods abbreviated respectively 
step complete pre affordable code growth algorithm integrates code motion restructuring denoted pre 
algorithm allows complete removal redundant expressions minimizing code duplication 
contrast existing complete tech niques weg weg ste resorts restructuring merely remove obstacles code motion carry entire optimization eliminating unnecessary code duplication 
resulting code growth minimal large class problems 
spec code growth times smaller pure restructuring approaches denoted pre 
prior systematically treated integration code motion transformation 
pre algorithm controls extent code duplication restricting code motion preventing cmp region localizes adverse effects control flow desired code motion 
illustrates algorithm pre optimization loop 
true break example loop 
assume statement loop defines variables 
computations loop invariant 
loop invariant removed loop code motion executed path execute original program 
frequency path higher paths execute optimization slow program 
avoid counterproductive transformations traditional pre disallows unsafe code motion 
desired optimization possible cfg restructured 
pure restructuring pre duplicates node value available strictly partially paths 
duplication splits partial redundancy full redundancy redundancy weg weg ste 
resulting program shown 
fully optimized restructuring unnecessarily peeled entire loop body 
program induces separable vng viewed cfg expressions vng computations named 
ex ex code motion en en source program 
speculation optimization code motion speculation 
ex ex ex en en ex optimization code motion restructuring 
duplicated fully redundant duplicated allow code motion ex en ex code motion duplicated complete optimization duplicated partial optimization optimization 
restructuring 
ex en optimization code motion restructuring 
trade variant 
pre integration code motion control flow restructuring control speculation 
contrast pre algorithm achieves completeness smaller duplication scope see 
apply economical code motion transformation full extent resorting restructuring merely enable desired code motion case hoisting loop 
hoist sufficient isolate offending path 
necessary scope duplication computed cmp region short code motion preventing region highlighted 
restructuring achieved duplicating region hoisting performed im pairing offending path 
opportunities value reuse remain resulting optimization complete 
contrast basic blocks duplicated 
profile guided pre dynamic count eliminated computations measure optimization benefit profile guided algorithms trade optimization code duplication 
reduce code growth profiling different ways identify infrequently executed paths reuse 
reuse paths worth ing cost 
identify infrequently executed program paths reuse 
paths may effectively disregarded hoisting computations 
hoisting paths constitutes control speculation 
profile guided algorithm denoted pre ms combines motion speculation 
restructuring code motion fails compensate partial redundancy full redundancy compensation done speculatively inserting computations program paths contain original program 
insertion speculative paths taken cost insertion amortized removed computation 
speculation paths impaired optimized 
net benefit speculation depends difference frequencies improved impaired paths computed profile 
example profile reveals offending impaired path frequent paths execute speculatively hoisted loop shown 
profile guided pre algorithm complete pre practical limiting code growth 
algorithm denoted pre restructures selectively 
sacrifices value reuse op infrequent require significant code duplication 
pre algorithm illustrated optimization serves starting point 
shows complete optimization performed pre duplicating shaded cmp region subsequently performing code motion 
program control flow structure affects optimization adversely affects cmp region larger code duplicated 
size duplication outweighs run time gains utility function pre algorithm scaled back select smaller set nodes duplicate yielding pre algorithm 
example incomplete pre size basic block assumed greater justified frequency value reuse flowing 
chapter presents pre msr algorithm balances methods 
pre msr uses restructuring speculation done beneficially 
experiments show pre msr near complete pre little code growth 
control speculation viewed unsafe version code motion 
minimal conversion conversion duc common pre processing transformation enabling code motion loop invariants loops prohibit desired code motion muc 
duc path separation converts loops loops duplicating part loop body loop exit condition 
duc enables optimization loop invariants 
additionally duplication scope larger necessary 
interesting note pre algorithm subsumes fully generalizes duc 
con sider loop 
commonly duc fail 
smarter duc peel unnecessarily entire loop iteration just pre algorithm shown 
known duc enable hoisting 
contrast pre produces necessary conversion shows conver sion necessary hoist shows conversion required 
pre conversion minimal duplication statements hoisted 
figures show separate conversions conversions naturally composed described chapter 
note pre successful reducing code growth profile guided speculation pre ms works better experiments show removes nearly cies code growth 
furthermore pre may generate irreducible programs 
irreducibility may produced restructuring algorithms including pre manifest 
irreducibility corrected section presents simple reducibility preserving version pre 
organization chapter section establishes groundwork analyzing limitations standard code motion pre motivating solution 
pre algorithms 
chapter presentation simplified assuming separable vng section general vng section 
section algorithms divided profile independent profile guided 
section handles various practical issues irreducible graphs hardware support 
section experimentally evaluates algorithms section concludes summary results discussion related 
analysis morel algorithm motivate approach taken section intuitively describes principle code motion pre denoted pre conceptually analyzes fails explains ap proach overcoming limitations 
illustrates principle pre 
computation partially redundant cause reuse thread leading 
cfg terms control flow path computed killed 
pre optimizes hoisting away reuse thread 
hoisting inserts computation incoming non reuse threads turn partial redundancy full 
transformation completed initializing fresh temporary variable carry reused value replacing original computation 
illustrates code motion fails 
shows partially redundant reuse thread 
program hoisted reuse thread shown 
slight modification program causes code motion fail 
reuse thread partially redundant 
optimization source program pre reuse thread hoisted dashed arrow 
reuse thread 
principle code motion pre transformation 
version reuse free thread 
pre fails inserted free thread 
initialize insert replace desired code motion code motion blocked reuse free meet 
reasons failure code motion pre 
loop changed loop shown desired hoisting fails 
hoisting fails placed free path compute value reuse value amortize cost insertion 
avoid impairment free path pre disables unsafe code motion code motion blocked enter free path shown 
shows consequences unsafe hoisting 
insertion case control speculation executed program execute original computation speculating control reach original computation amortize cost speculative insertion 
pre profile insensitive safely beneficially speculation 
summarize discussion pre code motion orthogonal deficiencies 
safe optimization model conservative 
guarantee program runs slower optimization allows improving reuse paths paths impaired 

program transformation aggressive 
code motion program trans formation technique applied blocked optimization opportunity missed 
approach attacks deficiencies 
relax optimization model 
allow control speculation 
guarantee program improved impaired speculation profile driven 
natural profile directed optimization guarantee program impaired program input generate profile 
code motion code growth misses opportunities code growth impairs paths control speculation restructuring complete code growth design space pre algorithm 
algorithm combination program transformation techniques 
algorithm lie design triangle 
resulting properties depend biased constituent technique 

enhance program transformation 
allow control restructuring 
restructuring economical code motion code motion fails 
pre algorithm uses transformation techniques 
techniques orthogonal useful different situation 
code motion cause code growth blocked fully remove 
control flow restructuring remove redundancies cost high code growth 
control speculation cause code growth impairs paths counter productive 
pre algorithms try optimize code motion possible safe economical 
code motion fails depending optimized program ii desired optimization properties pre employ restructuring speculation 
optimized program influences pre shape reuse threads profile 
properties optimization depend transformations applied 
shows design space pre algorithms formed methods 
resulting algorithm lie design triangle 
resulting properties depend biased particular transformation methods 
variants transformation algorithm characterized 
algorithms profile independent profile guided 
formulate profile independent pre algorithm order facilitate empirical comparison pre pure restructuring pre approach 
goals pre algorithm follows 
completeness desirable exploit reuse detected vng 
transformation methods permit completeness case code motion goal maximize removal redundancies 
best optimization defined differently profile independent profile guided algorithms separable vng code motion maximum degree possible 
pre ms pre msr pre pre pre pre various variants pre algorithms 
definition best static pre profile independent program best static optimization program transformation exists allowed methods path executes computations measure optimization quality individual program path best program may exist 
definition best dynamic pre profile guided program best dynamic optimization program transformation exists allowed methods dynamic number user computations single measure quality entire program best transformation exist 

shortest live ranges desirable insert compensating computations program points live ranges inserted temporaries short possible 
precisely set best optimizations live range optimal live range longer corresponding range best program 
pre algorithm developed chapter different optimality goal appropriate de pending transformation methods applied depending profiling 
pre find best static optimization changing shape cfg moving optimized computations computations program 
pre find complete optimization minimizes number duplicated cfg nodes 
pre optimality goal pre 
pre ms optimality goal pre terms best dynamic optimization 
pre find dynamic optimization maximizes utility function 
utility function reflects ratio code growth cost dynamic optimization benefit 
pre msr optimality goal pre allow speculation 
pre separable vng previous chapter algorithms separable general 
separable vng value thread uses name entire program 
simple require simpler algorithms achieve optimal optimizations typically polynomial time cost 
contrast general optimal transformation algorithm transformation intractable 
section devoted separable 
section presents extensions needed generality focusing pre ms algorithm appears useful practice 
profile independent pre consider profile independent variants pre 
algorithms guarantee path frequencies optimized program execute computations mized program 
algorithms operate safe optimization model program path impaired 
achieve completeness impairing path code motion obstacles come restructuring 
goal minimize restructuring cost code growth measured number duplicated cfg nodes 
turn section presents pre pre pre 
algorithm complete pre minimizes code duplication 
second algorithm uses abstractions derive intuitive formulation optimal code motion pre krs 
algorithm restructuring pre serve point experiments 
pre code motion restructuring pre integrates code motion control flow restructuring 
reduce code growth turing secondary transformation exploited pre 
merely enable hoisting cfg nodes prevent desired code motion 
central idea pre algorithm identify smallest set motion blocking nodes duplicate restructuring cfg 
restructuring motion obstacles disappear 
identify offending nodes determine predicate prevented characterizes vng node blocks desired code motion 
predicate solutions standard dataflow problems anticipability availability see definition 
problems computed may lattice defined section 
prevented predicate derived follows 
computation partially redundant value computed incoming control flow path previous computation 
code motion eliminates partial redundancy hoisting redundant computation paths reaches edge reused value redundant paths paths 
case computation removed inserted original computation fully redundant recall 
unfortunately code motion may blocked edges reached nodes prevent code motion 
nodes characterized set conditions 
hoisting computation exit entry vng node desired opportunity value reuse exists true conditions hold value computed control flow paths leading 
case hoisting continue move computation cfg edges redundant 
situation true iff may value consumed user node control flow path emanating computation optimized hoisted path 
situation exists iff desired may 
hoisting computation disabled computation impair control flow path path amortize computation conditions elaborate hoisted computation fully redundant incoming path removed true iff hoisted computation computation redundant path leaving disabled node prevents code motion motion desired disabled 
way conjunction get code motion preventing condition prevented desired disabled may may node generator kill node see definition show prevented may may predicate prevented characterizes smallest set nodes block code motion 
desired code motion enabled blocking condition nodes removed restructuring 
code motion preventing cmp region set nodes 
definition cmp region start value name graph 
cmp region denoted subgraph df prevented df df df nodes edges entry edges exit edges entry exit edges attach copy cmp region rest program restructuring 
set cmp entry edges factored sets entry edges value available incoming paths incoming paths 
sets denoted called entry edges called entry edges 
similarly exit edges factored value consumed anticipated outgoing paths outgoing paths 
sets denoted called exit edges called exit edges 
observe reuse thread enter cmp region entry leave exit 
similarly free thread enter entry leave exit 
explain pre removes obstacles cmp region assume sim vng contains name allows view vng cfg threads coincide paths 
deal multiple names central idea clear 
pre obstacles cmp region removed duplicating entire region illustrated 
goal duplicating cmp region factor may availability holds original region availability availability holding copy region 
may availability longer holds region paths availability separated 
see may availability split availability respective region copies observe region entry edge may available solution availability region depends solely solutions entry edges value computed killed region 
desired factoring carried attaching region copy subset entry edges separates offending paths shown 
exit edges duplicated attached copies region 
cmp region duplicated condition prevented false node enabling desired code motion shown 
remove restriction vng single value name 
possible cfg node prevents code motion multiple names denoted 
node duplicates may need duplicated times producing copies 
copies denoted separate reuse free paths 
enabling hoisting paths remaining names may meet duplication copies separates paths producing nodes process continues copy subset 
node duplicates may necessary 
example reuse paths match nodes need created 
alternatives restructure program create needed nodes 
restructure name recompute avail 
paths name split process prevented condition disappear 
restructuring continues names prevented predicate holds 
pre algorithm uses second alternative avoid recomputing avail solution creates copies node perform restructuring names simultaneously 
spurious copies manifested unreachable cfg nodes removed cleanup phase 
pre algorithm steps cmp code motion prevented cmp region cmp region diluted code duplication avail may antic may avail avail antic may antic may avail avail antic may antic may complete pre code motion prevented reuse free paths meet 
code motion possible paths separated code motion hoisted reuse paths removing obstacles code motion restructuring 
avail avail antic antic 
compute availability generators anticipability users 
computation problems described chapter 
remove cmp region control flow restructuring 
algorithm shown parts node duplication lines edge adjustment lines removal unreachable nodes lines 
algorithm builds restructured cfg original cfg 
algorithm easily altered modify place 
function cmp maps cfg node set value names belong cmp region 
function directs copies node created line copy cfg node created combination paths separated node copy subset cmp note cmp empty set copy created denoted case start cfg nodes 
node duplicated dataflow solutions avail antic 
lines effectively separate reuse free paths adjusting avail dataflow solution 
duplicated nodes adjusted avail solutions line places edges nodes compatible avail solutions creating restructured cfg 
line tests cfg nodes compatible solutions 
essentially test prevents available node con nected available node ensuring paths separated 
note vector avail solutions symbolic names 
lattice partial order defined definition 
function permutes names dataflow vector reflect value names change nodes 
separable function identity 
unreachable nodes detected list algorithm propagating control flow start start node 
pre algorithm 
theorem completeness pre pre optimal minimizes number computations path 
proof 
original computation replaced temporary eq 

second computation inserted value available incoming path 
user computation optimized program partially redundant domain morel code motion transformation pre ac hoisting optimization candidates hoisting statements pre achieves minimum code growth 
follows fact cmp restructuring node un reachable program node removed merged node destroying value reuse 
outside domain code growth reduction possible example moving instructions cmp prior duplication 

optimize program code motion 
code motion transformation carried replacing generator computation temporary variable eq 

temporary initialized computation inserted different points eq 
available edge sinks may available node 
insertion compensate partial redundancy full redundancy 
insertion edge anticipated verify optimized computation hoisted insertion edge 
eq 
user computation partially redundant 
eq 
generator computation user computation store instruction redundant load optimization 
recall computations reuse value generate 
cases initialize temporaries computations replaced hoisted 
replace insert may pre algorithm continued 
algorithm complexity 
cost restructuring step dominates dataflow analysis step code motion step 
due duplication size may times larger number vng symbolic names 
practice algorithm significantly slowed large procedures size nodes 
explosion expected due exponential number possible program paths 
pre successful reducing code growth 
shown section code growth half caused pre 
pre code motion enabling efficient complete pre abstraction cmp region facilitates intuitive formulation optimal code motion pre 
recall section pre optimal achieves best static optimization removes redundancies optimized code motion live range optimal live ranges inserted temporary variables short possible 
existing optimal algorithms ds krs phases 
cfg start graph input cmp cmp control flow graph start value name cmp region output auxiliaries create duplicate cmp nodes adjust dataflow solutions cmp copy cfg node including dataflow solutions avail antic copy denoted add cmp add create connect new nodes pair reachable remove nodes unreachable start start node 
add start reachable add start worklist worklist empty remove node worklist reachable reachable worklist worklist reachable reachable reachable phase pre remove cmp region control flow restructuring 

partially redundant computations hoisted high permitted code motion obstacles 
transformation produces best static optimization 

hoisted computations rolled back low possible undoing optimization 
transformation results best static optimization shortest live ranges temporaries 
krs krs phases called busy code motion lazy code motion respectively 
phase approach complicates comprehension algorithm reasons 
artifact dataflow equations busy code motion looks different counter intuitive desired final transformation 
second lazy code motion separate corrective step considered concert phase understood 
contrast pre algorithm operates single phase 
retains single phase property restructuring component disabled pre algorithm 
constraint provides natural formulation optimal code motion 
importantly pre derived framework pre algorithms cmp region may lattice inexpensively implemented special case general pre algorithm 
note computational cost pre equal phase algorithms 
explain pre single phase algorithm 
show restrict pre pre losing intuitive single phase property 
phase pre ag code motion blocked 
words hoisting continues upwards hoisted computation hoisted reuse path 
blind hoisting overshoots corrected second phase rolls back delays hoisted computations contrast pre algorithm far necessary 
hoisting stops soon hoisted computation leaves reuse path 
hoisting stopped early expressive lattice hoisting continues avail may reuse path stops soon avail turns longer reuse path reuse path fully redundant 
stopping early results shortest live ranges avoiding need roll back insertions 
derive pre pre needs disable restructuring cmp region 
pre observation reuse flowing cmp region exactly reuse code motion exploit 
critical issue prevent hoisting paths emanate exits cmp region hoisting precisely rolled back 
sufficient ensure avail cmp exit indicating reuse available code motion region 
modification pre needed derive pre 
pre algorithm uses dataflow property avail holds value exploitable code motion available node 
antic property pre 
definition availability generators accessible code motion availability en try incoming paths defined available paths start avail may available paths start available paths contain node cmp region 
shown avail may iff reuse flowing removed code motion 
summarize pre steps dataflow analysis code motion 

compute availability generators anticipability users 
compute standard anticipability pre 
availability accounts killing effect cmp nodes treated kill nodes 
flow function avail problem follows 
third line kills reuse cmp node value generated value killed prevented cmp region 

optimize program code motion 
maximal fixed point solution antic avail transformation proceeds pre avail replaces avail 
pre algorithm 
theorem computational optimality pre restriction immutable shape control flow graph pre achieves optimization best code motion 
proof outline 
proof showing reuse remains pre requires crossing cmp region code motion blocked understand concept pre algorithm need understand definition avail flow function 
pre easy understand requires computation dataflow problems antic avail avail requiring bits dataflow vectors value name 
contrast equivalent phase algorithms compute problems bit availability anticipability 
show compute pre efficiency 
efficiency improved computing avail weaker predicate requires bit 
compute avail need solution avail antic required predicate prevented 
avoid computing avail avail tempting combine detection cmp nodes killing effects single dataflow problem 
transfer function avail exactly prevented predicate value avail uses value avail computed avail appears value third line 
may may prevented 
shown maximal fixed point solutions equal avail 
unfortunately monotone may may iterative dataflow solver may produce conservatively imprecise values avail ku may obtain solution may 
define availability property denoted avail weaker avail sufficient computing insert predicate correctly 
avail defined follows avail df avail avail may df avail may avail df avail antic shown avail avail predicate insert changing value 
reason condition avail computed efficiently boolean bit problems defined follows df antic df avail df avail clearly pair expresses solution avail 
true false values denoted respectively 
avail avail may avail compute observe known boolean anticipability property holds value anticipated outgoing paths 
similarly follows avail avail turn follows fact available node cmp region 
solved computed transfer function 
prevented 
prevented df shown computes maximal fixed point false iff incoming paths reuse anticipated kill reuse cmp node 
intuitively condition prevented weaker prevented true df avail antic prevented avail may antic may weaker condition kills reuse cmp nodes nodes 
equivalent purpose safe kill reuse avail hoisting antic 
weaker predicate prevented beneficial computing testing non requires bit bits required test may result obtain implementation complexity algorithms ds krs data flow problems solved requiring bit solution expression 
cmp region convenient abstraction terminating hoisting unnecessarily extend live ranges 
provides intuitive way explaining shortest live range solution applying corrective step krs 
furthermore cmp motion solution implemented efficiently existing shortest live range algorithms 
pre restructuring pre removes redundancies relying exclusively path separation 
mentioned pre aggressiveness undesirable duplicates code economical code motion 
pre order explain formally duplication unnecessary subsection point experiment compares code growth pre pre pre 
pre turns partial redundancy full redundancy compensating partial redundancy separating reuse paths 
compared pre reuse paths separated meet free path requirement enabling code motion way partially redundant computation causes code growth pre 
formally pre duplicates pre duplicates reuse partial prevented may may may prevented may pre duplicates nodes may 
nodes partially redundant computation hoisted 
pre expressed form pre restructuring phase duplicates cmp region superset 

dataflow analysis pre 

restructuring line duplicates node true 

optimization code motion computation fully redundancy redundant merely remove fully redundant computations 
predicates insert replace remain pre 
pre algorithm 
algorithms fit pre category weg weg ste 
formulated region duplication peel reuse paths 
decide redundancy partial form avail 
go ksim gcc compress li ijpeg perl vortex int swim su cor int fp hydro wave code growth profile independent pre algorithms 
code growth experiment 
purpose experiment evaluate performance pre terms reducing code growth cost incurred pre 
pre pre effect complete removal pre duplicate code practice 
compares code growth 
combining code motion restructuring reduces amount duplication half pure restructuring approach 
average spec benchmarks pre algorithm able reduce code growth pre 
compare ratio pre pre code growth integer int versus floating point fp benchmarks 
scientific fp programs exhibit regular control flow structure control flow sensitive int programs relatively loops statements code motion successful fp requiring little restructuring 
words pure restructuring fp programs overkill int programs 
fact shown section fp benchmarks code motion able remove nearly redundancies measured dynamic amount 
experiment code size measured size basic blocks number instructions basic block 
final code size include amount inserted statements see insert predicate may grow program code slightly 
reason code growth pre shown 
code growth pre pre depends amount redundancies shape reuse paths 
experiment value flow representation restricted detected class lexically identical arithmetic expressions common traditional pre 
address instruction op considered partially redundant preceded control flow path identical instruction op redefined previous computation 
operator op arithmetic logic operator ksr instruction set 
loads stores conditional branches analyzed 
large procedures code growth exploded practical means 
ex periment feasible algorithm terminated procedure size reached instruction 
fp spec comparison algorithms procedures exceed limit algo rithm 
despite decreasing cost pre half pre growth significant code increase 
production compiler allowable growth ranges ags 
keep mind code size precious resource processor registers code growth budget needs shared procedure inlining loop unrolling typically higher payoffs pre allocated larger fraction budget 
furthermore recall experiment targeted lexical redundancies vng representation pre grow code 
pre algorithm achieves smallest possible code growth morel domain conjecture known program transformation methods code growth reduction achieved sacrificing reuse opportunities 
absence profile information code growth reduced impairing optimization 
obser vation suggests necessity profiling selects opportunities sacrificed 
profile guided pre developed 
profile guided transformation cmp region smallest set nodes duplication enables desired code motion size prohibitive practice 
section relying profile estimation run time optimization benefit pre practical avoiding code replication unprofitable pre little benefit duplication section replaced careful speculative impairment free paths section section 
pre ms code motion speculation pre profile driven measure best optimization changes 
improving path possible goal minimize number dynamic optimizations measured supplied profile recall definitions 
pre ms algorithm finds best dynamic optimization 
pre optimal absence profile information minimizes code growth pre ms optimal presence run time profile maximizes dynamic benefit profile 
pre ms profile driven speculative sense program optimized specific run time profile specific program input provide guarantee transformation slow program input 
preliminary experiments indicate pre ms extremely stable various profiling inputs 
describe principle combining code motion speculation 
pre hoisting computation blocked enter free path compute original program 
speculative code motion disabled executing path 
raise spurious exceptions computing overflow page fault 
outweigh dynamic benefit removing original computation 
cmp ex speculative code motion ex ex ex ex ex avail avail antic antic optimization benefit insertion removal pre ms simple version speculation profitability test 
optimal speculation estimators chapter 
course restriction hold instruction cause exceptions additions memory operations proven access valid address 
excepting instructions optimized modern processors support delayed exceptions 
special versions excepting instructions provided suppress raising exception generated value mcb 
delayed exceptions pre simple extension described section 
second problem harder 
guarantee speculation profitable pre ms utilizes cmp region determine positions speculative insertion points speculation profitable minimize live ranges temporary variables 
illustrates pre ms algorithm 
version algorithm discussed computationally optimal maximize benefit illustrates principle combining code motion speculation 
pre ms duplicating cmp region hoist expression available entry edges 
exits fully available enabling complete removal original computations exits 
example moved available region entry edge 
hoisting speculative executed path going previously contain expression 
determine speculative hoisting beneficial examine execution cies entry exit edges follows 
speculative hoisting dynamic amount computations decreased execution frequency anticipated exit edge com putation removed increased frequency available entry edge computation inserted 
speculation profitable insertion frequent removal total execution frequency exit edges exceeds available entry edges 
algorithm sketched computationally optimal 
optimality achieved observations 
necessary speculate entry edges 
exit reached entry entry need speculated enable optimization exit 
entry high frequency avoiding speculation may increase difference improvement impairment 
consider previous chapter 
profitable speculate entry benefit speculating entries yields benefit 
second cmp entries possible speculation points tu 
optimal speculation points may lie cmp region 
consider assume avail solution cmp entries reversed available available 
modified program profitable speculate inner edge benefit entry edge negative benefit 
observations lead main result pre ms theorem maximal benefit speculation equals lower bound precise estimator 
proof outline 
recall lower bound estimator computed frequency exits minus frequency reuse stolen entries 
proof showing speculation stolen reuse covered speculative insertions 
words available paths cmp region available speculative insertions constructive proof directly suggests pre ms algorithm 
central idea place insertions frequent set cmp edges ensure exits available 
set edges estimator algorithm 
optimal speculative insertions edges saturated network flow problem computed cmp estimator 
path cmp contains multiple edges select closest exits obtain shortest live ranges 
summarize estimator computes maximum speculation benefit determines insertion points 

dataflow analysis 
pre 

speculation 
compute cmp estimate 
cmp computes tightest estimate separable vng single computation 
lower bound computes maximum speculation bene fit 
find min cut flow network edges min cut close possible 
insertion edges 

recompute dataflow analysis 
add new speculative insertion points recompute avail 

code motion 
pre 
pre ms algorithm 
important consequence theorem best speculation edge profile 
speculative benefit independent branch correlation edge profiles precise path profiles case speculative motion pre 
corollary edge profile precise edge profile sufficient find optimal optimization uses speculation restructuring 
proof outline 
proof follows fact pre ms algorithm driven edge profile results best dynamic pre pre selective restructuring pre extends pre inhibiting restructuring response code duplication cost df expected dynamic benefit 
resulting profile guided algorithm duplicates cmp region incurred code growth justified corresponding run time gain eliminating redundancies 
model profitability duplicating cmp region cost benefit threshold predicate holds true region optimization benefit exceeds constant multiple region size 
metric benefit dynamic amount computations elimination enabled duplicated denote rem 
rem size constant parameter 
true region algorithm equivalent complete pre 
false region algorithm reduces code motion pre 
obviously predicate determines sub optimal tradeoff exploiting pre limiting code growth 
particular explicitly consider instruction cache size increase register pressure due introduced temporary variables 
chosen form order avoid modeling complex interactions compiler stages 
practice usually supplemented code growth budget asg code allowed grow 
benefit rem cmp region computed estimator bounds reuse flowing cmp region 
pre assume entire connected region duplicated compared possibility copying paths region entire cmp region 
cmp estimator appropriate computing bounds rem 
algorithm pre duplicates profitable cmp regions 
struc tured complete counterpart pre dataflow analysis proceed eliminate cmp regions separately value name 
pre sufficient treat nodes single cmp duplicated selective duplication benefits dividing cmp disconnected subregions done cmp estimator 
profitable regions eliminated motion blocking effect cmp regions remaining program captured 
needed apply pre improved control flow graph 
hoisting remains prevented cmp node selective restructuring performed avoided recomputing availability avail forces availability cmp detected 
pre algorithm address important problem names re structured 
cfg node may duplicated multiple times causing exponential replica tion desirable optimize beneficial reuse paths copies node 
possible heuristic order names line reuse computed estimator 
forming pre optimally maximize rem guaranteeing holds np hard due need consider multiple names simultaneously 
chapter edge profiles estimate benefit rem duplicating region 
alter native path profiles abl bl convenient establishing cost benefit optimization trade offs restructuring 
arrive value region benefit path profile sufficient sum frequencies paths paths cross region entry edge available exit edge anticipated 
precisely paths value reuse exists blocked region 
exponential number profiled acyclic paths procedures execute distinct paths spec gbf 
number drops 
dataflow analysis 
pre 

partial restructuring remove profitable cmp regions 
computation benefit order connected subregion cmp determine optimization benefit carry frequency analysis avail cmp subregion profitable duplicate duplicate 
code motion 
perform pre including recomputation avail 
pre algorithm 
low frequency paths accounting total frequency removed 
afford ap proximate disregarding infrequent paths summing individual path frequencies constitutes feasible algorithm cmp regions 
furthermore encapsulate branch correlation path profiles compute benefit precisely frequency analysis correlation insensitive edge profiles 
sub cmp restructuring 
notion individual cmp paths leads better pre 
considering cmp region indivisible duplication unit overly conservative 
may profitable restructure entire region region may contain paths frequently executed inexpensive duplicate 
goal find largest subset frequency wise region paths pass threshold test example illustrating pre algorithm 
table lists optimizable paths executed execution frequencies 
table lists size basic block shows basic blocks duplicated enable optimization path 
task select subset paths benefit sum frequencies path duplication cost sum sizes selected basic blocks satisfy predicate constant 
selecting paths satisfies benefit cost duplicating basic blocks 
task partial restructuring localize subgraph cmp small size contains hot paths 
duplicating subregion effectively peeling hot short paths 
presumably hot path node separated 
problem finding optimal subregion benefit maximized passes predicate smaller constant budget np hard 
furthermore path separation multiple expressions simultaneously considered 
empirically small number hot paths promises efficient exhaustive search algorithm 
pre msr motion selective restructuring selective speculation pre msr integrates restructuring speculation 
select profitable subgraph cmp restructure enable speculation similarly restructuring enables code motion 
cmp profitable part cmp ex ex select source program non zero freq 
path path freq 
optimal basic block size total selected example pre 
assume parameterized 
tightening code growth constant results program 
section presents principles lead efficient heuristics path profiles sub cmp version pre 
integrating partial speculation restructuring offers additional opportunities improving cost benefit ratio 
longer restricted peeling hot paths selecting entries speculation 
high frequency entry prevents speculation peel hot available path emanating entry reducing entry edge frequency allowing speculation cost code duplication 
shows example program annotated edge profile 
peeling hot paths highlighted cmp duplicate blocks try speculation 
eliminate redundancy cmp exit edge frequency computation inserted entries 
low frequency speculation disadvantageous assume exit branch strongly biased path frequency 
edge executed execution follow 
peel path shown effectively moving speculation point path 
peeling frequency speculation profitable 
cmp speculation profitable profitable 
source program speculation profitable path peeled example pre msr optimization 
summarize relationship profile guided approaches goal enable code motion maximum paths value reuse paths 
done peel ing path region cost duplicating basic blocks path 
duplication cost may shared various duplicated paths 
alternatively partial speculation enables reuse paths sinking exit inserting computation appropriate set entry edges 
cost speculating entry reduced peeling path 
remains shown pre algorithms section live range optimal 
theorem shortest live ranges 
cmp restructured original control flow graph pre pre optimal minimizes live range lengths inserted temporary variables 
proof 
initialization point insert delayed partially redundant destroying completeness temporary variable immediate successor pre arbitrary vng extension pre ms algorithm general vng representation 
restrict attention algorithm experiments suggests practical 
achieves near complete redundancy removal redundancies zero code growth simple imple ment restructuring needed 
code motion speculation pre ms general proceeds pre ms separable 
relies estimator determine place speculative insertions cmp regions 
unfortunately ex cmp copied reducibility en source program ex single loop entry node en reducible reducible restructuring 
estimators chapter separable general form general estimators suitable determining placement insertions 
reason best estimators cmp cmp computing maximum flow network structure directly reflect cfg program saturation network edges criterion insertion separable pre ms 
fortunately cmp estimator supports necessary speculation decisions 
experiments show lower bound precise cmp reliance cmp sacrifice 
general pre ms algorithm reflects underlying cmp estimator 
insertion candidate points entries cmp region inner cmp edges 
connected cmp region estimated separately 
lower bound greater zero speculation connected region beneficial algorithm inserts speculative computation cmp entries 
miscellaneous issues section covers pre issues mainly concern implementation production compiler 
sketch deal irreducibility cfg may introduced restructuring algorithms 
second outline adapt speculation algorithms exploiting control speculation features ia processor architecture 
reducible restructuring duplicating cmp region may destroy reducibility control flow graph 
example pre resulted loop distinct entry nodes 
pre preserves reducibility loop restructuring optimizations bgs ste plagued introducing irreducibility 
way deal problem perform pre optimizations require single entry loops 
algorithms scheduling ideally follow pre rely reducibility 
pre reducible graph obtained additional code duplication 
effective algorithm normalizing irreducible programs jc 
suppress unnecessary invocation algorithm employ simple test irreducibility may created region tion 
test examining cmp entry exit edges entire program 
assuming start reducible graph restructuring loop irreducible multiple cmp exit edges sink region entry outside dominated header node 
region duplicated target nodes region exit edges may multiple loop entry nodes 
consider loop 
exits cmp fall loop 
restructuring loop entries shown 
applying global algorithm jc straightforward approach af loop reducible peel part body 
goal extend replication scope region exits sink single loop node new loop entry 
node closest common postdominator loop offending region exits original loop entry 
highlights duplication cmp restructuring restore reducibility loop 
postdominator offending exits node new loop header 
spurious exceptions ia architecture introduces delayed exceptions mechanism support control speculation instructions may raise exceptions divisions memory access instructions 
general compiler reorders instructions way may executed paths execute original program hoisted conditional branch exception may spurious changes semantics original program 
mentioned section speculative pre particular introduces problem spurious exceptions 
preserve semantics ia allows raised exception delayed excepting instruction marked delaying exception suppressed propagated special flag attached register stores result excepting instruction 
delayed exception may raised instruction marked catching reads flagged register 
exception catching instruction usually placed original program point reordered excepting instruction exception raised exactly original program 
pre context steps performed allow speculation excepting instructions ia architecture 

speculative inserted computations may raise exceptions marked delaying 
step trivial speculation algorithms 

delayed exceptions caught way preserves exception semantics 
ac marking catching user nodes consume value produced speculative insertion point 
recall user computations replaced temporaries exceptions caught copy instructions form temporary 
experiments experiments evaluating transformation algorithms performed hp labs vliw back compiler fed spec benchmarks previously compiled edge int fp go ksim gcc compress li ijpeg perl vortex tomcatv swim su cor hydro loads removed dynamic count normalized global cse relative completeness pre algorithms 
profiled inlined spec int impact compiler 
table shows program sizes total number nodes expressions 
node corresponds intermediate statement 
memory require ments indicated column max space gives largest nodes expressions product procedures 
running time inefficient implementation behaved quadratically num ber procedure nodes procedure nodes pre time seconds pa 
typically complete pre ran faster subsequent dead code elimination 
experiment compares removal power completeness pre algorithms removal redundant load instructions 
vng served value flow program representation experiment 
plot shows dynamic amount computations removed pre pre ms pre pre 
clearly relationship holds pre pre ms pre pre means removes computations dynamic terms 
experiment answers relationship quantitative terms 
graph removal power normalized power global cse path insensitive algorithm redundancy elimination 
graph exposes important points 

due normalization amount reuse dynamic reuse path insensitive available paths reuse path sensitive available strict subset paths 
integer programs contain lot strictly partial reuse path sensitive algorithms impor tant 
assume profile guided pre ms optimized executed program input 
assumption held experiments 
benchmark program size cm prevented loop inv dynamic spec int spec fp procedures nodes expressions max space optimizable expr prevented cmp optim prevented poe optim loop invar optim li global cse complete pre go ksim gcc compress li ijpeg perl vortex avg spec int tomcatv swim su cor hydro fpppp wave avg spec fp avg spec table experience pre control flow restructuring 

integer programs obstacles code motion significant 
pre optimizes half strictly partial redundancies 
worth improving traditional pre approaches 

performance complete pre estimated cmp estimator 
bottom right bar plot shows lower bound estimate 
top bar shows upper bound 
complete reuse bounds 
recall lower bound estimate equals benefit speculation theorem 
pre ms close performance complete pre algorithm 
turing may necessary load removal 
third point especially news 
empirical result holds true value flow optimizations pre ms able remove third exponential path factor due number path various optimization opportunities introduced section 
value flow optimizations inherently restructuring branch elimination see section 
experimental results show need develop pre goes code motion 
contrast experiments performed lexical value flow program representation 
disabling effects cmp regions 
column labeled optimizable gives percentage expressions reuse value path static expressions partially redundant computations 
column prevented cmp reports percentage optimizable expressions complete optimization code motion prevented cmp region 
code motion pre fail fully optimize optimizable expressions 
comparison column prevented poe reports expressions require restructuring pre 
loop invariant expressions 
determined percentage loop invariant li expressions removed invariant loops code motion 
column loop invar shows percentage dynamic computations eliminated code motion pre safe speculative pre unsafe speculative pre complete pre go ksim gcc compress li ijpeg perl vortex avg int tomcatv swim su cor hydro fpppp wave avg fp avg benefit various pre algorithms lexical value flow representation 
dynamic op count decrease due strictly partial redundancies 
algorithm completely removes full redundancies 
optimizable expressions pass test loop invariance 
column gives percentage li expressions cmp region average li computations hoisted enclosing invariant loops restructuring 
eliminated computations 
report amount removed computations 
experiment differs pre performed lexical representation arithmetic instructions symbolic vng representation redundant loads 
column global cse reports dynamic amount computations removed global common subexpression elimination corresponds full redundancies 
column complete pre gives dynamic amount partially redundant statements 
fact strictly partial redundancies contribute difference complete pre global cse may due style impact intermediate code multiple virtual registers variable 
expect powerful redundancy analysis perform better 
plots dynamic amount strictly partial redundancies removed various pre techniques 
code motion pre yields half benefit complete pre 
furthermore speculation results near complete pre benchmarks special hardware support safe speculation 
speculation carried cmp 
note graph accounts dynamic impairment caused speculation 
measurements indicate ideal pre algorithm integrate speculation restructuring 
restructuring speculation waste large portion benefit provide complete pre small code growth 
related summary chapter contributions approach integrating orthogonal program transformation methods code mo tion control flow restructuring control speculation 
developed family pre algorithms combine methods pre traditional edge path profiling code motion aggressive edge path speculation relaxed safe restructuring model summary results 
pre extended traditional code motion transformation transformation methods achieving aggressive pre 
model showed code motion restructuring safe optimization model program path impaired 
speculation requires relaxed optimization model path impaired 
profiling showed code motion combined speculation edge profile precise path profile 
restructuring profile guided path profile precise edge profile 
pre pre algorithm complete exploits opportunities value reuse greatly reduces code growth necessary achieve desired complete code motion 
large class programs separable code growth minimal 
pre ms profile guided pre integrates code motion speculation 
restructuring achieves zero code growth 
experiments show optimization near complete 
important contribution pre ms algorithm determines speculation points benefit difference improved impaired path frequencies benefit maximized separable enumerating improved impaired paths edge profile precisely execution trace 
pre msr balances techniques 
resorts restructuring speculation done sufficiently beneficially 
pre natural restriction pre algorithm 
produces optimization equivalent optimal code motion pre krs believe easier understand 
experiments compare optimization power code growth pre pre ms pre pre pure restructuring pre 
summarizes chapter planes divide algorithm design space 
pre plane extended traditional code motion transformation transformation methods achieving aggressive pre 
optimization model plane showed code motion restructuring safe opti mization model program path impaired 
speculation requires relaxed optimization model path impaired 
profiling plane showed code motion combined speculation edge profile precise path profile 
restructuring profile guided path profile precise edge profile 
observation edge profile sufficient find optimal speculation deserves comment 
edge profile speculation precise exploit power path profiles partial restructuring speculative code motion 
intuitive realize control flow restructuring restricted consider individual edge path expression insertion removal 
compare cmp partial speculation speculative pre gbf show efficiently compute benefit defining cmp region apply edge profiles precision path profiles 
acyclic code achieve precision cyclic code precise presence loop carried reuse 
chapter defined code motion preventing cmp region vng subgraph localizing adverse effects control flow desired value reuse 
notion cmp applied enhance integrate existing pre transformations ways 
code motion restructuring integrated remove redundancies minimal code growth cost pre 

morel original method expressed restricted motion case complete algorithm pre 

develop algorithm power adjusts continually motion complete pre response program profile utility function pre 

demonstrate speculation navigated precisely edge profiles pre ms 

path profiles integrate transformations balance power level cmp paths 
summarizes related contributions 
pre research started inde pendent works wegman wegbreit developed pre algorithms weg weg 
fen created complete pre algorithm removed expressions conditional branches ste 
due exponential code growth algorithm implemented production compiler best knowledge 
morel created practical pre algorithm 
limit code growth algorithm code motion 
algorithm improved ds research stabilized lazy code motion considered standard pre algorithm krs krs 
contribution pre area intuitive formulation algorithm produces identical optimization lazy code motion 
pre pre algorithm lies contribution pre algo rithm complete pre algorithms minimizes code growth performing code motion possible 
horspool ho lo gupta heuristic morel dhamdhere 
knoop lazy code motion intuitive formulation lazy maximal pre code growth optimal edge profile wegbreit wegman steffen complete pre minimal code growth absence profile balanced pre near complete small code growth related contributions 
various researches extended code motion pre speculations hh gbf lck sj 
achieves optimal speculation relies inexpensive edge profiles 
contribution ability combine transformation methods producing balanced pre response profile characteristics optimized program 
integrated pre enabled cmp region serves single underlying abstraction algorithms 
chapter inter procedural removal redundancies chapter concerned inter procedural value flow 
value computed procedure recomputed result modular programming style 
exploit inter procedural redundancy optimizer requires interprocedural analysis transformation 
chapter presents inter procedural version dataflow analysis vng 
analysis distinguished respects 
demand driven 
computing dataflow solution required transformation stage reduces cost analysis compared exhaustive analysis 
second analysis require completely constructed interprocedural vng 
vng constructed demand portion needed demand driven analysis 
demand driven construction vng significantly reduces cost analysis drawback demand vng value numbering 
vng built back substitution dataflow analysis folded single demand driven pass 
second part chapter deals inter procedural transformation 
inter procedural optimized techniques chapter computations moved procedure boundaries 
inlining concentrate reuse single procedure may prohibitively expensive practice due code growth 
code growth free alternative inter procedural code motion kno 
unfortunately inter procedural code motion may fail just intra procedural counterpart 
furthermore attractive optimizations branch removal calls carried code motion 
chapter presents inter procedural version restructuring pre algorithm 
attempting combine code motion transformation minimize code growth focus achieving complete removal inter procedural redundancies resorting inlining procedures 
note entry exit splitting virtual call sites restricted branch elimination chapter 
may value flow optimization pre algorithm 
goal inter procedural pre separate reuse paths cross procedure boundaries 
pre algorithm performs procedure entry splitting exit splitting 
transfor mation creates multiple entry points procedure allows procedure return return points caller 
show transformations concert separate interprocedural paths convert partial redundancy full redundancy achieves complete optimization 
application entry exit splitting develop inter procedural conditional branch elim icbe 
relying inter procedural value flow analysis part chapter icbe removes branches correlated branches branches outcomes known execution paths prior branch outcomes assignments 
clearly static branch correlation special case value reuse branch condition value 
icbe eliminates correlated branches correlated paths reuse paths means code restructuring may involve splitting procedure entries exits 
describe benefits inter procedural branch elimination optimization ex show amount code growth estimated reduction executed conditional branches times higher intraprocedural conditional branch elimination applied 
demand driven interprocedural dataflow analysis section presents inter procedural version dataflow analysis inter procedural vng 
analysis distinguished respects 

analysis demand driven 
computing dataflow solution required transformation stage reduces cost analysis compared exhaustive analysis 
practice optimizer may decide analyze frequently executed user nodes 

analysis terminated early demanded solution completely computed 
analysis stopped amount nodes visited 
unexplored paths assumed conservative solution 

vng constructed fly dataflow analysis 
portion needed demand driven analysis virtually constructed goal avoiding construction potentially large interprocedural vng 
undesirable consequence desirable delayed vng construction value numbering invoked collapse vng threads resulting lower accuracy 
application inter procedural branch correlation demand vng analysis find statically correlated conditional branches 
branch statically correlated path branch outcome determined path compile time prior statements branch outcomes 
branch correlation name partial redundancy branches name reflects direction redundant branch depends direction branch es 
correlated branches eliminated optimizable path code restructuring chapter chapter 
chapter shows separate optimizable paths intra procedurally 
chapter presents inter procedural separation paths means procedure entry splitting exit splitting 
interprocedural conditional branch elimination icbe number benefits including enhancing instruction scheduling software pipelining improving speculative execution hardware branch prediction optimizing java virtual functions 
research branch prediction kra slm profiling bl elimination conditional branches mw reported existence significant amounts correlation con ditional branches presenting opportunities optimizations 
previous conditional branch elimi nation static correlation mw demonstrated substantial performance improvements despite restricted focus eliminating conditionals loops 
experimentally show substantially static correlation detected compile time programs analyzed interprocedurally 
programs spec suite discovered interprocedural detection correlation enables elimination executed conditionals factor improvement strictly intraprocedural analysis 
illustrated high correlation branches procedures considered due modular fashion write procedures procedure value returned selected statement 
value may checked caller 
example consider call procedure removes element linked list 
procedure tests list empty returns nil 
caller performs identical test return value determine nil returned 
test fully correlated earlier 
order keep procedure interface simple passing arguments procedures frequently clude checks parameters performed caller previous calls procedure 
example procedures library module may called propagating values 
procedures perform correlated tests propagated values 
icbe optimization repeated testing eliminated 
research implemented analysis experimentally investigated amount correlation detected cost analysis 
measurements performed subset spec programs provide insight interprocedural correlation detected statically usability compiler optimizations 
number conditionals correlated paths greatly increases inter procedural analysis effect branch elimination significant short frequently taken interprocedural correlated paths exist 
observation serves motivation performing vng analysis inter procedurally 
observed correlated branches correlated long usually inter procedural program paths 
correlations require time demanding analysis 
simple heuristic controlling ex tent demand driven analysis developed evaluated analysis branch allowed examine nodes 
paths completely analyzed conservatively assumed value reuse 
early termination reduced analysis cost order magnitude sacrificed detection fraction correlation 
note missed correlation long paths exploitable anyway due duplication required transformation stage 
observation serves motivation construct vng demand 
successful early termination heuristic value reuse paths examined completely desirable build portion vng analyzed 
motivation illustrate interprocedural branch correlation small application program uses stdio gnu library 
program shown 
function main opens text file call fopen iterates character file eof reached 
characters obtained call fgetc returns character buffer filled calling 
consider conditional branch main 
branch redundant incoming paths fully removed 
analyze paths leading branch 
path starting node fgetc branch exit main loop node returns value eof 
true outcome branch correlated node 
path node main false true define eof define null int fp fopen file fgetc fp eof process unsigned char uc fp null int fp magic fp magic errno return eof fp fp fp fp get limit fp source program 
return int fgetc fp uc fp uc example program gnu library version 
branch continue main loop value uc fetched buffer unsigned different constant eof 
false outcome branch correlated node examination procedure shown show paths node return eof unsigned character just nodes 
summary outcome branch redundant incoming paths 
section presents analysis detects kind inter procedural correlation 
branch optimizable paths optimization differs incoming paths paths true correlated false correlated 
optimization possible interprocedural separation paths program transformation chapter 
consider conditionals function fgetc 
inter procedural loop created main branches loop invariant outcomes iteration 
examination fopen shown show path emanating fopen fp null fp null fp magic holds 
case correlate 
result loop invariant redundant paths fully removed 
summarizing example original loop conditional branches executed iteration 
optimization conditional remains 
demand driven algorithm mentioned demand analysis builds vng fly components back substitution dataflow analysis folded essentially single demand driven pass 
value numbering collapses value threads engaged fit demand driven paradigm 
understand reasons recall steps exhaustive vng construction analysis 

place threads starting user optimized computations symbolic back substitution backward direction 

collapse threads value numbering forward direction 

solve dataflow problems forward backward direction 
branch correlation computed problem availability branch conditions forward problem 
compute forward dataflow problem demand demand driven analysis proceeds backward direction dgs 
reversed direction allows fold backward placing threads step vng construction demand driven version third step computing availability 
user computation demand driven vng analysis performs steps 

place threads leading symbolic back substitution backward direction 
placing threads look computations generate kill value solving availability 
complete dataflow analysis marking threads leading availability solution 
step proceeds forward direction 
value numbering explained 
reasons 
demand analysis folds third steps exhaustive construction bypassing second step combined proceeds opposite direction 
second build threads optimized computations threads merged 
page illustrates reuse captured demand vng analysis 
analyzed demand recompute value lie thread 
contrast analyzed demand recomputation value missed requires placing thread second reason collapsing thread reason 
important issue explained 
clearly described demand approach works forward dataflow problems 
backward problems reversed demand driven direction aligned backward direction back substitution 
deficiency significant situations 
removal conditional branches solution anticipability backward problem needed explained chapter 
similarly version speculative pre require anticipability pre estimator chapter 
second backward problems computed vng built demand albeit imprecisely threads placed demand analysis backward problems computed 
threads placed conservatively imprecise solution may obtained 
query propagation demand driven vng analysis context branch correlation detection 
analysis demand driven conditional node nodes may lie correlated path visited relevant data flow information computed 
analysis initialized raising query conditional corresponds asking question outcome conditional predicate relop known incoming paths form raised query relop variable constant 
note query format arbitrarily general affecting algorithm 
fact query format corresponds directly language symbolic names draw symbolic names vng construction allowed pick freely 
query propagated conditional backwards paths icfg resolved paths 
resolving query node produces answers true false undef 
answers minor extension value path sensitive lattice see definition 
indicate path query reached node correlated 
true means outcome conditional path true true outcome taken 
answer false means opposite false outcome taken 
undef means outcome unknown variable assigned unknown value 
resolving query identified sources static correlation 
query resolved true false node assigns constant variable query 
conditional branch involves variable 
assertions variables exist true false edges conditional may define outcome predicate query 
note conditional correlates path loop query variable defined 
type conversion unsigned signed value example 
result non negative may determine branch predicate outcome 
pointer variable dereferenced value guaranteed non zero tion fault occurred 
propagation copy assignment query variable may encountered happens query modified reflect assignment continues propagate 
simple form symbolic back substitution essential capture assignments temporaries common sions procedure return values parameter passing 
consequence substitution multiple distinct queries raised single node 
query format fixed relop number queries raised node number program variables 
general query formats limiting back substitution terminate query propagation see section page 
analysis terminates resolved queries rolled back paths traversed 
goal collect resolved answers query raised node 
starting successors nodes query resolved answers propagated forward merged set union operation control flow merge nodes 
node including conditional query may possible answers true false undef 
example query raised conditional answers true false correlated paths leading conditional outcome true correlated paths false paths unknown 
conditional full correlation 
computing procedure summary nodes interprocedural analysis interprocedural control flow graph icfg combines cfgs program procedures connecting procedure entries exits call sites depicted 
edges define predecessor successor relation nodes 
procedure pred analyze predicate relop conditional branch node initialize node form initial query relop nil raise query worklist empty remove pair node query worklist case entry node procedure summary node query add entries trans predecessors undef call site node predecessor entry node summary node query th exit raised th exit raise query raise query case call site exit node procedure exit predecessor call site predecessor entry node invoked query summary node entry exist copy add trans entries query raise entries exist raise query entries raise query answer resolve answer true false undef answer pred raise query substitute case procedure raise query node query add add pair worklist interprocedural static correlation analysis 
cal site exit nodes call site node call site procedure entry nodes procedure exit nodes procedure call site interprocedural cfg call site normal form 
multiple procedure entry nodes multiple procedure exit nodes support transformation chapter 
successors call site node procedure entry node associated call site exit nodes 
analysis algorithm requires icfg normal call site form call site node single procedure entry successor call site exit node exactly call site predecessor procedure exit predecessor 
assumed nodes dummy nodes program statements 
computation summary nodes motivated demand driven framework dgs computes procedure summary nodes demand order improve efficiency interpro analysis 
analysis queries propagated procedures backwards summary node entries stored procedure exit nodes query raised exit node maintain answers resolved procedure corresponding queries entry procedure query propagated way entry node 
queries raised procedure exit nodes compute sum mary nodes treated specially 
summary node query reaches procedure entry propagated callers resolved fourth kind query answer trans 
answer marks paths procedure query resolved 
procedure transparent paths summary node lookup propagate queries backward collect answers forward call sites transparent procedures 
analysis handles call value call parameters 
analysis algorithm 
algorithm computes summary nodes interrupting analysis 
query tuple relop summary node queries keep pointer summary node entries non summary queries field nil 
summary node entry query raised exit node tuple summary node query raised procedure exit node entries set queries propagated particular entry node 
algorithm procedure allowed multiple entry nodes support entry splitting chapter 
analysis started line raising initial query predecessor conditional analyzed 
line terminates analysis node unresolved query remains 
lines handle procedure entry nodes 
summary node queries resolved trans added summary node entry having reached particular entry node described 
non summary query propagated call sites entry lines 
summary node query propagated computation summary node initiated exit call site lines 
lines process call site exit node 
predecessors determined 
summary node lookup line fails new summary node entry created summary node query raised 
lines update summary node previous split procedure entry exit node 
line resolves query answers saved summary node line propagates query procedure transparent path procedure exists 
kind node may main 
call 
nil nil nil nil tr source program analysis rollback sne sne sne sne nil nil nil example interprocedural correlation analysis 
nil sne tr sne sne tr sne entries sne source correlation lines 
function resolve attempts resolve query 
fails query propagated back substituted 
algorithm collecting analysis answers propagating forward easily derived analysis algorithm 
analysis illustrated example 
possible query answers abbreviated tr query answers true false undef trans 
analysis conditional node initiated raising query predecessor 
entry signifies query compute summary node entry 
global variable propagated intraprocedural edge raised exit procedure initiates computation summary node entry summary node entry computed raising summary node query procedure exit node query resolved node undef unknown value assigned nodes query resolved highlighted 
scope summary node limited procedure resolved procedure entry node trans 
query recorded field summary node entry 
summary node query reaches procedure entry corresponding query raised call site node 
case query raised node query subsequently resolved nodes undef false respectively 
analysis followed rollback phase 
answer query stored consists answers reaching node 
note undef answer node propagated node trans answer summary node query 
algorithm fpr performing roll back shown 
inter procedural transformation example motivation illustrate utility entry exit splitting small program calls library procedure 
program branches redundant outcomes determined prior statements branches 
show inter procedural restructuring icbe eliminates execution branches resorting inlining 
program shown section illustrate inter procedural value flow analysis 
demonstrate transformation remove redundancies detected analysis 
program calls stdio gnu library glibc version 
function main opens text file call fopen iterates character file eof reached 
characters collect answers queries raised analysis branch add relop nil initial query raised branch worklist set nodes query resolved predecessor add trans worklist empty remove node worklist query th exit call site invoking th entry procedure th exit procedure add query entries resolved node pred add substitute answer added add succ worklist roll back algorithm 
obtained call fgetc returns character buffer buffer empty calling 
consider conditional main tests loop exit condition eof 
elaborated detail section outcome true path false path assuming code function unavailable optimizer deduced return value behavior determined path node summary conditional partially redundant sub paths reaching 
words analysis discovered static correlation executed outcome known 
optimize reuse paths separated 
separation paths paths isolate optimization condition isolated paths branch passed branch jump different target path 
procedures pose obstacles desired path separation 
procedures traditionally viewed single entry single exit regions code means paths procedure pass unique entry exit points 
exploit inter procedural opportunities conditional branch elimination correlated paths crossing procedure entry exit isolated splitting procedure en try exit nodes 
separate paths procedure return perform exit splitting creates exits called procedure 
exit split conditional bypassed eliminated time executed buffer node see 
exit splitting implemented passing callee additional return addresses section efficient implementation technique cost independent number exits 
optimize conditionals function fgetc 
conditionals analysis detected reuse originating procedure fopen fp magic holds path 
case conditionals fully redundant eliminated paths separation necessary recall reason 
main false true define eof define null int fp fopen file fgetc fp eof process unsigned char uc fp null int fp magic fp magic errno return eof fp fp fp fp get limit fp source program 
main fp fopen file fgetc fp int eof process return int fgetc fp uc fp uc fp null unsigned char uc int fp magic fp magic errno return eof int fgetc fp fp fp fp fp get limit fp return optimization 
file fopen main uc fp uc return 
fp fopen file fgetc fp fgetc fp process int fp null fp magic errno return eof int fgetc fp fp magic fp fp fp return fp fp get limit uc fp uc return elimination exit splitting 
example program gnu library 
main fgetc fp fp get limit uc fp uc process fp fp fopen file process fgetc fp partial inlining fgetc 
optimizer splits exit fopen entry fgetc bypass conditionals 
result shown 
call site entry exists statements fgetc reachable original entry deleted call site entry exists 
assume code available optimizer 
information analysis detects returns unsigned value 
case outcome determined 
exit splitting conditional completely eliminated shown 
appreciate power inter procedural transformation consider amount branches removed 
unoptimized program loop iteration executes conditional branches 
opti mization conditional remains 
optimization carried intra procedural branch elimination mw inlining applied 
furthermore icbe reduces code size procedure fgetc enables partial inlining main resulting reduced loop efficiently software pipelined see 
inter procedural pre algorithm chapter illustrates inter procedural value flow optimization means redundant branches arithmetic computations previous chapters start showing cmp region naturally supports intraprocedural removal branches 
proceed extend cmp restructuring inter procedural setting 
intra procedural branch removal briefly review value flow analysis conditional branches described section 
conditional branch path value flow analysis may detect exactly events branch outcome true false known compile time 
phrase valued branch redundancy valued value flow framework treat true false branch outcomes independently complementary branch exits redundant 
avail avail antic antic intra procedural restructuring 
eof path redundant 
example conditional branch eof split branch exits eof branch exit analyzed may lattice 
path leading branch solution availability avail meaning branch exit redundant path branch exit taken path taken branch condition need evaluated 
branch redundant path path taken branch condition evaluated determine branch exit complementary exit taken 
avail solution branch may path branch bypassed path branch evaluated 
vng complementary branch exits associated edges condi tional branch node shown 
depicts cmp region conditional expression 
note branch exit coincides exit edge cmp region 
reason coincidence branch exit may anticipated branch node branch exit computed path node 
consequence code motion applicable removal redundant conditional branches hoisting immediately hit cmp region restructuring 
cmp region branch exit indicates restructure just computation 
cmp region duplicated copy evaluate branch 
copy region branch outcome known disconnect complementary branch exit unreachable eliminate branch concludes transformation 
interprocedural cmp region computed interprocedural vng representation computed icfg see similarly way vng computed cfg 
inter procedural restructuring entry splitting occurs correlated path entering procedure procedure entry node 
entry splitting involves call site splitting 
exit splitting occurs correlated path crosses procedure exit node 
exit splitting involves splitting call site exit nodes 

call source program tr 
tr tr tr analysis tr analysis tr tr tr tr procedure exit node split call site normalization call site normalization ii optimized program redundant removed inter procedural restructuring 
label denotes query answer label denotes query answer 

tr call site exit node split call call icfg representation normal call site form duplication procedure entry exit nodes require little special handling 
required consult procedure summary function attaching edges connect call site node call site exit nodes 
handling added lines 
code normalizes call site normal form shown 
illustrates inter procedural restructuring 
shows source program annotates nodes icfg answers queries raised analysis fig ure 
marks cmp region 
triangle denotes trans entry edge 
note node belong cmp region lies path reuse path path free path 
node need split call site node split sufficiently splits paths 
fact reflected avail solution node contains trans single answer 
show icfg cmp region caller callee duplicated respectively 
notice call site related edges attached 
particular edges exist call site node may follow callee trans path producing solution call site exit node path 
put restructured call site normal form 
implementation details section elaborates important implementation details entry exit splitting 
efficient implementation exit splitting 
second show entry exit splitting applied call sites invoke multiple procedures virtual procedures object oriented languages 

return points array exit splitting code segment push push jsr ret implementation exit splitting 
naive implementation exit splitting pass alternative return addresses callee additional procedure arguments 
dynamic number instructions added implement exit splitting style proportional number procedure exits potentially high cost 
outlines method cost independent number exits 
passed arguments alternative addresses placed return points array static memory block initialized link time stored text segment 
return addresses stored immutable text segment addresses remain entire execution call site 
return points array starts immediately call site jsr instruction 
placement benefit machine dependent return register denoted points array allowing fast access alternative return addresses 
access array procedure returns fetches return address unique index return points array 
cost exit splitting single load operation executed just return operation 
entry exit splitting virtual procedures entry exit splitting enables optimization multi target call sites call sites virtual proce object oriented languages 
call sites generally amenable procedure inlining preferred albeit potentially expensive transformation enabling inter procedural optimizations 
inlining allowed virtual call sites may invoke different procedure time executed depending type receiver object 
call site invokes procedure analyzer able safely confirm fact 
virtual call sites invoke callee indirectly fetching address table pointed receiver object 
various organizations virtual lookup developed purpose assume address procedure entry obtained indexing lookup table type receiver object method name table type methodname ret ret entry splitting possible indirect calls simply indexing lookup table type call site 
table type callsite indexing call sites call method type invoke different entry entry splitting performed table distinguish entries 
importantly lookup scheme require invoke different entry possible receiver types 
particular type optimized call sites invoke original entry method 
simply means forgo path specific optimization opportunities created splitting paths leading original call site entries split 
conversely optimized method take advantage opportunities original entry called call sites 
algorithm 
transform virtual call site inter procedural pre algorithm need modified 
require icfg representation connects call site nodes possible callees call site node multiple successors call site exit node multiple predecessors 
prerequisite entry exit splitting multi target call sites number callees relatively small 
procedures invoked useful know callees frequently executed allow profile guide selection methods 
application inter procedural conditional branch elimination section puts demand driven analysis section transformation section 
develop optimization removal inter procedurally correlated con ditional branches 
pre algorithm potentially expensive approach profile guided eliminate conditionals benefit compute pre estimator code duplication cost 
conditional branch considered icbe optimization performs analysis followed restructuring 
conditional analyzed detect correlated paths determine amount code duplication required eliminate conditional 
correlation demands code growth acceptable program restructured create paths conditional instructions compute predicate condition eliminated 
find conditionals matching analyzable pattern relop select conditionals high execution count profile available selected conditional branch detect intra inter procedural correlation conditional correlation required code duplication limit restructure program implementation 
analysis transformation algorithms implemented interpro compiler retargetable compiler lcc fh 
implementation considered alternative index table type method name index procedure entry 
save table space certain situations 
correlation conditionals compared scalar variable structure member con stant 
conditionals benchmark programs analyzed pattern 
implementation included intraprocedural correlation analysis mod ck procedure summary information call sites inter procedural analysis detected intra inter procedural correlations 
analysis recognized sources correlation con stant assignments conditional branches 
benchmarks 
experiments performed integer spec suite 
generate correct code gcc benchmark lcc compiler benchmark program 
programs characterized table 
number procedures defined program library procedures called table 
correlation analysis analyze library procedures assumed worst case behavior call sites 
node representation corresponds dag multiple operations may viewed high level node 
ratio number conditional nodes number nodes executable higher usually reported columns 
note number nodes column includes label nodes 
dynamic profile information collected input set 
benchmark source procedures nodes cond prog program lines defined library cond static dynamic go ksim compress li ijpeg perl vortex lcc table benchmark programs 
behavior statically detectable correlation 
conducted experiments determine amount statically detectable correlation paths restricted procedure paths cross procedure bound aries 
top left graph depicts number conditionals exhibit correlation outcome known necessarily incoming paths 
total number conditionals program base graph shows program percentage conditionals analyzable implementation percentage conditionals correlated intraprocedural analysis percentage correlated interprocedural analysis 
re sults show twice correlated branches detected interprocedural analysis intraprocedural analysis 
top right graph presents information weighted execution count conditional showing correlation detected conditionals execute frequently 
bottom graphs show number conditionals full correlation 
outcome conditionals known paths completely eliminated code duplication necessary true false correlations discovered 
benefit interprocedural analysis evident 
fully correlated conditionals optimized programs execute conditionals intraprocedural analysis enables reduction 
fact useful correlation exists procedures conditionals conditionals benchmark time memory mb node query pairs program analysis analysis total cond go ksim compress li ijpeg perl vortex lcc conditionals correlation static count go ksim compress li go ksim compress li ijpeg perl vortex lcc conditionals full correlation static count ijpeg perl vortex lcc table cost correlation analysis 
conditionals conditionals conditionals correlation dynamic count go ksim compress li conditionals full correlation dynamic count go ksim compress li ijpeg perl vortex lcc ijpeg perl vortex lcc characteristics statically detectable branch correlation 

analysis 
analysis analyzable conditionals considered supports hypothesis write procedures isolated fashion repeated computation caller callee 
branch elimination optimizer replicates code eliminate conditionals creating separate paths 
amount code duplication increases distance correlated branch source correlation extent code duplication estimated interprocedural optimization applied 
plots cost benefit relationship correlated conditional 
point graphs represents conditional correlation 
coordinate point number nodes created due code duplication conditional eliminated 
coordinate shows amount dynamic instances conditionals avoided elimination conditional 
comparison intraprocedural results reveals substantially correlation detected pro considered full correlation graphs suggest 
interprocedural correlation requires code duplication cases correlation may span large part call graph 
amount frequently executed correlated conditionals low duplication needs posi tioned upper left quadrant increased interprocedural analysis 
conditionals icbe beneficial intraprocedural elimination code growth higher reduction elimi removed conditionals cond 
dynamic intraprocedural code duplication nodes interprocedural code duplication nodes contribution branch removal vs code duplication requirements correlated conditional 
nated branches achieved 
number eliminated dynamic instances optimized conditional estimated execution counts nodes analysis query resolved 
early termination heuristic terminates query propagation certain number nodes visited 
outstanding queries resolved undef 
experiments anal ysis terminated visiting nodes 
result analysis magnitude faster benchmarks vortex small fraction undiscovered 
provides ex majority optimizable nodes require small amount duplication small amount query propagation steps 
analyzing expensive conditionals loses opportunities gains lot analysis speed notice axis logarithmic 
eliminated branches 
goal eliminating conditionals causing reasonable code growth easily achieved approach icbe optimizes conditionals performing analysis restructuring optimization conditional 
amount code growth necessary optimize conditional determined analysis phase 
restructuring phase executed number new nodes created predetermined limit 
optimized benchmarks various values conditional duplication limit 
conditional optimized number node duplicates required optimization increase ranged 
shows amount conditionals eliminated incurred code growth 
point graph corresponds duplication limit value 
note different ranges bottom row 
experiment analysis terminated node query pairs examined see line queries resolved 
program numerous conditionals test global variables early termination demand driven analysis avoids far reaching prop queries dramatically reduces analysis time 
early termination possible demand driven analysis 
queries remaining analysis termination limit reached tively resolved undef 
terminating analysis nodes sufficient find correlated branches require approximately duplicated nodes 
correlation detected early termination missed opportunities prohibitive due high code duplication demands 
ter analysis early practical improvement 
note values duplication limit inter procedural analysis may produce worse optimization perl benchmark intra procedural counterpart 
reason analysis termination limit reached examining callees missing intra procedural opportunity 
problem alleviated exper increasing analysis termination limit 
note results computed infinite termination limit 
conclude code increase icbe eliminate significantly dynamic conditionals intra procedural counterpart code growth tolerated icbe offers opportunities additional branch elimination conditional limit code duplication effective way control code growth 
better heuristic deciding apply optimization consider amount conditionals eliminated opposed incurred code growth done experiments 
related branch elimination intraprocedural elimination conditional branches loops developed mueller ley mw 
icbe extends technique respects 
detect eliminate partial redundancy branches loop nests procedure boundaries 
second scope single procedure icbe powerful detect redundancy apparent examining multiple basic blocks path opposed redundancy due single basic block detected analysis 
addition icbe analysis cost code growth incurred due program restructuring con 
mueller whalley mw investigated avoiding unconditional jumps code replication 
krall kra developed code replication techniques improve accuracy semi static branch prediction accuracy dynamic prediction 
benefits entry exit splitting primary benefit icbe reduction instruction count schedule length elimination correlated conditionals operations compute predicate 
section discuss correlation analysis inter procedural restructuring applied areas compiler optimization 
procedure inlining 
inter procedurally visible opportunities branch elimination exploited inlining subsequent application intra procedural elimination conditionals mw 
knowledge correlated paths call graph pre pass inlining process resort exhaustive inlining critical program regions 
short folding procedures single flat procedure guarantee statements involved correlation procedure necessary remove branch 
clearly pre pass inlining incurs large code growth 
inlining practical directed inter procedural correlation analysis 
correlation branch detected procedures involved correlation merged post analysis inlining 
solution icbe may desirable existing compiler inlining intra procedural branch elimination supported 
code growth post analysis inlining may lowered performing full icbe inter procedural restructuring followed partial inlining hhr frequently executed paths optimized procedure inlined 
inlining recursive virtual library procedures may feasible 
case inter procedural restructuring applied carry icbe 
dynamic conditionals eliminated ksim lcc ijpeg vortex code size increase compress perl go code size increase reduction executed conditional nodes vs program code growth various values conditional code duplication limit 
li regardless exact icbe scenario correlation analysis produces upper bound code growth required eliminate conditional profile information available provides profile estimate cost effectiveness optimization applied 
inlining algo rithm ags inlines procedures execution rate code growth budget exhausted 
correlation analysis inliner give procedures generate correlation higher priority correlated branches removed inlining car dh 
ing algorithm eliminate correlated branches code growth budget inlining exhausted code growth demands smaller inlining 
richardson rg observed benefit inlining comes mainly eliminated procedure call overhead 
analysis able identify procedures inlining create intra procedural optimization opportunities branch removal 
virtual calls sites 
object oriented languages complicate inter procedural compilation call sites member procedures polymorphic types may transfer control procedures depending concrete type receiver object 
call sites require expensive dynamic dispatching methods elimination concrete type inference developed ah pc pc 
methods demand driven inter procedural analysis determines call site set reaching concrete types subsequent program restructuring separates paths clones procedures goal creating call sites reached single type receiver 
analogy concrete type inference methods compute optimizable nodes set union optimization opportunities enable optimization making opportunities unique path separation 
icbe collects values variables determine branch outcomes type inference interested types receiver objects 
respect restructuring algo rithms transformation powerful cloning exit splitting able separate paths cross exit node cloning achieve 
section described entry exit split ting performed virtual call sites 
entry exit splitting prove valuable object oriented languages cost passing additional return addresses small compared dynamic dispatch 
concrete type analysis successful enabling inlining virtual call sites call sites require dynamic dispatch 
case entry exit splitting described sec tion 
fine grain computer architectures 
elimination conditional branches especially important wide issue superscalar vliw architectures instructions pre fetched executed spec conditional branches predictions outcomes 
increasing processor parallelism branch density stream instructions critical expensive mechanisms required predict issue multiple conditional branches single cycle joh 
experiments shown executed conditionals eliminated icbe reducing branch density 
mispredicted branch stalls processor cycles instruction cache 
research correlation hardware branch prediction shows unpredictable branches exhibit correlation earlier branches 
unpredictable branches arguably eliminated icbe 
consider example procedure removes element linked list 
average list length low conditional tests empty list unpredictable 
test correlated conditional tests return value caller 
optimization unpredictable branches especially high payoff 
icbe improve effectiveness software pipelining lh rg re number conditionals statements loop body illustrated example 
elimination branches significantly speed loop schedule conditionals form recurrent cycles control dependencies eliminated 
branches testing flag value assigned loop examples conditionals 
assisting hardware branch prediction 
run time prediction schemes proposed predict outcome branch correlation branches slm 
exact source correlation known outcomes maintained prediction slowing learning process predictor 
correlation statically detectable analysis provide prediction hardware directions branch es prediction 
procedure cloning 
analysis improve effectiveness procedure cloning performing inter procedural analysis applying intra procedural restructuring 
inter procedural restructuring information correlation crosses procedure boundaries clone copies procedure 
clone procedure call node split multiple nodes call clone 
clone copy modified take advantage correlation 
previous chk cloning constants approach take advantage correlation cloning 
library procedures 
possible compile library procedures ap plication program take advantage correlation crosses application library boundary 
library procedures pre split optimization respect characteristic application programs summary nodes describing resulting entry exit splitting conveniently stored library interface lookup optimization user program 
example separate exit malloc exist taken return value null 
large portion correlation exists calls related library procedures characteristic program may small 
original unoptimized procedure entry maintained library procedures 
entry invoked procedure exits return control standard return address compilers icbe library 
inter procedural optimizations 
path separation entry exit splitting eliminate control flow merge points conservative merging data flow information procedure boundaries reduced 
result optimizations procedure cloning partial redundancy dead code elimination may effective inter procedural restructuring 
icbe optimization optimize array bounds checks kw gup typically exhibit correlation 
branch elimination component aggressive program transformations slicing partial dead code elimination bg 
chapter experimental evaluation chapter experimentally evaluates power pathfinder framework 
develop instance framework specialized removal redundant load operations measure various properties 
particular focus comparing pathfinder ideal optimizer 
ideal optimizer value flow analysis detects reuse apparent program text value flow transformation re moves detected reuse 
main focus measure completeness vng representation decides success value flow analysis pathfinder framework 
completeness transforma tion stage evaluated chapter pre ms shown near complete 
gauge completeness vng representation need ideal program analysis exposes reuse program 
detecting reuse undecidable problem ideal analysis carried statically 
obtain ideal performance dynamic program analysis 
observing run time stream memory collect pre exploitable reuse treat ideal analysis performance 
compare static value flow representation dynamic ideal value reuse estimators compute data flow solution program profile dynamic amount reuse detected static analysis 
experiments show loads executed spec exhibit reuse 
analysis exposes 
chapter starts describing register promotion optimization removes redundant load instructions 
suitability register promotion evaluating pathfinder framework justi fied 
method measuring amount value reuse inherent program empirical measurements ideal reuse 
chapter compares amount reuse removed pathfinder ideal amount 
instantiating framework register promotion comparison caches best hardware defense von neumann memory bot 
capitalizing data locality caches win reusing memory accesses 
compilers benefit reuse opportunities 
ideal case compiler promotes repeatedly accessed memory locations registers 
register promotion best compiler solution reducing memory traffic 
removing redundant loads register promotion decreases dynamic operation count shortens instruction schedules 
section describes register promotion shows derived pathfinder 
outline evaluation approach justify reasons selecting register promotion basis evaluation 
register promotion entails subproblems 
load reuse analysis finds loads stores access address execution paths reuse exists 
framework load reuse analysis consists vng representation chapter dataflow analysis carried representation chapter 
second alias analysis verifies reuse detected vng disrupted intervening stores 
framework effects killing stores incorporated dataflow analysis 
program transformation stores prior memory access register replaces redundant load register 
framework transformation phrased partial redundancy elimination chapter 
reasons register promotion basis evaluation pathfinder 
removing memory accesses important optimization 
memory operations expensive execute parallel require multiple ports hardware cache 
comparison register access cases cheaper operation 
additionally load reuse opportunities 
experiments show load opera tions redundant removed 
removing loads enabling optimization 
values passed arithmetic logical instructions memory means loads stores optimization scopes broken memory accesses small detecting arithmetic value flow 
develop relatively precise dynamic analysis 
point view dynamic run time analysis value flow memory loads access memory location 
contrast appears dynamic detection branch correlation lower precision involve mining correlation boolean values unique memory addresses 
chapter focuses mainly component register promotion load reuse representation analysis 
optimization powerful analysis improving precision analysis high significance 
second component alias analysis different aim load reuse analysis detects memory go location alias analysis finds may identifying killing stores 
research indicates register promotion simple alias analysis may sufficient dmm lc 
third component pre transformation evaluated section shown near completely eliminate detected reuse 
chapter concentrate evaluating amount detected reuse vng representation 
say analysis pre complete detects reuse pre transformation exploit 
typically optimizations evaluated reporting amount computations removed 
un fortunately absolute measure says little potential remains 
evaluation measures level pre completeness far analysis ideal 
detecting load reuse general undecidable hope find approximation ideal reuse amount 
purpose perform dynamic analysis program 
dynamic analysis simulation limit study observing dynamic stream memory find reuse available input upper bound pre exploitable reuse program 
microprocessor optimizations simulation limit studies long guiding re search direction evaluating designs 
result research processors offer impressive solutions compiler problems memory disambiguation ce redundancy elimination ls 
compiler optimization limit studies identify potential point bottlenecks evaluate algorithms 
chapter load reuse simulator section analysis chapter chapter data flow solution estimator weighted solution transformation program input profile reuse level comparison experimental setup 
section static load reuse analysis identifies redundant loads reuse paths dynamic limit study yields run time number redundantly executed loads 
compare disparate quantities weight static reuse program profile generated simulator 
result run time amount statically detected redundant loads 
outlines experimental setup 
value flow analysis composed vng dataflow analysis carries static analysis program 
dynamic analyzer composed simulator runs program input outputs pieces dynamic information 
reuse level measured percentage executed loads reuse value prior memory access 
second information edge profile collected simulation run program 
simulation dynamic analysis described section 
profile combined dataflow analysis solution producing dynamic amount reuse detected static analysis 
analysis detected reuse compared ideal reuse level 
results reported section 
pathfinder profile weighted reuse evaluating analysis navigate transformation 
ideal amount value flow section focuses load reuse visible run time 
simulation limit study multiple uses measuring amount reuse programs large optimization potential register promotion evaluating load reuse analysis providing point close analysis ideal performance tuning analysis redundantly executed load instructions 
section describe design simulation show large fraction loads executed spec exhibits reuse opportunities 
primary limit study evaluate precision completeness load reuse analysis 
precision measured level completeness 
analysis complete detects reuse removed program program transformation 
context partial redundancy elimination pre chapter 
pre code motion transformation exploit reuse exists subset execution paths incoming redundant load 
pre basis modern register promotion techniques ck bg sj lck 
unfortunately detecting load reuse general undecidable ram compile time pre complete load reuse analysis exists 
empirical run time analysis measures reuse program program executes 
order provide close approximation pre completeness simulation limit study collect reuse pre remove reuse power pre 
simulation mimic character pre transformation 
described detail chapter pre removes redundancy hoisting partially redundant load control flow paths reaches memory operation generates reuse 
point contents promoted memory location stored register carries contents original load 
pre performed vng representation load reuse restricted acyclic paths reused value carried multiple registers small number loop iterations 
recall parameter instructs back substitution build vng consecutive loop iterations see 
summary pre operational restriction redundant load reuse result static instruction result small number dynamic instances old 
simulation algorithm reflects pre property 
run time reuse detected static memory instruction access history dynamic stream addresses 
dynamic instance load redundant prior load store accessed location intervening store 
intervening store occur load redundant intervening store reuse source 
simulation technique contradictory goals 
hand limit study yield upper bound reuse removed pre detected 
hand bound tight reuse static load intermittent sporadic input dependent filtered noise 
example reuse recurrent array accesses store load pre exploitable allocating registers carry value iterations ck bg hand reuse noise 
consecutive loads hash table may access location reuse guaranteed occur time program takes path loop back edge 
pre exploit reuse 
read 
hash verify pre requirement path carries reuse time followed simulator extensive bookkeeping followed paths 
consequently favor noisier tight upper bound expensive simulation 
reduce noise limit number memory cells remembered access history static load store 
small number accesses sufficient capture loop carried reuses example ck 
simulation parameter counterpart vng parameter 
pre inherently instruction level optimization 
capable exploiting loop level reuse loads 
hoisting 
loops merged loop fusion cmt pre harvest reuse 


load store dynamic count normalized loads redundant due reuse dynamic loads go reuse history reuse history reuse history reuse history ksim gcc source program optimization register allocation 
compress li ijpeg dynamically detected load reuse 
inlining code growth spec input set train 
simulation algorithm correctly identify load redundant access history remembers accesses load 
simulation consistent power pre 
vortex reuse level 
plots amount simulation observed load reuse 
benchmark experiment carried points compilation original program optimiza tions register allocation 
compiler impact cmc optimizations included local global loop invariant redundant load elimination superblock optimizations hmc 
note floating point benchmarks right removal loads ac decrease observable reuse integer benchmarks optimizer left redundant loads unoptimized suggests programs complex control flow require powerful path sensitive optimizations better alias information 
note increase observed reuse register tomcatv allocation due spill code loads target processor pa 
show amount reuse history depth 
increasing history depth raises observable reuse integer programs scientific ones recurrent accesses expected captured increased history 
manual examination simulation results strongly suggests additional reuse collected deeper access history mainly noise similar intermittent reuse hash table example 
shown graph fraction reuse generator redundant load belong procedure 
reuse patterns strictly intra procedural procedure returned called reuse 
intra procedural reuse levels serve point intra procedural load reuse analysis section 
input variance 
profile directed optimization simulation directed optimization design valuable program input exercises input independent pervasive program characteristics 
swim su cor hydro loads stores benchmark input opti train test ksim big big compress ref reuse reuse loads stores li boyer test queens table sensitivity load reuse level program input 
column gives number executed loads stores 
ideal alias info calls array pointer stores calls stores calls reuse killed go ksim gcc compress li reuse seen simulator effects symbolic language pointer aliasing amount detected reuse 
reuse vary different inputs 
modified inputs benchmarks compared observed reuse 
results shown table 
input variation reuse level may suggest reuse largely input independent 
greatest difference inm ksim input directs execution different procedures 
reason benchmark reuse generated stores test input fractions add reuse instance may generated multiple instructions load store 
manually discovered lower reuse larger input due fewer noisy loads 
input variance may useful noise reduction mechanism intersection reuse detected different inputs may determine regular statically detectable reuse 
memory requirements simulator 
simulation limit study considerably expensive control flow profiling design tune analysis cheaper profiling repeated optimize program 
simulation speed acceptable seconds loads stores executed pa 
memory required varied greatly 
largest data structures needed mb mb hash table smallest mb hash table 
completeness value flow analysis section experimentally evaluates static value flow analysis relation dynamic limit study section 
implementation analysis intra procedural point comparison intra procedurally observed reuse 
minimize noise baseline reuse collected access history 
analyzed unoptimized source programs 
summary ijpeg vortex tomcatv swim hydro su cor benchmark baseline comparison mark leftmost column 
plots amount reuse discovered analysis 
plotted amount computed average lower upper bounds returned cmp estimator 
load reuse analysis carried varying assumptions 
highest lines fig ure show reuse detected level level address indirection respectively 
implementation considered indirect loads stores may explain lack indirect reuse benchmarks 
determine reuse detection power analysis lines assumed perfect aliasing stores reuse paths kill detected reuse 
aggressively detected reuse promoted registers exploited alternative reuse mechanisms data speculative loads noted section 
comparison limit study shows analysis pre complete 
aliasing 
studied killing effects intervening stores procedure calls 
compiler perform alias analysis considered hypothetical levels pointer aliasing precision specified follows assumed procedure calls killed detected reuse second added kill set stores stores global variables third stores procedure calls killed reuse 
due aggressive inlining small amount reuse lost procedure calls white bar segments 
array pointer stores remove third reuse dark middle segments 
pessimistic hypothetical aliasing gives disappointing results researchers showed simple alias analysis may produce memory disambiguation near optimal purposes register promotion dmm lc 
experimented noise reduction heuristics 
classified noise redundant loads observed reuse included dynamically insignificant generators dynamically frequent ones 
conservative noise reduction criterion filtered noisy reuse ingo compared baseline 
allows conclude load reuse analysis successful average observed reuse captured 
miscellaneous powerful load reuse analysis beneficial register promotion prevented due aliasing lack registers 
case pre transformation step employ alternative albeit effective reuse mechanisms 
promotion unsafe due interfering stores redundant load replaced data speculative load works register kill occur load ksr bg wu 
registers available load reuse exploited software cache control ksr 
directing loaded values remain cache bypass compiler improve sub optimal hardware cache replacement strategy 
experimentally investigated demanding pre respect number registers consumed 
register pressure cfg node number memory locations reuse path crosses node memory location needs register 
averaged register pressure nodes weighting node profile frequency 
level perfect aliasing analysis configuration highest average register pressure registers cor 
amount registers soon available general purpose processors 
compiler optimization dynamic program specialization hg processor architecture spectrum program optimization approaches 
optimization technologies equipped unique strengths replace 
methods value flow optimization conclude chapter comparing pathfinder representative compiler optimiza tion technology value prediction representative architectural approaches program optimiza tion svs ss ls 
describe experiment helpful refresh program optimiza tion spectrum shown 
qualitatively technologies compiler optimization dynamic optimization processor architecture operate different principles 
particular differ greatly exploit program text static analysis exploit values computed program dynamic analysis 
major question final experiment attempts answer different technologies quantitatively 
particular redundant computations technology remove experiment compares dynamic amount reuse removed pathfinder dy namic amount values predicted different value predictors value predictor ls delta stride predictor svs context predictor svs 
predictors allocated element store value stride static instruction 
size context predictor table mb 
prediction compiler optimization performed results load instructions 
measurements plotted 
notes 
expensive context predictor significant number computations removed compiler 

computations predicted stride predictor probably removed loop unrolling strength reduction 
considered form value flow optimization removed instructions compute value previous instruction plus offset 
compiler optimization reuse redundancy removal value prediction loads removed predicted dynamic count processor architecture predict value predictor value stride context expensive 
mb table comparing power value flow analysis value prediction 
interesting compare pathfinder instruction reuse ss ss hard ware technique predict values value prediction looks call value reuse table compiler value reuse 
value reuse table indexed values arguments operation reused 
sense instruction reuse similar compiler optimization value prediction 
chapter value flow optimizations backbone compiler techniques enhancing instruction level parallelism 
unifying paradigm optimizations exploit program property results operations previously computed 
value recomputation detected redundant operations removed substituted cheaper ones 
result program code improved ways 
eliminating useless computations instruction schedulers freed hardware resources construct shorter schedules 
second operations deleted critical path program dependencies optimization achieves faster execution resources bottleneck 
observations values computed program execution suggests compilers numerous value optimization opportunities highly optimized programs executed instruc tions compute value previous dynamic instance 
shown experiments instructions source redundant recomputation program expressions equivalent frequent execution paths 
executions expression optimizable paths redundancy conventional optimizers conservative analyzers fail expose inflexible transformations fail remove 
summary contributions thesis unified generalized improved value flow optimizations 
particular emphasis placed path sensitivity aim complete exploitation opportunities may exist execution paths visible individual paths examined separately 
goal accomplished defining class value flow problems identifying member optimizations 
value flow class broad practically significant partial list includes loop invariant code motion constant propagation load store elimination branch removal 
step problems shared optimizations value flow class identified enabling development optimization framework common optimization issues addressed uniformly entire class 
main result thesis optimization framework deriving path sensitive versions value flow optimizations 
major obstacle prevents construction practical path sensitive frame exponential cost incurred exponentially individual program paths optimized 
exponential cost comes forms analysis cost program path may different optimization opportunity 
transformation cost program paths may offer optimization opportunity 
profiling cost perform cost benefit trade offs may require execution frequency program path 
thesis presents techniques costs practical maintaining optimization power nearly optimal level 
specifically exponential cost attacked dividing pathfinder optimizer stages program representation dataflow analysis program transformation 
stages thesis develops new techniques 
contributions summarized 
representation 
developed value name graph vng novel program representation models flow recomputed value 
symbolically naming value vng reduces hidden value flow exposed data flow 
representation called value name graph names value demand set optimized computations 
names formed separately path obtaining path sensitivity paths analyzed separately matters value different name 
analyzing paths separately offer different optimization opportunities value different name representation reduces exponential analysis cost 
profile weighted dataflow analysis 
navigate transformation trade offs dataflow analysis weigh optimizable paths run time profile 
profile guiding practical thesis develops family estimator algorithms edge frequencies cheap inherently imprecise alternative path profiles measure frequencies individual paths 
weighing reuse estimators bound inherent error edge profile adding confidence imprecise profiles 
linear size edge profile exponential profiling cost avoided achieving esti mation precision close path profiles 
transformation intra procedural 
developed transformation nearly completely removes computations detected redundant 
transformation combines orthogonal methods 
resort expensive path duplication growth free code motion fails transform program profile driven control speculation profitably impair paths optimize 
spectrum algorithms single abstraction code motion preventing cmp region contains identifies adverse effects control flow desired optimization 
experiments show version transformation combines code motion speculation highly successful removes nearly redundancies perform restructuring achieves zero code growth 
exploiting code motion control speculation redundancies removed ing individual program paths reducing transformation cost 
transformation inter procedural 
developed transformation completely removes redundancies inter procedural value flows procedure boundaries 
resorting expensive inlining separate optimizable paths generating multiple procedure entry points multiple exit points may return different points caller 
entry exit splitting paths separated procedure boundaries call site invokes procedures virtual procedure calls 
splitting procedure entries exits fewer paths duplicated procedure inlining reduces transformation cost similarly intra procedural transformation 
compared power framework ideal value flow optimizer optimization redundant loads 
developed run time program monitoring algorithm exposed amount value reuse program 
ideal amount compared amount detected analysis 
observed captured reuse program 
removal redundant memory loads framework employed derive optimizations arithmetic expressions inter procedural version removal conditional branches promising results 
believe pathfinder framework successfully derive optimiza tions removal redundant array bounds checks constant propagation 
lessons observations section highlights observations development dissertation 
class value flow optimizations large 
seminal partial redundancy elimination pre morel considered optimization arithmetic expressions kinds computations targeted natural extensions analysis transformation algorithms 
computations belong value flow class include memory load operations condi tional branches communication statements memory pre fetch operations 
common kinds computations effects repeated load may read memory location content loaded instruction branch instruction may evaluate boolean expres sion evaluated branch instruction communication statement may receive data received program effects computations repeated redundant computations may exists computations repeat effects allows optimization 
definition value flow developed thesis definition unites computations reuse previously computed values single class 
definition allows phrasing previously unrelated optimizations general value flow framework 
example constant propagation viewed performed value flow optimization 
contrast traditional redundancy optimizations value reuse assumed constant propagation 
reusing value prior computation expression evaluates constant reuses value constant viewed computed compiler compile time 
despite difference constant propagation directly formulated pathfinder framework 
providing uniform optimization infrastructure definition unifying value flow class offers new views existing program analysis problems 
example detecting conditional branches redundant answers question branches correlated bgs turn answers question program paths infeasible guaranteed executed program bgs 
class value flow optimizations generalized scope assumed thesis 
consider elimination statements compute dead values values program program paths emanating partially dead statement bg 
elimination dead values analogous exploiting value reuse difference value reused optimization respect past dead value elimination optimization respect 
extension value flow class generalization reuse previous values 
directly reusing value computed previously optimizer previous value simplify computation 
consider computation 
value known previous iteration loop usually cheaper compute 
optimization called strength reduction developed operate path sensitive manner krs 
path sensitivity important 
perform effective value flow optimization important perform optimization path sensitive manner 
experiments show see section benchmarks half optimization opportunities measured dynamic terms require path sensitive optimizer 
furthermore standard approach path sensitive optimization may inadequate exploit half path specific opportunities 
contrast optimizer remove nearly opportunities 
exponential path explosion avoided 
large amount path specific optimization opportunities suggest optimizer may need pay cost considering program path separately 
observed cost managed 
dissertation divided path sensitive cost categories analysis cost 
cost analyzing program path separately analyzing way gives precision path analyzed separately 
solution dissertation value name graph analyzes paths separately value flowing behaves differently path 
worst case time space complexity value name graph exponential number program nodes graph size usually small practical compiler 
profiling cost 
cost obtaining execution frequency path program 
straightforward approach path sensitive profiling measure execution count acyclic path exponential worst case cost 
dissertation developed techniques linear size edge profile nearly precision path sensitive profile 
transformation cost 
cost corresponds code size growth caused separating pro gram paths 
path separation usually necessary isolate optimizable paths program path optimizable paths transformed affecting paths 
tation developed profile guided methods path sensitive program transformation cause code growth exploit nearly optimization opportunities 
section proposes directions value flow optimization 
ideas outlined emerge observation compiler optimization just technology program optimization 
related technologies processor architecture program specialization 
explained sec tion purpose value flow optimization particular redundancy removal technologies offer complementary solutions 
obtain significant advances power practicality program optimization needs explore relationships technologies develop new ones building contributions compiler optimizations microprocessor architecture 
outlined new technologies enabled demanded emerging computer technologies 
methods differ divide optimization compile time static run time dynamic 
division profound influence static methods exploit program input available run time complex slower dynamic ones 
compiler optimizations static program analyzed rebuilt 
architecture dynamic fly processor learns program predicts results instructions effectively removing predictable redundant ones svs ss 
dynamic versions program specialization hybrids static analysis finds values unchanging execution concrete values known run time hardcoded program specializing current input gmp 
method unique strengths subsume 
integration mutually beneficial 
observation widely recognized respective communities coop erate 
fueled technology changes integration eventually take place 
program optimization complement impact technology shaping integration careful consideration fundamental optimization principles 
specifically important understand static dynamic nature optimization exploit properly balanced techniques 
possible projects leading goals listed static dynamic approaches 

redundancy removal loops procedures 
dissertation focused redundancy individual statements 
redundant loops procedure calls recognized removed 
extend ing optimization larger program constructs benefit programs written object oriented technology large grain redundancy may occur frequently 

new paradigms dynamic optimizations 
advent mobile java code necessitates ing programs running 
fold speedup gained dynamic program spe gmp holds instruction level parallelism methods ilp static 
approaches orthogonal exploited 
unfortunately ilp methods costly run time 
careful combination compiler optimizations dynamic program specialization may help run time optimizations uniquely dynamic 

observational analysis 
static compiler analysis examines program abstractly exe 
current dynamic optimizers analyze way faster 
prove program properties examine code values computes 
waste run time possibilities ing abstracted execution observe concrete 
goal design dynamic analysis 
observation computed values may find opportunities invisible program code cheaper pure analysis 

hybrid hardware software optimizations 
hardware prediction values efficient simple redundancies 
find correlations instructions hardware needed 
hybrid com piler technology may help 
static analysis find correlated pairs hardware carry transformation remembering generated value sequence 
embedded computing hybrid optimizations brought life market 
emerging hardware software design technology chip non traditional features support optimization 
result low cost embedded processors enjoy server class power 

redundancy centric processors 
dependence successful modern processors hardware prediction indicates huge amounts redundancy programs predicted redundant 
processors redundancy centric 
learning predicting analyze program avoiding penalty paid mis prediction 
bibliography bibliography abd jennifer anderson lance jeffrey dean sanjay ghemawat monika henzinger shun tak leung richard sites mark vandevoorde carl waldspurger william weihl 
continuous profiling cycles gone 
acm transactions computer systems november 
abl glenn ammons thomas ball james larus 
exploiting hardware performance counters flow context sensitive profiling 
proceedings acm sigplan conf 
prog 
language design impl pages 
andrew ayers stuart de jong john peyton richard schooler 
scalable cross module optimization 
proceedings acm sigplan conference programming language design implementation pldi pages montreal canada june 
ags andrew ayers robert gottlieb richard schooler 
aggressive inlining 
sigplan notices 
proceedings acm sigplan conference programming language design implementation 
ah ole agesen urs lzle 
type feedback vs type inference comparison optimization techniques object oriented languages 
oopsla conference proceedings pages austin tx 
glenn ammons james larus 
improving data flow analysis path profiles 
proceedings acm sigplan conference programming language design implementation 
apc joel auslander philipose craig chambers susan eggers brian bershad 
fast effective dynamic compilation 
proceedings acm sigplan conference programming language design implementation pages may 
allen rosen zadeck 
optimization compilers chapter value numbering unpublished 
acm press addison wesley 
asg ayers schooler gottlieb 
aggressive inlining 
proceedings acm sig plan conf 
prog 
language design impl pages june 
asu alfred aho ravi sethi jeffrey ullman 
compilers principles techniques tools 
addison wesley 
bowen alpern mark wegman kenneth zadeck 
detecting equalities variables programs 
th annual acm symposium principles programming languages pages san diego california january 
ba bodik 
path sensitive value flow analysis 
conference record th acm sigplan sigact symposium principles programming languages january 
bc preston briggs keith cooper 
effective partial redundancy elimination 
proceedings conference programming language design implementation pages june 
bala evelyn duesterwald sanjeev banerjia 
transparent dynamic optimization design implementation dynamo 
technical report hpl hewlett packard laboratories 
bg bodik rajiv gupta 
array data flow analysis load store optimizations finegrain architectures 
international journal parallel programming december 
bg bodik rajiv gupta 
partial dead code elimination slicing transformations 
proceedings acm sigplan conf 
prog 
language design impl pages june 
bgs bodik rajiv gupta mary lou soffa 
interprocedural conditional branch elimination 
proceedings acm sigplan conf 
prog 
language design impl pages june 
bgs bodik rajiv gupta mary lou soffa 
refining data flow information infeasible paths 
esec pages 
lncs nr 
springer verlag september 
bgs bodik rajiv gupta mary lou soffa 
refining data flow information infeasible paths 
esec pages 
lncs nr 
springer verlag september 
bgs bodik rajiv gupta mary lou soffa 
complete removal redundant expressions 
proceedings acm sigplan conference programming language design implementation pages june 
bgs bodik rajiv gupta mary lou soffa 
load reuse analysis design evaluation 
proceedings acm sigplan conference programming language design implementation may 
bl thomas ball james larus 
optimally profiling tracing programs 
acm transactions programming languages systems july 
bl thomas ball james larus 
efficient path profiling 
th annual ieee acm international symposium microarchitecture pages 
bl thomas ball james larus 
efficient path profiling 
th annual ieee acm international symposium microarchitecture paris france 
bmo maccabe ottenstein 
program dependence web representation supporting control data demand driven interpretation imperative programs 
proceedings acm sigplan conference programming language design implementation volume pages june 
bms thomas ball peter mooly sagiv 
edge profiling versus path profiling showdown 
conference record th acm sigplan sigact symposium principles programming languages january 
car paul carini 
automatic inlining 
technical report ibm research report rc ibm watson research center november 
cc cousot cousot 
unified lattice model static analysis programs construction approximation fixpoints 
conference record th acm symposium principles programming languages pages january 
david callahan steve carr ken kennedy 
improving register allocation subscripted variables 
proceedings acm sigplan conference programming language design implementation pages june 
chow chan kennedy 
liu lo tu 
new algorithm partial redundancy elimination ssa form 
proceedings acm sigplan conf 
prog 
language design impl pages june 
david callahan keith cooper ken kennedy linda torczon 
interprocedural constant propagation 
proceedings sigplan symposium compiler construction pages july 
ce george joel emer 
memory dependence prediction store sets 
proceedings th annual international symposium computer architecture isca volume computer architecture news pages new york june 
acm press 
cfr ron cytron jeanne ferrante barry rosen mark wegman kenneth zadeck 
efficiently computing static single assignment form control dependence graph 
acm transactions programming languages systems october 
chk cooper hall kennedy 
procedure cloning 
intl 
conf 
computer languages oakland ca 
ck keith cooper ken kennedy 
interprocedural side effect analysis linear time 
sig plan notices july 
proceedings acm sigplan conference programming language design implementation 
ck steve carr ken kennedy 
scalar replacement presence conditional control flow 
software practice experience january 
ck steven carr ken kennedy 
improving ratio memory operations floating point operations loops 
acm transactions programming languages systems november 
ckl fred chow robert kennedy shin ming liu raymond lo peng tu 
register promotion partial redundancy elimination loads stores 
proceedings acm sigplan conference programming language design implementation pages montreal canada may 
cli cliff click 
global code motion global value numbering 
proceedings acm sigplan conference programming language design implementation pages la jolla california june 
cmc chang mahlke chen warter hwu 
impact architectural framework multiple instruction issue processors 
proceedings th international symposium computer architecture isca volume pages new york ny june 
acm press 
chang scott mahlke william chen wen mei hwu 
profile guided automatic inline expansion programs 
software practice experience may 
cmt carr mckinley 
tseng 
compiler optimizations improving data locality 
proceedings sixth international conference architectural support languages operating systems asplos san jose ca october 
cn charles consel fran ois general approach run time specialization application acm editor conference record popl rd acm sigplan sigact symposium principles programming languages papers symposium st petersburg beach florida january pages new york ny usa 
acm press 
coc john cocke 
global common subexpression elimination 
proceedings symposium compiler optimization volume pages july 
cs john cocke jacob schwartz 
programming languages compilers preliminary notes 
courant inst math 
sci nyu ny ny 
dgs evelyn duesterwald rajiv gupta mary lou soffa 
practical data flow framework array analysis optimizations 
proceedings acm sigplan conference programming language design implementation pages june 
dgs evelyn duesterwald rajiv gupta mary lou soffa 
demand driven computation interprocedural data flow 
conference record popl nd acm sigplan sigact symposium principles programming languages pages san francisco california january 
dgs evelyn duesterwald rajiv gupta mary lou soffa 
practical framework interprocedural data flow analysis 
acm transactions programming languages systems november 
dh jack 
davidson anne 
holler 
study function inliner 
software practice experience august 
dhamdhere 
practical adaptation global optimization algorithm morel renvoise 
acm transactions programming languages systems april 
di dhamdhere isaac 
composite algorithm strength reduction code movement optimization 
international journal computer information sciences june 
dmm amer diwan kathryn mckinley eliot moss 
type alias analysis 
proceedings acm sigplan conference programming language design implementation pldi pages montreal canada june 
sigplan notices may 
dhamdhere barry rosen kenneth zadeck 
analyze large programs efficiently 
proceedings acm sigplan conference programming language design implementation pages july 
ds drechsler 
solution problem morel renvoise global optimization suppression partial redundancies 
acm transactions programming languages systems october 
ds drechsler 
variation knoop thing steffen lazy code motion 
acm sigplan notices may 
carole 
ia architecture 
computer july 
ed alexandre edward davidson 
register allocation predicated code 
proceedings th annual international symposium microarchitecture pages ann arbor michigan november december 
ieee computer society tc micro acm 
hwu compiler technology microprocessors 
ieee 
ff joseph fisher stefan freudenberger 
predicting conditional branch directions previous runs program 
proceedings fifth international conference architectural support programming languages operating systems pages boston massachusetts october 
acm sigarch sigops sigplan ieee computer society 
fh christopher fraser david hanson 
retargetable compiler design implementation 
benjamin cummings 
isbn 
gbf gupta berson fang 
path profile guided partial dead code elimination predication 
international conference parallel architectures compilation techniques pages november 
gbf gupta berson fang 
resource sensitive profile directed data flow analysis code optimization 
th annual ieee acm international symposium microarchitecture pages december 
gbf gupta berson fang 
path profile guided partial redundancy elimination speculation 
ieee international conference computer languages may 
benjamin goldberg kim vinod john gyllenhaal 
compiler infrastructure instruction level parallelism research 
technical report www org hewlett packard laboratories university illinois nyu 
kennedy 
tseng 
practical dependency testing 
proceedings conference programming language design implementation pages ottawa cdn june 
acm sigplan 
sigplan notices 
gmp mock philipose chambers eggers 
annotation directed run time specialization proceedings acm sigplan symposium partial evaluation semantics program manipulation pepm volume acm sigplan notices pages new york june 
acm press 
gmp mock philipose chambers eggers 
uw dynamic compilation project 
technical report www cs washington edu research projects www university washington 
gt dan grove linda torczon 
interprocedural constant propagation study jump function implementations 
proceedings acm sigplan conference programming language design implementation pages june 
gup rajiv gupta 
fresh look optimizing array bound checking 
sigplan notices june 
proceedings acm sigplan conference programming language design implementation 
hh nigel horspool ho 
partial redundancy elimination cost benefit analysis 
proceedings th israeli conference computer systems software engineering pages israel june 
ieee computer society 
hhr richard hank wen mei hwu ramakrishna rau 
region compilation motivation 
th annual ieee acm international symposium microarchitecture ann arbor michigan 
hmc hwu mahlke chen chang warter hank holm 
superblock effective technique vliw superscalar compilation 
journal supercomputing volume issue 

hr howard barry rosen 
qualified data flow problems 
ieee transactions software engineering january 
jc johan janssen henk 
controlled node splitting 
compiler construction th international conference volume springer lecture notes computer science pages sweden april 
joh william johnson 
superscalar microprocessor design 
prentice hall 
isbn 
js richard johnson michael schlansker 
analysis techniques predicated code 
proceedings th annual international symposium microprogramming pages december 
david keppel susan eggers robert henry 
case runtime code generation 
technical report department computer science university washington november 
kno jens knoop 
optimal interprocedural program optimization new framework application volume lecture notes computer science tutorial 
springer verlag heidelberg germany 
phd dissertation department computer science university kiel 
kra andreas krall 
improving semi static branch prediction code replication 
sigplan notices june 
proceedings acm sigplan conference programming language design implementation 
krs jens knoop oliver thing bernhard steffen 
lazy code motion 
sigplan notices july 
proceedings acm sigplan conference programming language design implementation 
krs jens knoop thing bernhard steffen 
lazy strength reduction 
international journal programming languages 
krs jens knoop oliver thing bernhard steffen 
optimal code motion theory practice 
acm transactions programming languages systems july 
krs jens knoop oliver thing bernhard steffen 
partial dead code elimination 
proceedings conference programming language design implementation pages new york ny usa june 
acm press 
ksr vinod michael schlansker ramakrishna rau 
hpl architecture specification version 
technical report hpl hewlett packard laboratories 
ku kam ullman 
monotone data flow analysis frameworks 
acta informatica 
kw michael wolfe 
elimination redundant array subscript range checks 
sigplan notices june 
proceedings acm sigplan conference programming language design implementation 
lar james larus 
program paths 
proceedings acm sigplan conference programming language design implementation pages 
lc john lu keith cooper 
register promotion programs 
proceedings acm sig plan conference programming language design implementation pldi volume acm sigplan notices pages new york june 
acm press 
lck raymond lo fred chow robert kennedy shin ming liu peng tu 
register promotion sparse partial redundancy elimination loads stores 
proceedings acm sig plan conference programming language design implementation pldi pages montreal canada june 
geoffrey lowney stefan freudenberger thomas lichtenstein robert nix john donnell john 
multiflow trace scheduling compiler 
journal supercomputing may 
lh daniel wen mei hwu 
modulo scheduling loops control intensive programs 
proceedings th annual international symposium microarchitecture pages paris france december 
ls lipasti shen 
performance potential value dependence prediction 
lecture notes computer science 
mcb mahlke chen hank hwu rau schlansker 
sentinel scheduling vliw superscalar processors 
acm transactions computer systems 
mcb renaud marlet charles consel philippe 
efficient incremental run time specialization free 
acm sigplan notices may 
mh scott mcfarling john hennessy 
reducing cost branches 
proceedings th annual international symposium computer architecture pages tokyo japan june 
ieee computer society acm sigarch information processing society japan 
mlc mahlke lin chen hank 
effective compiler support predicated execution hyperblock 
wen mei hwu editor proceedings th annual international symposium microarchitecture pages portland december 
ieee computer society press 
morel 
global optimization partial redundancies 
cacm 
muc steven muchnik 
advanced compiler design implementation 
addison wesley 
mw frank mueller david whalley 
avoiding unconditional jumps code replication 
programming language design conference pages 
acm sigplan acm press june 
mw frank mueller david whalley 
avoiding unconditional jumps code replication 
sig plan notices july 
proceedings acm sigplan conference programming language design implementation 
mw frank mueller david whalley 
avoiding conditional branches code replication 
acm sigplan conference programming language design implementation volume acm sigplan notices pages 
acm sigplan acm press june 
mw frank mueller david whalley 
avoiding conditional branches code replication 
sig plan notices june 
proceedings acm sigplan conference programming language design implementation 
pc plevyak chien 
precise concrete type inference object oriented languages 
sigplan 
pc john plevyak andrew chien 
type directed cloning object oriented programs 
eighth annual workshop languages compilers parallel computing lecture notes computer science volume pages columbus ohio august 
ram ramalingam 
undecidability aliasing 
acm transactions programming languages systems september 
ram ramalingam 
data flow frequency analysis 
proceedings acm sigplan conf 
progr 
language design implementation pages june 
rau rau 
data flow dependence analysis instruction level parallelism 
proceedings fourth international workshop languages compilers parallel computing lncs pages 
springer verlag 
glenn brad calder dean tullsen gary tyson todd austin 
profile guided load marking memory renaming 
technical report ucsd cs university california san diego 
rg ramakrishna rau 
scheduling techniques easily schedulable horizontal architecture high performance scientific computing 
proc 
th annual workshop microprogramming pages 
rg stephen richardson mahadevan ganapathi 
interprocedural analysis versus procedure integration 
information processing letters 
rl reif lewis 
symbolic evaluation global value graph 
conference record fourth annual acm symposium principles programming languages pages 
acm acm january 
barry rosen mark wegman kenneth zadeck 
global value numbers redundant computations 
th annual acm symposium principles programming languages pages san diego california january 
sg sreedhar guang gao 
linear time algorithm placing nodes 
conference record nd acm sigplan sigact symposium principles programming languages popl pages january 
sit richard sites 
alpha axp architecture 
communications acm february 
sj sastry roy ju 
new algorithm scalar register promotion ssa form 
acm sigplan notices may 
skr bernhard steffen jens knoop thing 
value flow graph program representation optimal program transformations 
proceedings rd european symposium programming esop volume pages denmark may 
slm stuart chih lee trevor mudge 
correlation aliasing dynamic branch predictors 
proceedings rd annual international symposium computer architecture pages philadelphia pennsylvania may 
mooly sagiv thomas reps susan horwitz 
precise interprocedural dataflow analysis applications constant propagation 
theoretical computer science 
ss sohi 
dynamic instruction reuse 
proceedings th annual international symposium computer architecture isca volume computer architecture news pages new york june 
acm press 
ss sohi 
understanding differences value prediction instruction reuse 
proceedings th annual international symposium microarchitecture dallas tx december 
ste bernhard steffen 
property oriented expansion 
proc 
int 
static analysis symposium sas volume lncs pages germany september 
springer 
svs vassiliadis james smith 
performance potential data dependence speculation collapsing 
proceedings th annual international symposium microarchitecture pages paris france december 
ieee computer society tc micro acm 
tp tu padua 
gated ssa demand driven symbolic analysis parallelizing compilers 
conference proceedings international conference supercomputing barcelona spain july pages 
ts traub michael smith 
ephemeral instrumentation lightweight program profiling 
submitted nd annual international symposium microprogramming december 
tu peng tu 
personal communication 

weg wegbreit 
property extraction founded property sets 
ieee transactions software engineering september 
weg mark wegman 
thesis 
phd thesis university california berkeley 
wu wu 
conflict ratio profiling memory 
technical report mrl compiler technical report intel 
cliff young nicolas michael smith 
comparative analysis schemes correlated branch prediction 
intl 
symposium computer architecture italy 
yp tse yu yeh yale patt 
level adaptive training branch prediction 
proceedings th annual international symposium microarchitecture pages albuquerque new mexico november 
acm ieee computer society tc micro 
ys cliff young michael smith 
improving accuracy static branch prediction branch correlation 
proceedings sixth international conference architectural support programming languages operating systems pages san jose california october 
acm sigarch sigops sigplan ieee computer society 

