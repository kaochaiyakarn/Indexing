architectural level design methodology embedded face detection saha aggarwal bhattacharyya wolf chellappa ece dept institute advanced computer studies univ maryland college park md dept electrical engineering princeton univ princeton nj gaurav ssb umd edu wolf princeton edu face detection recognition research attracted great attention years 
automatic face detection great potential large array application areas including banking security system access control video surveillance multimedia information retrieval 
discuss architectural level design methodology implementation embedded face detection system reconfigurable system chip 
models performance estimation validate models experimental values obtained implementing system fpga platform 
modeling approach shown efficient accurate intuitive designers 
approach design options trade various architectural features 
categories subject descriptors real time embedded systems general terms design keywords design space exploration face detection reconfigurable platforms system level models 

study design modeling architecture exploration synthesis face detection system 
face detection pertains discernment existence human faces image video sequence 
operation holds interest fields authors equal contribution 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
codes isss sept jersey city new jersey usa copyright acm 
surveillance video archiving tracking 
furthermore aforementioned fields shown increased focus mobile outdoor applications 
mandates consideration power consumption memory size area 
face detection simple problem 
significant body exists elegant solutions problem approaches require computational power deemed acceptable mobile systems 
important note hardware solutions pursued tend consume significant system resources cases subsystem larger complex system 
history shown area minimization technology scaling 
unfortunately international technology roadmap semiconductors predicts change trend 
prediction coupled expected increase leakage power simply powering devices 
intuitively application areas face detection require fairly constant operation making reliance device scaling questionable 
addition applications implicit cases critical need real time performance 
real time realization applications achieved aggressive application parallel processing pipelining provided multiprocessor systems 
implementation involves interaction complex factors including scheduling interprocessor communication synchronization iterative execution memory buffer management 
addressing factors isolation typically intractable optimal sense 
issues mind study design synthesis embedded face detection system class reconfigurable system chips 
addition providing design details experimental results useful family face detection architectures contributions design methodology emerge study 
develop number useful generalizations synchronization graph performance analysis model 
demonstrate formulation multirate synchronization graphs show useful compactly representing repetitive patterns execution multiprocessor system 
second integrate aspects ordered transaction execution conventional self timed execution flexible seamless way 
demonstrates new class hybrid self timed ordered transaction designs 
furthermore demonstrates syn image find correlation sampled image create masks graph modeling methodology unify analysis entire spectrum systems encompassing pure self timed execution pure ordered transaction execution set hybrid ordered transaction possibilities exist extremes 
third show multirate synchronization graph approach hybrid self timed ordered transaction scheduling effectively design systems involving extensive multi dimensional processing case processing video frames 
previous development synchronization graph modeling focused primarily single dimensional signal processing systems 
apply generalized synchronous graph modeling approach designer aid architecture analysis exploration 
contrast previous development synchronous graphs focused intermediate representation automated tools 
image mask find max 
correlation value flow face detection algorithm 
show application domain specific design system designer effectively new modeling approach way understand explore performance issues regardless model supported synthesis tools employed 
parameterized construction multirate synchronization graph targeted class application architecture mappings analysis cycles parameterized synchronization graph concretely demonstrates steps needed type design methodology 

related vast related face detection significant focus accuracy expense computational complexity 
mentioned lends software implementations general purpose processors embedded mobile implementations feasible 
years focus placed hardware implementations face detection 
addition starting point reconfigurable platforms system implementation similar face detection system implemented reconfigurable platform area results requiring multiple fpga boards 
asic implementation fairly complex face detection algorithm real time frame rates possible 
mention architectural exploration 
framework generalized object detection general purpose embedded processor 
body suffers distinct lack focus design methodology architectural exploration little treats problem face detection stringent attention synchronization data accesses transfers resource assignment task scheduling 
bridging gap facilitating systematic cou mark outline detected face image results applying face detection algorithm images 
pling face detection algorithms embedded implementations major objectives 

face detection algorithm face detection research active area research past decades 
approaches shape intensity distribution face 
shape approach proposed 
face assumed ellipse 
method models cross section shape ellipse boundary step function 
moon proves derivative double exponential function optimal onedimensional step edge operator minimizes noise power mean squared error input filter output 
operator detecting faces derived extending filter boundary ellipse 
probability presence face position estimated accumulating filter responses centroid ellipse 
quite clearly approach face detection natural extension problem edge detection pixel level shape detection contour level 
moon provides formulations propagation error shape geometry 
way predict localization detection performance algorithms adjust parameters imaging conditions performance specifications 
shows complete flow employed face detection algorithm 
examples detection outputs described approach 
modeling approach build synchronization graph model analyze optimize multiprocessor implementation issues system 
representation iterative synchronous dataflow sdf graphs 
brief concepts section 
sdf application represented directed graph vertices actors represent computational tasks edges specify data dependencies numbers data values tokens produced consumed actor fixed 
delays sdf edges represent initial tokens specify dependencies iterations actors iterative execution 
mapping sdf application pe pe application graph self timed schedule synchronization graph example application graph associated self timed schedule synchronization graph resulting schedule 
multiprocessor architecture includes assignment actors processors ii ordering actors assigned processor iii determining precisely actor commence execution 
focus self timed scheduling strategy closely related ordered transaction strategy 
self timed scheduling processor executes tasks assigned fixed order specified compile time 
executing actor processor waits data needed actor available 
processors required perform run time synchronization communicate data 
provides robustness execution times tasks known precisely may exhibit occasional deviations compile time estimates 
eliminates need global clocks coordinates processors lockstep 
ordered transaction method similar method adds constraint global linear ordering interprocessor communication operations communication actors determined compile time enforced run time 
linear ordering imposed called transaction order associated multiprocessor implementation 
enforcing transaction order eliminates need run time synchronization bus arbitration enhances predictability 
synchronization graph gs model self timed execution parallel schedule iterative dataflow graph 
self timed multiprocessor schedule graph derive gs instantiating vertex task connecting edge task task succeeds processor adding edge unit delay task processor task processor 
edge vj vi gs called synchronization edge representing synchronization constraint start vi vj delay vj vi start respectively represent time invocation actor begins execution completes execution delay represents delay associated edge construct gs system maximum cycle mean mcm graph performance analysis 
mcm defined mcm gs max delay delay denotes sum edge delays edges cycle mcm wide variety analysis problems variety techniques developed efficient computation see 
examples application graph corresponding self timed schedule synchronization graph illustrated 
configurable logic processor core cache cache target architecture 

architectural exploration target architecture architecture targeting reconfigurable system chip 
system hardware software resources potential multiple processor development 
includes chip chip memory resources 
access chip memory assumed shared bus 
chip memory access performed shared bus dma 
example system xilinx virtex ii pro 
version system 
profiling software profiling usually step performance optimization approach 
profiling gives information run time different program modules time spent 
targeting embedded systems concerned optimization metrics time energy consumption important identify critical sections code benefit hardware implementation 
flat profiler provides loop function level information 
flat profiler identifies correlation module computes correlation mask image see candidate core core defined set loops execution higher threshold value optimization mapping hardware 
output flat table 
base model results profiling derived system model multiple processing elements pe concurrently execute multiple instances correlation function process masks simultaneously 
model requires multiple masks copies frame concurrent access available chip pes require frame copies chip 
increases rate memory accesses power consumption minimize process image stripe time define stripe minimum size image processed pass run masks set stripe image find maximum correlation value repeat process stripe continue exhausted stripes image 
set masks processing elements pes masks processed simultaneously take processing passes cover masks single stripe 
shows implementation transaction execution order synchronization model system 
fig mask transfer controller mtc 
pe row transfer controller rtc table flat output face detection algorithm 
loop name frequency loop size total ins 
exec program mask correlation pe 
pe mask synch dis ir ir 
pe synch repeat sdf representation mapping algorithm targeted architecture associated synchronization structure 
ure mri actors represent reading mask mask set processing element varies varies process takes time units 
masks stored external memory mask transfer controller mtc controls reading dedicated block rams pe 
mtc conducts mask transfers time repeating pre determined sequence fashion analogous ordered transaction strategy 
conventional ordered transaction implementation transaction ordering approach dataflow communications enclosing system 
ei actor represents processing ith mask ej takes time units 
dis actor downsampled image source represents downsampling image stripe execution time dis 
ir actor represents reading downsampled stripe row time execution time ir 
re peat actor conceptual vertex ensures exactly mask sets processed new row image data 
data needs replicated repeat actor required functionality achieved simple low overhead synchronization buffer management methods 
represents synchronization unit synchronizes start ith iteration pes reading mask set 
unit receives data pes repeat actor 
messages pes confirm completed processing mask 
messages sent iteration 
production rate consumption rate shown rep eat edge indicates unit execute times repeat actor invoked 
mask synch actor conceptual actor needed functional purpose 
represents synchronization executions pe synch actor corresponding ir pe pe pe pe pe pe repeat ir ir dis mask synch example unfolded representation algorithm factor 
execution dis actor 
execution dis actor pe synch executes times 
self timed model coordinate interaction mtc pe cluster 
start reading new set masks controller synchronize pes sure done processing current masks 
synchronization process represented edge directed pe synch actor starting actor mtc block 
edge delay connecting mri mri represents initially available mask data pre loading set masks new image associated 
multirate sdf graph unfolds unambiguously homogeneous sdf graph general leads expansion dataflow representation 
example sdf transformation 
performance analysis necessary reason terms directed cycles representation 
performance analysis modeling approach understand explore performance issues 
model may observed cycles decomposed limited set classes class exhibits similar patterns cyclic paths 
cycles graph isomorphic isomorphic cycles mean vertices edges placed correspondence corresponding vertices execution times corresponding edges delays 
understanding isomorphic relationships allows greatly reduce number mcm computations need considered 
similarly understanding patterns variation certain sets similarly structured cycles easy extract critical cycles cycles maximum mcm sets 
table different classes cycles description mcm class mcm obtained extracting critical cycle class 

experimental results evaluated proposed designs xilinx ml development board 
design space exploration seen table system performance function dis 
assume number masks mask sizes fixed mentioned shape face detection algorithm face modeled ellipse 
operational value implementation able handle variability size faces information usually available priori 
handle creating elliptical masks varying sizes 
masks detection performed position face determined quality filter response 
number masks required bounded possible ellipticity faces size image 
target application smart camera vision system 
particular smart camera size images shot camera assumed fixed 
assumptions masks parameters algorithm able perform robustly faces different sizes 
justification assume variable mask size considered size mask set 
function parameters consider degree finegrain parallelism simultaneous operations performed pe image size resolution number rows columns considered image compared mask 
dis function frame sizes 
keep design space manageable fix frame size vary number pes steps fine grain parallelism hw limits 
stripe size implementation 
execution times obtained multiplying number execution cycles node inverse clock frequency mhz board 
delays number cycles required initial values load source node destination node synchronization graph 
obtain cycle means stated classes cycles give throughput inverse cycle mean possible cycles 
observe cycles class yield largest cycle mean 
expected critical path involves execution pes reading mask 
obtain satisfactory throughput keeping camera frame rate need vary parameters affecting accuracy 
observe throughput improved merely increasing number pes 
increase number columns skipped bounded accuracy face detection 
actual throughput function number image stripes affected resolution camera 
number pes may implemented limited area constraints 
board allocated modules sampling unit powerpc 
required pe sets upper bound number pes 
parallelization possible pe multiplications required calculation correlation value independent instant multiplication may performed 
number multipliers available board limits parallelization 
multipliers board limits number pes 
buffers board impose serious restrictions number pes pe communicates sampling unit external ddr sdram memory controller output interface significant number ports 
limits maximum number pes may practically implemented 
obtain execution times parameters bounded analysis 
results table number pes degree parallelism number additional multiplications done simultaneously pe steps granularity image correlated mask 
maximum frame rate applications security video surveillance targeted fps 
current board available hardware resources implementation achieves maximum frame rate fps 
entails discarding frames tolerated applications 
fidelity analysis section calculate fidelity performance estimations design parameters varied si sj sign mi mj fij sis denote simulated execution times mis corresponding estimates mcm expression 
case fixed frame size design points table get fidelity 
model simplicity assumed small constant value synchronization actors pe synch causes difference estimated experimental results 
high value fidelity demonstrates accuracy robustness modeling technique 
alternatively models design space exploration techniques employed applied powerful boards explore implementations approach achieve fps target 

targeted architectural design modeling exploration embedded system face detection reconfigurable system chip 
provides design details experimental results useful family face detection architectures 
additionally developed contributions design methodology embedded multiprocessor design useful generalizations fij table maximum cycle mean expressions description cycle mcm classes reading masks reading image rows dis iri dis reading image rows dis iri rep eat synchronizations dis pes synchronization em synchronization pes reading masks em dis ir dis ir synchronization pes reading masks ii ii ii table execution time frame various design parameters estimation ms experimental ms degree steps steps parallelism synchronization graph modeling approach application processing multidimensional signals 
approaches multiple designs expose important trade offs different architectural features 
plan extend model explore hardware software design 
additionally current method frames video approach perform face detection independently frame discards inherent temporal continuity frames 
plan address issues employing sophisticated techniques kalman filters particle filters 
acknowledgments research supported number national science foundation 

gupta faster maximum minimum mean cycle algorithms system performance analysis ieee trans 
computer aided design integrated circuits systems vol 
pages 

lee messerschmitt 
static scheduling synchronous dataflow programs digital signal processing 
ieee transactions computers february 
real time face detection configurable hardware system proceedings roadmap reconfigurable computing th international workshop field programmable logic applications 
moon chellappa rosenfeld optimal edge shape detection ieee transaction image processing vol 
pp 

sriram lee 
determining order processor transactions statically scheduled multiprocessors 
journal vlsi signal processing march 
sriram bhattacharyya embedded multiprocessors scheduling synchronization 
marcel dekker 
suresh profiling tools hardware software partitioning embedded applications proc 
acm symp 
languages compilers tools embedded systems june 
link vijaykrishnan irwin wolf embedded hardware face detection 
proceedings th international conference vlsi design 
viola jones robust real time object detection 
proceedings ieee workshop statistical computational theories vision 

yang kriegman ahuja detecting faces images survey 
ieee trans 
pattern analysis machine intelligence vol 
pp 
jan 
