pict programming language pi calculus benjamin pierce david turner indiana university technical report march calculus ers attractive basis concurrent programming 
small elegant studied supports simple encodings wide range high level constructs including data structures higher order functional programming concurrent control structures objects 
familiar type systems calculus direct counterparts calculus yielding strong static typing high level language calculus core 
describes pict strongly typed concurrent programming language constructed terms explicitly typed calculus core language 
dedicated milner occasion th birthday 
milner parrow walker calculus mpw mil generalizes channel communication ccs relatives allowing channels passed data channels 
extension introduces element mobility enabling speci cation veri cation concurrent systems dynamically evolving communication topologies 
channel mobility leads surprising increase expressive power yielding calculus capable describing wide variety high level concurrent features retaining simple semantics tractable algebraic theory 
similar combination simplicity expressiveness calculus popular object theoretical investigation attractive basis sequential programming language design 
analogy may wonder kind high level programming language constructed calculus 
ml haskell 
calculus calculus anumber programming language designs combined calculus communication functional core language gone far take communication sole mechanism computation 
primary motivation pict project begun university design implement high level concurrent language purely terms calculus primitives pt pie 
compiling language solely communicating processes raises challenging code generation problems 
achieve acceptable performance realistic applications calculus compiler implement process creation context switching communication channels extremely ciently operations fundamental computational mechanism calculus example pervasive function calls functional language 
goal pict project explore practical applicability earlier theoretical type systems calculus ps tur calculus type systems subtyping pt hp ps 
particular pt proposed powerful combination subtyping polymorphism basis statically typed object oriented programming functional languages equipping pict similar type system provides testbed experiments statically typed concurrent objects :10.1.1.17.9345
powerful type system raises important issues typechecking algorithms ciency typechecking type inference 
questions motivating pict project summarized follows program calculus 
kind high level language built 
kinds concurrent objects arise setting 
calculus implemented ciently 
design practical type system calculus combining subtyping higher order polymorphism 
er responses questions concentrating addressed detail pt tur survey current state pict language 
section de nes syntax operational semantics core language discusses points di ers theoretical calculus milner parrow walker 
section presents type system core language incorporating channel types subtyping record types higher order polymorphism simple recursive types 
section constructs full pict language means translations core 
section ers concluding remarks directions research 
please note attempt give de nitive description pict pict experimental language subject relatively frequent changes design 
overview main decisions design pict 
complete description current version pict please consult formal de nition pt date current version compiler 
core language proceed rigorous de nition syntax semantics core language asynchronous choice free fragment ofthe calculus enriched records pattern matching 
pi calculus aid comparison brief review pure calculus milner parrow walker 
details original calculus papers mpw milner tutorial mil 
computational world modeled calculus contains just kinds entities processes channels 
processes called agents active components system interact synchronous rendezvous channels called names ports 
processes synchronize exchange single data value channel 
output process xy sends output completed continues 
conversely input process waits value received substitutes bound variable continues 
parallel composition processes written xy synchronize yielding derivative 

fresh channels introduced restriction operator expression creates fresh channel lexical scope example writing xy localizes channel ensuring process interfere communication expression denotes external choice allowed proceed discarded vice versa 
example process xy reduce 


nullary choice written inert 
nite behavior calculus introduced replication operator informally denotes arbitrary number copies running parallel 
operator replaces equivalent complex mechanism mutually recursive process de nitions 
variants calculus include matching operator proceed channel 
core language design issues core language pict di ers calculus trivial extensions important restrictions 
primitive values high level programming languages pict provides special syntax built types booleans characters strings integers 
adding syntax change fundamental character language types data easily encoded processes mil 
give compiler maximum freedom implement primitive values ciently types bool char string int reveal values types represented 
built channels provided performing common operations 
example built value type int addition operation represented built channel 
add numbers send channel result channel listen result calculation 
built channels provided interacting environment example channel print send strings standard output stream 
records pattern matching akey choice design pict de ne language possible terms encodings 
section describes forms including example function abstraction application 
style de nition means need give operational semantics typing rules core language rules functions arise translation 
pure calculus easily encode polyadic communication channels exchanged single communication mil 
similar encodings data structures records 
encodings give rise useful derived typing rules 
particular started pict design type systems pure monadic calculus linear types kpt may lead type systems 
slightly structured core language admits simple structural type system just typed functional languages ml haskell typically calculus extended basic data constructors 
asynchrony fundamental communication primitive calculus relatives synchronous rendezvous sender receiver blocked communication occurs 
example calculus expression xy expression proceed output completed similarly expression proceed value received fact output synchronous enables sending process tell message received process 
unfortunately depending information precludes number useful programming idioms involving bu ering delegation reordering requests 
example client server run separate machines may need add surrogate server process client machine forwards requests server machine 
synchronization client request channel indicates surrogate server received request 
allow asynchronous output pict amounts restricting continuation output expression null process 
programmer send explicit result inform client request processed eliminating possible sensitivity bu ering reordering requests 
investigation asynchronous process calculi initiated honda tokoro yoshida ht hy boudol bou 
amadio castellani sangiorgi acs shown technical aspects observational equivalence simpli ed asynchronous case 
choice early versions calculus completely unrestricted choice operator expression branches arbitrary processes 
presentations example mil constrained operator called guarded choice input expressions output expressions choice expressions 
guarded choice easier formalize especially context reduction semantics sections appears capture cases practical interest 
asynchronous language guarded choice restricted asynchronous output choice sensitive bu ering wy discard process reads xy wz reduce spontaneously wy pict go step dropping choice operator altogether 
simpli es formal semantics implementation little ect expressiveness language input choice easy implement library module pt np 
cost syntactic convenience bene exibility 
library implements subset reppy events rep allowing branches choice manipulated data 
fact pict programs simpler mechanisms semaphores cf 
section basic synchronisation tasks 
controlling concurrent execution methods objects di erent library implementing specialized operator called replicated choice pt 
replicated input matching pict core language simpli cations pure calculus 
restrict replication replicated input expressions 
variant formal power full replication simpler semantics closer realistic implementation 
second omit matching operator main functions encoding conditional expressions tracking side conditions axiomatizations behavioral equivalences subsumed features pict irrelevant context programming 
ascii notation discussed pict substitutes slightly heavier ascii concrete syntax mathematical calculus notation core language syntax calculus pict xy asynchronous output input pre parallel composition new channel creation replicated input de ne pict core language syntax 
details lexical analysis rules pict language de nition pt 
possible forms production listed successive lines 
keywords set typewriter font 
expression form denotes list zero occurrences expression denotes empty production 
entities communicated channels called values 
include variables records values package values rectype values constants 
val id variable label val 
label val record type val polymorphic package rec rectype value string string constant char character constant int integer constant bool boolean constant label anonymous label id explicit label channel constants variables ranging channels note variables range just channels 
record values generalise tuple values labels record optional 
rectype values help typechecker determine types recursive data structures package values part mechanism implement polymorphism pict 
defer description sections 
values decomposed means patterns 
avariable pattern binds variable pattern binds type variable plus variables bound pattern binds variable plus variables bound variables bound pattern pairwise distinct 
pat id type variable pattern type wildcard pattern id type pat layered pattern label pat 
label pat record pattern id type pat package pattern rec rectype pattern note bound variables wildcards explicitly typed 
practice annotations inferred automatically pict compiler 
pattern bind variable value time decomposing value 
example matching pattern value true binds true andz true 
defer description rectype package patterns sections 
process pre xed pattern called abstraction 
introducing separate syntactic class abstractions leaves room expansion 
full language allow higher order functions appear process abstractions allowed cf 
section 
abs pat proc process abstraction abstraction variable occurrences binders scope basic forms processes output atoms input pre xes parallel compositions processes pre xed declarations conditional processes 
proc val val output atom val abs input pre val abs replicated input pre proc proc parallel composition dec proc local declaration val proc proc conditional arbitrary values allowed left substitution total operation cf 
section 
type system guarantees values evaluate channel names 
anew declaration introduces new channel 
declarations separate syntactic category leave room growth 
dec new id type channel creation expression new binds scope note new channels annotated explicit types 
example simple examples pict core language programs 
section show annotate examples appropriate explicit type information 
section uses additional features full language express examples concisely 
process implements cons cell server sent triple hd tl constructs process encoding cons cell head hd tail tl returns address cons cell result channel cons hd tl new hd tl receiving triple hd tl rst create new channel thought location cons cell 
parallel return result channel run process hd tl 
process responds messages sent sending hd tl process behaves similarly constructs nil empty list 
receiving tuple containing just result channel create new channel parallel return result channel run process 
process responds messages sent sending trivial value back nil new program fragment illustrates nil cons build list containing number 
rst create fresh result channel send nil channel 
parallel wait nil reply sent binding resulting value create second result channel send tuple cons 
ect building cons cell head tail location new cell returned 
new nil new cons interrogate list channel convention empty list reply sending trivial value cons cell reply sending pair head tail list 
process executes expression empty list cons cell tl bound head tail new new hd tl structural congruence discussing examples informal understanding pict expressions behave 
time understanding precise 
mil operational semantics pict programs steps 
de ne structural congruence relation relation captures fact example order branches parallel composition ect behavior 
de ne reduction relation specifying processes evolve 
structural congruence plays important technical role device simplifying statement reduction relation 
example intend processes reduce fy 

structurally congruent su ces write reduction rule rst case stipulate general contains possibility expression structurally congruent toe possible behavior 
rst structural congruence rules state parallel composition commutative associative 
str comm str assoc third rule called scope extrusion calculus literature plays crucial role communication 
fv new new str informally scope channel starts private process extended include 
side condition fv ensures free channel named 
condition converting bound name expression new applying scope extrusion rule 
example process expression new may transformed new ife 
rule allows new channel communicated outside original scope process substitution matching de ne reduction need notation matching values patterns 
substitution nite map associating variables values type variables types 
substitutions disjoint domains substitution combines ects 
substitution extended function values values applying variables fall domain leaving rest unchanged 
example applying substitution fx 
ag fy 
value written yields 
substitution extended usual way operation processes renaming bound variables necessary avoid capture 
value successfully matched pattern result substitution fp 
vg de ned 
structure fp 
vg unde ned 
typing rules ensure happen typed programs 
fx 
vg fx 
vg 
vg fg 
vg fx 
vg fp 
vg rec 
rec fp 
vg 
vg fx 
tg fp 
vg 
fp 

vng match function traverses structure pattern value parallel yielding bindings variables encountered pattern 
note variables bound pattern distinct operations de nition match de ned 
match rule records allows record pattern matched record value extra elds record 
example record pattern matches record value true 
gives rise simple form record subtyping particularly easy implement common allow extra elds added record signi cantly complicates implementation records especially presence separate compilation 
reduction reduction relation may read process evolve process 
semantics nondeterministic specifying happen evaluation program proceeds happen 
particular execution pict program follow just possible paths 
basic rule reduction specifying happens input pre meets output atom fp 
vg de ned red comm fp 
vg case input expression replicated communication rule similar input expression consumed act communication 
fp 
vg de ned red 
fp 
vg rules allow reduction proceed declarations parallel composition 
red dec red prl 
body input expression hand participate reductions input discharged 
reduction conditional processes straightforward 
typing rules ensure guard closed typed conditional true false 
true false red red structural congruence relation captures distributed nature reduction 
subprocesses top level process expression guarded pre xes may brought proximity structural manipulations allowed interact 
red str note reduction rules maintain particular ordering messages sent channel 
example process value value may communicated process strictly speaking semantics de ned closed programs intentionally informal built channels print connect pict program environment 
underway re ned semantic framework explicitly incorporating interactions environment sew 
fairness closed programs reduction semantics previous section leaves important issue unaddressed characterizes set possible behaviors process expression commitment behaviors observed expression compiled executed 
example valid execution process new output executed 
compiler produced behavior unsatisfactory fail capture programmer intuitive expectation actions subprocesses running parallel interleaved fairly second input eventually succeed 
unaware formalising fairness calculus costa stirling fairness ccs cs generalisable case calculus 
costa stirling consider kinds fairness weak fairness stipulates process continuously able communicate channel eventually allowed proceed strong fairness insists process able communicate channel nitely continuously eventually proceed 
weak fairness guarantee su cient ensure output example eventually executed input continuously enabled 
process replaced process communication sending strong fairness guarantee required ensure output eventually executed input continuously able communicate 
practice relatively easy achieve fair execution strategy fifo channel queues round robin policy process scheduling 
guarantees process waiting communicate channel eventually succeed assuming partners available 
experience writing applications pict execution strategy works 
example fifo queueing lock channel cell section ensures competing set get requests handled fairly replicated choice construct pt exhibits similar behavior 
type system system roots theoretical literature type systems calculus mil gay vh ps tur functional languages immediate predecessors quest car amber car :10.1.1.117.1304
treatment subtyping higher order polymorphism static type systems object oriented languages car bru chc pt hp fm ac calculus car mit ps 
rules channel types taken pierce sangiorgi type system pure calculus ps 
early version pict type system prt :10.1.1.38.4600:10.1.1.38.4600
typed process calculi related goals proposed nierstrasz nie vasconcelos vas 
re nements channel typing discipline incorporating notions linear channel usage studied honda hon hy hon kobayashi yonezawa ky authors collaboration kobayashi kpt 
channel types type systems process calculi concurrent languages impose constraint channel lifetime carry values single type 
restriction greatly simpli es task type analysis typedness parallel composition independent ordering interactions 
computation pict purely communication channels basic elements type system types channels values carry 
example process outputs value channel typed type read channel carrying type recursive types programming languages pict ers capability build manipulate recursive data structures lists trees 
recursive types received considerable attention literature mps cc ac di erent technical treatments proposed 
rest pict type system somewhat complex recursive types tend small sections code chosen simplest alternatives folding unfolding recursion managed explicitly programmer 
example suppose recursive type rec 
avalue type coerced means rec pattern value type recursion type unfolded 
dually rec value construct coerce value type recursive type rec int represent type integer lists cons cell server section type intlist rec int cons hd int tl intlist intlist new int intlist rec intlist int intlist hd tl type annotations hd tl indicate cons takes arguments integer integer list returns integer list channel type new channel unfolding type intlist 
unfolded intlist type exposes fact list represented channel enables replicated input operation 
return result channel type intlist rec value construct 
values recursive type unfolded communication patterns form rec 
example channel type intlist bound variable body process rec intlist type int intlist unfolding intlist 
subtyping channel types serve useful role ensuring parts program channel consistent way eliminating possibility pattern matching failure cf 
section run time 
course pattern matching failure just kind bad behavior programs may exhibit especially concurrent programs range possible programming mistakes vast may deadlocks race conditions protocol violations kinds 
ultimately hope see static analysis tools capable detecting errors technology required far fortunately simple ways channel types enriched capture useful properties programs remaining bounds current typechecking technology 
pict relatively rare channel input output region program typically parts program channel reading writing 
example cons cell server example reads channel cons clients write cons 
similarly request hd tl server writes result channel client reads 
pict exploits observation providing re nements channel type atype giving capability write values type symmetrically type giving capability read values type example re ne type annotations cons follows type intlist rec int cons hd int tl intlist intlist new int intlist rec intlist int intlist hd tl re ned type annotations cons requires write capability onthe channels note channel created read write capabilities 
cons cell server uses read capability locally gives client write capability 
types fall naturally subtype relation ps type may context type expected example input output expression 
record subtyping objective pict project explore applicability earlier theoretical type systems object oriented programming 
pt proposed powerful combination subtyping polymorphism basis statically typed object oriented programming functional languages equipping pict similar type system useful testbed experiments statically typed concurrent objects :10.1.1.17.9345
implement simple form record subtyping allows record elds added record 
example record type int bool int 
record type systems order elds pict record signi cant 
example bool int subtype int bool 
pict simple record subtyping combination fact order record elds signi cant simpli es compilation record values position eld record determined type compile time especially useful separately compiling pict programs 
polymorphism type system may readily extended include polymorphism just simply typed calculus extended polymorphism gir rey 
support polymorphic communications new syntactic forms package values package patterns example channel type int output expression int sends channel type int pair values type pronounced channel carrying type avalue belonging type channel carrying elements 
familiar notation type written 
process receiving form variable received type 
bound variables types ectively means legal operation send generalise cons cell server polymorphic list element type cons hd tl list list new list rec list list hd tl clients polymorphic cons send additional type argument cons channel 
example process uses polymorphic cons build integer cons cell assume tail list tl built type list int new list int cons int tl list int polymorphism subtyping combined giving bound type variable package value upper bound polymorphic calculus bounded quanti cation system cw cmms 
example type describes channel transmit type values types stipulates legal values subtypes just functions pict special status regarded output channels clients send tuples arguments continuation channel function send result polymorphic functions represented output channels carrying package values 
pun entails primitive form polymorphism pict existential types universal types typed calculi 
type operators strictly speaking type list int formed applying type constructor list type int 
list function types types 
avoid nonsensical applications list list int int classify types type operators kinds typed calculi system gir bar car mit hp ps 
type system recognizes distinct levels expressions values types kinds 
level values contains familiar entities true tuple true 
level types contains proper types int bool list int int bool int aswell type operators list 
proper types classify values sense entities level values may inhabit proper types inhabits int sense kinds classify types proper types inhabit kind type type operators accepting proper type parameter yielding proper type list inhabit kind type type type operators proper type arguments yielding proper type inhabit kind type type type 
type inference pict core language explicitly typed convenient annotations omitted user programs 
languages ml haskell hindley milner type system automatically infer necessary type annotations 
pict type system signi cantly powerful hindley milner type system particular allows higher order polymorphism subtyping 
unfortunately means don algorithm infer necessary type annotations pict program 
simple partial type inference algorithm algorithm partial sense may ask user add explicit type information determine types 
pict partial type inference algorithm exploits fact number common cases type assigned bound variable completely determined surrounding program context 
example variable input expression type int channel known type int 
pict type inference algorithm local sense uses immediately surrounding program context try ll missing type annotation 
rst restrictive experience far favorable 
largest pict program approximately lines long cases feels type inference algorithm isn inferring type annotations automatically 
reasons partial type inference works pict programs contain explicit type annotations purposes documentation 
turns cases explicit type annotations su cient uniquely determine types assigned bound variables 
simple type inference algorithm important bene ts 
firstly easy pict programmers understand process type inference understand type annotations required type errors mean 
secondly simple type inference algorithm easier formalise pict type inference algorithm forms part speci cation pict language 
type systems languages ml haskell speci ed means set typing rules non deterministically pick correct types bound variables 
details actual process type inference required necessary prove sound complete type inference algorithm exist 
infer missing type annotations pict programs necessary specify exactly type annotations inferred automatically 
local nature partial type inference pict possible describe algorithm rules pict typing rules formalise type information propagates expression 
concentrate explicitly typed language omit details type inference 
see pict de nition pt formal description type inference 
notation syntax type expressions follows type type input output channel type output channel type input channel id type type package type label type 
label type record type id type identi er id kind type type operator type type type application rec id kind type recursive type top kind maximal type int integer type char character type bool boolean type string string type kind kind kind kind type operators type kind types typing context list bindings associating variables types type variables upper bounds 
metavariables range contexts 
concatenation written type system pict comprises axioms inferences rules de ning sets derivable statements forms subtype value type assumptions declaration formed yields bindings pattern requires type yields bindings abstraction formed accepts type ok process expression formed type kind ok context formed kinds statement familiar type systems functional languages 
third checking pict declarations 
declaration sent channel type may give rise collection variable bindings scope need keep track types variables 
type declaration typing context 
similarly pattern binds variables gives rise context pattern type match values certain form 
abstraction requires argument certain form 
process expression yields bindings value simply formed 
process formed context input output subexpressions respect typings channels communication occurs 
forms statements give standard rules formedness types typing contexts 
rules kinded types formed contexts familiar literature higher order typed calculi hp ps discuss 
rest section presents selection rules de ne remaining forms typing statements 
full description typing kinding rules pict language de nition pt 
subtyping subtype relation consists structural rules plus rules type constructor constant 
structural rules state subtyping re exive transitive includes conversion types type operator type int equivalent int int conv trans formally conversion relation contains ordinary conversion fx 
sgt rule top conversion cf 
ps top operator kinds behave type operator top top 
type variable subtype upper bound declared context tvar top maximal type 
particular top type written just top largest type 
top top record type subtype record type contains elds types corresponding eld values subtypes 
example char int char bool int 

tn 
lnt record package type subtype bounds kind subtype subtype assumption subtype package channel constructor covariant 
contravariant 
operationally captures observation example channel context read elements type safe replace channel carrying elements type read may safely regarded element oft long subtype notice contravariance gives rise usual rule subtyping types functions 
function implemented pict server process reading requests type channel performing appropriate calculation returning result channel provided second argument 
point view caller request channel type type contravariant ins covariant ins expected constructor invariant subtype relation subtype equivalent 
type subtype allowed forget capability write capability channel input output may just capability needed 
subtype relation extended pointwise proper types kinds type operators say appropriately kinded argument types top abs app subtyping recursive types familiar amber rule car ac states rec subtype rec show assumption values top rec rec rec current context contains binding variable type context bound variables assumed unique ambiguity var values vn types tn record value record type 

vn tn record value incorporated existential package type witness type subtype actual type value match type substitution fx 
sgt package example res type bool value bool false res type false type fx 
bool res type fx 
bool 
readers familiar typed calculi recognize similarity rule standard rule existential types cw mp 
pattern typing rule package section standard elimination rule existentials 
avalue recursive type formed value type matches unrolling type rec rec means recursive type obtained unrolling recursion step 
example type rec type channel type rec type rec unroll rec fx 
rec gt general unrolling operator take account unrolling operation may applied type expression formed applying recursively de ned type operator arguments case arguments carried unchanged result recursive type unrolled place unroll app allow types values promoted subtype relation value type subtype type sub rule embodies principle safe substitutability underlies subtype relation statement means element context element oft required 
declarations new declaration returns binding new channel declared type check declared type kinded equivalent type 
patterns type new new pattern typing statements form pattern type describing shape values match gives rise set type term variable bindings 
avariable pattern matches value type gives rise binding variable type var wildcard pattern matches value type give bindings 
type wild layered pattern matches value type return variables bound plus binding type 
layered rec pattern accepts value type subpattern matched value unfolded recursive type type 
rec rec record pattern type ti types elements gives rise set bindings including bindings subpatterns 

pn tn record pattern matches value type type pattern assumption subtype 
pattern yields bindings produced type binding 
package process abstractions process abstraction requires argument oftype type pattern process typechecked context extended bindings introduced processes ok abs typing rules processes simplest 
parallel composition processes formed context parts 
ok ok prl ok input expression formed channel permission type formed abstraction accepts value type ok symmetrically output expression formed output channel type type ok local declaration provides set bindings process body checked 
ok ok dec conditional expression formed guard expression boolean type branches conditional formed 
bool ok ok ok type safety relation type system operational semantics expressed form evaluation fail typed processes reduction preserves typing 
de ne runtime failure means set inference rule similar form pict reduction rules sake brevity important rules 
important type failure hope prevent pattern matching failure communication type failure occur communication replicated input omit rule fp 
vg unde ned fails fail comm addition process fails attempts value channel subject communication recall syntax channel constants variables range channels 
example fails attempts record value 
omit rules similar failures input replicated input pre xes 
variable fails fail failures may occur inside local declarations parallel compositions processes fail str rule combination fail prl captures case failure occurs right hand subterm parallel composition fails fails fails fails fail dec fail prl reuse structural congruence relation section capture distributed nature failures 
process considered failed subprocesses top level guarded input pre xes may brought proximity structural manipulations fail 
fails fails conjecture type safety fail 
conjecture subject reduction 
fail str metatheoretic foundations needed prove properties established major components pict type system channel types subtyping pierce sangiorgi ps polymorphic channels turner tur higher order polymorphism subtyping pierce ste en ps com 
properties remain conjectures checked type system 
derived forms statically typed core language pict powerful safe unacceptably verbose programming notation 
section show convenient high level constructs built core means source source translations tradition numerous papers showing various highlevel features encoded calculus san san san mil jon wal ama ap 
discuss interesting translation rules complete list pict language de nition pt 
simple translations large programs contain long sequences declarations new 
new xn 
avoid proliferation parentheses introduce compact syntactic form new new xn high level language 
formally extend syntactic category processes ary declarations form dn introduce translation rule dn 
dn tr shows ary declarations may expressions core language 
sequences declarations convenient start process running parallel evaluation remainder declaration 
introduce declaration keyword run purpose 
declaration sequence translated nested collection individual declarations run declarations may translated simple parallel compositions run tr run example process run print run print rising print overhead passing transformed tr followed applications tr run print print rising print overhead passing calculus allow process abstractions xy xy 
pict abstractions introduced declaration keyword def instances created syntax output expressions 
coincidence notations sending channel instantiating process abstraction accidental translate process abstraction channel declaration new replicated receiver instantiating abstraction just output 
formally translation captured rule def new recursive mutually recursive de nitions allowed 
rst de nition recursive group introduced def 
def 
general translation rule def tr def new 
new xn 
xn 
note tr def transformation typed expressions 
actual type channel xi determined thetype pattern pi omit type annotation 
complex values far value expressions wehave encountered built extremely simple way just variables channels basic values tuples values records values 
simple values important exactly entities passed channels participate pattern matching 
real programs common write expression computes simple value immediately sends channel 
example process new creates fresh channel sends alternative syntax expressions easier understand puts value expression inside output new 
general useful allow expressions position simple value expected 
formally extend syntactic category values declaration values form 
term complex value expression extended syntax fall core language 
write new mean send expression new complex value evaluated strictly yield simple value substituted complex expression 
introducing complex values taken fairly serious step de ne meaning complex value occurring position simple values allowed 
example nested expression new new interpreted core language expression creates new channels packages simple tuple integer sends result interpret arbitrary complex values general continuation passing translation 
complex value continuation channel denote process evaluates sends resulting simple value introduce translation rules process expressions containing complex values 
example rule new tr translates output process expression rst allocates fresh continuation channel evaluates waits result sent evaluates sending result directly channel resulted evaluation 
input processes containing complex values translated similarly new tr new tr rin continuation passing translation de ned induction syntax value expressions rec new rec new record values evaluated left right value declarations new 
new cn vn cn cn xn 
complex value expressions may long involve expensive computations convenient introduce new declaration form evaluates complex value names result 
example val binds result evaluating executes formally val declarations translated continuation passing translation val new tr val note val declaration val translated core language body appears inside input pre fact implies val declarations strict blocking body proceed bindings introduced established 
application course allowing declarations inside values represents minor convenience usefulness extension justify foregoing machinery 
having established basic pattern simplifying complex value expressions means continuation passing transformation apply useful extension 
value expressions syntax vn 
example de ne double function def double string string concat concat string concatenation scope declaration write double value dropping explicit result channel example print double causes sent built channel print 
fact allow slightly general syntax application enables argument values labelled witness types provided case operation polymorphic 
de ne meaning application adding clause de nition continuation passing translation tn new 
new 
new cn vn cn cn xn tn function value evaluated rst followed argument values vn 
function called instructed return result application expression continuation channel abstractions pict core language type system distinguish real functions processes act functions useful write parts programs functional style 
supported small extension syntactic class abstractions mirroring ability omit names result parameters applications 
example replace process de nition form def body de nition consists just output complex value result channel function de nition def avoids explicitly giving name formally captured translation rule abstractions xn tn tr xn tn derived form allows type arguments function de nition translated package patterns 
note explicit result type annotation type annotation result channel 
anonymous process declarations def def frequently useful higher order programming provide anonymous abstractions special form value 
need extra case continuation passing translation describe meaning special form just add local transformation values example def val def tr de nes function passes anonymous function adds argument 
examples illustrate high level forms introduced list example section rewritten full syntax type list rec def nil list rec def cons hd tl list list rec hd tl uses nil cons streamlined application syntax val cons cons cons nil example illustrates build simple cell object pict 
def init new run init set get message sent consists pair values init initial value cell created implicit result channel server uses return newly created cell requesting client 
reading request server creates new channel acts container current value cell 
sending value represents action placing value container 
receiving value empties container receiver responsibility re ll container transmitting new value container initialized sending init parallel initializing container returns record containing set get methods process abstractions 
method waits request service port having received reads obtain current value cell re lls appropriate sends result client 
possible multiple copies method may running parallel moment 
sender blocked waiting input discussion return motivating questions summarize learned 
program calculus 
kind high level language built 
calculus best thought kind concurrent machine code simple exible ciently implementable ers suitable target compilation higher level language features 
variety features semantics expressed terms message passing wide quite di erent language designs arisen experiment 
worth bearing mind choosing calculus semantic framework strongly discourages potentially useful language features process priorities exceptions easily formalized setting 
particularly important feature addressed calculus physical distribution semantic framework calculus lacks necessary concepts process location failure 
currently underway onthe design new language tentatively named distributed pict variant ofthe calculus fg extended distribution primitives 
cardelli obliq car achieves related aims building primitive notion network objects :10.1.1.17.6050
pict belongs sizeable family concurrent programming language designs inspired theoretical calculi including vasconcelos vas kobayashi numerous actor languages agh 
particularly close relative language oz smo integrates functional object oriented concurrent constraint programming translation common core calculus smo 
calculus uses concurrent constraints basic communication mechanism encoding high level features strongly reminiscent pict 
choice high level language features leads programming style similar functional languages channel concurrency hol amber car cml rep facile gmp poly ml mat concurrent haskell 
signi cant di erence lies type system impredicative polymorphism pict permits encoding polymorphic functions polymorphic communication 
pun possible languages type systems ml polymorphism channels carry messages varying types 
re ned channel types provided pict input output channels give useful extra control channel usage programs 
languages poly ml concurrent haskell distinguish di erent modes channel usage opportunity optimise implementation communication exploiting explicit type information 
kinds concurrent objects arise setting 
simple style objects arises necessarily message concurrent programming object just group agents cooperate provide collection services outside world jointly maintaining consistency shared data 
convenient group services record named channels allowing access collection services passed clients single unit 
unfortunately subtle mechanisms concurrent object oriented languages dynamic method lookup inheritance synchronization policies arise inevitable way 
commit particular high level object model pict chosen provide framework experimenting variety designs 
pict type system incorporates number powerful constructs higher order subtyping especially purpose 
preliminary experiments concurrent objects pict described pt 
sophisticated proposals described nsl 
calculus implemented ciently 
pict high level language de ned means translation calculus core language 
useful style de nition far compilation pict concerned identi es small calculus su cient implement pict 
operational semantics calculus plus number known program equivalences give rise number easy implement provably correct program optimisations generalise optimisations commonly compilers functional languages 
pict compiler static analysis programs optimisation code generation calculus core language 
encoding high level language low level language calculus run risk losing useful information program 
fortunately wehave far able regain information need exploiting explicit type information particular heavy type information optimise implementation communication 
functional code compiled pict compiler comes looking generating passing compiler 
compile portability easy inter operability existing program libraries signi cant cost ciency compiled code tarditi lee tal report modi ed new jersey sml compiler generated code produced code ran approximately twice slow code produced native code generator 
simple comparisons code produced pict new jersey sml tur indicate functional code compiled pict runs approximately times slower produced new jersey sml 
nd quite encouraging pict compiler little tuning lacks number important optimisations particular representation closures pict optimised way 
new jersey sml advantage compiling native code code generate similar code generated tarditi lee sml compiler reasonably expect gain factor ifwe produced native code code leave factor performance new jersey sml 
fast channel communication primitives compared performance pict program equivalent cml program uses cml channel primitives implement result channels pict tur 
cml program ran times slower pict 
say cml programs general run times slower pict cml programs typically consist large amounts sml code runs faster pict 
comparison give performance pict communication primitives 
especially cml program advantage compiled native code 
design practical type system calculus combining subtyping higher order polymorphism 
pict type system integrates number studied ideas milner simple sorting discipline channels mil polymorphic channels tur higher order polymorphism gir input output modalities ps higher order subtyping car mit pt hp ps recursive types mps ac 
key obtaining workable type system pict development practical type inference algorithm 
pict partial type inference algorithm surprisingly simple easy understand experience gives acceptable results 
reasons partial type inference works pict programs contain explicit type annotations purposes documentation 
turns cases explicit type annotations su cient uniquely determine types assigned bound variables 
design pict type system gave goal complete type inference preference powerful type theoretic constructs 
example pict impredicative polymorphism directly supports useful features rst class existential types expressible simpler predictive polymorphic type systems 
extensions language pict programmers structure programs datatypes facility extensively pict standard libraries 
working modest extensions pict type system enable better programming large standard ml require separate module level language 
instance hope extend pict treatment existential types account type sharing techniques similar proposed leroy ler harper lillibridge hl 
robin milner past programming languages concurrency calculus particular strongly background project conversations robin contributed speci insights 
idea basing programming language design calculus planted bob harper developed research project summer discussions concurrent objectoriented programming languages edinburgh ml club 
davide sangiorgi learned higher order calculus ways encoding calculi calculus 
didier remy helped build original pic compiler rst version pict compiler prt joined discussions integration processes functions :10.1.1.38.4600
uwe nestmann research proof techniques compilations concurrent calculi sharpened ideas formal foundations pict 
martin ste en helped study formal foundations subtyping algorithm 
dilip contributed code ideas implementation type inference record type checking 
kohei honda nobuko yoshida peter sewell helped think fairness process calculi 
conversations luca cardelli georges gonthier finne cli jones naoki kobayashi martin muller joachim oscar nierstrasz simon peyton jones john reppy gert smolka david walker deepened understanding calculus concurrent programming languages 
pierce supported fellowships science engineering research council engineering physical sciences research council esprit basic research actions types confer 
turner supported fellowship engineering physical sciences research council 
ac roberto amadio luca cardelli 
subtyping recursive types 
acm transactions programming languages systems 
preliminary version appeared popl pp 
dec systems research center research report number august 
ac mart abadi luca cardelli 
objects 
springer verlag 
acs roberto amadio castellani davide sangiorgi 
bisimulations asynchronous pi calculus 
technical report inria sophia antipolis 
agh gul agha 
actors amodel concurrent computation distributed systems 
mit press cambridge ma 
ama roberto amadio 
translating core facile 
technical report ecrc tr european computer industry research center gmbh munich 
available technical report cnrs inria nancy 
ap roberto amadio prasad 
localities failures 
technical report ecrc european computer industry research center gmbh munich 
bar henk barendregt 
lambda calculi types 
gabbay abramsky maibaum editors handbook logic computer science volume ii 
oxford university press 
dave berry robin milner david turner 
semantics ml concurrency primitives 
acm principles programming languages january 
bou gerard boudol 
asynchrony calculus note 
de recherche inria antipolis may 
bru kim bruce 
paradigmatic object oriented programming language design static typing semantics 
journal functional programming april 
preliminary version appeared popl title safe type checking statically typed object oriented programming language 
car luca cardelli 
semantics multiple inheritance 
kahn macqueen plotkin editors semantics data types volume lecture notes computer science pages 
springer verlag 
full version information computation 
car luca cardelli 
amber 
guy cousineau pierre louis curien bernard robinet editors combinators functional programming languages pages 
springer verlag 
lecture notes computer science 
car luca cardelli 
notes 
unpublished manuscript october 
car luca cardelli :10.1.1.117.1304
typeful programming 
neuhold paul editors formal description programming concepts 
springer verlag 
earlier version appeared dec systems research center research report february 
car luca cardelli :10.1.1.17.6050
language distributed scope 
computing systems 
short version principles programming languages popl january 
cc felice mario coppo 
type inference recursive types 
syntax semantics 
information computation 
chc william cook walter hill peter canning 
inheritance subtyping 
seventeenth annual acm symposium principles programming languages pages san francisco ca january 
carl gunter john mitchell editors theoretical aspects object oriented programming types semantics language design mit press 
cmms luca cardelli simone martini john mitchell andre scedrov 
extension system subtyping 
information computation 
preliminary version appeared tacs sendai japan pp 

com adriana 
decidability higher order subtyping intersection types 
computer science logic september 
poland 
springer lecture notes computer science june 
available university edinburgh lfcs technical report ecs lfcs titled subtyping decidable 
cs costa stirling 
weak strong fairness ccs 
information computation 
cw luca cardelli peter wegner 
understanding types data abstraction polymorphism 
computing surveys december 
fg cedric fournet georges gonthier 
re exive chemical machine join calculus 
principles programming languages january 
cedric fournet georges gonthier jean jacques levy luc didier remy 
calculus mobile agents 
th international conference concurrency theory concur pages pisa italy august 
springer verlag 
lncs 
fm kathleen fisher john mitchell 
notes typed object oriented programming 
proceedings theoretical aspects computer software sendai japan pages 
springer verlag april 
lncs 
gay simon gay 
sort inference algorithm polyadic calculus 
proceedings twentieth acm symposium principles programming languages january 
gir jean yves girard 
interpretation fonctionelle elimination des coupures de ordre 
phd thesis universite paris vii 
gmp alessandro mishra prasad 
facile symmetric integration concurrent functional programming 
international journal parallel programming 
hewitt 
viewing control structures patterns passing messages 
arti cial intelligence 
hl robert harper mark lillibridge 
atype theoretic approach higher order modules sharing 
proceedings acm symposium principles programming languages popl portland oregon pages portland january 
hol holmstrom 
functional language parallel programming implementation 
programming methodology group report university goteborg chalmers university september 
hon kohei honda 
types dyadic interaction 
concur volume lecture notes computer science pages 
hon kohei honda 
composing processes 
principles programming languages popl pages january 
hp martin hofmann benjamin pierce 
unifying type theoretic framework objects 
journal functional programming october 
previous versions appeared symposium theoretical aspects computer science pages title view objects subtyping preliminary report university edinburgh lfcs technical report ecs lfcs 
ht kohei honda mario tokoro 
object calculus asynchronous communication 
pierre america editor proceedings european conference object oriented programming ecoop volume lecture notes computer science 
springer verlag berlin heidelberg new york tokyo 
hy kohei honda nobuko yoshida 
combinatory representation mobile processes 
principles programming languages popl pages january 
simon peyton jones andrew gordon finne 
concurrent haskell 
conference record rd acm sigplan sigact symposium principles programming languages popl pages st petersburg florida january 
acm press 
jon cli jones 
pi calculus semantics object design notation 
best editor proceedings concur lncs pages 
springer verlag 
naoki kobayashi 
concurrent linear logic programming 
phd thesis department information science university april 
kpt naoki kobayashi benjamin pierce david turner 
linearity pi calculus 
principles programming languages 
ky naoki kobayashi akinori yonezawa 
type theoretic foundations concurrent object oriented programming 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla pages 
ler xavier leroy 
applicative functors fully transparent higher order modules 
proceedings second acm symposium principles programming languages popl portland oregon pages san francisco california january 
mat david matthews 
distributed concurrent implementation standard ml 
technical report ecs lfcs university august 
mil robin milner 
functions processes 
research report inria antipolis 
final version journal mathematical structures computer science 
mil robin milner 
polyadic calculus tutorial 
technical report ecs lfcs laboratory foundations computer science department computer science university uk october 
appeared proceedings international summer school logic algebra speci cation marktoberdorf august 
reprinted logic algebra speci cation ed 
bauer brauer schwichtenberg springer verlag 
mit john mitchell 
typed foundation method specialization inheritance 
proceedings th acm symposium principles programming languages pages january 
carl gunter john mitchell editors theoretical aspects object oriented programming types semantics language design mit press 
mp john mitchell gordon plotkin 
types existential type 
acm transactions programming languages systems july 
mps david macqueen gordon plotkin ravi sethi 
ideal model recursive polymorphic types 
information control 
mpw milner parrow walker 
calculus mobile processes parts ii 
information computation 
nie oscar nierstrasz 
regular types active objects 
nierstrasz tsichritzis editors object oriented software composition pages 
prentice hall 
earlier version proceedings oopsla published acm sigplan notices october pp 

np uwe nestmann benjamin pierce 
decoding choice encodings 
proceedings concur august 
nsl oscar nierstrasz jean guy schneider markus 
formalizing composable software systems research agenda 
formal methods open object distributed systems february 
pie benjamin pierce 
programming pi calculus tutorial pict 
available electronically 
prt benjamin pierce didier remy david turner :10.1.1.38.4600
higher order programming language pi calculus 
workshop type theory application computer systems kyoto university july 
ps benjamin pierce davide sangiorgi 
typing subtyping mobile processes 
logic computer science 
full version mathematical structures computer science vol 

ps benjamin pierce martin ste en 
higher order subtyping 
theoretical computer science 
appear 
preliminary version appeared ifip working conference programming concepts methods calculi june university edinburgh technical report ecs lfcs universitat erlangen bericht january 
pt benjamin pierce david turner :10.1.1.17.9345
simple type theoretic foundations object oriented programming 
journal functional programming april 
preliminary version appeared principles programming languages university technical report ecs lfcs title object oriented programming recursive types 
pt benjamin pierce david turner 
concurrent objects process calculus 
ito akinori yonezawa editors theory practice programming sendai japan nov number lecture notes computer science pages 
springer verlag april 
pt benjamin pierce david turner 
pict language de nition 
draft report available electronically part pict distribution 
rep john reppy 
cml higher order concurrent language 
programming language design implementation pages 
sigplan acm june 
rey john reynolds 
theory type structure 
proc 
colloque sur la programmation pages new york 
springer verlag lncs 
san davide sangiorgi 
expressing mobility process algebras order higher order paradigms 
phd thesis department computer science university edinburgh 
san davide sangiorgi 
investigation functions processes 
proc 
ninth international conference mathematical foundations programming semantics mfps volume lecture notes computer science pages 
springer verlag 
san davide sangiorgi 
lazy lambda calculus concurrency scenario 
information computation 
sew peter sewell 
observations pict nondeterministic programming language 
manuscript 
smo gert smolka 
concurrent constraint programming 
constraints computational logics volume lecture notes computer science munich germany september 
invited talk 
smo gert smolka 
oz programming model 
jan van leeuwen editor computer science today lecture notes computer science vol 
pages 
springer verlag berlin 
tal david tarditi anurag acharya peter lee 
assembly required compiling standard ml technical report cmu cs school computer science carnegie mellon university november 
tur david turner 
polymorphic pi theory implementation 
phd thesis university edinburgh 
vas vasco vasconcelos 
typed concurrent objects 
proceedings eighth european conference object oriented programming ecoop volume lecture notes computer science pages 
springer verlag july 
vh vasco vasconcelos kohei honda 
principal typing schemes polyadic pi calculus 
proceedings concur july 
available keio university report cs 
wal david walker 
objects calculus 
information computation 

