journal selected areas communications vol 

month cryptographically sound security proof needham schroeder lowe public key protocol michael backes member ieee birgit pfitzmann senior member ieee cryptographically sound security proof known needham schroeder lowe public key protocol entity authentication 
protocol previously proved unfounded abstractions cryptography 
show secure arbitrary active attacks implemented standard provably secure cryptographic primitives 
proof deal probabilistic aspects cryptography scope current automated proof tools 
achieve exploiting proposed dolev yao style cryptographic library provably secure cryptographic implementation 
establishing cryptographic security needham schroeder lowe protocol result exemplifies potential cryptographic library paves way cryptographically sound verification security protocols automated proof tools 
index terms security cryptography protocols verification cryptographic protocols authentication key establishment established technology 
new networking messaging stacks come new protocols tasks 
design cryptographic protocols error prone demand rigorous proofs rising 
way conduct proofs cryptographic approach 
security definitions complexity theory :10.1.1.1.5724
security cryptographic protocol proved reduction showing breaking protocol implies breaking underlying cryptographic primitives respect cryptographic definition computational assumption hardness integer factoring 
approach captures comprehensive adversary model allows mathematically rigorous proofs 
computational restrictions proofs done hand far yields proofs faults gaps 
proofs rapidly complex larger protocols 
alternative formal methods approach concerned automation proofs model checkers theorem provers 
tools currently deal cryptographic details error probabilities computational manuscript received september revised april 
backes pfitzmann ibm research zurich 
email mbc bpf zurich ibm com conference version appeared foundations software technology theoretical computer science lncs springer verlag berlin 
overview workshop security protocols verification marseille france september proceedings 
ieee restrictions abstractions cryptography 
called dolev yao model represents cryptography term algebras 
original dolev yao model extended papers 
term algebras simplifies proofs larger protocols considerably led large body literature analyzing protocol security various techniques formal verification :10.1.1.145.4394:10.1.1.1.5724
prominent example usefulness approach lowe discovery man middle attack known needham schroeder public key authentication protocol 
lowe proposed repaired version protocol model checker fdr prove modified protocol henceforth known needham schroeder lowe protocol secure dolev yao model 
original repaired needham schroeder public key protocols investigated security protocols :10.1.1.51.4552
various new approaches proof tools analysis security protocols validated rediscovering known flaw proving fixed protocol dolev yao model 
known easy show security flaw original protocol dolev yao model mount successful attack cryptographic implementation protocol 
previous security proofs repaired protocol dolev yao model theorem carried results cryptographic approach comprehensive adversary 
close gap show needham schroeder lowe protocol secure cryptographic approach 
precisely show secure arbitrary active attacks including arbitrary concurrent protocol runs arbitrary manipulation bitstrings polynomial time 
underlying assumption dolev yao style abstraction public key encryption implemented secure public key encryption scheme small additions ciphertext tagging 
chosen ciphertext security introduced formulated ind cca 
efficient encryption systems secure sense exist reasonable assumptions 
proof relies general result called ideal cryptographic library implements slightly extended dolev yao model securely realized specific cryptographic implementation 
composition theorem efforts exist formulate syntactic calculi dealing polynomial time considerations particular 
approach handle protocols degree automation 
journal selected areas communications vol 

month underlying security notion implies protocol proofs ideal library security carries automatically cryptographic realization 
extension dolev yao model prior formal methods proof carries directly 
validates approach protocol proof new ideal library extended dolev yao model cryptographic security follows corollary 
value needham schroeder lowe protocol proof shows spite extensions differences presentation respect prior dolev yao models proof new library easily accessible current automated proof tools 
particular proof contains computational restrictions 
related concurrently warinschi gave cryptographically sound security proof needham schroeder lowe protocol 
proof done scratch cryptographic approach 
preceded giving example cryptographically sound proof cryptographic protocol deterministic dolev yao style idealization cryptography 
hand warinschi proves stronger properties discuss section iv 
shows chosen plaintext secure encryption insufficient security protocol 
justifying dolev yao style models cryptographic definitions prior restricted passive adversaries symmetric encryption :10.1.1.29.1076
concurrently extension asymmetric encryption passive attacks 
underlying masters thesis considers asymmetric encryption active attacks random oracle model idealization cryptography justifiable 
gives slightly efficient implementation asymmetric encryption additional tagging randomization cost general library weaker security notion outlook essentially give 
security notion relation ideal dolev yao style library cryptographic implementation reactive simulatability composition properties introduced extended asynchronous systems 
extends security notions multi party step function evaluation observational equivalence 
multiple possible layers sound abstraction cryptography sense reactive simulatability dolev yao style cryptographic libraries 
reach low level idealizations real cryptographic outputs high level abstractions secure channels 
specific aspects dolev yao style abstraction simple operator tree abstractions nested cryptographic terms restriction adversary capabilities algebraic operations terms assumption terms equality derived explicitly unequal 
certainly full dolev yao model needed model just needham schroeder lowe protocol prior attempt prove similar cryptographic protocol sound abstraction cryptography way accessible automated proof tools 
ii 
needham schroeder lowe protocol original needham schroeder public key protocol lowe variant consist steps 
steps deal key generation public key distribution 
usually omitted security analysis simply assumed keys generated distributed 
keep proof short 
underlying cryptographic library offers commands modeling steps 
main part needham schroeder lowe public key protocol consists steps expressed typical protocol notation 

nu 
nu nv 
nv 
user seeks establish session user generates nonce nu sends encrypted public key message 
receiving message decrypts obtain nonce nu 
generates new nonce nv sends nonces identity back encrypted public key second message 
receiving message decrypts tests contained identity equals sender message earlier sent contained nonce user sends second nonce back encrypted public key third message 
decrypts message earlier sent contained nonce believes speak iii 
needham schroeder lowe protocol dolev yao style cryptographic library formal proof techniques protocols needham schroeder lowe need reformulation protocol detailed version steps 
details include necessary tests received messages types generation rules values nu surrounding framework specifying number participants possibilities multiple protocol runs adversary capabilities 
true dolev yao style cryptographic library plays similar role proof csp dolev yao model inductive approach dolev yao model proofs 
protocol formulation framework algorithms 
explain formulation explain general aspects surrounding framework far needed proofs 
frameworks compilers generate detailed protocol descriptions 
possible framework similar way 
journal selected areas communications vol 

month detailed protocol descriptions write deterministic probabilistic assignment error element available addition domains ranges functions algorithms 
framework automata protocols executed interacting machines event machines react received inputs 
mns denote needham schroeder machine participant act roles 
type input mns receive start message new prot user denoting start protocol run user number users called user inputs distinguished network inputs arriving called port ea 
input ports follows csp convention ea stands entity authentication user interface entity authentication protocols 
reaction input sending message described algorithm 
algorithm evaluation user inputs mns require new prot ea 

gen nonce 
nonceu nonceu hnd 
hnd store 
list 
encrypt pke hnd list 
send 

command gen nonce generates nonce 
mns adds result set nonceu comparison 
command store inputs arbitrary application data cryptographic library user identity command list forms list encrypt encryption 
final command send means ns attempts send resulting term insecure channel 
superscript hnd parameters denotes called handles local names machine corresponding terms 
important aspect allows protocol description implemented dolev idealized cryptography real cryptography 
precisely commands saw far input output domains belong interface sense java interface underlying cryptographic library 
interface implemented idealized real version 
case handles local names dolev yao style terms second case real cryptographic bitstrings 
say implementations 
effect send ideal implementation adversary obtains handle dolev yao style term decide forwarding ns performing dolev algebraic operations term effect real implementation adversary obtains real bitstring perform arbitrary bit manipulations 
list operation directly sending technicality lists allowed sent library list operation concentrates verifications secret items put messages 
behavior needham schroeder machine participant receiving network input defined similarly algorithm 
input arrives port 
form hnd supposed sender denotes channel insecure hnd handle list 
port 
connected cryptographic library implementations represent obtained dolev yao style term real bitstring respectively protocol unified way handle 
algorithm evaluation network inputs ns require hnd 

hnd list proj hnd hnd decrypt ske hnd hnd hnd list proj 
xhnd xhnd xhnd input retrieve hnd 
abort hnd gen nonce 
nonceu nonceu hnd 
hnd store 
message list xhnd 
encrypt 
list 
send 
xhnd xhnd xhnd second message input retrieve xhnd 
xhnd nonceu abort list xhnd 
encrypt 
list 
send 
xhnd nonceu xhnd xhnd third message input output ok ea 
algorithm protocol machine decrypts list content secret key yields handle hnd inner list 
list parsed components command list proj 
list elements correspond message protocol contains correct identity machine generates new nonce stores handle set nonceu builds new list protocol description encrypts sends user list elements correspond second message protocol machine tests third list element equals list element contained set nonceu journal selected areas communications vol 

month tests succeed mns aborts 
builds term protocol description sends user list element correspond third message protocol machine tests handle element contained nonceu ns outputs ok ea 
signals user protocol user terminated successfully believes speak algorithms immediately abort handling current input cryptographic command yield desired result decryption fails 
readability omitted algorithm descriptions impose convention algorithms 
adversary 
protocol machines ns certain users defined guarantee machines correct 
trust model determines subsets want guarantee case essentially subsets aim entity authentication ns ns correct 
incorrect machines disappear replaced adversary 
set potential correct machines user interface called structure set structures called system 
considering security structure arbitrary probabilistic machine connected user interface represent users arbitrary machine connected remaining free ports typically network fig 

overview needham schroeder lowe ideal system convention mns receives answer cryptographic library command mns aborts execution current algorithm command types list proj send refer step algorithm step initial state assumed algorithms needham schroeder machine mns handle ske hnd secret encryption key handles pke hnd corresponding public keys participant cryptographic library represent key generation distribution normal commands 
machine mns represent adversary see fig 

polynomialtime security proofs polynomial time 
setting implies number concurrent protocol runs honest participants adversary considered arbitrarily interleave protocol start inputs new prot delivery network messages 
set honest participants user interface ideal real cryptographic library port set contains bitstring denoting identity family nonceu initially empty sets nonce handles 
framework adversary model framework determines machines needham schroeder machines machines idealized real cryptographic library execute taken 
basis asynchronous probabilistic execution model distributed scheduling 
implicitly term construction parsing commands cryptographic library called local scheduling defined result returned immediately 
idealized real network sending library scheduled cry 

needham schroeder machines input cryptographic commands obtain results received messages 
ideal case interface served just machine thh called trusted host essentially dolev yao style terms handles 
real case interface served set cry real cryptographic machines 
corresponding systems called sys cry id thh cry real cry cry 
user interface needham schroeder machines entity authentication protocol ea ea ea 

ideal real needham schroeder lowe systems serving interface differ cryptographic library 
ns mns sys ns id ns ea thh sys ns real ns cry ea 
polynomial runtime order valid users real cryptographic library machines mns polynomial time 
define machine mns maintains explicit polynomial bounds accepted message lengths number inputs accepted port 
done exactly cryptographic library omit rigorous write 
iv 
security property security property states honest participant successfully terminates protocol honest participant started protocol output ok ea 
happen prior input new prot ea 
property actual protocol consider replay attacks user journal selected areas communications vol 

month successfully terminate protocol multiple times protocol 
easily avoided follows mns receives message containing nonces additionally removes nonce corresponding set removes xhnd nonceu steps 
proving freshness change mutual authentication useful better done proof automated 
warinschi proves properties 
stronger property matching conversations proves constraints events system interface 
regard overspecification approach abstraction 
integrity properties underlying model formally sets traces user interfaces system port sets ea intuitively integrity property req contains traces ports 
trace sequence sets events 
write event meaning message occurs output port th step trace written rt speak step time integrity requirement req ea needham schroeder lowe protocol defined follows meaning believes speak time exists past time started protocol definition iv entity authentication requirement trace contained req ea notion system sys securely implements system sys reactive simulatability recall written sys ea ok rt ea new prot rt 
poly sec sys computational case 
main result sys cry real poly sec sys cry id 
sys ns real sys ns id compositions protocol sys cry real sys cry id respectively composition theorem imply sys ns real poly sec id 
showing theorem preconditions easy machines mns polynomial time see section iii 
integrity preservation theorem imply integrity requirement req sys ns id poly req sys ns real poly req 
prove sys ns id perf req ea immediately obtain sys ns real poly req ea vi 
proof ideal setting section contains proof ideal part theorem iv prove needham schroeder lowe protocol implemented ideal dolev yao style cryptographic library perfectly fulfils integrity requirement req ea proof idea go backwards protocol step step show specific output requires specific prior input 
instance user successfully terminates protocol user sent third protocol message sent second protocol message 
main challenge proof find suitable invariants state ideal needham schroeder lowe system 
start section rigorous definition possible states ideal cryptographic library needed formulating invariants 
define invariants prove entity authentication requirement invariants 
prove invariants describing detailed state transitions ideal cryptographic library needed proof 
notion system sys fulfilling integrity property req essentially comes flavors 
perfect fulfillment sys perf req means integrity property holds traces arising runs sys defined notion underlying model 
computational fulfillment sys poly req means property holds polynomially bounded users adversaries negligible error probability permitted 
perfect fulfillment implies computational fulfillment 
theorem captures security needham schroeder lowe protocol prove rest 
theorem iv security needham schroeder lowe protocol needham schroeder lowe systems section iii integrity property definition iv sys ns id perf req ea sys ns real poly req ea proof cryptographic realization idealization discussed idea approach prove theorem iv protocol ideal dolev yao style cryptographic library 
result real system follows automatically 
instantiation argument describe detail 
overview states ideal cryptographic library ideal cryptographic library dolev terms allows user operate handles local names specific user 
handles contain information knowledge sets give dolev yao formalizations set terms participant knows including adversary set terms handle saw needham schroeder lowe algorithms library offers user adversary typical operations terms handles encryption public key decryption secret key 
terms typed instance decryption succeeds ciphertexts projection lists 
secure encryption schemes necessarily probabilistic library allows generation polynomially nonces key pairs multiple instances terms structure journal selected areas communications vol 

month occur multiple encryptions message key pke 
multiple ways deal prior dolev yao models counting nonces multisets 
version corresponds counting terms globally numbered called index 
term represented type root node level arguments indices earlier terms 
enables easy distinction nonces encrypted larger term 
global indices visible user interface 
indices handles participant generated counter 
novel aspect cryptographic library compared prior dolev yao models terms length parameter indicating length corresponding real message 
derived tuple length functions denote length term depends length subterms 
necessary real encryption entirely hide length 
contains bounds accepted message lengths number accepted inputs port 
bounds arbitrary polynomially bounded security parameter formally number participants tuple parameters system sys cry id omitted readability 
similarly tuple parameters ideal needham schroeder lowe system sys ns id see section iii 
machines ns system inputs cryptographic library bounds easily chosen large inputs legal 
prove integrity property problem proof number accepted inputs exceeded 
omit details length functions 
described terms ideal cryptographic library trusted host thh set honest participants represented top level knowledge potential handles different participants 
data structure chosen database generally database set functions called entries finite domain called attributes 
entry value attribute att written att 
predicate pred involving attributes pred means subset entries attributes fulfill pred 
pred contains element notation element 
adding entry abbreviated write list operation xj arguments unambiguously retrievable case entry arguments ind type arg hndu 
len um arguments types meaning ind global index entry 
type ds isomorphic distinguishes index arguments 
index primary key attribute database write selection ind 
type typeset identifies type types nonce list data payload data ske pke secret public encryption keys enc encryptions occur 
arg 
aj possibly empty list arguments 
arguments type ds indices entries subterms distinguish superscript ind 
hndu hn ds handles hndu means know entry hn ds set isomorphic superscript hnd handles 
len denotes length entry 
machine thh counter size ds current size counters current handle handles initialized 
assumption keys generated distributed section iii means user entries form added type ske arg hndu ske hnd len type pke arg hndu pke hnd 
pke hnd um pke hnd len pke len 
consecutive natural numbers pke len length function public keys 
treating secret key length technicality matter 
invariants section contains invariants system sys ns id proof theorem iv 
invariants correct nonce owner unique nonce easily proved essentially state handles contained set nonceu point entries type nonce nonce sets 
invariants nonce secrecy nonce list secrecy deal secrecy certain terms 
mainly needed prove invariant correct list owner establishes created certain terms 
correct nonce owner 
hnd nonceu hndu hnd type nonce 
unique nonce 
size hndu nonceu 
nonce secrecy states nonces exchanged honest users remain secret users adversary users adversary handles nonce nonce secrecy 
size hndu nonceu 
similarly invariant nonce list secrecy states list containing nonce known states identity fields lists correct needham schroeder lowe messages 
list argument entry entry encryption public key journal selected areas communications vol 

month nonce list secrecy 
size type list ind arg 
ind hndu nonceu 
ind ind type data xi arg 
size arg type enc arg :10.1.1.1.5724
invariant correct list owner states certain protocol messages constructed intended users 
instance database entry structured cleartext protocol message type list argument belongs set nonceu second argument non cryptographic type data created user similar statements exist second third protocol message 
correct list owner 
size type list ind arg xhnd ind hndu 
xhnd nonceu ind type data created mns step 
ind type nonce xhnd nonceu created mns step 
xhnd nonceu ind created mns step 
invariant key proceeding backwards protocol 
instance terminates protocol user received third protocol message 
correct list owner implies message generated constructs message received second protocol message 
applying invariant times shows started protocol proof described take care details 
formally invariance statements captured lemma 
lemma vi statements correct nonce owner unique nonce nonce secrecy nonce list secrecy correct list owner invariants sys ns id hold times runs ns thh 
proof postponed section vi 
entity authentication proof increase readability partition proof steps explanations 
assume mns outputs ok user protocol terminated successfully 
show implies mns received message corresponding third protocol step form allows apply correct list owner show created mns property thh proven useful proof show properties proven time hold time 
lemma vi ideal cryptographic library sys cry id modifications existing entries assignments previously undefined attributes hndu counter updates entries signature keys consider 
proof ideal part theorem iv assume mns outputs ok ea 
time 
definition algorithms happen hnd input mv 
time 
sequel notation algorithm distinguish variables different executions superscript indicating number claimed received protocol message give handles additional subscript owner execution algorithm input hnd lv step abort convention creating output 
ind hnd lv ind algorithm implies ind type list 
ind ind arg time step 
definition list proj condition step true immediately step hnd ind time hnd ind time hnd step implies ind 
part proof shows ns received list corresponding third protocol message 
apply correct list owner list entry ind show entry created ns show ns generates entry received second protocol message 
show message contains nonce needed application correct list owner exploit fact accepts value nonce third message know part proof 
proof cont rd message equations preconditions part correct list owner 
entry ind created mns step 
algorithm execution started input hnd mu 
time hnd conclude lu step set ind hnd hndu lu ind obtain ind type list 
ind ind arg time step 
condition step true immediately hnd obtain xi 
definition list proj lemma vi imply hnd xi ind hndu time 
step ensures hnd nonceu correct nonce owner implies ind type nonce 
exploit mns creates entry ind step hnd input list 
definitions list ind equations list proj implies ind imply ind time 
journal selected areas communications vol 

month shown mns received list corresponding second protocol message 
apply correct list owner show mns created list show happen mns received suitable protocol message 
part proof shows mns got second protocol message mns remained open previous proof part 
proof cont nd message equations preconditions part correct list owner 
entry ind created ns step 
construction entry steps implies definitions store retrieve list list proj 
results equation lemma vi obtain hnd nonceu time 
algorithm execution mns creates entry ind started input hnd mv 
time conclude hnd step set ind hnd lv ind obtain ind type list 
ind ind arg time step 
condition step hnd true obtain xi 
definition list proj lemma vi yield hnd xi ind time 
mns hnd list equations imply creates entry ind step input 
implies ind ind 
ind hndu nonceu time 
test step ensures 
implies ind type data definition retrieve lemma vi ind type data time 
apply correct list owner show ns generated list corresponding protocol message 
show message intended user user started protocol user proof cont st message equations preconditions part correct list owner 
entry ind created ns step 
construction entry steps implies execution algorithm started input new prot ea 
time 
show mns creates entry ind step input list 
definition list proj implies ind hndu nonceu 
equation unique nonce conclude nutshell shown times mns outputs ok ea exists time mns receives input new prot ea 
time 
proves theorem iv 
command evaluation ideal cryptographic library section contains definition cryptographic commands modeling needham schroeder lowe protocol local adversary commands model extended capabilities adversary far needed prove invariants 
recall deal top levels dolev yao style terms commands typically create new term index type arguments handles length functions parse existing term 
full definitions commands reader ignore length functions names len 
integer variables mean length message denoted len 
input port 
list cmd xj cmd fixed list commands certain parameter domains 
usually write cmd xj variable designating result thh returns 
algorithm hnd ind hndu side effect denotes thh determines handle hnd user entry hnd hndu returns sets returns hnd hndu 
non handles identity function 
function ind hnd applies ind hndu element list 
definitions assume cryptographic command input port 

describe commands storing retrieving data handles 
storing hnd store max len type data arg ind return hnd ind hndu 
data len len max len return 
set hnd ind size type data arg hndu hnd len data len len 
retrieval retrieve hnd 
hndu hnd type data arg :10.1.1.1.5724
describe list creation projection 
lists include secret keys public key systems entries type ske sks information away 
generate list hnd list hnd hnd max len 
xi hndu hnd ind xi type sks ske set hnd type list arg xj ind return hnd ind hndu 
set length list len len 
xj len return length max len 
set hnd ind size type list arg 
xj hndu hnd len length 
journal selected areas communications vol 

month th projection hnd list proj hnd max len 
hndu hnd type list arg 
xj hnd ind hndu xi hnd 
command create fresh nonce simply creates new entry generate nonce hnd gen nonce 
set hnd ind size type nonce arg hndu hnd len nonce len 
commands encrypt decrypt list 
encryption hnd encrypt pk hnd hnd 
pk hndu pk hnd type pke ind hndu hnd type list ind length enc len len 
length max len pk return 
set hnd ind size type enc arg pk hndu hnd len length 
decryption hnd decrypt sk hnd hnd 
sk hndu sk hnd type ske ind hndu hnd type enc ind return sk pk arg sk arg :10.1.1.1.5724
return hnd ind hndu 
set local adversary commands capture additional commands adversary port ina describe command adv parse 
allows adversary retrieve information explicitly require hidden 
command returns type usually arguments value indices replaced handles case ciphertexts 
remaining local adversary commands need know output handles existing entries type list nonce 
parameter retrieval type arg adv parse hnd 
transforms arguments ds 
exception type enc arg form pk valid ciphertext pk adversary know secret key arg ind pk len 
describe commands sending messages insecure channels 
second adversary sends list pretending send hnd port 
ind hndu hnd type list ind ind output ind ind outa 
adv send hnd port ina 
ind hnd type list ind ind output ind ind 
proof invariants start proof correct nonce owner 
proof correct nonce owner xhnd nonceu 
construction xhnd added nonceu mns step step 
cases xhnd generated command gen nonce time input port 
thh 
convention implies xhnd mns abort add xhnd set nonceu definition gen nonce implies hndu xhnd hndu xhnd type nonce time lemma vi holds times finishes proof 
proof unique nonce quite similar 
proof unique nonce assume contradiction hndu nonceu time loss generality time time 
construction added time step step 
cases generated command gen nonce time 
definition gen nonce implies new entry handle time time correct nonce owner implies set new handle put times contradiction 
prove correct list owner nonce secrecy nonce list secrecy induction 
assume invariants hold particular time run system show hold time 
proof correct list owner size type list 
ind arg hnd ind hndu assume xhnd nonceu time 
possibilities violate invariant correct list owner entry created time handle hndu created time ind type type 
cases set arg ind hnd entry exists time handle arg 
recall xhnd added nonceu time 
cases invariant holds induction hypothesis lemma vi 
start third case 
assume xhnd added nonceu time 
construction happens transition mns step step 
entry ind generated command gen nonce input 
time ind contained argument entry time formally corresponds fact formed index arguments entry smaller index entry shown 
transition mns modify entries thh holds time 
proving remaining cases assume hndu created time existing entry generated time 
happen transition thh implies xhnd nonceu time transitions thh modify set nonceu nonce secrecy implies ind 
lists journal selected areas communications vol 

month constructed basic command list requires handles elements 
precisely creates entry type list 
arg time time applied entry implies created entry 
show entry created claimed steps 
easily seen inspection algorithms 
show detail part invariant proven similarly immediately implies ind ind handles nonces occur second element list generation arg hndu nonceu time nonce list secrecy entry implies time yields contradiction 
proof nonce list secrecy size type list 
ind arg xhnd ind hndu 
remaining parts 
xhnd nonceu ind type data 
inspection algorithms type list see entry created mns mns step 
remaining list generation commands element implies ind ind ind type data type nonce construction 
assume contradiction entry generated mns implies entry ind newly generated command gen nonce input inv 
mns add handle set nonceu local state mns nonce mns adds set nonceu newly generated command gen nonce input mns construction 
implies xhnd nonceu times yields contradiction xhnd nonceu time 
created user proof nonce secrecy size hndu nonceu 
correct nonce owner know type nonce 
invariant affected handle hndu put set nonceu time handle added entry time 
proving case note set nonceu extended handle mns steps 
cases generated thh time command gen nonce input 
time definition gen nonce immediately implies time holds time transition mns modify handles thh finishes claim case 
proving second case consider commands add handles entries type nonce 
commands list proj adv parse input adv parse applied entry type list entries type list arguments indices nonce entries 
precisely commands violated invariant exist entry time type list ind ind arg 
commands modify set nonceu hndu nonceu time nonce secrecy yields time times lemma vi 
implies entry created generating list presupposes handles elements cf 
previous proof 
assume loss generality generated inspection algorithms hnd nonceu 
show invariant violated adding handle xhnd nonceu time 
happen transition mns step 
shown proof correct list owner entry ind generated thh time formed implies ind arg entries exist time holds entries time transition mns modify entries thh 
yields contradiction ind arg 
know xhnd nonceu holds time part invariant affected handle added entry exists time 
creation time handle impossible presupposes handles arguments contradiction nonce secrecy 
commands add new handles existing entries type list list proj decrypt adv parse send adv send applied entry arg 
nonce list secrecy entry time yields type enc 
commands list proj send adv send considered 
nonce list secrecy yields arg :10.1.1.1.5724
secret keys known formally ske hnd ske hnd corresponds invariant key secrecy 
command decrypt violate invariant 
command adv parse applied entry type enc unknown secret key give handle cleartext list arg outputs length 
part invariant affected list entry created time 
formedness argument entry ind created 
part created party parties handle nonce argument 
inspection algorithms shows happen steps commands list argument preconditions imply ind 
creation step preceding step implies ind step implies ind type data 
preconditions part invariant hold ind hndu nonceu unique nonce implies steps yield ind arg 
creation step preceding steps imply preconditions part invariant hold 
precondition step unique nonce imply arg 
steps yield ind journal selected areas communications vol 

month part invariant violated new entry created time arg lemma vi formedness 
exists time nonce list secrecy implies time easily see inspection commands new entry created commands list encrypt sign creates signature entries newly created commands arguments indices entries type list 
commands entered port 
presuppose entry created time 
steps create entry arg properties demanded entry steps 
cases type enc 
arg denotes current believed partner :10.1.1.1.5724
show 
case created step 
inspection algorithm see precondition proof fulfilled 
ind hndu nonceu ind unique nonce imply case created step 
ind hndu nonceu ind unique nonce imply case created step 
execution algorithm give step abort convention 
lind ind algorithm implies lind type list 
ind ind arg hnd time step xi handles obtained step 
algorithm ind type data abort steps ind arg 
hnd reuse step implies ind ind precondition ind hndu nonceu entry lind fulfills conditions part nonce list secrecy 
implies ind arg case created step 
step implies ind 
case execution algorithm give step set lind ind lind type list 
ind ind arg hnd time step xi handles obtained step 
algorithm abort ind type data steps ind arg 
hnd reuse step implies ind ind precondition ind hndu nonceu entry lind fulfills condition part nonce list secrecy 
implies ind arg cases obtained list containing nonce encrypted key honest participant 
vii 
shown needham schroeder lowe publickey protocol secure real cryptographic setting 
done proof dolev yao style deterministic idealization cryptography provably secure real cryptographic implementation 
composition integrity preservation theorems underlying model imply protocol proof idealized cryptography carries real protocol implementation 
example proof 
spite certain differences usual dolev yao variants particular representation terms real cryptographic objects protocol layer handles local names length functions idealization proof type readily accessible automatic proof tools 
hope hand proof paves way automated cryptographically sound proofs needham schroeder lowe protocol security protocols 
michael waidner anonymous reviewers helpful comments 
goldwasser micali probabilistic encryption computer system sciences vol :10.1.1.1.5724
pp 

goldreich micali wigderson play mental game completeness theorem protocols honest majority proc 
th annual acm symp 
theory computing stoc pp 

bellare rogaway entity authentication key distribution crypto ser 
lncs vol 

springer pp 

mitchell mitchell scedrov linguistic characterization bounded oracle computation probabilistic polynomial time proc 
th ieee symp 
foundations computer science focs pp 

mitchell mitchell scedrov probabilistic time process calculus analysis cryptographic protocols electronic notes theoretical computer science vol 
pp 

impagliazzo logics reasoning cryptographic constructions proc 
th ieee symp 
foundations computer science focs pp 

dolev yao security public key protocols ieee trans 
inform 
theory vol 
pp 

goldreich security multi party ping pong protocols proc 
th ieee symp 
foundations computer science focs pp 

merritt cryptographic protocols ph dissertation georgia institute technology 
millen interrogator tool cryptographic protocol security proc 
th ieee symp 
security privacy pp 

meadows narrowing analysis key management protocols proc 
th ieee symp 
security privacy pp 

kemmerer analyzing encryption protocols formal verification techniques ieee select 
areas commun vol 
pp 

burrows abadi needham logic authentication src digital technical report 
paulson inductive approach verifying cryptographic protocols cryptology vol :10.1.1.145.4394
pp 

abadi gordon calculus cryptographic protocols spi calculus information computation vol :10.1.1.1.5724
pp 

journal selected areas communications vol 

month needham schroeder encryption authentication large networks computers communications acm vol 
pp 

lowe attack needham schroeder public key authentication protocol information processing letters vol 
pp 

breaking fixing needham schroeder public key protocol fdr proc 
nd intern 
conf 
tools algorithms construction analysis systems tacas ser 
lncs vol 

springer pp 

syverson new look old protocol operation systems review vol 
pp 

meadows analyzing needham schroeder public key protocol comparison approaches proc :10.1.1.51.4552
th european symp 
research computer security esorics ser 
lncs vol 

springer pp 

schneider verifying authentication protocols csp proc 
th ieee computer security foundations workshop csfw pp 

thayer herzog guttman strand spaces security protocol correct proc 
th ieee symp 
security privacy pp 

rackoff simon non interactive zero knowledge proof knowledge chosen ciphertext attack crypto ser 
lncs vol 

springer pp 

bellare desai pointcheval rogaway relations notions security public key encryption schemes crypto ser 
lncs vol 

springer pp 

cramer shoup practical public key cryptosystem provably secure adaptive chosen ciphertext attack crypto ser 
lncs vol 

springer pp 

warinschi computational analysis needham schroeder lowe protocol proc 
th ieee computer security foundations workshop csfw pp 

backes pfitzmann waidner composable cryptographic library nested operations proc 
th acm conf 
computer communications security pp 
full version iacr cryptology eprint archive jan eprint iacr org 
abadi rogaway reconciling views cryptography computational soundness formal encryption proc 
st ifip intern 
conf 
theoretical computer science ser 
lncs vol 

springer pp 

abadi formal eavesdropping computational interpretation proc :10.1.1.29.1076
th intern 
symp 
theoretical aspects computer software tacs pp 

laud semantics program analysis computationally secure information flow proc 
th european symp 
programming esop pp 

herzog liskov micali plaintext awareness key registration crypto ser 
lncs vol 

springer pp 

herzog computational soundness formal adversaries master thesis mit sept 
canetti goldreich halevi random oracle methodology revisited proc 
th annual acm symp 
theory computing stoc pp 

micciancio warinschi soundness formal encryption presence active adversaries proc 
st theory cryptography conference tcc ser 
lncs vol 

springer pp 

pfitzmann waidner composition integrity preservation secure reactive systems proc 
th acm conf 
computer communications security pp 

model asynchronous reactive systems application secure message transmission proc 
nd ieee symp 
security privacy pp 

canetti universally composable security new paradigm cryptographic protocols proc 
nd ieee symp 
foundations computer science focs pp 

yao protocols secure computations proc 
rd ieee symp 
foundations computer science focs pp 

goldwasser levin fair computation general functions presence majority crypto ser 
lncs vol 

springer pp 

micali rogaway secure computation crypto ser 
lncs vol 

springer pp 

beaver secure multiparty protocols zero knowledge proof systems tolerating faulty minority cryptology vol 
pp 

canetti security composition multiparty cryptographic protocols cryptology vol 
pp 

lincoln mitchell mitchell scedrov probabilistic poly time framework protocol analysis proc 
th acm conf 
computer communications security pp 

lowe compiler analysis security protocols proc 
th ieee computer security foundations workshop csfw pp 

backes jacobi cryptographically sound verification security protocols proc 
th annual symp 
theoretical aspects computer science stacs ser 
lncs vol 

springer pp 

michael backes received ms phd degrees computer science university saarbr cken germany respectively ms mathematics 
currently research staff member ibm research zurich switzerland 
research interests include security privacy cryptography particular linking formal methods cryptography secure reactive systems information flow privacy policy languages steganography 
research published papers international journals proceedings international conferences 
member acm ieee iacr 
birgit pfitzmann received diploma computer science university karlsruhe germany doctorate university hildesheim germany 
currently senior research staff member ibm research zurich switzerland responsible research federated identity management web services security formal verification cryptographic protocols 
professor university saarbr cken researcher universities hildesheim dortmund 
research interests include cryptographic primitives novel security properties protocol cryptanalysis privacy security architectures 
author research papers served program committees multiple international conferences particular program chair eurocrypt acm ccs 
senior member ieee member iacr served board directors acm gi 
