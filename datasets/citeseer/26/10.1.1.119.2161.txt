design tao real time object request broker douglas schmidt david levine schmidt levine cs wustl edu article appeared computer communications science volume april 
real time application domains benefit flexible open distributed architectures defined corba specification 
corba architecture distributed object computing standardized omg 
corba suited conventional request response applications corba implementations suited real time applications due lack key quality service qos features performance optimizations 
contributions design realtime corba systems 
describes design tao high performance real time implementation runs range os platforms real time features including vxworks chorus solaris windows nt 
second presents tao realtime scheduling service provide qos guarantees deterministic real time corba applications 
presents performance measurements demonstrate effects priority inversion non determinism conventional corba implementations hazards avoided tao 
distributed computing helps improve application performance multi processing reliability availability replication scalability extensibility portability modularity cost effectiveness resources sharing open systems 
increasingly important class distributed applications require stringent quality service qos guarantees 
applications include telecommunication supported part nsf ncr darpa contract boeing siemens sprint 
department computer science washington university st louis mo usa january systems command control systems multimedia systems simulations 
addition requiring qos guarantees distributed applications flexible reusable 
flexibility needed respond rapidly evolving functional qos requirements distributed applications 
reusability needed yield substantial improvements productivity enhance quality performance reliability interoperability distributed application software 
common object request broker architecture corba emerging standard distributed object computing doc middleware 
doc middleware resides clients servers 
simplifies application development providing uniform view heterogeneous network os layers 
heart doc middleware object request brokers orbs corba dcom java rmi 
orbs eliminate tedious error prone non portable aspects developing maintaining distributed applications low level network programming mechanisms sockets 
particular orbs automate common network programming tasks object location object activation parameter marshaling socket request demultiplexing fault recovery security 
orbs facilitate development flexible distributed applications reusable services heterogeneous distributed environments 
overview corba model corba object request brokers orbs allow clients invoke operations distributed objects concern issues object location corba objects collocated client distributed remote server affecting implementation 
programming language languages supported corba include java ada cobol smalltalk 
os platform corba runs os platforms including win unix mvs real time embedded systems vxworks chorus 
communication protocols interconnects communication protocols interconnects corba run include tcp ip ipx spx fddi atm ethernet fast ethernet embedded system shared memory 
hardware corba shields applications side effects stemming differences hardware storage layout data type sizes ranges 
illustrates components corba model collaborate provide portability interoperability transparency outlined 
com components corba model ponent corba model outlined client program entity performs application tasks obtaining object objects invoking operations 
objects remote collocated relative client 
ideally accessing remote object simple calling operation local object object operation args 
shows underlying components described orbs transmit remote operation requests transparently client object 
object corba object instance interface definition language idl interface 
object identified object uniquely names instance servers 
objectid associates object servant implementation unique scope object adapter 
lifetime object servants associated implement interface 
servant component implements operations defined omg interface definition language idl interface 
languages java support objectoriented oo programming servants implemented class instances 
non oo languages servants typically implemented functions structs 
client interacts servant directly object identified object 
orb core client invokes operation object orb core responsible delivering request object returning response client 
objects executing remotely corba compliant orb core communicates version general inter orb protocol giop commonly internet inter orb protocol iiop runs atop tcp transport protocol 
orb core typically implemented run time library linked client server applications 
orb interface orb abstraction implemented various ways processes set libraries 
decouple applications implementation details corba specification defines interface orb 
orb interface provides standard operations initialize shutdown orb convert object strings back create argument lists requests dynamic invocation interface dii 
omg idl stubs skeletons idl stubs skeletons serve glue client servants respectively orb 
stubs provide strongly typed static invocation interface sii marshals application parameters common data level representation 
conversely skeletons data level representation back typed parameters meaningful application 
idl compiler idl compiler transforms omg idl definitions stubs skeletons generated automatically application programming language java 
addition providing programming language transparency idl compilers eliminate common sources network programming errors provide opportunities automated compiler optimizations 
dynamic invocation interface dii dii allows clients generate requests run time useful application compile time knowledge interface accesses 
dii allows clients deferred synchronous calls decouple request response portions way operations avoid blocking client servant responds 
contrast corba sii stubs support way request response way request operations 
omg standardized static asynchronous method invocation interface messaging specification appear corba 
dynamic skeleton interface dsi dsi server analogue client dii 
dsi allows orb deliver requests servants compile time knowledge idl interface implement 
clients making requests need know server orb uses static skeletons dynamic skeletons 
likewise servers need know clients dii sii invoke requests 
object adapter object adapter associates servants objects creates object incoming requests servants collaborates idl skeleton dispatch appropriate operation upcall servant 
corba portability enhancements define portable object adapter supports multiple nested orb 
object adapters enable orbs support various types servants possess similar requirements 
design results smaller simpler orb support wide range object granularities lifetimes policies implementation styles properties 
interface repository interface repository provides run time information idl interfaces 
information possible program encounter object interface known program compiled able determine operations valid object invocations dii 
addition interface repository provides common location store additional information associated interfaces corba objects type libraries stubs skeletons 
implementation repository implementation repository contains information allows orb activate servers process servants 
information implementation repository specific orb os environment 
addition implementation repository provides common location store information associated servers administrative control resource allocation security activation modes 
limitations corba real time applications experience corba telecommunication avionics medical imaging projects indicates suited conventional rpc style applications possess best effort quality service qos requirements 
conventional corba implementations suited high performance real time applications reasons lack qos specification interfaces corba standard provide interfaces specify qos requirements 
instance standard way clients indicate relative priorities requests orb 
likewise interface clients inform orb rate execute operations periodic processing deadlines 
corba standard define interfaces allow applications specify admission control policies 
instance video server prefer available network bandwidth serve limited number clients refuse service additional clients admit clients provide poor video quality 
conversely stock quote service want admit large number clients distribute available bandwidth processing time equally 
lack qos enforcement conventional orbs provide qos enforcement application network 
instance orbs transmit schedule dispatch client requests fifo order 
fifo strategies yield unbounded priority inversions occur lower priority request blocks execution higher priority request indefinite period 
likewise conventional orbs allow applications specify priority threads process requests 
standard orbs provide fine grained control servant execution 
instance terminate servants consume excess resources 
orbs ad hoc resource allocation 
consequently single client consume available network bandwidth misbehaving servant server cpu 
lack real time programming features corba specification define key features necessary support real time programming 
instance corba general inter orb protocol giop supports asynchronous messaging 
standard programming language mapping exists corba transmit client requests asynchronously messaging specification corba define mapping 
likewise corba specification require orb notify clients transport layer flow control occurs support timed operations 
result hard develop portable efficient real time applications behave deterministically orb endsystem network resources unavailable temporarily 
lack performance optimizations conventional orb endsystems incur significant throughput latency overhead exhibiting priority inversions sources non determinism shown 
overheads stem non optimized presentation layers copy touch data excessively overflow processor caches internal buffering strategies produce non uniform behavior different message sizes inefficient demultiplexing dispatching algorithms long chains intra orb virtual method calls sources latency priority inversion conventional orbs lack integration underlying real time os network qos mechanisms 
overcoming corba limitations highperformance real time applications meeting qos needs generation distributed applications requires defining idl interfaces adding preemptive real time scheduling os 
requires vertically horizontally integrated orb endsystem deliver qos guarantees multiple levels distributed system 
key components orb endsystem include network interfaces operating system subsystems communication protocols common middleware object services 
implementing effective framework real time corba requires orb endsystem developers address types issues qos specification qos enforcement 
realtime applications meet certain timing constraints ensure usefulness applications 
instance videoconferencing application may require upper bound propagation delay video packets source destination 
constraints defined qos specification system 
providing effective oo middleware requires real time orb endsystem supports mechanisms semantics applications specify qos requirements 
second architecture orb endsystem designed carefully enforce qos parameters specified applications 
section describes developing inte middleware framework called ace orb tao 
tao high performance real time orb endsystem developed ace framework highly portable oo middleware communication framework 
ace contains rich set components implement strategic design patterns highperformance real time communication systems 
tao ace runs wide range os platforms including general purpose operating systems solaris windows nt real time operating systems vxworks chorus 
synopsis tao tao project focuses topics related real time corba orb endsystems identifying enhancements standard orb specifications particularly omg corba enable applications specify qos requirements concisely precisely orb endsystems 
empirically determining features required build real time orb endsystems enforce deterministic statistical application qos guarantees 
integrating strategies subsystem architectures optimizations orb middleware provide bandwidth latency reliability guarantees distributed applications 
capturing documenting key design patterns necessary develop maintain configure extend real time orb endsystems 
addition providing real time orb tao integrated orb endsystem consists high performance subsystem atm port interconnect controller apic 
illustrates main components tao orb endsystem architecture 
requirements high performance real time orb endsystems remainder section describes requirements features orb endsystems necessary meet highperformance real time application qos needs 
outlines key performance optimizations provides roadmap orb features optimizations subsequent sections 
summarizes material covered 
policies mechanisms specifying application qos requirements orb endsystems allow applications specify qos requirements idl operations small number application centric features optimizations real time orb endsystems os network centric parameters 
typical qos parameters include computation time execution period bandwidth delay requirements 
instance video conferencing groupware may require high throughput statistical real time latency deadlines 
contrast avionics mission control platforms may require rate periodic processing deterministic real time deadlines 
qos specification addressed corba specification omg special interest group sig devoted topic 
section explains tao allows applications specify qos requirements combination standard omg idl qos aware orb services 
qos enforcement real time operating systems networks regardless ability specify application qos requirements orb endsystem deliver toend guarantees applications network os support qos enforcement 
orb endsystems capable scheduling resources cpus memory network connection bandwidth latency 
instance os scheduling mechanisms allow high priority client requests run completion prevent unbounded priority inversion 
os requirement preemptive dispatching 
example thread may runnable higher priority currently running corba request cpu 
case low priority thread preempted removing cpu favor high priority thread 
section describes os subsystem network interface integrating tao 
infrastructure designed scale support performance sensitive applications require gigabit data rates predictable scheduling orb endsystem low latency corba applications 
efficient predictable real time communication protocols protocol engines throughput latency reliability requirements multimedia applications teleconferencing stringent diverse traditional applications remote login file transfer 
likewise channel speed bit error rates services isochronous bounded latency delivery guarantees networks atm exceed offered traditional networks ethernet 
orb endsystems provide protocol engine efficient predictable flexible customized different application qos requirements network endsystem environments 
section outlines tao protocol engine provides real time enhancements high performance optimizations standard corba general inter orb protocol giop 
giop implementation tao protocol engine specifies connection concurrency architecture minimizes priority inversion transport protocol enables efficient predictable interoperable processing communication heterogeneous orb endsystems 
efficient predictable request demultiplexing dispatching orb endsystems demultiplex dispatch incoming client requests appropriate operation target servant 
conventional orbs demultiplexing occurs multiple layers including network interface protocol stack user kernel boundary levels orb object adapter 
demultiplexing client requests layers expensive particularly large number operations appear idl interface large number servants managed orb endsystem 
minimize overhead ensure predictable dispatching behavior tao applies perfect hashing active demultiplexing optimizations described section demultiplex requests time 
efficient predictable presentation layer orb presentation layer conversions transform application level data portable format masks byte order alignment word length differences 
performance optimizations designed reduce cost presentation layer conversions 
instance describes tradeoffs compiled vs interpreted code presentation layer conversions 
compiled marshaling code efficient requires excessive amounts memory 
problematic embedded real time environments 
contrast interpreted marshaling code slower compact utilize processor caches effectively 
section outlines tao supports predictable performance guarantees interpreted compiled marshaling operations giop protocol engine 
protocol engine applies number innovative compiler techniques optimization principles 
principles include optimizing common case eliminating gratuitous waste replacing general purpose operations specialized efficient ones precomputing values possible storing redundant state speed expensive operations passing information layers optimizing cache 
efficient predictable memory management modern high speed hardware platforms data copying consumes significant amount cpu memory bus resources 
likewise dynamic memory management incurs significant performance penalty due locking overhead nondeterminism due heap fragmentation 
minimizing data copying dynamic memory allocation requires collaboration multiple layers orb endsystem network interfaces subsystem protocol stacks orb core object adapter presentation layer application specific servants 
section outlines tao vertically integrated memory management scheme minimizes data copying lock contention orb endsystem 
real time vs high performance tradeoffs common misconception applications real time requirements equivalent application high performance requirements 
necessarily case 
instance internet audio conferencing system may require high bandwidth require predictably low latency provide adequate qos users real time 
multimedia applications teleconferencing real time high performance requirements 
applications domains avionics process control stringent periodic processing deadline requirements worst case 
domains achieving predictability worst case important high performance average case 
important recognize high performance requirements may conflict real time requirements 
instance real time scheduling policies rely predictability endsystem operations thread scheduling demultiplexing message buffering 
certain optimizations improve performance expense predictability 
instance self organizing search structure demultiplex client requests orb object adapter increase average case performance operations decreases predictability operation worst case 
allow applications select appropriate tradeoffs average case worst case performance tao designed extensible software architecture key communication patterns 
appropriate tao employs algorithms data structures optimize performance predictability 
instance de layered active demultiplexing scheme described section increase orb performance predictability eliminating excessive searching avoiding priority inversions demultiplexing layers 
remainder article organized follows section describes feature enhancements optimizations developing tao section discusses design implementation tao real time scheduling service detail section presents performance measurements demonstrate tao ability support real time qos requirements section 
compares related research projects section presents concluding remarks 
architectural components features high performance realtime orb endsystems tao orb endsystem contains network interface subsystem communication protocol corba middleware components shown 
components include 

subsystem send receives requests clients real time network atm backplane vme 

run time scheduler determines priority requests processed clients servers orb endsystem 

orb core provides highly flexible portable efficient predictable corba inter orb protocol engine delivers client requests object adapter returns responses clients 

object adapter dispatches client requests optimally servants perfect hashing active demultiplexing 

stubs skeletons optimize key sources marshaling overhead code generated automatically tao idl compiler 

memory manager minimizes sources dynamic memory allocation data copying orb endsystem 

qos api allows applications higher level corba services specify qos parameters oo programming model 
tao subsystem portions run time scheduler memory manager run kernel 
conversely tao architectural components tao real time orb endsystem orb core object adapter stubs skeletons portions run time scheduler memory manager run user space 
remainder section describes components explains implemented tao meet requirements high performance real time orb endsystems described section 
section focuses components allow applications specify qos requirements real time servant operations 
discusses high performance real time features tao designed support applications wide range qos requirements 
components tao high performance real time subsystem high performance real time subsystem subsystem responsible mediating orb application access low level network os resources device drivers protocol stacks cpu 
key challenges building high performance real time subsystem convenient applications specify qos requirements enforce qos specifications minimize priority inversion non determinism enable orb middleware leverage qos features provided underlying network os resources 
meet challenges developed highperformance real time network subsystem customized tao 
components subsystem shown 
include high speed atm network interface high performance real time subsystem real time scheduling service run time scheduler admission controller described 
high speed network interface bottom tao subsystem daisy chained interconnect containing atm port interconnect controller apic chips 
apic endsystem network interface interface chip 
sustains aggregate bi directional data rate gbps 
tao optimized apic subsystem designed layered architecture run conventional os platforms 
instance tao ported real time interconnects vme compact pci multi processor shared memory environments qos enabled networks ipv rsvp 
real time subsystem general purpose operating systems solaris windows nt support realtime scheduling 
example solaris provides real time scheduling class attempts bound time required dispatch threads thread class 
generalpurpose operating systems provide real time subsystems 
instance solaris streams implementation support qos guarantees streams processing performed system thread priority lower real time threads 
solaris subsystem prone priority inversion low priority realtime threads preempt operations high priority threads 
unbounded priority inversion highly undesirable real time environments 
tao enhances streams model provided solaris real time operating systems vxworks 
tao real time rio subsystem minimizes priority inversion hidden scheduling arise protocol processing 
tao minimizes priority inversion pre allocating pool kernel threads dedicated protocol processing 
kernel threads scheduled pool application threads 
kernel threads run priority application threads prevents real time scheduling hazards outlined 
ensure predictable performance kernel threads belong real time scheduling class 
scheduling class uses rate monotonic scheduling rms support real time applications periodic processing behavior 
real time thread admitted os kernel tao rio subsystem responsible computing priority relative threads class dispatching thread periodically deadlines met 
hidden scheduling occurs kernel performs asynchronously regard priority 
streams processing solaris example hidden scheduling computation time accounted application os scheduler 
avoid hidden scheduling kernel perform priority thread requested 
real time scheduling service run time scheduler scheduling abstractions defined real time operating systems vxworks posix implementations relatively low level 
instance require developers map high level application qos requirements lower level os mechanisms thread priorities virtual circuit bandwidth latency parameters 
manual mapping step non intuitive application developers prefer design terms objects operations objects 
allow applications specify scheduling requirements higher level intuitive manner tao provides real time scheduling service 
service corba object responsible allocating system resources meet qos needs applications share orb endsystem 
applications tao real time scheduling service specify processing requirements operations terms various parameters computation time period deadline operations scheduled scheduling service assigns priority request 
runtime priority assignments tao runtime scheduler 
run time scheduler maps client requests particular servant operations priorities understood local endsystem os thread dispatcher 
dispatcher priorities real time threads performs preemption schedulability enforced runtime 
section describe run time scheduler realtime scheduling service detail 
admission controller ensure application qos requirements met tao performs admission control real time scheduling class 
admission control allows os guarantee specified computation time refuse admit thread 
admission control useful real time systems deterministic statistical qos requirements 
focuses primarily admission control orb endsystems 
admission control important distributed system 
instance admission control global resource managers map applications computational storage network resources large scale distributed system ship board computing environment :10.1.1.27.1465
efficient predictable orb cores orb core component corba architecture manages transport connections delivers client requests object adapter returns responses clients 
orb core typically implements orb transport endpoint demultiplexing concurrency model 
key challenges developing real time orb core implementing efficient protocol engine corba inter orb protocols giop iiop determining suitable connection concurrency model share aggregate processing capacity orb endsystem components predictably operations threads control designing orb core adapted easily new endsystem network environments application qos requirements 
describes tao orb core designed meet challenges 
tao inter orb protocol engine tao protocol engine highly optimized real time version sunsoft iiop implementation integrated high performance subsystem described section 
tao orb core client server intermediate nodes collaborate process requests accordance qos attributes 
design allows clients indicate relative priorities requests allows tao enforce client qos requirements 
increase portability os network platforms tao protocol engine designed separate layer tao orb core 
tightly integrated high performance real time subsystem described section run conventional embedded platforms linked interconnects vme shared memory 
outline existing corba interoperability protocols describe tao implements protocols efficient predictable manner 
overview giop iiop corba designed run multiple transport protocols 
standard orb interoperability protocol known general inter orb protocol giop 
giop provides standard interoperability protocol potentially heterogeneous orbs 
giop specifies interface mapped transport protocols meet certain requirements connection oriented reliable message delivery untyped 
orb supports giop applications orb send receive standard giop messages 
giop specification consists elements common data representation cdr definition giop specification defines common data representation cdr 
cdr transfer syntax maps omg idl types native endsystem format bi canonical format supports little endian big endian binary data formats 
data transferred network cdr encodings 
giop message formats giop specification defines messages sending requests receiving replies locating objects managing communication channels 
giop transport assumptions giop specification describes types transport protocols carry giop messages 
addition giop specification describes connections managed defines constraints message ordering 
corba inter orb protocol iiop mapping giop tcp ip protocols 
orbs iiop able communicate orbs publish locations interoperable object ior format 
implementing giop iiop efficiently predictably corba giop iiop provide support specifying enforcing qos requirements applications 
giop iiop unsuitable real time applications tolerate latency overhead jitter tcp ip transport protocols 
instance tcp functionality adaptive retransmissions deferred transmissions delayed acknowledgments cause excessive overhead latency real time applications 
likewise routing protocols ipv lack functionality packet admission policies rate control lead excessive congestion missed deadlines networks endsystems 
address shortcomings tao orb core supports priority concurrency architecture priority connection architecture real time inter orb protocol described 
tao priority concurrency architecture tao orb core configured allocate real time thread application designated priority level 
thread tao orb core associated reactor implements reactor pattern provide flexible efficient endpoint demultiplexing event handler dispatching 
playing role server tao demultiplex incoming client requests connection handlers perform giop processing 
handlers collaborate tao object adapter dispatch requests application level servant operations 
operations execute models client propagation model operation run priority client invoked operation 
server sets model operation run priority thread server orb core received operation 
forthcoming real time corba specification support capability 
addition tao orb core configured support concurrency architectures including thread pool thread connection singlethreaded reactive dispatching 
server sets priority model suited deterministic real time applications minimizes priority inversion non determinism tao orb core 
addition reduces context switching synchronization overhead servant state locked servants interact different thread priorities 
tao priority concurrency architecture optimized statically configured fixed priority real time applications 
addition suited scheduling analysis techniques associate priority rate rate monotonic scheduling rms rate monotonic analysis rma 
instance avionics mission computing systems commonly execute tasks rates groups 
rate group assembles periodic processing operations occur particular rates hz hz hz hz assigns pool threads fixed priority scheduling 
tao priority connection architecture illustrates tao configured connection architecture 
model client tao priority connection concurrency architectures thread maintains connector thread specific storage :10.1.1.40.8396
connector manages map pre established connections servers 
separate connection maintained thread priority server orb 
design enables clients preserve priorities requests traverse orb endsystems communication links 
shows reactor associated thread priority server orb configured :10.1.1.40.8396
socket endpoint factory listens specific port number clients connect orb instance running particular thread priority 
tao configured priority level acceptor port 
instance statically scheduled avionics mission computing systems ports mapped hz hz hz hz rate groups respectively 
requests arriving socket ports processed appropriate fixed priority real time threads 
client connects acceptor server orb creates new socket queue giop connection handler service queue 
tao subsystem uses port number contained arriving requests demultiplexing key associate requests appropriate socket queue 
design minimizes priority inversion orb endsystem early demultiplexing associates requests arriving network interfaces appropriate real time thread services target servant 
described section early demultiplexing tao vertically integrate orb endsystem qos support network interface application servants 
tao real time inter orb protocol tao connection priority scheme described optimized fixed priority applications transfer requests particular rates statically allocated connections serviced priority real time server threads 
applications possess dynamic qos characteristics propagate priority client server require flexible protocol 
tao supports real time inter orb protocol 
implementation giop allows orb endsystems transfer qos attributes clients servants 
instance tao mapping transfer importance operation giop message 
receiving orb endsystem uses qos attribute set priority thread processes operation server 
maintain compatibility existing iiop orbs tao protocol implementation transfers qos information service context member giop 
orbs support tao extensions transparently ignore service context member 
incidentally feature standardized qos property asynchronous messaging portion corba specification 
tao service context passed client invocation contains attributes describe operation qos parameters 
attributes supported tao extensions include priority execution period communication class 
communication classes supported tao include isochronous continuous media burst bulk data message small messages low delay requirements message stream message sequences processed certain rate 
addition transporting client qos attributes tao designed map corba giop variety networks including high speed networks atm lans atm ip wans 
customized specific application requirements 
support applications require complete reliability tao mapping selectively omit transport layer functionality run directly atop atm virtual circuits 
instance teleconferencing certain types imaging may require retransmissions bit level error detection 
enhancing extensibility portability tao orb core conventional orbs interoperate iiop tcp ip orb limited running transports 
instance tcp transfer giop requests reliably flow control congestion control algorithms may preclude real time protocol 
likewise shared memory may effective transport mechanism clients servants collocated endsystem 
key design challenge orb core extensible portable multiple transport mechanisms os platforms 
increase extensibility portability tao orb core patterns ace framework 
section 
describes patterns tao detail 
outlines patterns tao orb core 
tao orb core uses strategy factory patterns allow configuration multiple scheduling algorithms earliest deadline maximum urgency 
likewise bridge pattern shields tao orb core choice scheduling algorithm 
tao uses ace components service configurator pattern allow new algorithms scheduling demultiplexing concurrency dispatching configured dynamically runtime 
platforms compilers optimize virtual function calls overhead extensibility negligible 
patterns tao orb core simplify connection concurrency architectures 
instance acceptor connector pattern defines ace components tao decouple task connection establishment giop processing tasks performed connection establishment :10.1.1.40.8396
tao uses reactor pattern defines ace component simplifies event driven portions orb core integrating socket demultiplexing dispatching corresponding giop connection handlers 
likewise active object pattern defines ace component tao configure multiple concurrency architectures decoupling operation invocation operation execution 
tao ports easily os platforms built ace components patterns described 
currently ace tao ported wide range os platforms including win win versions unix sunos sgi irix hp ux dec unix aix linux sco netbsd freebsd real time operating systems vxworks chorus psos mvs 
illustrates components client side server side tao orb core 
client components tao orb core side uses strategy connector create cache connection handlers bound server 
connections pre allocated orb initialization 
pre allocation minimizes latency client invocation servant operation execution connections established priori tao explicit binding operation 
server side reactor detects new incoming connections notifies strategy acceptor 
strategy acceptor accepts new connection associates connection handler executes thread appropriate real time priority 
client connection handler pass giop requests described section server connection handler 
handler upcalls tao object adapter dispatches requests appropriate servant operation 
real time scheduling dispatching client requests tao orb core configured implement custom mechanisms process client requests application specific real time scheduling policies 
provide guaranteed share cpu application operations tao orb core uses real time scheduling service described section 
strategies provided tao orb core variant periodic rate monotonic scheduling implemented real time threads real time upcalls 
tao orb core contains object run time scheduler shown 
scheduler dispatches client requests accordance real time scheduling policy configured orb endsystem 
run time scheduler maps client requests real time thread priorities connectors 
tao initial implementation supports deterministic realtime applications 
case tao run time scheduler consults table request priorities generated line 
run time tao orb core dispatches threads cpu dispatching mechanism 
extended tao support dynamically scheduling applications statistical qos requirements 
efficient predictable object adapters object adapter component corba architecture associates servant orb incoming client requests servant dispatches appropriate operation servant 
key challenges associated designing object adapter real time orbs determining demultiplex client requests efficiently scalably predictably 
tao corba orb object adapter implements omg portable object adapter specification 
specification defines wide range features including user system supplied object ids persistent transient objects explicit demand activation multiple servant corba object mappings total application control object behavior existence static dsi servants 
demultiplexing dispatching policies tao object adapter instrumental ensuring predictability efficiency 
subsection describes tao object adapter configured perfect hashing active demultiplexing map client requests directly servant operation tuples time 
conventional orb demultiplexing strategies standard giop compliant client request contains identity object operation 
object identified object key octet sequence 
operation represented string 
shown orb corba logical server architecture endsystem perform demultiplexing tasks steps os protocol stack incoming client request multiple times network interface card data link network transport layers user kernel boundary socket dispatches data orb core 
steps orb core uses addressing information client object key locate appropriate servant 
organized hierarchically 
locating contains servant involve multiple demultiplexing steps hierarchy 
step uses operation name find appropriate idl skeleton request buffer operation parameters performs upcall code supplied servant developers 
conventional layered orb endsystem demultiplexing implementation shown generally inappropriate high performance real time applications reasons decreased efficiency layered demultiplexing reduces performance increasing number internal tables searched incoming client requests ascend processing layers orb endsystem 
demultiplexing client requests layers expensive particularly large number operations appear idl interface large number servants managed object adapter 
increased priority inversion non determinism layered demultiplexing cause priority inversions servant level quality service qos information inaccessible lowest level device drivers protocol stacks subsystem orb endsystem 
object adapter may demultiplex packets fifo order arrival 
fifo demultiplexing cause higher priority packets wait indeterminate period time lower priority packets dispatched 
conventional implementations corba incur significant demultiplexing overhead 
instance show conventional orbs spend total server time processing demultiplexing requests 
overhead reduced demultiplexing performed predictably orbs provide uniform scalable qos guarantees real time applications 
tao optimized orb demultiplexing strategies address limitations conventional orbs tao provides demultiplexing strategies shown 
tao optimized corba request demultiplexing strategies optimized demultiplexing strategies include perfect hashing perfect hashing strategy shown step layered demultiplexing strategy 
strategy uses automatically generated perfect hashing function locate servant 
second perfect hashing function locate operation 
primary benefit strategy servant operation lookups require time worst case 
tao uses gnu tool generate perfect hash functions object keys operation names 
perfect hashing scheme applicable keys hashed known priori 
deterministic real time systems avionics mission control systems servants operations configured statically 
applications possible perfect hashing locate servants operations 
active demultiplexing tao provides dynamic demultiplexing strategy called active demultiplexing shown 
strategy client passes object key directly identifies servant operation time worst case 
client obtains object key obtains servant object naming service trading service 
request arrives server orb object adapter uses object key corba request header locate servant associated operation single step 
perfect hashing tao active demultiplexing strategy require object ids known priori 
suitable applications corba objects dynamically 
perfect hashing active demultiplexing demultiplex client requests efficiently predictably 
strategies perform optimally regardless number active connections application level servant implementations operations defined idl interfaces 
presents detailed study request demultiplexing strategies range target objects operations 
tao object adapter uses service configurator pattern select perfect hashing active demultiplexing dynamically orb installation 
strategies improve request demultiplexing performance predictability orb core 
improve efficiency predictability orb core tao uses atm port interconnect controller apic described section directly dispatch client requests associated atm virtual circuits 
vertically integrated optimized orb endsystem architecture reduces demultiplexing latency supports qos request connection basis 
efficient predictable stubs skeletons stubs skeletons components corba architecture responsible transforming typed operation parameters higher level representations lower level repre sentations marshaling vice versa 
marshaling major bottlenecks highperformance communication subsystems due significant amount cpu memory bus resources consume accessing copying data 
key challenges high performance real time orb design efficient presentation layer performs marshaling predictably minimizing costly operations dynamic memory allocation data copying 
tao presentation layer processing performed client side stubs server side skeletons generated automatically highly optimizing idl compiler 
addition reducing potential inconsistencies client stubs server skeletons tao idl compiler supports optimizations reduced dynamic memory tao idl compiler analyzes storage requirements messages exchanged client server 
enables compiler allocate sufficient storage priori avoid repeated run time tests determine sufficient storage available 
addition idl compiler uses run time stack allocate storage parameters 
reduced data copying tao idl compiler analyzes possible perform block copies atomic data types copying individually 
reduces excessive data access minimizes number load store instructions 
reduced function call overhead tao idl compiler selectively optimize small stubs inlining reducing overhead function calls incurred invoking small stubs 
tao idl compiler supports multiple strategies marshaling idl types 
instance tao idl compiler generate compiled interpreted idl stubs skeletons 
design allows applications select interpreted stubs skeletons somewhat slower compact size compiled stubs skeletons faster larger size 
likewise tao cache application data units adus repeatedly 
caching improves performance adus transferred sequentially request chains adu varies slightly transmission 
cases necessary marshal entire request time 
optimization requires real time orb perform flow analysis application code determine request fields cached 
techniques significantly reduce marshaling overhead common case applications strict real time service requirements consider worst case execution 
result flow analysis optimizations described employed certain circumstances applications accept statistical realtime service worst case scenarios sufficient meet deadlines 
efficient predictable memory management conventional orb endsystems suffer excessive dynamic memory management data copying overhead 
instance subsystems orb cores allocate memory buffer incoming client request subsystem typically copies buffer buffer allocated orb core 
addition standard giop iiop code allocates memory hold decoded request parameters 
likewise idl skeletons dynamically allocate delete copies client request parameters upcalls respectively 
general dynamic memory management problematic real time systems 
instance heap fragmentation yield non uniform behavior different message sizes different workloads 
likewise multi threaded orbs locks required protect heap race conditions increase potential priority inversion 
general excessive data copying orb endsystem significantly lower throughput increase latency jitter 
tao designed minimize eliminate data copying multiple layers orb endsystem 
instance tao buffer management system uses apic network interface enhance conventional operating systems zero copy buffer management system 
device level apic interacts directly main system bus devices 
transfer client requests endsystem buffer pools atm virtual circuits additional data copying 
apic buffer pools devices described section configured support early demultiplexing periodic aperiodic client requests memory shared user kernel resident threads 
apis allow client requests sent received network incurring data copying overhead 
buffers preallocated passed various processing stages orb minimizing costly dynamic memory management 
addition tao uses thread specific storage pattern minimize lock contention resulting memory allocation 
tao configured allocate memory thread specific storage 
case orb requires memory retrieved thread specific heap 
locks required orb dynamically allocate memory 
supporting real time scheduling corba section described architectural components tao provide high performance orb endsystem real time corba 
tao architecture realized minimal changes corba 
corba specification address issues related real time scheduling 
section provides depth coverage components tao uses implement real time scheduling service standard corba features 
synopsis application quality service requirements tao orb endsystem designed support various classes quality service qos requirements including applications deterministic statistical real time requirements 
deterministic real time applications avionics mission computing systems meet periodic deadlines 
types applications commonly static scheduling analysis techniques rate monotonic analysis rma rate monotonic scheduling rms 
statistical real time applications teleconferencing video demand tolerate minor fluctuations scheduling reliability guarantees require qos guarantees 
types applications commonly dynamic scheduling techniques earliest deadline edf minimum laxity mlf maximum urgency muf 
deterministic real time systems traditionally amenable understood scheduling analysis techniques 
consequently research efforts initially directed static scheduling deterministic real time systems 
architectural features optimizations studied developed applicable real time systems statistical qos requirements constrained latency multimedia systems telecom call processing 
describes static scheduling service initially developed tao 
follows progression scheduling research dynamic scheduling deterministic statistical real time systems 
responsibilities real time scheduling service subsection examines analysis capabilities scheduling policies provided tao real time scheduling service 
service responsible allocating cpu resources meet qos needs applications share orb endsystem 
real time applications deterministic qos requirements scheduling service guarantees processing requirements met 
real time applications statistical qos requirements scheduling service tries meet system processing requirements desired tolerance trying maximize cpu utilization 
initial design implementation tao real time scheduling service targeted deterministic real time applications require line static scheduling single cpu 
scheduling service useful dynamic distributed real time scheduling 
scheduling service defined corba object implementation idl interface 
design enables scheduling service accessed locally remotely having reimplement clients 
tao real time scheduling service offline line responsibilities line scheduling feasibility analysis tao scheduling service performs line feasibility analysis idl operations register 
analysis results determination sufficient cpu resources perform critical operations discussed section 
request priority assignment request priority relative priority request 
tao dispatch requests order priority 
thread priority priority corresponds thread invoke request 
line analysis scheduling service assigns request priority request assigns request thread priorities 
run time scheduling service provides interface allows tao real time orb endsystem access priorities 
priorities mechanism interfacing local endsystem os dispatcher discussed section 
high level depiction steps involved line line roles tao scheduling service shown 
step scheduling service constructs graphs dependent operations qos information registered application 
qos information stored rt info structures described section 
step identifies threads looking terminal nodes dependency graphs populates info repository step 
step assesses schedulability assigns priorities generating priority tables compilable code step 
steps occur line static schedule request run time representation operation idl interface passed client server 
steps involved line line scheduling configuration process 
priority tables generated step run time step tao orb endsystem 
tao real time scheduling service guarantees rt operations system dispatched sufficient time meet deadlines 
accomplish scheduling service implemented perform various real time scheduling policies 
describes rate monotonic scheduling implementation tao scheduling service 
outline information service requires build execute feasible system wide schedule 
feasible schedule schedulable available system resources words verified operations critical set deadlines 
desirable schedule operations part critical set dynamic behavior system results additional available cpu resources scheduling noncritical operation result operation critical set failing execute deadline 
simplify presentation focus orb scheduling single cpu 
distributed scheduling problem addressed presentation 
outlines approaches investigating tao 
specifying qos requirements tao real time idl schemas invoking operations objects primary collaboration mechanism components oo system 
qos research network os layers addressed key requirements usage characteristics oo middleware 
instance research qos atm networks focused largely policies allocating bandwidth connection basis 
likewise research real time operating systems focused largely avoiding priority inversion non determinism synchronization scheduling mechanisms multi threaded applications 
determining map insights mechanisms produced qos network os layers oo programming model key challenge adding qos support orb middleware :10.1.1.27.1465
subsection describes real time oo programming model tao 
tao supports specification qos requirements operation basis tao real time idl schemas 
overview qos specification tao orb endsystem resources involved satisfying application qos requirements including cpu cycles memory network connections storage devices 
support scheduling performance guarantees real time orbs allow applications specify qos requirements orb subsystem guarantee resource availability 
non distributed deterministic real time systems cpu capacity typically resource 
amount computing time required process client requests determined priori cpu capacity allocated accordingly 
accomplish applications specify cpu capacity requirements tao offline scheduling service 
general scheduling research real time systems consider resources cpu capacity relies online scheduling 
focus specification cpu resource requirements 
tao qos mechanism expressing cpu resource requirements readily extended shared resources network bus bandwidth scheduling analysis capabilities matured 
remainder subsection explains tao supports qos specification purpose cpu scheduling idl operations implement real time operations 
outline real time idl schemas rt operation interface rt info struct 
schemas convey qos information cpu requirements orb operation basis 
believe intuitive qos specification model developers maps directly oo programming paradigm 
rt operation interface operation interface mechanism conveying cpu requirements processing tasks performed application operations tao scheduling service shown corba idl interface remainder scheduler module idl description shown section 
module rt scheduler module timebase defines omg time service 
typedef timebase timet time nanoseconds typedef time quantum typedef long period nanoseconds enum importance defines importance operation scheduler tie breaker scheduling parameters equal 
low importance low importance medium importance high importance high importance typedef long handle rt info assigned application unique identifiers 
struct dependency info long number calls handle rt info notice rt info depend 
typedef sequence dependency info dependency set typedef long os priority typedef long sub priority typedef long preemption priority struct rt info title describes qos rt operation 
description cpu requirements qos entity implementing application operation described information 
application defined string uniquely identifies operation 
string entry point scheduler defined unique identifier 
handle handle execution times 
time worstcase execution time time typical execution time account server data caching 
time cached execution time rate base operations expresses rate 
means completely passive operation executes called 
period period operation importance break ties 
importance importance time slicing background operations 
quantum quantum number internal threads contained operation 
long threads attributes defined scheduler line schedule computed 
operations depend 
dependency set dependencies os por processing events generated rt info 
os priority priority ordering rt info equal priority 
sub priority subpriority queue number rt info 
preemption priority preemption priority shown operation interface contains type definitions key feature described 
rt info struct applications tao specify scheduled resource requirements 
qos information currently provided tao program execution 
case cpu scheduling qos requirements expressed attributes info worst case execution time worst case execution time maximum execution time rt operation requires 
conservative scheduling analysis applications strict real time requirements 
typical execution time typical execution time execution time operation usually requires 
typical execution time may useful scheduling policies statistical real time systems relax conservative worst case execution time assumption 
currently tao deterministic real time scheduling service 
cached execution time operation provide cached result response service requests cached execution time set non zero value 
execution periodic functions worst case execution cost incurred period caching enabled field non zero 
scheduling analysis incorporates caching including term worst case execution time operation period matter times called cached execution time calls 
period period minimum time successive iterations operation 
operation executes active object multiple threads control threads execute 
period indicates operation totally reactive specify period 
reactive operations called response requests clients 
run time scheduler tao need treat reactive operations occurring periodically account execution time 
criticality operation criticality enumeration value ranging lowest criticality low criticality highest criticality high criticality 
certain scheduling strategies implemented scheduling service notably maximum urgency consider criticality primary distinction operations assigning priority 
importance operation importance enumeration value ranging lowest importance low importance highest importance high importance 
scheduling service uses importance tie breaker order execution rt operations data dependencies factors criticality impose ordering 
quantum operations priority may preempted time orb endsystem dispatcher resumed time 
time quantum specified operation maximum time allowed run preemption runnable operations priority 
time sliced scheduling intended provide fair access cpu lowest priority operations 
quantum currently scheduling service 
dependency info array handles rt info instances rt operation directly depends 
dependencies scheduling analysis identify threads system separate dependency graph indicates thread 
addition number times dependent operation called specified accurate execution time calculation 
schemas outlined specify run time execution characteristics object opera tao run time scheduling participants tions tao scheduling service 
information tao validate feasibility schedule allocate orb endsystem network resources process rt operations 
single rt info instance required operation 
overview tao scheduling model tao line scheduling model includes participants shown operation operation unit encapsulates application level processing communication activity 
example utility functions read input print output convert physical units operations 
real time environments operation called module process avoid terms overloaded usage oo os contexts 
rt operation rt operation type operation timing constraints 
rt operation considered operation defined corba idl interface qos information specified terms attributes run time information rt info descriptor 
application level object multiple operations may require multiple rt operation instances distinct class qos specifications 
thread threads units concurrent execution 
thread implemented various threading apis solaris posix thread ada task vxworks task windows nt thread 
threads contained rt operations 
rt operation containing threads active object 
contrast rt operation contains zero threads passive object 
passive objects execute context rt operation borrow calling operation thread control run 
os dispatcher os dispatcher uses request priorities select runnable thread assign cpu 
removes thread cpu thread blocks longer runnable thread preempted higher priority thread 
preemptive dispatching runnable thread priority higher running thread preempt lower priority thread 
higher priority runnable thread dispatched available cpu 
analysis assumes fixed priority os unilaterally change priority thread 
tao currently runs variety platforms including real time operating systems vxworks generalpurpose operating systems real time extensions solaris windows nt 
platforms provide fixed priority real time scheduling 
point view os dispatcher priority thread constant 
fixed priority contrasts operation os schedulers typically age long running processes decreasing priority time 
rt info described section rt info structure specifies operation scheduling characteristics computation time execution period 
run time scheduler run time primary visible scheduling service run time scheduler 
run time scheduler maps client requests particular servant operations priorities understood local os dispatcher 
currently priorities assigned statically prior run time accessed tao orb system time table lookup 
overview tao line scheduling service meet demands statically scheduled deterministic real time systems tao scheduling service uses line scheduling high level goals 
schedulability analysis operations scheduled deadlines missed line scheduling service reports prior runtime 

request priority assignment operations scheduled scheduling service assigns priority request 
mechanism scheduling service uses convey execution order requirements constraints tao orb endsystem dispatcher 
line scheduling service interface key types operations idl interface tao line scheduling service defined module rt scheduler exception duplicate name application trying register task 
exception unknown task rt info handle valid 
exception scheduled application trying obtain scheduling information available 
exception utilization bound exceeded exception insufficient priority levels exception task count mismatch problems computing line scheduling 
typedef sequence rt info rt info set interface scheduler description class holds rt info single application 
handle create string entry point raises duplicate name creates new rt info entry function identifier entry point string fully qualified name function name suggested 
returns handle rt info 
handle lookup string entry point lookups handle entry point 
rt info get handle handle raises unknown task retrieve information rt info 
void set handle handle time time time typical time time cached time period period importance importance quantum quantum long threads raises unknown task set attributes rt info 
notice values may modified priority 
void add dependency handle handle remainder scheduler module idl description shown section 
handle dependency long number calls raises unknown task adds dependency handle void priority handle handle os priority priority sub priority subpriority preemption priority priority raises unknown task scheduled void entry point priority string entry point os priority priority sub priority subpriority preemption priority priority raises unknown task scheduled obtain run time priorities 
void compute scheduling long minimum priority long maximum priority rt info set raises utilization bound exceeded insufficient priority levels task count mismatch computes scheduling priorities returns rt info priorities properly filled 
info cached run time scheduler service dumped file compilation faster static lookup 
shown accessors system configuration data scheduler contains number operations threads system 
destroy operation application calls program exits 
operation allows scheduler release dynamically allocated resources 
general scheduling service interface need viewed application programmers interface need rt info interface described section 
division scheduling service interface application privileged sections shown 
privileged interface common tao services event channel tao real time event service registers operations offline scheduling service application level schedulable operations event channel tao real time orb endsystem accesses interfaces determine client request dispatch priorities 
remainder subsection clarifies operation tao scheduling service focusing assigns request tao scheduling service interfaces priorities invoked stored internal database 
rt operation priority assignments line scheduling service assigns priorities rt operation 
current implementation scheduling service utilizes rate monotonic scheduling policy priorities assigned operation rate 
operation repository priority assigned rules rule info period operation nonzero tao line scheduling service uses information map period thread priority 
instance msec periods may map priority highest msec periods may map priority 
rate monotonic scheduling example higher priorities assigned shorter periods 
rule operation rate requirement rt info period rate requirement implied operation dependencies field stored rt info struct 
rt info struct smallest period fastest rate rt info operation dependencies list treated operation implied rate requirement mapped priority 
priority values computed line scheduling service stored rt info priority field run time scheduler query run time operation 
final responsibility tao line scheduling service verify schedulability system configuration 
validation process provides definitive answer question current system resources lowest priority level operations meet deadlines line scheduling service uses repository info structures shown determine utilization required operation system 
comparing total required utilization priority level known resources assessment schedulability calculated 
tao line scheduling service currently uses rt info attributes operations build static schedule assign priorities steps 
extract rt extract info instances operations system 

identify real time threads determine realtime threads building traversing operation dependency graphs 

determine schedulability priorities traverse dependency graph thread calculate execution time periods 
assess schedulability thread properties assign request priorities 

generate request priority table generate table request priority assignments 
table subsequently integrated tao run time system schedule application level requests 
steps described remainder section 
extract rt scheduling service corba object accessed applications configuration runs 
scheduling service users instantiate rt info instantiation operation system 
configuration run execution application tao tao services provide services information needed static configuration 
interactions scheduling service configuration run shown 
rt info instantiations step compiled linked main program step 
application executed step 
registers rt operation tao currently tao real time event service step directly scheduling service step operations tao 
application notifies tao step turn notifies scheduling service registrations finished 
tao invokes line scheduling process step 
application exits step 
line scheduling rt needed run time 
space saving optimization scheduling steps configuration run conditionally configuration runs 
application destroy operation notify scheduling service program exit release resources holds 
necessary release memory configuration runs order permit repeated runs os platforms vxworks release heap allocated storage program terminates 
consistency application code scheduling service configuration run time interfaces identical 
schedule operation essentially op run time version merely performs checks ensure operations registered number priority values reasonable 
identify real time threads collecting rt info instances scheduling service identifies threads performs schedulability analysis 
thread defined directed acyclic graph rt operations 
rt info instance associated rt operation application developer rt info creation automated information available tao real time event service 
rt contain dependency relationships information importance determines possible run time ordering rt operation invocations 
graph dependencies rt operation generated mechanically algorithm 
build repository info instances task consists steps visit info instance visited add repository visit rt info dependent operation depth add link dependent operation internal scheduling service dependency info array 

find terminal nodes dependent operation graphs noted section identification real time threads involves building traversing operation dependency graphs 
terminal nodes separate dependent operation graphs indicate identify threads 
operation dependency graphs capture data dependency operation calls operation operation needs data operation produces operation depends operation operations execute context single thread operation execute operation terminal nodes dependency graphs delineate threads 

traverse dependent operation graphs identifying terminal nodes dependent operation graphs graphs traversed identify operations compose thread 
traversal starts dependent operation graph terminal node continues dependent operation roots termination 
operation may part thread indicating threads may call operation 
algorithm described applies restrictions arrangement operation dependencies 
thread may identified operation corresponds directly thread having single entry point 
os thread implementations support single entry point unique function called thread started 
restriction imposes additional constraints platforms 
second restriction cycles prohibited dependency relationships 
reasonable interpretation 
cycle dependency graph bound known scheduler number times cycle repeat 
alleviate restriction application absorb dependency graph cycles operation encapsulates 
info reflect bounded number internal dependency graph cycles worst case execution time 
info repository scheduling service builds depicted 
scheduling service srt info repository includes rt info array rt operations depends 
rt operation dependencies depicted blocks arrows dependent operations 
dependency info arrays initialized traversing rt info instances identify threads 
terminal nodes dependent operation graphs identified form starting point thread identification 
info repository passive rt operations internal threads appear terminal nodes dependent operation graphs 
may appear dependent operation graph case worst case typical execution times added corresponding execution times calling thread 
cached execution times may added periodic functions depending result caching enabled operation visited current period 
algorithm identifying real time threads may appear complicate determination operation execution times 
instance specifying thread execution time operation execution time specified 
design instrumental supporting oo programming abstraction provides qos specification enforcement operation basis 
additional information valuable accurately analyze impact object level caching provide finer granularity reusing rt 
addition approach convenient measure execution times operations profiling tools typically provide information directly 
determine schedulability priorities starting terminal nodes identify threads rt info dependency graphs traversed determine thread properties follows traverse graph summing worst case typical execution times traversal 
determine period thread run save minimum period non zero periods visited traversal 
assign priorities depending scheduling strategy higher priority assigned higher criticality higher rate 
thread properties scheduling strategy schedule feasibility assessed 
example rma edf mlf total cpu utilization utilization bound schedule set threads feasible 
muf utilization operations critical set utilization bound schedule feasible schedulability operations outside critical set may may guaranteed 
schedule feasible request priorities assigned scheduling strategy rms requests higher rates assigned higher priorities muf requests higher criticality levels assigned higher priorities 
generate request priority table scheduling service generates table request priority assignments 
thread assigned unique integer identifier 
identifier run time tao orb endsystem index request priority assignment table 
priorities accessed time scheduling analysis performed line 
output scheduling service produced form initialized static table compiled linked executable run time configuration runs 
scheduling service provides interface tao orb endsystem access request priorities contained table 
initial configuration run may contain worst initial estimates rt operation execution times 
likewise may include execution times code simulation manual instruction counts 
successive iterations include actual measured execution times 
accurate input reliable schedulability assessment 
line configuration runs fill dependency info arrays calibrate execution times info instances operations 
initial implementation scheduling service requires input gathered manually 
tao real time event service fills dependency info arrays suppliers 
applications manage realtime activity tao event service require manual collection dependency information 
user scheduling service written thin layer interface calibrating info execution times vx works provides system call timing execution function 
configuration run conditionally compiled code issues system call rt operation stores result info structure 
performance experiments past experience pinpointing performance bottlenecks middleware web servers corba orbs demonstrates efficacy measurement driven research methodology 
section describes results experiment illustrates conventional orbs unsuited applications real time requirements 
investigate real time performance tao detail 
requests 
services object adapter orb core client server atm switch ultra ultra testbed orb analysis measuring orb priority inversion experiment measures degree priority inversion orb 
priority inversion condition occurs execution high priority thread blocked lower priority thread 
priority inversion occurs threads running different priorities share common channels 
hard eliminate priority inversion completely avoided bounded priority inversion desirable 
means amount time higher priority task waiting due lower priority task tight upper bound 
describes approach control priority inversion priority inheritance 
priority inheritance temporarily increases priority lower priority task system detects higher priority task proceed due dependencies lower priority task 
basic priority inheritance protocol run problems formation deadlock chained blocking 
address problems priority ceiling protocols employed 
protocols involve assigning ceiling priority shared resource 
experimental setup experimental testbed depicted 
experiments conducted bay networks atm switch connected dual processor ultrasparc running sunos 
port oc mbs port switch 
ultrasparc contains mhz cpus megabyte cache cpu mbytes ram eni mf atm adaptor card supports megabits sec mbps multi mode fiber 
maximum transmission unit mtu eni atm adaptor bytes 
eni card kbytes board memory 
maximum kbytes allotted atm virtual circuit connection receiving transmitting frames total 
allows switched virtual connections card 
selected popular commercial multi threaded corba implementations priority inversion tests iona mt orbix visibroker 
test high priority client low priority clients 
priority clients determined follows client time constrained way corba operation invocations client requires operation invocation complete predefined amount time referred deadline 
high priority client earlier deadline low priority clients 
operation invocations complete earlier low priority clients 
server uses thread session concurrency model 
model new thread created handle client connection 
server supports notion client priority active object pattern follows 
client requests creation servant object create servant method provided server factory 
client indicates priority argument method 
factory creates new servant object client 
creates new thread called servant thread handle requests client 
priority indicated client calls servant method factory select appropriate priority servant thread 
high priority client server uses highest real time priority available solaris operating system 
low priority client server uses lowest real time priority available solaris 
number low priority clients increases number low priority requests server increases 
load high low priority clients contend high priority requests orbs avoid priority inversion implementing preemptive giop protocol processing satisfy deadline high priority client presence heavy low priority load 
shown results conventional orbs allow unlimited number low priority clients corba re quests perform admission control discussed section 
results mt orbix visibroker plot response times experienced high priority client average response time experienced low priority clients 
increase value figures indicate orbix visibroker exhibit extensive priority inversion 
particular number low priority clients increases latency observed high priority client increases rapidly 
server uses higher real time priority thread handle high priority client requests latency seen higher priority clients affected presence lower priority requests 
increase latency observed high priority client due priority inversion various layers orb endsystems described os subsystem solaris subsystem perform preemptible prioritized protocol processing protocol processing lower priority packets deferred due arrival higher priority packet 
incoming packets processed order arrival priority 
instance low priority request arrives high priority request subsystem process lower priority packet higher priority packet 
amount time spent low priority servant represents priority inversion 
tao addresses problems gigabit real time subsystem discussed section 
orb core orb core implements giop protocol 
sends receives giop packets subsystem responsible processing packets 
current giop mappings iiop communicate request priority request 
orb core unaware priority request 
orb core mt orbix visibroker process giop packets order arrival leads priority inversion 
tao implements protocol discussed section include qos information request 
information perform prioritized protocol processing alleviating priority inversion tao orb core 
object adapter object adapter mt orbix visibroker perform prioritized demultiplexing requests 
addition orb implementations perform layered demultiplexing causes priority inversion performance penalties 
section describes design tao real time object adapter eliminates priority inversion 
results illustrate non deterministic performance seen applications running atop conventional orbs lack real time features 
addition results show priority inversion significant problem orbs unsuitable applications deterministic real time requirements 
normalized latency number low priority clients latency high priority client latency low priority client priority inversion orbix results tao real time event channel illustrate tao addresses priority inversion problems discussed performed experiment similar tao real time event channel 
discussed section event channel currently implements key features tao real time object adapter roa real time dispatching requests events real time scheduling clients servants suppliers consumers 
similar experiments performed orbix visibroker created high priority client low priority clients 
client servant object 
corba clients tests orbix visibroker modeled event suppliers corba servants modeled event consumers 
event channel scheduler assigns appropriate real time priorities servants similar server factory experiments performed orbix visibroker 
experiment measured latency observed channel clients time taken event channel normalized latency latency high priority client latency low priority client number low priority clients priority inversion visibroker events dispatch servant servant handle requests 
depicts latency observed high priority client number low priority clients increase 
results illustrate latency observed high priority client significantly adversely affected number low priority clients increases 
event channel correctly handles priorities clients suffer priority inversion 
results serve proof concept prioritized request processing capabilities tao real time object adapter 
real time middleware emerging field study 
increasing number research efforts focusing integrating qos real time scheduling middleware corba 
section compares tao related qos middleware integration research 
corba related qos research mitre elucidate requirements real time corba systems 
system consisting commercial shelf rtos corba compliant orb real time object oriented database management system development 
similar initial approach provided tao initial static scheduling approach uses rms strategy dynamic deadline monotonic scheduling support designed 
wolfe developing real time corba system navy research development laboratories university rhode island uri 
system supports expression enforcement dynamic normalized latency number low priority clients latency high priority client latency low priority client tao event channel performance timing constraints timed distributed operation invocations 
corresponds tao rt operation 
likewise rt environment structure contains qos parameters similar tao rt info 
difference tao uri approaches express required timing constraints deadlines relative current time rt operations publish resource cpu time requirements 
difference approaches may reflect different time scales seconds versus milliseconds respectively scheduling requirements dynamic versus static initial application targets 
approaches equivalent respect system schedulability analysis 
addition uri supply new corba global priority service analogous tao scheduling service augment corba concurrency event services 
initial implementation uses edf importance level dynamic line scheduling supported global priorities 
global priority associated processing associated inherits priority 
contrast tao initial scheduling service static line uses importance tie breaker analysis requirements data dependencies 
uri tao readily support changing scheduling policy encapsulating corba global priority scheduling services respectively 
quo project bbn defined model com changes qos characteristics applications middleware underlying endsystems network :10.1.1.27.1465
quo model uses concept connection client object define qos characteristics 
characteristics treated class objects 
objects aggregated enable characteristics defined various levels granularity single method invocation method invocations group objects similar combinations 
quo model uses qos definition languages describe qos characteristics various objects expected usage patterns structural details objects resource availability 
quo architecture differs real time qos provisioning tao quo provide hard real time guarantees orb endsystem cpu scheduling 
furthermore quo programming model involves specifications addition omg idl separation concerns advocated aspect oriented programming aop 
believe aop paradigm powerful proliferation definition languages may overly complex common application 
tao programming model focuses operation info qos specifiers expressed standard omg idl integrated seamlessly existing corba programming model 
realize project ucsb supports soft real time resource management corba distributed systems 
realize aims reduce difficulty developing real time systems permit distributed real time programs programmed tested debugged easily single sequential programs 
key innovations realize integration distributed real time scheduling fault tolerance faulttolerance totally ordered multicasting multicasting distributed real time scheduling context object oriented programming existing standard operating systems 
realize hosted top tao 
project defines open real time corba scheme provides qos guarantees run time scheduling flexibility 
explicitly extends tao line scheduling model provide line scheduling 
addition allows clients added removed dynamically admission test run time 
project progress empirical results available 
non corba related qos research project defines set communication middleware services support fault tolerant guarantees real time distributed applications 
provides real time communication services kernel open group mk microkernel 
infrastructure provides foundation constructing higher level real time middleware services 
tao differs real time infrastructure features tao integrated orb core 
addition tao implements omg corba standard providing hooks necessary integrate underlying real time subsystem os 
real time services provided communication system utilized tao orb core support vertically horizontally integrated real time system 
rajkumar carnegie mellon university software engineering institute developed real time publisher subscriber model 
functionally similar tao real time event service 
instance uses real time threads prevent priority inversion communication framework 
cmu model utilize qos specifications publishers event suppliers subscribers event consumers 
scheduling assignment request priorities addressed cmu model 
contrast tao scheduling service real time event service utilize qos parameters suppliers consumers assure resource access priorities 
interesting aspect cmu publisher subscriber model separation priorities subscription data transfer 
handling activities different threads possibly different priorities impact line scheduling real time processing minimized 
concluding remarks advances distributed object computing technology occurring time global competition motivating need increased software productivity quality 
distributed object computing promising paradigm control costs open systems client server computing 
likewise oo design programming widely touted effective means reduce software cost improve software quality reuse extensibility modularity 
meeting qos requirements high performance real time applications requires oo design programming techniques 
requires integrated architecture delivers qos guarantees multiple levels distributed system 
tao orb endsystem described addresses need policies mechanisms span network adapters operating systems communication protocols orb middleware 
believe real time orbs promising 
real time system development strategies migrate mainstream systems achieve lower development cost faster time market 
ob served real time embedded software development projects lagged terms design development methodologies languages decades 
projects extremely costly evolve maintain 
specialized adapted meet new market opportunities 
flexibility adaptability offered corba attractive real time systems 
realtime challenges overcome progress reported indicates real time corba compelling 
solutions challenges sufficiently complex general worth re applying projects domains stringent qos requirements 
source code tao ace freely available www cs wustl edu schmidt tao html 
release contains real time orb benchmarking test suite described section 
tao currently deployed boeing st louis mo develop operation flight programs generation avionics systems 
source code tao orb available www cs wustl edu schmidt tao html 
frank buschmann extensive comments tim harrison rajeev irfan pyarali help earlier drafts 
addition gratefully acknowledge support direction boeing principal investigator bryan 
object management group common object request broker architecture specification ed feb 
box essential com 
addison wesley reading ma 
wollrath waldo distributed object model java system usenix computing systems vol 
november december 
schmidt harrison object oriented components high speed network programming proceedings conference object oriented technologies systems monterey ca usenix june 
corba integrating diverse applications distributed heterogeneous environments ieee communications magazine vol 
february 
eide frei ford lepreau lindstrom flick flexible optimizing idl compiler proceedings acm sigplan conference programming language design implementation pldi las vegas nv acm june 
object management group corba messaging specification omg document orbos ed may 
henning binding migration scalability corba communications acm special issue corba vol 
oct 
schmidt family design patterns applicationlevel gateways theory practice object systems special issue patterns pattern languages vol 

harrison levine schmidt design performance real time corba event service proceedings oopsla atlanta ga acm october 
pyarali harrison schmidt design performance object oriented framework high performance electronic medical imaging usenix computing systems vol 
november december 
schmidt design performance corba audio video streaming service proceedings hawaiian international conference system sciences jan 
rajkumar sha lehoczky real time synchronization protocols multiprocessors proceedings real time systems symposium huntsville alabama december 
khanna realtime scheduling sunos proceedings usenix winter conference pp 
usenix association 
fay wolfe black real time method invocations distributed environments tech 
rep university rhode island department computer science statistics 
gokhale schmidt measuring optimizing corba latency scalability high speed networks transactions computing vol 

schmidt levine orb endsystem architecture statically scheduled real time applications proceedings workshop middleware real time systems services san francisco ca ieee december 
gokhale schmidt principles optimizing corba internet inter orb protocol performance hawaiian international conference system sciences january 
gokhale schmidt performance corba dynamic invocation interface dynamic skeleton interface high speed atm networks proceedings globecom london england pp 
ieee november 
gokhale schmidt evaluating performance demultiplexing strategies real time corba proceedings globecom phoenix az ieee november 
gokhale schmidt measuring performance communication middleware high speed networks proceedings sigcomm stanford ca pp 
acm august 
schmidt gokhale harrison high performance endsystem architecture real time corba ieee communications magazine vol 
february 
schmidt levine design performance real time object request brokers computer communications vol 
pp 
apr 
schmidt ace object oriented framework developing distributed applications proceedings usenix technical conference cambridge massachusetts usenix association april 
schmidt applying patterns develop extensible orb middleware ieee communications magazine appear 
gokhale schmidt design principles op high performance orbs oopsla conference poster session atlanta georgia acm october 
cranor design universal continuous media proceedings th international workshop network operating systems support digital audio video nossdav durham new hampshire pp 
apr 
gopalakrishnan bringing real time scheduling theory practice closer multimedia computing sigmetrics conference philadelphia pa acm may 
jerome cox apic approach high performance network interface design protected dma techniques proceedings info com kobe japan ieee april 
gopalakrishnan efficient user space protocol implementations qos guarantees realtime upcalls tech 
rep washington university department computer science march 
automating performance optimization heuristic analysis formal specification proceedings joint conference formal description techniques forte protocol specification testing verification kaiserslautern 
druschel abbott peterson network subsystem design ieee network special issue system support high speed networks vol 
july 
stankovic misconceptions real time computing ieee computer vol 
pp 
oct 
braden resource reservation protocol rsvp version functional specification internet draft may 
ftp ietf org internet drafts draft ietf rsvp spec txt 
ritchie stream input output system bell labs technical journal vol 
pp 
oct 
liu layland scheduling algorithms multiprogramming hard real time environment jacm vol 
pp 
january 
klein pollak harbour practitioner handbook real time analysis guide rate monotonic analysis real time systems 
norwell massachusetts kluwer academic publishers 
information technology portable operating system interface posix part system application program interface api language 
melliar smith moser soft real time resource management corba distributed systems proceedings workshop middleware real time systems services san francisco ca ieee december 
zinky bakken schantz architectural support quality service corba objects theory practice object systems vol :10.1.1.27.1465

object management group realtime corba request proposals omg document orbos ed september 
schmidt evaluating architectures multi threaded corba object request brokers communications acm special issue corba vol 
oct 
schmidt reactor object behavioral pattern concurrent event demultiplexing event handler dispatching pattern languages program design coplien schmidt eds pp 
reading ma addison wesley 
object management group realtime corba joint submission omg document orbos ed december 
schmidt flores gokhale alleviating priority inversion non determinism realtime corba orb core architectures proceedings ieee real time technology applications symposium denver ieee june 
schmidt acceptor connector design patterns initializing communication services pattern languages program design martin buschmann riehle eds reading ma addison wesley :10.1.1.40.8396
levine gill schmidt dynamic scheduling strategies avionics mission computing proceedings th ieee aiaa digital avionics systems conference nov 
schmidt turner strategy integrating ip atm proceedings symposium communications architectures protocols sigcomm acm september 
gamma helm johnson vlissides design patterns elements reusable object oriented software 
reading ma addison wesley 
stewart khosla real time scheduling sensor control systems real time programming ramamritham eds ny pergamon press 
jain schmidt service configurator pattern dynamic configuration services proceedings conference object oriented technologies systems usenix june 
schmidt active object object behavioral pattern concurrent programming pattern languages program design coplien vlissides eds reading ma addison wesley 
schmidt object adapters concepts terminology report vol 
november december 
schmidt portable object adapter transient persistent corba objects report vol 
april 
tennenhouse layered multiplexing considered harmful proceedings international workshop high speed networks may 
schmidt perfect hash function generator proceedings conference san francisco california pp 
usenix april 
clark tennenhouse architectural considerations new generation protocols proceedings symposium communications architectures protocols sigcomm philadelphia pa pp 
acm sept 

choi cytron ferrante automatic construction sparse data flow evaluation graphs conference record eighteenth annual ace symposium principles programming languages acm january 
cytron ferrante rosen wegman zadeck efficiently computing static single assignment form control dependence graph acm transactions programming languages systems acm october 
schmidt harrison thread specific storage object behavioral pattern accessing thread state efficiently pattern languages programming conference washington university technical report wucs september 
ramamritham stankovic zhao distributed scheduling tasks deadlines resource requirements ieee transactions computers vol 
pp 
aug 
mckusick bostic karels quarterman design implementation bsd operating system 
addison wesley 
hu pyarali schmidt measuring impact event dispatching concurrency models web server performance high speed networks proceedings global internet conference ieee november 
sha rajkumar lehoczky priority inheritance protocols approach real time synchronization ieee transactions computers vol 
september 
schafer wolfe real time extensions common object request broker architecture proceedings object oriented programming systems languages applications oopsla workshop experiences corba acm oct 
statement extend program project replacement phase ii feb 
submitted omg response rfi orbos 
cooper johnston wolfe real time corba development mitre tri pacific uri proceedings workshop middleware real time systems services san francisco ca ieee december 
wolfe johnston real time corba proceedings third ieee real time technology applications symposium montr canada june 
kiczales aspect oriented programming proceedings th european conference object oriented programming june 
feng 
liu providing open real time corba proceedings workshop middleware real time systems services san francisco ca ieee december 
shin structuring communication software quality service guarantees ieee transactions software engineering vol 
pp 
oct 
abdelzaher dawson feng jahanian johnson shaikh shin wang zou middleware suite proceedings workshop middleware real time systems services san francisco ca ieee december 
rajkumar sha real time publisher subscriber inter process communication model distributed real time systems design implementation ieee real time technology applications symposium may 
stewart schmitz khosla implementing real time robotic systems chimera ii proceedings ieee international conference robotics automation oh 
gokhale schmidt techniques optimizing corba middleware distributed embedded systems proceedings infocom mar 
gokhale pyarali ryan schmidt wang design considerations performance optimizations real time orbs proceedings conference object oriented technologies systems san diego ca usenix may 
gill levine schmidt evaluating strategies real time corba dynamic scheduling international journal time critical computing systems special issue real time middleware appear 
schmidt suda object oriented framework dynamically configuring extensible distributed communication systems iee bcs distributed systems engineering journal special issue configurable distributed systems vol 
pp 
december 
unix system network programming 
reading ma addison wesley 
ramamritham shen gonz les sen windows nt real time applications experimental observations recommendations proceedings fourth ieee real time technology applications symposium denver ieee june 
adapting scheduling strategies support tao tao real time scheduling service uses scheduler implement scheduling strategies including rate monotonic scheduling rms earliest deadline edf minimum laxity mlf maximum urgency muf 
strategies carries certain benefits limitations body section addresses 
rate monotonic analysis scheduling rms higher priorities assigned statically threads faster rates 
priorities fixed modified operating system static changed application 
operating system support preemption highest priority runnable thread running available processor 
rate monotonic analysis rma validate rms schedules 
great deal research rma done software engineering institute carnegie mellon university 
rma consists analytical methods algorithms evaluating timing behavior 
note systems need scheduled rms analyzed rma selecting rma tao limited rms 
rma provides test schedulability guaranteed system 
context deterministic real time systems schedulability ability operations system meet deadlines 
selected rms policy tao scheduling service provides optimum schedule straightforward apply relatively simple analyze 
tao instantiation rma starts strict rules progressively relaxes restrictions reaches form 
restrictions allow application rma operations independent operations periodic interrupts context switching time negligible single operation priority level single cpu operation periods related harmonically operation deadlines ends periods 
restrictions knowledge computation time period operation schedulability test simply comparison sum utilizations operations program 
sum utilizations equal operation set schedulable 
restrictions relaxed tao deterministic real time environments follows interdependent operations operations independent scheduling analysis conservatively consider time thread may blocked lower priority due synchronization 
sufficient analysis system participants behaviors blocking eliminated explicit specification dependencies resultant execution ordering 
practice explicit dependency specification may feasible deterministic real time systems analyzed statically 
systems thread activity effectively determined prior run time 
rt info supports type line analysis 
statistical real time systems dynamically changing resource requirements operation interdependencies harder analyze 
instance potential priority inversion threads different priorities synchronize 
achieve optimum resource utilization best prevent situations 
occur analysis conservatively consider time thread may blocked lower priority due synchronization 
aperiodic operations aperiodic operations modeled periodic operations assuming worst fastest possible rate operations execute 
interrupts interrupts handled analysis execution times maximum possible rate 
usual drawback analysis conservative 
assumes interrupts occur maximum possible rate necessary assumed rate usually realized practice 
result reduced effective cpu utilization cpu reserved interrupts may occur 
context switching context switching time accounted charging switch execution time thread swapped 
multiple operation priority levels tao real time scheduling service generates operation priorities output 
assigns os specific priority thread application rms 
operation thread assigned priority thread 
operations thread highest priority assigned 
rma applied multiple priority levels preemption supported tao object adapter 
preemption immediate accounted analysis example analysis 
multiple cpus currently rma analysis assumes tao object adapter dispatches client requests single cpu 
scheduled cpu isolation 
step scheduling multiple cpus allocate threads manually separate cpus schedule cpu separately considering interprocessor communication interrupts 
refinement analysis take actual priority interprocessor events account 
operation periods related harmonically operation periods related harmonically utilization bound maximum utilization operation set guaranteed schedulable number operations set 
function approaches grows large 
operation periods related harmonically hz hz hz utilization bound 
intuitively operation periods fit largest operation period 
applications harmonically related operation periods clearly advantageous harmonic relations maximize cpu utilization 
operation deadlines ends periods operation deadlines modeled adjusting utilization bound 
purely dynamic scheduling strategies section reviews known purely dynamic scheduling strategies earliest deadline edf minimum laxity mlf 
strategies illustrated discussed 
addition depicts hybrid static dynamic maximum urgency muf scheduling strategy discussed section 
earliest deadline edf edf dynamic scheduling strategy orders dispatches operations time deadline shown 
operation executions closer deadlines dispatched dispatch particular execution operation 
dynamic scheduling strategies distant deadlines 
edf scheduling strategy invoked dispatch operation requested 
new dispatch may may preempt currently executing operation depending mapping priority components thread priorities discussed section 
key limitation edf operation earliest deadline dispatched sufficient time remaining complete execution prior deadline 
fact operation meet deadline detected deadline passed 
operation dispatched complete execution prior deadline operation consumes cpu time allocated operations 
result operation useful application prior deadline entire time consumed operation essentially wasted 
minimum laxity mlf mlf refines edf strategy account operation execution time 
dispatches operation laxity shown 
laxity defined time deadline minus remaining execution time 
mlf possible detect operation meet deadline prior deadline 
occurs scheduler reevaluate operation allocating cpu remaining computation time 
example strategy simply drop operation laxity sufficient meet deadline 
strategy may decrease chance subsequent operations deadlines especially system overloaded transiently 
evaluation edf mlf advantages scheduling perspective main advantage edf mlf overcome utilization limitations rms 
particular utilization phasing penalty described section 
occur rms factor edf mlf prioritize operations dynamic run time characteristics 
edf mlf handle harmonic non harmonic periods comparably 
respond flexibly invocation invocation variations resource requirements allowing cpu time unused operation reallocated operations 
produce schedules optimal terms cpu utilization 
addition edf mlf dispatch operations single static priority level need prioritize operations rate 
disadvantages performance perspective disadvantage purely dynamic scheduling approaches mlf edf scheduling strategies require higher overhead evaluate run time 
addition purely dynamic scheduling strategies offer control operations deadlines schedulable bound exceeded 
operations added schedule achieve higher utilization margin safety operations decreases 
risk missing deadline increases operation system overloaded 
maximum urgency maximum urgency muf scheduling strategy supports deterministic rigor static rms scheduling approach flexibility dynamic scheduling approaches edf mlf 
muf default scheduler chimera real time operating system rtos 
tao supports variant muf corba scheduling service framework discussed section muf assign static dynamic priority components 
contrast rms assigns priority components statically edf mlf assign priority components dynamically 
hybrid priority assignment muf overcomes drawbacks individual scheduling strategies combining techniques described criticality muf operations higher criticality assigned higher static priority levels 
assigning static priorities criticality prevents operations critical application preempted non critical operations 
ordering operations application defined criticality reflects subtle fundamental shift notion priority assignment 
particular rms edf mlf exhibit rigid mapping empirical operation characteristics single priority value 
offer little control operations deadlines overload conditions 
contrast muf gives applications ability distinguish operations arbitrarily 
muf allows control operations deadlines 
protect critical subset entire set operations 
fundamental shift notion priority assignment leads generalization scheduling analysis techniques discussed section appendix 
dynamic subpriority operation dynamic subpriority evaluated compared operation dynamic subpriority 
example operation dynamic subpriority evaluated enqueued dequeued dynamically ordered dispatching queue 
instant evaluation dynamic subpriority muf function laxity operation 
example simple dynamic subpriority function inverse operation laxity 
operations smallest positive highest dynamic followed operations higher positive followed operations negative followed operations negative closer zero 
assigning dynamic subpriority way provides consistent ordering operations move pending late dispatching queues described 
assigning dynamic laxity muf offers higher utilization cpu statically scheduled strategies 
muf allows deadline failures detected occur operation meet deadline preempted higher criticality operation 
muf apply various types error handling policies deadlines missed 
example operation negative laxity prior dispatched demoted priority queue allowing operations meet deadlines dispatched 
static subpriority muf static subpriority static application specific optional priority 
order dispatches operations criticality dynamic subpriority 
static subpriority lower precedence criticality dynamic subpriority 
assigning unique static subpriority operation criticality ensures total dispatching ordering operations run time operation laxity values having criticality 
total dispatching ordering ensures arrival pattern operation requests dispatching avoid division zero errors operation laxity range assigned negative dynamic subpriority smallest positive floating point number distinguishable zero 
laxity operation reaches considered missed deadline 
order 
turn helps improve reliability testability system 
variant muf tao scheduling service enforces complete dispatching ordering providing field info corba operation qos descriptor shown section 
tao scheduling service topological ordering operations assign unique static subpriority operation criticality level 
incidentally original definition muf uses terms dynamic priority user priority term dynamic subpriority static subpriority tao scheduling service 
selected different terminology indicate subordination static priority 
terms interchangeable referring muf 
strictly necessary know operations advance order schedule canonical definitions edf mlf 
real time applications worked exhibit useful property 
operations known advance line analysis schedule feasibility possible rms edf mlf muf 
output scheduling strategies tao schedule 
schedule defines set operation dispatching priorities dispatching minimum critical dispatching priority 
goal appendix feasibility analysis technique schedules independent specific strategy produce particular schedule 
analysis technique establish invariants hold urgency dispatching priority mappings 
doing line schedule feasibility analysis decouples application details particular scheduling strategy allows alternative strategies compared application remainder appendix organized follows 
section discusses notion schedule frame size 
section describes measure schedule cpu utilization 
section describes generalized schedule feasibility analysis technique schedule utilization frame size respective priorities operations 
frame size frame size schedule minimum time contain possible phasing relationships operations 
frame size provides invariant largest time operation executions fit 
assumes course scheduling parameters rates worst case execution times specified applications exceeded operations run time 
periods operations integral multiples hz hz hz hz operations said harmonically related 
harmonically related operations completely nested phasing relationships 
arrival pattern subsequently shorter period fits exactly longer period 
harmonically related operations frame size simply longest operation period 
operations harmonically related come phase 
exhibit nesting property 
pattern arrivals repeats periods come back phasing relationships 
observation leads invariant covers harmonic non harmonic cases 
frame size cases product non duplicated factors operation periods 
non harmonic cases calculate value starting frame size time unit iterating set unique operation periods 
unique period possibly expand frame size multiplying previous frame size greatest common divisor previous frame size operation period 
harmonic cases operation periods factors longest operation period 
longest operation period frame size 
depicts relationships operation periods frame size harmonic non harmonic cases 
harmonically related operation rates frame size examples harmonic non harmonic cases smaller periods fit evenly largest period 
largest operation period frame size 
related rates frame size larger largest operation period multiple operation periods 
utilization total cpu utilization sum actual execution times operation dispatches schedule frame size divided frame size 
tao scheduling service calculates maximum total utilization schedule summing operations fraction operation period consumed worst case execution time formula worst case execution time period 
addition total utilization tao scheduling service calculates cpu utilization set critical operations 
indicates percentage time cpu allocated operations completion prior deadline enforced 
operations assigned dispatching priority greater equal minimum critical priority bound considered critical set 
rms edf mlf scheduling strategies entire schedule considered critical critical set utilization total utilization 
total utilization exceeds schedulable bound tao scheduling service stores priority level previous exceeded schedulable bound 
previous priority level called minimum guaranteed priority level 
operations having dispatching priority greater equal minimum guaranteed priority level assured meeting deadlines 
contrast operations having dispatching priority immediately minimum guaranteed priority level may execute prior deadlines assured doing 
total utilization exceed schedulable bound lowest priority level system minimum guaranteed priority level operations assured meeting deadlines 
operation schedule feasibility may may possible achieve feasible schedule utilizes cpu 
achieving utilization depends phasing relationships operations schedule scheduling strategy 
maximum percentage cpu utilized called schedulable bound 
schedulable bound function scheduling strategy cases schedule 
schedule feasible operations critical set assured meeting deadlines 
critical set identified minimum critical priority 
operations having dispatching priority greater equal minimum critical priority critical set 
schedulability operation critical set depends worst case operation arrival pattern called critical instant 
critical instant operation occurs delay arrival completion maximal 
preemptive urgency dispatching model described section critical instant operation occurs arrives simultaneously operations 
dispatching models critical instant operation differs slightly 
occurs operation arrives immediately operation cause greatest additional preemption delay dispatched 
occurs operation arrives simultaneously operations causing additional preemption delay 
operation schedulable critical instant assured schedulability arrival pattern operations 
key research challenge assessing schedule feasibility determining operation sufficient time complete execution prior deadline 
deadline operation critical instant falls exactly critical instant plus period 
operation able complete execution period time preferentially dispatched operations 
operations higher dispatching priority current operation dispatched preferentially 
operations dispatching priority deadlines prior deadline current operation considered dispatched preferentially 
goal assessing schedule feasibility line way independent particular strategy correctly determines operation meet deadline motivates analysis 
tao scheduling service performs analysis operation line 
call operation analysis performed current operation 
number arrivals period current operation operation having higher dispatching priority current operation respective periods current operation higher priority operation 
time consumed higher priority operation period current operation function returns minimum values computation time dispatch higher priority operation 
similarly number deadlines operation having dispatching priority current operation period operation having dispatching priority current operation 
time consumed priority operation period current operation computation time priority operation 
illustrates various possible relationships periods operations priority levels 
higher priority operations lower priority operations schedulability current operation choosing fourth operation period current operation number arrivals higher priority operations expected number dead lines operations having priority level expected having established time consumed operation having higher dispatching priority current operation time consumed operation having dispatching priority current operation possible state invariant hold operations having dispatching priority schedulable set operations schedule 
func tion simply returns priority assigned operation worst case preemption delay operation operation suffers preemption delay arrives operation dispatching priority level deadline operation period executing 
operations deadlines operation period counted anyway impose additional delay operation arrive executing 
worst case preemption delay operation longest execution time operation longer period operations zero 
current operation having dispatching priority schedulable hold 
deadlines operations having dispatching priority higher including deadline current operation plus plus time scheduled higher priority operations arrive deadline period current operations schedulable period current operation 
invariant evaluated decreasing dispatching priority level schedule highest lowest 
lowest dispatching priority level invariant holds identified minimum priority schedulability operations guaranteed known minimum guaranteed priority 
summary schedule feasibility analysis technique appendix establishes uses invariants hold urgency dispatching priority mappings 
gives applications ability examine different scheduling strategies line discard produce feasible schedules particular operation characteristics 
decouples applications details particular scheduling strategy changes strategies require changes operation characteristics 
design tao scheduling service tao scheduling service provides real time corba applications flexibility specify different scheduling strategies specific qos requirements available os features 
flexibility allows corba applications extend set available scheduling strategies impacting strategies applications 
shields application developers unnecessary details scheduling strategies 
addition tao scheduling service provides common framework compare existing scheduling strategies empirically evaluate new strategies 
section outlines design goals architecture tao scheduling service framework 
briefly describing tao section section discusses design goals tao scheduling service 
section offers overview architecture operation 
section describes design forces motivate tao flexible scheduling service architecture 
section discusses resulting architecture detail 
overview tao tao high performance real time orb endsystem targeted applications deterministic statistical qos requirements best effort requirements 
tao orb endsystem contains network interface os communication protocol corba compliant middleware components features shown 
tao supports components tao real time orb endsystem standard omg corba model enhancements designed overcome shortcomings conventional orbs high performance real time applications real time idl stubs skeletons tao idl stubs skeletons efficiently marshal operation parameters respectively 
addition tao real time idl stubs skeletons extend omg idl specifications ensure application timing requirements specified enforced 
real time object adapter object adapter associates servants orb incoming requests servants 
tao real time object adapter uses perfect hashing active demultiplexing optimizations dispatch servant operations constant time regardless number active connections servants operations defined idl interfaces 
orb run time scheduler real time scheduler maps application qos requirements include bounding latency meeting periodic scheduling deadlines orb endsystem network resources orb endsystem network resources include cpu memory network connections storage devices 
tao run time scheduler sup ports static dynamic real time scheduling strategies 
real time orb core orb core delivers client requests object adapter returns responses clients 
tao real time orb core uses multi threaded preemptive priority connection concurrency architecture provide efficient predictable corba iiop protocol engine 
real time subsystem tao real time subsystem extends support corba os 
tao subsystem assigns priorities real time threads schedulability application components orb endsystem resources enforced 
tao runs efficiently relatively predictably conventional subsystems lack advanced qos features 
high speed network interface core tao subsystem daisy chained network interface consisting atm port interconnect controller apic chips 
apic designed sustain aggregate bidirectional data rate gbps 
addition tao runs conventional real time interconnects vme multi processor shared memory environments internet protocols tcp ip 
tao developed atop lower level middleware called ace implements core concurrency distribution patterns communication software 
ace provides reusable wrapper facades framework components support qos requirements high performance real time applications 
ace runs wide range os platforms including win versions unix real time operating systems sun chorus vx works 
design goals tao scheduling service alleviate limitations existing scheduling strategies described section research corba real time scheduling focuses enabling applications maximize total utilization preserve scheduling guarantees critical operations set critical operations identified adapt flexibly different application platform characteristics 
goals illustrated summarized goal 
higher utilization upper pair timelines demonstrates research goal higher utilization 
timeline shows case critical operation execution fact worst case execution time 
dynamic scheduling additional non critical operation dispatched achieving higher resource utilization 
critical non critical scheduled high utilization vs isolate missed deadlines time axis vs adaptation deadline application characteristics application second application design goals tao dynamic scheduling service goal 
preserving scheduling guarantees lower pair timelines demonstrates second research goal preserving scheduling guarantees critical operations 
timeline depicts statically scheduled timeline worst case execution time critical operation scheduled 
lower timeline priority traditional scheduling parameters rate laxity 
upper timeline criticality included 
timelines depict schedule overrun 
criticality considered non critical operations deadlines 
goal 
adaptive scheduling sets operation blocks bottom demonstrate third research goal providing applications flexibility adapt varying application requirements platform features 
example second applications operations 
application considers operations critical second application considers operations critical 
allowing applications select operations critical possible provide scheduling behavior appropriate application individual requirements 
goals motivate design tao scheduling service framework described section 
real time systems tao applied possible identify core set operations execution deadlines critical integrity system 
tao scheduling service designed ensure critical corba operations meet deadlines total utilization exceeds schedulable bound 
possible ensure deadlines met adding operations schedule increase total cpu utilization increase risk missing deadlines 
risk increase operations execution prior deadline critical integrity system 
way risk system minimized loaded higher utilization 
tao scheduling service framework tao scheduling service framework designed support variety scheduling strategies including rms edf mlf muf 
flexibility achieved tao strategy design pattern 
pattern encapsulates family scheduling algorithms fixed interface 
tao scheduling service scheduling strategies interchangeable varied independently 
architecture behavior tao scheduling service illustrated 
architecture evolved earlier corba scheduling service supported purely static rate monotonic scheduling 
steps involved configuring processing requests described 
steps typically occur line schedule configuration process steps occur line hybrid nature tao scheduling architecture 
step corba application specifies qos information passes tao scheduling service implemented corba object implements idl interface 
application specifies set values rt characteristics schedulable operations rt operations 
addition application specifies invocation dependencies operations 
step configuration time occur offline line application passes qos information tao scheduling service input interface 
tao scheduling service stores qos information repository info descriptors 
tao scheduling service input interface described section 
tao scheduling service constructs operation dependency graphs information registered application 
scheduling service identifies threads execution examining terminal nodes dependency graphs 
nodes outgoing edges incoming edges dependency graph called consumers 
consumers dispatched nodes depend 
nodes incoming edges outgoing edges called suppliers 
suppliers correspond distinct threads execution system 
nodes incoming outgoing edges fulfill roles 
step step tao scheduling service assesses schedulability 
set operations considered schedulable operations critical set guaranteed meet deadlines 
schedulability assessed cpu utilization operations minimum critical priority equal schedulable bound 
step tao scheduling service assigns static priorities operations 
values assigned specific strategy configure scheduling service 
example tao scheduling service configured muf strategy static priority assigned operation criticality 
likewise static subpriority assigned operation importance dependencies 
step specific strategy configure tao scheduling service divides dispatching priority dispatching subpriority components statically dynamically assigned portions 
static priority static subpriority values assign static portions dispatching priority dispatching subpriority operations 
dispatching priorities reside tao rt info repository 
step assigned dispatching priorities accordance specific strategy configure line scheduling service number types dispatching queues needed dispatch generated schedule assigned 
example scheduling service configured mlf strategy single queue uses laxity prioritization 
configuration information resides info repository 
step run time start configuration information info repository scheduling service run time scheduler component collocated orb endsystem 
orb uses run time scheduler retrieve thread priority queue dispatches operations type dispatching prioritization queue 
scheduling service run time component provides information orb output interface described section 
step step orb configures dispatching modules subsystem orb core event service 
information scheduling service output interface create correct number types queues associate correct thread priorities service queues 
configuration process described section 
ti ti ti processing steps tao dynamic scheduling service architecture step operation request arrives client run time appropriate dispatching module identify dispatching queue request belongs initialize request dispatching subpriority 
accomplish dispatching module queries tao scheduling service output interface described section 
run time scheduler component tao scheduling service retrieves static portions dispatching priority dispatching subpriority info repository 
supplies dispatching priority dispatching subpriority dispatching module 
step dispatching queue operation request placed configured dynamic queue step dynamic portions request dispatching subpriority possibly dispatching priority assigned 
queue enqueues request 
queue updates dynamic portions necessary operations enqueued dequeued 
remainder section describes tao scheduling service framework detail 
section motivates tao allows applications vary scheduling strategy section shows tao framework design achieves flexibility 
motivation tao scheduling architecture flexibility architecture tao scheduling service motivated goals 
shield application developers unnecessary implementation details alternative scheduling strategies improves system reliability maintainability described 

decouple strategy priority assignment dispatching model varied independently increases system flexibility adapt varying application requirements platform features 
tao scheduling strategy framework designed minimize unnecessary constraints values application developers specify input interface described section 
instance non recommended way implement rms edf mlf strategies tao scheduling service framework implement variants muf strategy 
done manipulating values operation characteristics 
approach tightly couple applications muf scheduling strategy strategy emulated 
significant drawback tightly coupling behavior scheduling service characteristics application operations 
particular value operation characteristic application changes developers remember manually modify operation characteristics specified scheduling service order preserve mapping 
general prefer shield application developers unnecessary details 
achieve encapsulation tao scheduling service allows applications specify entire set possible operation characteristics input interface 
scheduling strategies implemented tao mappings input output interfaces entirely encapsulated strategies 
need require unnecessary manipulation input values 
decouples operation characteristics need consider 
additional decoupling scheduling strategies beneficial 
scheduling strategy tao specifies distinct levels mapping input interface output interface 
urgency assignment level assigns urgency components static priority dynamic subpriority static subpriority operation characteristics specified input interface selected scheduling strategy muf mlf edf rms 

dispatching sub priority assignment second level assigns dispatching priority dispatching subpriority output interface urgency components assigned level 
decoupling strategy urgency assignment assignment urgency dispatching priority dispatching subpriority tao allows scheduling strategy underlying dispatching model vary independently 
decoupling allows scheduling strategy os supports preemptive non preemptive threading models minor modification scheduling strategy 
addition facilitates comparison scheduling strategies range dispatching models fully preemptive urgency preemptive priority band entirely non preemptive 
models discussed section 
enhancing tao scheduling strategy flexibility qos requirements applications hardware software features platforms networks hosted vary significantly 
instance scheduling strategy ideal telecommunication call processing may poorly suited avionics mission computing 
tao scheduling service framework designed allow applications vary scheduling strategies 
tao supports flexibility decoupling fixed portion scheduling framework variable portion follows fixed interfaces fixed portion tao scheduling service framework defined interfaces input interface discussed section input interface consists operations shown 
application operations manipulate qos characteristics expressed tao srt info descriptors steps 
output interface discussed section output interface consists operations shown 
operation returns dispatching module configuration information step 
returns dispatching priority dispatching subpriority components assigned operation step 
section describes tao dispatching modules information tao scheduling service output interface configure manage dispatching queues dispatch operations generated schedule 
variable mappings variable portion tao scheduling service framework implemented distinct mappings input mapping input mapping assigns operations desired scheduling strategy 
section describes strategies implemented tao maps input interface urgency values 
output mapping output mapping assigns dispatching priority dispatching subpriority underlying dispatching model 
section describes output mapping translates assigned urgency values appropriate dispatching priority dispatching subpriority values output interface 
section describes alternatives output mapping tao discusses key design issues related alternatives 
remainder section describes tao scheduling service implements fixed interfaces variable mappings 
tao scheduling service input interface illustrated steps applications tao scheduling service input interface convey qos information prioritizes operations 
tao scheduling service input interface consists corba idl interface operations shown outlined 
create operation takes string operation name input parameter 
creates new rt info descriptor operation name returns handle descriptor caller 
rt info descriptor operation name exists create raises cate name exception 
add dependency operation takes info descriptor handles input parameters 
places dependency second handle operation handle srt info descriptor 
dependency informs scheduler flow control passes second operation 
handles refers invalid rt info descriptor add dependency raises unknown task exception 






tao scheduling service input idl interface set operation takes rt info descriptor handle values operation characteristics input parameters 
operation assigns values operation characteristics handle rt info descriptor passed input values 
passed handle refers info descriptor set raises unknown task exception 
tao scheduling service output interface output interface tao scheduling service consists corba idl interface operations shown 
operation dispatch configuration provides configuration information queues dispatching modules orb endsystem step 
takes dispatching priority value input parameter 
returns os thread priority dispatching type corresponding dispatching priority level 
run time scheduler component tao scheduling service retrieves values info repository stored tao line scheduling component step 
unknown dispatch priority exception raised dispatch configuration operation passed dispatching priority schedule 
likewise schedule generated configuration operation raises scheduled exception 
second operation priority provides dispatching priority dispatching subpriority information operation request step 
takes rt info de 





tao scheduling service output idl interface handle input parameter returns assigned dispatching subpriority dispatching priority output parameters 
run time component tao scheduling service retrieves dispatching priority dispatching subpriority values stored rt info repository line component step 
passed handle refer valid rt info descriptor priority raises unknown task exception 
schedule generated priority raises scheduled exception 
integrating tao scheduling service dispatching modules noted section key research challenge implement dispatching modules enforce qos requirements 
section shows dispatching modules fit tao architecture describes internal queueing mechanism tao dispatching modules discusses issue run time control dispatching priority dispatching modules 
architectural placement output interface tao scheduling service designed dispatching modules layer tao architecture 
example tao real time extensions corba event service uses scheduler output interface subsystem 
illustrates dispatching tao real time event service 
client application pushes event tao event service 
event service dispatching module enqueues events dispatches dispatching priority dispatching subpriority 
dispatched 

alternative placement dispatching modules event results flow control orb layers client back orb layers server operation dispatched 
illustrates dispatching tao subsystem 
client application direct operation calls orb passes requests orb layers client back subsystem layer server 
subsystem dispatching module enqueues operation requests dispatches dispatching priority dispatching subpriority respectively 
dispatched operation request results flow control higher orb layers server operation dispatched 
internal architecture illustrates general queueing mechanism dispatching modules tao orb endsystem 
addition shows output information provided tao scheduling service configure operate dispatching module 
system initialization dispatching module obtains thread priority dispatching type queues scheduling service output interface described section 
queue assigned unique dispatching priority number unique thread priority enumerated dispatching type 
dispatching module ordered queue pending dispatches dispatching priority 
preserve qos guarantees operations inserted appropriate dispatching queue assigned dispatching priority 
operations dispatching queue ordered assigned dispatching subpriority 
mini example queueing mechanism tao dispatching module priority inversions operations dispatched queue highest thread priority preempting operation executing lower priority thread 
minimize preemption overhead preemption priority queue 
values defined dispatching type static dispatching type specifies queue considers static portion operation dispatching subpriority 
deadline dispatching type specifies queue considers dynamic static portions operation dispatching subpriority updates dynamic portion time remaining operation deadline 
laxity dispatching type specifies queue considers dynamic static portions operation dispatching subpriority updates dynamic portion operation laxity 
deadline laxity queues update operation dispatching operation enqueued dequeued 
run time dispatching priority run time control dispatching priority achieve preemptive dispatching model discussed section 
model incurs greater complexity dispatching module implementation increases run time overhead 
operation enqueued tao dispatching modules queues specified dispatching types exerts control operation dispatching priority run time 
noted section strategies implemented tao map static priority directly dispatching priority 
compared strategies modify operation dispatching priority dynamically mapping simplifies dispatching module implementation queues need maintain perform locking move messages queues 
addition tao strategy implementations minimize run time overhead queues specified dispatching types update dynamic portion operation dispatching priority 
characteristics meet requirements real time avionics systems tao applied 
possible application define strategies modify operation dispatching priority dynamically 
potential implementation add new constant enumerated dispatching types 
addition appropriate kind queue implemented configure dispatching module new dispatching type 
supporting extension simplified flexible design tao scheduling service framework 
input mappings implemented tao scheduling service tao scheduling strategies input mapping assigns urgency operation specific scheduling strategy 
input mappings muf mlf edf rms implemented tao scheduling service 
outline mapping 
mapping static subpriority assigned importance second topological ordering dependencies 
canonical definitions mlf edf rms include minimal static ordering 
adding tao strategy implementations strategies adverse effect 
mlf edf rms require operations guaranteed meet deadlines schedule feasible ordering operations identical priorities 
static ordering benefit ensuring determinism possible assignment urgency values 
muf mapping mapping operation characteristics urgency muf shown 
static priority assigned criticality mapping 
static priorities criticality levels tao muf implementation 
critical set version muf set operations assigned high criticality value 
muf implemented criticality levels minimum critical priority static priority corresponding high criticality value 
general version muf multiple criticality levels possible critical set may span multiple criticality levels 
dynamic subpriority assigned muf input mapping muf input mapping laxity 
laxity function operation period execution time arrival time time evaluation 
mlf mapping mlf mapping shown assigns constant zero value static priority operation 
results single static priority 
minimum mlf input mapping critical priority lone static priority 
mlf strategy assigns dynamic subpriority operation laxity 
edf mapping edf mapping shown assigns constant zero value static priority operation 
edf strategy assigns dynamic subpriority operation time deadline function period arrival time time evaluation 
rms mapping rms mapping shown assigns static priority operation period higher static priority shorter period 
period aperiodic execution assumed worst edf input mapping rms input mapping case 
rms operations critical minimum critical priority minimum static priority system 
rms strategy assigns constant zero value dynamic subpriority operation 
section explored known rms edf mlf muf priority mappings 
mappings reflect opposing design forces commonality difference 
tao scheduling service leverages commonality mappings implementation uniform 
differences mappings provide hot spots adaptation requirements specific applications 
output mapping implemented tao scheduling service need correctly specify qos requirements different operations motivates input output mappings tao scheduling service 
input mappings described section specify priorities operations 
mechanism enforce priorities independent specific os platform dispatching models 
tao scheduling strategies output mapping transforms priority subpriority values dispatching priority subpriority requirements enforced specific dispatching models real systems 
described section operations distributed priority dispatching queues orb assigned dispatching priority 
operations ordered priority dispatching queues designated dispatching subpriority 
scheduling strategy output mapping assigns dispatching priority dispatching subpriority operations function urgency values specified scheduling strategy input mapping 
illustrates output mapping scheduling strategies implemented tao 
mapping output mapping implemented tao described 
dispatching priority mapping static priority maps directly dispatching priority 
mapping corresponds priority band dispatching model described section 
unique static priority assigned input mapping results distinct thread priority tao orb request dispatching module 
dispatching subpriority dynamic subpriority static subpriority map dispatching subpriority 
tao scheduling service performs mapping efficiently runtime transforming dynamic static flat binary representation 
binary integer format length bits store dispatching subpriority value 
range dynamic subpriority values number static known prior run time fixed number bits reserved 
dynamic sub priority stored highest order bits number possible dynamic 
static subpriority stored lower order bits number static 
tao preemption subpriority mapping scheme preserves ordering operation dispatches assigned urgency values 
static correspond thread priorities 
operation higher static priority preempt lower static subpriority 
operations static priority ordered dynamic subpriority second static subpriority 
alternative output mappings useful consider consequences specific output mapping described section evaluate uses implications alternative output mappings 
scheduling strategies implemented tao strike balance preemption granularity run time overhead 
design appropriate hard real time avionics applications developed 
tao scheduling architecture designed adapt needs range applications just hard real time avionics systems 
different types applications platforms may require different resolutions key design forces 
example application may run platform support preemptive multi threading 
likewise platforms support thread preemption multiple thread priority levels 
cases tao scheduling service framework assigns operations constant dispatching priority maps entire urgency tuple directly dispatching subpriority 
mapping correctly assigns dispatching priorities dispatching nonpreemptive dispatching model 
platform preemptive multi threading application dispatch operations single thread execution single priority queue 
application run platform support preemptive multi threading large number distinct thread priorities 
thread preemption large number thread priorities supported alternative dispatching model preemptive urgency 
design may incur higher run time overhead allow finer preemption granularity 
application second example accept additional time space overhead needed preemptively dispatch operations urgency exchange reducing amount priority inversion incurred dispatching module 
depending os supports thread preemption number distinct thread priorities supported preemption granularity desired application dispatching models supported output interface tao scheduling service 
examine canonical variations supported tao illustrated 
dispatching models supported tao preemptive urgency consequence input output mappings implemented tao purely dynamic edf mlf strategies non preemptive 
newly arrived operation dispatched operation currently executing run completion new operation greater urgency 
assigning dispatching priority urgency scheduling strategies fully preemptive 
dispatching model maintains invariant highest urgency operation able execute executing instant modulo os dispatch latency overhead 
model implemented platforms support fully preemptive multitasking provide distinct real time thread priorities number distinct operation possible application 
preemptive urgency dispatching model achieve fine grained control priority inversions incurred dispatching modules 
design potentially reduces time bound inversion thread context switch plus switching overhead introduced dispatching mechanism 
preemptive urgency achieves precision cost increased time space overhead 
overhead reduced applications operations known advance techniques perfect hashing overhead additional context switches incurred 
preemptive priority band model divides range possible fixed priority bands 
similar non preemptive dispatching model message queues unix system streams subsystem 
dispatching model maintains slightly weaker invariant preemptive urgency model 
instant operation highest fixed priority band operations able execute executing 
dispatching model requires thread preemption small number distinct thread priority levels 
features operating systems 
preemptive priority band model reasonable choice desirable necessary restrain number distinct preemption levels 
example dynamic scheduling strategy produce large number distinct urgency values 
values constrained operating systems windows nt support small range distinct thread priorities 
operations queue ordered subpriority function urgency 
strategies implemented tao scheduling service form model described section 
non preemptive model uses single priority queue non preemptive 
maintains weaker invariant operation executing instant greatest urgency time dispatch 
operations ordered urgency single dispatching queue 
previous models model platforms lack thread preemption multi threading 

