ieee transactions software engineering october pages gregg rothermel department computer science oregon state corvallis cs orst edu prioritizing test cases regression testing roland department computer science middle state tn edu february chu department computer science oregon state corvallis cs orst edu mary jean harrold college computing georgia inst 
tech 
atlantic drive atlanta ga harrold cis ohio state edu test case prioritization techniques schedule test cases execution order attempts increase effectiveness meeting performance goal 
various goals possible involves rate fault detection measure quickly faults detected testing process 
improved rate fault detection testing provide faster feedback system test software engineers correcting faults earlier possible 
application prioritization techniques involves regression testing retesting software modifications context prioritization techniques take advantage information gathered previous execution test cases obtain test case orderings 
describe techniques test execution information prioritize test cases regression testing including techniques order test cases total coverage code components techniques order test cases coverage code components previously covered techniques order test cases estimated ability reveal faults code components cover 
report results experiments applied techniques various test suites various programs measured rates fault detection achieved prioritized test suites comparing rates rates achieved untreated randomly ordered optimally ordered suites 
analysis data shows prioritization techniques studied improved rate fault detection test suites improvement occurred expensive techniques 
data shows considerable room remains improvement 
studies highlight cost benefits tradeoffs techniques studied opportunities 
keywords test case prioritization regression testing software testing empirical studies software engineers save test suites develop software reuse test suites software evolves 
test suite reuse form regression testing pervasive software industry regression testing activities estimated account half cost software maintenance 
running test cases test suite require large amount effort 
example industrial collaborators reports products lines code entire test suite requires weeks run 
reason researchers considered various techniques reducing cost regression testing including regression test selection test suite minimization techniques 
regression test selection techniques reduce cost regression testing selecting appropriate subset existing test suite information program modified version test suite :10.1.1.53.353
test suite minimization techniques lower costs reducing test suite minimal subset maintains equivalent coverage original test suite respect particular test adequacy criterion 
regression test selection test suite minimization techniques drawbacks 
example empirical evidence indicates certain cases little loss ability minimized test suite reveal faults comparison original empirical evidence shows fault detection capabilities test suites severely compromised minimization 
similarly safe regression test selection techniques ensure selected subset test suite fault detection capabilities original test suite conditions safety achieved hold 
test case prioritization techniques provide method assisting regression testing 
techniques testers order test cases test cases highest priority criterion executed earlier regression testing process lower priority test cases 
example testers wish schedule test cases order achieves code coverage fastest rate possible exercises features order expected frequency exercises subsystems order reflects historically demonstrated propensity fail 
time required entire test suite short test case prioritization may cost effective may sufficient simply schedule test cases order 
time required execute entire test suite sufficiently long test case prioritization may beneficial case meeting testing goals earlier yield meaningful benefits 
test case prioritization techniques discard test cases avoid drawbacks occur regression test selection test suite minimization discard test cases 
alternatively cases discarding test cases acceptable test case prioritization conjunction regression test selection test suite minimization techniques prioritize test cases selected minimized test suite 
test case prioritization increase likelihood regression testing activities unexpectedly terminated testing time spent beneficially test cases prioritized 
describe techniques prioritizing test cases regression testing 
describe empirical studies performed techniques evaluate ability improve rate fault detection measure quickly faults detected testing process 
improved rate fault detection regression testing provides earlier feedback system test lets debugging activities earlier possible 
results indicate test case prioritization significantly improve rate fault detection test suites 
results highlight cost benefits tradeoffs various techniques 
test case prioritization techniques may applicable initial testing software 
concerned regression testing 
section discusses applications prioritization related prioritization detail 
section precisely describes test case prioritization problem presents prioritization techniques discusses previous prioritization 
section presents design results analysis empirical studies 
section discusses results practical implications section presents discusses 
test case prioritization formally define test case prioritization problem follows definition test case prioritization problem test suite pt set permutations function pt real numbers 
problem find pt pt 
definition pt represents set possible orderings function applied ordering yields award value ordering 
simplicity loss generality definition assumes higher award values preferable lower ones 
aspects test case prioritization problem worth describing 
possible goals prioritization including testers may wish increase rate fault detection test suite likelihood revealing faults earlier run regression tests test suite 
testers may wish increase coverage coverable code system test faster rate allowing code coverage criterion met earlier test process 
testers may wish increase confidence reliability system test faster rate 
testers may wish increase rate high risk faults detected test suite locating faults earlier testing process 
testers may wish increase likelihood revealing faults related specific code changes earlier regression testing process 
goals stated qualitatively 
measure success prioritization technique meeting goal describe goal quantitatively 
definition represents quantification 
precisely define particular function quantifying goals 
second depending choice test case prioritization problem may intractable undecidable 
example function quantifies test suite achieves statement coverage fastest rate possible efficient solution test case prioritization problem provide efficient solution knapsack problem 
similarly function quantifies test suite detects faults fastest rate possible precise solution test case prioritization problem provide solution halting problem 
cases prioritization techniques heuristics 
third test case prioritization initial testing software regression testing software 
difference applications case regression testing prioritization techniques information gathered previous runs existing test cases help prioritize test cases subsequent runs 
fourth useful distinguish varieties test case prioritization general test case prioritization version specific test case prioritization 
general test case prioritization program test suite prioritize test cases intent finding ordering test cases useful succession subsequent modified versions general test case prioritization performed release version program peak hours cost performing prioritization amortized subsequent releases 
hoped resulting prioritized suite successful original suite meeting goal prioritization average subsequent releases 
contrast version specific test case prioritization program test suite prioritize test cases intent finding ordering useful specific version prioritization performed set changes prior regression testing prioritization accomplished available care taken keep cost performing prioritization excessively delaying regression testing activities intended facilitate 
prioritized test suite may effective meeting goal prioritization particular test suite resulting general test case prioritization may effective average succession subsequent releases 
typically necessarily general test case prioritization information specific modified versions version specific prioritization information 
course possible general test case prioritization techniques incorporate information expected modifications improve average performance prioritized test suites succession program versions possible prioritization techniques ignore modified program version specific techniques 
fifth possible integrate test case prioritization regression test selection test suite minimization techniques example prioritizing test suite selected regression test selection algorithm prioritizing minimal test suite returned test suite minimization algorithm 
prioritization goal various prioritization techniques may applied test suite aim meeting goal 
example attempt increase rate fault detection test suites prioritize test cases terms extent execute modules measured historically tended fail 
alternatively prioritize test cases terms increasing cost coverage code components terms increasing cost coverage features listed requirements specification 
case intent choice prioritization technique informally knapsack problem problem set elements cost value size constraint value goal finding subset meets size constraint value goal 
formal treatment see 
increase likelihood prioritized test suite better meet goal ad hoc random ordering test cases 
restrict attention general test case prioritization application regression testing independent regression test selection test suite minimization 
focus specific goal function evaluate abilities prioritization techniques help meet goal 
prioritization rate fault detection focus goal listed section goal increasing likelihood revealing faults earlier testing process 
informally describe goal improving test suite rate fault detection describe function quantifies goal section 
suggested section motivations meeting goal 
improved rate fault detection regression testing software engineers debugging activities earlier possible speeding release software 
improved rate fault detection provide faster feedback system test provide earlier evidence quality goals met allowing strategic decisions release schedules earlier possible 
testing situation amount testing time available uncertain example market pressures may force release product prior execution test cases prioritization increase likelihood testing process terminated testing resources spent cost effectively relation potential fault detection 
consider different test case prioritization techniques see table 
techniques serve experimental controls techniques practical sense refer simplify presentation 
techniques represent heuristics implemented software tools techniques test coverage information produced prior executions test cases prioritize test cases subsequent execution 
source motivation approaches conjecture availability test execution data asset approaches assumption past test execution data predict sufficient accuracy subsequent execution behavior 
practice code modifications create new version may alter test execution patterns issue impacting efficacy test case prioritization techniques alterations significantly impact predictive value past execution data 
describe techniques listed table turn 
prioritization 
facilitate empirical studies prioritization technique consider simply application technique lets consider untreated test suites serves control 
random prioritization 
success untreated test suite meeting goal may depend manner test suite initially constructed 
additional control studies apply random prioritization randomly order test cases test suite 
code mnemonic description untreated prioritization random randomized ordering optimal ordered optimize rate fault detection stmt total prioritize order coverage statements stmt addtl prioritize order coverage statements covered branch total prioritize order coverage branches branch addtl prioritize order coverage branches covered fep total prioritize order total probability exposing faults fep addtl prioritize order total probability exposing faults adjusted consider effects previous test cases table catalog prioritization techniques 
optimal prioritization 
shall discuss section measure effects prioritization techniques rate fault detection empirical studies programs contain known faults 
program set known faults determine test suite test cases expose faults determine optimal ordering test cases maximizing rate fault detection set faults 
practice course practical technique requires priori knowledge existence faults test cases expose faults technique empirical studies gain insight success practical heuristics comparing solutions optimal solutions 
algorithm determines optimal test case ordering may consider possible testcase orderings worst case runtime exponential test suite size 
test suites empirical studies large support practical algorithm empirical studies employed greedy optimal prioritization algorithm 
program set faulty versions test suite information test cases expose faults algorithm iteratively selects test case exposes faults exposed selected test case test cases expose faults selected 
test cases expose faults selected algorithm remaining test cases prioritized method 
measure rate fault detection employ ordering subsequent test cases effect rate fault detection shall clear discussion effectiveness measure section 
algorithm prioritizes remaining test cases order appearance original test suite 
greedy prioritization algorithm may choose optimal test case ordering 
see suppose program contains faults suppose test suite program contains test cases detect faults shown table 
greedy algorithm may select test case test case second test case third 
optimal test case orderings case 
despite fact shall show algorithm provides useful benchmark measure practical techniques know optimal ordering perform worse ordering calculate 
brevity rest refer technique incorporates algorithm optimal prioritization 
test case fault table case greedy optimal prioritization algorithm may produce optimal solution 
total statement coverage prioritization 
instrumenting program determine test case statements program exercised covered test case 
prioritize test cases terms total number statements cover counting number statements covered test case sorting test cases descending order number 
multiple test cases cover number statements additional rule necessary order test cases order randomly 
illustrate depicts procedure left statement coverage executable statements procedure achieved test cases center 
applied case total statement coverage prioritization yields test case order 
procedure 



exit 
endif 
endwhile 


statement test case test case test case statement coverage true false true false test case test case test case entry branch coverage procedure statement branch coverage achieved test cases 
test suite containing test cases program containing statements total statement coverage prioritization accomplished time log 
term denotes time required count statements covered test case second term denotes time required sort test cases coverage 
typically greater case cost prioritization 
note measure total statement coverage consider repetition coverage calculation 
statement executed treated statement due looping executed multiple times 
treatment treatment underlies code coverage testing techniques generally 
alternative measures consider execution counts leave investigation alternatives subject 
additional statement coverage prioritization 
total statement coverage prioritization schedules test cases order total coverage achieved having executed test case covered certain statements may gained subsequent testing executing statements covered 
additional statement coverage prioritization iteratively selects test case yields greatest statement coverage adjusts coverage information remaining test cases indicate coverage statements covered repeats process statements covered test case covered 
multiple test cases cover number statements covered additional rule necessary choose test cases randomly 
having ordered subset test cases test suite manner may reach point statement covered test case remaining test cases add additional statement coverage 
order remaining test cases prioritization technique order remaining test cases reapplying additional coverage prioritization resetting coverage vectors test cases initial values reapplying algorithm ignoring previously prioritized test cases 
illustration consider 
example total additional statement coverage prioritization select test case total coverage prioritization selects test case second additional coverage prioritization detects test case covers statements covered test case test case covers uncovered statement outputs test case order 
additional statement coverage prioritization requires coverage information test case updated choice test case 
test suite containing test cases program containing statements selecting test case coverage information cost selection performed times 
cost additional statement coverage prioritization factor expensive total statement coverage prioritization 
total branch coverage prioritization 
total branch coverage prioritization total statement coverage prioritization uses test coverage measured terms program branches statements 
context define branch coverage coverage possible outcome possibly compound condition predicate 
example statement exercised evaluates true false 
accommodate functions contain branches treat function entry branch regard branch covered test case causes function invoked 
theory branch coverage properly subsumes statement coverage test suite adequate branch coverage necessarily adequate statement coverage vice versa conjecture prioritization branch coverage average effective effective prioritization statement coverage 
hand arms branch contain different numbers statements case ordering branches may cause attention paid branches contain code basis conjecture prioritization statement coverage effective prioritization branch coverage 
possibility suggested anonymous reviewers 
address contradictory intuitions empirical investigation relationship branch coverage prioritization techniques necessary 
right depicts branch coverage achieved code depicted test cases illustration statement coverage prioritization 
applied example total branch coverage prioritization outputs test case order 
additional branch coverage prioritization 
additional branch coverage prioritization additional statement coverage prioritization uses test coverage measured terms program branches statements 
technique require method prioritizing remaining test cases complete coverage achieved resetting coverage vectors initial values reapplying additional branch coverage prioritization remaining test cases 
applied example branch coverage information depicted total branch coverage prioritization outputs test case order 
case case statement coverage prioritization total additional branch coverage prioritization output identical test case orders 
total fault exposing potential fep prioritization 
statement branch coverage prioritization consider statement branch exercised test case 
techniques ignore fact test cases faults faults easily exposed faults test cases adept revealing particular faults test cases 
formally ability test case expose fault test case fault exposing potential fep depends test case covers executes faulty statement probability fault statement cause failure test case 
practical determination probability approximation wished determine approximation yield prioritization technique superior terms rate fault detection techniques simple code coverage 
voas provides method obtaining approximations form pie propagation infection execution analysis 
pie analysis assesses probability input distribution fault exists statement result failure 
probability termed sensitivity estimated combining independent estimates probabilities probability executed execution probability probability change cause change program state infection probability probability change state propagates output propagation probability 
pie analysis uses various methods obtain estimates simple code instrumentation estimate execution probability variant weak mutation syntactic changes applied state examined effects estimate infection probability state perturbation data state altered program output examined differences estimate propagation probability 
approach incorporating estimates fault exposing potential involve obtaining sensitivity estimates form suggested voas associating estimates test cases test coverage information 
purpose test case prioritization approach disadvantages 
factoring execution probabilities sensitivity measures probability fault cause failure relative input distribution 
prioritizing test cases regression testing existing coverage information interested probability test case executes statement containing fault fault propagate output 
possible high low infection propagation probabilities respect inputs execute low high execution probability relative input distribution 
incorporation execution probabilities sensitivity estimates distorts measure likelihood test case reaches expose fault application approach consider appropriate measure consider infection propagation 
second drawback sensitivity context involves treatment propagation infection estimates 
sensitivity analysis separately calculates estimates uses conservative approach combine 
conservative approach designed reflect worst case set data state errors produce infection estimate exactly set data state errors propagate output general case may occur 
approach result low estimates fault exposing potential large number statements receiving estimates zero zero estimates may compromise ability test case prioritization techniques create useful test case orderings 
obtain approximation fault exposing potential test case adopt approach uses mutation analysis produce combined estimate propagation infection incorporate independent execution probabilities 
mutation analysis creates large number faulty versions mutants program altering program statements uses assess quality test suites measuring test suites detect faults kill mutants 
approach works follows 
program test suite create set mutants nm noting statement sj contains mutant 
test case ti execute mutant version nk ti noting ti kills mutant 
having collected information test case mutant consider test case ti statement sj calculate fault exposing potential fep sj ratio mutants sj killed ti total number mutants sj 
note ti execute sj ratio zero 
perform total fep prioritization fep values calculate test case ti value summing fep sj ti values statements sj award values prioritize test cases sorting order descending award value resolving ties random selection 
illustrate depicts procedure considered earlier discussion coverage prioritization techniques table listing fault exposing potential estimates calculated test cases statements procedure 
case award value test case award value test case award value test case total fep prioritization outputs test case order 
total fep prioritization may appear statement branch coverage prioritization ignore multiple statement executions caused looping 
mutation scores obtain fep values obtained actual test executions captured procedure 



exit 
endif 
endwhile 


statement test case test case test case fep values procedure fep values test cases 
effects looping fault detection 
issue consider respect program mutation approximate fep values involves equivalent mutant problem problem determining mutant version program semantically equivalent original program 
semantically equivalent mutant killed test case 
problem identifying equivalent mutants undecidable general practice involve considerable human effort feasible empirical studies identify mutants enormous numbers mutants involved mutants 
considered approaches coping possible presence mutants 
approach consider mutants killed test case empirical studies semantically equivalent mutants ignore mutants fep calculations 
number test cases empirical studies enormous report section approach may overestimate number semantically equivalent mutants cause overestimate fep values 
overestimates may cause assign inordinately high award value test case executes statements containing mutants award value test case powerful second approach treat mutants killed test case possibly consider mutants fep calculations 
approach may underestimate number semantically equivalent mutants cause underestimate fep values 
underestimates may cause assign inordinately low award value test case executes statements containing mutants award value test case powerful chose second approach due conservatism 
fep values test suite containing test cases program containing statements total fep prioritization accomplished time log 
general greater case cost prioritization worst case time analogous total statement coverage prioritization 
cost obtaining fep values quite high certainly values obtained mutation analysis cost may excessive 
investigation prioritization techniques involves techniques potentially practical applicable investigation fep techniques considered exploratory 
exploration easily motivated fep prioritization shows promise justify search cost effective techniques approximating fault exposing potential techniques constrained mutation techniques static measures likelihood fault exposure 
additional fault exposing potential fep prioritization 
analogous extensions total statement branch coverage prioritization yield additional statement branch coverage prioritization extend total fep prioritization create additional fault exposing potential fep prioritization 
lets account fact additional executions statement may valuable initial executions 
describe technique precisely require mechanism measuring value execution statement related fep values 
term confidence 
say confidence statement estimate probability correct 
value inclusive 
execute test case exercises reveal fault increase 
assume prior execution confidence statement fault exposing potential fep 
execution exposes fault new confidence fep simplifying equation obtain fep additional confidence statement gain executing test case fep define additional confidence gained executing test case program sum statements covered sk statements covered sk additional fep prioritization iteratively selects test case yields greatest value current values updates values statements covered recalculates values remaining statements remaining test cases updated values repeats process test cases prioritized 
practice initial values set differently different statements initialize fixed value 
fixed value chose implies confidence statement prior running test suite 
choose initial values 
example indicate probabilities statement correct containing fault equal 
example application additional fep prioritization consider 
initialize statements 
case values result executing test case shown calculation test case equivalent original fep values 
additional fep prioritization total fep prioritization selects test case test case 
having chosen test case additional fep prioritization calculates statement new confidence statement 
test case executes statements confidence values increase confidence values statements remain 
calculation shows resulting values 
values recalculated remaining test case shown calculation values statements altered 
calculate 
additional fep prioritization selects test case yields greatest gain confidence 
technique outputs test case order order second third test cases reverse order output total fep prioritization 
statement calculation addi values test case execution test case statement calculation test case test case test case test case test case test case statement addi values test case calculation values calculated additional fep prioritization program test cases 
difference additional fep prioritization additional statement branch coverage prioritization additional fep prioritization algorithm need check full confidence achieved reach point additional confidence gained remaining test cases 
reason test case tobe statement covered statement exist test case fep 
fep may estimated cases estimated statement covered event occur proceed additional coverage prioritization techniques resetting values initial states test cases prioritized reapplying algorithm test cases empirical studies event occur 
additional statement coverage prioritization additional fep prioritization requires coverage information test case updated choice test case 
cost test suite test cases program containing statements factor expensive total fep prioritization 
total fep prioritization additional fep prioritization requires method estimating fep values potentially expensive requirement 
related weyuker techniques generating test cases apply software modeled markov chains provided operational profile data available 
authors term prioritization techniques generate test cases order cover larger proportion probability mass earlier testing essentially prioritizing test cases order increases likelihood faults encountered field uncovered earlier testing 
approach provides example application prioritization initial testing software test suites available 
wong suggest prioritizing test cases criterion increasing cost additional coverage 
explicitly stated authors possible goal prioritization reveal faults earlier testing process 
authors restrict attention prioritization test cases execution specific modified version program termed prioritization prioritization subset test cases selected safe regression test selection technique test suite program 
authors specify mechanism prioritizing remaining test cases full coverage achieved 
authors describe case study applied technique program lines executable code program space empirical studies reported evaluated resulting test suites faulty versions program 
conclude technique cost effective application 
empirical studies test case prioritization techniques investigate test case prioritization compare evaluate test case prioritization techniques described section performed empirical studies 
section describes studies including design measures subjects results threats validity 
research questions interested research questions 
test case prioritization improve rate fault detection test suites 
various test case prioritization techniques section compare terms effects rate fault detection 
effectiveness measure address research questions require measure assess compare effectiveness various test case prioritization techniques 
terms definition measure plays role function 
measure rapidly prioritized test suite detects faults weighted average subjects programs program versions test cases test suites studies data sets collected obtained contacting author 
test fault percent detected faults test case order area test suite fraction percent detected faults test suite fraction test suite fraction test suite faults exposed apfd prioritized suite apfd prioritized suite apfd prioritized suite test case order area example illustrating apfd measure 
percent detected faults test case order area percentage faults detected apfd execution test suite 
values range higher apfd numbers mean faster better fault detection rates 
illustrate measure consider example program faults test suite test cases fault detecting abilities shown suppose place test cases order form prioritized test suite 
shows percentage detected faults versus fraction test suite 
running test case faults detected faults detected test suite 
running test case faults detected faults detected test suite 
area inside inscribed rectangles dashed boxes represents weighted percentage faults detected corresponding fraction test suite 
solid lines connecting corners inscribed rectangles interpolate gain percentage detected faults 
area curve represents weighted average percentage faults detected life test suite 
area prioritized test suite average percentage faults detected measure apfd apfd example 
reflects happens order test cases changed yielding test suite faster detecting suite apfd 
shows effects prioritized test suite test case ordering inspection clear ordering results earliest detection faults illustrates optimal ordering apfd 
note measure effectiveness apfd incorporate factors cost performing prioritization measure factors experiments 
reasons 
implementations techniques built efficiency studies required run processes continuously machines weeks time unable control processes hardware altering timings 
clear performance cost measurements obtained tools run conditions meaningful 
cost benefits tradeoffs involving test case prioritization depend testing process interpolation granularity adjustment small number test cases comprise test suite larger test suite smaller adjustment 
interpolation corresponds interpretation test case test suite executes progress considered detecting faults detected test case 
test case prioritization fits process 
general test case prioritization variety prioritization investigating prioritization performed line release system time resource usage may noncritical provided falls certain threshold 
cost performing prioritization amortized successive releases software 
cost benefits tradeoffs prioritization techniques vary process resources available single measure incorporating costs benefits obscure cost effectiveness analyses apply particular processes 
measuring reporting run time costs provided complexity analyses test case prioritization techniques section discuss practical implications results 
prioritization analysis tools 
perform empirical studies required tools 
obtain test coverage control flow graph information aristotle program analysis system 
obtain mutation scores fep prioritization mutation system 
created prioritization tools implement techniques outlined section 
subjects programs subjects see table 
programs faulty versions test cases assembled researchers siemens corporate research study fault detection capabilities control flow data flow coverage criteria 
refer siemens programs 
eighth program program developed european space agency 
refer program space 
discuss siemens programs space subsections 
lines number number test average executable pool test suite program code versions mutants size size print tokens print tokens replace schedule schedule tcas tot info space table experiment subjects 
siemens programs versions test suites siemens programs perform variety tasks tcas aircraft collision avoidance system schedule schedule priority schedulers tot info computes statistics input data print tokens print tokens lexical analyzers replace performs pattern matching substitution 
researchers siemens sought study fault detecting effectiveness coverage criteria 
created faulty versions base programs manually seeding programs faults usually modifying single line code program 
goal introduce faults realistic possible experience real programs 
people performed fault seeding working knowledge 
result effort versions base program see table containing single fault 
context single fault versions important experiment design choice allows experimenters precisely determine test case reveals particular fault simply determining version containing fault fails 
absence methodology may difficult impossible associate test cases particular faults 
choice pose potential threat validity discuss section 
base program researchers siemens created large test pool containing possible test cases program 
populate test pools created initial suite black box test cases testing practices tester understanding program functionality knowledge special values boundary points easily observable code category partition method siemens test specification language tool 
augmented suite manually created white box test cases ensure executable statement edge definition pair base program control flow graph exercised test cases 
obtain meaningful results seeded versions programs researchers retained faults easy hard detect defined detectable test cases test pool associated program 
obtain sample test suites programs test pools base programs information test cases pools generate branch coverage adequate test suites program 
precisely generate test suite base program test pool tp pseudo random number generator rand seeded initially output time system call obtain integers treated indexes tp modulo tp 
indexes select test cases tp added selected test case added cumulative branch coverage achieved test cases added far 
continued add test cases contained test case exercise executable branch base program 
table lists average sizes branch coverage adequate test suites generated procedure subject programs 
generated mutants siemens programs 
table reports numbers mutant programs created 
space versions test suites space consists lines code executable functions interpreter array definition language adl 
program reads file contains adl statements checks contents file adherence adl grammar specific consistency rules 
adl file correct space outputs array data file containing list array elements positions excitations program outputs error messages 
space associated versions containing single fault discovered program development 
adopt single fault version approach siemens programs space reasons 
working program discovered additional faults created versions containing just faults 
discovered faulty versions originally supplied semantically equivalent base version 
excluded study ultimately faulty versions 
constructed test pool space stages 
obtained initial pool test cases frankl created pool study randomly generating test cases 
initial pool instrumented program coverage added additional test cases pool contained executable statement edge siemens programs definition pair program control flow graph test cases exercised statement edge 
process yielded test pool test cases 
space test pools obtain branch coverage adequate test suites program process siemens programs 
resultant test suites ranged size test cases averaging test cases 
initially generated test suites 
due time required exercise mutants space test cases contained test suites randomly sampled test suites selecting test suites studies 
selection allowed restrict mutation analysis test cases contained selected suites 
siemens programs generate mutants space tool produced mutants 
empirical studies results performed empirical studies varied subject programs faults 
discuss studies turn presenting results initial analysis 
provide discussion results practical implications section 
study siemens programs apfd measured relative siemens faults study investigated application prioritization techniques siemens programs measuring apfd relative set faults provided programs 
subject program applied prioritization techniques sample test suites obtaining prioritized test suites 
retained original test suites untreated controls analysis considered prioritized technique 
calculated apfd values prioritized test suites relative faults provided programs statistical data sets 
treated statements edges executable failure seventeen malloc calls program non executable 
initial indication prioritization technique affected test suite rate detection study determined presents boxplots apfd values categories prioritized test suites program program total 
control group 
random prioritization group 
optimal prioritization group 
comparing boxplots readily apparent optimal prioritization greatly improved rate fault detection increased apfd values test suites comparison prioritization random prioritization 
examining boxplots prioritization techniques produce improvement 
overlap apfd values mandates formal statistical analysis 
sas statistical package perform anova analysis able reject null hypothesis apfd means various techniques equal confirming boxplot observations 
anova analysis indicated statistically significant cross factor interactions programs effect apfd values 
general statements technique effects qualified 
rejection null hypothesis tells techniques produce statistically different apfd means determine techniques differ requires running multiple comparison procedure 
commonly means separation tests elected bonferroni method conservatism generality 
bonferroni calculated minimum statistically significant difference apfd means program 
table 
techniques listed program sub table apfd mean values higher better lower worse 
grouping letters partition techniques techniques significantly different share grouping letter 
examination sub tables affirms boxplots indicate non control techniques provided significant improvement rate fault detection comparison prioritization random prioritization 
relative improvement provided technique dependent program programs sub table show additional fep prioritization performed better techniques total fep prioritization performed better branch total prioritization worse branch total 
programs sub table suggests branch coverage techniques performed better corresponding statement coverage techniques branch total performed statement total branch additional outperformed statement additional 
interesting case print tokens total branch coverage prioritization performed outperformed additional branch coverage prioritization cases total statement coverage prioritization performed outperformed additional statement coverage prioritization 
effect worth noting programs randomly prioritized test suites outperformed untreated test suites 
comment effects section 
boxplots provide concise display distribution 
central line box marks median value 
edges box mark third quartiles 
whiskers extend quartiles farthest observation lying times distance quartiles 
individual markers whiskers outliers 
anova acronym analysis variance standard statistical technique study variability experimental data 
print tokens print tokens replace schedule schedule tcas tot info programs apfd boxplots study vertical axis apfd score program technique 
techniques untreated random optimal stmt total stmt addtl branch addtl fep total fep addtl 
print tokens grouping mean technique optimal brch addtl fep addtl brch total fep total stmt total stmt addtl random untreated df mse critical value minimum significant difference print tokens grouping mean technique optimal fep addtl brch addtl stmt total fep total stmt addtl brch total random untreated df mse critical value minimum significant difference replace grouping mean technique optimal fep total fep addtl stmt total brch total brch addtl stmt addtl untreated random df mse critical value minimum significant difference schedule grouping mean technique optimal brch addtl stmt total fep addtl brch total fep total random stmt addtl untreated df mse critical value minimum significant difference table bonferroni means separation tests study schedule grouping mean technique optimal fep addtl brch total brch addtl fep total stmt total stmt addtl random untreated df mse critical value minimum significant difference tcas grouping mean technique optimal stmt total fep total brch total fep addtl brch addtl stmt addtl random untreated df mse critical value minimum significant difference tot info grouping mean technique optimal fep addtl fep total brch addtl brch total stmt total stmt addtl random untreated df mse critical value minimum significant difference programs grouping mean technique optimal fep addtl fep total brch total stmt total brch addtl stmt addtl random untreated df mse critical value minimum significant difference study siemens programs apfd measured relative mutants threats external validity empirical study faulty versions provided siemens programs represent small subset faults occur practice programs 
discuss threats validity studies section threat addressed performing additional studies additional varieties faults 
step direction second study investigated application prioritization techniques siemens programs measuring apfd relative set mutant versions programs 
study design study 
subject program applied prioritization techniques sample test suites obtaining prioritized test suites 
retained original test suites untreated controls analysis considered prioritized technique 
calculated apfd values prioritized test suites relative mutant versions programs statistical data sets 
note mutant version consisted base version single mutation applied 
column entitled number mutants table indicates number mutant versions considered number ranged schedule replace 
presents boxplots apfd values categories prioritized test suites program program total 
similar apfd values calculated different faulty versions base program mutant versions program 
table presents results applying bonferroni means separation tests data 
examining table apparent non control techniques produce improvements apfd values test suites comparison prioritization random prioritization 
similar study considering results additional total fep prioritization outperformed prioritization techniques optimal results vary somewhat individual programs 
similar study branch coverage techniques performed better corresponding statement coverage techniques exception tcas total statement prioritization outperformed total branch prioritization 
study total statement coverage prioritization performed better additional statement coverage 
relationship hold branch coverage prioritization additional branch coverage outperformed total branch coverage 
study study randomly prioritized test suites outperform untreated test suites 
study space apfd measured relative actual faults third empirical study investigated application prioritization techniques space measuring apfd relative set actual faults provided program 
applied prioritization techniques sample test suites yielding prioritized test suites 
retained original untreated test suites controls analysis considered prioritized reader familiar mutation analysis may wonder presence equivalent mutants mutant versions siemens programs affect apfd calculations 
fact equivalent mutants effect apfd calculations apfd calculations measure rate detectable faults revealed test suite 
print tokens print tokens replace schedule schedule tcas tot info programs apfd boxplots study vertical axis apfd score program technique 
techniques untreated random optimal stmt total stmt addtl branch addtl fep total fep addtl 
print tokens grouping mean technique optimal brch addtl fep addtl stmt addtl brch total fep total stmt total random untreated df mse critical value minimum significant difference print tokens grouping mean technique optimal fep addtl brch addtl stmt addtl stmt total fep total brch total random untreated df mse critical value minimum significant difference replace grouping mean technique optimal fep addtl fep total brch addtl stmt addtl stmt total brch total untreated random df mse critical value minimum significant difference schedule grouping mean technique optimal fep addtl stmt addtl brch addtl fep total stmt total brch total untreated random df mse critical value minimum significant difference table bonferroni means separation tests study schedule grouping mean technique optimal fep addtl fep total stmt total brch total stmt addtl brch addtl untreated random df mse critical value minimum significant difference tcas grouping mean technique optimal fep addtl fep total stmt total brch addtl brch total stmt addtl random untreated df mse critical value minimum significant difference tot info grouping mean technique optimal fep addtl brch addtl fep total brch total stmt addtl stmt total random untreated df mse critical value minimum significant difference programs grouping mean technique optimal fep addtl fep total brch addtl brch total stmt total stmt addtl random untreated df mse critical value minimum significant difference space apfd boxplot study 
techniques untreated random optimal stmt total stmt addtl branch total branch addtl fep total fep addtl 
space grouping mean technique optimal fep addtl stmt total fep total branch total branch addtl stmt addtl random untreated df mse critical value minimum significant difference table bonferroni means separation tests study technique 
calculated apfd values prioritized test suites relative actual faults provided space statistical data sets 
presents boxplots apfd values categories prioritized test suites space 
earlier studies analyzed differences apfd means program results table 
examining table apparent prioritization techniques produced improvements apfd values test suites compared random prioritization 
techniques additional fep prioritization outperformed techniques 
significant difference coverage techniques total fep prioritization 
study study randomly prioritized test suites untreated test suites indistinguishable 
earlier studies distinctions statement coverage techniques total additional coverage variants 
space apfd boxplot study 
techniques untreated random optimal stmt total stmt addtl branch total branch addtl fep total fep addtl 
space grouping mean technique optimal fep addtl branch addtl stmt addtl fep total branch total stmt total random untreated df mse critical value minimum significant difference table bonferroni means separation tests study study space apfd measured relative mutants final study investigated application prioritization techniques space measuring apfd relative set mutants program 
applied prioritization techniques sample test suites obtaining prioritized test suites 
retained original untreated test suites controls analysis considered prioritized technique 
calculated apfd values prioritized test suites relative mutant versions space versions mutant statistical data sets 
examining table apparent prioritization techniques produce improvements apfd values test suites 
additional fep prioritization outperformed techniques 
study branch statement coverage techniques indistinguishable studies additional coverage techniques outperform techniques relatively large margin 
threats validity section discuss potential threats validity studies 
types threats consider threats construct validity concern measurements constructs interest phenomena underlying independent dependent variables threats internal validity concern supposition causal relation phenomena underlying independent dependent variables threats external validity concern ability generalize results 
construct validity construct validity deals issue measuring purport measuring 
studies measurements rate fault detection apfd values highly accurate apfd possible measure rate fault detection 
example measures assign value subsequent test cases detect fault detected inputs may help debuggers isolate fault reason worth measuring 
apfd measures account possibility faults test cases may different costs 
want measure rate detection measure percentage test cases prioritized test suite run faults detected 
ultimately apfd partially captures aspects effectiveness prioritization need consider measures purposes assessing effectiveness 
threat construct validity fep prioritization techniques concerned involves fep calculations 
fep values intended capture probability test case statement statement contains fault test case expose fault 
mutation analysis provide estimate fep values estimates precise increase effectiveness fep techniques 
empirical measurements focused measures effectiveness prioritization techniques measuring cost 
arguments favor approach stated worst case analyses provide information useful assessing relative costs may situations version specific prioritization explicit cost information helpful empirical studies costs useful assessing cost benefits tradeoffs situations 
internal validity greatest concern respect internal validity studies instrumentation effects bias results 
source effects faults prioritization apfd measurement tools 
reduce likelihood effects performed code reviews tools validated tool outputs small tractable program lines versions test suites siemens test suites 
instrumentation effects caused differences test process inputs code tested locality program changes composition test suite 
time control effects related types test suites structure subject programs locality program changes 
limit problems related applied prioritization algorithm test suite subject program 
external validity threats external validity studies centered issue representative subjects studies 
siemens programs nontrivial small larger programs may subject different cost benefit tradeoffs 
space real program program 
threats validity concern faults faulty versions programs study 
faults placed siemens programs synthetic seeded 
faults space real faults reportedly discovered development faults development may differ faults independent test faults represent set faults development team program 
studies mutants faults consider wider set types faults mutants represent class faults occur practice represent certain class faults 
source threats involves decision single fault versions decision facilitated experimentation measurements practice faults may occur different distributions 
threats involve test cases test suites 
branch coverage adequate test suites represent variety test suites constructed siemens programs mix functional code coverage test cases may represent distribution test cases occur practice 
similar statement applies test suites space constructed mix randomly generated code coverage test cases 
general threats external validity addressed additional studies additional subjects 
studies process continue 
additional discussion practical implications keeping mind threats validity empirical studies data analysis provide insights effectiveness test case prioritization generally relative effectiveness prioritization techniques examined 
discuss insights possible implications practical application test case prioritization research prioritization 
greatest practical significance data analysis indicates test case prioritization substantially improve rate fault detection test suites 
heuristics examined produced improvements case schedule study test suites produced heuristic outperform untreated randomly prioritized test suites 
results extended larger space program 
study case including space additional fep prioritization outperformed prioritization techniques coverage 
cases specific coverage techniques outperformed additional fep prioritization cases additional fep prioritization top performer total gain apfd large 
results run contrary initial intuitions suggest expense depending testing process additional fep prioritization may cost effective coverage techniques 
considering results siemens programs branch coverage techniques performed better corresponding statement coverage techniques suggesting cost factors coverages equal branch coverage techniques better choice 
space difference occur 
considering differences total additional branch statement coverage techniques clear winner 
total coverage techniques outperform additional coverage techniques siemens programs 
worst case costs total branch statement coverage prioritization factor test suite size worst case costs additional branch statement coverage prioritization results suggest cases expensive total coverage prioritization schemes may cost effective additional coverage schemes 
result extend fully larger realistic program space fact space study additional total coverage techniques significantly different study additional coverage techniques outperformed total coverage techniques wide margin 
initial investigation space suggests difference may due fact relatively high percentage original faults space occur relatively frequently executed paths mutants space construction relatively evenly distributed code statements 
average total coverage prioritization tends paths times prior attempting reach obscure paths 
increases probability total coverage prioritization reveal faults paths earlier testing additional coverage prioritization driving apfd score total coverage prioritization 
study observed randomly prioritized test suites typically outperformed untreated test suites 
conjecture difference due type test suites faults study 
described section test suites siemens programs generated greedily selecting test cases test pools order test cases added suites process constitutes untreated order 
suspect process caused test cases added ends test suites cover average harder reach statements test cases added beginnings test suites 
faults provided siemens programs relatively hard detect disproportionate number reside harder reach statements detected test cases added test suites added earlier 
random prioritization essentially redistributes test cases reach expose faults test suites cause faults detected quickly 
different results obtained studies support conjecture 
faults second fourth studies widely distributed program statements faults study faults second third fourth studies include mix faults relatively easy detect faults relatively difficult detect 
expect faults detected frequently test cases ends untreated test suites randomizing suites redistribute fault revealing test cases evenly 
experiences untreated test suites noteworthy implications raise empirical studies need aware implications conducting studies 
described techniques prioritizing test cases regression testing empirically examined relative abilities improve quickly faults detected regression testing 
results suggest techniques improve rate fault detection test suites result occurs sophisticated expensive techniques 
studies fep techniques due expense techniques significance primarily researchers study techniques necessary determine cost effective 
results respect code coverage techniques immediate practical implications suggesting code coverage techniques testing leveraged additional gains prioritization 
results studies suggest avenues 
intend perform additional studies programs types test suites wider range distribution faults 
apfd measure provides benchmark compare prioritization techniques measures possible intend empirically investigate measures 
second analysis revealed sizable performance gap prioritization heuristics optimal prioritization fep techniques bridge gap investigating alternative techniques 
alternative involves simpler mutation prioritize test cases total mutation score number additional mutants expose 
possibility involves employing alternative estimates fault exposing potential measure static dynamic dependencies code 
prioritization techniques investigated extended incorporate forms information 
instance prioritization techniques consider information probabilities modifications 
techniques incorporate static measures fault proneness may useful 
techniques account differing test case fault costs accurately reflect practical tradeoffs 
third differences performance various prioritization techniques investigated differences performance total statement coverage total branch coverage mandate study factors underlie relative effectiveness various techniques 
desirable outcome study techniques predicting particular programs types test suites classes modifications prioritization techniques effective 
test case prioritization problem general facets investigated 
example considered possible prioritization objective objectives listed section interest 
examined general prioritization techniques version specific techniques interest 
processes combine regression test selection minimization prioritization may cost effective 
investigation confined prioritization regression testing may beneficial order tests initial creation initial testing software 
results reported areas hope provide software practitioners cost effective techniques improving testing regression testing processes prioritization test cases 
supported part nsf faculty early career development award ccr oregon state university nsf award ccr ohio state university oregon state university 
siemens corporate research supplied siemens programs 
alberto frankl filip provided space program test cases 
toto assisted statistical analysis 
qiang liu contributed early discussions 
anonymous reviewers provided suggestions helpful insightful 
weyuker 
automatic generation load test suites assessment resulting software 
ieee transactions software engineering september 
ostrand 
automatic generation test scripts formal test specifications 
proceedings rd symposium software testing analysis verification pages december 
ball 
limit control flow analysis regression test selection 
proceedings acm international symposium software testing analysis pages march 
beizer 
software testing techniques 
van nostrand reinhold new york ny 
binkley 
semantics guided regression test cost reduction 
ieee transactions software engineering august 
chen lau 
dividing strategies optimization test suite 
information processing letters march 
chen rosenblum vo 
testtube system selective regression testing 
proceedings th international conference software engineering pages may 

tool assessment test adequacy programs 
proceedings conference performability computing systems pcs pages new brunswick nj july 
demillo lipton 
hints test data selection help practicing programmer 
computer april 
freund 
sas linear models guide anova glm procedures 
sas institute cary nc 
garey johnson 
computers intractability 
freeman new york 

dynamic impact analysis cost effective technique enforce error propagation 
proceedings acm international symposium software testing analysis pages june 
hamlet 
testing programs aid compiler 
ieee transactions software engineering se july 
hamlet 
probable correctness theory 
information processing letters april 
harrold gupta soffa 
methodology controlling size test suite 
acm transactions software engineering methodology july 
harrold rothermel 
aristotle system research development program analysis tools 
technical report osu tr ohio state university mar 

sas introductory guide 
sas institute 

weak mutation testing completeness test sets 
ieee transactions software engineering se july 
hutchins foster ostrand 
experiments effectiveness controlflow test adequacy criteria 
proceedings th international conference software engineering pages may 
leung white 
insights regression testing 
proceedings conference software maintenance pages october 
leung white 
study integration testing software regression integration level 
proceedings conference software maintenance pages november 
munson 
detection fault prone programs 
ieee transactions software engineering may 
offutt lee rothermel 
experimental determination sufficient mutation operators 
acm transactions software engineering methodology april 

tsai 
regression testing industrial environment 
communications acm may 
ostrand 
category partition method specifying generating functional tests 
communications acm june 
ott 
statistical methods data analysis 
pws kent publishing boston ma third edition 
weyuker 
selecting software test data data flow information 
ieee transactions software engineering april 
rothermel harrold 
analyzing regression test selection techniques 
ieee transactions software engineering august 
rothermel harrold 
safe efficient regression test selection technique 
acm transactions software engineering methodology april 
rothermel harrold hong 
empirical study effects minimization fault detection capabilities test suites 
proceedings international conference software maintenance pages november 
rothermel chu harrold 
test case prioritization empirical study 
proceedings international conference software maintenance pages august 
thompson richardson clarke 
information flow model fault detection 
proceedings acm international symposium software testing analysis pages june 
voas 
pie dynamic failure technique 
ieee transactions software engineering august 
frankl 
pythia regression test selection tool textual differencing 
proceedings rd international conference reliability quality safety software intensive systems may 
frankl 
empirical evaluation textual differencing regression testing technique 
proceedings international conference software pages november 
wong horgan london agrawal 
study effective regression testing practice 
proceedings eighth international symposium software reliability engineering pages november 
wong horgan london mathur 
effect test set minimization fault detection effectiveness 
software practice experience april 
wong horgan mathur 
test set size minimization fault detection effectiveness case study space application 
proceedings st annual international computer software applications conference pages august 

