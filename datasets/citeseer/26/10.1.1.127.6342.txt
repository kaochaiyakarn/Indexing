transactors programming model maintaining globally consistent distributed state unreliable environments john field ibm watson research center watson ibm com introduce transactors fault tolerant programming model composing loosely coupled distributed components running unreliable environment internet systems reliably maintain globally consistent distributed state 
transactor model incorporates certain elements traditional transaction processing allows elements composed different ways need central coordination facilitating study distributed fault tolerance semantic point view 
formalize approach calculus extended lambdacalculus actor model illustrate usage number examples 
calculus incorporates constructs distributed processes create globally consistent checkpoints 
provide operational semantics calculus formalize safety liveness properties show globally consistent checkpoints equivalent execution traces node failures application level failures second show possible reach globally consistent checkpoints provided bounded failure free interval checkpointing occur 
categories subject descriptors programming languages language constructs features concurrent programming structures logics meanings programs semantics programming languages operational semantics process models operating systems reliability checkpoint restart faulttolerance programming techniques concurrent programming distributed programming general terms languages reliability design theory keywords distributed state transactor tau calculus actor permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
popl january long beach california usa 
copyright acm 
carlos varela department computer science rensselaer polytechnic institute cs rpi edu 
motivation distributed systems maintain distributed state 
mean states distributed components network connected system interdependent 
classical example scenario bank transaction involving transfer money account ensure possible presence system failure account corresponding credit account vice versa 
ensuring interrelated states maintained consistent way wide area network transmission latencies may high node link failures relatively common occurrences difficult 
exposing key semantic concepts related maintenance distributed state common wellfounded language issues system middleware composite distributed applications reason failure semantics components appropriate supply extra protocol layers logging rollbacks retries replication add additional reliability 
better illustrate complexity maintaining distributed state loosely coupled distributed system consider collection web services combined dynamically manage purchase house 
purchase complex multi step transaction involving interacting participants 
today steps required purchase house entail tedious requests responses information telephone calls faxes documents 
possible virtually information generated process exchanged managed electronically 
depicts subset operations performed collection web services involved negotiation house purchase serve illustrate issues arise building infrastructure support services 
consider services concurrent processes send receive messages processes spawn new processes 
negotiation may involve failure subsequent recovery sub processes 
vertical bars labeled represent web services acting behalf buyer seller respectively 
represent web services appraisal service title search service respectively 
represent sub processes spawned appraisal service search service specifically manage interaction particular buyer example 
horizontal arrows depict messages sent processes creation new processes 
portions vertical process bars black represent stable states state maintained process subsequently change 
process rollback arising various forms failure depicted dashed diagonal arrows 
example depicted fig 
generates estimated price specifications size house age provided electronically 
typical transactions elements process proceeds optimistically assumption initial specifications correct human verifies site inspection electronic specifications accurate 
case inspector discovers inconsistency actual specifications provided electronically causes appraisal process rolled back restarted correct specifications 
system reconcile fact components distributed state inconsistent mortgage application initiated buyer information inaccurate appraisal bring full system back consistent state 
consistent state restored requests price information returns message indicating mortgage approved 
point state inconsistent information original price returned approved updated price generated rollback initial state 
transactor model serves maintain dependence information needed detect semantic inconsistencies depicted fig 
cause rollback process occur automatically 
addition semantic failures process network failures course transaction cause information loss requires orderly re establishment transaction distributed state 
note certain steps transaction title search need semantic system failure results search unaffected inconsistent appraisal values 
steps committed early process steps final transfer purchase price require mutual agreement multiple parties reached durable binding 
describe transactor model fault tolerant programming model composing loosely coupled distributed components running unreliable environment internet systems reliably maintain consistent distributed state 
model concerned certain aspects traditional acid transactions isolation certain forms atomicity 
features scope explicitly coded model desired manner similar focus ensuring consistency distributed state presence certain types node network failures 
particular assume node fails stopping reverting programmatically defined checkpoint saved stable storage restarting 
remainder structured follows section introduces related 
section informally describes transactor model 
section introduces syntax calculus extended lambda calculus actor model 
section illustrates representative transactor examples 
section provides operational semantics calculus 
section formalizes safety liveness properties model 
reader referred complete proofs 
section concludes discussion potential directions 

related transactor model actor model introduced hewitt refined developed agha req 
search new req 
price new specs verify specs req 
price price search ok req 
specs offer 
appr 
price req 

house purchase scenario involving semantic failure rollback sub process due inconsistent information house specifications 
ultimately results rollback process due inconsistency price initiate buying process differing price incorporated mortgage approval sub process 

actors inherently independent concurrent autonomous enables efficiency parallel execution facilitates mobility 
actor model languages provide useful framework understanding implementing open distributed systems 
traditionally distributed state maintenance viewed primarily systems middleware problem system infrastructure message passing provides guaranteed message delivery unreliable network substrate distributed databases transaction systems support illusion shared atomically updatable state multiple nodes 
number projects underway realize distributed programming models internet web services model exchange xml data 
distributed transaction management systems implement xa system neutral transaction api typically require participants transaction coordinate pre designated transaction manager transaction defined points 
properties difficult build open distributed systems topology system determined dynamically scope need transaction situation dependent transactional non transactional components easily interact 
existing foundational languages concurrent lesser extent distributed systems actors calculus join calculus mobile ambients formalisms provide primitives reasoning consistency distributed state presence failures developed 
liskov argus language incorporates constructs maintenance distributed state nested transactions 
liskov introduced principal abstractions guardians actions 
argus essentially provides programming interface centrally managed nested transactions 
contrast transactors intend new uniformly model variety failure management techniques including transactions applications weaker consistency semantics 
haines designed extension ml modularly support class transactions 
atomicity isolation durability properties composed desired 
concerned distributed state consistency durability explicitly model isolation 
atomicity transactor inherited actor model transactor represents unit concurrency processes message time 
actor abstractions synchronizers provide atomicity actions performed groups related actors 
duggan abstractions fault tolerant global computing include groups correlated processes fail atomically logs persistent storage 
berger honda provide extension calculus model phase commitment protocol 
motivation similar approaches quite different 
transactor model assume atomicity process group failures transactors fail independently causal dependencies carried messages ensure globally consistent checkpoints reached application level protocols 
calculus enables reasoning composing modules different transactional semantics reliability properties 
preliminary account ideas underlying transactor model published contained correctness proofs 
shares ideas earlier semantic components calculus updated simplified 

transactor model goal transactor model enable developing reliable systems composed potentially unreliable components may suffer system failures application specific semantic inconsistencies 
show checkpointed global states distributed system related execution trace containing inconsistent states resulting node failures application level failures lost messages exists equivalent execution trace containing message losses 
programmers model need reason possibility lost messages forms failure 
transactors extend actor model explicitly modeling node failures network failures persistent storage state immutability 
transactor encapsulates state communicates transactors asynchronous message passing 
response message transactor may create new transactors send messages transactors modify internal state 
addition inherited actor operations transactor may stabilize checkpoint rollback 
transactor stabilization commitment modify internal state immutable subsequent checkpoint performed peer actor causes rollback due semantic inconsistencies 
stabilization thought phase phase commitment protocol 
checkpoint serves purposes commitment current transactor state persistent able survive local temporary node failures second important consistency guarantee pending dependencies volatile state peer transactors 
dependence information carried messages globally consistent states checkpointed 
checkpoint thought second phase phase commitment protocol 
rollback operation brings transactor back previously checkpointed state disappear 
node failures similar effect 

tau calculus calculus extended untyped call value lambda calculus terms depicted fig 

basic lambda calculus constructs standard comment 
extensions divided categories terms ea encode traditional actor semantics explicit state management additional constructs support distributed state maintenance 
section give brief intuitive tour calculus constructs defer detailed discussion semantics section 
traditional actor constructs transactor creation construct trans init creates new transactor behavior initial state 
behavior evaluate abstraction term intuitively term evaluates incoming message created transactor 
expression returns transactor name fresh value subsequently target message send construct send construct sends message contents transactor named ready construct indicates transactor waiting process incoming message 
self yields transactor name 
setstate construct imperatively updates transactor state value message send potentially introduce causal dependency sender target transactor target transactor modifies state response message 
transactor committed change state execution setstate effect expression setstate returns boolean value indicating state update took place 
getstate retrieves value state 
state maintenance constructs stabilize construct causes current transactor ignore subsequent setstate rollback expressions stable fact communicated underlying operational semantics transactors current transactor corresponds effect promise transactor peers transactor attempt change state 
note entering stable state stabilize construct transactor process messages simply change state 
checkpoint construct creates checkpoint effectively copy transactor current state recovered event certain failures 
checkpoint current transactor dependent volatile state transactors 
state potentially unrecoverable presence node failures 
dependent 
construct tests case 
rollback construct causes transactor revert previous checkpoint exists causes transactor disappear 
setstate construct rollback construct effect transactor stable 
defined forms fig 
depicts number defined forms provide convenient syntactic sugar writing calculus programs 
constructs self explanatory deserve explanation true false nil 
atoms 
natural numbers 
transactor names 
variable names 
primitive operators values lambda abstraction pair constructor ep pure expressions lambda application fst element pair snd second element pair fi conditional letrec ni recursive definition 
primitive operator ea traditional actor constructs ep trans init new transactor send message send ready ready receive message self name setstate set transactor state getstate retrieve transactor state transactor expressions ea checkpoint failure resilient rollback revert prev 

stabilize prevent state changes dependent 
test dependence terms 
construct yields lambda abstraction body processes incoming messages 
messages assumed take form vector parameters atom constitutes message name 
body tests value incoming message processes message arguments appropriately messages understood ignored 
construct declares names transactor state presumed consist vector elements 
construct expand core calculus expression simply defines static name scope subsequent form expand appropriate operations transactor state vector 

transactor examples section illustrate representative transactor programs 
refer reader additional examples 
cells simple cell reliable versions thereof providing progressively refined notions consistent state different failure interaction assumptions 
cell program shown volatile cell gets checkpointed tolerate process failures programs depend cell value able reach consistent states checkpoint 
program attempt provide cell invariant checkpoint current value able recover process failures 
creation receive initialize message creates initial checkpoint 
notice needs stable succeed checkpointing 
notice creator cell needs stable checkpoint succeed 
reception set message cell modify value checkpoint 
checkpoint assumes transactor sending set message stable vec 
en 
en nil vec nil vec 
xn seq fv fi nil fi ni 
xn ni fst 
xn fst snd 
snd ni 
ni ni fv msg msg msg msg msg 
xn en esac 
msg ni 
xn en ni ready fi 
fi ready sta 
un declaration names elements state sta ui 
xi getstate xi ni ui ith name declared closest statically enclosing scope length sta ui setstate 
ui ui 
un ui ith name declared closest statically enclosing scope length defined forms 
create spurious dependencies cell state assignment 
reception get message cell needs stabilize ensure new dependencies incurred cell customer 
preserve invariant just checkpointed volatile message reception final checkpoint 
program builds previous example considers possibility clients setting value cell may volatile unstable state 
case cell set message handler checks outstanding dependencies updating state transactor dependent transactors rolls back previously known consistent state 
strictly reliable sense considers interaction potentially volatile clients 
electronic money transfer traditional electronic money transfer example depicted fig 
implemented transactors protocol similar classical phase commit protocols 
teller represents atm machine similar coordinator transfer cell trans contents set val contents val get customer send data contents customer esac init trans contents initialize stabilize checkpoint set val contents val stabilize checkpoint get customer stabilize send data contents customer checkpoint esac init trans contents initialize stabilize checkpoint set val contents val dependent 
rollback stabilize checkpoint fi get customer stabilize send data contents customer checkpoint esac init progressively refined cell 
leftmost example unreliable cell 
middle persistent cell assumes stable clients 
rightmost cell represents persistent reliable cell 
bankaccount transactors assume persistent checkpointed initially assume teller exclusive access accounts 
isolation locking needed ensure exclusive access managed appropriate auxiliary transactors 
basic protocol example quite simple 
teller sends appropriate account adjustment requests account 
account separately determines able fulfill request 
stabilizes sends done result message teller 
sends done error message teller rolls back 
teller received done messages stabilizes requests account send ping message peer account teller 
note point protocol teller idea update successful assuming interpreting messages returned done 
transactors rolled back due insufficient funds spontaneous failure ping messages incorporate inconsistent dependence information effectively resulting rollback received 
absence failure transactor eventually receive sufficient ping messages checkpoint operation succeed point checkpoint op 
protocol fig 
ensures transfer complete consistent state accounts updated appropriately left unchanged 
protocol deal directly certain combinations message losses easily augmented adding timer transactor periodically re sends ping requests participants checkpointed 
note easily interpose transactor participants need know parties involved part transaction model enables compose services full transaction semantics services transactional behavior seamless correct manner 

operational semantics section provide operational semantics calculus 
need establish notational conventions 
notational preliminaries notation sequel standard 
cover concepts standard 
grammars sets 
define sets context free grammars non terminal grammar represent set terms derivable non terminal 
lists 
set denote set lists defined denotes empty list ls denotes list cell 
frequently 
en shorthand denote 
en 
len denotes length denotes list consisting elements len 
finite maps 
sets denotes set finite partial maps dom ran denote domain range respectively 
denote empty map denote element maps denote map mapped denote map dom 
shorthand 
map function ran ran 
shorthand map 

want apply selected elements map map comprehension expressions dom generate new maps obvious way 
multisets 
set denotes set multisets bags consisting collections elements denote multiset union 
multiset comprehension expressions generate new multisets obvious way multiple instances generate number instances 
denote multiset instance removed 
bankaccount trans bal delta atm bal bal delta bal send done funds atm rollback stabilize send done balance update successful atm fi requester send ping requester ping may cause rollback checkpoint esac init teller trans acks transfer delta send delta self send delta self done msg send println msg stdout acks acks acks stabilize send send send self send self fi ping may cause rollback checkpoint esac init savings checking electronic money transfer example 
illustrates nontrivial stabilize protocol similar phase commit 
note ping messages communicate status stable rolled back implicitly checkpoints resulting receipt ping messages succeed peer transactors stabilized op pings received peers cause rollback peer inconsistent 
pattern matching 
writing rules comprising operational semantics transactors various pattern matching constructs determine applicability particular rule match components terms variables 
addition usual convention building patterns applying term constructors variables additional pattern related conventions underscore character matches term 
pattern matches map dom matches variable bound map pattern matches multiset case bound arbitrary element bound multiset reduction contexts transition rule operational semantics refer particular redex term lambda term encoding transactor behavior 
standard lambda calculi notion reduction contexts form distinguish redex transition rule operate 
reduction context special term single hole element defined transactor behavior uniquely decomposed exactly redex reduction context 
definitions redex reduction context completely standard covered 
transactor configurations fig 
depicts collection semantic domains calculus operational semantics manipulate 
volatility value encodes fact transactor volatile stable 
value referred incarnation 
history encodes checkpoint history transactor 
history lh encodes fact transactor refers volatility value checkpointed len lh times creation values list lh reflect incarnation checkpoint occurred 
calculus semantics defines operations histories 
transactor created history initialized 
transactor history lh rolls back incarnation incremented history lh 
transactor history lh checkpoints history lh 
transactor history lh stabilizes history lh dependence maps critical auxiliary structures informally thought encoding states transactors value depends 
precisely dependence map maps transactor name defined history value associated dependence maps associated distinct semantic components transactor transactors dependent existence creation dependence map transactors current state depends state dependence map transactors value current redex depends behavioral dependence map 
separating transactor dependences components distinguish dependences related creation related state radically different semantic consequences avoid creation spurious dependences transactor reads state 
transactor tuple containing components volatile state component contains current state say volatile value lost event failure 
contrast persistent state component encodes value stored checkpoint operation state resilient failure models stable storage 
behavior fixed response incoming message represented order formed lambda expression 
evaluation state component expression generally partially evaluated representing current volatility value transactor history dependence map transactor message name service transactor configuration semantic domains 
state evaluation transactor behavior 
state dependence map component dependence map encodes fact state dependent transitively states transactors dom histories encoded map 
creation dependence map component similar records information transitive dependence parent transactor initially created 
behavioral dependence map component represents behavioral dependences transactor dependences current redex evaluation 
note commas semicolons separate components transactor 
semantic distinction purely syntactic convention designed separate transactor components semicolon separated logical clusters easier reading 
clusters represent respectively persistent durable components survive failures volatile components generally survive failures dependence information 
message contains target transactor name encoding message destination value representing message payload dependence map encoding transitive closure transactors message payload dependent 
transactor configuration pair consisting network multiset messages nameserver map transactor names transactors 
network serves buffer messages sent transactors configuration 
multiset representation network encodes fact order messages sent transactor received unrelated order sent sender 
history dependence map operations section define number auxiliary operations histories dependence maps related structures required operational semantics 
basic history operations 
defining basic operations histories 
lh history 
stable notated volatile 
lh nonempty checkpointed persistent notated ephemeral 
empty history denoted 
relations histories 
define relations histories transition rules operational semantics calculus 
relations satisfying conditions lh lh rolls back lh lh rolls back lh lh stabilizes lh lh checkpoints represent valid single step transitions history associated single transactor encodes fact transactor rolled back 
volatile transactor roll back case rolled back spontaneously due node failure inconsistent state stable transactor second case rolls back state inconsistent 
transition encodes fact transactor stabilized encodes fact transactor checkpointed 
relations functions speak applying history yield new history 
define composite relation succeeded intuitively valid histories transactor say occurs execution trace 
defines partial order histories 
say histories comparable 
relation superseded intuitively history transactor rolled back state represented history proceeded zero additional operations 
state represented supersedes obsolete state represented 
say histories consistent supersedes 
consistent histories define sharpening operation notated follows exists intuitively stable reachable intermediate history stable form sharpening operation yields op 
sharpening operation update dependence information peer transactors stabilized communication 
operations dependence maps 
dependence maps 
invalidated notated exists dom dom 
dependence maps 
union denoted defined follows max dom dom comparable dom dom dom dom undef 
extend sharpening operation histories consistent dependence maps follows dom dom dependence map 
independent notated dom dependent 
characterizing transactors 
transactor bound name transactor configuration say stable volatile 
transactor independent depends unstable transactors dependent 
transactor ready ready busy persistent ephemeral initial non initial 
persistent independent ready initial say resilient 
qualified refer volatile state simply state 
stable independent say daemon 
daemons model humans external agents system send receive messages resilient system 
failure participate global state 
operations configurations 
configuration 
net denote network ns denote nameserver 
domain denoted dom set transactors name service map dom ns 
configuration transactor name dom shorthand transactor ns 
say configuration ready resilient iff dom ready resilient respectively 
transactor configuration transition rules divide transition rules calculus principal classes representing normal transitions form failure allowed message loss node failure transitions representing spontaneous node failures rules designed manage inconsistencies resulting failures 
set normal transitions represented composite transition relation relational union primitive transition rules fig 

transition rules figs 
encode classical semantics actor model 
transition rules fig 
augment classical semantics additional operations managing consistency creating checkpoints 
set node failure transitions represented composite transition relation relational union primitive transition rules figs 

transition rules model spontaneous node failures failures control transactors 
transition rules define semantics program induced failures rollback operation operations handle inconsistencies resulting failures 
denote arbitrary calculus transition sections consider collection rules turn 
number transition rules may appear somewhat daunting initially believe encodes semantically orthogonal component calculus semantics reasonably natural way 
pure reduction rules 
fig 
depicts set standard pure reduction rules lambda terms encoding transactor behaviors 
rules imported classical actor calculus transition rules depicted fig 

transition rules basic actor semantics 
fig 
depicts collection transition rules encode semantics actor model 
semantics loosely modeled semantics agha significantly different treatment state 
rules fig 
rules pur pur fst pur snd pur true fi pur false fi pur letrec ni letrec ni pur 
vn 
vn sequel relation pure reduction rules 
single step transition relation trans actor configurations 
single step transitions annotated name applicable rule distinguished transactor name relation said apply 
transactor configuration maps transactor name transactor convenient refer name consider rule turn 
pure rule applies pure reduction rules depicted fig 
behavior transactor 
new rule creates new transactor behavior initial state persistent state initially nil checkpointed 
state dependence map initialized refer transactor dependent information may appear redundant avoids technical problems transactor sends messages things convenient way encode continuations performed checkpoints 
creation dependence map dependence map union creation dependences behavioral dependences creating transactor mapping creating transactor 
map encodes transactors states creation transitively dependent 
note behavioral dependence map updated encode dependence newly created transactor 
contravariant dependence critical ensuring persistent state transactor refer ephemeral transactor 
send rule encodes act sending message payload vm transactor 
message tagged creation behavioral dependences sender transactor dependence 
carries information transactors transitively dependent 
note necessary incorporate state dependences sender included behavioral dependence map state read 
rcv rule encodes message receipt 
note messages selected network component configuration nondeterministically 
model assumes guaranteed message delivery guarantee order delivery 
preconditions rule ensure received message invalidates state creation receiver invalidated preconditions hold absence failures rules addressing failure preconditions addressed 
result message receipt behavioral dependences updated contain dependences received message behavior lambda expression applied message 
current state creation dependence maps updated sharpening operation reflect new information dependences contained arriving message 
particular need determine previously volatile transactors dependent stable 
get set rules model retrieving setting state model single possibly composite cell 
note case rule get updated behavioral dependence map encodes dependence state symmetrically rule set adds information behavioral dependence map update state dependence map things semantics ensures transactor update state course processing message transactor previously dependent dependent self rule encodes retrieval transactor name 
core transactor transition rules 
rules depicted fig 
augment basic actor transitions fig 
additional rules managing distributed state follows set rule causes expression setstate ignored target transactor stable encodes promise peer transactors voluntarily update state roll back may rolled back due inconsistencies 
sta sta rules encode stabilization operation 
stabilization inhibits state updates rollback operations rules set rol renders transactor resilient spontaneous failure due absence rules failures fig 
prerequisite checkpointing rule chk 
rule sta applies transactor currently volatile simply updates transactor history reflect fact stable 
rule sta encodes fact stabilization op transactor stable 
chk chk rules encode checkpoint operation 
preconditions rules chk chk determine received messages transactors dependent indicating transactors stabilized checkpointed relevant dependent states 
checkpoint operation succeeds rule chk volatile state stored persistent state history updated reflect checkpoint state dependences reset creation behavioral dependence maps reset 
addition storing volatile state persistently dependence map resetting performed checkpoint operation effect bounding amount dependence information tracked checkpoints 
resetting creation dependence map implies map non empty ephemeral transactors 
preconditions checkpointing hold rule chk causes behave ready 
rol rule rol encodes fact programmatic rollback disallowed stable case rollback behaves ready 
dep dep rules determine dependent non stable transactors 
lose rule models fact normal circumstances messages may lost sent 
assume losses relatively rare may initially odd message loss element normal transactor behavior 
part consequence global consistency semantics trades possibility global inconsistency possibility message loss transforming programmer burden reasoning global failures knowledge general reasoning local failure form lost messages 
practical matter programs running systems guarantees message delivery effectively reason possibility message loss typically incorporate time outs deal protracted message latencies indistinguishable losses 
failure transitions 
rules depicted fig 
model spontaneous node failure caused faults 
realistic systems rules applied far frequently non failure rules 
fl rule models transient node failure persistent volatile transactor 
cases state transactor reverts stored persistent state state dependence information reinitialized 
rule assumes persistent transactor capable checkpointing intermediate states stable storage restoring checkpoints failure reboot software recovery 
fl rule models permanent node failure ephemeral transactor annihilated 
rule models systems checkpoint intermediate states stable storage systems assumed fail stopping permanently 
note transactor stable failure rule applies 
means practice program counter intermediate evaluation states stable transactor behavior logged persistent storage 
may onerous requirement expect number intermediate states computations performed stable transactor minimal 
optimizations possible minimize overhead requirement practice deferring side effects message sends transactor creations cause executed local acid transaction short duration 
transactor rules managing inconsistency 
final collection rules depicted fig 
encode programmatic rollback manage inconsistencies result explicit rollback inconsistencies due incoming messages 
inconsistency management rules follows rol rol rules rol encode rollback operation 
rule rol encodes fact programmatic rollback disallowed stable case rollback behaves ready 
rule rol encodes fact ephemeral non checkpointed transactor rolls back disappears annihilated things behavior allows certain transactors dispose done 
rule rol encodes fact rollback resets volatile state stored persistent state addition state creation behavioral dependences reinitialized 
rcv rule applies dependences associated incoming message invalidated state creation dependences associated occurs message depends earlier incarnation dependent transactor 
case message ignored ensure global consistency 
rcv rule applies dependences associated incoming message supersede state dependences creation dependences associated persistent 
cases effectively rolled back ensure global consistency result rule rol 
rcv rule applies ephemeral transactor state creation dependences invalidated incoming message 
case roll back checkpoint roll back annihilated ensure global consistency 

formal properties section define means system calculus behaved 
particular prove certain soundness liveness properties appropriate calculus 
soundness show trace transition sequence containing node failures inconsistencies equivalent normal trace containing node failures possibly message losses 
show checkpointing possible assuming pure evaluate pure redex 
pure new create new transactor 
trans init new nil ready dom send send message piggybacking dependence information 
send vm send vm nil rcv message dependences invalidated transactor transactor dependences invalidated message process message normally 
sc sc vm ready rcv vm get retrieve state 
getstate get set transactor volatile setting state succeeds 
setstate set true self yields name 
self self certain reasonable preconditions 
need preliminary definitions 
preliminary definitions traces 

rm set binary relations 
rm refer composite relation basis set primitive relations 
general primitive relations represent single step transition relations operational semantics 
basis set primitive relations say orthogonal basis set 

rn set primitive relations composite relation refer possibly empty sequence primitive relations set trace 
initial value trace ri ri 
rim orthogonal basis set exists unique sequence 
xm ri ri rim xm case trace refer sequence relations ri ri 
rim sequence values 
xm feel free treat set values 
xm convenient 
note adopt convention value sequence represented includes initial element transition sequence final element 
frequently notation xm trace composite relation denote empty trace len denote length trace 
configuration formedness 
section define means transactor configuration sensible respect history annotations 
transactor arbitrary transactor name 
set histories associated denoted histories transition rules encoding basic actor semantics 
defined histories sc note set necessarily singleton creation dependent checkpointed version current state different version 
network arbitrary transactor name 
set histories associated denoted histories defined histories formed transactor configuration transactor dom 
principal history denoted history defined history configuration 
set dependent node histories denoted defined dom histories yields set histories nodes exception principal history 
configuration transactor dom garbage transactor say configuration formed iff conditions hold 
dom dom history 

history set transactor stable attempt set state fails 
setstate set false sta transactor volatile stabilization causes stable 
stabilize sta nil sta transactor currently stable stabilize op 
stabilize sta nil chk transactor stable independent checkpoint succeeds 
checkpoint chk ready chk transactor dependent volatile checkpoint simply behaves ready 
checkpoint chk ready rol transactor stable rollback simply behaves ready 
rollback rol ready dep transactor independent yields false 
dependent 
dep false dep transactor dependent yields true 
dependent 
dep true lose message loss 
lose transition rules encoding basic transactor semantics 
fl spontaneous failure volatile persistent transactor causes rollback 
fl spontaneous failure volatile ephemeral transactor causes annihilated 
nil fl words configuration formed transactor history state dependence map creation dependence map empty checkpointed 
addition transactor principal history histories associated transactors lemma formedness preservation 
formed configuration configuration formed 
proof 
straightforward induction len 
configuration consistency 
section define notions consistency transactor configurations 
inconsistent fl ready transition rules modeling spontaneous failures 
rations correspond transactors states inconsistent due node failures 
transactor 
composite dependence map notated maps defined maps configuration dom transactor name 
composite dependence map notated maps defined maps maps 
configuration say transactor dom consistent respect exists dom maps history 
words dependent transactor state currently inconsistent similarly message ns consistent respect exists dom history 
rol transactor volatile ephemeral rollback causes transactor annihilated 
nil rollback rol rol transactor volatile persistent rollback reverts state contents persistent state saved checkpoint 
rollback rol ready rcv message dependences invalidated transactor vice versa discard message 
sc sc ready rcv ready sc rcv state dependences creation dependences invalidated message transactor persistent transactor rolls back 
vm ready rcv ready rcv state creation dependences invalidated message transactor ephemeral transactor annihilated 
sc sc nil ready rcv transition rules programmatic rollback consistency management 
say nameserver consistent dom consistent 
formed network consistent consistent 
configuration network consistent net consistent respect node consistent ns consistent respect configuration consistent network consistent node consistent 
configuration equivalence modulo history 
section define simple notion transactor equivalence oblivious certain inconsequential differences dependence information 
histories predecessor history reversion operation revert defines new history operations represented occur revert exists definition critical defining node failure free trace corresponding trace node failures represents set failing operations transactor extract operations trace update histories revert 
transactor name history transactor configuration 
defined follows vm vm dom recall shorthand map similarly maps 
trace denote trace resulting replacing configuration 
transactor consistent configuration history 
revert 
relation read equivalence modulo history defined equivalence relation satisfying relation weak form configuration equivalence akin equivalence lambda calculus structural congruences process calculi 
idea configurations identical certain inconsequential differences dependence information behave identically 
fact embodied lemma lemma behavior equivalent configurations 
configurations trace 
exists 
proof 
straightforward induction len definition 
cycle properties 
trace 
nonempty trace sequence primitive transitions form transitions applicable transactor named cycle terminating transition primitive transition rule takes form ready words cycle terminating transition causes transactor evaluation state ready results annihilation transactor 
trace cycle trace cycle terminating transition 
lemma cycle decomposition 
formed ready configurations 
exists trace form 
tn ti ti cycle possibly empty message loss trace form lose 
refer trace cycle decomposition 
proof 
induction len 
define total ordering transactor names 
permute pairs primitive non loss transitions consistent total ordering permute loss non loss pairs 
resulting trace desired form 
simulation node failures preceding definitions position prove arbitrary calculus traces simulated traces containing node failure free subset calculus 
require key lemma lemma simulation 
formed configurations traces 
sets transactor names 
network multiset messages 
assume 
satisfy conditions 
resilient network consistent 

node consistent 

dom history history initial 

dom 


dom dom 
history 


net net inconsistent respect exists configuration trace proof 
induction length cycle decomposition 
full details may companion technical report 
position prove main simulation theorem theorem simulation node failures 
formed resilient consistent configurations 
exists 
proof 
follows directly lemma 
define variables premise lemma follows 
unique trace 

definitions premises lemma trivially theorem follows immediately lemma 
proof theorem effectively shows global reasoning state inconsistencies reduced local reasoning possibility message loss 
universal checkpointing critical calculus property liveness possible reach global checkpoints transactor model operational semantics 
course transactor programs reach global checkpoints 
trivial program transactor sends messages introducing dependencies stabilizes tries checkpoint eliminate ability dependents reach checkpoints 
introduce universal checkpointing protocol ucp assumes set preconditions entail global checkpointing set transactors prove preconditions protocol terminates global checkpoint reached 
definition ucp preconditions 
set transactors transitive closure dependencies transactors elements depend transactors depend forth 
transactors need keep set acquaintances acq state checkpoint time creation including names transactors target messages sent 
transactors created 
parent transactor 
transactors need eventually stabilize start universal checkpointing protocol 
transactors need able receive ping messages 
transactor stabilizes transactors programmatically rollback caused rollback transactors assumes previous application dependent communication provides guarantee 
failures universal checkpointing protocol place 
definition universal checkpointing protocol 
transactor stabilizes pings transactor acq ii 
checks dependent pings transactor acq checkpoints ends protocol 
pings transactor acq waits incoming pings 
iii 
reception ping message goes back ii 
theorem universal checkpointing property 
universal checkpointing protocol ucp terminates ucp preconditions proof 
omitted due space limitations details may companion technical report 

discussion introduced formal framework understanding managing distributed state presence various classes failures 
internet scale distributed computing important grid mechanisms web services increases 
believe order develop robust applications settings necessary incorporate state management constructs flexible traditional transaction mechanisms 
addition failure free simulation universal checkpointing properties number additional aspects calculus worthy study 
example show certain application properties topologies allow specialized checkpointing techniques 
trivial example consider transactor application reads update state transactor initially checkpointed easily show checkpoint requiring message exchanges interestingly define various failure rates scenarios show situations configurations able progress reasonable fairness assumptions despite failures 
number interesting directions research build ideas developed including modeling transactional compensation mechanisms consistency maintained reversal actions rolling back previous states modeling isolation atomicity modular way studying type systems statically constraining dependences exposing various failure modes developing techniques optimizing dependence information modeling additional classes failures 

acknowledgments gratefully acknowledge insightful comments james leifer carolyn talcott maria cristina anonymous referees 

agha 
actors model concurrent computation distributed systems 
mit press 
agha varela 
agent naming coordination actor models infrastructures 
omicini zambonelli klusch tolksdorf editors coordination internet agents models technologies applications chapter pages 
springer verlag mar 
agha mason smith talcott 
foundation actor computation 
journal functional programming 
berger honda 
phase commitment protocol extended pi calculus 
prelim 
proc 
express ns pages 
brics notes 
bernstein 
middleware model distributed system services 
communications acm 
birman renesse 
reliable distributed computing isis toolkit 
wiley ieee computer society press 
cardelli gordon 
mobile ambients 
foundations system specification computational structures lncs pages 
springer verlag 
chothia duggan 
abstractions fault tolerant global computing 
electronic notes theoretical computer science entcs 
foundations wide area network computing 
elsevier 
field varela 
programming model building reliable systems distributed state 
electronic notes theoretical computer science entcs 
international workshop foundations coordination languages software architectures 
elsevier 
field varela 
transactors programming model maintaining globally consistent distributed state unreliable environments 
technical report department computer science 
rensselaer polytechnic institute troy ny november 
fournet gonthier 
reflexive cham join calculus 
proc 
acm symp 
principles programming languages pages 
fr lund 
coordinating distributed objects actor approach synchronization 
mit press 
gray reuter 
transaction processing concepts techniques 
morgan kaufman 
haines morrisett nettles wing 
composing class transactions 
acm trans 
program 
lang 
syst 
hewitt 
viewing control structures patterns passing messages 
journal artificial intelligence june 
kim agha 
efficient support location transparency concurrent object oriented programming languages 
proceedings supercomputing 
liskov 
distributed programming argus 
communications association computing machinery 
milner parrow walker 
calculus mobile processes parts ii 
information computation 
spector pausch 
flexible distributed transaction processing system 
proc 
ieee computer society international conf pages san francisco march 
ieee computer society press 
talcott 
composable semantic models actor theories 
higher order symbolic computation 
van renesse birman maffeis 
horus flexible group communication system 
communications acm 
world wide web consortium 
web services activity statement 
www org ws 
open limited 
distributed transaction processing xa specification 
open limited 
open cae specification xo cae 
