ieee transactions software engineering vol 
october temporal logic query checking tool model exploration arie chechik member ieee computer society temporal logic query checking introduced chan order speed design understanding discovering properties known priori 
query temporal logic formula containing special symbol known placeholder 
kripke structure propositional formula say satisfies query replacing placeholder results temporal logic formula satisfied kripke structure 
solution temporal logic query kripke structure set propositional formulas satisfy query 
query checking helps discover temporal properties system useful tool model exploration 
show query checking applicable variety model exploration tasks ranging invariant computation test case generation 
illustrate cruise control system 
additionally show query checking instance multi valued model checking chechik approach enables build implementation temporal logic query checker top existing multi valued model checker 
allows decide large class queries introduce witnesses temporal logic queries essential notion effective model exploration 
index terms ctl query checking model checking model understanding multi valued logic 
temporal logic model checking allows decide property stated temporal logic ctl holds model :10.1.1.111.7245
typical temporal logic formulas ag hold state system state followed state holds model checking originally proposed verification technique 
complete specifications typically available start design analysis phase 
key properties attempt model checker validate 
properties hold seldom fault properties design 
typically need modified design bug properties strong incorrectly expressed 
verification process aimed building correct model system discovering properties 
closely linked process model exploration model understanding understanding behavior model properties preserves reasons preservation 
temporal logic query checking introduced chan order speed design understanding discovering properties known priori 
query temporal logic formula containing special symbol known placeholder ag ag 
kripke structure propositional formula say satisfies query replacing placeholder results temporal logic formula satisfied kripke authors department computer science university toronto toronto canada 
mail arie chechik cs toronto edu 
manuscript received mar accepted apr 
recommended acceptance griswold 
information obtaining reprints article please send mail tse computer org ieeecs log number 
ieee published ieee computer society structure 
example satisfy query ag evaluated model fig 

solution temporal logic query kripke structure set propositional formulas satisfy query 
query checking want restrict atomic propositions answer 
example may care value invariant computed model fig 

phrase question ag fp qg explicitly restricting propositions interest solution query includes expressions 
fixed set propositions interest query checking problem defined solved propositional formulas set substituting placeholder verifying resulting temporal logic formula results returning set maximally strong solutions 
refer approach naive direct solution 
number propositions interest provides way control complexity query checking practice terms understanding result terms computation 
chan proposed number applications query checking aimed giving feedback user model checking providing partial explanation property holds diagnostic information 
example checking evaluate query ag fa bg 
suppose answer ag holds model 
inform user stronger property explain thata invariant query checking gather diagnostic information ctl formula hold 
example ag req af ack false request followed acknowledgment ask follow request ag req af 
temporal logic query checking tool model exploration fig 

simple state machine 
complexity general query checking problem looked infeasible chan concentrated valid queries queries solutions derivable single solution 
complexity query checking valid queries atomic propositions exponential opposed double exponential general case 
chan showed general expensive determine ctl query valid 
identified set syntactic restrictions guaranteed resulting ctl query valid 
implemented query checker valid queries single placeholder top symbolic model checker smv 
hand queries valid 
suppose interested exploring successors initial state model fig 

example holds states starting initial state results incomparable sets solutions 
know state successors different values 
furthermore successors holds 
clearly queries useful model exploration 
bruns godefroid provide mechanism computing solutions arbitrary queries single placeholder occurring negative positive position query extended alternating automata eaa 
examples queries ex positive position ef ex negative position 
schnoebelen study problem efficiently producing maximally strong solutions positive queries single placeholder 
algorithm computes solution linear number calls model checker solutions quadratic number calls model checker methods queries specified temporal logics ctl knowledge methods implemented 
range applications query checking expanded limit queries just placeholder 
particular queries placeholders allow ask questions pairs states dependencies current state system 
example suppose interested exploring transition relation model fig 

achieve forming query ef ex compute pairs reachable states may want produce complete set test cases cover transition relation model 
solving query insufficient need paths state model 
problem addressed query checker return witnesses paths model explain solution computed 
show query checking applicable variety model exploration tasks ranging invariant computation test case generation 
tasks require witness computation depend 
illustrate specification cruise control system 
additionally show query checking instance multi valued model checking generalization classical model checking problem classical logic arbitrary de morgan algebras finite distributive lattice operation preserves involution de morgan laws 
approach enables build implementation temporal logic query checking tool top existing symbolic multi valued model checker 
implementation computes witnesses temporal logic queries 
encoding proposed gives formal framework extending query language include multiple dependent independent placeholders occurring positive negative positions query 
examples queries decide ag ax ag ax 
query placeholders independent 
second dependent instance positive position negative position 
allows study complexity query checking symbolic representation point view 
note approach similar proposed bruns godefroid query checking problem decided extended alternating automata 
raise level abstraction reduction works independently implementation multi valued model checking machinery eaa decision diagrams benefit approaches implementation 
rest organized follows section give necessary background fix notation 
section defines language queries 
section describes implementation query checker 
section variety model exploration tasks 
describe multi valued model checking solving queries single multiple placeholders respectively sections address complexity issues section 
conclude section summary directions 
background section provide background information lattice theory fix notation briefly outline ctl model checking describe multi valued ctl model checking 
fundamentals give basics lattice theory review concept join irreducibility define upward sets 
definition 
lattice partial order finite upper bound called join written tb greatest lower bound called meet ieee transactions software engineering vol 
october fig 

lattices set fpg pf pf pf 
written ub 
maximum minimum elements lattice respectively 
lattice ordering operation clear context refer furthermore finite lattices considered 
definition 
lattice distributive lattice elements uc tb tc tc ub uc definition 
set atomic set propositional formulas example pf fpg ftrue false pg 
set forms finite distributive lattice implication see fig 

true pis true lattice 
meets joins lattice correspond logical operations respectively 
definition 
ordered set upward closure lj example ordered set pf fpg shown fig 
fp pg fp trueg 
definition 
upward closed upset fp pg upset fp trueg write set 
note closed union intersection forms lattice ordered set inclusion 
call lattice lattice upset lattice pf fpg shown fig 
element encoded upset 
singleton sets write fag 
leta elements lattice tb distribution meet vb proposition 
lattice distributive 
note pf distributive set atomic propositions 
fig 

formal semantics ctl operators 
definition 
subset lj downward closed refer sets write lattice lattice pf fpg ordered set inclusion fig 

definition 
lattice join irreducible ty xor words join irreducible decomposed join elements lattice 
example join irreducible elements lattice fig 
ftrueg fp trueg trueg trueg 
denote set join irreducible elements lattice 
element finite lattice uniquely decomposed join join irreducible elements 
theorem 
element lattice 
fj jjv note case lattice propositional formulas pf join irreducible element conjunction literals example join irreducible elements pf fp qg proposition 
set join irreducible elements lattice isomorphic lg ctl model checking ctl model checking automatic technique verifying properties expressed propositional branching time temporal logic called computation tree logic ctl 
model kripke wheres set states total transition relation initial state set atomic propositions labeling function providing set atomic propositions hold state 
ctl properties evaluated tree infinite computations produced 
formal semantics ctl fig 

function ftrue falseg indicate result checking formula states 
define set successors states fs rg 
familiar notation indicating property holds temporal logic query checking tool model exploration kripke defined follows true false say formula holds kripke holds initial state 
fig 
conjunction disjunction place familiar universal existential quantification 
semantics alternatively expressed ex ax note definition preserves duality ax operators ax ex 
semantics eu fig 
greatest fixpoints respectively 
alternatively define path trace states sequence si si define equivalent semantics eu exists paths si exists paths sj si remaining ctl operators af ef ag ef example consider model fig 
wheres initial state anda fp rg 
true model axp 
define fragments ctl existential fragment ectl allows existential temporal operators dual universal fragment actl allows universal temporal operators 
fragments restrict application negation atomic propositions 
easy see ectl property holds model exists witness collection paths property true 
dually actl property fails hold model explained counter example collection paths negation property true 
multi valued model checking multi valued ctl model checking generalization model checking problem classical logic arbitrary de morgan algebra finite distributive lattice operation preserves involution de morgan laws 
conjunction disjunction defined meet join operations respectively 
algebra get 
necessarily law 
excluded middle 
ordering negation operation algebra clear context refer model checking problem extended number ways transitions kripke structure allowed take values algebra propositions kripke structure evaluated element algebra lattice values introduced constants ctl 
general theory multi valued model checking allows extensions combinations described 
purpose assume multi valued model checking problem model remains classical transition relation atomic propositions valued lattice values allowed appear constants temporal logic formulas 
properties specified multi valued extension ctl called ctl 
de morgan algebra ctl syntax ctl extends scope allowable constants ftrue falseg itis assumed boolean values true false occurring model mapped lattice respectively 
boolean formulas interpreted de morgan algebra 
semantics ctl ctl exception interpretation constants operations defined ctl counterparts see fig 
interpreted lattice respectively 
fact rest write place follows write mean 
ctl formula ctl formula vice versa 
example ctl formula pf fpg formula ctl 
multi valued model checking reduced classical model checking problems 
recall element lattice uniquely decomposed elements 
solution ctl property kripke structure obtained solving wj join irreducible element lattice composing results 
reduction comes theorem 
theorem 
de morgan algebra ctl formula join irreducible exists ctl formula called cut wj case ctl formula obtained follows lattice value replace true wj false 
example cut ag respect ag true ag false respectively 
furthermore ctl formula ctl cut ctl formula 
theorem shows combine results cuts obtain solution multi valued model checking problem 
ieee transactions software engineering vol 
october theorem 
de morgan algebra ctl formula 
ji ji ji example cut ag true cut false model checking solution hand cuts true solution fp pg 
de morgan algebra complexity model checking ctl formula kripke structure iso jsj provided meets joins quantification operations take constant time 
language queries section review query checking fundamentals define language queries 
queries placeholder set propositional variables pf defined section set propositional formulas definition 
temporal logic query single placeholder denoted expression containing symbol replacing propositional formula yields ctl formula 
note definition allows multiple occurrences placeholder symbol query 
example ag ax valid queries single placeholder 
denote set temporal logic queries placeholder 
denote substituting propositional formula placeholder query 
write kripke mean variables solution 
name explicitly 
convenience write fp qg placeholder restricted fp qg ag fp qg 
query implicitly explicitly restricts set variables substituted placeholder 
definition 
substitution satisfies query state true 
example satisfies query ag state model fig 
satisfies query ag fp qg 
definition 
solution states denoted set substitutions pf satisfy state kripke structure query thought function ftrue falseg 
refer set variables restricting placeholder var 
solutions formed elements pf var abusing notation refer 
placeholder appear multiple places query occurrence restricted set propositional variables 
example ag fp qg fp legal ag fp qg fp rg ur 
definition 
query positive solution solution 
example solution words set solutions positive query set propositional formulas upward closed respect implication ordering propositional formula element solution weaker formula 
set possible solutions queries upset lattice pf defined section 
note means solution positive query uniquely represented set maximally strong propositional formulas satisfying 
follows refer set set maximally strong solutions 
set maximally strong solutions singleton say fpg say strongest solution 
simplicity presentation assume queries negation normal form negations appear front atomic propositions placeholders 
say occurrence placeholder query negative preceded negation 
occurrence positive 
theorem 
query positive occurrence positive 
definition 
query negative occurrence negative 
query mixed positive negative 
example query ag positive query ef negative query ag ef mixed 
note function pf 
ftrue falseg monotone positive negative queries 
refer set positive negative queries monotone queries 
set possible solutions negative queries lattice pf defined section 
similarly positive queries solution negative query uniquely represented set weakest propositional formulas satisfying referred set weakest solutions 
queries multiple placeholders number interesting model exploration properties ones section formed queries just single placeholder 
extend query language include multiple independent placeholders 
denote set queries placeholders substitution query multiple placeholders tuple propositional formulas placeholder 
query placeholders pf lattice propositional formulas ith placeholder set possible substitutions cross product pf pf 
set forms lattice implication ordering lifted pointwise elements example pf pf pf pf iff temporal logic query checking tool model exploration placeholder refer name variables restricting name var respectively 
rest notation section trivially extends queries multiple placeholders 
query positive negative mixed placeholder 
query positive negative monotone positive negative monotone placeholder 
queries monotone referred mixed 
example ag ax positive monotone ag ag ax mixed 
table summarizes different types queries addressed 
column comments chan indicate queries decided chan approach bruns godefroid approach respectively 
note approach subsumes 
example positive valid queries solved chan approaches general positive queries solved approach 
decision procedures query types marked new technical contributions 
addition comments column includes sections describe solutions corresponding types queries 
example monotone queries multiple addressed section 
queries witnesses ectl formula holds model witness trace model showing formula holds 
similarly witness existential query set traces showing solutions satisfies query 
example consider model fig 

maximally strong solutions witness consists traces maximally strong solution shown fig 

trace corresponds solution meaning trace explains propositional formulas satisfy query 
trace corresponds solution table summary types queries traces comprising witness query start initial state represented tree 
addition branch tree labeled set propositional formulas membership solution set illustrated branch 
example fig 
left branch labeled right benefit treating witness tree set independent traces possible prefer certain witnesses 
example may prefer witness traces longest common prefix usually results minimizing total number traces comprising witness 
temporal logic query checker section describe design implementation temporal logic query checker 
architecture fig 

implemented java top ctl model checker ctl reduction technique section section 
symbolic ctl model checker provides support model checking fairness generation witnesses counter examples 
kripke structure model de morgan algebra ctl formula returns element algebra corresponding value initial state model represented variety modeling languages particular smv modeling language supported 
internally decision diagram packages symbolic state space representation 
particular algebraic decision fig 

witness ex fpg model fig 

ieee transactions software engineering vol 
october fig 

architecture 
diagrams add known multi terminal binary decision diagrams part state art cu decision diagram package 
witness generation facility handled interactive witness visualization exploration tool 
presents witnesses graphically presenter layout exploration 
addition simply browsing witnesses user define number strategies exploration forward backward setting step granularity choosing witnesses size branching factor uses combination black box 
temporal logic query smv model converts query corresponding ctl formula 
model resulting formula passed model checking 
answer witness returned transformed multi valued logic sets propositional formulas user 
consider example query ex fpg evaluated state kripke structure fig 
witness shown fig 

screen shot displaying witness fig 

presentation follows proof style state nodes double lines labeled proof steps depend 
double lines correspond transitions kripke structure single lines indicate dependencies proof nodes state nodes 
example proof node labeled ex fpg connected states required explain solution 
copy tool please send mail cs toronto edu 
applications experience section show different techniques model exploration temporal logic queries 
technique section uses solutions problem essentially extension methodology proposed chan solving queries multiple placeholders positive negative positions 
technique section completely new fact addition computing solution query provide witness explaining 
examples fig 

presentation witness ex fpg 
section experience exploring scr specification cruise control system described section 
please refer table running time various queries section 
cruise control system ccs cruise control system ccs responsible keeping automobile traveling certain speed 
driver accelerates desired speed presses button steering wheel button activate cruise control 
cruise control maintains car speed remaining active events occurs 
driver presses brake pedal brake 

driver presses gas pedal accel 

driver turns cruise control button 

engine stops running running 

driver turns ignition ignition 

car speed uncontrollable toofast 
events listed occur driver cruise control system previously set speed pressing resume button button 
addition system keeps track number miles car traveled determine due service oil air filter need replaced 
case study functional part scr specification ccs done kirby 
scr method specify event driven systems 
system outputs called controlled variables computed terms inputs environment called monitored variables system state 
represent state scr uses notion sets states called modes partition monitored environment state space 
system changes state result events changes monitored variables 
example event formalized indicates true state true current state 
prime variables refer values state 
version ccs monitored controlled variables cc 
specifying ccs major assumptions features scr method terms temporal logic query checking tool model exploration table mode transition table mode class cc cruise control system condition tables ensured variables system boolean enumerated type ease model checking 
particular referring speed maintained ccs sp des speed car sp veh defined predicates toofast car speed control sp veh max speed speed fast sp veh sp des threshold speed slow sp veh sp des threshold speed ok sp des threshold sp veh sp veh sp des threshold cc described table 
row mode transition table specifies event activates transition mode left mode right 
system starts mode ignition false transitions mode inactive ignition true 
formally events change ignition mode transition occur time ignition cc ignition cc inactive 
order facilitate computation state scr method assumes monitored variable change time interval single input assumption partial order dependencies variables system 
table shows event table throttle 
throttle assumes value indicating throttle accelerating position speed slow system mode cruise shown table event table controlled variable throttle row table system returns mode cruise indicated speed determined slow see second row table 
applications queries witnesses converted scr specification cruise control system smv format tool sc 
analyze resulting model questions symbolic ctl model checker smv show temporal logic queries help express reachability properties discover system invariants transition guards 
reachability analysis common task model exploration finding states reachable 
example ccs may want know modes cc reachable 
easily solved checking series ef properties 
example ef cc cruise holds mode cruise reachable 
queries provide concise representation solution single query ef corresponds reachable modes cc pi true 
example solution fcc cc cruise cc inactive cc includes modes modes reachable 
similarly finding possible values throttle ieee transactions software engineering vol 
october system mode cruise accomplished query ef cc cruise throttle solution throttle toff 
complex analysis done combining ef queries ctl operators 
example query ef cc ex find modes follow ex determine pairs modes follow query ef cc cruise ex cc inactive explore values toofast inactive change system goes modes cruise inactive 
discovering invariants invariants concisely summarize complex relationships different entities model useful identifying errors 
original motivations query checking chan 
discover invariants simply need solve query ag placeholder restricted atomic propositions model 
unfortunately trivial models solution query big effectively 
easy restrict attention different parts model 
example set invariants mode inactive respect variables ignition running solution query ag cc inactive evaluates ignition 
furthermore multiple placeholders find invariants mode single query 
example solution query ag table running time queries cruise control system corresponds invariants individual mode respect variables ignition running 
example solution cc cruise ignition running indicates ignition running remain true system mode cruise 
query help analyst determine invariants shared modes 
solution cc inactive cc cruise cc override ignition see ignition stays true mode inactive invariant modes cruise override 
mode invariants ccs restricted variables ignition brake toofast running able discover query checking shown table 
equivalent invariants discovered algorithms 
notice strength invariants obtained query checking depends variables placeholder restricted 
example result query ag cc cruise strongest invariant mode cruise table stronger 
strongest invariants table mode invariants cruise control system temporal logic query checking tool model exploration obtained restricting placeholder monitored variables system 
combining reachability invariant computation results interesting queries 
example determine modes cc globally reachable find reachable modes system stay forever 
guard discovery illustrate queries discover guards 
example know change environment prompted mode transition cc cc inactive 
clearly guards enable transitions modes easily obtained examining scr tables row table see mode transition caused ignition 
guards readily available scr tables converted kripke structure format smv 
reverse engineer event tables discovering guards resulting kripke structure 
formally guard defined weakest propositional formula current pre post states invariant holds preand postconditions respectively 
notice define guard weakest solution guard directly correspond scr event 
show scr events discovered combining guards mode invariants 
guards defined pre placeholders required express query discover making guard weakest solution query ag ax 
show query discover event causes ccs switch mode cruise inactive 
case cc cruise cc inactive furthermore restrict placeholders set running 
note include ignition invariantly true modes see table 
solving query obtain weakest solutions brake toofast running true true running toofast analyzing result note solution violates invariant mode cruise see table making antecedent implication false second solution follows table sequence events guided simulation ag cc cruise ax running toofast cc inactive holds yielding guard running toofast combining invariant mode cruise determine mode transition guarded independent events running toofast just indicated mode transition table 
applications queries witnesses applications query checking witnesses 
guided simulation easiest way explore model simulate behavior providing inputs observing system behavior outputs 
impossible simulation guide exploration objective 
wrong choice inputs simulation result system evolving uninteresting behavior 
example objective exploration ccs evolves different modes 
case guess set inputs results system evolving mode cruise set inputs yields transition mode inactive process exploring system simulation usually slow error prone 
interesting alternative simple simulation guided simulation 
guided simulation setting user provides set objectives demonstrated simulation needs guess inputs cases objective met single execution system 
choice set objectives satisfies 
query checking natural framework implementing guided simulations 
objective existential query witness serves basis simulation 
example suppose want devise set simulations illustrate ccs evolves modes 
formalize objective query ef explore witness 
indicate prefer witnesses longest common prefix results single trace system going modes inactive cruise override 
trace corresponds simulation sequence events table 
objective achieved single trace simulation generated completely automatically requiring user input 
ieee transactions software engineering vol 
october test case generation primary goal model checking verify model temporal properties generate test cases 
proposed techniques fact addition computing values properties model checker produce witnesses counter examples construct test sequences 
properties force model checker generate desired test sequences called trap properties 
heitmeyer proposed method uses scr specification system identify trap properties satisfying form branch coverage testing criterion 
technique uses mode transition condition tables generate test sequences 
illustrate method mode transition tables tables analyzed similarly 
method assures form branch coverage satisfying rules mode mode transition table test event mode test case mode change change 
example test sequences need generated mode testing event ignition testing change case 
obtained trap properties ef cc ex cc inactive ef cc ex cc alternatively test sequences obtained witness single query ef cc ex 
similarly set test sequences cover full mode transition table obtained witness query ef ex 
traces comprising witness query generated time possible minimize number different test sequences guarantee full coverage mode transition table 
query minimal solution query checker produce minimal solution necessary witness soon 
cases complexity model checking precludes obtaining results trap properties query checker produce solution trap properties soon possible 
method suggested generates set test sequences cover change mode system necessarily cover events 
example change mode cruise mode inactive guarded independent events running toofast witness trap query contains single trace corresponding change covering just events 
solution problem examine query witness discover events covered test sequences generate remaining test sequences explicit trap properties methodology 
example witness covers event toofast test sequence covering event running obtained trap property ef cc cruise running ex running cc inactive better solution provided know variables comprising event mode transition additional query 
current example events causing change mode cruise mode inactive depend variables toofast running 
cover events form query ef cc cruise ex cc inactive witness query corresponds test sequences testing change event event running 
deciding temporal logic queries single placeholder turn attention deciding temporal logic queries 
section consider query checking problem positive query single placeholder potentially occurring places query ef fp qg fp fp qg 
show problem instance multi valued model checking problem expressed terms framework described section 
complex class queries considered section 
recall multi valued model checking extension model checking arbitrary de morgan algebra 
case algebra upset lattice propositional formulas see fig 

order reduce query checking multi valued model checking need define syntactic translation positive temporal logic queries single placeholder ctl formulas lattice pf solution ctl formula solution query 
lattice pf basis de morgan algebra 
reduction ctl consider query fpg evaluated model fig 

solving query respect notice ins formulas fpg hold ins implied 
fpg solution query 
arbitrary state kripke structure solution query fpg fpg fpg true pg true ctl formula corresponding query fpg pg 
general solution query restricted arbitrary set atomic propositions iff true temporal logic query checking tool model exploration element pf 
example solution query fp qg states model fig 
fp qg join irreducible lattice pf fp qg true 
syntactic translation query ctl formula lattice pf pf transformation correct solution query state value resulting ctl formula state 
equality follows trivially definition 
think transformation stage transformation 
stage transforms disjunction disjunct corresponds unique element pf 
second stage assigns value lattice disjunct 
values transformation determine model checking lattice case value assigned disjunct pf upward closure principle replace functionf pf maps pf lattice value corresponding solution state satisfying generalized transformation function tf pf define different functions section 
need query set temporal logic queries tf tf translate query just need translate placeholder 
example suppose interested computing ex fp qg state model fig 

apply transformation tf obtain tf ex fp qg fp qg 
expanding tf fp qg get tf fp qg fp qg fp qg qg qg evaluate resulting formula state fp qg tf fp qg tf fp qg qg fp qg fp qg fp qg solution fp qg state model fig 

proof correctness prove transformation fact reduction query checking multi valued model checking 
show kripke structure solution equivalent naive see section solution query checking problem 
proof correctness reduction multi valued model checking classical model checking described section 
algebra ctl formula 
reduction classical ctl computing solutions cut respect join irreducible elements 
case model checking lattice pf elements pf pf avoid confusion join irreducible elements pf translate query ctl formula join irreducible elements ofu pf proof correctness 
start showing value cut ctl prepositional formula tf computed directly classical propositional formula 
prove result tf just intend section 
lemma 
temporal logic query lattice pf tf defined 
tf ji proof 
fji pf jf ji tf theorem tf defn tf fji pf ji join irreducible fji pf ji ji boolean fji pf ji ji boolean fji pf jf ji ut continue define specific properties 
show cut ctl respect join irreducible pf equivalent ctl formula obtained substituting placeholder 
theorem 
positive temporal logic query pf 
proof 
theorem sufficient show 
theorem lemma fji pf fji pf theorem ut ieee transactions software engineering vol 
october theorem establishes correctness transformation positive temporal logic queries placeholder ctl formulas pf 
theorem 
temporal logic query defined 
proof 
theorem proposition pf theorem pf defn fj pf definition deciding complex queries section describe solve nonpositive queries 
start queries multiple placeholders consider negative queries single multiple placeholders deal mixed queries 
queries multiple placeholders reduction ctl query placeholders placeholder 
pf solution query single placeholder 
substitution pf pf satisfies state solution pf 
uses placeholder say solution obtained embedding solution lattice pf pf 
general query pf lattice propositional formulas placeholder set possible substitutions cross pf pf 
lattice implication ordering lifted pointwise elements set solutions positive query byu pf pf 
desired embedding function fi pf defined fi pf pf defn fi element 
translate query translation function tf defined section 
transform query placeholders replacing placeholder turn going result tfi tf tfn defn ut example give example computing solution query placeholders 
evaluate query fp qg ex fp qg state model fig 

example section placeholder fp qg ex fp qg note false pf fp qg 
lifting solution lattice pf fp qg pf fp qg obtain fp qg fp qg ex fp qg fp qg putting yields fp qg fp qg query minimal solutions 
proof correctness section reducing multi valued model checking classical model checking 
case model checking lattice set elements jj lg 
de morgan show cut ctl formula obtained translation tn query respect join irreducible equivalent ctl formula resulting substituting 
correctness approach results theorem 
theorem 
positive temporal logic query ctl defined pf pf 
proof 
theorem sufficient show tn theorem tn defn tn tfi lemma pf jfi jk gjk defn fi upset law pf jk gjk defn pf join irreducible law ut temporal logic query checking tool model exploration theorem 
positive query state kripke structure andt defined 
proof 
proof similar proof theorem 
tu deciding negative queries show nonpositive queries solved transforming positive queries query checking postprocessing result 
negative queries single placeholder start considering query single negated placeholder 
transform positive query removing negations appearing front denoting transformation example ex ex 
proposition formalizes connection negative positive queries 
proposition 
negative query 
proof 
proofs results shown section omitted due space limitations 
tu find solution solving positive query negating resulting substitutions theorem 
negative query 
alternatively query checking negative queries reduced directly multi valued model checking pf lattice downward closed sets pf 
case transform negative query corresponding positive query 
apply transformation tf section wheref pf pf defined asf combining transformations yields transformation tf example consider query fpg states kripke structure fig 

obtain positive query fpg 
apply transformation tf get tf fpg solution ctl formula states model solution required 
theorem 
negative query state kripke structure defined 
monotone queries multiple placeholders technique applied queries multiple negated placeholders 
query negative transformation removes negations front example ex ex ex 
proposition 
query negative ni find solution query negative transform solution case single placeholder 
theorem 
query placeholders negative ai ai ni deciding mixed queries solve mixed query transform monotone query apply query checking algorithm postprocess solution 
mixed query transformed monotone query positive negative replacing positive occurrences negative occurrences follows denote transformation example ex ex note change restrictions placed placeholders pf pf pf 
note thata pf substitution satisfying mixed query substitution satisfying 
yields theorem 
theorem 
query mixed 
fa case negative queries technique solving query single mixed placeholder easily extended queries multiple mixed placeholders 
running time section study complexity symbolic approach query checking 
direct approach query checking take jvar 
possible solutions substitute placeholder check results classical model checking complexity jvar 
complexity deciding valid queries exponential jvar 
despite bad worst case complexities query checking perform practice illustrated table 
symbolic implementation query checking allows analyze running time finer granularity 
particular section show running time query checking depends type query complexity performing operations terminal nodes decision diagrams 
section discuss heuristics aimed improving running time query checkers 
section gives performance results aimed illustrating discussion 
complexity symbolic encoding section showed solution obtained evaluating ctl 
section model checking ctl formula requires jsj jt iterations 
ieee transactions software engineering vol 
october size query defined number temporal logic operators occurring transformation introduce new temporal operators jt iteration model checking algorithm requires computing unions intersections quantification operations 
described section query solved symbolic ctl model checker implemented algebraic decision diagrams adds 
simplify analysis express worst case complexity performing operation terminal nodes add ct stands number propositions restricting placeholder 
unions intersections 
complexity performing add operation linear size argument linear complexity performing operations terminal nodes 
existential quantification 
cost performing existential quantification bdds exponential jaj 
easy show size largest add representing function variables twice size largest bdd variables 
cost existential quantification adds exponential jaj 
quantification implemented series operations complexity linear 
combining arguments get lemma 
worst case solving query single temporal operator kripke structure linear jsj ct jvar exponential jaj 
theorem 
worst case complexity solving arbitrary query kripke structure 
analyze complexity queries multiple placeholders note pf isomorphic lattice propositional formulas jvar atomic propositions 
worst case complexity solving query multiple placeholders expressed relative worst case complexity solving query single placeholder 
theorem 
worst case complexity solving query placeholders kripke structure linear jsj exponential jaj 
ct jvar note worst case complexity query checking dominated ct jvar turn depends number solutions query worst case double exponential jvar possible implementation query checker represent elements ofu pf minimal elements complexity meet join operations quadratic number minimal elements operands 
note set minimal elements solution query exactly set maximally strong solutions 
query maximally strong solutions easier solve query large number maximally strong solutions 
queries states chan valid queries ones case study section jvar jsj maximally strong solutions 
hand queries paths may contain jvar 
maximally strong solutions infeasible small models 
note mean queries paths infeasible illustrated query row table exists model query worst case complexity 
improving complexity bounds refine upper bound complexity theorem noticing usually query built combining ctl fragment fragment containing placeholders 
example solve afa apply ctl model checking result evaluate query 
theorem 
worst case complexity solving query placeholder occurs scope temporal operators worst case complexities query checking model checking formula temporal operator 
complexity queries multiple placeholders reflected theorem 
note simple additional heuristics help improve expected time space complexities query checking 
example constructing decision diagrams quite expensive 
avoided queries 
majority operations performed query checking operands transition relation boolean function 
complexity performing terminal nodes boolean operand iso depend 
experimental results section shown large class queries worst case complexity symbolic ctl model checking solving queries comparable worst case complexity symbolic ctl model checking 
illustrate observations verifying ctl formulas related queries cruise control system summarizing results table 
ctl formulas checked classical logic de morgan algebra 
query second row restricted boolean atomic propositions required encode enumerated type cc 
note running time query double running time corresponding ctl formula row 
similar picture seen comparing ctl formula row query row table 
increasing number variables placeholder depends slow analysis significantly 
comparing queries rows table see observed slowdown marginal 
experiments rows paint similar picture temporal logic query checking tool model exploration illustrating performance changes number placeholders goes 
conducted comprehensive set experiments evaluate running time query checker believe preliminary findings indicate query checking feasible tool variety model exploration applications 
section summarize suggest venues 
summary discussion demonstrated applicability query checking model exploration cruise control system running example 
query checking reachability analysis discovering guards invariants depends able decide queries multiple placeholders guided simulation test case generation require ability produce witnesses temporal logic queries 
convinced temporal logic query checking applications addition ones explored 
particular see immediate applications variety test case generation domains 
recognizing query checking reduced multi valued model checking provided algorithm encoding built tool top existing symbolic multi valued model checker 
implementation allowed generate solutions temporal logic queries provide witnesses explaining answers existential queries 
symbolic representation allows study complexity query checking problem decision diagram point view suggest number optimizations 
table query checking experiments experience applying suggests effectively variety software engineering tasks 
hope reported open venues engineering query checking implementations ensure handle larger problems practical query checking useful tool model exploration analysis 
building query checker top model checker advantages 
allow query checking systems fairness assumptions 
example compute invariants ccs assumption brake pressed infinitely 
far know query checker implemented chan implement fairness 
presentation ctl temporal logic 
multi valued modelchecking temporal logics ltl ctl studied literature framework adopted deciding queries defined logics 
underlying framework calculus easily extend implementation handle calculus queries 
example query propositional formulas hold infinitely useful discovering fairness conditions system analysis 
plan implement heuristics suggested section develop ones 
experiment different decision diagram implementations 
case studies essential assessing feasibility query checking realistic systems 
addition success query checking practice achieved effective methodology 
intend case studies guide development methodology 
ieee transactions software engineering vol 
october acknowledgments authors program committee symposium foundations software engineering fse anonymous tse referees feedback earlier versions 
financial support research provided national science engineering research council canada nserc communications information technology ontario 
clarke grumberg peled model checking :10.1.1.111.7245
mit press 
clarke emerson sistla automatic verification finite state concurrent systems temporal logic specifications acm trans 
programming languages systems vol 
pp 
apr 
chan temporal logic queries proc 
th conf 
computer aided verification cav pp 
july 
bruns godefroid temporal logic query checking proc 
th ann 
ieee symp 
logic computer science lics pp 
june 
mcmillan symbolic model checking 
kluwer academic 
kupferman vardi wolper automata theoretic approach branching time model checking acm vol 
pp 
mar 
schnoebelen solving temporal logic queries proc 
ninth int conf 
algebraic methodology software technology amast pp 

chechik easterbrook model checking multi valued logics proc 
formal methods europe fme pp 
mar 
chechik multi valued model checker proc 
th int conf 
computer aided verification cav july 
davey priestley lattices order 
cambridge univ press 
chechik easterbrook multi valued symbolic model checking acm trans 
software eng 
methodology jan 
chechik multivalued model checking classical model checking proc 
th int conf 
concurrency theory concur sept 
multi valued symbolic model checking fairness counterexamples running time master thesis dept computer science univ toronto oct www cs toronto 
edu chechik pubs ps 
chechik proof counterexamples proc 
ninth int conf 
tools algorithms construction analysis systems tacas pp 
apr 
somenzi cu decision diagram package release vlsi colorado edu fabio 
html 
fujita 
yang multi terminal binary decision diagrams efficient data structure matrix representation formal methods system design int vol 
nos 
pp 
apr 
fr hlich werner graph visualization system user interface applications technical report dept computer science bremen univ citeseer nj 
nec com fr graph html 
dong ramakrishnan smolka model checking evidence exploration proc 
th ieee int conf 
workshop eng 
computer systems pp 
apr 
stevens stirling practical model checking games proc 
fourth int conf 
tools algorithms construction analysis systems tacas pp 
citeseer nj nec com stevens practical html 
kirby example nrl scr software requirements automobile cruise control monitoring system technical report wang inst 
graduate studies oct 
heitmeyer jeffords labaw automated consistency checking requirements specifications acm trans 
software eng 
methodology vol 
pp 
july 
chechik sc usability formal methods proc 
ann 
ibm centre advanced studies conf pp 
nov 
jeffords heitmeyer automatic generation state invariants requirements specifications proc 
sixth int symp 
foundations software eng 
fse pp 
nov 
jeffords heitmeyer algorithm strengthening state invariants generated requirements specifications proc 
fifth ieee int symp 
requirements eng pp 
aug 
automated analysis software requirements phd dissertation univ maryland college park dec 
heimdahl coverage test case generation model checkers proc 
eighth ann 
ieee int conf 
workshop eng 
computer systems pp 
apr 
heitmeyer model checking generate tests requirements specifications proc 
joint seventh european software eng 
conf 
seventh acm sigsoft int symp 
foundations software eng 
esec fse pp 
sept 
engels test generation intelligent networks model checking proc 
conf 
tools algorithms construction analysis systems tacas pp 

hong cha lee ural data flow testing model checking proc 
th int conf 
software eng 
icse may 
chechik easterbrook lai efficient multiple valued model checking lattice representations proc 
th int conf 
concurrency theory concur pp 
aug 
wegener branching programs binary decision diagrams theory applications 
siam 
bruns godefroid generalized model checking reasoning partial state spaces proc 
th int conf 
concurrency theory concur pp 
aug 
arie received bsc msc degrees computer science university toronto respectively currently working phd degree 
research interests lie intersection formal methods software engineering emphasis automated techniques program verification 
chechik received phd degree university maryland joined computer science department university toronto currently associate professor 
main research interests applying formal methods improve quality software 
authored papers formal methods software specification verification model checking requirements engineering 
member ieee computer society 
received bsc degree university western ontario msc degree university toronto currently working phd degree 
principal research interest application logic requirements engineering software engineering 
information computing topic please visit digital library computer org publications dlib 
