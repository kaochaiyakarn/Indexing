application performance flexibility exokernel systems frans kaashoek dawson engler gregory ganger ctor brice russell hunt david mazi res thomas robert grimm john jannotti kenneth mackenzie laboratory computer science cambridge ma www pdos lcs mit edu exokernel operating system architecture safely gives untrusted software efficient control hardware software resources separating management protection 
describes exokernel system allows specialized applications achieve high performance sacrificing performance unmodified unix programs 
evaluates exokernel architecture measuring application performance xok exokernel intel computers comparing xok performance performance widely bsd unix systems free bsd openbsd 
results show common unmodified unix applications enjoy benefits applications perform comparably xok exos bsd perform significantly better 
addition results show customized applications benefit substantially control resources factor web server 
describes insights exokernel approach gained building different exokernel systems presents novel approaches resource multiplexing 
traditional operating systems privileged servers kernel manage system resources 
untrusted applica research supported part advanced research projects agency contract nsf national young investigator award 
robert grimm currently university washington seattle 
copyright association computing machinery permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage new copies bear notice full citation page 
copyrights components owned acm honored 
abstracting credit permitted 
copy republish post servers redistribute lists requires prior specific permission fee 
request permissions publications dept acm fax permissions acm org 
tions restricted interfaces implementations privileged software 
organization flawed application demands vary widely 
interface designed accommodate application anticipate possible needs 
implementation interface need resolve tradeoffs anticipate ways interface 
experience suggests anticipation infeasible cost mistakes high :10.1.1.117.6702:10.1.1.100.6047
exokernel architecture solves problem giving untrusted applications control resources possible 
dividing responsibilities differently way conventional systems 
separate protection management protect resources delegate management applications 
example application manages disk block cache exokernel allows cached pages shared securely applications 
exokernel protects pages disk blocks applications manage 
course applications need customized resource management 
communicating exokernel directly expect programs linked libraries hide low level resources traditional operating system abstractions 
traditional implementations abstractions library implementations unprivileged modified replaced 
refer unprivileged libraries library operating systems 
hope exokernel organization facilitate operating system innovation orders magnitude application programmers os implementors programmer specialize affecting rest system 
allow incremental selective adoption new os features applications link provide need new os functionality effectively distributed application binary 
exokernel approach raises questions 
ambitious applications achieve significant performance improvements exokernel 
traditional applications example unaltered unix applications pay price reduced performance 
global performance compromised centralized authority decides scheduling multiplexing policies 
lack centralized management policy shared os structures lower integrity system 
attempts answer questions evaluate soundness exokernel approach 
experiments performed xok exos exokernel system 
xok exokernel intel computers exos default 
xok exos compiles runs unmodified unix programs perl gcc telnet file utilities 
compare xok exos bsd unix systems running hardware large real world applications 
exos ensures integrity abstractions xok support protected sharing 
abstractions shared global data structures 
exos guarantee unix semantics abstractions protected arbitrary writes processes 
measurements approximate cost protection inserting system calls writes shared global state 
results show unmodified unix applications perform comparably xok exos freebsd openbsd 
applications run factor faster xok exos 
experiments multiple applications running concurrently show offer competitive global system performance 
demonstrate application level control significantly improve performance applications 
example describe new high performance server cheetah actively exploits exokernel extensibility 
cheetah uses file system tcp implementation customized properties traffic 
cheetah performs times faster best unix server measured hardware 
addition evaluating exokernel approach presents new kernel interfaces separate protection management 
discuss disk subsystem xn explain unprivileged applications define new file systems file systems safely multiplex disk fine granularity 
summarize learned building complete exokernel systems xok aegis multiprocessor 
rest organized follows 
section discusses related 
section summarizes exokernel architecture 
section provides detailed example reconciling application control protection presenting disk system xn 
section briefly overviews xok exos experimental environment 
section reports performance unaltered unix applications section reports performance applications high performance cheetah web server 
section investigates global performance exokernel system 
section discusses experiences building different exokernel systems 
section concludes 
related exokernel architecture proposed described research prototype performed significantly better ultrix microbenchmarks 
provided evidence exokernel approach promising left questions unanswered 
large literature extensible operating systems starting classic rationales lampson brinch hansen 
previous approaches extensibility coarsely classified groups better microkernels virtual machines downloading untrusted code kernel 
discuss turn 
principal goal exokernel giving applications control orthogonal question monolithic versus microkernel organization 
applications restricted inadequate interfaces little difference implementations reside kernel privileged user level servers cases applications lack control 
example difficult change buffer management policy shared file server 
ways servers viewed fixed kernel subsystems happen run user space 
monolithic microkernel goal exokernel system remains privileged software provide interfaces limit ability unprivileged applications manage resources 
newer microkernels push kernel interface closer hardware obtaining better performance robustness previous microkernels allowing greater degree flexibility shared monolithic servers broken servers 
techniques reduce cost shared servers improving ipc performance moving code servers libraries mapping read shared data structures batching system calls successfully applied exokernel system 
virtual machines vms os structure privileged virtual machine monitor vmm isolates privileged software emulated copies underlying hardware 
unfortunately emulation hides information 
lead ineffective hardware resources instance vmm way knowing vm longer needs particular virtual page 
vms share resources remote communication protocols 
prevents vms sharing os abstractions processes file descriptors 
vmms confine specialized operating systems associated processes isolated virtual machines applications customized sacrificing single view machine downloading code kernel approach extensibility 
systems trusted users download code dynamically loaded kernel extensions static configuration 
spin vino systems user safely download code kernel 
safe downloading code software fault isolation unix application fd read exos block page 
buffer cache registry specialized application exos subset kernel 
simplified exokernel system applications linked sharing pages buffer cache registry 
exokernel approach separating protection management 
downloading code kernel leave decisions untrusted software 
addition structural approaches done better os abstractions give control applications user level networking lottery scheduling application controlled virtual memory file systems 
directly applicable 
exokernel background section briefly summarizes exokernel architecture 
shows simplified exokernel system running applications unmodified unix application linked exos specialized exokernel application tcp file system libraries 
applications communicate kernel low level physical names block numbers kernel interface close hardware possible 
handle higher level names file descriptors supply abstractions 
briefly describe exokernel principles motivated 
principles illustrate mechanics exokernel systems provide important motivation design decisions discussed 
addition show principles applied discuss general issue protected sharing 
exokernel principles goal exokernel give efficient control resources untrusted applications secure multi user system 
follow principles achieve goal separate protection management 
provide primitives lowest possible level required protection ideally level hardware disk blocks context identifiers tlb 
resource management re functions necessary protection allocation revocation sharing tracking ownership 
expose allocation 
applications allocate resources explicitly 
kernel allows specific resources requested allocation 
expose names 
physical names possible 
physical names capture useful information require potentially costly race prone translations virtual names 
expose revocation 
expose revocation policies applications 
applications choose instance resource give 
application control set physical resources 
expose information 
expose system information collect data applications easily derive locally 
example applications determine hardware network buffers pages cache file blocks 
exokernel record approximate ordering physical pages individual applications global information 
principles apply just kernel component exokernel system 
privileged servers provide interface just required protection 
kernel support protected abstractions resources protected traditional operating systems high level abstractions 
files instance consist metadata disk blocks buffer cache pages guarded access control highlevel file objects 
allow direct access lowlevel resources exokernel systems able provide unix protection including access control high level objects required security 
main challenges designing find kernel interfaces allow higher level access control particular implementation hindering application control hardware resources 
xok meets challenge design techniques 
performs access control resources manner 
second xok provides software abstractions bind hardware resources 
example shown xok buffer cache registry binds disk blocks memory pages caching 
applications control physical pages disk safely cached pages 
xok protection mechanism guarantees process access cache page level access corresponding disk block 
third general xok abstractions allow applications download code 
required abstractions protection map hardware abstractions 
example files may require valid updates modification times 
key exokernel software abstractions hinder low level access hardware resources unduly restrict semantics protected abstractions enable 
properties kernel software abstraction violate exokernel principles 
software abstractions reside kernel xok implemented trusted userlevel servers 
microkernel organization cost additional context switches particularly expensive intel pentium pro processors xok runs 
furthermore partitioning functionality user level servers tends complex 
protected sharing low level exokernel interface gives hardware control implement traditional operating system abstractions 
library implementations abstractions advantage trust applications link need defend malicious 
flip side necessarily trust access particular resource 
guarantee invariants abstractions aware exactly resources involved processes access resources level trust place processes 
example consider semantics unix fork system call 
spawns new process initially identical currently running 
involves copying entire virtual address space parent process task operating systems typically perform lazily copy write avoid unnecessary page copies 
copy write done trusted kernel virtual memory system exercise care avoid compromising semantics fork sharing pages potentially untrusted processes 
section details approaches allow maintain invariants sharing resources 
exokernel provides mechanisms maintain invariants shared abstractions 
software regions areas memory read written system calls provide sub page protection fault isolation 
second exokernel allows fly creation hierarchically named capabilities requires capabilities specified explicitly system call 
buggy child process accidentally requesting write access page software region parent provide wrong capability denied permission 
third exokernel provides wakeup predicates small functions wake processes arbitrary conditions true see section details 
wakeup predicates ensure buggy crashed process hang correctly behaved 
fourth exokernel provides robust critical sections inexpensive critical sections implemented disabling software interrupts 
critical sections locks eliminates need trust processes 
levels trust determine optimizations implementation shared abstraction 
optimize common case mutual trust 
case applications sharing resources place considerable amount trust 
instance unix programs run user arbitrarily modify memory debugger system call ptrace 
exokernel processes write memory clearly trust malicious 
reduces problem guaranteeing invariants security fault isolation consequently allows code resemble monolithic kernels implementing abstraction 
unidirectional trust 
common scenario occurs processes share resources trusts trust mutual 
network servers follow organization privileged process accepts network connections forks drops privileges perform actions behalf particular user 
abstractions implemented mutual trust function unidirectional trust slight modification 
example copy instance trusted parent process retain exclusive control shared pages page tables preventing child child making copied pages writable parent 
requires page faults parent increase number page copies seriously complicate code 
defensive programming mutual distrust 
situations mutually processes share high level abstractions 
instance unrelated processes may wish communicate unix domain socket may trust 
os abstractions shared mutually processes include defensive implementations give reasonable interpretations possible actions foreign process instance socket write larger buffer interpreted file 
fortunately sharing mutual distrust occurs infrequently abstractions 
types sharing occur child parent processes mutual unidirectional trust holds 
mutual distrust occur defensive sanity checks critical path performance 
remaining cases case disk files carefully crafted kernel software abstractions help maintain necessary invariants 
multiplexing stable storage exokernel provide means safely multiplex disks multiple library file systems 
contains 
multiple share files different semantics 
addition accessing existing files define new disk file types arbitrary metadata formats 
exokernel give control file management pos sible protecting files unauthorized access 
rely simple minded solutions partitioning multiplex disk file require partition 
allow perform file management exokernel stable storage system satisfy requirements 
creating new file formats simple lightweight 
require special privilege 
second protection substrate allow multiple safely share files raw disk block metadata level 
third storage system efficient close raw hardware performance possible 
fourth storage system facilitate cache sharing allow easily address problems cache coherence security concurrency 
section describes xok multiplexes stable storage show address problems provide concrete example exokernel principles practice 
describe xn xok extensible low level kernel stable storage system 
describe general interface xn particular ffs locating fast file system 
overview xn designing flexible exokernel stable storage system proven difficult xn fourth design 
section provides overview udfs cornerstone xn sections describe earlier approaches failed aspects xn greater depth 
xn provides access stable storage level disk blocks exporting buffer cache registry section free maps disk structures 
main purpose xn determine access rights principal disk block efficiently possible 
xn prevent malicious user claiming user disk blocks part files 
conventional os task easy kernel knows file metadata format 
exokernel files application defined metadata layouts task difficult 
xn novel solution employs udfs untrusted deterministic functions 
udfs metadata translation functions specific file type 
xn uses udfs analyze metadata translate simple form kernel understands 
developer install udfs introduce new disk metadata formats 
restricted language udfs specified ensures deterministic output depends input metadata 
udfs allow kernel safely efficiently handle metadata layout understanding layout 
udfs stored disk structures called templates 
template corresponds particular metadata format example unix file system templates data blocks inode blocks inodes indirect blocks template udf owns udf untrusted potentially nondeterministic functions acl uf size uf functions specified language owns udf deterministic 
access example time day 
limited language write functions pseudo risc assembly language checked kernel ensure determinacy 
template specified changed 
piece metadata template type owns udf returns set blocks points respective template types 
udf determinism guarantees owns udf compute output input xn spoofed owns udf 
set blocks owns udf returns represented set tuples 
tuple constitutes range block address specifies start range number blocks range template identifier blocks range 
owned sets large xn allows partition metadata blocks disjoint pieces set returned typically single tuple 
example say wants allocate disk block placing pointer metadata structure call xn passing proposed modification specified list bytes write 
enforce protection xn needs know proposed modification says allocates xn runs owns udf proposed modification copy runs owns udf 
verifies new result equal old result plus acl uf function implements template specific access control semantics input piece metadata proposed modification metadata set credentials capabilities 
output boolean value approving modification 
xn runs proper function metadata modification 
acl ufs implement access control lists providing certain guarantees example acl uf ensure inode modification times kept current rejecting metadata changes update 
size uf function simply returns size data structure bytes 
xn problem history difficult requirement xn efficiently determining access rights principal disk block 
discuss successive approaches pursued 
disk block level multiplexing 
approach associate block extent capability access control list guards 
unfortunately capability spatially separated disk block stored separately table accessing block require disk accesses fetch capability fetch block 
caching mitigate problem degree nervous overhead disk intensive workloads 
alternative approach locate capabilities disk blocks placing immediately disk block data 
unfortunately common hardware reserving space capability prevent blocks multiples page size adding overhead complexity disk operations 
self descriptive metadata 
serious attempt efficient disk multiplexing provided means instance metadata describe 
example disk block start number bytes applicationspecific data say integers disk block pointers complexity space efficient self description caused limit metadata described 
discovered approach caused unacceptable amounts space overhead required excessive effort modify existing file system code difficult existing file system data structures universal format 
template description 
self description problems eliminated insight file system built handful different disk data structures considered type 
number types small feasible describe type file system instance type template 
originally templates written declarative description language similar self descriptive metadata udfs 
system simple better self descriptive metadata exhibited come appreciate indication applications control system tradeoffs 
myriad decisions base types available represented large disk block pointers type layout change extents specified 
variety data structures described file system literature fixed set components describe useful metadata 
current solution uses templates trades declarative description language expressive interpreted language udfs 
lets track access rights xn understanding xn merely verifies track block ownership correctly 
xn design implementation describe requirements xn design 
requirements approach experience far requirements sufficient reconcile application control protected sharing 

prevent unauthorized access operation disk data guarded 
speed xn uses secure bind ings move access checks bind time checking access 
example permission read cached disk block checked page inserted page table environment access 

xn able determine unambiguously access rights principal disk block 
speed uses udf mechanism protect disk blocks metadata guarding block individually 

xn guarantee disk updates ordered crash incorrectly access data freed allocated 
requirement means metadata persistent crashes written contains pointers uninitialized metadata reallocation freed block delayed persistent pointers removed 
isolation allows separate coexist safely protected sharing file system state mutually requires additional features 
coherent caching disk blocks 
distributed disk block caches create consistency problem applications cache disk block different physical pages modifications shared 
xn solves problem kernel system wide protected cache registry maps cached disk blocks physical pages holding 

atomic metadata updates 
file system updates multiple steps 
ensure shared state ends consistent correct state lock cache registry entries 
explore optimistic concurrency control versioning 

formed updates 
file abstractions xn interface may require metadata modifications satisfy invariants link counts inodes match number associated directory entries 
udfs allow xn guarantee invariants file system specific manner allowing mutually applications safely share metadata 
xn controls necessary enforce protection rules 
abilities initiation disk block layout allocation policies recovery semantics consistency guarantees left untrusted 
ordered disk writes difficulty xn face guaranteeing rules ganger patt give achieving strict file system integrity crashes reuse disk resource previous pointers 
second create persistent pointers structures initialized 
third moving disk resource reset old pointer persistent storage new set 
rules required global system integrity enforced xn file system violating third rule affect 
rules simple difficult enforce efficiently naive implementation incur frequent costly synchronous disk writes 
xn allows address enforcing rules follow 
particular choose operation order satisfies constraints 
rule implemented deferring block deallocation disk pointers block deleted count performed crash recovery time helps implement third rule 
second rule hardest 
implement xn keeps track tainted blocks 
block considered tainted points uninitialized block tainted block 
allowed write tainted block disk 
exceptions allow xn enforce general rule efficiently xn allows entire file systems marked temporary persistent reboots 
file systems persistent required adhere integrity rules 
technique allows memory file systems implemented loss efficiency 
second exception observation subtrees trees root reachable persistent root preserved reboots temporary trees free ordering constraints 
xn track tainted blocks unreachable tree connected persistent root 
buffer cache registry discuss xn buffer cache registry allows protected sharing disk blocks 
registry tracks mapping cached disk blocks metadata physical pages vice versa 
traditional buffer caches records mapping disk blocks 
disk blocks stored application managed physical memory pages 
registry tracks mapping state dirty core uninitialized locked 
allow see disk blocks cached buffer cache registry mapped read application space 
access control performed attempts map physical page containing disk block address space block requested disk 
registry entries inserted requiring object describe memory 
blocks installed registry template parent known 
result significant freedom prefetch 
registry entries installed ways 
application write access block directly install mapping registry 
second applications write access block indirectly install entry performing read insert tells kernel read disk block associate application provided physical page set protection page page appropriately insert mapping registry 
mechanism prevent applications permission write block modifying installing bogus core copy 
xn replace physical pages registry freed applications allowing applications determine appropriate caching policy 
applications manage virtual memory paging partitioning disk cache virtual memory backing store application control 
simplify application task inexpensive provide xn maintains lru list unused valid buffers 
default need pages free recycle oldest buffer lru list 
xn allows process write dirty blocks disk blocks associated running process process write permission dirty blocks 
allows construction daemons asynchronously write dirty blocks 
trust daemons write access files flush blocks 
ability benefits 
contents registry safely retained process invocations having brought paged creation exit 
second design simplifies implementations rely daemon choice flush dirty blocks difficult situations application containing swapped 
third design allows different write back policies 
xn usage illustrate xn sketch implement common file system operations 
setup operations install type creation 
describes types storing templates described section type catalogue 
template identified unique string ffs inode 
installed types persistent reboots 
persistence 
ensure data persistent reboots register root tree xn root catalogue 
root entry consists disk extent corresponding template type identified unique string 
crash xn uses roots garbage collect disk reconstructing free map 
logically traversing roots blocks reachable reachable blocks allocated non reachable blocks 
rebuilding free map crash needs fast step eliminated ordering writes free map 
initialization new xn 
describe simplified version common operations 
startup 
start xn loads root types needs root catalogue buffer cache registry 
usually cached 
read 
reading block disk stage process stages combined separated 
creates entries registry passing block addresses requested disk blocks metadata blocks controlling parents 
parents exist registry responsible loading 
xn uses owns udf determine requested blocks controlled supplied metadata blocks installs registry entries 
second stage initiates read request optionally supplying pages place data 
access control acl uf performed parent data loaded bare disk block child data inode 
load block tree traversing root entry optionally starting intermediate node cached registry 
note xn specifically disallows metadata blocks mapped read write 
speculatively read block parent known issue raw read command 
block registry marked unknown type disk request initiated 
block bound parent stage read process determine type allow access control performed 
allocate 
selects blocks allocate reading xn map free blocks allowing control file layout grouping 
free blocks allocated metadata node calling xn metadata node blocks allocate proposed modification metadata node 
xn checks requested blocks free runs appropriate acl uf see permission allocate runs owns udf described section see correct block allocated 
checks succeed metadata changed allocated blocks removed free list allocated metadata blocks marked tainted see section 
write 
writes dirty blocks disk passing blocks write xn 
blocks memory pinned memory application write prevented 
write fails blocks tainted reachable persistent root 
write succeeds 
block previously tainted eliminating pointers uninitialized metadata initialized xn modifies state removes tainted list 
applications control fetched paged order control disk management policies enforce strong stability guarantees 
deallocate 
xn uses udfs check deallocate operations analogously allocate operations 
disk pointers deallocated disk block xn places free list 
xn enqueues block free list block count zero 
counts decremented parent disk pointer block deletes pointer write 
ffs library file system subsection briefly describes ffs locating fast file system unix library file system built special additional protection guarantees provides 
xn provides basic protection guarantees needed file system integrity real world file systems require file system specific invariants 
instance unix file systems ensure uniqueness file names directory 
type guarantee provided number ways kernel server cases simple defensive programming 
ffs currently downloads methods kernel check invariants 
currently developing system similar udfs enforce type specific invariants efficient extensible way 
experience ffs shows strongest desired guarantees protected interface provide significant flexibility unprivileged software exokernel approach deal readily highlevel protection requirements closer hardware 
ffs main additions xn protection mechanisms 
access control maps unix representation semantics access control uids exokernel capabilities 

formed updates ffs guarantees unix specific file semantics example directories contain legal aligned file names 

atomicity ffs performs locking ensure data recoverable disk writes occur metadata internally consistent 

implicit updates ffs ensures certain state transitions implicit certain actions 
examples modification times updated file data changed renaming deleting file updates name cache 
difficult implement unix protection significantly degrading application power 
ffs protection implemented mainly small number statements procedures limit flexibility 
intricate operation ensuring files directory unique names lines code scans linked list cached directory blocks ensure name uniqueness 
stable storage challenging resource multiplexed 
focus areas 
plan implement range file systems log structured file systems raid memory file systems testing xn interface powerful support concurrent radically different file systems 
second investigate lightweight protected methods udfs implement simple protection checks required higherlevel abstractions 
overview xok exos experiments xok exos 
section describes xok exos 
xok xok safely multiplexes physical resources intel computers 
xok performs task manner similar aegis exokernel runs mips 
cpu multiplexed dividing time round robin scheduled slices explicit notification time slice 
environments provide hardware specific state needed run process exception stack respond event occurring process execution interrupts exceptions 
network multiplexed dynamic packet filters 
subsection briefly describes differences aegis xok 
physical memory 
mips architecture architecture defines page table structure 
tlb handled hardware structure overridden applications 
additionally hardware verify physical page translation mapped process applications prevented directly modifying page table system calls 
restrictions xok extensible aegis simplify implementation see section small reduction application flexibility 
aegis xok allows efficient powerful virtual memory abstractions built application level 
exposing capabilities hardware mmu protection bits exposing kernel data structures free lists inverse page mappings 
xok low level interface means paging handled applications 
done disk network data regeneration 
additionally applications readily perform page transformations compression verification contents digital signatures allow untrusted nodes network cache pages encryption 
wakeup predicates 
applications want sleep condition true 
unfortunately may difficult application express condition kernel 
problem prevalent bulk os functionality resides application 
solve problem xok provides applications ability inject wakeup predicates kernel 
wakeup predicates boolean expressions applications sleep state system satisfies condition evaluated kernel environment scheduled 
application scheduled predicate hold 
predicate evaluation efficient 
dynamic packet filters xok compiles predicates fly executable code 
significant overhead address space context switch eliminated evaluating predicates exokernel pre translating predicate virtual addresses associated physical addresses 
virtual page referenced predicate unmapped physical page marked free new predicate downloaded application exits 
furthermore implementation wakeup predicates simple fewer lines commented code careful language design loops easy understand operations allows predicates easily controlled 
predicates simple powerful 
coupled xok exposure data structures provided robust wakeup facility new uses wakeup predicates required changes xok 
example wait disk block paged wakeup predicate bind block state wake changes transit resident bound amount time predicate sleeps compare system clock 
composition multiple predicates allows atomic checking disjoint data structures 
access control aegis xok performs access control hierarchically named capabilities despite name capabilities closely resemble generalized form unix user group id traditional capabilities 
xok calls require explicit credentials 
believe combination exokernel interface capabilities explicit credentials simplify implementation secure applications hope demonstrate 
exos exos supports abstractions bsd 
runs unmodified unix applications including applications needed build complete system kernel exos applications 
runs shells file utilities wc grep ls vi networking applications ftp 
salient missing functions full paging process swapping process groups windowing system 
fundamental reason supported simply time implement port 
aegis instance exos supported full paging disk network 
primary goals exos simplicity flexibility 
allow applications override implementation feature system entirely library place objects process tables non customizable servers 
result customization resulting system limited application understanding system interfaces protection enforced shared abstractions exos functionality replaced application specific code 
primary caveats current implementation system research production quality uses shared global state abstractions 
limitations fundamental expect removing caveat significant impact results 
compensate effects shared state performance measurements sections include cost inserting system calls writes shared state 
represents overhead invoking kernel check writes shared state 
implementing unix abstractions xok implement unix abstractions library partitioned unix kernel state private process 
remainder shared 
critical shared state inode table file system metadata page tables buffer cache process table pipes protected xok protections mechanisms 
shared state process map file descriptor table sockets mount table system shared memory table exos uses shared memory 
software regions plan shared state fully protected near 
limited degree fault isolation provided abstractions mapping shared data addresses far application text data 
processes 
process map maps unix process identifiers xok environment numbers shared table 
process table records process identifiers process parent arguments process called run status identity children 
table partitioned application reserved memory xok environment structure mapped readable processes writeable environment owning process 
exos uses xok ipc safely update parent child process state 
unix ps process status program implemented reading entries process table 
unix provides fork system call duplicate current process exec overlay 
exec implemented creating new address space new process loading demand disk image process new address space discarding address space called exec 
implementing fork library pe requires process create replica address space state executing 
fork efficient exos uses copy write lazily create separate copies parent address space 
exos scans page tables exposed xok marking pages copy write data segment stack pages fork call 
pages duplicated generate copy write faults running fork page fault handling code 
groups page table entries updated batching system calls amortize system call overhead updates 
interprocess communication 
unix defines variety interprocess communication primitives signals software interrupts sent processes process pipes producer consumer untyped message queues sockets differing pipes established non related processes potentially executing different machines 
signals layered top xok ipc 
pipes implemented xok software regions coupled directed yield party required queue full empty 
sockets communicating machine currently implemented shared buffer 
inter machine sockets implemented user level network libraries udp tcp 
network libraries implemented xok timers upcalls packet rings allow protected buffering received network packet file descriptors 
file descriptors small integers access unix resources files sockets pipes 
exos name entries global file descriptor table currently stored shared memory 
unix kernel exos accesses table element object oriented manner resource associated table pointers functions implementing operation read write 
unix exos allows applications install methods 
files 
local files accessed ffs uses xn protect file metadata remote files accessed network file system protocol nfs 
file systems library 
exos uses xn buffer cache registry safely share ffs nfs disk blocks 
unix allows different file systems attached hierarchical name space 
exos duplicates functionality maintaining currently unprotected shared mount table maps directories file system 
shared libraries exos implemented library shared libraries crucial 
shared libraries application contain copy exos wasting memory making process creation expensive 
employ simple primitive scheme shared libraries 
exos linked stand executable base address starting reserved section application address space 
exported symbols extracted stored assembly file 
resolve calls library routines application links assembly file 
process creation application loaded exos maps library indicated address 
organization separates file resides applications allowing multiple applications share disk copy importantly cached disk blocks file 
code sharing reduces size exos executables roughly normal unix applications 
traditional dynamic linking procedure calls expensive normal code require relocation table 
application performance xok section shows unmodified unix applications run fast xok exos conventional centralized operating systems 
fact ffs applications run considerably faster xok exos 
compare xok exos freebsd openbsd hardware 
xok uses device drivers derived openbsd 
exos shares large source code base openbsd including applications libc 
compared openbsd freebsd exos time mature built system years moved platform year ago 
experiments performed mhz intel pentium pro processors kbyte chip cache mbyte main memory 
disk system consists ncr scsi controller connecting fast scsi chain quantum atlas xp disk drives pci bus vs fx pci chip set 
reported times minimum time trials standard deviations total run times percent 
measurements establish results 
base performance unaltered unix applications linked exos comparable openbsd freebsd 
untrusted exokernel support unchanged unix applications performance centralized monolithic unix operating systems 
second exos highperformance file system unaltered unix applications perform better exos freebsd openbsd 
applications need re written modified order take advantage exokernel 
important note sufficiently motivated kernel programmer implement optimization implemented extensible system 
fact member research group costa implemented version ffs openbsd 
extensible systems believe particular optimizations significantly easier implement centralized systems 
example porting ffs openbsd took effort designing ffs implementing library file system 
experiments demonstrate unprivileged application level resource management benchmark description application copy small file copy compressed archived source tree cp uncompress uncompress archive gunzip copy large file copy uncompressed archive cp unpack file unpack archive pax copy large tree recursively copy created directories cp 
diff large tree compute difference trees diff compile compile source code gcc delete files delete binary files rm pack tree archive tree pax compress compress archive tree gzip delete delete created source tree rm table 
intensive workload installs large application lcc compiler 
size compressed archive file lcc mbyte 
skilled programmer implement useful os optimizations 
extra layer protection required application level management safe costs little 
base system performance test exos base performance running benchmarks table exos library implementation ffs top xn comparing openbsd ffs file system 
workload experiments represents unmodified unix programs involved installing software package copying compressed archive file unpacking results source tree copying resulting tree comparing trees compiling source tree deleting binaries archiving source tree compressing archive file deleting source tree see table 
shows performance applications xok exos openbsd ffs openbsd freebsd 
establish base system performance compare xok exos openbsd fss ffs file system 
total running time xok exos seconds openbsd ffs seconds 
exos openbsd ffs type file system expect exos openbsd perform equally 
seen xok exos performance comparable openbsd ffs applications 
applications pax cp diff xok exos runs considerably faster explanation 
measurements conclude exos implements bulk operating system application level common software development operations xok exos perform comparably openbsd ffs 
demonstrate common domain applications exokernel flexibility provided free aggressive optimizations exos performance comparable mature monolithic systems 
cost low level multiplexing negligible 
runtime seconds xok exos openbsd ffs openbsd freebsd cp gunzip cp pax cp diff gcc rm pax gzip rm unmodified unix programs 
performance unmodified unix applications 
xok exos openbsd ffs ffs file system free openbsd native ffs file systems 
times seconds 
invisible optimization ffs comparisons concentrate intensive operations exploit ffs library file system 
intensive benchmarks described table compare xok ffs openbsd freebsd 
shows unaltered unix applications run significantly faster top xok exos 
xok exos completes benchmarks seconds seconds faster freebsd openbsd 
eleven benchmarks xok exos performs better free openbsd case factor 
exos performance improvements due ffs file system 
ran modified andrew benchmark mab 
benchmark xok exos takes seconds openbsd ffs takes seconds openbsd takes seconds freebsd takes seconds 
difference performance mab profound benchmark mab stresses fork expensive function xok exos 
exos fork performance suffers xok allow environments share page tables 
fork takes milliseconds exos compared millisecond openbsd 
cost protection section investigate cost protection xok exos 
discussed previous section completed protected implementation data structures 
exos stores tables writeable global shared memory including file descriptor table 
order measurements estimate performance fully protected exos inserted system calls write shared tables 
measurements reported section include extra calls 
measure costs protection ran benchmarks xn extra system calls 
reduces number xok system benchmark shared memory protection openbsd latency byte latency kbyte table 
cost local trust implementation pipes times microseconds 
calls changes total running time seconds seconds 
real workloads dominated costs system call overhead 
investigate cost protection detail measure cost protection mechanisms described section 
comparing implementations pipes see table 
implementation places data shared memory performs sanity checking 
second implementation uses software regions protect pipe data installs wakeup predicate read unnecessary mutual distrust 
results show gratuitous xok protection mechanisms user level pipes outperform openbsd 
exploiting extensibility applications section demonstrates interesting possibilities functionality performance enabled applicationlevel resource management 
report binary emulator zero touch file copy program cheetah web server 
xn developed applications section measured xn 
fast simple binary emulation xok provides facilities efficiently reroute specific int instructions 
ability build binary emulator openbsd applications capturing system calls emulated openbsd programs 
binary emulator useful openbsd programs source code 
emulator partially completed supports approximately openbsd system calls initial results promising able execute large programs mosaic 
main interesting feature emulator runs address space emulated program consequently need privilege 
measurements show programs emulator run percent slower programs running directly xok exos 
counter intuitive result emulator runs address space exos possible run emulated programs faster native os 
example trivial get process id system call takes cycles openbsd cycles emulator running xok exos mhz intel pentium 
difference comes fact emulator replaces openbsd system calls procedure calls exos 
exos omit expensive checks unix perform order guard application errors exokernel application passes wrong arguments application affected 
xcp zero touch file copying program xcp efficient file copy program 
exploits low level disk interface removing artificial ordering constraints improving disk scheduling large schedules eliminating data touching cpu performing disk operations asynchronously 
list files xcp works follows 
enumerates sorts disk blocks files issues large asynchronous disk reads schedule 
multiple instances xcp run concurrently disk driver merge schedules 
second creates new files correct size overlapping inode disk block allocation disk reads 
disk reads complete constructs large writes new disk blocks buffer cache entries 
strategy eliminates copies file buffer cache disk controller cpu touches data 
xcp factor faster copy program cp xok exos uses unix interfaces irrespective files core xcp touch data disk xcp issues disk schedules minimum number seeks largest contiguous ranges disk blocks 
fact file system application library allows integration appropriate craft new abstractions needed 
ability especially profitable disk high cost disk operations demonstrated reluctance operating systems vendors provide useful simple improvements interfaces prefetching asynchronous reads writes fine grained disk restructuring sync operations 
cheetah server exokernel architecture suited building fast servers nfs servers web servers 
server performance crucial client server applications centric nature servers operating system optimizations profitable 
developed extensible library fast servers sample application uses cheetah server 
library designed allow application writers exploit domain specific knowledge simplify construction high performance servers removing need trick operating system doing application requires harvest stores cached pages multiple directories achieve fast name lookup :10.1.1.21.1584
server task simple client request finds appropriate document sends 
cheetah throughput requests second ncsa bsd harvest bsd socket bsd socket xok cheetah byte byte kbyte kbyte kbyte page size 
document throughput function document size servers 
ncsa bsd represents ncsa server running openbsd 
harvest bsd represents harvest proxy cache running openbsd 
socket bsd represents server tcp sockets openbsd 
socket xok represents server tcp socket interface built extensible tcp ip implementation xok exokernel 
cheetah xok represents cheetah server exploits tcp file system implementations speed 
web server performs set optimizations listed 
merged file cache retransmission pool 
cheetah avoids memory data touching cpu need distinct tcp retransmission pool transmitting file data directly file cache precomputed file checksums stored file 
data transmitted retransmitted necessary client directly file cache cpu copy operations 
pai technique 
knowledge packet merging 
cheetah exploits knowledge request state transitions reduce number actions initiates 
example avoids sending redundant control packets delaying acks client requests knows able piggy back response 
optimization particularly valuable small document sizes reduction represents substantial fraction total number packets 
html file grouping 
cheetah locates files included html document allocating disk blocks adjacent file possible 
file cache capture majority client requests extension improve throughput factor 
shows request throughput function requested document size servers ncsa server running openbsd harvest cache running openbsd base socket server running openbsd server optimizations base socket server running xok exokernel system server optimizations vanilla socket file descriptor implementations layered cheetah server running xok exokernel server optimizations enabled :10.1.1.21.1584
provides important pieces information 
base server performs roughly harvest cache shown outperform server implementations general purpose operating systems 
outperform ncsa server 
gives reasonable starting point evaluating extensions improve performance 
second default socket file system implementations built top perform significantly better openbsd implementations interfaces 
improvement comes mainly simple generally valuable extensions packet merging application level caching pointers file cache blocks protocol control block reuse 
third importantly cheetah significantly outperforms servers traditional interfaces 
exploiting xok extensibility cheetah gains times performance improvement small documents kbyte smaller making times faster best performance achieve openbsd 
furthermore large document performance cheetah limited available network bandwidth mbit ethernets server hardware 
socket implementation limited mbyte cpu utilization cheetah delivers mbyte cpu idle time 
extensibility exos default unprivileged tcp ip file system implementations possible achieve performance improvements incrementally low complexity 
optimizations performed cheetah architecture independent 
aegis cheetah obtained similar performance improvements ultrix web servers 
global performance xok exos decentralization resource management allows performance individual applications improved xok exos guarantee global performance running multiple applications concurrently 
experiments section measure situation exokernel architecture potentially weak substantial load selfish applications consuming large resources utilizing devices heavily 
results indicate exokernel successfully reconcile local control global performance 
global performance extensively studied 
total time complete set concurrent tasks measure system throughput minimum maximum latency individual applications measure interactive performance 
simplicity compare xok exos performance high load free runtime seconds total max min xok exos freebsd 
measured global performance xok exos bar freebsd second bar application pool 
times seconds log scale 
number number refers total number applications run script maximum number jobs run concurrently 
total total running time experiment max longest runtime process run giving worst latency 
min minimum 
bsd experiments freebsd performs better openbsd openbsd small non unified buffer cache 
methodology guarantee exokernel compare centralized system offer useful relative metric 
space possible combinations applications run large 
experiments randomization ensure get reasonable sample space 
inputs set applications pick total number run maximum number running concurrently 
experiment maintains number concurrent processes specified maximum 
outputs total running time giving throughput time run application 
poor interactive performance show high minimum latency 
application pool includes mix intensive cpu intensive programs pack archive pax search word large file grep compute checksum times small set files solve traveling salesman problem tsp solve iteratively large discrete laplace equation successive overrelaxation sor count words wc compile gcc compress gzip uncompress gunzip 
experiment chose applications xok exos freebsd run roughly equivalently 
application runs seconds run separate directory avoid cooperative buffer cache reuse 
pseudo random number generators identical start seed producing identical schedules 
applications chose compete cpu memory disk 
shows log scale results different experiments jobs maximum concurrency job jobs maximum concurrency runtime seconds total max min xok exos freebsd 
measured global performance xok exos bar freebsd second bar second application pool 
methodology presentation described 
jobs 
results show exokernel system achieve performance roughly comparable unix despite untuned global performance 
second application pool examine global performance specialized applications emulated applications benefit ffs performance advantages compete non specialized applications 
pool includes tsp sor unpack archive pax section recursive copy cp section comparison diff identical mb files 
pax cp applications represent specialized applications 
shows log scale results experiments jobs maximum concurrency job jobs maximum concurrency jobs 
results show global performance exokernel system degrade applications resources aggressively 
fact relative performance difference freebsd xok exos increases job concurrency 
central challenge exokernel system enforcing global system policy deriving information needed decide enforcement involves doing way application flexibility minimally curtailed 
exokernel controls resource allocation revocation power enforce global policies 
quota schemes instance trivially enforced allocation denial revocation 
fortunately successful global optimizations allows global schemes readily implemented exokernel 
example xok currently tracks global lru information applications deallocating resources 
believe exokernel provide global performance superior current systems 
effective local optimization mean resources entire system 
second exokernel gives application writers machinery orchestrate inter application resource management allowing perform domain specific global op possible current centralized systems unix program modified orchestrate complete build process 
third exokernel unify space partitioned caches current systems buffer cache network buffers 
fourth applications know resources scarce better resources layering abstractions 
example web server caches documents virtual memory caching documents cache fit main memory 
research pursue issues 
experience past years built exokernel systems 
distill experience discussing clear advantages costs lessons learned building exokernel systems 
clear advantages exposing kernel data structures 
allowing map kernel hardware data structures address spaces powerful extensibility mechanism 
course structures contain sensitive information application lacks privileges 
benefits mapping data structures fold 
exposed data structures accessed system call overhead 
importantly mapping data structures directly allows information exokernel anticipate exporting 
exposed data structures constitute welldefined api software directly relies hardware abstraction layer may need recompiled modified kernel changes 
seen disadvantage 
hand code affected changes exposed data structures typically reside applications need concern changes 
improvements require kernel modification traditional operating systems need effect 
main advantages exokernel modified debugged considerably easily kernels 
expect changes exokernel proper lines new device drivers functionality expose new structures modify existing ones 
aggressive applications may versions exokernel dynamically linked 
problem new 
number unix programs top gated netstat private kernel data structures kernel memory device dev kmem 
administrators simply learned programs major kernel data structures change 
wakeup predicates forcefully driven home advantages exposing kernel data structures 
frequently required unusual information system 
cases information provided kernel data structures 
cpu interface 
combination time slices initiation termination upcalls directed yields proven value repeatedly 
subsequent primitives useful 
primitives inter process communication optimization applications communicating shared message queue yield global gang scheduling robust critical sections see 
libraries simpler kernels 
edit compile debug cycle applications considerably faster edit compile reboot debug cycle kernels 
practical benefit placing os functionality libraries reboot replaced relink accumulated iterations replacement reduces development time substantially 
additionally fact library isolated rest system allows easy debugging basic abstractions 
untrusted user level servers microkernel systems benefit 
costs panacea 
subsection lists costs encountered 
exokernel interface design simple 
goal exokernel system privileged software export interfaces unprivileged applications manage resources 
time interfaces offer rich protection assure invariants high level abstractions 
generally takes iterations obtain satisfactory interface designer increase power remove unnecessary functionality providing necessary level protection 
major exokernel interfaces gone multiple designs years 
information loss 
valuable information lost implementing os abstractions application level 
instance virtual memory file system completely application level exokernel may unable distinguish pages cache disk blocks pages virtual memory 
exokernel additional complication distinguish uses physical pages buffering messages 
frequently information derived little effort 
example page tables managed application exokernel approximate lru page ordering tracking insertion translations tlb 
inference requires thought 
self paging 
self paging difficult commercial operating systems page kernel 
self paging difficult paging caused external entities kernel touching paged buffer provided 
careful planning necessary ensure quickly select return page exokernel facility swap processes knowledge internals virtual memory customization infeasible 
lessons provide space application data kernel structures 
easier develop store shared state kernel data structures 
particular ability simplify task locating shared state avoids awkward complex replication indexing structures application level 
example xok lets software bits page tables greatly simplifying implementation copy write 
fast applications require microbenchmark performance 
main benefit exokernel primitive operations efficient gives applications control expensive operations control gives order magnitude performance improvements applications fast system calls 
heavily tuned aegis achieve excellent microbenchmark performance 
xok hand completely untuned 
applications perform 
inexpensive critical sections useful 
traditional oses inexpensive critical sections implemented disabling interrupts 
exos implements critical sections disabling software interrupts time slice termination upcalls 
critical sections locks removes need communicate manage lock trust software acquire release locks correctly complex algorithms reclaim lock process dies holding 
approach proven similarly useful multiprocessor basis fast message passing 
user level page tables complex 
page tables migrated user level aegis concerted effort ensure user tlb refill handler run unusual situations 
reason performance naming context provided virtual memory mappings requirement useful operations 
example case downloaded code run interrupt handler kernel willing allow application code service tlb misses situations code unable progress 
user level page tables implementation tricky aegis hardware page tables issue disappeared xok exos 
downloaded interrupt handlers questionable utility 
aegis downloaded code extensively interrupt servicing 
main benefits elimination kernel crossings fast upcalls unscheduled processes reducing processing latency send response style network messages 
current generation chips latency devices large compared overhead kernel crossings making benefit negligible 
second require downloading code upcall mechanism 
practice ability gives speed 
downloading interrupt handlers useful commercial operating systems extremely high overhead kernel crossing exokernel systems 
easier download interrupt handlers existing commercial os turn commercial os exokernel system 
downloaded code powerful 
downloaded code lets kernel leave decisions untrusted software 
delegation invaluable places 
main benefit downloaded code execution speed trust consequently power kernel invoke downloaded code cases trust application code 
example packet filters downloaded code fragments applications claim incoming network packets 
kernel kernel inspect verify steal packets intended applications 
alternative asking application claims packet clearly unworkable kernel know decisions guarantee correctness 
example downloaded code metadata interpretation kernel ensure udfs deterministic change trust output having understand 
evaluates exokernel architecture proposed 
shows built exokernel system separates protection management give untrusted software control resource management 
exokernel system gives significant performance advantages applications maintaining competitive performance unmodified unix applications heavily workloads 
simplify job operating system development allowing library operating system developed debugged running machine 
advantages rapid operating system development extend specialized niche applications 
questions full implications exokernel architecture remain answered viable approach offers advantages conventional systems 
acknowledgments years people contributed exokernel project 
particular deborah wallach doug wyatt contributions 
josh cates erik constantine elliot porting drivers applications xok exos 
eddie kohler help writing 
josh cates john chapin matt frank john guttag anthony joseph hank levy shepherd erik max poletto deborah wallach david wetherall witchel anonymous referees careful reading earlier versions valuable feedback 
anderson 
case application specific operating systems 
third workshop workstation operating systems pages 
barrera 
invocation chaining manipulating light weight objects heavy weight boundaries 
proc 
th ieee workshop workstation operating systems pages october 
bershad redell ellis 
fast mutual exclusion uniprocessors 
proc 
conf 
architectural support programming languages operating systems pages october 
bershad savage pardyak sirer fiuczynski becker eggers chambers 
extensibility safety performance spin operating system 
proceedings fifteenth acm symposium operating systems principles pages december 
bugnion devine rosenblum 
disco running commodity operating systems scalable multiprocessors 
proceedings sixteenth acm symposium operating systems principles 
cao felten li 
implementation performance application controlled file caching 
proceedings symposium operating systems design implementation pages november 
chankhunthod danzig neerdaels schwartz worrell :10.1.1.21.1584
hierarchical internet object cache 
proceedings usenix technical conference pages january 
cheriton duda 
caching model operating system kernel functionality 
proceedings symposium operating systems design implementation pages november 
dennis van horn 
programming semantics multiprogrammed computations 
communications acm march 
engler kaashoek 
dpf fast flexible message demultiplexing dynamic code generation 
acm communication architectures protocols applications sig comm pages august 
engler kaashoek toole jr exokernel operating system architecture application specific resource management 
proceedings fifteenth acm symposium operating systems principles pages december 
ford hibler lepreau back 
microkernels meet recursive virtual machines 
proceedings second symposium operating systems design implementation pages october 
ford van lepreau robinson jeff turner 
flux os toolkit reusable components os implementation 
proc 
sixth workshop hot topics operating systems pages may 
ford 
cpu inheritance scheduling 
proceedings second symposium operating systems design implementation pages october 
ganger kaashoek 
embedded inodes explicit grouping exploiting disk bandwidth small files 
proceedings usenix technical conference pages 
ganger patt 
metadata update performance file systems 
proceedings symposium operating systems design implementation pages november 
goldberg 
survey virtual machine research 
ieee computer pages june 
golub dean forin rashid 
unix application program 
usenix summer conference pages june 
brinch hansen 
nucleus multiprogramming system 
communications acm april 
liedtke sch 
performance kernel systems 
proceedings sixteenth acm symposium operating systems principles 
hartman mosberger malley peterson proebsting 
scout operating system 
technical report tr university arizona tucson az june 
cheriton 
application controlled physical memory external page cache management 
fifth international conference architecture support programming languages operating systems pages october 
hitz 
nfs file server appliance 
technical report network march 
kaashoek engler wallach ganger 
server operating systems 
sigops european workshop pages september 
lampson 
reliable extendable operating systems 
state art report 
lampson sproull 
open operating system single user machine 
proceedings seventh acm symposium operating systems principles pages december 
lee chen chang 
high performance external virtual memory caching 
proceedings symposium operating systems design implementation pages 
liedtke 
micro kernel construction 
proceedings fifteenth acm symposium operating systems principles pages december 
mackenzie kubiatowicz frank lee lee agarwal kaashoek 
udm user direct messaging general purpose multiprocessing 
technical memo mit lcs tm march 
maeda bershad 
protocol service decomposition high performance networking 
proceedings fourteenth acm symposium operating systems principles pages 
mazi res kaashoek 
secure applications need operating systems 
proc th workshop hot topics operating systems pages may 
ncsa university illinois urbana champaign 
ncsa httpd 
ncsa uiuc edu index html 
ousterhout 
aren operating systems getting faster fast hardware 
proceedings summer usenix conference pages june 
pai druschel zwaenepoel 
lite unified buffering caching system 
technical report www cs rice edu vivek io lite html rice university 
patterson gibson zelenka 
informed prefetching caching 
proceedings fifteenth acm symposium operating systems principles pages december 
bruno 
space new approach operating system abstraction 
international workshop object orientation operating systems pages october 
redell dalal lauer lynch mcjones murray purcell 
pilot operating system personal computer 
communications acm february 
sandberg goldberg kleiman walsh lyon 
design implementation sun network filesystem 
proc 
summer usenix conference pages 
seltzer endo small smith 
dealing disaster surviving misbehaved kernel extensions 
proceedings second symposium operating systems design implementation pages october 
thekkath levy lazowska 
separating data control transfer distributed operating systems 
sixth international conference architecture support programming languages operating systems pages san francisco ca october 
von eicken basu vogels 
net userlevel network interface parallel distributed computing 
proceedings fifteenth acm symposium operating systems principles pages 
wahbe lucco anderson graham 
efficient software fault isolation 
proceedings fourteenth acm symposium operating systems principles pages asheville nc december 
waldspurger weihl 
lottery scheduling flexible proportional share resource management 
proceedings symposium operating systems design implementation pages november 
wallach engler kaashoek 
application specific handlers high performance messaging 
acm communication architectures protocols applications sigcomm pages august 
