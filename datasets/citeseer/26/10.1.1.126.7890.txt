proceedings usenix annual technical conference monterey ca usa june 
pebble component operating system eran gabber christopher small john bruno jos avi silberschatz information sciences research center lucent technologies bell laboratories mountain ave murray hill nj eran chris avi research bell labs com affiliated university california santa barbara pebble new operating system designed goals flexibility safety performance 
architecture combines set features heretofore single system including minimal privileged mode nucleus responsible switching protection domains implementation system services replaceable user level components minimal privileges including scheduler device drivers run separate protection domains enforced hardware memory protection generation code specialized possible cross domain transfer 
combination techniques results system extremely inexpensive cross domain calls suited efficiently specializing operating system application basis supporting modern component applications 
new operating system project address real problem currently addressed constructing general purpose posix windows compliant system runs standard applications worthwhile goal 
pebble operating system designed goal providing flexibility safety high performance applications ways addressed standard desktop operating systems 
flexibility important specialized systems referred embedded systems 
term misnomer embedded systems run just microcontrollers cars high performance general purpose processors routers laser printers hand held computing devices 
safety important living today world mobile code component applications 
safe languages java gosling limbo dorward applications hardware memory protection important code written unsafe languages 
high performance sacrificed provide safety flexibility 
history shown systems chosen primarily performance characteristics safety flexibility come second place 
system structure added support flexibility safety come significant decrease performance possible new system offer better performance existing systems 
early project designers pebble decided maximize system flexibility pebble run little code possible privileged mode nucleus 
piece functionality run user level removed nucleus 
approach easy replace layer offer alternative versions operating system services 
user level component runs protection domain isolated means hardware memory protection 
communication protection domains done means generalization interrupt handlers termed portals 
portal exists protection domain protection domain invoke service offered protection domain portal table restricting set portals available protection domain threads domain efficiently isolated services access 
portals basis flexibility safety pebble key high performance 
specialized tamper proof code generated portal simple interface definition language 
portal code optimized portal saving restoring minimum necessary state encapsulating compiling demultiplexing decisions run time checks 
remainder structured follows 
section discuss related 
section describe architecture pebble section discuss portal mechanism uses detail 
section covers key implementation issues pebble 
section introduces idea implementing protected application transparent sandbox portal interposition shows performance overhead sandbox 
section compares performance pebble openbsd test hardware mips processor 
section reviews current status pebble discusses plans 
summarize section include short code example implements sandbox discussed section 
related pebble general structure classical microkernel operating systems mach chorus windows nt custer consisting privileged mode kernel collection user level servers 
pebble protected mode nucleus smaller fewer responsibilities kernels systems way microkernel liedtke 
pebble share common philosophy running little code privileged mode possible 
implements ipc minimal virtual memory management privileged mode pebble nucleus includes code transfer threads protection domain small number support functions require kernel mode 
mach provides facility intercept system calls service user level golub 
pebble portal mechanism designed high performance cross protection domain transfer similar way existing application component interposing components application component services uses 
pebble architecture closer spirit nested process architecture fluke ford 
fluke provides architecture virtual operating systems layered layer affecting performance subset operating system interface implements 
example presence multiple virtual memory management provide demand paging distributed shared memory persistence effect cost invoking file system operations read write 
fluke model requires system functionality replaced groups memory management implement functions virtual memory interface specification 
pebble portals replaced piecemeal permits finer grained extensibility 
exokernel model engler kaashoek attempts os abstractions privileged mode kernel charge protecting resources leaving resource abstraction user level application code 
exokernel approach pebble moves implementation resource abstractions user level exokernel pebble provides set abstractions implemented user level operating system components 
pebble os components added replaced allowing alternate os abstractions coexist override default set 
pebble interposition technique discussed section wrap sandbox untrusted code 
extensible operating system projects studied software techniques safe languages spin bershad software fault isolation vino seltzer purpose 
software techniques require faith safety compiler interpreter software fault isolation tool sandbox implemented portal interposition hardware memory protection provides isolation hardware level may simpler verify software techniques 
philosophically pebble approach sandboxing akin provided plan operating system pike 
plan nearly resources modeled files process file name space 
restricting namespace process effectively isolated resources access 
contrast plan pebble restrict access service just represented files 
pebble applies techniques developed bershad bershad massalin massalin pu pu improve performance ipc 
bershad results showed ipc data size tends small fits registers large passed sharing memory pages 
massalin synthesis project pu project studied generating specialized code improve performance 
pebble inspired space project 
concepts terminology project come space pro vided idea cross domain communication generalization interrupt handling 
spring kernel mitchell provided cross protection domain calls doors similar pebble portals 
spring doors implementing operations objects include general purpose parameter manipulations 
kea system veitch similar pebble 
provides protection domains inter domain calls portals portal remapping 
kea portals perform general parameter manipulations pebble 
parameter manipulations sharing memory pages essential efficient communication components 
mmlite system helander componentbased system provides wide selection objectoriented components assembled application system :10.1.1.33.7380:10.1.1.33.7380
mmlite components space efficient 
mmlite memory protection components execute protection domain 
dijkstra system dijkstra pebble hides details interrupts higher level components uses semaphores synchronization 
cisc processors provide single instruction performs full context switch 
notable example intel task switch call gate intel 
instruction takes machine cycles 
philosophy architecture pebble philosophy consists key ideas 
privileged mode nucleus small possible 
run user level privileged mode nucleus responsible switching protection domains 
perfect world pebble include privileged mode instruction transfer control protection domain 
minimizing done privileged mode reduce amount privileged code time needed perform essential privileged mode services 
operating system built fine grained replaceable components isolated hardware memory protection 
application server file system nucleus device driver scheduler 
pebble architecture 
arrows denote portal traversals 
right interrupt causes device driver semaphore incremented unblocking device driver thread see section 
functionality operating system implemented trusted user level components 
components replaced augmented layered 
architecture pebble availability hardware memory protection pebble described requires memory management unit 
cost transferring thread protection domain small performance related reason locate services 
demonstrated cost hardware memory protection intel extremely small liedtke believe done done 
results bear pebble perform way ipc machine cycles mips processor see section details 
transferring thread protection domains done generalization hardware interrupt handling termed portal traversal 
portal code generated dynamically performs portal specific actions 
hardware interrupts ipc pebble equivalent system calls handled portal mechanism 
pebble generates specialized code portal improve run time efficiency 
portals discussed detail section 
protection domains portals threads interrupt dispatcher component runs protection domain pd 
protection domain consists set pages represented page table set portals generalized interrupt handlers stored protection domain portal table 
protection domain may share pages portals protection domains 
illustrates pebble architecture 
portals handle hardware interrupts software traps exceptions 
existence portal pd pd means thread running pd invoke specific entry point pd return 
associated portal code transfer thread invoking domain invoked domain 
portal code copies arguments changes stacks maps pages shared domains 
portal code specific portal allows important optimizations performed described 
portals usually generated pairs 
call portal transfers control domain pd pd return portal allows pd return pd discussion omit return portal brevity 
portals generated certain resources created semaphores clients connect servers files opened 
portals created system initialization time interrupt exception handling portals 
scheduling priority stack machine context associated pebble thread 
thread traverses portal scheduling decision thread continues run priority invoked protection domain 
thread executes invoked domain may access resources available invoked domain longer access resources invoking domain 
threads may execute protection domain time means share portal table resources 
part portal traversal portal code manipulate page tables invoking invoked protection domains 
commonly occurs thread wishes map duration ipc region memory belonging invoking protection domain virtual address space invoked protection domain gives thread window address space invoking protection domain running invoked protection domain 
thread returns window closed 
memory window save cost copying data protection domains 
variations include windows remain open share pages protection domains windows transfer pages invoking domain invoked domain implement tear away write windows transfer pages invoked domain invoker implement tear away read 
note portal code may modify vm data structures vm manager portal manager generates portal code share knowledge data structures 
pebble nucleus oblivious data structures 
safety pebble implements safe execution environment combination hardware memory protection prevents access memory outside protection domain limiting access domain portal table 
protection domain may access portals inherited parent new portals generated behalf portal manager 
portal manager may restrict access new portals conjunction name server 
protection domain transfer portal portal table unrelated domain 
parent domain may intercept child portal calls including calls indirectly manipulate child portal table described section 
server components part pebble philosophy system services provided operating system server components run user mode protection domains 
applications server components trusted may granted limited privileges afforded application components 
example scheduler runs interrupts disabled device drivers device registers mapped memory region portal manager may add portals protection domains protection domain modify portal table directly 
advantages implementing services user level 
software engineering standpoint guaranteed server component exported interface components 
second server component privileges needs job programming error component directly affect components 
critical component fails vm system affected bug console device driver overwrite page tables 
additionally user level servers interrupted time approach possibility offering lower interrupt latency time 
server components run user level including interrupt driven threads blocking synchronization primitives simplifies design 
contrast handlers run interrupt level block require careful coding synchronize upper parts device drivers 
portal manager portal manager operating system component responsible instantiating managing portals 
privileged component permitted modify portal tables 
portal instantiation step process 
server pebble system component application component registers portal portal manager specifying interface definition name portal 
second client component requests portal name opened 
portal manager may call name server identify portal verify client permitted open portal 
name server approves access portal manger generates code portal installs portal client portal table 
portal number newly generated portal returned client 
client may inherit portal parent result domain fork described section 
invoke portal thread running client loads portal number register traps nucleus 
trap handler uses portal number index portal table jumps code associated portal 
portal code transfers thread invoking protection domain invoked protection domain returns user level 
stated portal transfer involve scheduler way 
section describes exception rule 
portal interfaces written tiny interface definition language described section 
portal argument may processed transformed portal code 
argument transformation may involve function nucleus state inserting identity calling thread current time 
argument transformation may involve servers 
example portal argument may specify address memory window mapped receiver address space 
transformation requires manipulation data structures virtual memory server 
design portal mechanism presents conflict hand order efficient argument transformation code portal may need access private data structures trusted server virtual memory system hand trusted servers allowed keep internal data representations private 
solution advocate allow trusted servers virtual memory manager register argument transformation code templates portal manager 
portals registered untrusted services required standard argument types 
portal manager instantiates portal uses argument appropriate type specific code generated part portal 
technique allows portal code efficient inlining code transforms arguments encapsulated allowing servers keep internal representations private 
portal code runs kernel mode access server specific data structures data structures accessed servers 
portal manager currently supports argument transformation code single trusted server virtual memory server 
scheduling synchronization inter thread synchronization intrinsically scheduling activity synchronization managed entirely user level scheduler 
thread creates semaphore portals added portal table transfer control scheduler 
thread domain invokes thread transferred scheduler succeeds scheduler returns 
fails scheduler marks thread blocked schedules thread 
operation works analogously operation unblocks thread higher priority invoker scheduler block invoking thread run newly awakened 
device drivers interrupt handling hardware device system associated semaphore communicate interrupt dispatcher component device driver component specific device 
portal table protection domain entries portals corresponds machine hardware interrupts 
pebble nucleus includes short trampoline function handles exceptions interrupts 
code determines portal table current thread transfers control address taken corresponding entry portal table 
nucleus oblivious specific semantics portal invoked 
portal handles interrupt starts saving processor state invocation stack see section switches interrupt stack jumps interrupt dispatcher 
words mechanism converts interrupts portal calls 
interrupt dispatcher determines device generated interrupt performs operation device semaphore 
typically device driver left thread blocked semaphore 
operation unblocks thread runnable thread higher priority currently running thread gains control cpu interrupt handled immediately 
typically priority interrupt handling threads corresponds hardware interrupt priority order support nested interrupts 
priority interrupt handling threads higher threads ensure short handling latencies 
way pebble unifies interrupt priority thread priority handles scheduler 
pictorial example process 
note pebble invokes interrupt dispatcher promptly interrupts including low priority ones 
interrupt handling thread scheduled priority higher currently running thread 
small portion pebble runs interrupts disabled portal code interrupt dispatcher scheduler 
necessary avoid race conditions due nested exceptions 
low consistent interrupt latency pebble provides low consistent interrupt latency design servers interrupt dispatcher scheduler run interrupts enabled 
interrupt disabled execution path pebble short portal code contain loops interrupt dispatcher scheduler optimized speed 
user code increase length longest path increase interrupt latency 
previous included details interrupt handling mechanism pebble measurements interrupt latency machines memory hierarchies bruno :10.1.1.43.1516
particular interrupt latency mips processor typically cycles exception scheduling user level handling thread 
non systems non high availability systems characterized ability run continuously extended periods time support dynamic updates 
example systems telephone switches expected run years unscheduled time 
pebble especially suited systems system functionality may replaced dynamically loading new servers modifying portal tables 
component replaced nucleus provides minimal functionality 
portals uses portals multiple purposes pebble 
section describe applications 
interposition layering technique building flexible system factor components orthogonal functionality composed arbitrary ways 
example distributed shared memory persistent virtual memory implemented layer top standard virtual memory service 
altered semantics offered layering binary interface operating system emulated operating system intercepting system calls application written emulated system implementing native system calls 
portal mechanism supports development methodology nicely 
portal mechanism uniformly system portal performs user level user level transfer service components designed accept set portals 
example primary task virtual memory manager accept requests pages clients service obtaining pages backing store 
client requests page virtual memory manager read page backing store return client memory window operation 
standard virtual memory service implementation support just protocol typically configured user application client file system backing store server 
backing store replaced distributed shared memory dsm server interface virtual memory manager accept page requests client obtain pages backing store case backing store page local disk remote dsm server return page client memory window operation 
implementing dsm server standard virtual memory interface layered vm file system 
services persistent virtual memory transactional memory added way 
page fault takes place faulting address determine portal invoke 
typically single vm fault handler registered entire range application heap need case 
example fault page shared memory region handled differently fault page private memory region 
assigning different portals subranges protection domain address space different virtual memory semantics supported range 
portals encapsulate state portal code trusted specific portal private data portal code encapsulate state associated portal need exposed endpoint 
state invoking thread trivial example portal code saves thread registers invocation stack see section restores thread returns 
flip side data invoked protection domain embedded portal invoker view manipulate 
portal code modified invoking protection domain invoked protection domain ensured values passed valid 
technique frequently allows run time demultiplexing data validation code removed code path 
example pebble portals take place file descriptors 
open call creates portals invoking protection domain reading writing seeking closing 
code portal embedded pointer control block file 
read file client domain invokes read portal portal code loads control block pointer register transfers control directly specific routine reading underlying object disk file socket 
file handle verification needs done client file handle demultiplexing branching type underlying object need done appropriate read routine underlying object invoked directly portal code 
way portals permit run time checks compiled shortening code path 
concrete open call generates consecutive portals caller portal table 
open returns file descriptor corresponds index portals 
read write read fd buf invoke portal fd buf write fd buf invoke portal fd buf seek fd offset close fd 
implementing file descriptors portals seek close calls implemented library routines invoke appropriate portals seen 
invoke portal invokes portal specified argument 
note portal code read write may map buffer argument memory window avoid data copying 
short circuit portals invoke portal fd offset invoke portal fd cases amount done portal traversal server small portal code implement service 
short circuit portal transfer invoking thread new protection domain performs requested action inline portal code 
examples include simple system calls get current thread id read high resolution cycle counter 
tlb handler software mips architecture current platform pebble implemented short circuit portal 
currently semaphore synchronization primitives implemented scheduler necessitate portal traversals operation block 
primitives candidates implementation hybrid portals 
operation done semaphore value positive invoking thread block done decrement semaphore need thread transfer scheduler 
portal code decrement semaphore directly return 
case semaphore value zero thread block calling thread need transfer scheduler 
similarly operation semaphore non negative value threads blocked waiting semaphore performed handful instructions portal code 
optimizations small ones domain transfer takes cycles operations critical path benefit small savings 
portal specification portal specification string describes behavior portal 
controls generation portal code portal manager 
portal specification includes calling conventions portal registers saved invoking domain shares stack invoked domain arguments processed 
character specification encodes portal stack manipulation 
example denotes invoking domain shares stack invoked domain 
denotes invoked domain allocated new stack 
second character specifies amount processor state saved restored 
example denotes minimal state saved invoking domain trusts invoked domain obey calling convention 
denotes partial state saved invoking domain trust invoked domain retain values registers required calling convention 
rest specification contains sequence single character function codes specify handling corresponding parameters 
example template specifies shared stack saving minimal state passing constant parameter passing page memory window second parameter passing word transformation third parameter 
template read write portals 
portal manipulations described earlier portals referred index local portal table 
portal available particular portal table exported protection domains index 
protection domain may access portals portal table 
properties basis pebble safety 
thread calls fork creates new thread executes protection domain parent 
thread calls domain fork creates new protection domain copy parent domain portal table 
parent may modify child portal table allow portal interposition described section 
implementation issues section discuss interesting implementation details pebble 
thread data structure currently running thread user stack interrupt stack invocation stack portal table 
pebble nucleus data structures nucleus data structures pebble nucleus maintains handful data structures illustrated 
thread associated thread data structure 
contains pointer thread current portal table user stack interrupt stack invocation stack 
user stack normal stack user mode code 
interrupt stack interrupt exception occurs thread executing 
interrupt portal switches interrupt stack saves state invocation stack calls interrupt dispatcher server 
invocation stack keeps track portal traversals processor state 
portal call code saves invoking domain state stack 
saves address corresponding return portal invocation stack 
portal return code restores state stack 
portal table pointer thread data structure portal table domain thread currently executing 
changed portal call restored portal return 
virtual memory cache virtual memory manager responsible maintaining page tables accessed tlb handler memory window manipulation code portals 
virtual memory manager component access entire physical memory 
current implementation pebble support demand paged virtual memory 
pebble implementation takes advantage mips tagged memory architecture 
protection domain allocated unique address space identifier avoids tlb cache flushes context switches 
portal calls returns load mapping current stack tlb entry avoid certain tlb flip side pebble components run separate protection domains user mode necessitates careful memory allocation cache flushes component commit values physical memory 
example portal manager generate portal code placed contiguous physical memory 
memory windows portal code opens memory window updates access data structure contains vector counters counter protection domain system 
vector addressed corresponding domain 
counter keeps track number portal traversals corresponding domain passed page memory window 
counter incremented portal call decremented portal return 
page accessible counter corresponds domain greater zero 
counters bit values maintaining page access rights page may handed domain multiple concurrent threads 
page table contains pointer corresponding access data structure 
shared pages dedicated access data structure 
portal code load tlb mapping memory window page 
tlb handler consults counter vector order verify access rights page 
arrangement saves time shared window passed domain touched current domain 
portal return code remove corresponding tlb entry counter reaches zero 
stack manipulations portal call may implement stack sharing require stack manipulations 
invoked domain just uses current thread stack 
portal call requires new stack obtains invoked domain stack queue 
case invoked protection domain pre allocate stacks notify portal manger place domain stack queue 
portal call dequeues new stack invoked domain stack queue 
stacks queue empty portal calls scheduler waits stack available 
portal return enqueues released stack back stack queue 
threads waiting stack portal return calls scheduler pick waiting thread allow proceed portal code 
portal calls interrupt dispatcher interrupt switches stack interrupt stack available thread 
footprint pebble nucleus essential components interrupt dispatcher scheduler portal manager real time clock console driver idle task fit pages kb 
pebble support shared libraries cause code duplication components 
user thread stacks user interrupt invocation require pages interrupt invocation stacks placed page reduce memory consumption 
addition fixed size pages inherently waste memory 
alleviated segmented architectures 
portal interposition important aspect component system ability interpose code client servers 
interposed code modify operation server enforce safety policies enable logging error recovery services implement protocol stacks layered system services 
pebble implements low overhead interposition modifying portal table controlled domain 
interactions domain surroundings implemented portal traversals possible place controlled domain comprehensive sandbox replacing domain portal table 
original portals replaced portal stubs transfer interposed controlling domain 
controlling domain intercepts portal traversal takes place performs actions deems necessary calls original portal 
portal stubs pass parameters way original portals necessary maintain semantics parameter passing windows 
portal stubs regular portals pass corresponding portal index argument 
controlling domain aware particular semantics intercepted portals implement transparent sandbox passing portal parameters verbatim 
domain portal create portal server table 
original portal configuration portal interposition controlled domain portal table controlling domain intercept portal table notification create portal create portal server server server server server server server top diagram illustrates configuration original portal table interposition domain calls servers directly 
bottom diagram shows operation portal interposition 
case portals controlled domain call controlling domain calls servers 
time modification controlled domain portal table 
servers create new portals dynamically client portal table return index newly created portal back client 
controlling domain calls server server creates new portals controlling domain table 
controlling domain notified portal manager new portal created portal table 
notification portal completes process creating portal stub controlled domain table index controlling domain table 
portal stub calls controlling domain passes parameters way original portal 
way controlling domain implements robust sandbox controlled domain understanding semantics controlled domain portals 
comments interposition mechanism 
controlled domain detect portals diverted thwart interposition way 
mechanism similar unix redirection child process accesses standard file descriptor redirected parent process 
second portal interposition comprehensive unix redirection control interactions controlled domain environment 
third interposition recursive controlling domain interposes portals child domain child ad infinitum 
comment deals semantics certain system services fork sbrk change internal state calling domain somewhat tricky implement face transparent interposition 
special allow controlling domain issue behalf controlled domain 
implementing transparent sandbox portal interposition appendix contains code excerpt program implements transparent sandbox child domain 
program counts number times portal called child domain completes child portal traversals calling appropriate server 
fully functional program omitted error handling code due space constraints 
run test hardware see section overhead process machine cycles iteration sem wait sem post roughly twice execution time original code interposition 
program starts calling portal notify registers routine notify portal manager 
modification calling domain portal table call notify immediately portal caused returned 
portal notify necessary handle portal call parent executed behalf child created new portal parent portal table 
new portal replicated child portal table ensure correct operation 
situation occurs example parent executes sem create behalf child 
notify routine receives template newly created portal position portal table 
creates portal child portal table position 
portal template modified pass portal number argument 
program proceeds create child domain domain fork 
child starts copy parent portal table 
entries child portal table point intercept routine parent domain 
argument intercept routine index called portal portal table 
routine increments counters performs required action invoking portal index parent domain 
invoke portal applications invoke specific portal caller portal table 
intercept routine assumes portals parameters 
child domain executes measure routine measures execution time semaphore ping pong threads domain 
function returns current value high resolution timer incremented machine cycles 
measure creates semaphores calling sem create 
scheduler creates new portals semaphore parent domain calls notify create corresponding stubs child domain portal table 
performance measurements section measure performance pebble possible compare openbsd running hardware 
test hardware algorithmics board includes mhz mips processor kb instruction kb data level cache way set associative megabyte integrated level cache mb memory 
ran version openbsd 
times measured high resolution chip timer incremented clock cycles 
results terms elapsed machine cycles elapsed time tests generally fit level level cache 
long cache memory speed scales processor speed cycle results remain meaningful 
convert cycle counts elapsed time multiply cycle time ns 
code size pebble small cache associativity level cache low way performance pebble dependent code data placed cache 
sense fairness experiments specifically attempt control cache layout 
believe careful tuning cache layout reduce number cache misses conflicts 
performance results seen date felt little need go effort 
context switch pipe latency semaphore latency tests adapted hbench os test suite brown 
tests pebble run times 
context switch pipe latency times openbsd trimmed mean excluding smallest largest measurements results iterations hbench os measurement methodology 
cases standard deviation pebble measurements 
ipc naive implementation inter process communication ipc emulate behavior remote procedure call rpc marshalling arguments buffer copying buffer invoking protection domain invoked protection domain unmarshalling calling server function 
common optimizations performed greatly improve performance ipc 
amount data transmitted ipc follows bimodal distribution bershad small number bytes sent case passed registers large number bytes sent case may sense transfer data virtual memory mapping operations 
test measure cost performing ipc data fits registers page memory window passed invoked domain invoked domain access page page memory window written invoked domain 
virtual memory tlb managed software mips memory management unit involved passing memory window window additional portal overhead 
window invoked domain tlb fault takes place memory management unit comes play 
portal code may remove resulting tlb entry return 
simply measuring leg cost ipc domains tell entire story 
system factored components may find client request service causes request request initial request satisfied 
example client page fault generates request vm service request file system request disk driver bring page memory 
simple ipc protection domains cheap critical cascade ipcs takes place performance drop 
test measure time perform ipc domain return time required perform ipc second domain return ipc involving domains total domains 
portal specification window memory window means new stack allocated call reclaimed return 
processor registers preserved calls calling convention saved call restored return 
see section description portal specification 
results leg oneway time cycles 
point comparison included time required perform null short circuit portal traversal user level nucleus user level 
pebble equivalent null system call thought minimum time required enter leave nucleus 
results tests table 
cases 
domains window window window fault table 
ipc pebble new stack partial save times cpu cycles mean runs 
parameters passed registers stack 
see times leg window unused window remains roughly constant number domains traversed increases cycles overhead passing window portal machine cycles 
time leg increases domains due cache contention 
memory window cost increases cycles time required handle tlb fault remove tlb entry return ipc 
outlier single domain case tlb fault page mapped domain domain 
optimization performed invoking domain trusts invoked domain case application invoking system service 
share stack saving costs allocating stack pool invoked protection domain copying data new stack 
additional processor registered saved call invoking domain trusts invoked domain save restore registers 
portal specifications 
tested case data passed stack optimization significant performance benefit seen table 
domains window window window fault table 
ipc pebble shared stack minimal save 
cpu cycles mean runs savings optimization measured cycles reduces leg time 
addition sharing stacks invoking invoked protection domains number stacks amount memory needed system decreased absolute 
pebble ipc time slightly higher aegis exokernel mips processors engler 
aegis performs minimal way protected control transfer cycles mips processors performs null system call stack cycles 
pebble ipc takes longer maintains invocation stack enables easy scheduling thread 
context switch described portal traversal involve scheduling decision 
section show cost context switch pebble 
measure pebble context switch cost ways pebble explicit yield primitive passing byte token ring pipes 
test derived hbench os compare performance pebble openbsd 
cases number protection domains single thread arranged ring scheduled turn 
measurements table 
domains see cost explicit yield increases number protection domains certain point levels 
done scheduler case independent number processes simply selects thread ready queue increase time due cache effects grow level cache rely level cache point running entirely level cache protection domains 
expect see similar jump point overflow megabyte level cache 
openbsd pipe test shows similar behavior leveling protection domains roughly machine cycles 
pipe latency pebble yield pebble pipe openbsd pipe table 
context switch times pebble vs openbsd 
cpu cycles mean runs 
test measures time required pass single byte pipes connecting ring processes 
value represents time transfer byte adjacent processes includes context switch time 
measuring time required transmit single byte capture overhead associated pipes data sent data copy time mask pipe costs 
results table 
domains pebble pipe openbsd pipe table 
pipe latency pebble vs openbsd 
cpu cycles mean runs 
see context switch times open bsd pipe time increases domains levels 
difference numbers table table gives time required transfer data pipe system 
openbsd pipe overhead roughly cycles pebble approximately half 
semaphore acquire release test similar test section pipes semaphores 
number processes arranged ring synchronized means semaphores 
process performs operation right semaphore operation left semaphore 
value table represents time release semaphore process acquire process mod ring processes including context switch time 
results table 
domains pebble semaphore openbsd semaphore table 
semaphore acquire release pebble vs openbsd 
cpu cycles mean runs 
processes difference pebble openbsd roughly cycles cycles attributed difference context switch times 
number domains semaphores increases difference widens pebble semaphores highly optimized key system primitive openbsd semaphores believe due restriction implementation openbsd semaphores reflection difference system structure 
portal generation table shows portal generation time typical portals 
time measured application program including overheads incurred portal manager 
portal specification typically call trusted server integer arguments 
second portal specification typically call untrusted server memory window argument 
see section additional explanations portal specifications 
portal spec 
portal len instr 
time cycles table indicates portal generation time relatively fast 
examination portal manager reveals portal generation time includes large fixed overhead interpretation specification string cache flushing 
reduce time employing various techniques run time code generation techniques vcode engler :10.1.1.25.8634
status cycles instr 
table 
portal generation time 
pebble nucleus small set servers scheduler portal manager interrupt dispatcher minimal vm devices console clock currently run mips single board computers algorithmics 
support qed rm processor idt qed rm processors 
currently porting ethernet scsi device drivers pebble 
plan port pebble intel verify pebble mechanisms performance advantages architecture independent 
plan implement demand paged virtual memory system 
building high performance vm system pebble challenge servers share data structures freely 
plan port tcp ip stack pebble compare performance similar user level protocol stacks 
addition intel port plan port symmetric multiprocessor embedded processor strongarm 
plan investigate various processor architecture support component systems pebble 
summary pebble provides new engineering trade construction efficient component systems hardware memory management enforce protection domain boundaries reducing cross domain transfer time synthesizing custom portal code 
pebble enhances flexibility maintaining private portal table domain 
table provide different implementations system services servers portal interposition domain 
addition portal interposition allows running untrusted code robust sandbox acceptable overhead unsafe languages having small nucleus minimal functionality enhances system modularity enables non systems modify behavior integrating new servers fly 
showed pebble faster openbsd limited set system related microbenchmarks 
pebble efficiency stem clever low level highly optimized code natural consequence custom portal synthesis judicious processor state manipulations portal traversals encapsulating state portal code direct transfer control clients servers scheduler intervention 
pebble build systems flexible safe higher performance conventionally constructed systems 
acknowledgments authors anonymous referees insightful comments 
accetta accetta baron bolosky golub rashid tevanian young mach new kernel foundation unix development proc 
summer usenix conf pp 

bershad bershad anderson lazowska levy lightweight remote procedure call proc 
th sosp pp 

bershad bershad savage pardyak sirer fiuczynski becker chambers eggers extensibility safety performance spin operating system proc 
th sosp pp 

brown brown seltzer operating system benchmarking wake lmbench case study performance netbsd intel architecture proc 
sigmetrics pp 

bruno bruno gabber silberschatz small pebble component operating system embedded applications proc :10.1.1.43.1516
usenix workshop embedded systems cambridge ma 
custer custer inside windows nt microsoft press redmond wa 
dijkstra dijkstra structure multiprogramming system cacm volume number pp 

dorward dorward pike presotto ritchie trickey inferno proc 
ieee compcon pp 

engler engler frans kaashoek toole jr exokernel operating system architecture application level resource management proc 
th sosp pp 

engler engler vcode retargetable extensible fast dynamic code generation system proc :10.1.1.25.8634
conference programming language design implementation pldi pp 

ford ford hibler 
lepreau back microkernels meet recursive virtual machines proc 
nd osdi pp 

golub golub dean forin rashid unix application program proc 
summer usenix pp 

gosling gosling joy steele java language specification addison wesley reading ma 
helander helander forin mmlite highly system architecture proc :10.1.1.33.7380
th acm sigops european workshop sintra portugal 
intel intel pentium family user manual volume architecture programming manual 
kaashoek kaashoek engler ganger brice hunt mazi res application performance flexibility exokernel systems proc 
th sosp pp 

liedtke liedtke micro kernel construction proc 
th sosp pp 

liedtke liedtke sch heiser islam jager achieved ipc performance proc 
th hotos pp 

massalin massalin synthesis efficient implementation fundamental operating system services ph thesis columbia university department computer science new york ny 
mitchell mitchel overview spring system proc 
compcon spring pp 

pike pike presotto thompson trickey plan bell labs proc 
summer conf pp 

bruno space new approach operating system abstractions proc 
intl 
workshop object orientation operating systems pp 
available line ftp cs ucsb edu pub papers space ps gz pu pu black consel cowan inouye walpole zhang optimistic incremental specialization streamlining commercial operating system proc 
th sosp pp 

rozier rozier armand herrmann kaiser leonard 
chorus distributed operating system computing systems pp 

seltzer seltzer endo small smith dealing disaster surviving misbehaved kernel extensions proc 
nd osdi pp 

veitch veitch hutchinson kea dynamically extensible configurable operating system kernel proc 
rd conference configurable distributed systems annapolis 
appendix implementing transparent sandbox portal interposition see section explanations include pebble define int child int count child domain runs routine void measure void int code unsigned long long start elapsed int sem id sem id create semaphores sem id sem create sem id sem create create child thread domain code fork child thread wakes parent sem post sem id sem wait sem id sem post sem id reached exit parent thread waits child active accurate timing sem wait sem id time semaphore ping pong child start sem post sem id sem wait sem id elapsed start printf iteration cycles int elapsed void dump counters void int count printf portal called times count parent domain intercepts child portal call int intercept int id int int int int int count id id sys exit dump counters return invoke portal id parent domain gets notification int notify int int id char template char sprintf sm template portal create child child id intercept return void main void portal notify notify child domain fork intercept child child domain measure exit parent waits child exits sem wait sem create exit 
