arxiv cmp lg may proper treatment optimality computational phonology lauri karttunen xerox research centre europe de france 
presents novel formalization optimality theory 
previous treatments optimality computational linguistics starting ellison new approach require explicit marking counting constraint violations 
notion lenient composition defined combination ordinary composition priority union 
underlying form outputs meet constraint lenient composition enforces constraint output candidates meets constraint lenient composition allows 
sake greater efficiency may compose gen relation constraints single finite state transducer maps underlying form directly optimal surface realizations vice versa 
seen perspective optimality theory surprisingly similar older strains finite state phonology classical rewrite systems level models 
particular ranking optimality constraints corresponds ordering rewrite rules 
recognized time optimality theory ot introduced prince smolensky computational point view closely related classical phonological rewrite systems chomsky halle level descriptions koskenniemi 
ellison observes gen function ot regarded regular relation ot constraints regular 
constraint modeled transducer maps string sequence marks indicating presence absence violation 
optimal solution sorting comparing marks 
frank satta give formal proof ot models construed regular relations provided number violations bounded 
eisner develops typology ot constraints corresponds types rules level descriptions restrictions prohibitions 
practice marking counting constraint violations closely related tableau method introduced prince smolensky selecting optimal output candidate 
current optimality theory consists constructing tableaux demonstrate need particular constraints rankings allow favored candidate emerge best score 
computational viewpoint evaluation method suboptimal 
gen assignment violation marks carried finite state transducers sorting counting marks envisioned ellison subsequent walther line activity finite state process 
kind optimality computation straightforwardly integrated types linguistic processing morphological analysis text speech generation commonly performed means finite state transduction 
demonstrates computation optimal surface realizations input string carried entirely finite state calculus subject limitation frank satta maximal number violations need considered bounded 
show optimality constraints treated computationally similar manner level constraints rewrite rules 
example optimality constraints merged respecting ranking just possible merge rewrite rules level constraints 
system optimality constraints imposed finite state lexicon creating transducer maps member possibly infinite set lexical forms optimal surface realization vice versa 
sake conciseness limit discussion optimality theory originally prince smolensky 
techniques described applied correspondence version theory mccarthy prince expands model encompass output output constraints base forms 
set stage discussing application merging optimality constraints useful look corresponding operations context rewrite rules level constraints 
see similarities differences approaches 
background rewrite rules level constraints known phonological rewrite rules level constraints implemented finite state transducers johnson karttunen koskenniemi kaplan kaplan kay 
application system rewrite rules input string modeled cascade transductions sequence compositions yields relation mapping input string surface realizations 
application set level constraints combination intersection composition karttunen 
illustrate idea rule application composition take concrete example known vowel alternations cole mccarthy 
vowels subject types alternations underspecified suffix vowels rounded presence stem vowel height dub hin ol 
long high vowels lowered tut mi kit 
vowels shortened closed syllables sa sap go hin 
examples hin rules applied order 
rounding precede lowering suffix vowel hin emerges shortening follow lowering stem vowel hin remain high giving final output 
rewrite rules formalized straightforwardly regular replace expressions karttunen compiled finite state transducers 
derivation hin modeled cascade compositions yield transducer relates input directly final output 
step composition initial network identity transducer string hin rounding transducer produces network maps hin hun 
symbol denotes composition operation 
important realize result rule application output string relation 
application produces mapping hin hun 
essence original rounding transducer restricted specific input 
resulting network represents relation languages sets strings 
case languages contain just string rounding rule optional output language contain strings rounding 
rounding rounding lowering 
cascade rewrite rule applications 
rounding lowering shortening step intermediate output created rounding transducer eliminated result composition lowering transducer 
final stage transducer maps directly input string surface realization intermediate stages 
achieve result different way composing rules produce transducer maps underlying form directly surface realization applying resulting single transducer particular input 
rounding lowering shortening 
vowel alternations 
small network states pictured merges rules represents complexity vowel alternations intermediate representations 
context level model vowel alternations described quite simply 
level version rounding rule controls rounding lexical context 
ignores surface realization trigger high stem vowel 
joint effect lowering shortening constraints lexical hin realized level description alternations consists rule transducers operating parallel 
rounding lowering shortening 
parallel level constraints 
application level system input formalized intersecting composition karttunen 
involves constructing partial intersection constraint networks composing input 
course carry intersection rules independently particular input 
merging operation results state transducer composition corresponding rewrite rules pictured 
descriptions sketched completely equivalent yield mapping underlying surface forms 
decompose complex vowel alternation relation different ways set simpler relations easily understood manipulated 
see shortly optimality theory characterized way achieving kind decomposition 
fundamental computational operation rewrite rules composition involved application rules strings merging rules 
level rules corresponding operations intersecting composition intersection 
turning optimality theory main interest finding corresponding computations new paradigm 
applying constraint mean context optimality theory 
optimality constraints merged account ranking 
optimality theory optimality theory prince smolensky abandons rewrite rules 
rules replaced new concepts universal function called gen set ranked universal constraints 
gen provides input form possibly infinite set output candidates 
constraints eliminate best output candidate 
constraints conflict may impossible candidate satisfy 
winner determined consideration language specific ranking constraints 
winning candidate serious violations 
order explore computational aspects theory useful focus concrete example simpler vowel alternation just discussed 
take familiar case constraints discussed prince smolensky subsequent authors ellison hammond 
gen assume input gen consists strings vowels consonants gen allows segment play role syllable remain unparsed 
syllable contains nucleus possibly onset coda 
assume gen marks roles inserting labeled brackets input element 
input consonant outputs onset coda unparsed 
vowel outputs nucleus unparsed addition gen freely inserts empty onset nucleus coda brackets 
sake concreteness give explicit definition gen notation xerox regular expression calculus karttunen 
define gen composition simple components input parse 
definitions components shown 
discussion issues see karttunen 
case problematic optimality theory cole mccarthy rounding depends height stem vowel underlying representation 
cole offer baroque version level solution 
mccarthy strives distinguish sympathy candidates intermediate representations postulated rewrite approach 
define input define parse 

define 

input parse replace expression type 
xerox calculus denotes relation wraps prefix strings suffix strings string parse transducer inserts appropriate bracket pairs input segments 
consonants onsets ignored 
vowels nuclei ignored 
inserts optionally unfilled onsets nuclei 
dotted brackets 
specify single instance bracket pair inserted position 
role third gen component constrain output parse 
syllable needs nucleus onsets optional right order unparsed elements may occur freely 
sake clarity define help auxiliary terms 
define onset define nucleus define coda define unparsed define onset nucleus coda unparsed 
round parentheses xerox regular expression notation indicate optionality 
definition onset indicates onsets may empty filled consonant 
similarly onset definition means syllable may onset 
effect operator allow unparsed consonants vowels occur freely syllable 
disjunction definition unparsed allows consonants vowels remain unparsed 
preliminaries define gen simple composition components 
define gen input parse 
gen appropriate definitions consonants vowels expression yields transducer states arcs 
necessary include input definition gen technically beneficial effect 
constraints explicit auxiliary bracket alphabet included input 
gen wild abandon produces large number output candidates short inputs 
example applying gen string yields relation strings output side 

gen applied number output candidates nearly network representing mapping states 
evident working finite state tools significant advantage manual tableau methods 
constraints constraints prince smolensky easily expressed regular expressions xerox calculus 
lists constraints translations 
syllables onsets 
define syllables 
define input segments parsed 
define parse nucleus position filled 
define onset position filled 
define 
constraints definition constraint uses restriction operator 
requires occurrence nucleus bracket immediately preceded filled unfilled onset 
definitions constraints composed negation contains operator 
example constraint read contain 
constraints forbid empty nucleus onset brackets 
constraints compile small networks largest contains states 
constraint network encodes infinite regular language 
example language includes strings length contain instances strings length instance immediately preceded onset 
identity relations constraint languages thought filters 
example identity relation maps strings blocks strings 
section fact consistently treat constraint networks representing identity relations 
constraint application having defined gen constraints position address main issue optimality constraints applied 
gen denotes relation constraints thought identity relations sets simplest idea proceed way rewrite rules 
compose gen constraints yield transducer maps input optimal realization letting ordering constraints cascade implement ranking 
gen parse 
cascade 
immediately obvious composition intended 
state transducer illustrated works fine inputs panama yielding fails produce output inputs america fail constraint 
strings perfect output candidate survive cascade 
need replace composition new operation schema correctly 
lenient composition necessary operation call lenient composition difficult construct knowledge previously defined 
frank satta come close take final step encapsulate notion 
hammond idea lacks means spell formal terms 
step defining lenient composition review old notion called priority union kaplan 
term originally defined operation unifying feature structures way eliminates risk failure stipulating priority case conflict 
finite state version notion proved useful management transducer lexicons kaplan newman 
consider relations depicted 
relation maps relation maps priority union denoted maps includes pairs pair upper element string occur upper string pair string occurs upper element pair priority union includes pair consequently maps system sri karttunen operation respectable title 
called 

example priority union 
priority union operator defined terms regular expression operators xerox calculus 
straightforward definition 

definition priority union operator extracts upper language regular relation 
expression denotes set strings occur upper side relation 
effect composition restrict mappings concern strings mapped subset unioned define desired operation lenient composition denoted combination ordinary composition priority union 

definition lenient composition better visualize effect operation defined may think relation set mappings induced gen relation constraints defined 
left side priority union restricts mappings satisfy constraint 
pair lower side string eliminated 
string upper language counterpart lower side meets constraint reason priority union 
words underlying form output meet constraint lenient composition enforces constraint 
underlying form output candidates meet constraint underlying form outputs retained 
definition lenient composition entails upper language preserved people including hammond frank satta independently similar idea conceiving finite state operation 
knows priority union lenient composition obvious idea 
illustrate effect lenient composition starting example composition input gen yields relation maps outputs 
compose relation constraints order ranking starting constraint 
lower case operator stands ordinary composition upper case lenient composition 
illustrates applying lenient composition removes output candidates produced gen resulting relation maps outputs 
highest ranking constraint removes alternative 
twelve candidates eliminated lenient composition longer consideration 
hammond implements pruning operation removes output candidates condition pruning reduce candidate set null 
frank satta describe process conditional intersection enforces constraint met 
gen gen 
cascade constraint applications 
gen parse constraints sequence parse obviously change relation remaining output candidate satisfies 
point distinction lenient ordinary composition difference exhausted set output candidates 
bring constraint right half definition come rescue output example demonstrates application optimality constraints thought cascade lenient compositions carry decreasing number output candidates allowing set empty 
intermediate representations intermediate candidate populations corresponding columns left right ordering constraint tableau 
applying constraints output provided gen particular input may compose gen relation constraints 
suggestion nearly correct provided replace ordinary composition lenient composition 
gen parse 
lenient cascade composite single transducer shown maps input directly viable outputs producing failing candidates 
multiple violations addressed important issue 
sufficient obey ranking constraints 
output candidates violate constraint multiple times prefer candidate candidates smallest number violations 
come free 
system sketched far distinction 
input form perfect outputs may get set outputs differ respect number constraint violations 
example transducer gives outputs string bebop 

outputs bebop output meets parse constraint lenient composition allows outputs contain parse violation regardless number violations 
second alternative just violation win 
viewing parse single constraint need reconstruct series relaxed parse constraints 
operator means iterations 
define parse define parse define parse define 
family parse constraints original parse constraint violated single unparsed element 
parse allows unparsed element 
parse allows violations violations 
single parse line replaced sequence lenient compositions chosen parse parse parse 
gradient parse constraint input string output form meets parse constraint violations competing output forms parse violations eliminated 
failing input string output form just violation outputs violations eliminated 

particular order individual parse constraints apply effect final outcome constraint languages strict subset relation parse parse parse 

example best candidate incurs jason eisner observation 
violations parse weaker constraints 
ranking determines order losing candidates eliminated 
start strictest constraint losers eliminated parse applied start weaker constraint output candidates eliminated earlier winner remains 
number constraints goes size combined constraint network states parse violations violations 
maps bebop correctly instantaneously 
immediately evident construct cascade constraints prefer violations violations way finite state system express general idea fewer violations better violations 
frank satta point finite state constraints infinitely distinctions formedness 
limitation serious obstacle practical optimality computations finite state systems number constraint violations need taken account generally small 
curious violation counting emerge crucial issue potentially pushes optimality theory finite state domain making formally powerful rewrite systems level models 
argument older models allow unlimited counting 
clear additional power constitutes asset embarrassment ot 
novel formalization optimality theory technical advantages previous computational treatments marking sorting counting constraint violations 
application optimality constraints done finite state calculus 
system optimality constraints merged single constraint network 
approach shows clearly optimality theory similar older strains finite state phonology classical rewrite systems level models 
optimality theory lenient composition plays role ordinary composition rewrite systems 
top rule ordering replaced left right constraint tableau 
new lenient composition operator uses phonology 
area syntax constraint grammar karlsson formal point view similar optimality theory 
constraint grammars far implemented pure finite state systems evident lenient composition operator possible 

noam chomsky morris halle 

sound pattern english 
harper row new york 

jennifer cole charles 

restricting multi level constraint evaluation opaque rule interaction vowel harmony 
roa 

jason eisner 

decomposing primitive constraints ot 
viii 
roa 

jason eisner 

efficient generation primitive optimality theory 
acl madrid spain 
roa 

jason eisner 

constraints ot allow 
handout talk lsa annual meeting chicago 
roa 

mark ellison 

phonological derivation optimality theory 
coling vol ii pages kyoto japan 
roa cmp lg 

robert frank giorgio satta 

optimality theory generative complexity constraint 
computational linguistics forthcoming 
roa 

michael hammond 

parsing syllables modeling ot computationally 
roa 

douglas johnson 

formal aspects phonological description 
mouton hague 

ronald kaplan martin kay 

regular models phonological rule systems 
computational linguistics 

ronald kaplan paula newman 

lexical resource reconciliation xerox linguistic environment 
acl eacl workshop computational environments grammar development linguistic engineering pages madrid spain july 

ronald kaplan 

computational psycholinguistics 
wood somers johnson bennett editors linguistic theory computer applications pages 
academic press new york 
reprinted formal issues lexical functional grammar ed 
dalrymple kaplan maxwell iii zaenen 
university chicago press 

fred karlsson voutilainen juha 

constraint grammar language independent framework parsing unrestricted text 
mouton de gruyter berlin new york 

lauri karttunen kimmo koskenniemi ronald kaplan 

compiler level phonological rules 
technical report center study language information stanford university june 

lauri karttunen jean pierre gregory grefenstette anne schiller 

regular expressions language engineering 
journal natural language engineering 

lauri karttunen 

patr development environment unification grammars 
coling pages 

lauri karttunen 

finite state constraints 
john goldsmith editor phonological rule pages 
chicago university press chicago 

lauri karttunen 

constructing lexical transducers 
coling kyoto japan 

lauri karttunen 

replace operator 
proceedings rd annual meeting acl cambridge ma 
cmp lg 

charles 

abstractness phonology 
papers linguistics 

kimmo koskenniemi 

level morphology general computational model word form recognition production 
publication university helsinki department general linguistics helsinki 

john mccarthy alan prince 

faithfulness identity prosodic morphology 
van der editors interface 
cambridge university press cambridge uk 
roa 

john mccarthy 

sympathy phonological opacity 
roa 

alan prince paul smolensky 

optimality theory constraint interaction generative grammar 
technical report tr rutgers university cognitive science center new brunswick nj 
appear mit press 

bruce 

computational optimality theory 
ph thesis university colorado boulder 
markus walther 

ot simple construction kit approach optimality theory implementation 
roa 
