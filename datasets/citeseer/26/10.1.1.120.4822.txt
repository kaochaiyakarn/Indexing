michigan benchmark xml query performance diagnostics patel jagadish yun chen university michigan beal avenue ann arbor mi usa jag eecs umich edu propose micro benchmark xml data management aid engineers designing improved xml processing engines 
benchmark inherently different application level benchmarks designed help users choose alternative products 
primarily attempt capture rich variety data structures distributions possible xml isolate effects imitating particular application 
benchmark specifies single data set carefully specified queries evaluate system performance xml data various characteristics 
benchmark analyze performance database systems native xml dbmss commercial 
benchmark reveals key strengths weaknesses systems 
find commercial relational techniques effective xml query processing cases sensitive query rewriting require better support efficiently determining indirect structural containment 
xml query processing taken considerable importance xml databases constructed variety platforms 
naturally interest benchmarking performance systems number benchmarks proposed :10.1.1.18.5187
focus currently proposed benchmarks assess performance xml database performing variety representative tasks 
benchmarks valuable potential users database system providing indication performance user expect specific application 
challenge devise benchmarks sufficiently representative requirements users 
tpc series benchmarks accomplished reasonable success relational database systems 
benchmark successful realm object relational dbmss object oriented dbmss extensibility user defined functions lead great heterogeneity nature 
soon say current xml benchmarks successful respect certainly hope 
aspect current xml benchmarks focus performance basic query evaluation operations selections joins aggregations 
micro benchmark highlights performance basic operations helpful database developer understanding evaluating alternatives implementing basic operations 
number questions related performance may need answered strengths weaknesses specific access methods 
areas developer focus attention 
basis choose alternative implementations 
questions nature central engineered systems 
application level benchmarks nature unable deal important issues detail 
relational systems wisconsin benchmark provides database community invaluable engineering tool assess performance individual operators access methods 
inspired simplicity effectiveness wisconsin benchmark measuring understanding performance relational dbmss 
goal develop comparable benchmark xml dbmss 
benchmark propose achieve goal called michigan benchmark 
challenging issue designing benchmark choice benchmark data set 
data specified represent particular real application quite applications different data characteristics 
holistic benchmarks succeed able find real application data characteristics reasonably representative large class different applications 
challenges micro benchmark different holistic benchmark 
benchmark data set complex incorporate data characteristics impact performance query operations 
time benchmark data set simple easy pose understand queries data set easy pinpoint component system performing poorly 
attempt achieve balance data set simple schema carefully orchestrated structure 
addition random number generators sparingly generating benchmark data set 
michigan benchmark uses random generators attribute values derives data parameters generated values 
furthermore wisconsin benchmark appropriate attribute names reflect domain distribution attribute values 
designing benchmark data sets relational systems primary data characteristics interest distribution domain attribute values cardinality relations 
may additional secondary characteristics clustering tuple attribute size 
xml databases distribution domain attribute values cardinality nodes characteristics tree fanout tree depth contribute rich structure xml data 
xml benchmark incorporate additional features benchmark data query set design 
michigan benchmark achieves data set incorporates characteristics introducing unnecessary complexity data set generation carefully designing benchmark queries test impact characteristics individual query operations main contributions identification xml data characteristics query operations may impact performance xml query processing engines 
single heterogeneous data set carefully specified queries evaluate system performance xml data various characteristics 
insights running benchmark database systems commercial native xml database system native xml database system developing university michigan commercial 
remainder organized follows 
section discuss related 
rationale benchmark data set design section 
section describe benchmark queries 
results benchmark database systems section 
conclude final remarks section 
related proposals generating synthetic xml data proposed 
proposed data generator accepts parameters allow user control properties generated data 
large number parameters adds level complexity may interfere ease data generator 
furthermore data generator available schema data systems exploit 
barbosa proposed template data generator xml generate multiple tunable data sets 
user specify distribution different element values synthetic data sets 
contrast previous data generators data generator proposed benchmark produces xml data set designed test different xml data characteristics may affect performance xml engines 
addition data generator requires parameters vary scalability data set 
schema data set available exploit 
benchmarks xmark proposed evaluating performance xml data management systems :10.1.1.18.5187
xmark generate xml data models data particular internet applications 
database contains directory collected xml documents management documents 
directory represents structured data managed documents text documents 
xmark data internet auction application consists relatively structured data oriented parts 
xml version oo benchmark benchmark 
oo schema instances mapped document type definition dtd oo queries translated respective languages query processing engines lore xml enabled rdbms :10.1.1.41.3062
results tests conclude xml enabled rdbmss efficient processing queries data centric documents native xml databases effi cient processing queries document centric queries 
recognizing different applications requires different benchmarks yao proposed family number different application benchmarks 
benchmarks provides excellent measure test system perform data queries targeted xml application difficult extrapolate results data sets queries different ones targeted domain 
queries benchmarks designed test different performance aspects xml engines perceive change system performance xml data characteristics change 
hand different queries analyze system performance respect different xml data characteristics tree fanout tree depth different query characteristics predicate selectivity 
note presents desiderata xml database benchmark identifies key components operations enumerates challenges xml benchmarks address 
central focus application level benchmarks micro benchmarks sort propose 
benchmark data set section discuss characteristics xml data sets significant impact performance query operations 
schema generation algorithm benchmark data 
discussion data characteristics relational paradigm primary data characteristics selectivity attributes important simple selection operations join selectivity important join operations 
xml paradigm complicating characteristics consider discussed section section 
depth fanout depth fanout structural parameters important tree structured data 
depth data tree significant performance impact instance evaluating indirect containment relationships ancestor descendant nodes tree 
similarly fanout nodes affect way dbms stores data answers queries selecting children specific order example selecting child node 
potential way evaluating impact fanout depth generate number distinct data sets different values parameters run queries data set 
drawback approach large number data sets benchmark harder run understand 
approach fold single data set 
create base benchmark data set depth 
level attribute restrict scope query data sets certain depth level fanout nodes nodes distribution nodes base data set quantifying impact depth data tree 
similarly specify high low different levels tree shown 
fanout level means thirteenth node level single child nodes leaves 
variation fanout designed permit queries fanout factor isolated factors number nodes 
instance number nodes levels 
nodes level fanout nodes level fanout 
pair queries levels isolate impact fanout 
rightmost column nodes percentage number nodes level number total nodes document 
data set granularity keep benchmark simple choose single large document tree default data set 
important understand effect document granularity modify benchmark data set treat node level root distinct document 
compare performance queries modified data set original data set 
scaling benchmark needs able scale order measure performance databases variety platforms 
relational model scaling benchmark data set easy simply increase number tuples 
xml scaling options increasing numbers nodes depths 
isolate effect number nodes effects structural changes depth fanout 
achieve keeping tree depth constant scaled versions data set changing number nodes levels levels 
design benchmark data set deliberately keep fanout bottom levels tree constant 
design implies percentage nodes lower levels tree levels nearly constant data sets 
allows easily express queries focus specified percentage total number nodes database 
example select approximately nodes irrespective scale factor predicate 
propose scale michigan benchmark discrete steps 
default data set called dsx nodes arranged tree depth fanout levels levels respectively 
data set generate additional scaled data sets called dsx dsx numbers nodes data sets approximated times number nodes base data set respectively 
achieve scaling factor varying fanout nodes levels 
data set dsx levels fanout level fanout 
data set dsx levels fanout level fanout 
total numbers nodes data sets dsx dsx respectively schema benchmark data construction benchmark data centered element type base type 
element attributes 
unique integer generated traversing entire data tree breadth manner 
attribute serves element identifier 

unique integer generated randomly 

integer set store level node 

integer set mod 
integer set mod 
attribute generated unique attributes avoid correlation values attribute derived attributes 

integer set mod 

string approximately bytes length 
content element long string approximately bytes length 
generation element content string attribute described section 
addition attributes listed element sets subelements 
type second type 
number repetitions subelement determined fanout parent element described 
hand number occurrences element attribute translates scale factor 
parent element value number occurrences 
element content identical content parent attribute aref 
element refers base type node value equal parent achieved assigning value aref attribute element 
case element parent value top nodes tree element refers root node tree value aref equal value root node 
xml schema specification benchmark data set shown 
string attributes element content element content element long string 
string meant simulate piece text natural language appropriate generate string uniform distribution 
selecting pieces text real sources involves difficulties maintain roughly constant size string avoid idiosyncrasies associated specific source generate strings required scaled benchmark 
benchmark results applicable wide variety languages domain vocabularies 
obtain string values distribution similar distribution natural language text generate long strings synthetically carefully stylized manner 
creating pool thousands synthetic words 
words divided buckets exponentially growing bucket occupancy 
bucket words 
example bucket word second words third words 
word contains information bucket drawn word number bucket 
example indicates th word fourteenth bucket 
keep size vocabulary bucket roughly words words bucket derived words buckets adding suffix ing get exactly words sixteenth bucket add dummy word ing 
value long string generated template shown placeholder word picked word pool described 
pick word bucket chosen bucket equally word picked chosen bucket word equally 
obtain discrete zipf distribution parameter roughly 
zipf distribution accurately reflect word occurrence probabilities wide variety situations 
value attribute simply line long string element content 
procedures data set structure facilitates study impact data characteristics system performance roughly twice number entries second edition oxford english dictionary 
half words benchmark derived words produced appending ing word 
version xml xsd sequence xsd schema xmlns xsd www org xmlschema www eecs umich edu db bm xsd xmlns www eecs umich edu db bm xsd qualified xsd element name type xsd complextype name mixed true xsd element name type minoccurs maxoccurs unbounded xsd key name au pk xpath xpath xsd key xsd element xsd unique xsd selector xsd field xsd unique name au xpath xpath xsd selector xsd field xsd element name type minoccurs xsd name au fk xpath aref xpath refer au pk xsd complextype xsd sequence xsd element xsd xsd selector xsd ref xsd field xsd xsd complextype name xsd complextype xsd xsd extension base xsd string xsd extension xsd attribute name aref type xsd integer name required xsd xsd attribute name type xsd integer required xsd attribute name type xsd integer required xsd attribute name type xsd integer required xsd xsd attribute name type xsd integer required xsd attribute name type xsd integer required xsd attribute name type xsd integer required xsd attribute name type xsd string required xsd schema benchmark specification xml schema sing song pocket full baked 
opened began sing wasn set 
king counting queen eating bread 
hanging came 
template string element content element attribute content simulates piece text natural language 
benchmark queries creating data set possible tease apart data different characteristics issue queries controlled vastly differing data access patterns 
interested evaluating cost individual pieces core query functionality evaluating composite performance queries application level 
knowing costs individual basic operations estimate cost complex query just adding relevant piecewise costs keeping mind pipelined nature evaluation changes sizes intermediate results operators pipelined 
find useful refer simple queries selection queries join queries clearly indicate functionality query 
complex query involves simple operations take time varies monotonically time required simple components 
choose set simple queries indicate performance simple components complex query 
designed data set engineer define additional queries test impact data characteristics may affect performance developing engines 
example engineer interested impact fanout system performance devise pair queries requests nodes level requests nodes level 
levels number nodes number node different 
subsections describe benchmark queries detail 
query descriptions types nodes assumed specified 
selection relational selection identifies tuples satisfy predicate attributes 
xml selection complex important tree structure 
consider query bibliographic database seeks books published year author name including string blake 
apparently straightforward selection query involves matches database node query pattern predicates associated elements book year author name 
match pattern may interested returning book element possibilities returning nodes participated match 
attempt organize various sources complexity 
returned structure relation tuple selected tuple returned 
xml saw example element selected may return element structure related element sub tree rooted element 
query performance significantly affected data stored returned result materialized 
understand role returned structure query performance query select elements selectivity query qr 
element 
return elements question including subelements 
qr 
subtree 
return entire sub tree rooted elements 
remaining queries benchmark simply return unique identifier attributes selected nodes aref occasional type explicitly specified 
design choice ensures cost producing final result small portion query execution cost 
note query selectivity value return result takes total bytes data identifier attributes selected nodes returned 
selection values xml queries involving element predicates show considerable diversity 
examine effect selection predicate values set queries 
detailed computation query selectivities appendix exact match qs 
selective attribute 
select nodes sing song 
selectivity 
qs 
non selective attribute 
select nodes sing song 
selectivity 
selection range values 
qs 
range value 
select nodes 
selectivity 
approximate match qs 
selective word 
select nodes element content distance keyword keyword 
selectivity 
qs 
non selective word 
select nodes element content distance keyword keyword 
selectivity 
structural selection selection xml patterns 
queries constructed consider multi node patterns various sorts selectivities 
patterns conditional selectivity consider simple node selection pattern 
nodes identified selectivity second node pattern differ selectivity database 
similar dependencies different attributes relation exist affecting selectivity multi attribute predicate 
conditional selectivity complicated xml different attributes may element different elements structurally related 
queries listed section return attribute root node selection pattern specified 
queries selectivity predicate noted predicate 
order sensitive selection qs 
local ordering 
select second element element sel second element sel 
selectivity 
qs 
global ordering 
select second element sel element sel 
query returns element previous query returns parent 
parent child selection qs 
non selective parent selective child 
select nodes sel approx 
child sel 
selectivity approximately 
qs 
selective parent non selective child 
select nodes sel approx 
child sel 
selectivity approximately 
ancestor descendant selection qs 
non selective ancestor selective descendant 
select nodes sel approx 
descendant sel 
selectivity 
qs 
selective ancestor non selective descendant 
select nodes sel approx 
descendant sel 
selectivity 
ancestor nesting ancestor descendant selection ancestor descendant queries qs qs ancestors nested ancestors 
test performance queries ancestors recursively nested ancestors ancestor descendant queries qs qs 
queries variants qs qs 
qs 
non selective ancestor selective descendant 
select nodes sel descendant sel 
qs 
selective ancestor non selective descendant 
select nodes sel descendant sel 
selectivities queries qs qs equivalent unnested queries qs qs situations descendants multiple ancestors match second number candidate descendants different fewer ancestor predicate satisfied nodes level predominantly satisfied nodes levels due large numbers 
effects may necessarily cancel 
focus local predicate selectivities keep queries parent child queries considered 
complex pattern selection complex pattern matches common xml databases section introduce number chain twig queries benchmark 
shows example query types 
node represents predicate element tag name predicate attribute value predicate element content match predicate 
structural parent child relationship query shown single line ancestor descendant relationship represented double edged line 
chain query shown finds nodes matching condition child matching condition child matching condition child matching condition twig query shown ii matches nodes satisfy condition child node satisfies condition descendant node satisfies condition benchmark uses complex queries qs 
chain query parent child joins selectivity value pattern high low low high 
query test choice join order evaluating complex query 
achieve desired selectivities predicates sel sel sel sel 
chain query ii twig query samples chain twig queries qs 
twig query parent child joins selectivity value pattern low high low low 
select parent nodes sel child sel child sel 
qs 
twig query parent child joins selectivity value pattern high low high low 
select parent nodes sel child sel child sel 
negated selection xml elements optional queries test existence optional elements 
negated selection query selects elements contain descendant optional element 
qs 
find elements element 
value join value join involves comparing values different nodes need related structurally 
computing value joins naturally expect nodes participating join returned 
returned structure pair attributes nodes joined 
qj 
selective value join 
select nodes sel join equality attribute 
selectivity query approximately 
qj 
non selective value join 
select nodes sel join equality attribute 
selectivity query approximately 
pointer join queries specify joins specified dtd xml schema implementation may optimized logical oids xml databases 
qj 
selective pointer join 
select nodes point node sel 
selectivity 
qj 
non selective pointer join 
select nodes point node sel 
selectivity 
pointer joins semi join queries 
returned elements nodes type nodes pointed 
aggregation aggregate queries important data warehousing applications 
xml aggregation richer possibilities due structure 
explored set queries 
qa 
value aggregation groupby 
compute average value attribute nodes level 
returned structure tree dummy root child group 
leaf child node attribute level attribute average value 
number returned trees 
qa 
structural aggregate selection 
select elements children satisfy sel 
selectivity 
qa 
structural exploration 
node level sel determine height sub tree rooted node 
selectivity 
functionalities casting significant performance factors engines need convert data types 
benchmark focus testing core functionality xml engines 
update load benchmark contains update queries include insert delete bulk load 
qu 
insert 
insert new node node 
new node attributes identical parent set new large unique value necessarily contiguous values assigned database 
qu 
delete 
delete leaf nodes 
qu 
bulk load 
load original data set set document 
document construction xml applications require construction reconstruction large new documents data stored 
applications usually deal document centric data web pages line news 
qc 
structure preserving 
return set documents sub tree rooted node level child type 
qc 
structure transforming 
node type parent parent database 
node direct child position place sub tree rooted 
return set documents sub tree rooted node 
benchmark action section analyze performance different databases michigan benchmark 
conducted experiments native commercial xml dbms university native xml dbms leading commercial 
due nature licensing agreement commercial systems disclose actual names systems refer commercial native system cnx commercial cor 
native xml database timber university native xml dbms developing university michigan 
timber uses shore storage manager implements various join algorithms query size estimation query optimization techniques developed xml dbmss 
provided leading database vendor hybrid inlining algorithm map dtd relational schema 
generate sql queries adopted algorithm 
queries benchmark converted sql queries sanitized remove system specific keywords query language michigan benchmark web site 
commercial native xml system provides xpath interface released xquery interface 
started writing benchmark queries xquery 
xquery interface unstable cases hang server java client run memory machine 
unfortunately interface available posing xquery queries commercial system 
consequently reverted writing queries xpath expressions 
cases run queries xquery interface xpath approach faster 
consequently query execution times reported queries written xpath 
actual queries commercial native xml system sanitized remove system specific keywords query language michigan benchmark web site 
experimental platform methodology experiments run single processor mhz pentium iii machine mb main memory running windows 
benchmark machine gb ide disk 
systems configured mb buffer pool size 
system setup commercial systems default settings systems choose software installation 
setting changed cor enable hash joins query response times generally improved option turned 
cor loading data update statistics provide optimizer current statistical information 
cnx tried running queries indices 
cnx permits building structure path indices value indices 
surprisingly indexing cases reduced performance queries 
cases performance improved non indexed case 
reason ineffectiveness index cnx indexing effectively handle operator invoked benchmark 
furthermore index effective retrieving elements recursively nested elements 
data sets experiment loaded base data set nodes mb raw data refer dsx 
wanted load larger scaled data sets cases xml parsers fragile break large documents 
consequently study decided load scaled version data 
scaled data set refer dsx produced changing nodes levels respectively 
scaled data set approximately th size dsx data set 
note nature document tree percentage nodes levels close leaves remains query selectivities stay roughly constant scaled data set 
purpose experiment loaded wrote queries scaled set base data set 
smaller data set size reduced time set queries load scripts systems 
queries scripts reused base data set 
expect strategy may useful users benchmark data generator benchmark available free download michigan benchmark web site allows generation scaled data set 
measurements experiments query executed times execution times reported section average middle runs 
queries run cold mode query execution times include side effects cached buffer pages previous runs 
benchmark results benchmark useful produce kinds tables summary table presents single number group related queries detail table shows execution time individual query 
summary table presents high level view performance benchmark queries 
contains entry group related queries shows geometric mean response times queries group 
shows summary table systems benchmarked indicates sections detailed numbers analyzed 
indicates queries run configuration system software 
geometric mean response times seconds discussed query group dsx dsx section query numbers cnx timber cor cnx timber cor idx idx idx idx returned structure qr qr exact match qs qs match qs qs order sensitive qs qs selection qs qs selection qs qs ancestor nesting qs qs complex pattern qs qs negated selection qs value join qj qj pointer join qj qj aggregation qa qa update qu qu bulk load qu construction qc qc benchmark numbers dbmss observe timber efficient processing xml structural queries qs qs 
implementation traditional relational style queries value joins qj qj highly tuned timber 
primarily timber research prototype development attention focused xml query processing issues covered traditional relational techniques 
cor execute queries ancestor descendant relationship queries qs qs 
cor performs parent child queries qs qs evaluated foreign key joins 
observe cnx usually slower systems 
large query overhead seconds dsx data set incurred cnx small queries 
overhead measured issuing query retrieves single root element document 
cnx considerably slower timber 
suspect reason poor performance cnx fourfold 
structure indices built database queries involve operator incurs post processing server dominates major chunk query processing time 
second suspect cnx builds tag indices structural indices 
result elements benchmark data set elements tag indices essentially useless 
furthermore system forced follow tag indices random accesses occur result compromised performance 
third value indices attributes nodes may cause random disk accesses query evaluation time document fit entirely memory incurs higher disk access costs sequential scan non indexed database 
situation optimizer ideally able evaluate different query plans choose optimal plan case sequential scan plan 
current version cnx optimizer favors index plans sequential scan plans cheaper 
detailed performance analysis section analyze impact various factors performance observed 
returned structure qr qr shows execution times returned structure queries qr qr 
response times seconds query query sel 
dsx dsx description cnx timber cor cnx timber cor idx idx idx idx qr return result element qr return entire sub tree benchmark numbers returned structure queries examining performance returned structure queries qr qr observe returned structure impact systems 
timber cor perform poorly sub tree returned qr 
surprising timber stores elements depth order retrieving sub tree fast sequential scan 
turns timber uses shore low level storage memory management initial implementation timber data manager shore call element retrieved 
poor performance qr helped timber designers identify implementation weakness steps address 
cor takes time selecting returning descendant nodes qr cor needs call recursive sql statements retrieving descendant nodes 
cnx takes time returning entire sub tree just returning element performance difference returning element returning element sub tree dramatic timber cor 
selection values qs qs section examine performance systems selection values queries 
performance numbers shown 
response times seconds query query sel 
dsx dsx description cnx timber cor cnx timber cor idx idx idx idx qs selection string value selective qs selection string value non sel 
qs selection range values benchmark numbers selection values queries exact match qs qs single attribute selection qs qs tested systems selectivity impact cor 
response time non selective query qs selective query qs response times grow linearly increasing selectivity 
hand selectivity impact timber large data set dsx relatively smaller data set dsx 
cnx perform dbmss 
selectivity impact cnx strong dbmss true indexing cnx 
response time non selective query qs higher selective query qs difference reflect linear growth 
range selection qs timber cor handle range predicate query just equality predicate 
systems performance range predicate query qs comparable equality selection query qs 
hand cnx takes little time evaluate range predicate query evaluate comparable equality selection query 
approximate match qs qs shows execution times approximate match queries qs qs 
response times seconds query query sel 
dsx dsx description cnx timber cor cnx timber cor idx idx idx idx qs string distance selection selective qs string distance selection non sel 
benchmark numbers approximate match queries cor measure distance words contained long string qs qs need invoke user defined function index 
consequently efficiency query independent selectivity string distance selection predicate 
cnx currently support string distance selections 
structural selection qs qs order sensitive selection qs qs execution times order selection queries qs qs shown 
response times seconds query query sel 
dsx dsx description cnx timber cor cnx timber cor idx idx idx idx qs local ordering qs global ordering node benchmark numbers order sensitive queries cnx local ordering qs global ordering qs slightly different 
timber local ordering qs results considerably worse performance global ordering qs requires random accesses 
hand global ordering qs performs requires random access 
cor local ordering qs expensive global ordering qs 
local ordering qs needs access number nodes satisfy order 
hand qs quickly returns soon finds tuple satisfies order predicates 
simple containment selection qs qs shows performance selected structural selection queries qs qs 
low high refers join parent low selectivity value child high selectivity value high low refers join ancestor high selectivity value descendant low selectivity value 
response times seconds query query sel 
dsx dsx description cnx timber cor cnx timber cor idx idx idx idx qs high low qs low high qs high low qs low high qs ancestor nesting high low qs ancestor nesting low high qs chain high low low high qs twig low high low low qs twig high low high low qs negated selection benchmark numbers structural selection queries seen results direct containment queries queries qs qs cor processes direct containment queries better timber timber handles indirect containment queries qs qs better 
cnx direct containment queries qs qs compared systems 
indirect containment queries qs qs performs better cor 
cnx slightly better performance direct containment queries qs qs indirect containment queries qs qs 
examining effect query selectivities cnx query execution example see queries qs qs notice execution times relatively immune query selectivities implying system effectively exploit difference query selectivities choosing query plans 
notice qs response times dsx data set slightly dsx data set 
examined query plans data sets cnx see system query plan 
small increase probably noise case query execution cost dominated overhead costs executing queries 
timber structural joins evaluate types containment queries 
structural join reads inputs ancestor parent descendant child indices 
keeps potential ancestors stack joins descendants descendants arrive 
cost evaluating ancestor descendant queries necessarily higher evaluating parent child queries 
cor efficient processing parent child queries qs qs translate foreign key joins system evaluate efficiently indices 
hand cor longer response times ancestor descendant queries qs qs 
evaluating queries cor tried approaches approach call recursive sql statements second approach write sql queries combine results queries union operators 
note queries schema data available approach applicable 
benchmark schema available allows system approaches 
report best execution time query approaches 
sql queries union operators approach suitable queries data ancestor nesting queries shallow data 
example query qs dsx data set recursive sql statement response time seconds 
contrast query second approach resulted query evaluation time seconds 
recursive approach suitable queries ancestor descendant queries deeply nested data 
example cost evaluating query qs dsx data set multiple sql queries union operators seconds 
contrast execution time query seconds recursive sql statement 
systems cor immune recursive nesting ancestor nodes ancestor nodes queries recursively nested ancestor nodes qs qs response times non recursive counterparts qs qs 
complex pattern containment selection qs qs timber performs complex queries 
breaks chain pattern queries qs twig queries qs qs series binary containment joins evaluating selective joins 
cor performs queries availability indices speed foreign key joins parents children 
cnx perform timber cor 
timber cnx breaks complex pattern queries series binary containment joins 
cnx inefficient implementation structural indexing causes system chase level nesting order find nodes question 
index access take time sequential scan occurs non indexed database 
irregular structure qs parts xml document may irregular data structures queries looking missing elements qs useful checking capability system handling irregularities 
query qs looks elements element 
looking irregular data structures cnx performs reasonably small scale database scale queries 
selectivity query qs fairly high database size increases size returned result grows dramatically 
cnx spends large part execution time processing results client part scale 
timber qs executed efficiently query evaluated variation structural join algorithm 
variation structural join algorithm executes usual algorithm joins simply outputs ancestors matching descendant 
cor ways implement query 
naive way set difference operation results long response time seconds dsx data set 
approach expensive cor needs find set elements contain missing elements recursive sql query find elements set 
second alternative implementing query left outer join 
alternative create view selects elements descendants requires recursive sql statement 
left outer join query view relation holds elements select elements view accomplished checking null value 
compared response time implementation seconds rewriting query results smaller response time seconds reported 
value pointer joins qj qj execution times join queries qj qj shown 
cnx timber show poor performance traditional join queries 
timber simple unoptimized nested loop join algorithm evaluate joins 
timber performs poorly qj qj high overhead retrieving attribute values random accesses 
cnx poor performance compared databases value join queries qj qj small scale version database due fact joins evaluated naive nested loop join algorithm 
complexity execution time queries data size 
selectivity factor impact value joins cnx pointer joins 
notice cnx scales better timber qj qj 
cnx results super linear scale timber scales poorly cor linear scale 
pointer join queries qj qj cnx performs worse cor shows super linear scale curve respect size database 
response times seconds query query sel 
dsx dsx description cnx timber cor cnx timber cor idx idx idx idx qj value join selective qj value hr hr hr join non sel 
qj pointer join selective qj pointer join non sel 
benchmark numbers traditional join queries response times seconds query query sel 
dsx dsx description cnx timber cor cnx timber cor idx idx idx idx qa value aggregation nodes groupby qa structural aggregate nodes selection qa structural exploration benchmark numbers aggregate queries cor performs class queries evaluated foreign key joins efficiently implemented traditional commercial database systems 
aggregation qa qa shows execution times aggregation queries qa qa 
timber structure xml data maintained reflected system 
structural exploration query qa performs 
hand value aggregation query qa performs worse due large number random accesses required fetching element values kept clustered 
cor evaluating structural aggregation query expensive evaluating value aggregation query 
relational representation structure xml data reconstructed expensive join operations attribute values accessed quickly indices 
response times seconds query query description dsx dsx cnx timber cor cnx timber cor idx idx idx idx qu insert qu delete qu bulk load benchmark numbers update queries response times seconds query query description dsx dsx cnx timber cor cnx timber cor idx idx idx idx qc structure preserving qc structure transforming benchmark numbers document construction queries cnx native xml database expect perform reasonably structural aggregation queries 
currently evaluate structural aggregation queries fast cor 
support functionality features needed aggregation queries qa qa 
update qu qu shows execution times update queries qu qu 
update operations qu qu currently supported cnx timber 
bulk loading query qu cor efficient cnx timber 
surprising commercial relational system pay careful attention performance bulk loading algorithms 
example commercial relational bulk load utilities bulk load index building index bottom 
contrast timber insert entry index time 
document construction qc qc shows execution times queries construct xml documents qc qc 
execution time query qc entirely reflect actual bulk reconstruction cor function available group content elements reconstruct xml document 
restructuring query qc takes excessive amount time finding updating descendants element require nested loop joins large number row scans 
document construction operations currently supported cnx timber 
performance analysis scaling databases section discuss performance systems data set scaled dsx dsx 
discussion refer results 
scaling performance cnx queries ratios response times dsx dsx qs consists nested aggregate count function 
indicates cnx scales linearly super linearly respect database size 
scaling performance timber timber scales linearly queries response time ratio approximately exceptions 
exception large returned results constructed 
case timber inefficient scales poorly discussed section 
second exception value join invoked 
value join implementation naive scales poorly 
scaling performance cor cor ratios response times dsx dsx data sets approximately showing linear scale 
exceptions linear scale occur types queries approximate match queries update queries document construction queries 
approximate match queries scale poorly 
queries qs qs cor requests table scan user defined function search tuples satisfy predicates 
costs finding predicate words computing distance words increase rapidly table size increases 
indicates performance gets worse data size increases update queries 
complexity finding updating elements related deleted inserted elements 
joins update queries nested loop joins grow exponentially respective input sizes 
cor performs poorly document construction queries 
experimental results queries qc show cor spends significant amount time reconstruct results 
shanmugasundaram addressed problem proposed techniques efficiently publishing querying xml view relational data 
techniques currently implemented cor 
proposed benchmark identify individual data characteristics operations may affect performance xml query processing engines 
careful analysis benchmark queries engineers diagnose strengths weaknesses xml databases 
addition engineers try different query processing implementations evaluate alternatives benchmark 
benchmark simple effective tool help engineers improve system performance 
benchmark evaluated xml systems commercial xml system timber commercial 
results show commercial native xml system substantial room performance improvement queries 
benchmark invaluable tool development native xml database timber helping identify portions system need performance tuning 
consequently benchmark queries timber outperforms systems 
notable exception behavior poor performance timber traditional value join queries 
benchmarking effort shows sensitive method translate xml query sql statements 
shown true xml queries past show true simple indirect containment queries queries search irregular structures 
demonstrate recursive sql statements evaluate structural query benchmark recursive sql statements expensive efficient xml structural join algorithms implemented timber 
note proposed benchmark meets key criteria successful domain specific benchmark proposed 
key criteria relevant portable scalable simple 
proposed michigan benchmark relevant testing performance xml engines proposed queries core basic components typical application level operations xml application 
michigan benchmark portable easy implement benchmark different systems 
fact data generator benchmark data set freely available download michigan benchmark web site 
scalable scaling parameter 
simple comprises single document set simple queries designed test distinct functionality 
naughton zhang 
generating synthetic xml data 
proceedings international workshop web databases pages santa barbara california may 
jagadish koudas patel srivastava wu 
joins primitive efficient xml query processing pattern matching 
proceedings ieee international data engineering san jose ca 
barbosa mendelzon lyons 
extensible data generator xml 
proceedings international workshop web databases pages madison wi 
hme rahm 
benchmark xml data management 
proceedings german database conference btw oldenburg germany march 
lacroix lee li 
applying oo benchmark xml query processing tools 
proceedings acm international conference information knowledge management pages atlanta georgia november 
carey dewitt franklin hall mcauliffe naughton schuh solomon 
persistent applications 
proceedings acm sigmod international conference management data pages minneapolis minnesota 
carey dewitt naughton 
oo benchmark 
sigmod record acm special interest group managment data 
ibm 
db xml extender 
www ibm com software data db 
microsoft 
microsoft sql server 
www 
microsoft com sql xml 
oracle 
xml oracle oracle 
com tech xml content html 
transaction processing performance council 
tpc benchmarks 
www tpc org 
dewitt 
wisconsin benchmark past 
gray editor benchmark handbook database transaction systems 
morgan kaufmann second edition 

xis extensible information server 
www 
odi com products xis 
fernandez suciu 
efficient evaluation xml middle ware queries 
proceedings acm sigmod international conference management data philadelphia pennsylvania may 
goldman mchugh widom 
data xml migrating lore data model query language 
proceedings international workshop web databases pages philadelphia pennsylvania june 
gray 

gray editor benchmark handbook database transaction systems 
morgan kaufmann second edition 
mchugh abiteboul goldman quass wid om 
lore database management system semistructured data 
sigmod record september 
lacroix lee li 
efficient xml data management analysis 
proceedings rd international conference electronic commerce web technologies pages aix en provence france september 
sahuguet dupont nguyen 
querying xml new millennium 
db cis upenn edu 
schmidt kersten florescu carey manolescu busse 
benchmark xml databases 
sigmod record september 
schmidt kersten florescu manolescu carey busse 
xml benchmark project 
technical report cwi amsterdam netherlands april 

dbms designed xml 
proceedings ieee international data engineering pages heidelberg germany april 

internet database system 
proceedings international conference extending database technology pages konstanz germany march 
shanmugasundaram shekita fan 
querying xml views relational data 
proceedings international conference large data bases pages roma italy september 
shanmugasundaram shekita barr carey lindsay pirahesh 
efficiently publishing relational data xml documents 
vldb journal 
shanmugasundaram tufte zhang dewitt naughton 
relational database querying xml documents limitations opportunities 
proceedings international conference large data bases pages edinburgh scotland september 
poet software 

www com fo corporate homepage html 
michigan benchmark team 
michigan benchmark xml query performance diagnostics 
www eecs umich edu db 
timber database team 
tree structured native xml database implemented university michigan timber 
www eecs 
umich edu db timber 
bitton 
asap ansi sql standard scaleable portable benchmark relational database sytems 
gray editor benchmark handbook 
morgan kaufmann second edition 
yao tamer zsu 
family benchmarks xml dbmss 
vldb workshop efficiency effectiveness xml tools techniques 
query selectivity computation benchmark queries carefully chosen desired selectivity 
appendix describe computation selectivities analytically 
purpose frequently need determine probability pick word uniform distribution buckets words bucket described section 
example indicates word bucket 
buckets word bucket probability picked 
words fourth bucket probability picked 
qr qr 
select elements 
queries selectivity selected attribute probability 
qs 
select nodes sing song 
selectivity probability 
qs 
select nodes sing song 
selectivity probability 
qs 
select nodes 
selectivity qs 
select nodes element content distance keyword keyword 
probability occurrence selected 
placeholders distance 
selectivity 
qs 
select nodes element content distance keyword keyword 
occurrences words occurrences away 
probability occurrence selected 
selectivity 
qs 
select second element element second element 
number nodes level number fanout level 
number second element nodes 
selectivity element probability second element parent 
selectivity query 
qs 
select second element element 
query returns element 
qs 
select nodes child 
predicate selectivity second predicate selectivity 
argument selectivity query 
qs 
select nodes child 
predicate selectivity second predicate selectivity 
argument selectivity query 
qs 
select nodes descendant 
predicate selectivity 
node level descendant children probability nodes satisfies second predicate 
selectivity 
qs 
select nodes descendant 
predicate selectivity 
level node descendants probability nodes satisfy second predicate 
selectivity query 
qs 
query test choice join order evaluating complex query 
achieve desired selectivities predicates 
probability probability 
selectivity query 
qs 
select parent nodes child child 
probability 
selectivity query 
qs 
select parent nodes child child 
probability 
selectivity query 
qj 
select nodes join equality attribute 
probability selectivity query 
qj 
select nodes join equality attribute 
probability selectivity query 
qj 
select nodes point node 
query returns nodes probability nodes 
selectivity query 
qj 
select nodes point node 
query returns nodes probability occasional type nodes 
selectivity query 
qa 
compute average value attribute nodes level 
query returns nodes contains average values levels 
qa 
select elements children satisfy 
database nodes level children 
remainder exactly children satisfy predicate node qualify 
selectivity predicate 
selectivity query qa 
node level determine height sub tree rooted node 
nodes level nodes selectivity query 

