implementing type classes john peterson mark jones department computer science yale university box yale station new haven ct usa 
electronic mail peterson john cs yale edu jones mark cs yale edu 
describe implementation type checker functional programming language haskell supports type classes 
extends type system ml support overloading ad hoc polymorphism implement features equality types numeric overloading simple general way 
theory type classes understood practical issues involved implementation systems received great deal attention 
addition basic type checking algorithm implementation type classes requires form program transformation 
current haskell compilers takes form dictionary conversion functions hidden parameters overloaded values 
efficient techniques type checking dictionary conversion 
number optimizations extensions basic type class system described 
study programming languages term overloading describe ability single symbol different interpretations determined context appears 
standard examples include represent addition integers addition floating point quantities compare character values pointers 
case intended meaning overloaded symbol determined types arguments applied 
common approach completely resolve overloading compile time 
compiler installs type specific meanings overloaded symbols type information attached operands usual case general overloading resolution mechanism 
significant drawback approach overloaded operations abstracted retaining overloaded nature 
dynamic approach overloading preserves ability overloaded definitions object oriented languages 
resolution overloaded operations occurs run time 
particular problems dealt ffl determine interpretation overloaded operator particular situation 
examples appropriate overloading determined compile time 
example program uses function double double integer floating point values way fix single interpretation symbol 
ffl ensure overloaded values appropriate arguments 
example probably sense try add character values 
result ensure double function applied character value 
standard ml uses different approaches overloading ffl type arithmetic operator uniquely determined context possibly inserting explicit type declaration 
compile time resolution overloaded operators able preserve full overloading double function specific implementation chosen 
ffl standard ml introduces notion equality types deal typing equality function 
undesirable forces programmer accept particular structural definition equality tests equality representation equality represented value 
addition appel reports equality types add significant complexity language implementation :10.1.1.17.2744
alternative approach treatment overloading introduced wadler blott notion type class intended provide uniform general framework solving exactly kinds problems :10.1.1.47.1059:10.1.1.130.789
type classes widely known functional programming language haskell deal standard primitive functions 
addition type classes useful specific application areas help produce clear modular programs 
mention appear significant reason type classes limited non strict purely functional languages principle language basic hindley milner damas type system extended support type classes 
meant serve practical guide implementation type classes 
previous area concentrated typing rules culminated set syntax directed typing derivations basis type checker 
typing rules create concrete algorithm type checks transforms program 
hope reveal essential simplicity theory implementation type classes 
concerns type checking programs efficiently generating best possible code type checker introducing number simple extensions type classes incorporated basic framework 
result experience implementing type classes yale haskell compiler gofer interpreter 
type classes summary summarizing main features system type classes simple known example definition equality operator written ffl polymorphic operator restricted values single type 
ffl overloaded interpretation equality determined types arguments 
ffl extensible definition equality extended include new datatypes 
example programs written concrete syntax haskell explanatory comments necessary 
details may 
terms describing class system method primitive overloaded operator called method 
methods expressions 
class group related methods packaged class 
class name type language 
data type type classes sort data types ml type system 
type constructor names data type type language data constructors create values expression language 
instance instance binds data type operations implement methods specified class type 
basic idea define set types eq known type class haskell contains precisely types suitable definition equality instance declaration 
definition class eq follows class eq 

bool line introduces name class indicates type variable represent arbitrary instance class part definition 
general case expression form represent assertion type instance class 
remaining part declaration lists collection method functions associated class 
particular example single method function written infix operator 
type signature 

bool indicates instance eq symbol behaves function takes arguments type returns value type bool 
class declaration may define set superclasses class 
superclasses significantly complicate type system discussed 
notation haskell full type written eq 


bool 
note convention free variables type expression implicitly bound universal quantifier outermost level 
polymorphic choice types restricted instances eq 
type class constraints described context part type 
defined single instance class operator indirectly directly define values 
restriction instances eq reflected types assigned values 
example member eq 


bool member false member ys member ys line definition gives type member 
note haskell represents type lists values type basic ml type system user supplied type signatures required inferred automatically type system 
provide signatures examples documentation 
second third lines typical way functions defined haskell 
example equations pattern matching left hand side distinguish cases list argument member empty non empty written ys ys head tail respectively list 
types members class defined collection instance declarations may distributed program typically different program modules new datatypes introduced 
built types definition equality may provided primitive function instance eq int generally define instances class eq built user defined algebraic data types definition equality lists instance eq 
eq true xs ys xs ys false underscore character line wildcard indicates cases applied equality test produce result false 
expression eq 
eq line indicates definition equality lists depends definition equality elements held list instance eq 
set types defined finite collection instance declarations may infinite recursively enumerable 
example definitions describe equality operator integers lists integers lists lists integers forth 
implementing overloading standard technique implementation runtime overloading attach kind tag concrete representation object 
overloaded functions equality operator described implemented inspecting tags arguments dispatching appropriate function tag value 
schemes exist encoding tags tag dispatch efficient 
essentially method deal equality function standard ml new jersey 
benefits static type checking provides compile time check ensures equality function applied object corresponding definition equality 
unfortunately tags described number drawbacks 
complicate data representation may suited underlying hardware 
significantly forms overloading implemented approach 
particular possible implement functions overloading defined returned type 
simple example read function haskell parse string value type instance text class set readable printable types 
elegant way avoid problems separate objects tags treating tags data objects right 
example implement read function takes extra argument gives tag result value 
amounts passing type information run time necessary overloaded functions involved 
potentially efficient uniformly tagging data object regardless 
approach member function previous section implemented translating original definition member 

bool 


bool member eq false member eq ys eq member eq ys words implementation member simply parameterized appropriate definition equality 
tag case equality function 
example evaluate member rewriting member evaluating expression :10.1.1.17.2744
interesting example xs list lists integers evaluate member xs similar way rewriting member eqlist xs eqlist :10.1.1.17.2744

bool 


bool eqlist eq true eqlist eq xs ys eq eqlist eq xs ys eqlist eq false definition eqlist obtained directly instance declaration lists section way definition member obtained member 
type classes require particular definition equality data type function appropriate type supplied user check equality 
convenience haskell allows programmer derived instances standard classes eq automatically generating appropriate instance definitions 
note feature part underlying type system 
goals remainder describe translations obtained automatically part type checking process 
static analysis type checking compiler assemble components static type environment 
data type class instance declarations top level declarations haskell collected processed 
constraint declarations instances unique instance declaration particular combination data type class allowed 
ensures meaning overloaded operations respect parameter data types consistent program 
previous section described member function implemented parameterizing definition respect implementation method 
general case class may different methods sensible parameterize definitions overloaded functions dictionary values tuples containing implementations methods particular instance class 
static analysis generates dictionary instance declaration dictionaries may overloaded 
dictionary contains overloaded functions manifested context component instance declaration constructed 
dictionary containing eqlist need overloaded provide eq argument eqlist 
implementation captured dictionary stored partially applying eqlist just eq argument dictionary containing eqlist created 
instance converted tuple containing data type class dictionary context associated instance 
definition inserted program binds dictionary value tuple method functions variable dictionary variable 
instance context represented list class constraints class constraint argument data type defined instance 
class constraint possibly empty list classes apply constituent type 
instance declaration list equality create dictionary eq list eqlist declaration represented list eq eq list eq list name list type data constructor 
class method tuple needed normally dictionary tuple containing definition method 
context indicates argument list type constructor eq class 
dispatching method requires selection appropriate function dictionary 
selector functions method dictionary defined static type environment processed 
previous example selectors needed tuple dictionary 
simply extract component dictionary tuple constant time operation member function located specific place dictionary 
dictionaries overloading resolved compile time 
type associated method known compile type type specific version method called directly dictionary 
type inference separate issues type inference program expression assigned possibly overloaded type dictionary conversion program code transformed explicitly extract method functions dictionaries 
implementation ml style type inference documented repeat see example 
concentrate relatively minor changes needed extend ml style type inference support type classes 
ordinary ml typechecking type variables unification play central role 
type variables initially unbound corresponding unknown types 
type checking proceeds various constraints values assigned type variables exposed example ensuring argument type function type value applied 
constraints solved instantiating unbound type variables accurate types 
type classes require additional field uninstantiated type variable context set represented list classes 
unification affected simple way type variable instantiated class constraints passed instantiated value 
type variable context augmented set union context instantiated variable 
context passed type constructor context reduction required 
context reduction uses instance declarations static type environment propagate class constraints type variables 
type constructor reduced context reduction instance reducing class 
type checking fails error attempt overloaded operator type instance corresponding class 
instance declaration linking data type class context instance declaration propagates type constructor arguments 
process continues contexts propagated exclusively type variables 
example consider unification eq 
type variable eq context type integer 
type variable instantiated integer 
context reduction resulting type eq integer 
integer 
instance declaration class eq list data type exists type error occurs propagates context eq argument list type constructor 
leads type eq integer 
integer 
see program include instance declaration integer instance class eq 
assuming true integer type constructor take arguments constraints exist leaving integer resulting type 
note unification failed required instance declarations static type environment 
similar process unification eq 
yield type eq 

contexts remain attached resulting type variables 
code implements type variable instantiation presence type classes 
type variable value field null uninstantiated contains type 
context field list classes attached uninstantiated type variables 
function searches static type environment instance selected class data type 
function signals type error 
returns list contexts argument data type 
tyvar type tyvar value type tyvar context type classes type tyvar type type context union classes type context classes type class type type tycon class tycon args minor change ml type inference required 
letrec typechecked variables defined letrec share common context 
discussed section 
worth emphasizing context reduction significant change ml type inference process necessary infer correct typings haskell programs involving type classes 
hand dictionary conversion described section similar process carried implement overloading final executable version type checked program 
dictionary conversion dictionary conversion affects generated code ways 
overloaded definitions receive additional parameter variables bind dictionaries 
second overloaded definition passed dictionaries 
typechecker needs basic changes overloaded definition usually function may type type checked hidden dictionary parameters inserted 
definition top level local definition letrec typed hidden dictionary arguments inserted bind necessary dictionaries needed resolve overloading run time 
relation type signature dictionary parameters simple element context corresponds dictionary passed overloaded definition 
example function type eq text 

require dictionaries class eq text 
ordering context arbitrary dictionaries passed order long ordering consistently 
adding dictionary passing code program code walk performed standard ml typechecker essential implementation issue addressed 
type associated expression may change due unification type checker proceeds 
types generalization appropriate dictionaries needed resolve overloading determined entire expression generalized walked 
avoid second pass code generalization hold necessary bits unresolvable code placeholders 
placeholder captures type object resolved type 
generalization placeholders replaced required type dependent code 
inserting placeholders placeholders inserted type checker encounters overloaded variable method letrec bound variable 
slightly different forms placeholder case 
overloaded variables rewritten application placeholders ultimately replaced dictionaries implied variable context 
fresh type variables associated variable captured placeholders 
example type num text 

type checker freshly instantiate type variables yielding typing num text 


fresh instantiation type variables part ordinary ml style type checking 
value rewritten application num 
text 
object type 
notation represent placeholders 
placeholders additional arguments placed ahead arguments 
classes text num appear placeholders indicate placeholder resolve expression yielding dictionary class 
method functions converted directly placeholders 
type variable placeholder corresponds type variable defines class class declaration 
example method class eq typechecked freshly instantiating type yielding eq 


bool returning placeholder 
object placeholder method resolved specific implementation method type variable instantiated concrete type code select function eq dictionary 
recursively defined variables converted type known 
variables encountered generalized simply replaced placeholder correct context determined 
example simple recursive definition member recursive call member placeholder type generalized 
generalization treated ordinary overloaded variable 
inserting dictionary parameters definition typed context associated type variables definition generate dictionary parameter variables bind dictionaries needed resolve overloading 
occurs generalization portion type inference 
generalization gathers uninstantiated type variables type definition creates new dictionary variable element context type variables 
lambda binds dictionaries wrapped body definition parameter environment created 
environment resolve placeholders created typechecking definition 
environment maps pair containing class type variable dictionary parameter variable 
simple example inferred type num text 

definition changed 
original definition creates parameter environment num text 
resolving placeholders generalization placeholders inserted definition resolved 
list placeholders updated new placeholder created avoid walking code search placeholders 
dictionary parameters inserted placeholder examined 
placeholders associated methods classes type associated placeholder determines resolved 
possibilities 
type type variable parameter environment 
case mapping defines variable carry dictionary run time 
class placeholder resolved dictionary parameter variable method placeholder requires selector function applied dictionary variable 

type instantiated type constructor 
instance declaration associated type supplies method method placeholder dictionary variable class placeholder 
dictionaries methods may overloaded type checker may need recursively generate placeholders resolve additional overloading 

type variable may bound outer type environment 
processing placeholder deferred outer declaration 

conditions hold ambiguity detected 
ambiguity may resolved language specific mechanism simply signal type error 
placeholders associated recursive calls resolved different ways 
simplest way generate overloaded variable different overloaded variables 
done generalization context recursive call unknown time 
dictionaries passed recursive call remain unchanged original entry function need pass dictionaries inner recursive calls eliminated inner entry point dictionaries bound 
example shown section 
examples illustrate operation type checker couple examples consists code trees 
code tree shows freshly instantiated type variables ti inserted placeholders 
rules instantiating type variables type templates ml type checking 
second tree shows result unification 
types unified pairwise lines diagrams 
result generalization placeholder resolution shown 
actual type checker performs unification continuously type variables steps separated clarity 
write context associated type variable time mentioned type variable context information shown side 
function uses method recursive call 
class num 


type variable instantiation placeholder insertion produce expression tree 
nodes curried applications 
letrec context num unification letrec context num type placeholder associated part parameter environment 
indicates dictionary passed contain implementation appropriate parameter execution time sel function retrieve addition function dictionary 
simplest translation recursive call passes dictionary unchanged 
better choice create inner entry bound recursive call avoid passing repeatedly 
letrec sel example uses previously defined overloaded function length type 
int 
necessary class instance declarations included 
convention dictionaries named class type 
class text print 
string instance text text 
text print print tuple instance text int instance text 
text 
print length placeholder insertion type variable instantiation print tuple length context text string int unification print int tuple length context text string string int string int int placeholder resolved specific printer tuples 
function overloaded placeholder resolution required types associated tuple components 
print tuple text list text int tuple length extensions implementation type classes extended number ways improve generated code increase expressiveness type system 
class hierarchy haskell class declaration set classes may declared superclasses defined class 
example declaration class text 
num class text superclass num 
implies datatypes declared class num declared text 
superclass relation allows type num text 
abbreviated num 
type checker superclasses require changes 
class sets type variables constructed contexts implied superclass relation removed 
compacts class sets requires fewer dictionary parameters 
superclasses require dictionaries contain superclass dictionaries 
dictionary conversion dictionary may directly available associated class absorbed superclass 
case dictionary method fetched embedded superclass dictionary 
dictionary representation affects speed method selection 
deeply nested dictionaries avoided flattening dictionaries include methods associated class superclasses top level structure 
slows dictionary construction speeds selection operations 
effect tradeoff real programs known 
optimizations avoid dictionary construction flattening attractive 
default method declarations class declarations may supply default method instance declaration provide implementation method class 
requires definition bound variable dictionary construction 
variable placed dictionary method specified instance declaration 
typing recursive definitions far assumed letrec construct binds variable 
mutually recursive definitions understood tupling functions 
mutually recursive functions defined follows letrec 
single recursive value tuple 
notice context combined translation 
mutually recursive functions implemented tuples type checked manner 
functions defined single letrec share common context 
may create ambiguous functions type letrec bound variable contain full context letrec 
function called letrec outside 
error compiler provides warning functions 
easy single recursive function local entry point avoid passing dictionaries recursive calls harder function 
simplest pass dictionaries recursive call letrec 
outside entries recursive group functions needs single lambda binding dictionaries sort switch required enter proper function 
approaches may possible critical performance issue 
reducing constant dictionaries source inefficiency local functions inferred overloaded type overloading 
detected optimization type inference 
type inference involves saving type variables created freshly instantiation signature referenced 
variables instantiated concrete type dictionary reduced constant 
flow analysis dictionaries accomplish task superior optimizations may remove function calls prevent dictionary marked invariant 
overloaded methods haskell allows method functions overloaded type variable defined class 
example class definition may contain class foo bar 


contains extra overloading 
dictionary class type bar 


type class foo 
component overloaded function bar context second component independent bar 
unfortunately type signature valid context float outside tuple 
implementation terms tuple attempt bind dictionary bar dictionary constructed simply placing function binds bar dictionary inside tuple 
requires implementation dictionaries go outside standard type class system generating dictionaries 
cleanest solution problem probably involve existential types 
yale compiler avoids issue internal construct similar type cast 
user supplied signatures user supplied type signatures necessary part type system 
avoid unwanted overloading essential efficiency 
ml type system user supplied signatures significant impact generated code possibly replacing higher order function calls method selectors direct calls instance functions 
numerous ways implementing signatures system clean way readonly type variables 
type variables signatures marked read prevent type instantiation violating signatures 
read type variable instantiated context augmented 
user supplied signatures fix ordering dictionaries dictionary conversion 
haskell uses interface files support separate compilation 
interfaces provide signature definition module 
interface signatures define specific ordering dictionaries passed resolve overloading implementation level types foo bar 

bar foo 

different important way 
compiler aware interface module compiled signature determine dictionary ordering generalization 
monomorphism restriction haskell report imposes constraint known monomorphism restriction generalization overloaded variables 
intended avoid problems loss laziness occur overloaded variable translated function dictionary parameters 
explicit type signatures avoid monomorphism restriction cases overloading restricted 
regardless monomorphism issue treated simple implementation 
restriction applies variable type variables context generalized remain type environment avoid fresh body defining expression type checked 
avoiding unnecessary dictionary construction overloaded dictionaries constants constructed run time 
algorithm may repeatedly reconstruct identical copies overloaded dictionaries underlying implementation fully lazy 
illustrate problem occur consider implementation equality lists essentially form eqlist true eqlist xs ys eq eq xs ys eqlist false function constructs dictionary equality lists type dictionary equality values type eq function denotes selector extracts method corresponding dictionary :10.1.1.47.1059:10.1.1.130.789
written implementations definition repeat construction dictionary step recursion 
simple way avoid rewrite definition form eqlist eql eq eqa eq true xs ys eqa eql xs ys false example thing consider function type 

bool class suppose definition function requires construction dictionary value 
note fact may hidden compilation system definition appears external module 
suppose define function xs xs naive implementation definition xs xs attempt evaluate complete list produced application function repeat construction redex repeat dictionary construction element argument list 
happily observation solution problem quite obvious need just dictionaries involved application overloaded operators dictionaries giving translation xs xs additional benefit garbage collector reclaim storage dictionary values soon implementations required methods extracted 
note problems occur implementation supports full laziness 
examples improved translation obtained original version translation fully lazy form described 
performance issues type classes affect compiler 
observation increase compilation time slightly 
minor increase cost unification placement resolution placeholders majority extra processing required type classes 
far program execution concerned type classes costs extra level indirection dispatching method function time space required propagate dictionaries overloaded functions 
cost instance function dispatch quite small requires tuple element followed function call 
simplest method functions negligible 
cost dictionary creation propagation harder pin 
passing storing extra arguments overloaded functions incur slightly function call overhead 
overloaded dictionaries consume non constant amount space 
code overloaded functions may method functions class system adds overhead specific instance functions called directly 
case lazy language haskell overhead overloaded functions may greater overloading implemented higher order functions 
higher order functions may expensive haskell ml harder apply strictness uncurrying optimizations 
noticable simple functions basic arithmetic operators complex functions system overhead overloading noticable 
possible completely eliminate dynamic method dispatch overloaded function specific creating type specific clones overloaded function 
implemented general partial evaluation context controlled program annotations 
related type classes relatively new addition type theory argue longer considered exotic experimental 
type classes provide elegant solution number serious language design problems considered important tool programming language construction 
type classes provide simple regular framework program parameterized 
provide expressiveness example ml module system parameterization explicit 
hand particularly convenient applications code needed support overloading handled automatically compiler 
shown implementation type classes relatively simple requiring extensions basic ml type checking algorithms 
addition type classes severely impact compiler program performance 
basis translation haskell syntax declaring type classes set wadler blott results early implementation directly ideas hammond blott :10.1.1.47.1059:10.1.1.130.789
ideas fairly level static semantics haskell concentrating problems repeated dictionary construction 
techniques improve performance haskell overloading chalmers haskell compiler described 
summary experience development haskell systems done reduce costs type class overloading 
acknowledgments supported darpa contract number nsf contract number ccr 
appel :10.1.1.17.2744
critique standard ml 
princeton university cs tr february 
appel 
compiling continuations 
cambridge university press 
augustsson 
implementing haskell overloading 
appear conference functional programming languages computer architecture copenhagen denmark june 
damas milner 
principal type schemes functional programs 
th annual acm symposium principles programming languages 
hammond blott 
implementing haskell type classes 
proceedings glasgow workshop functional programming scotland 
workshops computing series springer verlag 
hudak peyton jones wadler eds 
report programming language haskell version 
acm sigplan notices may 
jones 
computing lattices application type classes 
journal functional programming volume part october 
jones 
qualified types theory practice 
phil 
thesis 
programming research group oxford university computing laboratory 
july 
peyton jones lester 
modular fully lazy lambda haskell 
software practice experience may 
peyton jones wadler 
static semantics haskell draft 
manuscript department computing science university glasgow february 
wadler blott :10.1.1.47.1059:10.1.1.130.789
ad hoc polymorphism ad hoc 
acm principles programming languages 
