transparent proxies java futures cs umd edu university maryland college park college park md michael hicks cs umd edu university maryland college park college park md jaime cs umd edu university maryland college park college park md cs tr umiacs tr proxy object surrogate placeholder controls access target object 
proxies support distributed programming lazy parallel evaluation access control simple forms behavioral reflection 
wrapper proxies futures suspensions computed results require significant code changes statically typed languages proxies generally inadvertently violate assumptions transparency resulting subtle bugs 
solve problems designed implemented simple framework proxy programming employs static analysis qualifier inference additional novelties 
code wrapper proxies automatically introduced classfile classfile transformation potential violations transparency signaled programmer 
formalized analysis proven sound 
framework variety applications including support asynchronous method calls returning futures 
experimental results demonstrate benefits framework programmers relieved managing checking proxy usage analysis times reasonably fast overheads introduced added dynamic checks negligible performance improvements significant 
example changing lines simple rmi peer peer application framework resulted large performance gain 
proxy object surrogate placeholder controls access object 
example proxy popularized multilisp 
multilisp syntax designates expression evaluated concurrently 
returned time program claims possibly blocking result evaluating available 
example code lists sorted parallel new thread parent thread merge mergesort mergesort results mergesort computations passed merge routine argument second argument sorted list 
multilisp claims performed transparently interpreter 
example allows programmer write merge takes sorted lists arguments interpreter perform claims necessary 
general programmer simply inserts annotations program runtime transparently takes care rest 
futures simple lightweight 
example wrapper proxy wraps actual result actual result needed unwrapped retrieve 
examples wrapper proxies include suspensions wrappers lazy computations capabilities wrappers controlled resources 
support wrapper proxies java kind transparency afforded multilisp 
add futures provide asynchronous method calls return non void result 
existing proposals fall short goal futures manifest programmer 
example java util concurrent library defines java interface public interface get get long timeout unit 
introducing util concurrent futures java program imposes programming tasks 
value passed function function type changed 
example change type merge take list argument object merge called normal list objects 
second futures claimed manually calling get 
example merge function claim list store values merged list 
claim avoid revealing identity expression doing lead subtle bugs call transparency violations 
example wrapping false result unexpected behavior storing value container 
changing types adding claims require considerable programming effort add futures remove 
solve problems developed framework proxy programming 
core framework static analysis tracks proxy flow possible need added synchronization due side effects computations 
program coupled transformation implement proxy manipulations runtime 
customize framework programmer specifies syntactic points proxy introduced specifying method call asynchronous expression forms require claim proxy argument 
programmer provides code implements claim 
framework variety applications implemented support transparent futures 
programmer indicates method call asynchronous specifies thread manager handling call 
thread managers include global thread pools object thread pools 
programmers influence futures claimed 
essence framework drastically simplifies programming futures util concurrent timely release java 
implemented support transparent suspensions 
programmer annotates method call performed lazily call delayed suspension claimed 
implemented analysis discover possible transparency violations due interface proxies large programs 
interface proxy shares interface target object specified proxy design pattern 
wrapper proxies incorrect usage proxies result transparency violations 
static analysis qualifier inference improves ways :10.1.1.24.8366
support dynamic coercions needed claim futures wrapper proxies 
second simple form flow sensitivity avoid claiming expression 
framework developed proxy programming advances apply qualifier systems general 
described section enable number new improved applications including tracking security sensitive data program supporting stack allocation non null types 
contributions describes design theory implementation evaluation framework proxy programming 
contributions formalize problem transparent proxy programming qualifier inference extending existing algorithms support dynamic coercions form flow sensitivity 
formalized analysis extension featherweight java fj proven sound section :10.1.1.109.1141
consider qualifier inference object oriented setting approach enables new improved applications qualifier systems section 
design implementation applications framework described programming transparent futures suspensions section discovering transparency violations section 
evaluate framework performance applications section 
analysis times comparable similar static analyses overheads due inserted claims negligible 
section describes profitably futures suspensions rmi peer peer application changing lines resulted large performance gain 
section describes transparency analysis discovered number potential transparency violations arising interface proxies large programs 
overview section overview framework including api seen user basic flavor static analysis 
user api inputs framework takes application library classfiles analyze proxy policy implementation specification pspec respectively 
outputs framework produces modified application library classfiles form new application 
pspec allow user customize framework support different kinds proxies 
particular pspec defines syntactic patterns program indicate proxies introduced coerced indicates proxy coercion implemented runtime 
framework consists parts static analysis uses pspec program transformation uses 
static analysis discovers proxies introduced program tracks flow 
analysis observes proxy flow location requiring non proxy requiring coercion convert proxy non proxy 
results static analysis program transformation generates modified program 
particular code proxy site modified create proxy runtime code inserted coercion site implement proxy non proxy coercion 
example consider implement asynchronous method calls java api details section 
proxy pspec follows policy spec proxies introduced method calls marked user asynchronous 
expressions identity revealing dynamic downcasts subexpressions instanceof operate non proxies necessitating possible coercion 
concrete usage object invocations methods extractions fields requires non proxy 
implementation spec calls marked asynchronous replaced code executes original call separate thread returns placeholder eventual result 
coercing possible requires checking analysis may imprecise calling get method extract underlying object 
may entail waiting result available 
lazy method calls supported similarly applications described section 
implementation details section 
goal framework normal software development programmer develops annotated files framework generates final bytecode 
alternatively framework add needed features java program annotated files simply direct transformation development proceed modified files 
allow programmers manually optimize compiled code eliminate benefits lighter weight specification proxies development 
turn overview analysis 
proxies qualifiers conceptually particular program variable refers proxy independent variable type 
think proxies type qualifiers refine meaning particular type 
qualified type written qualifier type 
familiar type qualifier final variable qualifier immutable variable actual type may 
proxies annotated way 
variable qualifier nonproxy definitely proxy qualifier proxy may may proxy 
qualified types admit natural subtyping relationship 
particular nonproxy proxy 
object definitely proxy may may proxy expected 
problem solved framework akin qualifier inference :10.1.1.24.8366
qualifier inference programmer annotates expressions introduce values particular qualified type 
inference algorithm determines values flow program ensure correctly 
existing qualifier inference systems sufficient model wrapper proxies futures treat qualifiers having runtime effect 
creating requires spawning thread creating placeholder result 
wrapper proxy context expecting nonproxy signal error induce runtime claim acquire underlying result 
analysis augments qualifier inference support coercions 
particular formal target language section includes expression form coerce type qualifier nonproxy 
qualifier inference expression forms user pspec drive coercions inserted 
runtime coercions implemented user 
example possible wrapper proxy dynamic coercion inserted convert coerce 
runtime coercion implemented checking proxy extracting underlying object call method optimization local variable treated flow sensitively analysis type coercion qualifier nonproxy 
justify flow sensitivity code coercion logically assigns coerced value back source variable easily generalize support flow sensitive coercions apply traditional qualifier systems 
leads new improved applications described section 
formal development section describes analysis formally proves sound 
model analysis extension featherweight java fj purely functional object calculus :10.1.1.109.1141
define implicitly typed calculus call fji explicitly typed calculus called 
source programs written fji translated programs making manifest operations manipulating proxies 
translation occurs stages inference transformation formalized follows judgment defines proxy inference expression language fji derivation induces sets subtyping constraints constraints capture proxies flow program constraints indicate coercions inserted 
judgment states assuming generated constraints solution expression type context 
modeled output context domain variables may nonproxy qualifiers proxy qualifiers result evaluating expression constraints solved standard techniques 
judgment defines transformation original implicitly typed fji program explicitly typed program language 
function uses solutions constraints add coercions needed fill needed qualifier type annotations 
resulting expression typechecked explicitly typed system described judgment show system sound fji programs inference successful type check turn implies go wrong execution 
establish result defining operational semantics proving standard type soundness inference soundness theorems 
syntax implicitly typed language fji define process inference transformation described conclude relevant soundness theorems 
additional details proofs appendix 
syntax syntax implicitly typed calculus fji shown 
expressions consist raw expression unique label designate coercions inserted inference 
explicit coercion expression target language 
terms cl class extends super 
return new makeproxy types class names proxy nonproxy cn syntax fj fj programs consist class table ct maps class names class definitions cl class definition defines list fields constructor list methods constructors merely assign arguments fields directly invoking superclass constructor 
method bodies consist single expression write shorthand xn similarly write mn commas 
abbreviate operations pairs sequences similarly writing tn fn length sequences field declarations parameter names method declarations assumed contain duplicate names 
note syntactically different variable typeset bold emphasis similarly object 
expressions fj including field access method invocation object creation new cast support local variables lets expressions illustrate effects flow sensitivity described 
programmers expression makeproxy designate create proxy 
treats proxies generically ignoring particular proxies implemented 
particular operational semantics merely tags result evaluating possible proxy 
types consist qualifier set type set types set class names cn coupled upper bound supertype ci 
set types technical device allow inference precise expect programmers directly 
essence set type upper bound write normal java program set provides precise refinement determined inference 
example say defined classes subclasses variable assigned objects class normal java program give type fji give type indicating assigned objects classes objects type note checked casts refer class names types qualifier necessary assumed nonproxy set type necessary inference system infer 
proxy inference takes normal java program infers necessary qualifiers coercions 
model fji extending qualifiers variables sets class names variables 
stand unknown qualifiers sets class names solved inference 
simplest case automatically decorate normal java program fresh variables performing inference 
example java variable declaration rewritten fresh 
fact inference rules require explicit types form 
implementation allow users decorate java types qualifiers manually implement coercion policies 
example user wished ensure proxies stored set class decorate relevant set methods require input arguments qualifier nonproxy 
fj fji support mutation flow sensitivity coercions updates local variables types implicitly objects purely functional 
avoids unnecessary complication formalism implementation handles full java language 
discussion section 
subtyping rules subtyping shown 
fj subtyping rules extended consider set types qualified types rule indicates set type subtype bound subtype set subset include formedness condition convenience stating types set subtypes bound 
subtyping qualified types rule natural 
example subclasses nonproxy proxy nonproxy proxy object definitely proxy class possible proxy class subtypes expected 
inference ct class extends 
cn dn di ci cn dn nonproxy proxy fji subtyping inference expressed judgment cl class definitions method definitions expressions 
rules figures 
judgment indicates context expression type output context rules specify nonproxy required appealing coercion judgment notice subscript 
example field rule checks expression fi indicates receiver nonproxy including requirement nonproxy premise 
implementation expressions require nonproxy determined user pspec 
simplicity rules specialized case wrapper proxies 
case nonproxy type implies operations occur underlying object wrapper proxy 
coercion judgment note labels expressions may need inserted coercion 
forms 
rule creates implication constraint qualifier expression nonproxy fresh label included set 
fact label fresh simplifies proof important 
set transformation determine coercions inserted 
output type judgment nonproxy qualifier justified inserting coercions transformation 
rule similar variable input context re bound output context coerced type 
flow sensitive treatment allows continuation avoid coercing fields mtype mtype mtype mbody mbody override call fields object fields object ct class extends fields fields fields fields fields ct class extends return mtype ct class extends defined mtype mtype mtype ci ti ui mtype cn 
tn un ct class extends return mbody ct class extends defined mbody mbody mtype dn cn override ci mtype ci ti qi di ci ti qi di fresh call fji auxiliary definitions variable coerced 
inference rules thread output context subexpression input con var nonproxy nonproxy lub merge field nonproxy fields fi ti invoke nonproxy call new fields new nonproxy cast makeproxy nonproxy subtypes fresh nonproxy nonproxy makeproxy proxy fresh proxy nonproxy fresh proxy nonproxy nonproxy fji inference expressions method class nonproxy ct class extends 
override cn fresh return super 
fields cn cn fresh class extends fji inference classes methods text 
typing output context typing expression ei input context typing ei 
highlights interesting rules rule output context binding expression extended binding input context body 
typechecking body completed binding removed output context rule output context merging output context branches 
particular function merge context dom dom result type supertype types branches bounded upper bound bounds 
invoke rule creates subtyping constraints arguments methods possible receivers call auxiliary function call auxiliary functions shown 
done implication constraints possible subtypes appear constrained 
allows overriding methods arguments different qualifiers methods overriding improving precision analysis 
example argument class method nonproxy argument subclass overriding method proxy 
sound calling contexts considered 
cast rule requires resulting set type contains names set type limited subtypes bound predicate subtypes set subtypes defined class table ct possible outcomes 
subtype may contain classes pruned solution downcast 
second supertype intersection class names bounded bounded situation holds say unrelated intersection empty signaling type error 
makeproxy rule requires nonproxy makeproxy prevents proxies proxies 
technically necessary simplifies implementation coercions 
example wrapper proxy underlying object extracted directly coercion iterate reached non wrapper 
standard parlance inference system monomorphic field insensitive context insensitive 
context field sensitivity supported adding class method parameterization generic java gj :10.1.1.21.2609
constraint solving subtypes subtypes ti qi ti qi subtypes subtypes subtypes subtypes subtype constraint reduction proxy inference generates constraints flow proxies forms listed rules generate new subtypes cast ci ti qi invoke note represent equality constraint cast subset constraints 
constraints coercions introduced form proxy call set flow constraints set coercion constraints solve constraints follows 
reduce continuously applying rewriting rules shown 
reduce compound constraints simpler ones subtyping rules iteratively discharge implication constraints left hand side implication solved 
finished constraints forms form subtyping requirements determined program hold program type correct fj 
remaining forms solved standard techniques 
particular qualifier constraints form atomic subtyping constraint system 
constraints fact proxy nonproxy form finite lattice allows solve time 
set type constraints subset constraints occur andersen style points analysis 
constraints solved worst time practice faster :10.1.1.109.6502
class extends class extends super 
super 
return return fi 
fi new new makeproxy makeproxy coerce transforming fj expression expression inference solution constraints mapping qualifier variables constants proxy nonproxy set type variables sets class names cn 
solution ensures constraint similarly set type constraints 
write solution interested solution set types reduce spurious constraints qualifiers favor proxy nonproxy unconstrained qualifier variables delay inserting coercion absolutely necessary 
solution constraints solve coercion constraints particular apply left hand side implication solve 
result set program labels require runtime coercion properly typecheck 
write set substitution satisfies constraints transformation transform fji program program resulting inference 
differs fji addition expressions form coerce absence qualifier set type variables substituted solutions 
expression coerce takes possible proxy coerces nonproxy runtime 
makeproxy semantics treats coercions generically merely changing tag nonproxy 
transformation shown function global avoid clutter 
function simply inserts coercions directed rewrites types method declaration parameters field declarations directed 
avoid clutter strips labels case doing completely static analysis look transparency violations fact non empty denote possible violation transformation stage signal error directed user 
properties wish prove sound respect operational semantics transformed fj program sound respect semantics 
proof follows standard syntactic approach progress preservation lemmas 
second done proving typedness transformed program source fj program 
typedness programs expressed judgment cl class definitions method definitions expressions 
typing rules appendix 
typechecking straightforward similar inference fj operational semantics set machine 
programs consist store expression evaluate transition relation maps programs programs 
store maps variables source program variables fresh addresses allocated evaluation values 
complete transition rules appendix 
extend typing programs support proof preservation 
progress preservation lemmas follows lemma progress variable stuck due failed dynamic downcast 
lemma preservation note type program takes step may subtype original type due coercions downcast proxy qualifier dynamic downcasts 
lemmas theorem follows 
theorem type soundness stuck due failed dynamic downcast 
executes forever 
define mean reflexive transitive closure transition relation 
implicit statements presence formed class table ct standard proofs progress preservation induction typing evaluation derivations respectively type soundness follows 
show proxy transformation fj sound 
theorem inference soundness substitution label set inference derivation ct generates constraints ct 
subderivation ct contains subderivations form 
cl 

corresponding subderivation ct having form 
cl 

proof induction inference derivation 
proofs appendix 
discussion compared past flow sensitive type qualifiers flow sensitivity system significantly simpler 
approach foster allows arbitrary memory locations treated flow sensitively complicated combination aliasing mutation :10.1.1.24.8366
particular allowing qualifier value change flow sensitively requires proving value aliased linear 
contrast approach treats local variables flow sensitively java address operator contents local variable accessed variable 
get linearity free trading expressive power simplicity 
caveat implementation coerce provided user operate variable object refers 
wrapper proxies happens overwritten point underlying object wrapper 
coercions meet criteria treated flow sensitively 
flow sensitive local variables opted model field variable updates 
adding updates straightforward modeled mj existing qualifier systems example change character approach adding unnecessary complication :10.1.1.24.8366
order able support full java language address jni reflection mechanisms 
assumed conservative approach case demanding proxy object flows jni api reflection invocation 
approach inserts claims places native method called arguments java lang reflect method invoke ensuring proxy object passed reflection jni invocation 
addition proxy object accessed reflection reading fields object 
analysis treats objects obtained way possible proxies 
applications formal presentation analysis specific proxies added support coercions easily folded general qualifier systems admitting new improved applications 
consider possibilities 
security sensitive data shankar describe application type qualifiers untrusted data arriving user login prompt network connection qualifier tainted trusted data qualifier untainted 
qualifier inference ensure tainted data flow functions requiring untainted data 
similar analysis supported perl programs checks tainted data performed dynamically 
drawback potentially significant added runtime overhead dynamic checks benefit precise avoid false alarms generated purely static approach 
framework implement blending approaches 
particular pspec specify routines returned tainted data expected untainted data implement coercions check determine data came untrusted source reading required field object 
approach blends prior approaches static analysis avoid runtime checks 
stack allocation java objects dynamic unrestricted lifetimes implemented heap allocation garbage collection 
stack allocating objects improve performance avoiding dangling pointers entail stack allocated object escape defining scope 
happen object assigned field returned defining function 
solution copy stack allocated object heap point escapes scope 
doing violate transparency object identity revealed stack allocated object argument 
analysis support transparent stack allocation qualifiers heap stack annotates object heap stack allocated indicates object heap allocated heap stack 
operation reveal identity object cause escape assigning field heap object require object qualifier heap 
coercion check object stack bit mask copy heap necessary 
null types application null nonnull qualifiers characterize objects possibly null definitely null respectively 
provide simple way specifying standard null check elimination optimization qualifier system allow users manually annotate fields method arguments nonnull avoid explicit null tests 
implement framework pspec indicate occurrences constant null qualifier null including default initialization fields concrete object usages call method require object qualifier nonnull 
implement coercions null checks throwing exception failure flow sensitivity naturally eliminating redundant checks 
course truly useful require cooperation jvm avoid checks proven redundant framework 
asynchronous method calls having described proxy framework formally describe implementation asynchronous method invocations java 
framework implementation analysis implemented extension soot version framework analyzing transforming java classfiles 
soot provides framework implementing flow insensitive points analyses called spark 
extended spark track proxies generate set types points information 
spark constraint graph representation uses node corresponding variously qualifier variable set type variable local variable method parameter 
extended flow sensitive assigning multiple nodes variable method parameter 
optimization nodes possibly contain proxies determined flow insensitive analysis 
reduces total nodes consider proxies typically sparingly program relative total number objects 
applications section optimization yields improvement cost flow sensitive analysis 
note spark supports context sensitivity taken advantage 
programmers implement pspec providing classes linking analysis 
class pspec defines syntactic patterns indicate proxies introduced 
patterns course legal java syntax compiled bytecode 

policy class pspec defines coercions visitor jimple syntax tree specifies expressions require non proxies 

class implements 
defines call sites create proxies transformed coercions implemented 
may direct supporting classes linked transformed application 
jimple represents typed bytecode coercions assign back original variable typed 
give type object jimple variable type contain proxy 
coerced assign result variable type replace subsequent occurrences continuation 
transformation sound proxies treated transparently way alias mutate storage original variable asynchronous invocations programmers invoke methods asynchronously syntax async invoke pspec syntax indicates method invoked asynchronously result returned caller 
method arguments en evaluated current thread 
defines steps needed implement asynchronous call 
program creates anonymous subclass encapsulates invocation method signature public class implements runnable wrapper public void run executes invocation public object get acquires result wrapper interface simply defines single get method extracts underlying object wrapper proxy 
public interface wrapper object get object passed thread manager 
thread managers implement java executor interface public interface executor void execute runnable command thread manager call run method separate thread achieve asynchrony 
run method execute method invocation 
store result private field extracted call get 
returned caller original method place result analysis determines program variable type contain coercion required concretely 
implements coercions code fragment instanceof wrapper 
wrapper get wrapper call get extract result 
get method turn wait result available 
implementation executor thread manager 
java provides extensible thread pool implementation emulates active objects mapping object receiving asynchronous method call executor 
note programmers influence claims occur performing null casts 
expression requires qualifier nonproxy casting known type effect forcing claim 
design lightweight flexible 
programmers easily experiment method asynchrony rewriting substantial amounts code 
addition programmers experiment variety threading policies choosing different thread managers 
simple extension supports lazy evaluation 
invoke method object lazily programmer uses syntax lazy invoke subclass generated run method called get called wrapper claimed final result exists 
exceptions asynchronous method call throws exception exception cached inside returned claimed exception re thrown 
presents challenges analysis 
fact claims throw exceptions modeled simple extension 
extend language model exceptions 
extend expressions include form try catch name exception handled 
method declarations extended include throws clauses 
add form throw throwing exception type throw take arbitrary expressions exception type simplifies presentation 
extend typing judgment include throw set exceptions thrown evaluating expression 
typing rule try blocks merge handles try catch function handles prunes exceptions subtypes resulting throw set pruned set set handler 
rule conservatively assumes flow sensitive effects reflected seen 
checking method consisting expression sure resulting throws set covered throws clauses method declares 
reflect proxy type exceptions throw 
expand proxy qualifier family qualifiers mentions exception thrown qualified value coerced 
form lattice subtyping relationship exceptions example 
proxy 
rule makeproxy nonproxy lub makeproxy exceptions throw reflected qualifier 
rule sound modify operational semantics capture exception thrown evaluating proxy re throw exception doing coercion 
typing rule coerce reflects exception thrown coerce nonproxy differs util concurrent get method declares throw encapsulating exception thrown computation 
programmer required handle time claimed 
implementation claim essentially catches exception re throws exception encapsulates 
implementation extend definition wrapper interface define get methods throw various expressions determined analysis adjust claim code accordingly easy automatically 
formulation ensure proxy inference deals exceptions properly couple ways 
simplest case ensure expression makeproxy throws exception 
done allowing programmer provide handler possible exceptions creating proxy 
particular users executor handles exceptions user specified way inside spawned threads 
approach requires user specify default value object returned claim exception prevented method returning value 
experience simple approach works fairly practice 
second case inference determine proxies flow signaling error inserted coercion throw exception covered throws clause method occurs 
applications considered unclaimed proxies flow outside scope reasonable exception handler 
frequently true event style server applications outermost exception handling block coupled event loop catch exceptions raised event handlers 
case proxy flow unexpected location user learns exactly offending claim inserted manually alter code insert handler 
alternatively user specifies method call asynchronous provide handler object handle method called argument claim cause thrown 
exceptions thrown handler delegate outer scope handler reflected type proxy 
surrounding context handle exception thrown due claim incorrect 
exceptions ioexception thrown methods exception generated claim may violate invariant expected programmer 
done able ensure proxy throw handlers original context 
track exceptions possibly thrown expression track handlers catch exceptions thrown create similar partial order folded proxy qualifier 
time typing judgment keep track handler context set handlers exception possibly throw including method callers 
typechecking coercion require handler context subset handlers mentioned proxy 
note discussion need apply checked exceptions 
unchecked exceptions typically signal disastrous unrecoverable situations choose ignore analysis 
synchronization concurrent programs balance safety liveness guarding invariant violations preventing deadlock 
approach worse better standard java thread programming 
asynchronous method calls programmers ordering synchronization immutability techniques ensure safety liveness automatic support provided 
ideally ensuring program safe live lightweight introducing asynchronous invocation 
lisp trivial programs written purely functional style means added concurrency affect program safety 
contemplated approaches inserting synchronization automatically rejected idea lack generality potentially negative impact performance 
discuss issue section 
feel promising approach programmers specify synchronization requirements declaratively 
declarative specifications change infrequently programmer changes various method invocations asynchronous 
proper synchronization code generated specification changes 
aspect oriented programming language level transactions aim realize goal :10.1.1.5.9270:10.1.1.21.5662
making assumptions synchronization readily incorporate results projects 
evaluation evaluate framework terms programming benefit framework simplify programming task analysis effectiveness impact run time instrumented program analysis performance fast analysis 
number applications wrapper proxies transparency checking give sense costs benefits approach 
java concurrency libraries widespread hope adapt larger examples framework 
ran experiments ghz amd athlon gb ram running mandrake linux kernel version 
claim overhead wrapper proxies flow potentially parts program static analysis conservative classes may instrumented redundant claims 
measure performance overhead necessary redundant claims constructed simple microbenchmark object int test tot check ns claim redundant claim necessary claim table overhead inserted claims method simply increments volatile counter 
varied normal object claimed wrapper proxy unclaimed wrapper proxy case copy ensures claimed time gets claimed rewritten wrapped object 
results shown table values showed similar relationship 
redundant claims consist essentially instructions runtime instanceof check cast assignment 
measurements show adds loop running time 
necessary claims require additional synchronized method call assignment cost 
appear frequently overwritten underlying object acquired inducing redundant claims 
actual applications expect overhead claims small method calls require claims method calls perform real cost claims relative program running time 
programming futures central benefit approach manual coding proxies simplifies programming process 
illustrate take example util concurrent api documentation describes convert blocking service nonblocking service futures 
blocking service implements interface interface public response serve request req throws convert objects non blocking approach manual approach proposed documentation util concurrent 
approach object bs calls serve method asynchronous simply changing existing method calls bs serve request async invoke executor bs serve request analysis infer claims required insert directly bytecode applications library classes user input 
assuming claims occur caught finished 
modify invocations include wrapping exception handler add handlers claim locations described section 
wish insert null casts force claims early performance reasons 
manual approach java futures take steps 
define nonblocking variant interface serve method returns build adapter class wrap object shown 
serve method creates task invoke underlying object serve method handling exception locally 
task executed adapter executor object turning implements 
returned caller 
original bs object non blocking creating nbs new bs 
existing calls bs serve request changed nbs serve request point adjust old client code handle fact nbs serve returns response response 
futures claimed late possible follow response objects flowed calls serve claims just response object 
tricky response objects stored containers accessed methods threads program 
response object flow library routines third party components programmer may forced claim early hurt performance 
compared line invocation change imposed framework fair amount programming overhead 
similar overhead required undo change 
asynchronous rmi asynchronous method call worthwhile added parallelism overcome added overheads thread creation time synchronization realize performance gain 
remote method calls natural candidate pay cost network round trip time invocation 
asynchronous rpc initial motivation liskov shrira promises considered idea java 
interface public response serve request req class implements public svc svc executor executor public response serve final request req callable response task new callable response public response call try return serve req catch exception handling response new response task executor execute return private final private final executor executor adapter class illustrate benefit applied framework rmi peer topeer service sharing application developed class university maryland peer perform text processing number composable services simply objects implementing service interface 
application services wants ask network receive remote messages peers 
stored local services table 
code find potentially remote service roughly follows www cs umd edu class fall cmsc htm analysis time classes analyzed fut 
transformed claims fi fs spark table analysis performance async rmi version services requested orig 
async orig 
delay async delay table elapsed time peer peer rmi application varying workload service self string sname service self sname null return self forward new sname return self sname service local table method immediately returns 
forward method rmi send messages node peers asking service 
thing method call asynchronous returned call block wait observes desired service installed table 
problematic client application wishes invoke times create composed service call wait prior service network search services parallel 
address issue call lazy changing lazy invoke self sname 
syntax introduces wrapper proxy framework rewrites caller class delay invocation method proxy unwrapped 
calls proceed parallel block service concretely 
analysis performance analysis times benchmark shown table 
show results flow sensitive analysis fs flow insensitive variant fi 
times seconds show total number classes analyzed largely library classes futures flow transformed 
classes transformed indicate coercions claims inserted 
results show benefit flow sensitivity fewer classes polluted futures fewer claims required 
flow sensitive analysis takes time run flow insensitive version 
process number classes flow sensitive version generates constraints 
flow insensitive analysis virtually identical cost just running spark modification 
flow sensitive analysis uses result flow insensitive analysis limit number variables analyzed 
particular variables qualifier proxy re analyzed flow sensitively 
time saved compared running flow sensitive analysis program significant running analysis twice 
runtime performance assess runtime benefit asynchronous remote invocations ran simple experiments node network connected mbps ethernet 
application attempts acquire services non local 
compare original application orig changed version async 
addition normal rmi messaging ran version inserts ms delay message send simulate wide area message 
results shown table represent median runs times milliseconds mean median values similar 
local area traffic added parallelism asynchronous rmi nets performance gains 
delayed case running time original application tracks number services times round trip delay async version significantly amortizes cost 
course results achieved rewriting application hand capture invocation acquire applying result 
framework significantly easier annotate method calls framework rest automatically 
transparency checking framework search possible transparency violations interface proxies 
consider programmer specialize object implementing interface count particular method called 
proxy design pattern programmer dynamic proxy class create method counting object implements forwards calls original object 
framework ensure program distinguish proxy underlying object identity related operation instanceof done policy implementation specification version time classes errors analyzed proxies fi fs spark table analysis performance soap rmi policy calls proxy 
introduce proxies 
expressions identity revealing operate non proxies including synchronized instanceof 
note futures wrapper proxies method calls require object non proxy 
implementation code needed generate proxies done program coerce 
requirement coercion implies possible transparency violation signaled analysis 
ran checker examples xml implementation soap rmi uses dynamic proxy classes soot bytecode analysis framework version 
case analysis tracks proxies created proxy 
selected different methods return interfaces told checker calling methods return proxies 
simulates user wishing proxy object returned methods perform profiling ensuring transparency violated 
ran flow sensitive flow insensitive analysis detect possible errors 
soap rmi example ran checker code transparency violations 
table summarizes results 
flow insensitive analysis essentially running time spark points analysis shown flow sensitive version added overhead 
interestingly flow sensitive analysis adds value case 
potentially reduce false positives due spurious flows 
soot examples different methods shown table 
spark number average time examples similar running times 
looked reported violations verified genuine transparency violations lead bugs 
interesting see flow sensitivity added precision overhead original spark analysis times relatively close flow insensitive analysis times 
analyze soot analyzing causes benchmark machine swap 
related example time classes errors fi fs analyzed proxies spark table analysis performance soot examples proxies gamma uses proxy design pattern including remote lazy evaluation access control 
uses include memoization delegation synchronization addition generic event listeners views data types 
java dynamic proxy classes permit simple construction interface proxies variety applications 
static analysis analysis variant qualifier inference draws techniques developed static analyses including constraint analysis points analysis 
approach extends foster qualifier inference support coercions implement checks runtime claim :10.1.1.24.8366
coercions treated flow sensitively 
foster define flow sensitive variant analysis approach allows heap locations just variables treated flow sensitively :10.1.1.24.8366
adds expressive power significant complication 
asynchronous method calls futures notion popularized halstead multilisp 
dynamically typed language lisp scheme potentially value necessitating runtime check 
flanagan felleisen define program static analysis reducing eliminating unnecessary checks analysis conversely adds needed checks possible flow futures 
liskov shrira proposed promises futures statically typed languages 
promise type parameterized type object ultimately compute java 
number applications futures statically typed object oriented languages :10.1.1.58.8141
framework provides asynchronous method invocation futures java 
asynchronous calls implemented reflection dynamic proxy classes modular approach 
efficient transparent 
identity revealing operations distinguish see example blog com archives html 
object 
dynamic proxies reflection method call notoriously slow order magnitude slower normal method call benchmark machine 
overhead programmer treat returned value asynchronous call explicit object java manually claimed sacrificing programming benefit transparency 
number languages support active objects extension eiffel io return futures method calls handled object thread automatically synchronized programmer supplied method preconditions 
simple programmers forced concurrency basis opposed activity severely limit performance potentially unnatural program approach concurrency handled method arbitrary executor objects synchronization handled programmer 
polyphonic adds concurrency abstractions join calculus 
method declarations annotated async invoked asynchronously 
methods return results need futures 
asynchronous remote method invocation batch remote calls amortize delay round trip times 
promises developed context 
propose approach returned manifest programmer adding programming burden 
require remote calls provided callback invoked result available 
simplifies exception handling obscures control flow program making debugging difficult 
forces programmers distinguish remote local eliminating transparency afforded rmi 
simple flexible framework transparent programming proxies java 
framework uses sound static analysis track flow proxies program 
analysis qualifier inference extensions permit dynamic coercions allow proxies runtime effect flow sensitivity avoid redundant coercions :10.1.1.24.8366
framework implement natural form asynchronous lazy method invocation java check possible transparency violations proxy design pattern 
framework general apply interesting applications including tracking security sensitive data supporting null types stack allocated objects 
currently avenues 
generalizing framework support arbitrary qualifiers support applications mentioned 
doing plan support sophisticated context sensitive analysis 
second exploring analysis incremental avoid program time source file changed 
developing dependency tracking system allow selective reanalysis unchanged classes possibly background better performance 
hope generalize approach static analyses 
acknowledgments jeff foster nikhil james rose anonymous referees helpful comments drafts 
alexander aiken 
set constraint program analysis 
science computer programming scp 
lars ole andersen :10.1.1.109.6502
program analysis specialization programming language 
phd thesis diku university copenhagen may 
diku report 
nick benton luca cardelli dric fournet 
modern concurrency abstractions 
acm transactions programming languages systems toplas 
special issue papers fool 
gregory cahill mads 
dynamic proxy architecture support distributed java objects mobile environment 
proceedings coopis doa odbase pages 
gavin bierman matthew parkinson andrew pitts 
imperative core calculus java java effects 
technical report university cambridge computer laboratory april 
gilad bracha martin odersky david stoutamire philip wadler :10.1.1.21.2609
making safe past adding genericity java programming language 
proceedings acm conference object oriented programming systems languages applications oopsla pages vancouver british columbia canada 
michael james compton 
investigation concurrency eiffel 
master thesis department computer science australian national university december 
deng matthew dwyer john hatcliff mizuno 
invariant specification synthesis verification synchronization concurrent programs 
proceedings ieee international conference software engineering icse pages orlando florida usa 
dynamic proxy classes 
java sun com se docs guide reflection proxy html 
jdk documentation 
emami rakesh ghiya laurie hendren 
context sensitive interprocedural points analysis presence function pointers 
proceedings acm conference programming language design implementation pldi pages orlando florida usa 
ric jacques noy denis pierre cointe 
partial behavioral reflection spatial temporal selection reification 
proceedings acm conference object oriented programming systems languages applications oopsla pages anaheim california usa 
executor examples 
gee cs edu cgi bin cgi jsr notes tim execu tor examples html rev 
manuel hndrich rustan leino 
declaring checking non null types object oriented language 
proceedings acm conference object oriented programming systems languages applications oopsla pages anaheim california usa 
cormac flanagan matthias felleisen 
semantics program optimizations 
proceedings acm symposium principles programming languages popl pages san francisco ca january 
jeffrey foster manuel hndrich alexander aiken :10.1.1.24.8366
theory type qualifiers 
proceedings acm conference programming language design implementation pldi pages may 
jeffrey foster alex aiken :10.1.1.24.8366
flow sensitive type qualifiers 
proceedings acm conference programming language design implementation pldi pages berlin germany june 
charles leiserson keith randall 
implementation cilk multithreaded language 
proceedings acm conference programming language design implementation pldi pages montreal canada 
erich gamma richard helm ralph johnson john vlissides 
design patterns elements reusable object oriented software 
addison wesley 
tim harris fraser 
language support lightweight transactions 
proceedings acm conference object oriented programming systems languages applications oopsla pages anaheim california usa 
claude 
personal communication 
describes jsr futures enterprise application 
atsushi igarashi benjamin pierce philip wadler :10.1.1.109.1141
featherweight java minimal core calculus java gj 
acm transactions programming languages systems toplas 
io small programming language 
www com 
robert halstead jr multilisp language concurrent symbolic computation 
acm transactions programming languages systems toplas 
jsr concurrency utilities 
www jcp org en jsr detail id 
gregor kiczales erik hilsdale jim hugunin mik jeffrey palm william griswold 
overview aspectj 
proceedings european conference object oriented programming ecoop volume lecture notes computer science pages budapest hungary 
springer verlag 
greg douglas schmidt 
active object object behavioral pattern concurrent programming 
proceedings pattern languages programs september 
laurie hendren 
scaling java points analysis spark 
proceedings international conference compiler construction cc volume lecture notes computer science pages warsaw poland 
barbara liskov shrira 
promises linguistic support efficient asynchronous procedure calls distributed systems 
proceedings acm conference programming language design implementation pldi pages atlanta georgia usa july 
cristina lopes karl lieberherr 
abstracting process function relations concurrency object oriented applications 
proceedings european conference object oriented programming ecoop volume lecture notes computer science pages bologna italy july 
springer 

sourceforge net projects 
manolescu 
workflow enactment continuation objects 
proceedings acm conference object oriented programming systems languages applications oopsla pages seattle washington usa 
greg morrisett matthias felleisen robert harper 
models memory management 
proceedings international conference functional programming languages computer architecture fpca pages la jolla california usa 
rajeev joseph william michael 
asynchronous remote method invocation mechanism java 
proceedings acm workshop java science engineering computation las vegas nevada 
jakob rehof torben mogensen 
tractable constraints finite semilattices 
science computer programming 
umesh shankar talwar jeffrey foster david wagner 
detecting format string vulnerabilities type qualifiers 
proceedings th usenix security symposium washington august 
aleksander govindaraju dennis gannon randall 
design xml interoperable rmi system java 
proceedings international conference parallel distributed processing techniques applications pages las vegas nevada june 
tom jan 
optimizing remote method invocation java 
proceedings international workshop database expert systems applications dexa pages aix en provence france september 
raja vall rai laurie hendren vijay sundaresan patrick lam etienne gagnon phong soot java optimization framework 
proceedings ibm centers advanced studies conference cascon pages 
adam suresh jagannathan antony hosking 
transactional monitors concurrent objects 
proceedings european conference object oriented programming ecoop oslo norway 
proxy calculus include details explicitly typed calculus introduced section including typing rules operational semantics 
typing syntax fji minus qualifier set type variables plus expressions coerce typing rules shown 
stripped labels expressions clarity 
subtyping rules auxiliary definitions figures 
rules basically straightforward analogues inference rules 
note rules typing casts 
cast rule types downcast rule types stupid cast 
technical device borrowed fj allow possible casts considered typed necessary prove type soundness property type preservation theorems stated section 
java compiler reject programs containing stupid casts 
operational semantics operational semantics set machine 
programs consist store expression evaluate transition relation maps programs programs 
call value allocation style semantics objects allocated looked store substituted term 
allows model flow sensitivity coercions variables 
store essentially represents hybrid stack heap 
complete transition rules 
qualified system store maps variables qualified store values store values paired qualifier store value simply object form new variables index qualified store values qualified store values allocated rule replaces store value fresh variable maps variable store new nonproxy new computation rules operate variables indexing store look corresponding value evaluation 
example rule variables looks store discover function continues evaluating function body having updated store map function parameter actual argument pointed nonproxy new mbody note encode freshness adding variables domain store illustrated 
enforce condition alpha conversion 
qualified store values concretely qualifier nonproxy indicating actual value available 
conditions match type rules 
relaxing requirement type rules happen interface proxies require relaxing 
rule handles flow sensitive coercions coerce nonproxy variable coerced remap output store qualifier nonproxy 
subsequent uses require coercions 
little effect variable original program 
constant expression reused 
note rule welldefined qualified store values just qualifier proxy critical subtyping rule nonproxy proxy employed type system allows proxies expected 
extend typing judgment programs shown 
rule requires store characterized sufficient typecheck notice rule checks values mapped variables domain domain allows refer variables transitive closure variables appearing indexes store essentially garbage removed 
note returns exact dynamic type objects finds 
objects higher type program allow rule 
var nonproxy nonproxy merge field nonproxy fields fi ti cast makeproxy nonproxy subtypes nonproxy nonproxy makeproxy proxy invoke nonproxy mtype 
tn un ti ui new fields new nonproxy nonproxy subtypes stupid warning nonproxy coerce nonproxy nonproxy cl method nonproxy ct class extends 
override return class fields new typing coerce nonproxy super 
fields class extends dom transitions new nonproxy new nonproxy new mbody nonproxy new fields fi xi congruence rules nonproxy new nonproxy makeproxy proxy coerce nonproxy fi fi makeproxy makeproxy coerce coerce new new operational semantics proofs progress prove lemma progress states variable stuck due failed dynamic downcast 
proof proof induction get case case lemma true definition expression value 
case field get nonproxy fields case nonproxy deduce nonproxy new reduces 
case nonproxy induction hypothesis reduces 
case invoke get nonproxy case nonproxy nonproxy new definition mtype get mbody em 
reduce 
case nonproxy induction hypothesis expression reduces 
case invoke get induction hypothesis expression reduces 
case new case new reduces 
case new new get induction hypothesis reduce 
case case cast nonproxy nonproxy new subtypes hold apply program take step due bad cast 
case subtypes reduces subtypes applied stuck program due bad cast 
case cast induction hypothesis reduces 
case case term reduces 
case 
induction hypothesis get reduces 
case makeproxy case makeproxy typechecks makeproxy get nonproxy get nonproxy new reduce 
case makeproxy get induction hypothesis reduces 
case coerce case coerce get written 
get written new reduces 
case coerce get induction hypothesis reduces 
case case get nonproxy nonproxy 
get nonproxy new nonproxy new 
reduces 
case get nonproxy induction hypothesis reduces 
case get nonproxy induction hypothesis reduces 
preservation prove lemma preservation states proof proof induction 
case case program take evaluation step definition lemma true 
case field get nonproxy fields case reduces fi xi 
field fields hypothesis gives 
new xi si si ti 
case 
induction hypothesis mean 
fields case invoke get nonproxy case invoke invoke nonproxy ty mtype 
tn un ty ti ui classes ci belong set mbody ci ei 
nonproxy nonproxy new get mbody mbody mbody get ancestor mbody declared return 
method nonproxy te te know reduces 
dom create nonproxy 
nonproxy means 
furthermore new elements xi yi yi yi 
ty ty te te method invoke 
te case reduces induction hypothesis 
case reduces induction hypothesis 
case new case new reduces nonproxy new 
new nonproxy 
nonproxy new 
nonproxy dom dom dom 
nonproxy nonproxy 
case new reduces induction hypothesis 
case case case program takes step stuck program due bad cast 
program takes step reduce 
fact program takes step means nonproxy new 
resulting program type nonproxy case cast reduces 
induction hypothesis typechecks cast 
case case reduces 
know ty ty ty dom 
know case 
hypothesis reduces induction hypothesis 
case makeproxy case makeproxy typechecks makeproxy get proxy nonproxy get nonproxy new reduction gives proxy 
proxy proxy case makeproxy get te 
hypothesis reduces makeproxy te 
makeproxy case coerce case coerce get written 
get written new hypothesis reduces coerce nonproxy 
nonproxy nonproxy nonproxy case coerce hypothesis coerce coerce gives te 
induction hypothesis get te 
coerce case case get nonproxy nonproxy 
get nonproxy new nonproxy new 
reduces 
change case case get nonproxy hypothesis reduces 
induction hypothesis nonproxy 
follows nonproxy 
case get nonproxy hypothesis reduces 
induction hypothesis nonproxy 
follows nonproxy 
inference soundness soundness proof general lemma corollary 
lemma derivation ct subderivation concluding subderivation ct 
proof assume expressions appearing ct uniquely labeled 
proceed case analysis inference rules observing subderivation premise refer label 
interesting cases rules introduce fresh label ensure invariant 
corollary derivation ct generating implication constraints label set substitution expressions appearing subderivations concluding rules exp exp lemma cases involving fields methods proof 
lemma substitution label set inference derivation ct generates constraints ct ct 
ct fields ct fields 
call subderivation ct ci mtype ci ti qi ct mtype ci ti qi ct proof 
fields fields suffices show fields ct fields ct follows straightforward induction derivation fields ct transformation 
key point class case uniformly applies types declared fields remain 

definition call implies ci mtype ci ti qi desired result follows straightforward induction derivation mtype ci ct transformation ct 
key point method case uniformly applies types parameters return types methods remain 
prove theorem inference states substitution label set inference derivation ct generates constraints ct 
subderivation ct contains subderivations form 
cl 

corresponding subderivation ct having form 
cl 

proof proof induction inference derivation ct consider rules derivation ct corollary assume exp rules exp 
case var var 
case 
induction hypothesis 
written 

case nonproxy nonproxy lub merge 
induction hypothesis nonproxy nonproxy 


dom dom definition merge implies merge 
get case field fi nonproxy fields 
fi 
induction hypothesis nonproxy 
lemma fields field 
fi ti case invoke nonproxy call 
induction hypothesis nonproxy lemma ci mtype ci ti qi ct implies mtype tn qn mtype ci ct ci definition call ti qi invoke get case new new fields new 
induction hypothesis lemma fields 
new get new nonproxy case cast nonproxy 
induction hypothesis nonproxy apply cast depending subtypes empty prove nonproxy case makeproxy makeproxy nonproxy makeproxy 
induction hypothesis nonproxy makeproxy makeproxy proxy case induction hypothesis desired result nonproxy nonproxy nonproxy 
cases 
implies proxy implies nonproxy 
show desired result 
implies proxy implies proxy 
coerce desired result 
case induction hypothesis desired result nonproxy nonproxy similarly cases similarly nonproxy yields desired result 
coerce desired result 
case method return nonproxy ct class extends 
override return return induction hypothesis nonproxy definition ct class extends 

override lemma ct mtype 
method return case class class extends super 
fields transformation gives class extends class extends induction hypothesis lemma fields definition super 
class class extends 
