physically modeling rigid body simulation david baraff animation studios please note document david baraff 
chapter may freely duplicated distributed long consideration received return copyright notice remains intact 
rigid body simulation david baraff animation studios portion course notes deals problem rigid body dynamics 
help get started simulating rigid body motion provided code fragments implement concepts discussed notes 
segment course notes divided parts 
part covers motion rigid bodies completely unconstrained allowable motion simulations aren concerned collisions rigid bodies 
external forces acting rigid body ll show simulate motion body response forces 
mathematical derivations notes meant fairly informal intuitive 
second part notes tackles problem constrained motion arises regard bodies solid need disallow inter penetration 
enforce non penetration constraints computing appropriate contact forces contacting bodies 
values contact forces simulation proceeds exactly unconstrained case simply apply forces bodies simulation unfold motions bodies completely unconstrained 
computed contact forces correctly resulting motion bodies free inter penetration 
computation contact forces demanding component entire simulation process 
collision detection determining points contact bodies runs close second 
part unconstrained rigid body dynamics simulation basics portion course notes geared full implementation rigid body motion 
section ll show basic structure simulating motion rigid body 
section ll define terms concepts equations need implement rigid body simulator 
ll give code implement equations need 
derivations concepts equations left appendix thing need familiar point basic concepts numerical details solving ordinary differential equations 
re familiar topic re luck just turn back course notes read section differential equation basics want read section particle dynamics re repeat material anyway 
simulating motion rigid body simulating motion particle start particle simulation 
way simulate particle follows 
function denote particle location world space space particles bodies occupy simulation time function gives velocity particle time state particle time particle position velocity 
generalize concept defining state vector system single particle 
re talking actual implementation flatten array 
single particle described array numbers typically elements array represent elements represent 
talk state vectors contain matrices vectors sort operation done flatten array 
course ll reverse process turn array numbers back state vector 
comes pretty simple bookkeeping henceforth ll assume know convert sort state vector array appropriate length vice versa 
simple example involving particles look particle system dynamics section notes 
system particles enlarge xn vn siggraph course notes physically modeling xi vi position velocity ith particle 
working particles harder working particle ll state vector single particle get single rigid body 
simulate motion particle need know thing force acting particle time ll define force acting particle time function sum forces acting particle gravity wind spring forces particle mass change time dt dt 
value equation describes instantaneously changing time simulation starts initial conditions values andthen uses numerical equation solver track change flow time long re interested 
want know particle location second ask solver compute assuming time units seconds 
re going animate motion particle want compute 
numerical method solver relatively unimportant respect actual implementation 
look interact numerical solver language 
assume access numerical solver ll generically write function 
typically ode specification typedef void double double double xdot void ode double double int len double double pass initial state vector 
knows inherent structure ofx 
solvers handle problems arbitrary dimension pass ofx 
system particles obviously 
pass solver starting times simulation andt 
solver goal compute state vector timet return 
pass 
encodes state vector time compute return array xdot 
reason pass may time varying forces acting system 
case know time determine value forces 
tracing flow tot allowed likes 
need code ll give parameter 
simulating rigid bodies follows exactly mold simulating particles 
difference state vector rigid body holds information derivative little complicated 
ll exactly paradigm tracking movement rigid body ll supply 
siggraph course notes physically modeling rigid body concepts goal section develop analogue equation rigid bodies 
final differential equation develop section 
order need define lot concepts relations 
longer derivations appendix section ll show write needed numerical developed section 
compute derivative dt position orientation location particle space time described vector describes translation particle origin 
rigid bodies complicated addition translating rotate 
locate rigid body world space ll vector describes translation body 
describe rotation body ll terms rotation matrix 
call spatial variables rigid body 
rigid body particle occupies volume space particular shape 
rigid body undergo rotation translation define shape rigid body terms fixed unchanging space called body space 
geometric description body body space transform body space description world space 
order simplify equations ll ll require description rigid body body space center mass body lies origin 
ll define center mass precisely center mass thought point rigid body lies geometric center body 
describing body shape require geometric center lie body space 
agree specifies rotation body center mass fixed vector body space rotated vector time likewise arbitrary point rigid body body space world space location result rotating origin translating 
center mass body lies origin world space location center mass directly 
lets attach physical meaning saying location center mass world space time attach physical meaning 
consider axis body space vector 
time vector direction world space 
write components rxx rxy rxz siggraph course notes physically modeling body space world space center mass transformed point world space time axes body body space transform vectors fixed point body space transformed point 
rxx rxy rxz column 
physical meaning column gives direction rigid body axis points transformed world space time similarly second third columns directions axes rigid body world space time 
linear velocity simplicity ll call position orientation body time thing need define position orientation change time 
means need expressions 
position center mass world space velocity center mass world space 
ll define linear velocity velocity 
imagine orientation body fixed movement body undergo pure translation 
quantity gives velocity translation 
siggraph course notes physically modeling world space physical interpretation orientation matrix 
time columns world space directions body space andz axes transform 
angular velocity addition translating rigid body spin 
imagine freeze position center mass space 
movement points body due body spinning axis passes center mass 
center mass moving 
describe spin vector 
gives direction axis body spinning 
magnitude tells fast body spinning 
dimensions revolutions time relates angle body rotate period time angular velocity remains constant 
quantity called angular velocity 
linear velocity related 
related 
clearly matrix vector 
answer question remind physical meaning 
know columns tell directions transformed body axes time means columns describe velocity transformed 
discover relationship examine change arbitrary vector rigid body related angular velocity 
shows rigid body angular velocity 
consider vector time specified world space 
suppose consider vector fixed body moves rigid body world space 
direction independent translational effects particular independent 
study decompose vectors parallel perpendicular 
suppose rigid body maintain constant angular velocity tip traces circle centered axis 
radius circle 
tip vector instantaneously moving circle instantaneous change perpendicular 
tip moving circle radius instantaneous velocity magnitude 
siggraph course notes physically modeling linear velocity angular velocity rigid body 
perpendicular cross product magnitude 
putting write 
parallel wehave 
simply express rate change vector 
put 
time know direction axis rigid body world space column whichis rxx rxy rxz time derivative column just rate change vector cross product rule just discovered change siggraph course notes physically modeling rxx rxy rxz rate change rotating vector 
tip spins axis traces circle diameter 
speed tip 
obviously holds columns 
means write rxx rxy rxz 
cumbersome expression 
simplify things ll trick 
vectors vector vector define matrix az az ay ax ay ax az ay az ax ay ax bx bz 
looks little magical 
discover identity accidentally 
relation just happens 
construct derived considering known infinitesimal rotations 
interested reader wish read chapter goldstein complete derivation matrix 
siggraph course notes physically modeling notation rewrite simply rxx rxy rxz rules matrix multiplication factor rxx rxy rxz 
matrix matrix multiplication 
matrix right get simply 
gives relation wanted 
note correspondence vector rotation matrix 
mass body order derivations ll need conceptually perform integrations volume rigid body 
derivations simpler re going temporarily imagine rigid body large number small particles 
particles indexed ton 
mass ith particle mi particle constant location body space 
location ith particle world space time denoted ri formula total mass body ri 
mi 
henceforth summations assumed summed index variable 
velocity particle velocity ri ith particle obtained differentiating equation relation obtain rewrite ri 
ri ri siggraph course notes physically modeling ri ri ri velocity ith point rigid body world space 
velocity ri decomposed linear term angular term ri 
definition ri equation 
recall definition operator vector simply write ri ri 
note separates velocity point rigid body components linear component angular component ri 
center mass definition center mass going enable likewise separate dynamics bodies linear angular components 
center mass body world space defined mass body sum individual masses mi 
say center mass coordinate system mean body space mir 
note implies mir 
spoken location center mass time true 
ith particle position ri time center mass time mi mir mix mi 
siggraph course notes physically modeling ri ri fi fi torque due force fi acting ri rigid body 
additionally relation mi ri mi mir useful 
force torque imagine force acting rigid body due external influence gravity wind contact forces imagine force acts particular particle body 
remember particle model conceptual 
force act geometrical location inside body imagine happens particle exact location 
location particle force acts defines location force acts 
fi denote total force external forces acting ith particle time define external torque acting ith particle ri fi 
torque differs force torque particle depends location ri particle relative center mass 
intuitively think direction axis body spin due fi center mass held firmly place 
total external force acting body sum fi total external torque defined similarly fi ri fi 
siggraph course notes physically modeling note conveys information various forces acted body tell distribution forces fi body 
linear momentum linear momentum particle mass velocity defined mv 
total linear momentum rigid body sum products mass velocity particle mi ri 
equation velocity ri ith particle ri ri 
total linear momentum body mi ri miv mi ri miv mi ri 
center mass coordinate system apply equation obtain miv mv 
mi gives nice result total linear momentum rigid body body simply particle mass velocity 
simple transformation mv constant 
concept linear momentum lets express effect total force rigid body quite simply 
appendix derives relation says change linear momentum equivalent total force acting body 
note tells rotational velocity body conveys change rotational velocity body 
relationship simple state variable rigid body 
course state variable relation 
state variable consistent way dealing angular velocity acceleration 
siggraph course notes physically modeling angular momentum concept linear momentum pretty intuitive mv concept angular momentum rigid body 
reason angular momentum rigid body lets write simpler equations get stuck angular velocity 
mind probably best worry attaching intuitive physical explanation angular momentum unintuitive concept 
angular momentum ends simplifying equations conserved nature angular velocity body floating space torque acting body angular momentum constant 
true body angular velocity angular momentum body constant body angular velocity may 
consequently body angular velocity vary force acts body 
ends simpler choose angular momentum state variable angular velocity 
linear momentum relation mv 
similarly define total angular momentum rigid body equation matrix technically rank tensor called inertia tensor describe momentarily 
inertia tensor describes mass body distributed relative body center mass tensor depends orientation body depend body translation 
note angular linear case momentum linear function velocity just angular case scaling factor matrix simply scalar linear case 
note independent translational effects independent rotational effects 
relationship total torque simple appendix derives analogous relation 
inertia tensor inertia tensor scaling factor angular momentum angular velocity 
time letr displacement ith particle defining ri 
tensor expressed terms symmetric matrix mi iz mir mir mir iz yr ix mi ix iz mir yr iz mir mir mi actual implementation replace finite sums integrals body volume world space 
mass terms mi replaced density function 
glance need evaluate integrals find orientation changes 
prohibitively expensive simulation body shape simple example sphere cube integrals evaluated symbolically 
fortunately body space coordinates cheaply compute inertia tensor orientation terms precomputed integral body space coordinates 
integral typically computed simulation begins regarded input parameters siggraph course notes physically modeling describing physical property body 
fact difference mir ix iz mir mir ix mir iz mir ix outer product multiplication ir ix iz mir mir iz mir iz ix mir iz mir ix iz ix iz iz ix iz letting denote identity matrix express simply rewrite mi ir help 
ri constant 
mi ir mi mi ir mi ir 
scalar rearrange things writing define matrix previous equation mi ir mi ir mi ir 
mi ir 
specified body space constant simulation 
precomputing body simulation begins easily compute orientation matrix 
section derives body space inertia tensor rectangular object terms integral body volume body space 
siggraph course notes physically modeling inverse formula body rotation matrices 
clearly simulation 
rigid body equations motion body constant covered concepts need define state vector 
rigid body define state rigid body position orientation describing spatial information linear angular momentum describing velocity information 
mass body inertia tensor constants assume know simulation begins 
time auxiliary quantities computed derivative dt dt 

section gives implementation computes dt 
final note represent orientation body matrix itis better quaternions 
section discusses quaternions place rotation matrices 
briefly quaternion type element vector represent rotation 
replace quaternion treat auxiliary variable computed directly computed 
section derives formula analogous expresses terms 
computing dt lets consider implementation function rigid bodies 
code written ll assume datatypes classes called matrix triple implement respectively matrices points space 
datatypes ll represent siggraph course notes physically modeling rigid body structure struct constant quantities double mass mass matrix body inverse state variables triple matrix triple derived quantities auxiliary variables matrix triple omega computed quantities triple force torque assume global array bodies bodies constant assumed calculated member simulation begins 
initial conditions rigid body specified assigning values state variables member bodies 
implementation section represents orientation rotation matrix section describes changes necessary represent orientation quaternion 
communicate differential equation solver ode passing arrays real numbers 
bookkeeping routines required copy state information array void rb double rb component position rb rb int copy rotation matrix int rb siggraph course notes physically modeling rb rb rb rb rb rb copy information array state variables void rb double rb rb rb int int rb rb rb rb rb rb rb compute auxiliary variables :10.1.1.163.5683
rb rb mass body rb transpose rb omega rb rb note responsible computing values auxiliary variables 
ll assume appropriate arithmetic operations defined real numbers triple returns transpose matrix 
siggraph course notes physically modeling examining routines see rigid body state represented numbers 
transfers members size implemented define state size void double int bodies state size void double int bodies state size 
assume routine void double rb computes force torque acting rigid body rb time stores force 
account forces torques gravity wind interaction bodies routine ll void double double double xdot put data bodies int bodies bodies xdot state size numerical calls responsible allocating space state size worth 
function real storing computing dt siggraph course notes physically modeling void rb double xdot copy xdot xdot rb xdot rb xdot rb compute matrix star rb omega rb copy array int int xdot xdot rb force dt xdot rb force xdot rb force xdot rb torque dt xdot rb torque xdot rb torque calculate defined matrix star triple returns matrix performing simulation simple :10.1.1.163.5683
assume state variables rigid bodies initialized 
ll simulation run seconds calling th second display bodies void double state size state size siggraph course notes physically modeling double 
copy back int state size ode state size copy state variables quaternions vs rotation matrices better way represent orientation rigid body rotation matrix 
number reasons unit quaternions type element vector normalized unit length better choice rotation matrices 
rigid body simulation important reason avoid rotation matrices numerical drift 
suppose keep track orientation rigid body formula 
update formula integrate equation inevitably encounter drift 
numerical error build coefficients longer precisely rotation matrix 
graphically effect applying body cause skewing effect 
problem alleviated representing rotations unit quaternions 
quaternions parameters extra variable describe freedoms rotation 
contrast rotation matrix uses parameters describe degrees freedom degree redundancy noticeably lower quaternions rotation matrices 
result quaternions experience far drift rotation matrices 
necessary account drift quaternion quaternion lost unit magnitude 
easily correctable renormalizing quaternion unit length 
properties desirable represent orientation body directly unit quaternion 
express angular velocity vector 
orientation matrix needed compute computed auxiliary variable 
quaternion unit length corresponds rotation quaternions deviate representing rotations lose unit length 
notes deal problem simplistic way 
siggraph course notes physically modeling write quaternion pair notation quaternion multiplication 

rotation radians unit axis represented unit quaternion cos sin 
quaternions represent rotations indicate rotations represents composite rotation followed 
moment ll show change routines section handle quaternion representation orientation 
changes ll need formula 
appendix derives formula 
multiplication shorthand multiplication quaternions 
note similarity equation 
quaternion representation ll need redefine struct constant quantities double mass mass matrix body inverse state variables triple quaternion triple derived quantities auxiliary variables matrix triple omega computed quantities convention rotation point quaternion warned 
opposite convention rotation original shoemake correspondence versions shoemake article 
writing composite rotation parallels matrix notation composition rotations 
siggraph course notes physically modeling triple force torque ll replace double loop int copy rotation matrix int rb assume quaternion represented terms elements real part vector part 
rb rb rb rb similar change 
responsible computing auxiliary variable depends compute auxiliary variable section add line compute auxiliary variables 
rb rb mass body rb transpose rb omega rb rb rb normalize rb prior computing rb 
routine normalize returns divided length unit length quaternion returned passed returns rotation matrix 
quaternion returns siggraph course notes physically modeling matrix case need convert rotation matrix quaternion quaternion const matrix quaternion double tr tr tr sqrt tr inti switch case sqrt break case sqrt siggraph course notes physically modeling break case sqrt return structured andm form row column ofm :10.1.1.163.5683
don need changes note size changes quaternion requires elements rotation matrix 
change need 
ll matrix star rb omega rb copy array int int xdot quaternion rb omega rb xdot xdot xdot xdot re assuming multiplication triple rb omega quaternion rb defined return quaternion product rb omega siggraph course notes physically modeling rectangular block constant unit density center mass 
examples inertia tensor block calculate inertia tensor rectangular block 
block dimensions 
required center mass block origin 
extent block axis similarly axes 
calculate inertia tensor treat sums equation integrals volume block 
assume block constant unit density 
means density function 
block volume block 
siggraph course notes physically modeling body space dxdy dx dxdy dx 
similarly 
diagonal terms xy similarly integrals symmetric 
inertia tensor block 
uniform force field suppose uniform force acts particle body 
example typically describe gravitational field exerting force mig particle rigid body vector pointing downwards 
net force fg acting due gravity body fg mig mg yields acceleration mg center mass expected 
torque due gravitational field 
net torque sum ri mig mi ri equation 
see uniform gravitational field effect angular momentum body 
furthermore gravitational field treated single force mg acting body center mass siggraph course notes physically modeling block acted equal forces different points 
rotation free movement body consider forces acting block 
suppose external force acts body points 
expect cause body accelerate linearly accelerating 
net force acting body acceleration center mass axis 
torque due force acting torque due force acting total torque gives 
siggraph course notes physically modeling block acted opposite forces different points 
expected forces acting block impart angular acceleration block 
translation free movement body suppose external force acts body point external force acts body point 
net force acting block acceleration center mass hand net torque siggraph course notes physically modeling seconds energy energy rectangular block acted force center mass net torque parallel axis 
final result forces acting block cause accelerate axis 
force vs torque puzzle considering effect force acting point body force considered twice 
force acts body point space consider accelerating center mass consider spin body 
gives rise paradox consider long horizontal block initially rest 
suppose force acts block center mass period time say seconds 
force acts center mass torque exerted body 
seconds body acquired linear velocity body acquired angular velocity kinetic energy block suppose force applied center body shown 
force acting body acceleration center mass 
siggraph course notes physically modeling energy seconds energy block acted force center center mass seconds body linear velocity seconds body picked angular velocity force acting center exerts torque body 
kinetic energy see appendix kinetic energy block higher force acted center mass identical forces pushed block cases energy block different 
hint energy integral force distance 
siggraph course notes physically modeling energy seconds energy path force acts longer 
result force larger kinetic energy block 
shows force acting center results higher kinetic energy 
kinetic energy block equivalent done force 
done force integral force path traveled applying force 
force acts center mass consider path traced point force applied 
path clearly longer path taken center mass 
force applied center done point force applied traces longer path force applied center mass siggraph course notes physically modeling part ii 
constraints problems constraints know write implement equations motion rigid body consider problem preventing bodies inter penetrating move environment 
simplicity suppose simulate dropping point mass single particle fixed floor 
issues involved 
dealing rigid bodies totally non flexible don want allow inter penetration particle strikes floor 
considered floor flexible allow particle inter penetrate small distance view floor deforming near particle impacted 
don consider floor flexible don want inter penetration 
means instant particle comes contact floor abruptly change velocity particle 
quite different approach taken flexible bodies 
flexible body say rubber ball consider collision occurring gradually 
fairly small non zero span time force act ball floor change ball velocity 
time span ball deform due force 
rigid ball ball deform faster collision occur 
limiting case ball infinitely rigid deform 
ball downward velocity halted instantaneously ball inter penetrate floor somewhat 
rigid body dynamics consider collisions occurring instantaneously 
means types contact need deal 
bodies contact point velocity particle striking floor call colliding contact 
colliding contact requires instantaneous change velocity 
collision occurs state body describes position velocity undergoes discontinuity velocity 
numerical routines solve ode assumption state varies smoothly 
clearly requiring change discontinuously collision occurs violates assumption 
get problem follows 
collision occurs time tc tell ode solver 
take state time tc compute velocities bodies involved collision change 
ll call state reflecting new velocities tc note tc tc agree spatial variables position orientation different velocity variables bodies involved collision time tc 
restart numerical solver new state tc instruct simulate forward time tc 
bodies resting point imagine particle contact floor zero velocity say bodies resting contact 
case compute force prevents particle accelerating downwards essentially force weight particle due gravity external forces push particle 
call force particle floor contact force 
resting contact clearly doesn require restart ode solve instant ode solver point view contact forces just part force returned 
siggraph course notes physically modeling inter penetration detected time particle lie floor 
actual time collision tc lies time known legal position andt far problems ll need deal computing velocity changes colliding contact computing contact forces prevent inter penetration 
tackle problems deal geometric issue detecting contact bodies 
go back dropping particle floor 
run simulation compute position particle drops floor specific time values 
suppose consider particle times suppose time collision tc particle strikes floor lies time particle lies floor time step find particle beneath floor means inter penetration occurred 
re going restart simulator time tc ll need compute tc 
know far tc lies general solving tc exactly difficult solve tc numerically certain tolerance 
simple way determining tc numerical method called bisection 
time detect inter penetration inform ode solver wish restart back time simulate forward time 
simulator reaches encountering inter penetration know collision time tc lies andt tc try simulate 
eventually time collision tc computed suitable numerical tolerance 
accuracy tc depends collision detection routines 
collision detection routines parameter 
decide computation tc particle inter penetrates floor floor 
point declare particle contact floor 
method bisection little slow easy implement quite robust 
faster method involves predicting time tc collision examining 
baraff describes predictions 
implement ode solver doesn proceed equal size time steps 
siggraph course notes physically modeling tolerance inter penetration detected particle tolerance contacting floor tc considered computed sufficient accuracy 
depends interact ode routines 
exception handling code signal ode various events collisions inter penetration pass sort messages ode solver 
ll just assume way getting ode solver progress just point tc 
reach time collision re state inter penetration occurred geometric determination find points contact 
just may looking time collision bodies doesn mean get neglect resting contact forces bodies re trying move simulation forward ll need compute point contact bodies contact forces points 
vast amount literature dealing collision detection problem 
instance siggraph papers dealing subject von herzen barr moore wilhelms robotics number papers interest canny gilbert hong meyer 
preparata shamos describes approaches computational geometry problem 
section ll briefly describe collision detection philosophy leads efficient algorithms sorts simulation course notes concerned 
actual code algorithms fairly easy write little lengthy fit notes 
ll move consider colliding resting contact 
collision detection collision detection algorithm begins preprocessing step bounding box rigid body computed box sides parallel coordinate axes 
bounding boxes want quickly determine pairs bounding boxes overlap 
pair rigid bodies bounding boxes overlap need considered 
pairs rigid siggraph course notes physically modeling bodies bounding boxes overlap require consideration 
ll describe efficiently check inter penetration contact points rigid bodies defined convex polyhedra 
ll show perform bounding box check efficiently 
described section simulation process consists repeated computation derivative state vector various times numerical ode solver responsible choosing values state derivative computed 
reasonably complicated simulation values chosen state change greatly successive values result great geometric coherence successive time steps 
time step idea take advantage collision detection results computed previous time step 
convex polyhedra primary mechanism exploiting coherence witnesses 
context convex polyhedra witness piece information quickly answer question disjoint 
utilize coherence caching witnesses time step hopefully witness previous time step witness current time step 
considering convex polyhedra polyhedra inter penetrate separating plane exists 
separating plane polyhedra plane polyhedron lies different side plane 
plane verified separating plane testing sure vertices lie opposite sides plane 
separating plane witness fact convex polyhedra inter penetrate 
separating plane exist polyhedra inter penetrating 
cost initially finding witness time step simulation time bodies close require bounding box test unavoidable 
simple way find separating plane initially follows 
pair convex polyhedra disjoint contacting inter penetrating separating plane exists property plane contains face polyhedra plane contains edge polyhedra parallel edge polyhedra 
separating plane normal cross product edge directions plane contains edges 
call face edges question defining face edges 
initially simply check possible combinations faces edges see combination forms separating plane 
inefficient done infrequently inefficiency unimportant 
subsequent time steps need form separating plane defining face edges previous time step verify plane see valid 
rare occasions cached face edges fails form valid separating plane faces edges adjacent previously cached face edges examined see form separating plane happens infrequently may simpler start scratch compute new separating plane prior knowledge 
separating place contact region polyhedra determined assuming polyhedra disjoint 
contact points polyhedra occur separating plane 
separating plane contact points quickly efficiently determined comparing faces edges vertices polyhedra coincident separating plane 
separating plane polyhedra inter penetrating 
polyhedra inter penetrate case vertex poly siggraph course notes physically modeling separating plane exhaustive search separating plane 
face polygons forms separating plane 
defining face time step separating plane defined face polygons 
time step polygons moved face defines separating plane 
siggraph course notes physically modeling face defining separating plane longer new separating plane 
inside edge polyhedron intersected face 
case inter penetrating vertex intersecting edge face cached witness inter penetration 
indicates collision earlier time simulator back attempt compute earlier time 
collision time determined action taken collision contact determination step check cached vertex edge face see indicate inter penetration 
collision time states inter penetration exists identified minimum computational overhead 
bounding boxes reduce number pairwise collision contact determinations necessary bounding box hierarchy imposed bodies simulation environment 
bounding boxes overlap comparisons involving contents boxes needed 
collection rectangular bounding boxes aligned coordinate axes efficiently determine pairs boxes overlap 
naive pairwise comparison pairs requires inefficient number bodies small 
computational geometry algorithms exist solve problem time nlogn number pairwise overlaps general result problem solved time nlog dimensional bounding boxes 
coherence achieve substantially better performance 
exception 
stack cubes equal size atop contacting faces exactly coincide 
lower top 
produces inter penetration vertex inside cube edge penetrates face 
siggraph course notes physically modeling sweep sort algorithm 
encountered active list contains intervals interval reported overlap intervals 
interval added active list algorithm continues 
encountered active list contains intervals 
interval removed active list 
dimensional case consider problem detecting overlap dimensional bounding boxes aligned coordinate system 
bounding box described simply interval real numbers 
consider list intervals ith interval bi ei 
problem defined determination pairs intervals bi ei intersect 
problem solved initially sort sweep algorithm 
sorted list bi ei values created lowest highest 
list swept list active intervals initially empty maintained 
value bi encountered intervals active list output overlapping interval interval added list 
value ei encountered interval removed active list 
cost process log create sorted list sweep list output overlap 
gives total cost log optimal algorithm initially solving problem 
subsequent comparisons improved follows 
need log algorithm form sorted list bi ei values 
considerably efficient start order bi ei values previous time step coherence high ordering nearly correct current time step 
sorting method called insertion sort permute nearly sorted list sorted list 
insertion sort algorithm works moving items list smaller item encountered 
second item interchanged necessary third item moved list proper place movement item indicates change ordering values 
item list processed list order 
siggraph course notes physically modeling coherence method detecting overlaps 
order produced nearly correct arrangement intervals 
need exchanged 
exchange occurs change overlap status interval detected 
sort takes time number exchanges necessary 
example difference figures interval moved right 
starting ordered list bi ei values single exchange necessary sort list 
insertion sort sorting procedure general may require exchanges algorithm sorting nearly sorted list occurs highly coherent environment 
complete algorithm note intervals overlap previous time step current time step exchanges involving bi ei value value occur 
converse true intervals change overlapping previous time step overlapping current time step 
maintain table overlapping intervals time step table updated time step total cost 
assuming coherence number exchanges necessary close actual number changes overlap status extra negligible 
dimensional bounding box problem coherence view yields efficient algorithm extreme maximal simplicity approaches optimality coherence increases 
dimensional case efficient computational geometry algorithms solving bounding box intersection problem ir complicated sort sweep method dimensional case 
algorithms common step essentially sort coordinate axis dimensional case 
bounding box described independent intervals represent intervals spanned coordinate axes ith bounding box 
thought improving efficiency computational geometry algorithm coherent situations sort list containing values similarly axes 
step involve siggraph course notes physically modeling total number exchanges involved sorting lists 
observe checking bounding boxes overlap constant time operation follows simply check bounding boxes overlap exchange values indexed coordinate axis detect changes overlap status time 
maintain table overlapping bounding boxes update time step time 
extra involved 
dimensional case extra occur extents bounding boxes change coordinate axis actual change overlap status 
practice extra done completely negligible algorithm runs essentially time 
colliding contact remainder notes re going concerned examining bodies simulator particular instant time 
time assume bodies simulator determined bodies contact points 
simplify matters ll imagine bodies polyhedra contact point bodies detected 
ll consider contacts polyhedra vertex face contacts edge edge contacts 
vertex face contact occurs vertex polyhedra contact face polyhedra 
edge edge contact occurs pair edges contact assumed case edges collinear 
vertex vertex vertex edge contacts degenerate considered notes 
examples cube resting plane described vertex face contacts contact corner cube 
cube resting table bottom face hanging edge table described contacts vertex face contacts vertices table edge edge contacts edge cube crosses edge table 
contact represented structure struct contact body containing vertex body containing face triple world space vertex location outwards pointing normal face ea edge direction eb edge direction bool vf true vertex face contact int contact contacts contact vertex face contact variable points rigid body contact vertex attached body face attached 
ll call bodies respectively 
vertex face contacts variable set outwards pointing unit normal contact face body unused 
edge edge contacts ea triple unit length points direction contacting edge body pointed bya 
similarly eb unit vector giving direction contact siggraph course notes physically modeling points pa pb vertex face contact 
time bodies come contact pa pb 
edge body points 
edge edge contacts denotes unit vector eb direction 
ll adopt convention contacting bodies labeled normal eb points outwards vertex face contacts 
types contact position contact world space contact vertex point edges intersect collision detection routines responsible discovering contact points number contact points allocating space initializing array structures 
thing ll need examine data structure see colliding contact place 
contact point bodies contact point pa denote particular point body satisfies pa 
vertex face contacts point vertex 
edge edge contacts particular point contact edge 
similarly pb denote particular point body coincides pa time 
pa pb coincident time points time may quite different 
examine velocity see bodies colliding 
section calculate velocity vertex point pa formula pa va pa xa va velocities body similarly velocity contact point face examine quantity pb vb pb xb 
pa pb siggraph course notes physically modeling vector pa pb points direction bodies separating 
scalar 
equation unit surface normal described variablen contact point 
quantity gives component relative velocity pa pb direction 
clearly positive relative velocity pa pb contact point positive direction 
means bodies moving apart contact point disappear immediately time 
don need worry case 
zero bodies approaching receding 
exactly mean resting contact ll deal section 
section re interested possibility 
means relative velocity opposite colliding contact 
velocities bodies don immediately undergo change inter penetration result 
compute change velocity 
force imagine acting matter strong require small amount time completely halt relative motion bodies 
matter strong car brakes need apply hit brick wall 
wait contacted wall late 
want bodies change velocity instantly postulate new quantity called impulse 
impulse vector quantity just force units momentum 
applying impulse produces instantaneous change velocity body 
determine effects impulse imagine large force acts small time interval go infinity derive effect body velocity considering velocity change force act time 
example apply impulse rigid body mass change linear siggraph course notes physically modeling contact force vector pa pb perpendicular bodies resting contact 
contact force may necessary prevent bodies accelerating 
colliding contact 
relative velocity pa pb directed inwards opposite 
relative velocity abruptly changed inter penetration occur immediately time 
siggraph course notes physically modeling velocity simply 
equivalently change linear momentum simply impulse acts point just force produces torque produces impulsive torque impulse 
imagine impulsive torque impulse gives rise change angular momentum impulse 
change angular velocity simply impulse assuming impulse applied time 
bodies collide apply impulse change velocity 
frictionless bodies direction impulse normal direction 
write impulse undetermined scalar gives magnitude impulse 
ll adopt convention impulse acts positively body thatis subject impulse body subject equal opposite impulse 
compute empirical law collisions 
denote velocity contact vertex prior impulse applied denote velocity apply impulse defined similarly 
notation initial relative velocity normal direction application impulse rel rel 
empirical law frictionless collisions says simply rel rel 
quantity called coefficient satisfy 
rel rel collision perfectly particular kinetic energy lost 
spectrum results rel maximum kinetic energy lost 
sort collision bodies resting contact contact point 
calculating magnitude impulse fairly simple equations bit tedious 
define displacements ra rb xa andp xb 
pre impulse velocities body andv post impulse velocities write ra siggraph course notes physically modeling impulse bodies contact point 
impulse acts impulse acts 
relative velocity application impulse 
component relative velocity direction reversed collision 
relative velocity perpendicular remains 
collision 
bodies bounce away direction speed approached 
collision 
bodies bounce away relative velocity perpendicular unaffected collision 
siggraph course notes physically modeling ma ra ma mass body inertia tensor 
combining previous equations yields ma ra ra ra ma ra ra ra ra 
ma important note form simple linear function body opposite impulse acts yielding rb rb 
yields mb ma mb ra ra rb rb 
calculate rel dot expression 
unit length obtain rel ma mb ra ra rb rb rel ma mb ra ra rb rb 
expressing rel terms rel compute equation 
substitute equation equation get rel ma mb ra ra rb rb rel 
siggraph course notes physically modeling solving rel ma mb ra ra rb 
rb consider actual code written clarity speed 
determine bodies colliding contact 
operators triples assume cross product dot product 
return velocity point rigid body triple pt velocity body body triple return body body omega body return true bodies colliding contact 
parameter threshold small numerical tolerance deciding bodies colliding 
bool colliding contact triple pt velocity pt velocity double rel threshold moving away return false threshold resting contact return false threshold return true ll loop contact points collisions resolved compute apply impulse 
void collision contact double epsilon triple pt velocity pt velocity siggraph course notes physically modeling ra ra rb rb double rel numerator epsilon ll calculate denominator parts double term mass term mass term ra ra term rb rb compute impulse magnitude double numerator term term term term triple force apply impulse bodies force force ra force rb force recompute auxiliary variables mass mass omega omega void contact contacts int bool collision double epsilon collision false int colliding contacts collision contacts epsilon collision true tell solver collision ode discontinuous siggraph course notes physically modeling collision true note things 
chosen arbitrarily 
real implementation allow user different values depending bodies colliding 
time find collision list contacts bodies rest may longer new collisions may develop 
initially collisions resolved cube dropped flat plane vertices colliding order contact list may effect simulation 
way compute impulses contact point time complicated concepts resting contact section 
information see baraff :10.1.1.163.5683
incidentally want certain bodies fixed moved floors walls trick bodies mass zero inverse inertia tensor zero matrix 
special case code check body supposed fixed recode definition variable mass ordinary bodies inverse mass fixed bodies zero 
goes inertia tensor 
note dynamics computations including section mass inertia tensor inverses won worry dividing zero 
trick section resting contact simulate bodies support amount weight moving 
resting contact case resting contact bodies colliding separating contact point hardest dynamics problem ll tackle notes 
implement section ll obtain fairly sophisticated piece numerical software ll describe 
point assume configuration contact points 
contact point bodies resting contact relative velocity section zero numerical 
say colliding contact eliminated contact points larger safely ignored bodies separating 
case colliding contact contact point contact force acts normal contact surface 
case colliding contact impulse unknown scalar 
resting contact contact point force fi ni fi unknown scalar ni normal ith contact point 
goal determine fi computing fi determined time force ith contact point may influence bodies contact point 
section wrote velocity contact points pa pb changed respect ll thing ll describe acceleration pa pb depends fi 
colliding contact empirical law related impulse strength relative velocity coefficient 
resting contact compute fi subject conditions 
contact forces prevent inter penetration contact siggraph course notes physically modeling resting contact 
configuration contact points contact force acts pairs bodies contact point 
forces strong prevent bodies contact pushed 
second want contact forces repulsive contact forces push bodies apart act glue hold bodies 
require force contact point zero bodies separate 
example block resting table force may act contact points prevent block accelerating downwards response pull gravity 
strong wind blow brick upwards contact forces brick zero instant wind accelerated brick table 
deal condition preventing inter penetration 
contact point construct expression di describes separation distance bodies near contact point time positive distance indicates bodies broken contact separated ith contact point negative distance indicates inter penetration 
bodies contact time di numerical tolerances contact point 
goal sure contact forces maintain di contact point times 
vertex face contacts immediately construct simple function di 
pb contact points ith contact bodies distance vertex face times di ni pa pb 
time function measures separation near pa 
zero bodies contact ith contact point 
di bodies lost contact ith contact point 
di bodies inter penetrated need avoid 
function edge edge contacts ni siggraph course notes physically modeling pa displacement pa pb indicated arrow points direction 
distance function positive 
distance function zero 
displacement pa pb points opposite direction 
distance function negative indicating inter penetration 
points outwards convention ni pa pb positive contacting edges move separate bodies 
di keep di decreasing time di 
di 
differentiating di ni pa pb ni pa pb 
di describes separation distance di describe separation velocity time time pa pb means di ni pa pb 
look familiar previous section 
function di measure bodies separating resting contact know zero bodies moving away contact point 
point di di 
ll look di 
differentiate equation get di ni pa pb ni pa pb ni pa pb ni pa pb ni pa pb ni pa pb ni pa pb 
pa pb write di ni pa pb ni pa pb 
siggraph course notes physically modeling quantity di measures bodies accelerating contact point bodies acceleration away contact break immediately 
contact remains 
case di avoided indicates bodies accelerating 
note ni constant body fixed ni zero leading simplifications 
satisfy condition contact forces writing constraint di contact point 
acceleration di depends contact forces really constraint contact forces 
turn attention second third constraints 
contact forces repulsive contact force act outward 
means fi positive force fi ni acts body ni outwards pointing normal need fi contact point 
third constraint expressed simply terms fi di 
contact force fi ni zero contact breaking ith contact says fi zero contact breaking 
express constraint writing fi di contact breaking di equation satisfied requiring fi 
contact breaking di equation satisfied regardless fi 
order find fi satisfy equations need express di function unknown fi turn able write di form di ai ai ain fn bi 
matrix parlance means able write dn fn bi bn matrix aij coefficients equation 
code needed calculate aij bi complicated working derivations code somewhat tedious 
derivations worked appendix code compute matrix aij bi appendix gives implementation routines void compute matrix contact contacts int siggraph course notes physically modeling void compute vector contact contacts int vector represent matrices vectors arbitrary size 
routine computes aij second routine computes bi computed think solving equations 
system equations forms called quadratic program qp fi satisfy equations algorithm called quadratic programming 
quadratic programs solved efficiently contact forces normal contact surfaces involve friction turns qp solved efficiently 
interesting thing note qp codes easily handle case di di 
di drop constraint fi wish constrain bodies separate contact point 
enables implement hinges pin joints non penetration constraints simulation 
quadratic programming codes aren terribly common certainly nearly common linear equation codes harder implement 
quadratic programming routines author obtained department operations research stanford university 
see gill details 
code described baraff solve quadratic programs 
determined really implement suggest thorough study excepting section contact friction 
rate assume got working qp solver disposal 
ll assume pass matrix vector bi qp solver get back vector fi pretend interface void qp solve vector vector see compute resting contact forces 
routine presumably called called 
void contact contacts int double assume element contacts represents contact resting contact 
ll assume element bodies force torque fields set net external force torque acting body due gravity wind call allocate matrix vectors 
siggraph course notes physically modeling new vector new vector new vector compute aij bi coefficients compute matrix contacts compute vector contacts solve qp solve bmat add resting contact forces just computed force torque field rigid body 
int double fi triple contacts ni contacts body contacts body apply force positively 
force torque contacts negatively force torque contacts pretty 
resting forces computed combined external forces return control ode solver body goes way physically correct manner inter penetration 
siggraph course notes physically modeling appendix motion equation derivations appendix ll fill missing details section regards equations andl 
derivation method somewhat nonstandard proposed andy witkin 
derivation appendix feel shorter considerably elegant traditional sources goldstein 
described external force acting rigid body terms forces fi external force acting ith particle 
rigid body maintain shape internal constraint forces act particles body 
assumption constraint forces act passively system perform net 
fci denote net internal constraint force acting ith particle 
performed fci ith particle time fci ri dt ri velocity ith particle 
net particles sum fci ri dt fci ri dt zero interval 
means integrand fci ri zero time 
henceforth ll just write expressions fci ri 
fact eliminate mention constraint forces fci derivations 
quick notes operator defined section weget antisymmetric matrix operator linear operator set vectors ai 

dt ai 
siggraph course notes physically modeling recall write velocity ri ri ri ri particle location position center mass linear angular velocity 
letting ri notation ri 
substituting fci ri zero yields fci 
note equation hold arbitrary values 
completely independent choose zero fci choice conclude fact fci true 
means constraint forces produce net force 
similarly choosing zero see fci forany 
rewriting fci fci get fci fci fci tr transposing fci fci fci means internal forces produce net torque 
derive rigid body equations motion 
net force particle sum internal constraint force fci external force fi 
acceleration ri ith particle ri dt ri dt 
individual particle obey newton law ma equivalently ma mi ri fi fci mi fi fci particle 
derive fi sum equation particles 
obtain mi fi fci 
breaking large sum smaller ones mi fi fci mi mi mir fi fci mi mi mir fi fci mi mir dt mir fi fci 
siggraph course notes physically modeling center mass coordinate system equation section tells mir means dt mir 
removing terms mir fci equation yields mi fi simply fi advertised 
obtain fi start equation 
multiplying sides yields mi fi fci 
summing particles obtain mi mi mir fi fci 
fci rearrange obtain mir mir mir fi 
mir left mir mir fi recognizing fi fi mir mir 
re done refer back matrix defined notation easily verify relation matrix equivalent matrix aat identity matrix 
relation equivalent vector rule cat 
mir mi ir 
substituting equation yields mir 
expression acceptable gives expression terms requires evaluate matrix mir expensive computing inertia tensor scratch 
ll trick clean things 
write mi mi mi 
siggraph course notes physically modeling add mi equation obtain mir mi 
mir dt mir mi 
dt leaves final result appendix quaternion derivations 
formula derived follows 
recall angular velocity indicates body instantaneously rotating axis magnitude 
suppose body rotate constant angular velocity 
rotation body period time represented quaternion cos sin 
compute particular instant time 
times small orientation body order result rotating rotating velocity time 
combining rotations get cos sin 
making substitution express cos sin 
differentiate time 
constant differentiate time cos sin 
dt cos sin sin 
siggraph course notes physically modeling similarly dt sin cos cos time cos dt sin cos dt sin 
product abbreviated form general expression appendix miscellaneous formulas kinetic energy kinetic energy rigid body defined letting ri wehave ri 
mi ri mi miv mir vt mi mir wehave 
mi ri 
mi mir mi 
vt mv mir vt mv mir appendix kinetic energy decomposed terms linear term vt mv angular term 
siggraph course notes physically modeling angular acceleration necessary compute 
know 

know consider 
equation body 
antisymmetric 
yields 

body 
term equivalent zero 
leaves final result 
siggraph course notes physically modeling see forces act zero non zero 
fact happen angular momentum angular velocities point different directions turn occurs body rotational velocity axis axis symmetry body 
acceleration point point rigid body world space coordinate necessary compute 
body space coordinate transforms time 

interpret follows 
term tangential acceleration point acceleration perpendicular displacement result body accelerated 
second term acceleration point acceleration arises body rigid points body rotate circular orbit center mass term linear acceleration point due linear acceleration center mass body 
appendix resting contact derivations re determined implement resting contact simulator ll need derivations code appendix 
probably fun appendix wasn fun appendix write 
derivations somewhat terse code appendix hopefully things clearer 
derivations need express di terms unknown fi turn ll able write di form di ai ai ain fn bi 
siggraph course notes physically modeling need know di depends need know aij 
need compute constant term bi 
start determining aij ignoring constant part bi 
ll assume ith contact involves bodies equation write di ni pa pb ni pa pb pa pi pb contact point ith contact time 
right term ni pa pb velocity dependent term immediately calculate knowing forces involved part bi ll ignore 
need know pa pb depend magnitude jth contact force 
consider jth contact 
body bodies involved jth contact pa independent jth contact force act body similarly bodies involved jth contact pb independent 
example acceleration contact points contact completely unaffected contact force acting fifth contact 
completely independent 
conversely completely independent 
suppose jth contact body involved 
definiteness suppose jth contact force acts body opposed 
derive pa affected force acting equation write pa va ra ra ra pa xa va variables associated body know va linear acceleration body equal total force acting divided mass force contributes va pa 
similarly consider equation ma ma la total torque acting body contact occurs point force exerts torque xa 
angular contribution pa ia xa ra 
total dependence pa xa ra ma siggraph course notes physically modeling force acted get dependence minus sign front clearly pb depends sort manner 
compute pa pb depend combine results take dot product ni see di depends gives aij 
confused 
see code 
need compute bi 
know di contains constant term ni pa pb 
take account contributions pa pb due known external forces gravity force independent terms ra ra 
net external force acting fa external torque equations get fa contributes contributes fa ma ra 
part pa independent fa ma ra ra ra similarly pb 
compute bi combine constant parts pa pb dot ni add term ni pa pb 
siggraph course notes physically modeling code code implement derivations 
start computing constant bi terms 
return derivative normal vector triple contact vf vertex face contact vector attached 
return omega little trickier 
unit normal ea eb ea eb differentiating respect time left exercise code triple omega ea ea omega eb eb ea eb eb ea double length length normalize return void compute vector contact contacts int vector int contact contacts body triple ni ra xa rb xb get external forces torques triple ext force ext force ext torque siggraph course notes physically modeling ext torque triple ext part vel part ext part vel part operators cross product dot products triples matrix vector multiplication matrix triple 
compute part pa due external force torque similarly pb ext part ext mass ext ra ext part ext mass ext rb compute part pa due velocity similarly pb vel part omega omega ra omega ra vel part omega omega rb omega rb combine results dot ni double ext part vel part ext part vel part triple see section pt velocity definition double pt velocity pt velocity computing aij terms little tricky keep track jth contact force affects ith contact point 
routine efficient way things data structure tell advance aij going zero 
re working really huge numbers contacts extra done 
siggraph course notes physically modeling void compute matrix contact contacts int int int compute aij contacts contacts double compute aij contact ci contact cj bodies involved ith jth contact distinct aij zero 
ci cj ci cj ci cj ci cj return body ci ci triple ni ci ni nj cj pi ci ith contact point location pj cj jth contact point location ra pi rb pi force torque contact exert body triple force torque cj ci force direction jth contact force force nj torque direction torque pj nj cj ci force nj torque pj nj siggraph course notes physically modeling force torque contact exert body triple force torque cj ci force direction jth contact force force nj torque direction torque pj nj cj ci force nj torque pj nj compute jth contact force affects linear angular acceleration contact point body triple linear force mass angular torque ra triple linear force mass angular torque rb return ni linear angular linear angular siggraph course notes physically modeling baraff :10.1.1.163.5683
analytical methods dynamic simulation non penetrating rigid bodies 
computer graphics proc 
siggraph volume pages 
acm july 
baraff 
curved surfaces coherence non penetrating rigid body simulation 
computer graphics proc 
siggraph volume pages 
acm august 
baraff 
fast contact force computation rigid bodies 
computer graphics proc 
siggraph 
canny 
collision detection moving polyhedra 
ieee transactions pattern analysis machine intelligence 

formulation dimensional distinct element model part scheme represent contacts system composed polyhedral blocks 
international journal rock mechanics mineral science 
gilbert hong 
new algorithm detecting collision moving objects 
international conference robotics automation pages 
ieee 
gill hammarling murray saunders wright 
user guide fortran package constrained linear squares convex quadratic programming 
technical report sol systems optimization laboratory department operations research stanford university 
gill murray saunders wright 
user guide fortran package quadratic programming 
technical report sol systems optimization laboratory department operations research stanford university 
gill murray saunders wright 
user guide fortran package nonlinear programming 
technical report sol systems optimization laboratory department operations research stanford university 
goldstein 
classical mechanics 
addison wesley reading 
meyer 
distance boxes applications collision detection clipping 
international conference robotics automation pages 
ieee 
moore wilhelms 
collision detection computer animation 
computer graphics proc 
siggraph volume pages 
acm august 
preparata shamos 
computational geometry 
springer verlag new york 
press flannery teukolsky vetterling 
numerical recipes 
cambridge university press 
sedgewick 
algorithms 
addison wesley 
shoemake 
animating rotation quaternion curves 
computer graphics proc 
siggraph volume pages 
acm july 
von herzen barr 
geometric collisions time dependent parametric surfaces 
computer graphics proc 
siggraph volume pages 
acm august 
siggraph course notes physically modeling 
