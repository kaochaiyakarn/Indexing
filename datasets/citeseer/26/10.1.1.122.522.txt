arxiv cs cs pl nov templates partial evaluation todd veldhuizen explores relationship templates partial evaluation 
templates designed support generic programming unintentionally provided ability perform compile time computations code generation 
features completely accidental result syntax awkward 
recasting features terms partial evaluation simpler syntax achieved 
may regarded level language types class values 
template instantiation resembles offline partial evaluator 
describes preliminary single mechanism partial evaluation unifies generic programming compile time computation code generation 
language introduced illustrate ideas 
templates added language support generic programming 
addition unintentionally introduced powerful mechanisms compile time computation code generation 
mechanisms proven useful generating optimized code scientific computing applications 
accidental features syntax somewhat awkward 
goal achieve simpler syntax recasting features partial evaluation 
start briefly summarizing capabilities provided templates intended accidental 
generic programming original intent templates support generic programming summarized reuse parameterization 
generic functions objects parameters customize behavior 
parameters known compile time static binding 
example generic vector class declared template typename int class vector member functions private data example vector vector int indiana university computer science department bloomington indiana usa 
phone 
extreme indiana edu vector class takes template parameters line type parameter specifies element type vector parameter length vector 
vector class template arguments provided line 
causes template instantiated instance template created replacing occurrences definition vector int respectively 
functions may templates 
function template sums elements array template typename sum array int result int result array return result function works built types user defined types provided appropriate operators defined 
templates allow programmers develop classes functions customizable retain efficiency statically configured code 
compile time computations templates exploited perform computations compile time 
discovered erwin unruh wrote program produced errors compile time erwin cpp convert enum erwin cpp convert enum erwin cpp convert enum erwin cpp convert enum erwin cpp convert enum 
program compiler calculating list prime numbers 
capability quite accidental turned useful 
simpler example calculates pow compile time template int int struct ctime pow static const int result ctime pow result base case terminate recursion template int struct ctime pow static const int result example const int ctime pow result template defines structure ctime pow single data member result 
static const qualifiers result value available compile time 
ctime pow refers ctime pow compiler recursively instantiate template hits base case provided second template partial specialization 
array class uses ctime pow calculate number array elements needed template typename int length int dim class static const int ctime pow length dim result data example float array elements float array elements template instantiated ctime pow calculate array size required 
similar techniques find greatest common divisors test primality 
possible implement interpreter subset lisp runs compile time 
code generation turns compile time versions flow control structures loops case switches implemented terms templates 
example definition ctime pow section emulates loop tail recursion 
compile time programs perform code generation selectively inlining code interpreted compiler 
technique called template metaprogramming 
template metaprogram generates specialized dot product algorithm template typename int int struct meta dot static inline return meta dot template class int struct meta dot static inline return example float float meta dot float example call meta dot line marked results code equivalent float head recursion unroll loop vector elements 
syntax writing code generators clumsy 
technique proven useful producing specialized algorithms scientific computing 
possible create manipulate static data structures compile time encoding templates 
basis expression templates technique creates parse trees array expressions compile time 
parse trees generate efficient evaluation routines array expressions 
technique backbone libraries object oriented numerics 
traits traits technique allows programmers define functions operate return types data 
motivating example consider generic function calculates average value array 
return type 
array contains integers floating point result returned 
floating point return type obviously suffice complex valued array 
solution define traits class maps type array elements type suitable containing average 
simple implementation template typename struct average traits typedef average default behaviour template struct average traits int typedef float average specialization int float appropriate type averaging array type average traits average 
implementation average template class typename average traits average average array int typename average traits average result sum array return result templates partial evaluation partial evaluators regard program data containing subsets static data known compile time dynamic data known run time 
partial evaluator evaluates program possible static data outputs specialized residual program 
determine portions program may evaluated partial evaluator performs binding time analysis label language constructs data static dynamic 
labelled language called level language 
example binding time analysis scientific computing code produce level code fragment float float length return pow length float pow float int float int return static constructs underlined 
partial evaluator cmix evaluate static constructs produce residual code float float length return pow length float pow float float specializations result substantial performance improvements scientific code 
level language templates resemble level language 
function templates take template parameters static binding function arguments dynamic binding 
example pow function previous example declared template int float pow float calculate pow static data template parameter dynamic data function argument 
incorporate template type parameters viewpoint need regard types class values 
example declaration template typename int void func int int regard piece data value type 
statically typed type variables may static binding 
useful think type typename regarded type possible values span types 
point view certain simplifying power example view typedefs assignments typename variables 
example typedef float float type regarded equivalent fictional syntax typename float type float template instantiation offline pe partial evaluation languages contain binding time information called offline partial evaluation 
template instantiation resembles offline partial evaluation compiler takes template code level language evaluates portions template involve template parameters statically bound values 
example consider template class template int struct foo static const int result foo 
result base case template struct foo static const int result foo instantiated compiler determine 
true instantiates foo foo instantiated 
theory continues compiler hits base case 
simpler syntax preliminary ideas single mechanism partial evaluation unifies generic programming compile time computation code generation 
illustrate ideas introduce currently hypothetical language 
multi level language types class values 
binding time specifications scope program associated default binding time 
default global scope dynamic binding 
indicate statically bound variables symbol appended type int dynamic data int static data type int equivalent const int 
preserve consistency dynamic static versions language necessary allow multiple levels binding stages 
symbol indicates variable bound previous stage 
symbol may applied control constructs calculate 
factorial compile time int int recursion terminates known open problem 
impossible determine chain template instantiations terminate 
reason compilers place limits depth template instantiation chains 
operators applied compile time operands statically bound 
data may flow static dynamic constructs vice versa 
called cross stage persistence taha sheard :10.1.1.17.4285
example int int okay known runtime okay known ctime functions functions may take mixture static dynamic arguments 
find convenient give functions separate parameters lists 
implementation meta dot function described earlier function dot int typename result int result return result note simpler definition template metaprogram counterpart section 
function dot may thought generating extension higher order function 
concept easier express functional notation define dot lambda static pe static lambda dynamic body pe expr performs partial evaluation static 
argument lists form static dynamic hints idea avoids parsing difficulty associated brackets 
discards return type specification replaces keyword function 
return type may result compile time calculations inferred body function 
allow static parameters inferred dynamic argument types example function average inferred type array argument 
functions may evaluated compile time run time 
fixed stage 
example definition pow function pow int int int result int result return result invoke pow run time compile time int result pow evaluated run time int result pow evaluated compile time functions replace traits classes 
version average traits section return type appropriate averaging array function average type typename switch case int return float case char return float case long int return double default return illustrates usefulness regarding types class values 
average function recoded function average typename array int typename average average type sum array divide average sum int sum array return sum specialization calls function templates encountered compilation template instantiated 
similar process occur may called specialization partial evaluator produces residual function evaluating static constructs 
function call int data 
float result average int data triggers partial evaluation average resulting specialization translated float average int int array int float sum int sum array return sum classes classes may take static parameters contain static dynamic data members 
example class typename int length int dim public calculate array size needed dim length error dim length positive pow length dim initially set elements zero int data private static int data class constructors compile time constructor runtime constructor 
constructor invoked compilation class specialized 
time check static parameters ensure correct compile time error issued 
aid reflection may right way enforce constraints template parameters idea due vandevoorde 
constructor invoked runtime instances class created 
functions classes specified binding time may instantiated stage 
example int array instantiated compile time int array instantiated run time thoughts compiling implement described apparently needs interpreter compiler 
example compile function static parameters dynamic parameters steps needed 
interpreter partially evaluate static parameters interp fs 
compiler produce native code residual function fs compiler fs indicates native code 
wasteful lots duplicated effort create interpreter compiler 
may possible avoid problem approach similar pioneered cmix partial evaluation system 
basic approach closure compiler uses run time code generation rtcg compile single function 
rtcg bit misnomer code generation done compile time compiler 
example evaluate code int result pow evaluated compile time closure compiler cc compile pow native code execute function arguments cc pow pow pow evaluate level function transformed function 
suggest term flattening transform 
flattening turns level code single level code replacing dynamic code static code generates syntax trees dynamic code 
example level function float pow int float float result int result return result transformed int func lambda func body append float result result result int func body append op result func body append return result return fn aid flattening transformation level functions compiled interpreter notation partial evaluation pow function pow input result executing pow input 
example pow 
flatten cc gen gen fs cc fs flattening transform turn single level generator called 
generator compiled cc native code gen native code version executed static parameters produces specialized version fs 
function compiled cc 
availability fast portable run time code generation systems vcode approach compilation possible 
interesting possibilities languages abilities raise interesting possibilities scripting partial evaluator needs contain essentially interpreter evaluate static portions program 
implies get scripting extra cost program consisting solely static constructs completely interpreted residual code generated 
little bit extra ought possible dynamically link compiled programs possible steer applications natural scripting interface 
futamura projection suppose wrote interpreter domain specific language dsl 
design interpreter take input text static parameter input variables dynamic parameters 
interpreter result dsl code compiled dynamic subset futamura projection :10.1.1.10.2747
approach allow users incorporate fragments domain specific languages applications sacrificing efficiency 
reflection meta level processing language may provide natural environment implementing reflection meta level processing capabilities ability perform compile time calculations 
capabilities allow programmers query objects methods members determine parameter types functions manipulate generate syntax trees 
related nielson nielson investigated level languages showed bindingtime analysis expressed form type checking 
closely related metaml statically typed multi level language hand writing code generators :10.1.1.17.4285
metaml appear address issue generic programming 
gl ck rgensen described program generator multi level specialization uses multi level functional language represent automatically produced program generators 
metalevel processing systems address problems give library writers ability directly manipulate syntax trees compile time 
relevant examples mpc open 
systems phrased terms partial evaluation level languages code generation generally done constructing syntax trees 
closely related system provides level language generating runtime library code parallelizing compilers 
address issues generic programming 
idea types class values originates polymorphic second order typed lambda calculus languages 
shown templates may regarded level language types class values static binding template instantiation bears striking resemblance offline partial evaluation 
languages built insight may offer way provide generic programming code generation compile time computation single mechanism simple syntax 
acknowledgments supported part nsf cda ccr 
grateful robert gl ck pointing relevant partial evaluation 
andersen program analysis specialization programming language phd thesis diku university copenhagen may 
diku report 
berlin weise compiling scientific code partial evaluation computer pp 

chiba metaobject protocol oopsla pp 

czarnecki eisenecker meta control structures template metaprogramming 
home online de home ulrich eisenecker meta htm 
czarnecki eisenecker gl ck vandevoorde veldhuizen generative programming active libraries proceedings dagstuhl seminar generic programming vol 
tba lecture notes computer science 
review 
engler vcode retargetable extensible fast dynamic code generation system proceedings acm sigplan conference programming language design new york may acm press pp 

incorporating application semantics control compilation usenix conference domain specific languages dsl october 
futamura partial evaluation computation process approach compiler compiler systems computers controls pp :10.1.1.10.2747

gl ck rgensen automatic program generator multi level specialization lisp symbolic computation pp 

gl ck binding time analysis applied mathematical algorithms system modelling optimization eds chapman hall pp 

ishikawa hori sato maeda design implementation metalevel architecture mpc approach reflection 
jones partial evaluation acm computing surveys pp 

cummings humphrey smith williams array design expression evaluation ii vol 
springer verlag 
lecture notes computer science 
myers new useful template technique traits report pp 

nielson level functional languages cambridge university press cambridge mass 
siek lumsdaine matrix template library generic programming approach high performance numerical linear algebra international symposium computing object oriented parallel environments 
gross code composition implementation language compilers usenix conference domain specific languages 
taha sheard multi stage programming explicit annotations acm sigplan notices pp :10.1.1.17.4285

unruh prime number computation 
ansi iso wg 
veldhuizen expression templates report pp 

reprinted gems ed 
stanley lippman 
template metaprograms report pp 

reprinted gems ed 
stanley lippman 
arrays vol 
lecture notes computer science 
veldhuizen linear algebra template metaprograms dr dobb journal software tools pp 


