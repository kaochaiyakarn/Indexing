integrating planning learning prodigy architecture manuela veloso veloso cs cmu edu jaime carbonell carbonell cs cmu edu rez cs cmu edu daniel borrajo eugene fink fi upm es eugene cs cmu edu jim blythe cs cmu edu school computer science carnegie mellon university forbes ave pittsburgh pa phone number running head planning learning prodigy architecture 
journal experimental theoretical artificial intelligence research wright laboratory aeronautical air force materiel command usaf andthe advanced research projects agency arpa number 
views contained document authors interpreted necessarily representing official policies endorsements expressed implied wright laboratory government 
third fourth authors supported fellowships de ciencia spain 
current address facultad de inform tica universidad polit cnica de madrid campus de del monte madrid spain 
planning complex reasoning task suited study improving performance knowledge learning accumulation interpretation planning experience 
prodigy architecture integrates planning multiple learning mechanisms 
learning occurs planner decision points integration prodigy achieved mutually interpretable knowledge structures 
article describes prodigy planner briefly reports learning modules developed earlier project presents detail explored methods learn generate plans better quality 
introduce techniques illustrate comprehensive examples show empirical results 
article includes retrospective discussion characteristics prodigy architecture discusses evolution goal project building large robust integrated planning learning system 
prodigy architecture initially conceived jaime carbonell steven minton artificial intelligence ai system test develop ideas role machine learning planning problem solving 
general learning problem solving meaningless measurable performance improvements 
prodigy created testbed systematic investigation loop learning performance planning systems 
result prodigy consists core generalpurpose planner learning modules refine planning domain knowledge control knowledge guide search process effectively 
design prodigy simplifying assumptions planning algorithm focus study integrate learning planning 
planner prodigy prodigy assumed linear subgoaling decomposition interleaving subplans minton 
learning technique developed explanation learning control knowledge guide search process 
version architecture led minton complete impressive thesis extensive empirical analysis effect learning control knowledge planner performance minton 
minton successful pioneering results incorporating learning planning framework pursued investigation alternative learning techniques prodigy address domains problems increasing complexity 
led need evolve prodigy planning algorithm simple linear incomplete prodigy current nonlinear complete prodigy 
current prodigy architecture encompasses learning methods improve performance core planner different dimensions 
article organized sections 
section presents planner prodigy 
section describes learning opportunities addressed prodigy briefly reviews learning methods prodigy 
illustrate concretely learning integrated planning prodigy section presents techniques learn improve quality plans produced planner 
section discusses characteristics prodigy architecture shows evolution system pursuit goal building large robust planning learning system takes retrospective look project 
section draws article 
prodigy planning algorithm planning domain specified prodigy planner mainly set operators 
operator corresponds generalized atomic planning action described terms effects necessary conditions enable application operator 
planning problem domain prodigy initial configuration world goal statement achieved 
current prodigy system uses complete nonlinear planner 
follows means ends analysis backward chaining search procedure reasoning multiple goals multiple alternative operators relevant achieving goals 
prodigy nonlinear character stems dynamic goal selection enables planner fully interleave plans exploiting common subgoals addressing issues resource contention 
operators organized different levels abstractions prodigy plan hierarchically 
section describe prodigy combines state space search corresponding simulation plan execution plan backward chaining responsible goal directed reasoning 
formal description prodigy planning algorithm 
describe illustrate simple example planning domain language prodigy 
show planner represents incomplete plans considered search solution 
presents technique change internal planning state simulate effects plan execution introduce backward chaining algorithm 
discuss control rules prodigy guide search solution 
domain problem definition planning domain defined set types objects classes domain library operators inference rules act objects 
inference rules syntax operators distinguish section 
prodigy language describing operators strips domain language fikes nilsson extended express disjunctive negated preconditions universal existential quantification conditional effects carbonell 
operator defined preconditions effects 
description preconditions effects operator contain typed variables 
variables constrained functions 
preconditions operator represented logical expression containing conjunctions disjunctions negations universal existential quantifiers 
effects operator consist set regular effects list predicates added deleted state operator applies set conditional effects performed depending particular state conditions 
operator planning variables replaced specific objects corresponding types 
say operator instantiated 
precondition expression effects instantiated operator described terms literals term literal refers predicate variables instantiated specific objects 
order apply instantiated operator execute internal state planner preconditions satisfied state 
effects specify set literals added deleted state 
shows example planning domain simplified version process planning domain introduced gil 
section examples complete version domain describe techniques learning control rules 
simplified domain represents operations drill press 
drill press uses types drill bits spot drill twist drill 
spot drill small spot surface part 
spot needed guide movement twist drill drilling deeper hole 
types objects domain part drill bit 
type subdivided subtypes spot drill twist drill 
types combined functions limits scopes possible values variables description operators 
planning problem defined set available objects type initial state goal statement initial state represented set literals 
goal statement logical formula equivalent preconditions expression contain typed variables conjunctions negations disjunctions universal existential quantifications 
example planning problem shown 
example objects metal parts called part part spot drill drill twist drills drill drill 
solution planning problem sequence operators applied initial state transforming state satisfies goal 
sequence operators called total order plan 
plan valid preconditions operator satisfied execution operator 
valid plan achieves goal statement called correct 
example problem plan put part part put drill bit drill valid executed initial state 
plan achieve goal correct 
problem may solved correct plan put part part put drill bit drill drill spot part drill remove drill bit drill put drill bit drill drill hole part drill drill press part drill spot part drill bit part type part drill bit type spot drill pre holding tool drill bit holding part part add spot part drill hole part drill bit part type part drill bit type twist drill pre spot part holding tool drill bit holding part part add hole part drill bit put drill bit drill bit drill bit type drill bit pre tool holder empty add holding tool drill bit del tool holder empty remove drill bit drill bit drill bit type drill bit pre holding tool drill bit add tool holder empty del type hierarchy part drill bit spot drill twist drill holding tool drill bit put part part part type part pre part holder empty add holding part drill bit del part holder empty remove part part part type part simplified version process planning domain 
initial state part holder empty drill holder empty set objects part part type part drill type spot drill pre holding part drill bit add part holder empty del holding part drill bit drill drill type twist drill goal statement hole part problem simplified process planning domain 
partial order plan partially ordered set operators 
linearization partial order plan total order operators consistent plan partial order 
partial order plan correct linearizations correct 
example operators solution sequence need ordered respect giving rise partial order plan 
put part part put drill drill representation plans drill spot part drill operators example partial orden plan 
problem planning algorithms start empty plan modify solution plan 
plan may modified inserting new operator imposing constraint order operators plan instantiating variable description operator 
plans considered search solution called incomplete plans 
incomplete plan may viewed node search space planning algorithm 
modifying current incomplete plan corresponds expanding node 
branching factor search determined number possible modifications current plan 
different planning systems different ways representing incomplete plans 
plan may totally ordered sequence operators strips fikes nilsson partially ordered set operators tweak chapman nonlin tate snlp mcallester rosenblitt operators plan may instantiated veloso contain variables tweak relations operators goals establish may marked causal links nonlin snlp 
prodigy incomplete plan consists parts head plan tail plan see 
tail plan built partial order backward chaining algorithm starts goal statement adds operators achieve preconditions operators untrue current state pending goals 
head plan gap tail plan representation incomplete plan 
head plan valid total order plan sequence operators applied initial state variables operators head plan instantiated replaced specific constants 
head plan generated execution simulating algorithm described subsection 
current incomplete plan successfully modified correct solution problem current head plan solution 
state achieved applying head plan initial state called current state 
notice head plan total order plan contain variables current state uniquely defined 
back chaining algorithm responsible tail plan views initial state 
tail plan validly executed current state gap head tail 
purpose planning bridge gap 
shows example incomplete plan 
plan constructed prodigy solving problem making spot part 
gap plan bridged single operator put drill bit drill 
simulating plan execution state space search initial state goal statement prodigy starts empty plan modifies step step correct solution plan 
empty plan root node prodigy search space 
head tail plan naturally empty current state initial state step prodigy modify current incomplete plan ways see 
add operator tail plan operator 
modifications tail handled planning algorithm called back chainer subsection 
prodigy move operator op tail head operator 
preconditions op initial state current state goal statement part holder empty tool holder empty put part part holding part part tool holder empty gap example incomplete plan 
drill spot part drill spot part satisfied current state op operator head current state updated account effects op 
may operators applied state 
usually possible goals plan operators instantiations operators achieve particular goal 
choices expanding tail plan 
applying operator moving head modifying current plan 
adding operator tail plan intuitively may imagine head plan carried real world prodigy changed world initial state current state tail plan contains operator preconditions satisfied prodigy apply changing world new state say analogy real world changes operation moving operator tail head called application operator 
notice term application refers simulating operator application 
application current head plan disastrous world suffer prodigy simply backtracks considers alternative execution sequence 
moving operator tail head way updating head plan 
prodigy perform additional changes state adding redundant explicit information inference rules 
prodigy recognizes plan solution problem head plan achieves goal statement goal statement satisfied prodigy may terminate finding solution may search plan 
table summarizes execution 
places prodigy chooses alternative modifications current plan marked decision points 
guarantee completeness prodigy consider alternatives decision point 
notice construction head plan valid 
prodigy terminates goal statement satisfied current state achieved applying head plan 
termination head plan valid achieves correct solution planning problem 
conclude prodigy sound planner soundness depend back chainer 
prodigy 
goal statement satisfied current state return head plan 

back chainer adds operator tail plan operator application moves operator tail plan head plan 
decision point decide apply operator add operator tail 

recursively call prodigy resulting plan 
operator application 
pick operator op tail plan applicable operator operator tail plan ordered op preconditions op satisfied current state decision point choose applicable operator apply 

move op head plan update current state table execution simulating algorithm 
backward chaining algorithm turn attention backward chaining technique construct prodigy tail plan 
tail plan organized tree see 
root tree operator finish adds goal statement nodes operators edges ordering constraints 
operator tail plan added tail plan achieve pending goal 
operator gets instantiated immediately inserted tail gap tail plan tree structured tail plan 
precondition literal tree tail plan considered hold current state linked operator tail plan 
backward chaining algorithm called modify tail chooses literal adds new operator op achieves establishes ordering constraint op op 
op marked relevant operator achieve inserting operator op tail plan back chainer substitutes free variables op 
prodigy domain language allows complex constraints preconditions operators finding set possible substitutions may difficult problem 
problem handled constraint matching algorithm described wang 
example suppose planner adds operator drill hole part drill bit order achieve goal literal hole part effects operator unify goal see 
prodigy instantiates variable part description operator constant part goal literal 
system instantiate remaining free variable drill bit 
problem contains twist drills drill drill variable possible instantiations 
different instantiations give rise different branches search space 
drill hole part drill drill hole part drill bit hole part hole part drill hole part drill instantiating newly added operator 
hole part summary backward chaining algorithm table 
may shown back chaining algorithm execution simulator described previous subsection guarantees completeness planning fink veloso 
notice decision point step algorithm may required efficiency depth planning completeness 
prodigy generates entire tail applying need branching step 
may pick preconditions order matter order add nodes tail plan 
back chainer 
pick goal precondition literal decision point choose literal 

pick operator op achieves decision point choose operator achieves literal 

add op plan establish link op 
instantiate free variables op 
decision point choose instantiation variables operator 
table backward chaining algorithm 
control rules algorithms previous section tables determine search space prodigy planner 
different choices decision points algorithms give rise different ways exploring search space 
usually prodigy uses depth search explore search space 
efficiency depth search crucially depends choices decision points 
summarizes decisions system step planning directly related choice points tables 
strategies prodigy directing choices decision points called control knowledge 
strategies include control rules usually domain dependent minton complete problem solving episodes analogy veloso carbonell domain independent heuristics blythe veloso stone 
focus explaining control rules 
control rule production rule tells system choices avoided depending current state preconditions tail plan operators meta level information previous choices subgoaling links 
control rules hand coded user automatically learned system 
techniques learning control rules minton etzioni rez etzioni 
rule learning techniques see section 
shows decisions prodigy decisions controlled control rules 
directly compared 
see search node corresponds sequence decisions learning opportunities 
apply decide apply operator add operator tail modify operator application choose operator apply top level branching decisions 
back chainer choose literal choose operator achieves literal choose instantiation variables operator examples control rules shown table 
rule says just inserted operator drill hole part drill achieve unsatisfied goal literal hole drill literal holding drill bit drill satisfied current state specific drill drill instantiate variable drill drill consider instantiations variable 
equivalent saying drills identical perspective 
rule selects alternatives prunes branches search space 
rule called select rule 
similarly may define control rule points alternative considered pruning specific branch search space 
rules type called reject rules 
second rule table says unsatisfied goal literals hole part hole part part drill press goal considered second 
rule suggests branch search space explored branch 
rules provide knowledge preferred order considering different alternatives called prefer rules 
control rules prodigy divided groups select reject prefer rules 
control rules applicable current decision point prodigy 
select reject rules prune parts search space prefer rules determine order exploring remaining parts 
prodigy applies select rules part matches current situation creates set candidate branches search space considered 
branch candidate select rule spot part current goal drill spot part drill current operator holding drill bit drill holds current state drill type spot drill select drill drill prefer rule hole part candidate goal hole part candidate goal holding part part holds current state prefer goal hole part hole part table examples control rules 
select rule points branch 
select rules applicable current decision point default branches considered candidates 
prodigy applies reject rules match current situation prunes candidate pointed reject rule 
notice improper select reject rules may violate completeness planning rules prune solution search space 
carefully 
select reject rules prune branches search space prodigy applies prefer control rules determine order exploring remaining candidate branches 
system applicable prefer rules may general domain independent heuristics deciding order exploring candidate branches 
heuristics applicable prefer rules contradict ordering candidate branches 
prodigy encounters new planning domain initially relies control rules specified user domain independent heuristics branching decisions 
prodigy learns control rules stores problem solving episodes analogical case reasoning domainindependent heuristics gradually learned control knowledge 
learning prodigy prodigy planning algorithm combined learning modules designed reducing planning time improving quality solution plans refining domain knowledge 
shows learning modules developed prodigy learning goal 
describe briefly algorithms 
section detail prodigy learning modules improve quality plans produced planner 
learning control knowledge improve planning efficiency prodigy learning modules acquire control knowledge improve planning efficiency ebl explanation learning facility minton acquiring control rules problemsolving trace 
ebl analyzes search space planning algorithm explains reasons branching decisions search solution 
resulting explanations expressed form control rules 
prodigy ebl explanation learning observe expert observation practice experiment controlled experiments refine incomplete domain static alpine prodigy analogy static domain generation analogical reasoning evaluation abstraction hierarchy apprentice graphical knowledge acquisition prodigy planner hamlet incremental inductive explanation refinement quality evaluation quality analysis alternative plans learning modules prodigy architecture 
identify classes learning goals learn control knowledge improve planner efficiency reaching solution problem learn control knowledge improve quality solutions produced planner learn domain knowledge learn refine set operators specifying domain 
static method learning control rules analyzing prodigy domain description prior planning 
static program produces control rules examples planning problems 
experiments show static runs considerably faster ebl control rules static usually superior generated ebl 
rules static require ebl dynamic capabilities learn 
static design detailed predictive theory ebl described etzioni 
dynamic technique combines ebl static 
training problems pinpoint learning opportunities determine ebl explanations 
dynamic uses analysis algorithms introduced static relies training problems achieve distribution ebl rez etzioni 
alpine abstraction learning planning module knoblock 
alpine divides description planning domain multiple levels abstraction 
planning algorithm uses description domain find outline solution plan refines outline adding necessary details 
analogy derivational analogy engine solves problem knowledge similar problems solved veloso carbonell veloso 
planner records justification branching decision search solution 
justifications guide search solutions similar problems 
learning domain knowledge acquiring planning knowledge experts difficult knowledge engineering task 
learning modules support user specification domain knowledge acquisition refinement times 
experiment learning experimentation module refining domain description properties planning domain completely specified carbonell gil gil 
module prodigy notices difference domain description behavior real domain 
experiment module aimed refining knowledge properties real world learning control knowledge 
observe provides novel method accumulating domain planning knowledge learning observation expert planning agents practice 
observations agent consist sequence actions executed state action executed state resulting execution action 
planning operators learned observation sequences incremental fashion conservative specific general inductive generalization process 
operators refined new ones created extending done experiment 
order refine new operators correct complete system uses new operators solve practice problems analyzing learning execution traces resulting solutions execution failures wang 
apprentice user interface participate apprentice dialogue enabling user evaluate guide system planning learning 
interface graphic tied directly planning process system acquires domain knowledge user uses user advices guiding search solution current problem joseph joseph 
learning modules loosely integrated planning algorithm domains 
learned control knowledge planner 
investigating ways integrate learning modules understanding tradeoffs conditions individual technique appropriate 
learning modules share generated knowledge tighter integration achieved 
initial effort direction ebl combination abstraction generator learn control rules level abstraction 
integration modules prodigy simplifies learning process results generating general control rules proofs space contain fewer details knoblock 
learning improve plan quality research planning far concentrated methods constructing sound complete planners find satisficing solution find solution efficiently chapman mcallester rosenblitt peot smith 
accordingly integrating machine learning planning described focused learning control knowledge improve planning efficiency learning acquire refine domain knowledge 
developed techniques learn improve quality plans produced planner 
generating plans essential element transforming planners research tools real world applications 
plan quality planning efficiency planning goals rarely occur isolation interactions conjunctive goals effect quality plans solve 
rez veloso argued distinction explicit goal interactions quality goal interactions 
explicit goal interactions represented part domain knowledge terms preconditions effects operators 
goals achieved respectively operators op op deletes goals interact strict ordering op op 
hand quality goal interactions directly related successes failures 
particular problem may different solutions quality goal interactions may arise result particular problem solving search path explored 
example machine shop scheduling domain identical machines available achieve goals goals may interact problem solver chooses just machine achieve goals wait machine idle 
problem solver uses machines just goals interact particular solution 
interactions related plan quality resources dictates interaction goals 
alternative better depends particular quality measure domain 
control knowledge guide planner solve interactions harder learn automatically domain theory set operators encode quality criteria 
argued heuristics guide planner better solutions incorporated planner case removing unnecessary steps breadthfirst search plan length evaluation function 
domains plan length accurate metric plan quality different operators different costs 
sophisticated search heuristics needed 
goal learning plan quality automatically acquire heuristics guide planner generation time produce plans quality 
ways measure plan quality discussed rez carbonell 
learning quality enhancing control knowledge focuses quality metrics related plan execution cost expressed linear evaluation function additive cost individual operators 
section strategies attacking learning problem implemented respectively learning modules quality hamlet 
quality assumes different final plans evaluated evaluation function identify alternative plans better quality 
quality provides plan checker allow user interactively find valid variations plan produced 
system analyzes differences sequence decisions planner encountered ones selected generate plan better quality 
learner interprets differences identifies conditions individual planning choices lead desired final plan 
quality compiles knowledge control decision making process new planning situations generate plans better quality 
hamlet acquires control knowledge guide prodigy efficiently produce cost effective plans 
hamlet learns exhaustive explorations search space simple problems loosely explains conditions quality success refines learned knowledge experience 
quality learning explaining quality differences knowledge plan quality domain dependent encoded domain definition set operators inference rules vary time 
capture knowledge quality assumes planner domain theory extended function evaluates quality final produced plans 
learning consists translation task plan evaluation function control knowledge usable planner plan generation time 
shows architecture quality implemented prodigy 
domain knowledge problems expert control knowledge faster planning interactive plan checker prodigy quality control knowledge better plans plan quality evaluation function architecture learning module quality learn control knowledge improve quality plans 
learning algorithm domain theory operators inference rules domain dependent function evaluates quality plans produced 
problems solve domain 
quality analyzes problem solving episodes comparing search trace planner solution current control knowledge search trace corresponding better solution better evaluation function 
search trace obtained asking human expert better solution producing search trace leads solution letting problem solver search better solution 
algorithm explains solution better outputs search control knowledge directs problem solving better quality plans 
points worth mentioning learning driven existence better solution failure current control knowledge produce 
change representation knowledge quality encoded plan evaluation function knowledge operational planning time plan search tree partially available decision 
translated knowledge expressed search control knowledge terms problem solving state meta state tail plan operators bindings chosen achieve goals candidate goals expand 
claim control knowledge necessarily guide planner find optimal solutions quality plans incrementally improve experience planner sees new interesting problems domain 
quality algorithm table shows basic procedure learn quality enhancing control knowledge case human expert provides better plan 
steps correspond interactive plan checking module asks expert better solution checks correctness 
step constructs problem solving trace expert solution obtains decision points control knowledge needed turn learning opportunities 
step corresponds actual learning phase 
compares plan trees obtained problem solving traces step explains solution better builds new control knowledge 
steps described detail 

run prodigy current set control rules obtain solution 
show sp expert 
expert provides new solution se possibly sp guide 

test se 
solves problem continue 
go back step 
apply plan quality evaluation function better sp continue 
go back step 
compute partial order se identifying goal dependencies plan steps 

construct problem solving trace corresponding solution satisfies determines set decision points problem solving trace control knowledge missing 
sp 

build plan trees tp corresponding respectively search trees 
compare tp explaining better sp build control rules 
table top level procedure learn quality enhancing control knowledge 
interactive plan checker quality interacts expert determine variations plan currently generated may produce plan better quality 
built interactive plan checker obtain better plan domain expert test plan correct better 
purpose interactive plan checker capture expert knowledge generate better plans order learn quality enhancing control knowledge 
interaction expert level plan steps instantiated operators problem solving time decisions relieving expert understanding prodigy search procedure 
plan checker offers expert plan obtained current knowledge guide build better plan 
interactive asks checks plan step time 
expert may pick operator old plan menu form propose totally new operator 
option see current state 
plan checker verifies correctness input operator name variable bindings type specifications may suggest default value missing wrong 
operator applicable current state checker notifies expert precondition failed true 
new plan completed goal satisfied final state plan worse previous plan plan quality evaluation function plan checker informs prompts expert plan focus learning control knowledge improves solution quality 
mentioned interaction user level operators represent actions world 
domains inference rules usually correspond semantically actions world compute deductive closure current state 
plan checker require user specifies part plan fires rules needed similar way problem solver 
truth maintenance system keeps track rules fired operator applied state changes effects inference rules preconditions longer true undone 
constructing problem solving trace plan expert provided plan problem solver called order generate problem solving trace corresponds plan 
require solution precisely 
plan quality evaluation functions additive cost operators linearization partial order corresponding expert solution cost content obtaining trace 
veloso describes algorithm generates partial order total order 
force problem solver generate solution prodigy interrupt mechanism car run user provided code regular intervals problem solving 
decision node checks current alternative may part desired solution backtracks 
example bindings node checks instantiated operator part expert plan tries different set bindings 
result process search trace produces expert solution set decision points current control knowledge lack overridden guide prodigy expert solution 
learning opportunities algorithm 
building plan trees point problem solving traces available current control knowledge corresponding better plan 
quality builds plan tree 
nodes plan tree goals operators bindings instantiated operators considered prodigy problem solving successful search path lead solution 
tree goal linked operator considered achieve goal operator linked turn particular instantiation bindings chosen bindings linked subgoals corresponding instantiated operator preconditions 
leaf nodes correspond subgoals true prodigy tried achieve 
reason true stored goal node true initial state achieved operator chosen subgoal 
shows plan trees corresponding plans problem 
plan quality evaluation function assign costs nodes plan tree starting leaves propagating back root 
leaf nodes cost 
operator node cost evaluation function plus sum costs achieving preconditions costs children subgoals 
operator bindings nodes cost 
goal node cost operator achieve child 
note goal child operator 
cost achieving goal sum costs children operators 
root cost cost plan 
plans plan trees different costs tree left corresponding plan worse quality 
note solutions differ operator bindings chosen achieve 
decisions ones guidance provided control knowledge needed 
cost cost op op iop iop goal node operator node bindings instantiated operator node op op iop iop cost instantiated operator iop plan quality evaluation function cost associated node goal node ng ng leaf node nop nop child ng op node nop nop child nop bindings node iop children ng plan trees corresponding solutions different quality problem 
cumulative cost subtree propagated 
number node indicates cost subtree rooted node 
learning control rules plan trees algorithm explains solution better 
cost plan trees compared recursively starting root looking cost differences 
trees cost achieving trees cost achieving different 
subtrees explored turn 
cost children operators operators 
subgoals expensive achieve better solution 
fact cost zero shared subtree corresponding 
algorithm considers explains different costs plans 
note ignores subgoals higher cost cheaper solution introducing incompleteness explanation construction 
explanation shared operational expressed knowledge available planner decision time 
step algorithm table indicated learning opportunities wrong decisions planner new control knowledge required 
op bindings corresponding iop preferred op 
corresponds operator bindings decision 
explanation propagated subtrees reaches node corresponding decision point gathering conditions shared subgoal 
node pending goal subgoal op shared subgoal precisely op chosen appropriate set bindings iop facts control rules built 
learning opportunity defines right hand side rule operator bindings prefer preconditions current goal rest preconditions come explanation 
algorithm able learn goal preferences 
example plan quality process planning domain illustrate algorithm just described introduce example domain process planning production manufacturing 
domain plan quality crucial order minimize resource consumption execution time 
goal process planning produce plans machining parts specifications 
planning requires account technological economical considerations latombe doyle instance may advantageous execute cuts machine fixing reduce time spent setting machines hole opens hole recommended machining order avoid risk damaging drill 
considerations pure constraints preferences compromises necessary 
represent experience know engineers may differ 
section gave simplified example actions involved drilling hole 
realistic implementation domain prodigy gil gil rez 
implementation concentrates machining joining finishing steps production manufacturing 
order perform operation part certain set actions required part secured machine table holding device certain orientation cases part clean preceding operations 
appropriate tool selected installed machine 
table shows initial state goal problem domain 
goal produce part height spot hole sides side 
system knows domain dependent function evaluates quality plans additive plan operators 
right operations tools machine parts selected portions set ups may shared may usually reduce total plan cost 
plan quality metric example captures different cost setting parts tools machines required machine part 
assume current control knowledge planner obtains solution table state diameter drill bit twist drill material part aluminum size part length size part height size part width goal part part size part height spot part hole side table example problem showing goal subset initial state 
uses drill press spot hole 
example operation drill spot drill drill spot drill vise part hole side side side indicates hole part drill press drill tool spot drill part held side sides facing holding device vise 
solution put tool drill drill spot drill put holding device drill drill vise clean part put machine table drill part hold drill vise part side side side drill spot drill drill spot drill vise part hole side side side put tool mm milling mach plain mill release drill vise part remove holding device drill vise put holding device mm milling mach vise remove part brush clean part put machine table milling mach part hold milling mach vise part side side side face mill milling mach part plain mill vise side side side height cost put tool mm milling mach spot drill put holding device mm milling mach vise clean part put machine table milling mach part hold milling mach vise part side side side drill spot drill mm milling mach spot drill vise part hole side side side remove tool milling mach spot drill put tool mm milling mach plain mill face mill milling mach part plain mill vise side side side height cost table plan obtained prodigy guided current control knowledge 
better plan evaluation function possibly input human expert 
problem 
domain milling machines drill presses reduce size part drill holes spot holes 
exists better plan evaluation function uses milling machine drill spot hole shares set machine holding device orientation drill mill operations part released held 
differences correspond problem solving time operator decision prefer drill spot drill milling machine drill spot drill instantiation decision bindings drill spot drill milling machine 
table shows improved plan 
plan may input human expert interactive plan checker 
search traces corresponding plans transformed plan trees similar ones shown 
hole milling machine proper holding device orientation subgoal holding milling mach vise part side side side shared face mill drill operations 
explain holding particular bindings shared algorithm traverses tree goal node finding drill spot drill milling machine chosen appropriate set bindings includes machine type milling machine particular holding device orientation 
note machine type determines bindings operator 
explanation operational point operator bindings decisions point holding pending goal precondition operator face mill 
table shows control rules learned example 
rules indicate operator bindings preferred achieve current goal spot hole certain part side pending goal tail plan hold part milling machine certain orientation certain holding device 
control rule pref drill spot drill milling machine current goal spot part hole side loc loc pending goal holding mach holding dev part side side pair type object mach milling machine prefer operator drill spot drill milling machine drill spot drill control rule pref bnds drill spot drill milling machine current goal spot part hole side loc loc current operator drill spot drill milling machine pending goal holding mach holding dev part side side pair diff mach mach diff holding dev holding dev diff side pair side pair prefer bindings mach mach hd holding dev sp side pair mach mach hd holding dev sp side pair table operator bindings preference control rules learned problem table 
discussion quality builds explanation single example difference plan generated modification plan suggested expert 
compiles reasons alternative decision point preferred 
explanation incomplete consider possible hypothetical scenarios 
example assume third goal example problem hole 
performed drill press 
milling machine spot hole may best alternative part set drill press 
rules table fire choosing milling machine general 
consequence incomplete explanations learning general knowledge 
system refines learned knowledge incrementally unexpected failures 
failure mean preferred alternative leads plan improved 
refinement modify applicability conditions learned rules adds new rules needed sets priorities rules 
example specific rule considers existence goal learned priority previously learned general rule 
section show hamlet refines general specific rules changing applicability conditions 
process planning domain plan length usually accurate metric plan quality different operators different costs 
suppose planner goal drill holes different sides part hole requires different diameter drill bit 
initial state part held ready drill hole side machine holds drill bit suitable hole side 
possible plan starts releasing part holding orientation suitable hole side keeping tool drill spindle drilling hole 
alternative plan starts switching tool keeping part place drilling hole side 
plans length may different quality tool switched automatically holding part requires human assistance plan second 
obtain better plan goal drilling hole side achieved goal drilling hole side 
note different plan evaluation function switching tool expensive holding part order achieve goals opposite 
quality able learn goal preference rules produce better plan case 
hamlet incremental inductive learning control knowledge hamlet views planning episodes opportunity learn control knowledge improve planner performance quality plans generated 
relying comparison pairs complex plans quality hamlet assumes learner trained simple problems planner explore space possible plans 
generated exhaustive search tree hamlet learns control rules override default choices particular search strategy direct planner avoid planning failures generate plans optimal quality 
hamlet learns incrementally correct control knowledge 
uses initial deductive phase generates bounded explanation problem solving episode create control rules 
learned knowledge may specific general 
experiencing new problem solving episodes hamlet refines control knowledge incrementally acquiring increasingly correct control knowledge borrajo veloso borrajo veloso 
hamlet evolves previous authors borrajo 
inputs hamlet domain set training problems quality measure 
output set control rules 
hamlet main modules bounded explanation module inductive module refinement module 
bounded explanation module generates control rules prodigy search tree 
rules specific general 
induction module solves problem specificity generalizing rules analyzing positive examples 
refinement module replaces general rules specific ones finds situations learned rules lead wrong decisions 
hamlet gradually learns refines control rules converging concise set correct control rules rules individually general specific 
shows hamlet modules connection prodigy 
st st search trees generated prodigy planning algorithm set control rules set new control rules learned bounded explanation module set rules induced inductive module 
outlines hamlet algorithm 
new training search tree hamlet finds new positive examples opportunities learn control rules generates new rules possible induces general rules 
negative examples application control rules hamlet refines generates specific rules 
bounded explanation bounded explanation module learns control rules choosing important decisions search solution extracting information justifies decisions search space 
explanation procedure consists phases labeling decision tree credit assignment generation control rules parameterization 
labeling decision tree 
hamlet traverses search tree generated prodigy bottom starting leaf nodes 
assigns kinds labels node tree success node corresponds correct solution plan failure node dead search space unknown planner expand node know node lead solution 
label leaf nodes algorithm propagates labels root search tree hamlet training problems domain quality measure bounded explanation module st st prodigy st st learned control knowledge inductive module refinement module refer set learned control rules 
st refer search tree 
problem solved 
quality measure 
initially empty 
set training problems st result solving rules 
st result solving current set rules positive examples st st bounded explanation st st induce negative examples st st refine st st return shows hamlet high level architecture shows high level description hamlet learning algorithm algorithm described borrajo veloso 
nodes solution path labeled length optimal solution reached node 
shows example typical search tree leaf node labeled prodigy planner success failure 
shows hamlet propagates labels root tree 
general solutions problem 
grey nodes ones operator applied operator moved head plan 
typical prodigy search tree corresponding search solution leaf node labeled success failure tree hamlet labels attaches optimal solution length node 
credit assignment 
credit assignment process selecting important branching decisions learning occur 
done concurrently labeling 
hamlet views branching decision learning opportunity decision leads best solutions differs default decision domain independent heuristics 
shows learning opportunities hamlet find search tree 
wide lines show branching decisions learned case optimal learning 
learning opportunities tree figures 
generation control rules 
decision point learned hamlet access information current state search tail plan information 
information generation module create applicability conditions parts control rules 
relevant features current state selected goal regression 
hamlet learns kinds select control rules corresponding prodigy decisions 
kinds control rules template describing parts 
templates features instantiated particular state tail plan decisions learned 
complete set features borrajo veloso 
hamlet learns rules kind control rule general representation learned knowledge disjunction conjunctive rules 
parameterization 
rule generated hamlet replaces specific constants inherited considered planning situation variables corresponding types 
distinct constants replaced differently named variables rule applied different variables matched distinct constants 
heuristic may relaxed process inductive generalization learned rules 
inductive generalization rules generated bounded explanation method may specific noticed etzioni minton 
address problem inductive learning module generalizes learned rules analyzing new examples situations rules applicable 
devised methods generalizing aspects learned knowledge state subgoaling dependencies interacting goals type hierarchy borrajo veloso 
general look inductive process target concept shown figures 
wsp stands set preconditions rule refers complete description current state available information tail plan 
step shows bounded explanation step wsp generalized goal regression parameterization 
wsp learning opportunity 
step shows inductive generalization bounded rules 
step shows inductive generalization generating new rule 
goal regression inductive operators generate general rules hamlet keeps learning history backtrack generalization step refining learned knowledge explained section 
wsp wsp wsp learning episodes hamlet target concept 
shows initial step bounding explanation set preconditions control rule 
shows inductive step rule generating induced rule 
shows second inductive step generating 
example inducing new control rules example hamlet induces rules new general previous ones 
domain logistics transportation domain veloso 
domain packages delivered different locations different cities 
packages carried city trucks cities airplanes 
city locations post offices airports 
domain consists set operators load unload packages carriers different locations move carriers locations 
consider problem solving situation illustrated 
cities city city post office airport 
initially post office packages package package trucks truck truck 
airport airplane plane package package 
truck truck city airport airport 
goals package post office plane airport 
problem interesting package airplane need moved different city 
hamlet learn things package loaded airplane needed carrier airplane moves 
post office package package truck truck post office city initial state airport package plane city airport truck post office post office package city airport city airport goal statement plane illustrative example initial state goal statement 
optimal solution problem sequence steps table 
notice example optimal plan corresponds unique linearization general learning procedure reason partially ordered dependency network plan steps 
hamlet labels assigns credit decisions search tree generated prodigy 
rule 
load truck package truck post office drive truck truck post office airport unload truck package truck airport load airplane package plane airport fly airplane plane airport airport unload airplane package plane airport load truck package truck airport drive truck truck airport post office unload truck package truck post office table solution problem 
table learned decisions prodigy finds delay moving carriers package loaded 
hamlet target goal goal goals rest goals prior goal goal generated current node search tree 
control rule select inside truck target goal inside truck package truck prior goal object package post office true state truck truck post office true state object package post office true state city airport post office goals truck truck airport airplane plane airport select goals inside truck package truck control rule select inside truck target goal inside truck package truck prior goal object package airport true state truck truck airport true state object package post office true state city airport post office goals airplane plane airport select goals inside truck package truck table rule learned hamlet applying bounded explanation rule learned hamlet second example 
rule says planner find way achieving inside truck package truck moving carriers plane truck flying empty airplane achieve planning goals 
useful rule prodigy decides move carrier loading carrier moved back pick load resulting non optimal plan 
rule specific things prior goal package post office truck place package order goal 
suppose prodigy solves new problem package plane go airport truck initially airport 
hamlet learns new rule shown table 
rules table induction module generates rule table result applying inductive operators relaxing subgoaling dependency removes prior goal part refinement goal dependencies requires goals union goals rule finding common superclass finds common general type hierarchy prodigy types location common ancestor types airport post office 
complete list inductive operators borrajo veloso 
refinement control rule select inside truck target goal inside truck package truck true state truck truck location true state object package post office true state city location post office goals truck truck location airplane plane airport select goals inside truck package truck table rule induced hamlet rules shown tables 
hamlet may generate general rules doing goal regression generating rules applying inductive operators 
general rules need refined 
main issues addressed detect negative example refine learned knowledge 
negative example hamlet situation control rule applied resulting decision led failure expected success solution worse best decision 
negative example hamlet tries recover generalization refining wrong rule 
goal find general rule larger set predicates covers positive examples negative examples 
speed convergence refinement introduced informed elaborated ways adding features information content measure quinlan quinlan 
adapted methods incrementally 
refinement sorts predicates added part control rule information potential 
information literal supplies target concept computed information li tj lx li tj log li tj number predicates domain probability literal belongs positive example target concept compute measure target concept hamlet keeps frequency literal appeared state prior goal positive negative examples target concept 
detailed description refinement process borrajo veloso 
general example suppose rule general hamlet negative example application 
shows process refining 
case generating rules general 
refinement module backtracks refines rules generated 
general hamlet backtrack consider wsp generating refined rule rf 
general created rule rf deleting 
general generated new rule rf deleted 
dotted lines represent deleted links dotted boxes deleted rules normal boxes active rules refinement 
discussion learning system hamlet learns control rules enables prodigy efficiently obtain plans quality user defined criteria 
believe necessary build wsp rf wsp wsp rf rf graphical representation refinement process general control rule 
kind strategy learning tools existing problem solvers adaptive changing environments 
hamlet automatically analyzes decision making search episode produced planner 
identifies appropriate learning opportunities successful choices repeated failed ones avoided situations 
learning correct generalized conditions responsible decisions single example tractable real world applications 
hamlet learns incrementally correct control knowledge 
uses initial deductive phase generates bounded explanation problem solving episode create control rules 
learned knowledge may specific general 
experiencing new problem solving episodes hamlet refines control knowledge incrementally acquiring increasingly correct control knowledge 
empirical results carrying experiments measure impact learned knowledge quality plans domains 
section results process planning domain quality logistics transportation hamlet 
explored characteristics method suitable domain show empirical results allow prodigy produce plans quality 
plan quality improvement process planning domain implemented quality run preliminary experiments evaluate solution quality gained learned control knowledge 
table shows effect knowledge solution cost evaluation function mentioned section randomly generated problems process planning domain 
column corresponds set problems common parameters number type goals parts determine problem difficulty usefulness control knowledge 
training test problems planner require control knowledge obtain solution problem set recorded problems solution improved 
third row corresponds cost solutions obtained planner lacks quality enhancing control knowledge 
fourth row shows cost solutions obtained learned control rules 
rules learned different set randomly generated problems parameters sets table 
problems solution improved learning invoked 
smaller quality improvement obtained set due fact training phase include problems problem set probs set problems improvement learned control knowledge learned control knowledge cost decrease table improvement quality plans obtained randomly generated problems process planning domain 
similar parameters control knowledge relevant problems learned 
number nodes reduced learned control knowledge due shorter solution lengths 
total cpu time reduced plan analyze cost learned knowledge possible tradeoff matching cost savings obtained learned knowledge doing exhaustive search reasonably solution evaluation function 
exploring effect learning mechanism domains types evaluation functions 
plan quality improvement logistics domain trained hamlet simple randomly generated problems goals cities packages solution length quality measure 
hamlet generated control rules 
randomly generated testing problems increasing complexity 
table shows results tests 
varied number goals problems maximum number packages 
notice problems goals pose complex problems find optimal solutions 
test sets unsolved problems solved problems better solutions solution length nodes explored number number goals problems rules rules rules rules rules rules rules rules totals table table shows results increasingly complex problems logistics domain 
results show remarkable decrease number unsolved problems learned rules great number problems solution generated rules better quality accounting problems solved configurations 
time bound mod seconds 
running times decreased rules significantly 
currently developing efficient methods organizing matching learned control rules 
consider organization essential learning process avoid potential utility problem due inefficient matching doorenbos veloso 
related plan quality relationship plan quality goal interactions 
wilensky explores relationship detail 
planners process planning domain deal quality plans hayes nau chang domain dependent heuristics 
focuses post facto plan modification merging plans individual subgoals advantage helpful goal interactions 
prodigy uses control knowledge problem solving time able learn experience domain independent fashion 
ruby kibler learned control knowledge acquired underlying case learner 
developed extension prodigy solve optimization problems ebl method learn control rules find near optimal solutions lsi design 
quality goals represented explicitly quality final state plan 
equivalent quality evaluation function 
learning method similar quality compares solutions different quality builds explanation learns operator preferences 
quality quality evaluation function build explanation learns addition bindings goal preference rules 
case learned knowledge may refined experience 
method allow user guidance uses exhaustive search quality goal satisfied find best solution 
possible relatively small size search space examples 
ebl problem solving systems golding learn externally provided guidance 
guidance takes form plan reducing need user understand problem solving process 
method rely guidance quality evaluation function available system continues searching better solutions learns paths better 
soar rosenbloom uses similar approach optimizing computer configuration task 
chunking reduce search prefer better solutions 
quality explains difference cost paths simply union mattered paths may able build general rules 
number systems learn control knowledge planning systems oriented improving search efficiency plan quality 
speedup learning systems applied problem solvers linearity assumption ones applied prolog logic programming problem solvers quinlan zelle mooney special purpose problem solvers mitchell langley general purpose linear problem solvers etzioni fikes nilsson zukerman minton rez etzioni 
problem solvers known incomplete unable finding optimal solutions rich veloso 
learning strategy knowledge necessary step application today computer technology real world tasks 
current strategy learning systems eagerly try explain correctly problem solving choices single episode static analysis domain definition 
rely heavily complete axiomatic domain theory provide support generalization explanation episode situations 
requirement explanation effort generally acceptable real world applications incompletely specified subject dynamic changes 
remove linearity assumption dealing nonlinear problem solvers 
kind problem solvers needed address real world complex problems 
nonlinear planners search plan space partially ordered plans chapman mcallester rosenblitt 
remove linearity assumption fully interleaving goals searching state space keeping plans veloso warren 
approaches backward chaining approaches forward chaining laird 
general learning systems applied nonlinear problem solving 
approaches kambhampati kedar laird ruby kibler veloso 
addresses learning context nonlinear planning 
similar lazy approach followed tadepalli lazy explanation learning 
main difference refines knowledge introducing exceptions quality establishes priorities hamlet modifies control rules adding removing applicability conditions 
applies games general task planning consider plan quality 
prodigy discussion current characteristics doing research prodigy architecture years 
main characteristic prodigy research project addressing planning glass box decision making process integrated learning 
essence prodigy view planning decisions learning opportunities addressed depth part ongoing research agenda expand plan construction commit operator application continue subgoaling goal subgoal operators select order reduce selected goal bindings state select operator instantiation direct backtracking search space failure retain new control rule new planning case plan domain theory replaying retrieved cases experiment forge ahead evidence incompletely specified operator interact human expert user run fully automated mode 
long term goal enable prodigy address increasingly complex real world planning problems 
goal progressively enhancing planner learning algorithms cope challenges real world 
table shows evolution prodigy system problem solving version prodigy current planner learning system prodigy 
table enumerates prodigy characteristics dimensions domain representation search strategies learning methods 
table captures prodigy approaches solutions incrementally challenging planning tasks problems 
discuss issues underlying evolutionary processes 
representation domain control knowledge contributions steven minton dissertation terms initial design prodigy system solver clearly distinguish domain control knowledge 
far obvious distinction repeatedly overlooked planning literature 
precisely clean consistent distinction enabled prodigy group develop test rich variety learning mechanisms starting speedup learning maximize planning efficiency plan quality learning maximize plan execution efficiency factual knowledge refinement incomplete incorrect planning operators entirely new operator learning 
prodigy prodigy prodigy planning objects organized class hierarchy conjunctive preconditions disjunction negation existential prodigy domain control knowledge universal quantification preconditions functions constraining bindings regular effects add delete lists conditional effects inference rules control rules control guidance planning prep episodes state space search means ends backward chaining linear goal independence assumption nonlinear full interleaving goals planning subgoals chronological backtracking dependency directed backtracking search situations large set domain independent search strategies heuristics planning abstraction levels anytime planning incremental matching operators rete matcher control rules rete matcher operators control rules ebl analogy hamlet control knowledge alpine static analogy prep learning dynamic domain knowledge apprentice experiment apprentice observe plan quality quality hamlet table evolution prodigy planning learning real world planning problems 
primary distinction previous ai systems prodigy system distinction typically employ impoverished second class representation status control knowledge 
particular game playing systems express control knowledge numeric evaluation function usually linear weighted sum 
control knowledge macro operators consists fancy concatenation operation 
prodigy utilizes typed fol representation domain knowledge operators inference rules identical representation augmented meta predicates represent control knowledge form meta rules cases guide decision making decision points listed 
languages control domain knowledge expressed essentially role plays internal system markedly different 
domain knowledge lays legal moves control knowledge strategies legal moves apply order best achieve goals 
fact arbitrary reasoning occur control level apply decision points fundamental tenet prodigy architecture served 
advantages factual control knowledge distinction modularity domain control representation languages making easy add modify new knowledge kind system development 
reification control knowledge explicit data structures buried internals interpreter permitting direct acquisition clear glass box examination control knowledge 
selectivity building learning modules 
learning module focus specifically certain types knowledge planning efficiency applied certain types decision points 
compositionality acquired control knowledge 
theory multiple learning methods coexist task domain contribute improved performance experience accumulates 
theory far reduced practice pair wise manner learning systems coexisting 
larger scale multi module learning longer term research agenda 
multiple planning procedures modularity prodigy structure allows large degree versatility 
result prodigy emulates different planning search strategies controlling domain independent search parameters 
planner employ breadth depth best search controlled state space search means ends analysis 
multi level hierarchical planning plan refinement case tracking supported 
prodigy different search mechanisms 
currently prodigy emulate linear planning nonlinear planning full interleaving goals subgoals permitting controlled experimentation 
early versions prodigy flexible 
increased variety complexity domains prodigy apply noticed different planning strategies better suited different classes domains 
additionally comparisons planners permitting prodigy plan multiple modes quite useful stone veloso blythe 
domain generality prodigy applied wide range planning problem solving tasks robotic path planning blocksworld versions strips domain matrix algebra manipulation discrete machine shop planning scheduling computer configuration logistics transportation planning 
prodigy architecture built domain independent ai system 
user able describe domain series operators prodigy domain representation language prodigy planner try find solution problems domain 
empirical question identify characteristics domains comply prodigy assumptions 
subscribe underlying domain independent substrate aware extensive empirical experiments domain dependence prodigy multiple domain independent search strategies 
believe single search heuristic performs efficiently problems domains stone 
current research interests learning clusters domains map appropriately different prodigy default search strategies permitting learning mechanisms improve performance domain handle exceptions cache reasoning paths 
scalability integrated architecture address increasingly large tasks objective model human cognition build useful knowledge systems complex tasks 
scalability calibrated multiple ways relate efficient behavior increasing complexity 
prodigy seek achieve reasonable measure scalability dimensions size domain total number objects attributes relations operators inference rules size problem number steps solution plan number conjuncts goal expression size visited search space variety number qualitatively different actions object types domain 
perplexity average fan decision point search space learned control knowledge 
stability domain involved deterministic actions involves unpredictable exogenous events 
learning techniques strive reduce visited search space problems respect virtual complete search space 
cognitive fidelity mentioned earlier prodigy project strives produce useful scalable maintainable reasoning learning architecture 
matches human cognition accident limited imagination prodigy designers human mind optimized aspects cognition 
aspects goal produce effective system problem solving planning learning choice cognitive approach secondary goal 
enumerate additional ways prodigy differs human thought cognitive architectures prodigy decisions goal operator apply objects apply operator backtrack local failure remember newly acquired knowledge refine operator inaccurate predictions 
introspect fully decision cycle modify 
consistent human mind extremely useful faculty rapid learning 
know human mind distinct cognitive abilities distinct methods achieving similar ends multiple learning methods 
modularization level sound engineering principle adhered 
integration brought sharing uniform knowledge representation common problem solving planning engine 
systems soar take monolithic structure 
learning mechanism chunking turned modulated 
better 
clearly believe superior engineering principles psychological ones 
implementation lessons learned prodigy start addressing complicated phenomenon addressing simpler versions 
extend simple versions address complicated phenomena occasionally find need reimplement system part 
process sequence simplification research development approximate learning planning methods success simplified task domains extension augmentations patching necessary reimplementation 
believe process inevitable building large ai systems 
lesson learned process keep full fledged phenomena mind keep system flexible possible 
situations easy transfer capabilities version system new system exhibits brand new capabilities orthogonal dimensions 
fortunately latest system prodigy proven flexible earlier implementations handled far wider variety phenomena 
learned lesson guarantees newer powerful system implementation required address new challenging phenomena 
lessons decision prodigy proven successful appear ill conceived light informed hindsight 
ill decisions fortunately implementational nature correctable prodigy modular architecture 
conceptual nature enumerate hidden control knowledge dilemma early prodigy designed operator preconditions lexically fixed expansion order 
operator preconditions strictly right 
far mere convenience simple design decision created control point subgoal ordering open learning mechanisms performance dependent correct initial encoding 
feature correspond implicit control knowledge introduced performance degradation short run enhanced learnability control knowledge long run 
essence learned deviate glass box philosophy decisions deliberate explicit comprise opportunities learn 
nonlinear ebl myth initial explanation speedup learning techniques prodigy prodigy ebl static dynamic developed context linear prodigy 
complete axiomatization planning domain support generalization explanations successes failures single particular search episode 
algorithms eagerly try explain correctly problem solving choices single episode static analysis domain definition 
rely heavily complete axiomatic domain theory provide support generalization explanation episode situations 
process trying apply techniques directly designed nonlinear prodigy accumulated interesting examples methods failed learning correct useful control knowledge 
fact nonlinear problem solving developed prodigy feasible obtain perfect explanation decisions correct 
explanation methods rely heavily axiomatization problem solver planning domain easily acquired user automatic domain analysis 
developed alternative approaches learn control knowledge lazily form planning cases replayed analogy prodigy analogy inductively incrementally refining learned knowledge hamlet 
ubiquitous version control problem learning mechanisms depended internal data structures planner making application newer powerful version system problematical 
painfully learned software engineering lessons modularity localization data paths access functions careful version control 
unfortunately lesson universally applied parts project 
simpler problem generation detail discovered early creation learning derivational analogy far efficient solve simple versions problems expand solution full fledged versions problems attacking start 
naively decided build add module problem simplification 
years ago module exist 
fact open research problem recognized george polya polya characterizing general useful simplifications arbitrary problems 
headway exploring 
prodigy system extremely useful research vehicle planning learning scaling 
spite flaws permitted nearly dozen graduate students explore questions required far longer phd period prodigy platform launching pad booster 
permitted comparisons analyzes multiple learning techniques problems common encodings common planning substrates 
research continues current greater emphasis planning methods learning map problem domain planning search strategy learning knowledge level 
prodigy architecture integrates planning different learning mechanisms robust reasoning framework 
article introduced prodigy system 
prodigy planner overviewed early learning modules 
learning prodigy addresses different aspects performance improvement ai reasoning system learning control level learn improve efficiency planner search learning domain level domain theory set planning operators acquired refined incompletely specified learning plan quality focus acquiring planning knowledge guides better generate plans quality previously specified quality metric 
particular developed learning strategies acquire control knowledge guide planner produce solutions quality 
discuss characteristics prodigy system evolution years research producing large robust planning learning ai system 
prodigy architecture demonstration show article empirical evidence integration planning learning greatly increases solvability horizon planning system 
learning allows interpretation planning experience solving simple problems transferred problems considerable complexity planner may able address directly 
prodigy applied complex planning domains 
research goal prodigy powerful integration planning learning handle problems increasingly close real world problems 


learning incomplete explanations failures recursive domains 
proceedings machine learning conference pages 
blythe veloso 

analysis search techniques totally ordered nonlinear planner 
proceedings international conference ai planning systems college park md borrajo valente 

knowledge compilation model learning heuristics 
proceedings workshop knowledge compilation th international conference machine learning scotland 
borrajo veloso 

bounded explanation inductive refinement acquiring control knowledge 
proceedings third international workshop knowledge compilation speedup learning pages amherst ma 
borrajo veloso 

hamlet incremental deductive inductive learning local control knowledge nonlinear problem solving 
technical report cmu cs school computer science carnegie mellon university 
borrajo veloso 

incremental learning control knowledge nonlinear problem solving 
proceedings european conference machine learning ecml pages 
springer verlag 
carbonell blythe etzioni gil joseph kahn knoblock minton rez reilly veloso wang 

prodigy manual tutorial 
technical report cmu cs carnegie mellon university 
carbonell gil 

learning experimentation operator refinement method 
michalski kodratoff editors machine learning artificial intelligence approach volume iii pages 
morgan kaufmann palo alto ca 
chapman 

planning conjunctive goals 
artificial intelligence 
latombe 

making compromises antagonist constraints planner 
artificial intelligence 
doorenbos veloso 

knowledge organization utility problem 
proceedings third international workshop knowledge compilation speedup learning pages amherst ma 
doyle 

manufacturing processes materials engineers 
prentice hall englewood cliffs nj second edition 
etzioni 

structural theory explanation learning 
phd thesis school computer science carnegie mellon university 
available technical report cmu cs 
etzioni 

acquiring search control knowledge static analysis 
artificial intelligence 
etzioni minton 

ebl produces overly specific knowledge critique prodigy approaches 
proceedings ninth international conference machine learning pages 
fikes nilsson 

strips new approach application theorem proving problem solving 
artificial intelligence 
fink veloso 

prodigy planning algorithm 
technical report cmu cs school computer science carnegie mellon university 
li yang 

theory algorithms plan merging 
artificial intelligence 
gil 

specification process planning prodigy 
technical report cmu cs school computer science carnegie mellon university pittsburgh pa gil 

acquiring domain knowledge planning experimentation 
phd thesis school computer science carnegie mellon university 
available technical report cmu cs 
gil rez 

applying general purpose planning learning architecture process planning 
working notes aaai fall symposium series symposium planning learning real applications 
golding rosenbloom laird 

learning general search control outside guidance 
proceedings tenth international conference artificial intelligence pages milan italy 
hayes 

machining planning model expert level planning process 
phd thesis robotics institute carnegie mellon university 


planner quality goal speedup learning optimization problem 
proceedings second international conference ai planning systems pages chicago il 
joseph 

graphical knowledge acquisition 
proceedings th knowledge acquisition knowledge systems workshop banff canada 
joseph 

graphical knowledge acquisition visually oriented planning domains 
phd thesis school computer science carnegie mellon university 
available technical report cmu cs 
kambhampati kedar 

explanation generalization partially ordered plans 
proceedings ninth national conference artificial intelligence pages 
nau yang 

handling feature interactions process planning 
applied artificial intelligence 
special issue ai manufacturing 
knoblock 

automatically generating abstractions planning 
artificial intelligence 
knoblock minton etzioni 

integrating abstraction explanation learning prodigy 
inproceedings ninth national conference artificial intelligence pages 
laird rosenbloom newell 

chunking soar anatomy general learning mechanism 
machine learning 
langley 

learning effective search heuristics 
proceedings ninth international joint conference artificial intelligence pages 
zukerman 

learning search control rules planning inductive approach 
proceedings machine learning workshop pages 
mcallester rosenblitt 

systematic nonlinear planning 
proceedings ninth national conference artificial intelligence pages 
minton 

learning effective search control knowledge explanation approach 
kluwer academic publishers boston ma 
minton 

learning effective search control knowledge explanation approach 
phd thesis computer science department carnegie mellon university 
available technical report cmu cs 
minton knoblock kuokka gil joseph carbonell 

prodigy manual tutorial 
technical report cmu cs school computer science carnegie mellon university 
mitchell utgoff banerji 

learning experimentation acquiring refining problem solving heuristics 
machine learning artificial intelligence approach pages 
tioga press palo alto ca 
nau chang 

hierarchical representation problem solving knowledge process planning system 
technical report tr computer science department university maryland 
peot smith 

threat removal strategies partial order planning 
proceedings eleventh national conference artificial intelligence pages washington dc 
rez carbonell 

automated acquisition control knowledge improve quality plans 
technical report cmu cs school computer science carnegie mellon university 
rez etzioni 

dynamic new role training problems ebl 
sleeman edwards editors proceedings ninth international conference machine learning pages 
morgan kaufmann san mateo ca 
rez veloso 

goal interactions plan quality 
preprints aaai spring symposium series symposium foundations automatic planning classical approach pages stanford university ca 
polya 

solve 
princeton university press princeton nj 
quinlan 

learning efficient procedures application chess games 
michalski carbonell mitchell editors machine learning artificial intelligence approach volume morgan kaufman 
quinlan 

learning logical definitions relations 
machine learning 
rich 

artificial intelligence 
mcgraw hill rosenbloom laird mcdermott newell 

soar experiment knowledge intensive programming problem solving architecture 
ieee transactions pattern analysis machine intelligence pami 
ruby kibler 

learning episodes optimization 
proceedings machine learning conference pages san mateo ca 
morgan kaufmann 
stone veloso blythe 

need different domain independent heuristics 
proceedings second international conference ai planning systems pages 
tadepalli 

lazy explanation learning solution intractable theory problem 
proceedings eleventh international joint conference artificial intelligence pages san mateo ca 
morgan kaufmann 
tate 

generating project networks 
proceedings fifth international joint conference artificial intelligence pages cambridge ma 
veloso blythe 

examining causal link partial order planning 
proceedings second international conference ai planning systems pages 
veloso 

nonlinear problem solving intelligent casual commitment 
technical report cmu cs school computer science carnegie mellon university 
veloso 

learning analogical reasoning general problem solving 
phd thesis school computer science carnegie mellon university 
available technical report cmu cs 
revised version manuscript published springer verlag 
veloso carbonell 

integrating analogy general problem solving architecture 
ras editors intelligent systems pages 
ellis horwood chichester england 
veloso carbonell 

derivational analogy prodigy automating case acquisition storage utilization 
machine learning 
wang 

constraint efficient matching prodigy 
technical report cmu cs school computer science carnegie mellon university 
wang 

learning planning operators observation practice 
proceedings second international conference ai planning systems aips pages chicago il 
warren 

system generating plans 
technical report department computational logic university edinburgh 
memo 
wilensky 

planning understanding 
addison wesley reading ma 
zelle mooney 

combining foil ebg speed logic programs 
proceedings thirteenth international joint conference artificial intelligence 

