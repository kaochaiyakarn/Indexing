lisp symbolic computation international journal kluwer academic publishers manufactured netherlands efficient implementation self dynamically typed object oriented language prototypes craig chambers craig self stanford edu david ungar ungar self stanford edu lee parcplace com computer systems laboratory stanford university stanford california 
developed implemented techniques double performance dynamically typed object oriented languages 
self implementation runs twice fast fastest smalltalk implementation despite self lack classes explicit variables 
compensate absence classes system uses implementation level maps transparently group objects cloned prototype providing data type information eliminating apparent space overhead prototype systems 
compensate dynamic typing user defined control structures lack explicit variables system dynamically compiles multiple versions source method customized receiver map 
version type receiver fixed compiler statically bind inline messages sent self 
message splitting type prediction extract preserve static type information allowing compiler inline messages 
inlining dramatically improves performance eliminates need hard wire low level methods iftrue 
despite inlining optimizations system supports interactive programming environments 
system traverses internal dependency lists invalidate compiled methods affected programming change 
debugger reconstructs inlined stack frames debugging information making inlining invisible self programmer 
generously supported national science foundation presidential young investigator ccr ibm texas instruments ncr tandem computers apple computer sun microsystems 
author address sun microsystems garcia avenue mountain view ca 
author address parcplace systems plymouth street mountain view ca 
originally published oopsla conference proceedings sigplan notices 
chambers ungar lee self dynamically typed object oriented language inspired smalltalk language 
smalltalk self type declarations allowing programmers rapidly build modify systems interference date type declarations 
self provides blocks lexically scoped function objects akin closures self programmers may define control structures standard control structures iteration boolean selection constructed blocks 
smalltalk object oriented languages self classes 
prototype object model object defines object specific behavior inherits shared behavior parent objects 
smalltalk self accesses state solely sending messages special syntax accessing variable changing value 
features combined self multiple inheritance rules help keep programs concise malleable reusable 
straightforward implementation self prototype model consume storage space dynamically typed object oriented programming languages reliance message passing access state exact higher penalty execution time 
developed implemented techniques eliminate space time costs features 
addition implemented optimizations enable self run twice fast fastest smalltalk system 
techniques improve implementations class object oriented languages smalltalk flavors clos trellis owl eiffel 
describes implementation self running year 
review self object execution model section 
describe self object storage system section introducing maps segregation presenting object formats 
section explains byte coded representation source code 
section reviews compiler techniques originally published 
section explains optimizations coexist exploratory programming environment supports incremental recompilation source level debugging 
section compares performance self fastest available smalltalk system optimizing compiler 
proposes new performance metric object oriented language implementations 
conclude discussion open issues 
smalltalk trademark parcplace systems write smalltalk referring smalltalk system language 
illustrate unusual note respected authorities gone far require object oriented languages provide classes 
prototype models discussed 
efficient implementation self overview self self initially designed second author randall smith xerox parc 
subsequent design evolution implementation undertaken mid authors stanford university 
self objects consist named slots contains object 
slots may designated parent slots appending asterisks names 
objects may self source code associated case object called method similar procedure 
new object self existing object called prototype simply cloned 
message sent object called receiver message object searched slot name message 
matching slot contents object parent slots searched recursively self multiple inheritance rules disambiguate duplicate matching slots 
matching slot contents evaluated result returned result message send 
object code evaluates slot holding acts variable 
object code method prototype activation record 
evaluated method object clones fills self slot receiver message fills argument slots arguments message executes code 
self slot parent slot cloned activation record inherits receiver message send 
instance point example shown page sending message cartesian point object finds slot immediately 
contents slot integer evaluates associated code producing result message 
sent polar point object wouldn immediately 
object parents searched finding slot defined polar point traits object 
slot contains method computes coordinate rho theta coordinates 
method get cloned executed producing floating point result 
print message sent point object print slot defined point traits object 
method contained slot prints point object cartesian coordinates 
point represented cartesian coordinates messages access corresponding data slots point object 
print method works fine points represented polar coordinates messages find conversion methods defined polar point traits object compute correct values 
self supports assignments data slots associating assignment slot assignable data slot 
assignment slot contains assignment primitive object 
assignment primitive evaluated result message send stores argument associated data slot 
data slot efficient implementation self self allows programmers define control structures blocks 
block contains method slot named value method special invoked sending value block method runs child lexically enclosing activation record normal method activation block method activation 
self slot rebound invoking block method inherited lexically enclosing method 
block methods may terminated non local return expression returns value caller block method caller non block method return statement kinds objects appear self object arrays byte arrays 
arrays contain single parent slot pointing parent object kind array contain variable number element objects 
names suggest object arrays contain elements arbitrary objects byte arrays contain integer objects range compact form 
primitive operations support fetching storing elements arrays determining size array cloning new array particular size 
self language described simple powerful resists efficient implementation 
self prototype object model object unique format behavior poses serious challenges economical storage objects 
self exclusion type declarations commitment message passing computation control structures variable accesses defeats existing compiler technology 
remainder describes responses challenges 
object storage system object storage system referred memory system represent objects self user world including objects 
creates new objects reclaims resources consumed inaccessible objects 
ideal memory system squeeze objects little memory possible high performance low cost 
earlier version self memory system documented 
memory system design exploits technology proven existing highperformance smalltalk systems 
minimal overhead common case self system represents object direct tagged pointers indirectly object table 
allocation garbage collection self system uses generation scavenging demographic feedback mediated augmented traditional mark sweep collector reclaim garbage 
subsections describe new techniques efficient object storage systems third subsection describes object formats detail 
chambers ungar lee maps naive implementation self prototype object model waste space 
self classes class objects contain format names locations instance variables methods superclass information instances instances contain values instance variables pointer shared class object 
self uses prototype model object define format behavior inheritance presumably implementation represent class format method inheritance information instance state information self object 
luckily regain storage efficiency classes self prototype object model 
self objects totally unique format behavior 
objects created cloning object modifying values assignable slots 
wholesale changes format inheritance object induced programmer accomplished invoking special primitives 
say prototype objects cloned identical way values assignable slots form clone family 
invented maps implementation technique efficiently represent members clone family 
self object storage system objects represented values assignable slots pointer object map map shared members clone family 
slot object map contains name slot slot parent slot offset object slot contents assignable slot slot contents constant slot non assignable parent slot 
object code method map stores pointer self byte code object representing source code method byte code objects described section 
maps immutable may freely shared objects clone family 
user changes format object value object constant slots map longer applies object 
case new map created changed object starting new clone family 
old map applies members original clone family 
implementation point view maps look classes achieve sorts space savings shared data 
maps totally transparent self language level simplifying language increasing expressive power allowing objects change formats 
addition map object conveys static properties self compiler 
section explains compiler exploit information optimize self code 
efficient implementation self parent cartesian point traits cartesian points maps cartesian point traits parent rho theta rho theta 
cartesian points maps parent cartesian point traits map parent rho theta rho theta 
parent offset offset cartesian point map example representations cartesian points parent 
maps slot require words name contents 
means point occupy words 
maps point object needs store contents assignable slots plus word point map 
constant slots format information factored map 
maps reduce words point words 
cartesian point traits object assignable slots data kept map 
chambers ungar lee segregation common operation memory system scan object meet criterion scavenger scans objects objects space 
reflective object modification programming primitives redirect object size changes moved 
browser may want scan objects contain particular object interests self user 
support functions self implementation designed rapid scanning object 
elements byte arrays represented packed bytes tagged words byte array elements may masquerade object 
smalltalk systems typically handle problem scanning heap object object word word 
object system checks see object contains object bytes 
object contains object system scan object matching iterating length object 
scanner proceeds object 
procedure avoids problems caused scanning byte arrays slows scan overhead parse object headers compute object lengths 
self system avoid problems associated scanning byte arrays degrading object scanning speed segregating byte arrays self objects 
generation scavenging memory space divided areas byte arrays objects 
scan object object area space needs scanned 
optimization speeds scans ways byte array objects scanned object headers parsed 
bytes area grows downward contains byte arrays object object area grows upward contains object confusing byte arrays self memory space efficient implementation self avoid slowing tight scanning loop explicit space check word space temporarily replaced sentinel matches scanning criterion 
scanner checks space matching word 
early measurements sun showed self system scanned memory rate approximately megabytes second 
measurements fastest smalltalk implementation machine indicated scanning speed non segregated memory spaces megabytes second 
kinds scans finding objects refer particular object scanner needs find objects contain matching 
system perform types searches nearly fast normal scan 
special tag header word object called mark word identify object 
scanner proceeds normally searching matching 
object containing simply scanning backwards object mark word converting mark address object 
object formats self memory space organized linear array aligned bit words 
word contains low order bit tag field interpret remaining bits information 
integer floating point number encodes number directly 
converting tagged integer immediate corresponding hardware representation requires shift instruction 
adding subtracting comparing tagged integers require conversion 
self objects map objects embed address object remember object table 
remaining tag format mark header word object required scanning scheme discussed previous subsection 
pointers virtual machine functions objects self heap represented raw machine addresses addresses bit half word aligned scavenger interpret immediates won try relocate 
object begins header words 
word mark word marking object 
mark contains scavenger immutable self hash primitive 
second word tagged object map 
self object assignable slots contains additional words represent contents 
array object contains length tagged self integer prevent interactions scavenging scanning elements bit tagged object bit untagged bytes padded nearest bit boundary 
chambers ungar lee bit signed integer representation map similar 
map objects mark map words 
map objects share map called map map map map map 
maps new space linked third words scavenge system traverses list finalize inaccessible maps 
fourth word map contains virtual machine address array function pointers functions perform format dependent operations objects maps 
maps objects slots fifth word specifies size object words 
sixth word indicates number slots object 
words contain change dependency link map described section 
words tagged integers 
map method ninth word byte code object representing method source code 
function pointer array exactly virtual function array generated compiler 
integer immediate virtual machine address top bits word aligned address self heap object bits ieee floating point number floating point immediate address scavenging fields hash field mark header word begins self heap object object slots object array byte array mark map slot contents slot contents slot contents mark map mark map array length array length element element element bytes bytes bytes efficient implementation self map includes word description object slots 
word points self string object representing name slot word describes type slot constant data slot assignable data slot assignment slot slot parent slot 
third word slot description contains contents slot constant slot offset object contents slot assignable data slot index corresponding data slot assignment slot 
words slot contain change dependency link slot described section 
self parents prioritized priority parent slot stored second word slot description 
map map data object method mark map map link function array object length slot count dependency link slot description slot description mark map map link function array object length slot count dependency link byte code slot description slot description map array mark map map link function array parent slot description constant slot data slot assignment slot description description description slot name slot type slot contents dependency link slot name slot type slot offset dependency link slot name slot type data slot index dependency link chambers ungar lee mark map slot contents slot contents mark map slot contents slot contents 
representation cartesian point objects 
objects left point instances containing values assignable data slots 
right object shared map cartesian points containing value constant parent slot offsets assignable slots 

map map 

parent const 
parent slot cart 
point traits 
data slot 
data slot 
assignment slot 
assignment slot 
mark map scavenging link function array object length slot count map dependency link slot name slot type slot contents slot dependency link slot name slot type slot offset slot dependency link slot name slot type slot offset slot dependency link slot name slot type data slot index slot dependency link slot name slot type data slot index slot dependency link efficient implementation self object formats determine total space cost represent clone family objects slots assignable words 
simple cartesian point example parent leading total space cost represent point objects words 
published accounts smalltalk systems indicate systems extra words object class pointer address hash code flags 
maps allow objects prototype system self represented just space efficiently objects class system smalltalk 
parser minimize parsing overhead textual self programs parsed entered system generating self level byte code objects smalltalk instances 
method object represents source code storing pre parsed byte code object method map cloned invocations method share byte code object 
byte code object contains byte array holding byte codes source object array holding message names object literals source 
byte code byte array represents single byte sized virtual machine instruction divided parts bit opcode bit object array index 
opcodes specified execution stack oriented interpreter actuality self compiler dynamically translates byte code objects native machine instructions just prior execution 
opcodes represent self programs self push self execution stack literal value index push literal value execution stack send message name index send message popping receiver arguments execution stack pushing result self send message name index send message self popping arguments execution stack pushing result super send message name index send message self delegated parents popping arguments execution stack pushing result delegatee parent name index delegate message send named parent non local return execute non local return lexically enclosing method activation index extension index extension extend index prepending index extension chambers ungar lee method object prototype activation record self 
code byte code object source code representation literals codes byte code array self send send print literal send print self send send print literal array representation point print method 
top object prototype activation record containing placeholders local slots method case just self slot plus byte code object representing source code stored method map 
byte code object contains byte array byte codes separate object array constants message names source code 
index opcodes index accompanying object array 
bit offset allows message names literals referred directly indices larger constructed extra index extension instructions 
self source code primitive operations invoked syntax send message message name begins underscore 
call primitive operation may optionally pass block invoked primitive fails appending message name 
invoked block passed error code identifying nature failure overflow divide zero incorrect argument type 
normal send byte codes represent primitive operation invocations simplifying byte codes facilitating extensions set available primitive operations 
contrast smalltalk primitives invoked number name may called method 
rest method executed primitive fails indication primitive failed 
print efficient implementation self byte codes needed express self programs fall classes base values literal self message sends non local return 
small number results simplicity elegance self language lack elaborate space saving encodings 
smalltalk defines larger set byte codes tuned minimize space maximize interpretation speed includes byte codes fetch store local instance class pool global variables shortcut byte codes common case operations loading constants nil true 
smalltalk systems special control flow byte codes implement common boolean messages iftrue iffalse smalltalk parser translates message sends conditional unconditional branch byte codes open coding argument blocks 
similarly message automatically translated identity comparison primitive operation byte code 
similar optimization included messages parser translates special byte codes 
executed byte codes directly invoke corresponding integer primitive operation receiver integer perform message send receiver isn integer 
special processing common messages may significantly improve performance existing smalltalk systems especially interpreted ones violate extensible flexible spirit smalltalk source code hard wired methods relegated documentation changes hard wired source code ignored system 
definitions iftrue iffalse types objects ignored 
receiver iftrue iffalse message evaluate true false object run time arguments block literals parse time receiver argument block literals parse time receiver block evaluate true false object run time 
worst aspect parser optimizations programmers select inappropriate control structures obtain performance hard wired message 
effect hard wired messages non object oriented built operators smalltalk 
self system incorporates tricks 
compilation techniques achieve better performance compromising language conceptual simplicity elegance preserving message passing model messages 
chambers ungar lee compiler self compiler significant part efficient implementation 
similar deutsch schiffman translator described implemented parcplace smalltalk system supports dynamic translation methods machine code transparently demand run time uses inline caching technique reduce cost non polymorphic message sends 
deutsch schiffman system fastest smalltalk system july runs times slower optimized combining traditional optimizing compiler technology techniques highperformance smalltalk systems critical new techniques developed self compiler achieved level performance twice fast deutsch schiffman system times slower optimized hope second generation system construction described section achieve better levels performance 
main obstacle generating efficient code smalltalk programs people noted little static type information available smalltalk source 
literal constants known class compile time detailed analysis types known 
type inferencing difficult smalltalk programs especially compiler inferred types improve performance 
smalltalk programmer willing sacrifice benefits exploratory programming environment annotate programs static type declarations designing adequate type system smalltalk hard flexible type system smaller performance improvement possible smaller reward including type declarations place 
self programs harder compile efficiently smalltalk programs 
problems missing static type information smalltalk compilers face faced self compiler 
addition variables self accessed sending messages explicitly identified variables source code byte codes 
classes self class techniques optimize smalltalk programs inline caching type inferencing static type checking directly self system 
compromising flexibility self programs static type system compromising execution speed programs interpreting dynamic type information developed compilation techniques automatically derive type information statically specified type systems 
combining extra information general purpose techniques optimizing compilers traditional languages fortran compiler achieves performance sacrificing interactive exploratory programming environment fast turnaround programming efficient implementation self changes complete source level debugging simple elegant programming language static type declarations 
subsections summarize new compilation techniques detailed discussion may 
customized compilation deutsch schiffman smalltalk system compiles single machine code method source code method 
classes may inherit method smalltalk compiler know exact class receiver 
self compiler hand compiles different machine code method type receiver runs source method 
advantage approach self compiler know type receiver message compile time generate better code specific versions method single general purpose compiled method 
call technique dynamic translation multiple methods single source code method customized compilation 
consider min method defined objects min arg arg iftrue self false arg 
method invoked integers floating point numbers strings objects compared 
dynamic compilation systems self system waits min method invoked compiling code method 
systems compile method receiver argument types require generating code full message dispatch select right comparison routine 
self compiler generates separate compiled version receiver type customize version specific receiver type new type information optimize message 
trace operations self compiler evaluate expression min contains integer run time 
assuming time min sent integer compiler generate code version min customized integer receivers 
compiler builds internal flow graph pictured top page expensive operations bold face 
expensive operations eliminated inlining messages sent receivers known type described 
simplify discussion message sends access local slots executing activation record arguments assumed replaced local register accesses immediately 
chambers ungar lee message inlining push self push arg send push self create closure push arg create closure send iftrue false compiler uses sources type information types source code literals type self gleaned customized compilation perform compile time message lookup message inlining 
type receiver message known compile time compiler perform message lookup compile time wait run time 
lookup successful absence dynamic inheritance programming errors compiler slot contains method compiler inline body method call site method short nonrecursive 
slot contains block value method compiler inline body block value method call site short 
inlining remaining uses block object compiler eliminate code create block run time 
slot constant data slot compiler replace message send value slot constant known compile time 
slot assignable data slot compiler replace message send code fetch contents slot load instruction 
slot assignment slot compiler replace message send code update contents slot store instruction 
inlining messages sent receivers known type compiler inlined messages equivalent smalltalk program variable assignments eliminating overhead self message passing access variables 
addition messages inlined smalltalk system remained full message sends 
efficient implementation self example version min customized integers compiler statically look definition defined integers arg arg 
method simply calls integer primitive failure block omitted brevity 
compiler inlines method get flow graph overhead sending message eliminated calling procedure compare integers expensive 
section explains compiler open codes common primitive built operations increase performance 
primitive inlining push self push arg push 
create closure call push self create closure push arg create closure send iftrue false primitive inlining viewed simpler form message inlining 
calls primitive operations normally implemented simple procedure call external function virtual machine 
high performance systems including smalltalk systems self compiler replaces calls certain common primitives integer arithmetic comparisons array accesses hard wired definitions 
significantly improves performance primitives implemented machine instructions overhead procedure call removed 
arguments side effect free primitive arithmetic comparison chambers ungar lee primitive known compile time compiler calls primitive compile time replacing call primitive result primitive self form constant folding 
ongoing min example compiler inlines call definition integer primitive integer method hard wired compiler get flow graph push true cmp self arg branch arg push false push self create closure push arg create closure send iftrue false push 
create closure send value compare branch sequence verifies argument call integer receiver known integer courtesy customization failure block created invoked 
argument integer integers compared true object false object returned result message 
message considered compiler iftrue false message 
arg integer common case receiver iftrue false true false result value message unknown compile time 
normally prevent inlining iftrue false message type receiver uniquely determined 
compiling multiple versions iftrue false message version statically known receiver type self compiler handle optimize case separately 
technique explained 
efficient implementation self message splitting type information lost flow control merges happens just prior iftrue false message min example self compiler may elect split message merge separate messages preceding branches merge postponed split message 
compiler knows type receiver copies message perform compile time message lookup message inlining radically improve performance versions 
proper semantics original unsplit message preserved compiling real message send branches unknown receiver types 
message splitting thought extension customized compilation customizing individual messages particular control flow paths similar improvements run time performance 
min example self compiler split iftrue false message separate versions push true push self create closure push arg create closure send iftrue false cmp self arg blt arg push false push self create closure push arg create closure send iftrue false push 
create closure send value push self create closure push arg create closure send iftrue false chambers ungar lee compiler inline definition iftrue false true object iftrue false value 
false object iftrue false value 
get flow graph push true push self create closure push arg create closure cmp self arg blt arg push false push self create closure push arg create closure push 
create closure send value push self create closure push arg create closure self value arg value send iftrue false value messages inlined replaced bodies blocks 
receiver arguments inlined iftrue false messages need created run time compiler eliminates control flow graph producing flow graph top page 
assume failure block integer comparisons complex inline away 
compiler won inline value message value message result type unknown compile time 
receiver type iftrue false message unknown simple self compiler wouldn able inline message away 
subsection describes compiler uses known patterns usage predict receiver iftrue false message boolean optimizes message accordingly 
efficient implementation self push self type prediction cmp self arg blt arg push arg push 
create closure send value push self create closure push arg create closure send iftrue false type receiver message unknown compile time self compiler uses static type prediction generate better code common situations 
certain messages known compiler sent receivers certain types sent integers iftrue false sent true false 
compiler generates run time test expected type value receiver followed conditional branch sections code success branch type value receiver known compile time failure branch type unknown 
compiler uses message splitting techniques split predicted message compiling copy message branch 
compiler knows type receiver split message success branch inline version message away significantly improving performance common operations integer arithmetic boolean testing 
real message send executed case prediction fails preserving original message semantics possible receivers 
chambers ungar lee type prediction scheme requires little additional implementation message splitting inlining implemented 
better hard wiring iftrue iffalse messages parser compiler smalltalk systems achieves sorts performance improvements preserves message passing semantics language allows programmer modify definitions self methods including optimized type prediction 
apply type prediction remaining iftrue false message min example 
compiler inserts run time tests true object false object followed copies iftrue false message ll just look remaining unoptimized branch push self create closure push arg create closure send iftrue false push 
create closure send value cmp true beq push self create closure push arg create closure send iftrue false cmp false beq push self create closure push arg create closure send iftrue false efficient implementation self left branch receiver iftrue false known value true middle branch receiver known value false 
compiler inlines iftrue false messages plus corresponding value messages eliminates closure creations get final flow graph entire method cmp self arg blt push self arg push 
create closure send value cmp true beq push arg cmp false beq push self create closure push arg create closure send iftrue false chambers ungar lee common case minimum integers compiler executes simple compare branch sequences fast execution 
similar savings seen user calls min floating point numbers strings compiler customizes optimizes special versions receiver types 
case minimum values different types integer floating point number compilation techniques preserve message passing semantics original source code execute source code faithfully 
supporting programming environment self system supports high productivity programming environment 
environment requires rapid turn time programming changes complete source level debugging byte code level 
features coexist optimizing compiler techniques including message inlining 
subsections describe compiler maintained change dependency links support incremental recompilation compiled code affected programming changes compiler generated debugging information allows debugger reconstruct inlined stack frames debug time 
information appended compiled method object compiled code cache 
support incremental recompilation high productivity programming environment requires programming changes take effect fraction second 
accomplished self system selectively invalidating compiled methods affected programming change recompiling new definitions needed 
compiler maintains way change dependency links cached compiled method slots compiled method depends 
information compile code object formats contents non assignable slots precisely information stored maps 
confine dependency links maps 
links formed ways method compiled system creates dependency link map slot description containing method compiled code case definition method changes slot removed 
compiler inlines message system creates dependency link matching slot description method slot data slot assignment slot compiled code case definition inlined method changes slot removed 
efficient implementation self compiled method header native machine code scavenging info 
dependency links scope descriptions byte code mappings scope description caller scope desc 
ptr 
slot locations byte code mapping address scope desc 
ptr 
byte code index compiled method contains just instructions 
includes list offsets instructions embedded object scavenger modify compiled code referenced object moved 
compiled method includes dependency links support selective invalidation 
includes descriptions inlined method scopes find values local slots method display source level call stacks bidirectional mapping source level byte codes actual program counter values 
compiler searches parent object course compiletime lookup system creates dependency link slot description containing parent compiled code case parent pointer changes alters result lookup 
compiler searches object unsuccessfully matching slot compile time lookup system creates dependency link map object searched compiled code case matching slot added object 
rules ensure date compiled methods survive programming changes limiting invalidations methods affected change 
dependency link represented circular list connects slot description map dependent compiled methods 
system changes contents constant slot removes slot traverses corresponding dependency list chambers ungar lee root root map integer traits integer traits map true false compiled code integer min min map dependency parent map dependency integer map parent map dependency true map parent iftrue false map dependency false map parent dependency lists iftrue false map dependency case min added case parent change affects min lookup case changed case min added case parent change affects min lookups case min added case iftrue false changed case iftrue false changed dependency lists compiled min method customized integers 
gray line represents separate circularly linked dependency lists 
list connects slot description dependent compiled code objects 
map information linked compiled code changes compiled code min compiled methods depend changed information thrown away recompiled needed 
efficient implementation self invalidates compiled code objects list 
system adds slot similarly traverses map dependency list invalidates linked compiled code objects 
links removed lists method invalidated map garbage collected lists doubly linked speed removals 
selective invalidation complicated methods executing programming change requires invalidated 
methods really flushed executing code exist 
remain untouched optimized information longer correct 
solution implemented recompile executing methods immediately rebuild execution stack new compiled methods 
know procedure fast keep programming turn time short 
support source level debugging programming environment include source level debugger 
self debugger presents program execution state terms programmer execution model state byte code interpreter optimizations 
requires debugger able examine state compiled optimized self program construct view state virtual state terms byte coded execution model 
examining execution state complicated having methods virtual call stack inlined methods compiled method call stack allocating slots virtual methods registers stack locations compiled methods 
allow debugger reconstruct virtual call stack physical optimized call stack self compiler appends debugging information compiled method 
scope compiled initial method methods block methods inlined compiler outputs information describing scope place virtual call chain compiled method physical stack frame 
argument local slot scope compiler outputs value slot constant known compile time slots register stack location allocated hold value slot run time 
self compiler outputs debugging information support computing setting breakpoints 
information takes form bidirectional mapping program counter addresses byte code instructions particular scope 
complexity mapping byte codes may map program counter address messages get inlined optimized away program counter addresses may map byte code messages get split compiled place 
determine current state program byte code terms program counter address debugger finds latest program counter address mapping equal current program counter selects latest byte code mapped address algorithm returns byte code chambers ungar lee self arg value block 
min self arg iftrue false self true self arg value block self iftrue false self false self arg value block arg debugging information min method 
scope description points calling scope description black arrows block scope points lexically enclosing scope description gray arrows 
slot scope debugging information identifies slot compile time value run time location 
min example initial arguments run time locations registers case slot contents known statically compile time 
started completed program counter address 
execution stack uses mapping information find bottommost virtual stack frame physical stack frame display call stack program halted 
implemented facilities debugger current debugger displays virtual execution stack immediately continues execution primitive called 
mapping system designed support computing setting breakpoints anticipation process control primitives 
set breakpoint particular source level byte code debugger find program counter addresses associated byte code set breakpoints 
cases byte codes map program counter address single stepping byte code wouldn cause instructions executed debugger pretend execute instructions preserve illusion byte coded execution 
efficient implementation self performance comparison self implemented lines code lines assembler runs sun machine sun machine 
written lines self code including hierarchy collection objects recursive descent parser self prototype graphical user interface 
compare performance generation self implementation fast smalltalk implementation standard sun optimizing compiler sun workstation 
fastest smalltalk system currently available excluding graphics performance parcplace smalltalk virtual machine rated system includes deutsch schiffman techniques described earlier 
compare smalltalk self stanford integer benchmarks richards operating system simulation benchmark small benchmarks adapted smalltalk systems sumto 
sumto arg total arg index total total index 
total 
recurse 
recurse iffalse recurse 
recurse 
rewrote stanford integer benchmarks selfish programming style argument function receiver corresponding self method 
measurements rewritten benchmarks columns labeled self oo times parentheses mark benchmarks rewritten 
table presents actual running times benchmarks specified platform 
times milliseconds cpu time smalltalk times milliseconds real time real time measurements self system compiled program practically identical cpu time numbers comparisons measured performance parcplace smalltalk system systems valid 
originally published performance numbers improved significantly factor 
see 
dorado measure performance smalltalk implementations 
dorado defined performance early smalltalk implementation microcode ns xerox dorado fastest available smalltalk implementation 
chambers ungar lee raw running times smalltalk self self oo real ms cpu ms cpu ms cpu ms perm towers queens puzzle quick bubble tree richards entries table ratios running times benchmarks pair systems 
point view bigger numbers better columns smaller numbers better columns 
meaningful rows table probably rows median stanford integer benchmarks row richards benchmark 
relative performance self smalltalk smalltalk smalltalk self self oo self self oo perm towers queens puzzle quick bubble tree min median max richards self implementation outperforms smalltalk implementation benchmark cases self runs twice fast smalltalk 
surprisingly optimizing compiler better self compiler 
efficient implementation self difference performance results significantly poorer implementation self compiler standard compiler techniques register allocation peephole optimization 
difference may attributed robust semantics primitive operations self arithmetic operations check overflow array accesses check indices bounds method calls check stack overflow 
rest difference probably caused lack type information especially arguments assignable data slots 
deficiencies large extent second generation self system described section 
previous tables show performance object oriented systems improving dramatically 
new metric comparing performance systems propose millions messages second measure analogous millions instructions second mips measure processors 
number measures performance object oriented system executing messages 
compute rating system specific benchmark particular hardware platform divide number messages benchmark sends total running time 
define message sends invocations semantics include dispatch self includes slots receiver instance variable accesses invoke method excludes slots local method invocation local variable accesses access data 
computed rating generation self system richards benchmark sparc sun message executed ns 
efficiency object oriented system inversely proportional number instructions executed message sent 
cycle time sun ns giving self system cost message cycles 
sparc clocked cycles instruction accounting cache misses multicycle instructions give self system efficiency rating instructions message sent 
aware implementations dynamically typed object oriented languages approach level efficiency 
researchers attempted speed smalltalk systems adding type declarations smalltalk programs 
atkinson hurricane compiler compiles subset smalltalk annotated type declarations 
reports performance improvement factor hurricane compiler deutsch schiffman system sun initial self system achieves performance improvement deutsch schiffman system type declarations 
johnson ts typed smalltalk system type checks compiles smalltalk programs fully annotated type declarations 
reports performance improvement factor tektronix smalltalk interpreter tektronix 
bench chambers ungar lee mark identical benchmark reports execution time ms executed ms machine times faster machine 
system performance roughly comparable system performance system relies type declarations 
results suggest compilation techniques job extracting type information available systems programmer supplied type declarations 
self reached final state 
established feasibility rewards implementation techniques described remains 
second generation self system process reimplementing entire self system clean code simplify design include better compilation algorithms 
writing july completely rewritten object storage system unified run time compile time message lookup system 
implemented core second generation compiler compiles executes half self code 
new compiler performs type flow analysis determine types local slots compile time 
includes significantly powerful message splitting system 
initial message splitter described splits message type result previous message second generation message splitting system type information constructed type flow analysis especially types local slots 
message splitter may elect split messages message immediately merge point splitting messages intervene merge lost type information message needs type information 
goal combined type analyzer extended message splitter allow compiler split entire sections control flow graph especially loop bodies manipulate common data types 
sections types variables known compile time leading maximally inlined code run time type checks sections type information available compiler full message sends generated 
normal conditions optimized code executed method run fast possibly just fast program 
exceptional situations overflow occurs flow control transfer optimized section method preserves message passing semantics 
efficient implementation self second generation compiler performs data flow analysis common subexpression elimination code motion global register allocation instruction scheduling 
hope addition optimizations allow new self compiler compete high quality production optimizing compilers 
open issues method arguments largest sources unknown type information current compiler 
want extend second generation system customize methods types arguments addition receiver type 
extension provide compiler static type information arguments generate faster code 
benefits balanced costs verifying types arguments prologue method runtime 
compile time lookup strategy works nicely long parents get searched constant parents assignable compile time lookup fails message inlined 
second generation system provides limited support dynamically inherited methods adding types assignable parents traversed run time lookup customization information method method prologue tests values assignable parents addition type receiver 
plan investigate techniques optimize dynamically inherited methods 
message inliner needs better decisions inline method 
inliner information call site loop failure block help decide inline send wasting extra compile time compiled code space 
better job deciding method short inline reasonably counting byte codes fixed cut value algorithm 
implementation type prediction hard wires message names predicted type dynamic implementation dynamic profile information analysis self inheritance hierarchy produce better adapting results 
current implementation compiler speedy traditional batch optimizing compiler standards fast interactive programming environment 
compiler takes seconds compile optimize stanford integer benchmarks lines self code seconds compile optimize richards benchmark lines self code 
plan experiment strategies compiler executes quickly little optimization user waiting compiler queuing background jobs recompile unoptimized methods full optimization 
remains making sure techniques practical larger systems tested 
fully understand contributions need chambers ungar lee analyze relative performance gains associated space time costs techniques 
analysis performed part author forthcoming dissertation 
researchers attempted boost performance dynamically typed object oriented languages 
designers smalltalk hard wired definitions user level arithmetic control methods compiler preventing users changing overriding 
researchers added type declarations smalltalk hindering reuse modification code 
devised dynamic customized compilation static type prediction type flow analysis message splitting message inlining automatically extract preserve static type information 
measurements suggest system runs just fast smalltalk systems type declarations twice fast hard wired methods 
researchers seeking improve performance improve compilers compromising languages 
self novel features cost user execution time storage space 
virtual machine supports prototype object model just space similar class systems maps act implementation level classes reclaim efficiency classes implementation class semantics self user 
self messages access variables absolutely effect final performance self programs message sends get inlined away 
implementation reaches level sophistication performance information provided classes explicit variables redundant unnecessary 
languages run just fast class languages 
implementation introduces new techniques support programming environment 
segregation object byte arrays speeds scavenging scanning operations 
dependency lists reduce response time programming changes 
detailed debugging information maps execution state user source level execution model transparently undoing effects method inlining optimizations 
techniques restricted self apply dynamically typed object oriented languages smalltalk flavors clos 
techniques applied statically typed object oriented languages trellis owl 
example customization automatic inlining eliminate virtual function calls encouraging broader object oriented features programming styles reducing cost 
debugging information debugger hide inlining user just compiler generates debugging information reconstruct self virtual call stack 
efficient implementation self self practical implementation self twice fast dynamically typed purely object oriented language documented literature 
self compiler achieves level efficiency combining traditional optimizing compiler technology procedure inlining global register allocation specialized techniques developed high speed smalltalk systems dynamic translation inline caching new techniques customization message splitting type prediction bridge gap 
synergy old new results performance 
acknowledgments owe randy smith original designers self 
peter deutsch instructive discussions seminal ideas design implementation self 
bay wei chang implemented graphical self object browser contributed discussions self language implementation 

atkinson hurricane optimizing compiler smalltalk 
oop sla conference proceedings 
published sigplan notices 

ballard maier wirfs brock smalltalk dialect defining primitive methods 
oopsla conference proceedings 
published sigplan notices 

bobrow demichiel gabriel keene kiczales moon common lisp object system specification 
published sigplan notices 

borning classes versus prototypes object oriented languages 
proceedings acm ieee fall joint computer conference 

borning ingalls type declaration inference system smalltalk 
conference record ninth annual symposium foundations computer science 

chambers ungar customization optimizing compiler technology self dynamically typed object oriented programming language 
proceedings sigplan conference programming language design implementation 
published sigplan notices 
chambers ungar lee 
chambers ungar iterative type analysis extended message splitting optimizing dynamically typed object oriented programs 
proceedings acm sigplan conference programming language design implementation 
published sigplan notices 
lisp symbolic computation 

curtis type inferencing smalltalk 
personal communication 

deutsch dorado smalltalk implementation hardware architecture impact software architecture 
krasner editor smalltalk bits history words advice addison wesley reading ma 

deutsch richards benchmark 
personal communication 

deutsch schiffman efficient implementation smalltalk system 
proceedings th annual acm symposium principles programming languages 

goldberg robson smalltalk language implementation 
addison wesley reading ma 

hennessy stanford integer benchmarks 
personal communication 

johnson graver ts optimizing compiler smalltalk 
oopsla conference proceedings 
published sigplan notices 

lalonde thomas pugh exemplar smalltalk 
oopsla conference proceedings 
published sigplan notices 

lee object storage inheritance self prototype object oriented programming language 
engineer thesis stanford university 

lieberman prototypical objects implement shared behavior object oriented systems 
oopsla conference proceedings 
published sigplan notices 

mccall smalltalk benchmarks 
krasner editor smalltalk bits history words advice addison wesley reading ma 

meyer genericity versus inheritance 
oopsla conference proceedings 
published sigplan notices 

moon object oriented programming flavors 
oopsla conference proceedings 
published sigplan notices 
efficient implementation self 
agrawal jackson cmos gate array implementation sparc architecture 
compcon conference proceedings 

parcplace systems 
parcplace newsletter winter 

schaffert cooper kilian trellis owl 
oopsla conference proceedings 
published sigplan notices 

steele jr lambda ultimate declarative 
ai memo mit artificial intelligence laboratory 

steele jr sussman lambda ultimate imperative 
ai memo mit artificial intelligence laboratory 

stein delegation inheritance 
oopsla conference proceedings 
published sigplan notices 

stroustrup programming language 
addison wesley reading ma 

suzuki inferring types smalltalk 
th annual acm symposium principles programming languages 

ungar design evaluation high performance smalltalk system 
ph thesis university california berkeley 
published mit press cambridge ma 

ungar jackson policies generation storage reclamation 
oopsla conference proceedings 
published lan notices 

ungar smith self power simplicity 
oopsla conference proceedings 
published sigplan notices 
lisp symbolic computation 

wegner dimensions object language design 
oopsla conference proceedings 
published sigplan notices 
