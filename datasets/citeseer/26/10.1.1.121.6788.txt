founded semantics general logic programs lambda allen van gelder univ calif santa cruz kenneth ross stanford univ john schlipf univ cincinnati april appeared journal association computing machinery volume number pp 

general logic program abbreviated program set rules positive negative subgoals 
common view deductive database general logic program consisting rules idb sitting elementary relations edb facts 
desirable associate herbrand model program think model meaning program declarative semantics 
ideally queries directed program answered accordance model 
research indicates programs satisfactory total model programs question appropriate partial model arises 
introduce unfounded sets founded partial models define founded semantics program founded partial model 
founded partial model fact total model call founded model 
show class programs possessing total founded model properly includes previously studied classes stratified locally stratified programs 
compare method proposals literature including clark program completion fitting kunen valued interpretations stable models gelfond lifschitz 
categories subject descriptors programming languages formal definitions theory semantics mathematical logic formal languages mathematical logic logic programming model theory artificial intelligence deduction theorem proving logic programming nonmonotonic reasoning belief revision general terms languages theory additional key words phrases negation failure founded models fixpoints unfounded sets stable models valued logic lambda preliminary version seventh acm symposium principles database systems addresses kenneth ross computer science dept stanford university stanford ca john schlipf computer science dept university cincinnati cincinnati oh allen van gelder computer science center university california santa cruz ca 

extending horn rule logic programs include negative subgoals giving called general logic programs 
research proceeded general directions may summarized program completion approach canonical model approach 

program completion semantics original program completion approach due clark discussed detail shepherdson kunen lloyd define new program called completed program called completed database 
completed program treated simply order formula see section 
negative literals logical consequences completed program considered true 
applies positive literals completion treats positive negative literals symmetrically 
proof method supports approach called sldnf sld resolution plus negation failure rule studied extensively 
closely related idea closed world assumption introduced context deductive databases reiter 
generalized closed world assumption proposed minker handle disjunctive databases producing inconsistency typical closed world assumption discussed example 
sldnf applied original program 
clark showed procedure sound sense goal finite sldnf derivation logical consequence completed program 
jaffar lassez lloyd showed sldnf complete sense horn programs non floundering queries consisting conjunction positive negative literals 
sldnf investigated general logic programs lloyd coined term sldnf shepherdson bibliography 
approach logically address issue compiler interpreter general logic program treat atoms goals positive negative literals logical consequences completion interpreter allowed succeed fail 
programs completed program inconsistent completed program consistent unintuitive 
importantly natural examples yields surprisingly weak reasoning ability 
shall illustrate claims examples section 
fitting kunen gave markedly different uniform semantics interpreting completed program valued constructive logic elegantly eliminating difficulties clark program completion approach 
third truth value connotes unknown truth value information true false incomparable 
fitting showed completion program unique minimum valued model suggested model taken semantics program 
kunen describes variant recursively enumerable characterizes valued logical consequences completed program 
point view semantics weak capture common sense notion negation failure discussed motivating examples section 
different approach negation interpret general rules disjunctive clauses 
context generalized closed world assumption concludes false minimal positive disjunction delta delta delta qk valued logical consequence clauses 
may zero simply true 
disjunctive databases quite different logic programs clauses direction 
treated alike example illustrates distinction 

canonical model semantics canonical model preferred model approach declare certain model original program presumed intended programmer program users mind 
justification choosing preferred model relies appeal common sense people write read program think means 
topor sonenberg proposed term canonical model describe model selected incomparable minimal models represent meaning logic program deductive database 
advantage assigning canonical model program standard correctness interpreter goals conform canonical model succeed fail appropriately 
see discussion canonical model approach benefit application development 
motivation concentrating canonical models view expounded reiter logic programs appropriately thought having components intensional database idb represents reasoning component extensional database edb represents collection facts 
course time may want apply idb quite different 
context properties idb merit careful study sense think idb implicitly defining transformation edb set derived facts set derived facts canonical model 
finite cases computational complexity transformation studied see section 
problem canonical model approach programs may canonical model unclear model matches users expectations 
difficulty canonical model may computationally infeasible 
line research look definition canonical model apply broad class programs possible 
classes programs studied called stratified locally stratified stratified class treated 
locally stratified class defined studied przymusinski superset class stratified programs 
defined perfect models showed locally stratified program unique perfect model 
classes discussed section 
feeling programs locally stratified probably really sense inherently ambiguous faulty 
failure perfect model thought indicate flaw program definition perfect models 
experience cast doubt attitude see discussion spurred search improvements definition canonical model :10.1.1.24.6050
gelfond lifschitz propose elegant definition stable model closely related 
drawing ideas define stable model able reproduce certain sense program may zero stable models 
scheme program unique stable model considered canonical model 
argue unique stable model natural associate logic program describe properties 
stable models discussed section 

founded semantics proposes new definition canonical model call founded model 
show locally stratified programs perfect model coincides founded model addition interpreter mean mechanism executing program including compiler 
certain programs locally stratified founded model 
examples section 
program founded total model founded partial model define founded semantics general logic program literals founded partial model true complements false literals truth values determined program 
partial model viewed model valued logic 
relationship discussed section 
stratification syntactic property idb idb program total founded model depends general edb 
view founded semantics attempt give reasonable meaning program possible unfavorable cases partial model exists extension semantics favorable cases total model 
key idea formulation concept unfounded set adaptation closed set developed disjunctive databases ross topor essentially set 
unfounded sets defined section 
preliminary version conference alternative formulations negation appear equivalent founded semantics developed 
believe indicates robustness semantics provides evidence coincides common sense intuition 

general logic programs partial interpretations section introduce notation basic definitions describe class general logic programs shall considering 
definition 
general logic program finite set general rules may positive negative subgoals 
general rule written head left subgoals body right symbol may read 
example rule head positive subgoal negative subgoal 
rule may read 
horn rule negative subgoals horn logic program horn rules 
lloyd adopted word normal general describe rules bodies consist conjunction literals programs rules 
reserves word general allow involved constructs applies conjunction atom 
avoid constructs simplicity presentation founded semantics easily generalized syntax continue word general 
keeping prolog convention logical variables capital letter constants functions predicates lowercase letter 
symbol refer predicate relation 
arguments predicate terms customarily defined logic 
variable constant term 

function symbol terms arguments term 
terms may viewed data structures program function symbols serving record names 
word ground synonym variable free keeping common practice 
constant treated function symbol arity zero 
herbrand universe set ground terms function symbols constants appear program herbrand base set atomic formulas formed predicate symbols program arguments herbrand universe 
program contains function symbol positive arity herbrand universe herbrand base countably infinite finite 
shall considering atoms herbrand base ground rules variables instantiated elements herbrand universe call instantiated rules 
definition 
herbrand instantiation general logic program set rules obtained substituting terms herbrand universe variables possible way 
instantiated rule herbrand instantiation 
uninstantiated logic programs assumed finite set rules instantiated logic programs may infinite 
certain programs exhibit property called unsafe negation cause anomalous behavior interpreted herbrand universe 
appendix explains way augment programs introducing extra rule removes anomalies enlarging herbrand universe 
development independent augmentation 
shall working extensively sets literals introduce notation definitions 
atomic formula atom positive literal negative literal literals said complements 
definition 
set literals denote set formed complement literal delta ffl say literal inconsistent delta ffl sets literals inconsistent literal inconsistent delta ffl set literals inconsistent inconsistent consistent 
constant symbol program added arbitrarily 
definition 
program partial interpretation consistent set literals atoms herbrand base total interpretation partial interpretation contains atom herbrand base negation 
say ground variable free literal true say false complement similarly say conjunction ground literals true literals true false literals false definition 
say instantiated rule satisfied partial total interpretation head true subgoal false falsified head false subgoals true 
addition head rule false subgoal false say rule weakly falsified definition 
total model program total interpretation instantiated rule satisfied 
partial model partial interpretation extended total model customary omit adjective total speaking interpretations models shall dealing valued valued logics shall include clarity 
intuitively partial interpretation may contain incomplete information positive literals considered true atomic facts negative literals denote atoms considered false truth values rest atomic facts unknown unspecified 
natural ordering partial interpretations 
idea contains information positive negative plus possibly 
partial model partial interpretation instantiated rules may satisfied possibly empty set literals addition partial interpretation satisfy rules 
clearly impossible falsifies instantiated rule 
weakly falsifies instantiated rule addition negative literal may necessary satisfy rule 
recognition partial models containing weakly falsified rules may difficult 
lemma shows situation simpler weakly falsify instantiated rule 
lemma 
program partial interpretation 
weakly falsifies instantiated rule partial model proof 
total interpretation formed adding atoms herbrand base true false instantiated rule satisfies clearly 
satisfy head false true 
total model 
notion partial model natural notions models valued logics approaches fitting kunen 
founded partial model construct model fitting valued sense 
shall discuss valued models section 

unfounded sets founded partial models section define unfounded sets variation closed sets defined disjunctive databases ross topor 
unfounded sets provide basis negative founded semantics 

unfounded sets definition 
program associated herbrand base partial interpretation 
say unfounded set respect atom satisfies condition instantiated rule head holds 
positive negative subgoal body false 
positive subgoal body occurs literal true called witness rule respect 
intuitively regard know intended model possibly partial 
rules satisfying condition usable derivations hypotheses known false 
condition condition rules usable derive set requires atom true 
words atom established true rules starting knowing 
consequently choose infer atoms false way infer true 
described formally founded semantics uses conditions draw negative 
essentially simultaneously infers atoms false 
contrast semantics uses condition draw negative 
closed sets ross topor defined condition 
example 
consider program consisting instantiated rules 

atoms fp form unfounded set respect 
particular fq unfounded due condition rule usable establish truth 
set fp unfounded due condition way establish establishing establishing establish support rule irrelevant determining 
way establish establishing way establish establishing 
clearly proven see proven 
contrast pair fp form unfounded set depend dependence negation 
tempting claim proof attempts fail claim faulty 
difference sets fp fp declaring false create proof element set true 
soon declared false possible prove true 
declared false inconsistency 
treatment flavor generalized closed world assumption gcwa valued logical consequence program interpreted indefinite disjunctive clauses consequently gcwa declines consider false 
gcwa behaves quite differently general 
example logical consequence gcwa consider false founded semantics 
similar remarks apply 
considered false gcwa positive disjunction disjunction minimal difference classified false founded semantics derivable 
property gcwa atoms considered false support derivations 
simultaneously negating atoms unfounded set generalizes negation failure horn clause programs herbrand base set atoms represents minimum herbrand model horn clause program gamma set atoms unfounded respect formalize intuition preceding discussion 
immediate union arbitrary unfounded sets unfounded set 
leads naturally definition 
greatest unfounded set respect denoted union sets unfounded respect easy instructive observations unfounded sets 
certain extent flexibility having having unfounded set 
lemma shows interpretation deduce certain facts unfounded set add complements unfounded atoms remain unfounded 
lemma 
set literals unfounded set subset gamma unfounded respect delta proof 
witness atom negative literal delta witness 
lemma demonstrates connection lack weak falsification definition unfounded sets 
recall lemma lemma partial model 
lemma 
partial interpretation consisting positive literals negative literals delta weakly falsify instantiated rule program unfounded set respect proof 
instantiated rule head weakly falsified subgoal false subgoal positive condition definition satisfied 
subgoal negative positive version condition satisfied 

founded partial models consider possibly transfinite sequence results combining set transformations 
limit sequence defines founded semantics 
follows word transformation means transformation sets literals atoms herbrand base program recall transformation called monotonic definition 
transformations tp wp defined follows ffl tp instantiated rule head subgoal literal body true ffl greatest unfounded set respect definition 
ffl wp tp delta 
lemma 
tp wp monotonic transformations 
proof 
immediate definitions 
wish emphasize methods tp treats positive negative subgoals symmetrically 
deciding negative subgoal true methods look absence presence absence immaterial truth subgoal require presence definition 
ff range countable ordinals 
sets iff elements literals herbrand base program defined recursively 
limit ordinal ff iff fi ff ifi note limit ordinal 

successor ordinal ff fl ifl wp ifl 
define ff iff moschovakis literal define stage ordinal ff iff 
observe stage successor ordinal literals 
lemma 
iff defined definition monotonic sequence partial interpretations consistent 
proof 
proof induction ff 
basis ff immediate 
ff assume lemma true fi ff 
monotonicity ff fl successor ordinal 
literal ifl smallest fi fl wp ifi fl limit ordinal 
wp monotonic inductive hypothesis wp ifl 
monotonicity limit ff follows definition iff 
show consistency successor ordinal ff fl note literal iff appears ifi successor ordinal stage 
set positive ground literals nonempty intersection positive literals ifl 
sufficient show unfounded ifl greatest unfounded set ifl disjoint positive part ifl 
choose earliest ifi intersects select atom intersection 
derived rule subgoals ifi 
inductive hypothesis subgoals ifl ifl consistent subgoals false ifl 
choice fi rule witness demonstrates unfounded set ifl 
limit ordinal ff show iff partial interpretation assume lemma true fi ff 
iff successor ordinal fl ff true 
contradicts inductive hypothesis 
follows classical results tarski fixed point operator wp herbrand base countable countable ordinal ff iff 
definition 
closure ordinal sequence iff ordinal ff iff cf 

examples constructed closure ordinal authors believe examples rare practical logic programming 
case function free program finite edb common deductive databases limit reached finite ordinal 
data complexity case discussed section 
definition 
founded semantics program meaning represented fixed point wp limit described positive literal denotes atom true negative literal denotes atom false missing atoms truth value assigned semantics 
lemma 
iff defined definition 
iff weakly falsify definition instantiated rule proof 
instantiated rule head iff 
need show body false iff 
definition ifi fi ff 
lemma ifi ifi iff 
body false ifi subgoal body greatest unfounded set ifi 
case ifi body false ifi 
case follows body false iff 
theorem 
countable ordinal ff iff sequence described definition partial model proof 
immediate lemmas 
definition 
suppose herbrand base contains total interpretation 
theorem total model call founded model call founded partial model theorem 
horn program founded model minimum model sense van emden kowalski positive literals contained herbrand model 
proof 
herbrand base set positive literals 
fixed point tp 
view theorem sufficient show gamma 
positive literal gamma rule positive subgoal gamma subgoal witness rule 
gamma unfounded fortiori 

valued models program completion relationship founded semantics methods program completion valued logics discussed section 
clark introduced completed program way formalizing notion facts inferable rules program regarded false 
fitting studied models completed program valued logic showed models fixed points certain operator 
show founded partial model model logic model 
idea clark completion program collect rules having head predicate single rule body disjunction conjunctions replace symbol 
states effect predicate completely defined rules 
formal details including handling variables axioms equality described places 
example 
recall rules example atoms formed unfounded set clark completion combines rules rule combines rules rule replaces 
simplifications eliminate bound variables results 

equality freeness axioms called clark equality theory cet part completed program 
roughly require interpretation terms true setting original logical consequence approach essentially declares logical consequences classical valued sense completed program inferred 
completed program consistent approach implicitly defines valued interpretation assign value true instantiated atoms true valued necessarily herbrand models completed program false instantiated atoms false models 
unknown instantiated atoms 
truth literal traditional valued logic call valued program completion pc interpretation 
valued interpretations explicit fitting kunen valued logic evaluate formulas 
true valued logic valued logic may 
addition produced program completion process interpreted lukasiewicz operator having truth value evaluates true 
fitting kunen treatments eliminated anomalies pc interpretation 
example 
consider single rule program clark completion false valued model 
second rule derives false representing empty disjunction rule bodies 
add meaningless rule completed program changes true unique valued model fp qg 
add meaningless rule completed program changes different valued model qg 
versions valued models 
suggested referee add rules giving completed program valued models vary true 
common part intersection pc interpretation qg 
pc interpretation valued model principal result completion program unique minimum valued herbrand model 
fitting suggests model taken semantics program call fitting model fitting model defined pc interpretation previous example 
example appendix shows pc interpretation defined fitting model 
partial interpretation valued logic corresponds obvious valued interpretation atoms missing assigned truth value 
setting partial interpretations fitting basic sets 
valued logic literals conjunctions true false specified definition addition truth value may assigned definition 
literal called undefined denoted complement conjunction literals evaluates undefined literal conjunction false undefined definition 
np defined transformation valued interpretation gives np set atoms rule herbrand instantiation head body false subgoal rule false note np portion produced condition definition 
fitting constructs valued models fixed point operator 
positive inferences tp definition 
negative inferences uses effect transformation np defined 
second main theorem approach theorem 
fitting valued interpretation valued model completed program tp delta np 
immediately yields fixed point construction valued models fitting model fixed point 
show founded partial model valued model fitting sense 
theorem 
defined definition 
tp delta np 
valued model completion logic program 
proof 
tp delta follows 
tp delta np 
positive literal tp 
remains show negative literal delta np 
lemma instantiated rule head body false np 
corollary 
fitting model subset 
differ smallest valued model completion program need subset valued models shown rule program false undefined fitting model 
kunen describes variant differs fitting important ways iteration stopped herbrand universe defined respect language infinite set function symbols properly includes occur program 
resulting valued interpretation recursively enumerable may valued model 
kunen main theorem interpretation characterizes valued logical consequences completed program 

stable models gelfond introduced approach negation stable models motivated appealing autoepistemic logic developed moore 
theory developed gelfond lifschitz marek truszczynski 
section follow definition defines stability autoepistemic logic 
show program total founded model model unique stable model 
discuss programs total founded models unique stable models 
inferring inferring truth extra literals bug feature approach leave reader judgement 
gelfond lifschitz define stable model reproduces certain stage transformation call stability transformation 
program stable model called unique stable model 
stable models refer valued logic 
speaking total valued interpretations common represent models sets ground atoms understanding missing atoms represent negative literals 
context minimal model minimal set positive literals monotonic transformation total interpretations monotonic terms positive literals 
consistency rest shall represent models sets literals notation sets positive negative atoms interpretations 
definition 
partial interpretation pos set positive literals neg set atoms represent negative literals pos delta neg 
definition 
general logic program herbrand instantiation ph define stability transformation total interpretations total interpretations 
total interpretation transformation defined stages 
define ph transformation rule instantiation contains negative subgoal inconsistent rule instantiation discarded 
output transformation set rule instantiations remain 

define transformation negative subgoals dropped rules leaving horn program 
call reduction respect 
horn program form minimum valued model standard van emden kowalski semantics 
context minimum means set positive literals minimized set negative literals maximized 
define minimum model 
example 
ph fa pg minimal model ph 
consists rules contain negative subgoals atoms pos 
horn rule fa pg incidentally model ph 
name stability transformation justified sense lemma shows shrinking transformation positive literals applied total models 
shown possible model model may shrink 
lemma 
total model general logic program pos pos 
proof 
terminology definition total model construction 
minimum total model 
models fixed points special interest 
definition 
total model general logic program stable fixed point 
program exactly stable model model called unique stable model immediate stable model minimal terms set positive literals minimal model stable shown example example 
example 
fa bg fb ag stable models unique stable model 
fitting model pc interpretation founded partial model 
example 
example model fpg 
rule program drops reduction making pg minimum model reduction 
stable model 
discussed example completed program pc interpretation valued logic inconsistent 
fitting model founded partial model 
close relationship stable models founded partial total models 
defined unique stable model demonstrated explicit enumeration minimal models followed testing stability 
shall show founded total models unique stable models 
offers method generate unique stable model directly programs 
lemmas illustrate close relationship showing total models negative part stability transformation agrees greatest unfounded set positive part contained tp lemma 
total model program neg 
proof 
form horn program definition minimum total model 
show neg 
total suffices show positive literal pos 
prove induction stages van emden consider possibly transfinite iteration direct 
kowalski type construction 
true vacuously stage empty 
stage suppose positive literal derived stage construction 
rule ak ai derived stages rule corresponds rule ak bn bj neg turn corresponds rule ph 
lemma ai pos 
consistent subgoals ai bj false inductive hypothesis ai 
virtue ph rule 
prove neg 
suffices show neg unfounded set ph suppose neg fails satisfy condition defined definition 
rule ak bn ph facts hold 
ai false 
bj true 
ai true neg third fact negation condition 
total follows second fact bj neg 
ak rule 
total follows third fact ai pos 
pos contradiction 
lemma 
total model pos tp 
proof 
form program horn program definition minimum total model 
lemma pos pos pos pos tp pos tp monotonicity tp positive literals 
pos tp pos tp pos tp construction 
preceding lemmas lead theorem fixed point equivalent fixed point wp total models 
fact equivalence extends total interpretations fixed point transformation ensures interpretation model 
shown example possible fixed point fixed point wp fixed point stable model obviously unique 
theorem 
total model stable fixed point wp proof 
form horn program definition minimum total model 
suppose fixed point wp prove stable 
fixed point wp neg 
lemma neg 

suppose stable prove fixed point wp lemma pos pos tp 
tp pos model tp pos 
lemma neg 
corollary 
total interpretation fixed point fixed point wp proof 
routine show fixed point wp instantiated rule satisfied 
model theorem applies 
corollary 
founded total model model unique stable model 
corollary 
founded partial model subset stable model proof 
stable model fixed point wp founded partial model fixed point 
examples show converse corollary necessarily true 
agree gelfond lifschitz model intended associated program able derive 
shown examples sense deriving differs slightly founded semantics stable model semantics 

comparison stable founded approaches compare founded semantics stable model semantics 
programs identical appeared difference founded semantics defined partial model multiple stable models 
turns programs unique stable model partial founded model 
words converse corollary necessarily true 
examples show awkward situations arise founded models unique stable models factoring operation resolution theorem proving law excluded middle natural deduction plays part 
recall factoring ground clause simply operation merging identical literals 
factoring enters picture rule form disjunctive clause rewritten literals merged 
manifestation phenomenon occurs pair rules disjunctive clauses resolved giving literals combined factoring 
valued logical consequences derived factoring derived founded semantics valued program completion approaches cf 
examples 
example 
consider program rules consider consisting just rules cf 
example 
rules comprise example stable models third example stable model 
rules minimal models stable fa pg pg program completion inconsistent 
just turn 
surprisingly founded partial model fitting model empty 
adding fourth rule appear meaningless glance valued logical consequence rules apparent basis conclude anyway 
fourth rule strange effect stabilizes precisely models produces unique stable model full program 
program completion full valued model 
founded partial model fitting model remain empty unique stable model fa pg verify note reduction respect model pc model 
example 
consider program rules fitting model founded partial model unique stable model exists agrees pc model fa cg verify note reduction respect simply 
stratified locally stratified programs program stratified predicates assigned rank ffl predicate depends positively greater rank ffl predicate depends negatively equal greater rank rule 
context idb edb edb set simple facts rank 
idb predicates defining rules involve negation rank 
idb predicates negative dependencies rank predicates rank 
easy check syntactically fact checked examination idb 
stratified semantics program defined drawing rank inferences normal way horn programs concluding rank atoms inferred 
note usual negation failure atoms may failed finitely cf 
example 
definition stratified semantics completed inductively atoms ranks classified positive negative literals derive positive rank atoms conclude rank atoms inferred 
result called stratified model 
immediate theorem stratified semantics agrees founded semantics rank easy see agreement extends ranks 
shall prove somewhat stronger result 
point view van gelder shown stratified programs satisfy certain conditions model tight derivations coincides stratified model 
przymusinski carried idea finer grain defining program locally stratified atom herbrand base assigned countable ordinal rank atom depends atom greater rank depends negatively equal greater rank instantiated rule 
note program stratified atoms predicate symbol assigned rank 
extension handles situations recursive negation apparent real 
typical example program ground atom rank equal power argument 
give semantics locally stratified programs przymusinski definition perfect model essentially perfect model ranking atoms models positive literal atom rank model 
words perfect model minimizes positive literals low rank preference positive literals greater rank 
przymusinski shown locally stratified programs perfect model independent ranking system chosen constraints mentioned stratified programs perfect model agrees stratified model 
show founded semantics extension approach sense 
theorem 
locally stratified founded model identical perfect model 
proof 
take inductive hypothesis atom rank perfect model founded partial model perfect model 
basis immediate 
assume perfect model 
claim instantiated rule head say qi perfect model rj perfect model 
remove supposedly perfect model worst add atoms greater rank rule containing restore model 
rj lower rank inductive hypothesis asserts rj 
qi lower rank 
consider program consisting instantiated rules atoms rank subgoals lower rank true 
modify rules removing subgoals rank leaving horn program cf 
definition 
clearly minimum model precisely atoms rank perfect model 
atoms 
atoms rank minimum model form unfounded set respect theorem 
follows construction atoms form unfounded set respect negations 

motivating examples particular model right really depends people expectations 
programs tools behavior needs understood manageable people 
section compare founded semantics approaches canonical models stable model semantics outlined section stratified semantics studied researchers 
examples support position founded models natural intuitive 
example 
example abstracted yale example due hanks mcdermott 
program noise loaded shoots loaded 
loaded succ loaded shoots shoots triggers triggers 
succ 
regard triggers succ edb predicates idb 
herbrand instantiation contains ground versions idb rules follows noise loaded shoots noise loaded shoots loaded succ loaded shoots loaded succ loaded shoots loaded succ loaded shoots loaded succ loaded shoots shoots triggers shoots triggers intuitively information shoots holds led presumably intended minimal model loaded shoots noise loaded shoots noise alternate minimal model exists loaded shoots noise loaded shoots noise noise true minimal models circumscription approach allow concluded main point 
founded model intended 
compare approaches pc model fitting model intended model 
program stratified stratified semantics agrees founded semantics 
intended model unique stable model alternate stable 
preceding example pc fitting models valued gave intended model 
example situation consider pc fitting models weak approach 
example 
consider program rules facts apparently transitive closure transitive closure expect difference relations particular true 
appears intended model founded model stratified model 
minimal model true false 
alternate model satisfies clark completion program 
method logical consequences completion program status literals addressed pc interpretation declared undefined fitting model kunen model 
criterion stability reinforces choice founded model 
alternate model incapable reproducing manner defined definition intended model emerges unique stable model 
fact kunen shown valued logical consequence semantics strict logic program function symbols define predicate true transitive closure false complement undefined 
informally strict program dependence predicate number negations odd number 
kunen semantics different fitting programs function symbols see example appendix question strict program possible fitting semantics open 
nonstrict programs fitting semantics known exist quite complicated details discussed van gelder 
motivational example consider program locally stratified defined section founded model edb relation acyclic 
involved example constraints edb specified guarantee founded model total discussed 
example 
example essentially discussed gelfond lifschitz examples led formulation founded semantics stable models 
program turns closely related game described kolaitis prove queries fixpoint logic expressible stratified programs 
respect program viewed describing game wins opponent moves checkers 
winning move winning sample move graphs shown fig 

move edb relation acyclic part founded total model easily proceeding directed graph 
part shows cyclic case founded model partial cycle edb may founded total model part 
program fitting model pc interpretation agree founded model 
program locally stratified herbrand instantiation contains rule winning depends negatively winning move winning zz zz zz ae gamma gamma gamma gamma gamma psi gamma gamma gamma gamma gamma psi ss ss sw xi pi upsilon sigma oe xi pi upsilon sigma oe graphs example acyclic cyclic partial model cyclic total model 
entries nodes indicate winning true false undefined founded partial model 
destroys perfect model move occur edb przymusinska defined weakly perfect models handle programs example 
example inspired informal presentation morris stanford university 
shows negation issues addressed easily arise practical settings 
example 
imagine logic program part vlsi cad system function display vlsi chip hierarchically defined 
object modeled series layers layer array grid points 
hierarchical definition specifies basic synthesized objects basic objects distinguished having base colors colors synthesized objects defined wholly terms components vary point point 
entire chip root object 
shows example root object synthesized objects details shown 
assume program uses predicates may treated edb relations purposes 
ffl pt true pt dimensional vectors details representation concern 
trivial case program herbrand model 
dd vlsi objects example object synthesized level level 
color object inherited point represented lower dot hold upper dot dominated 
ffl component obj true object obj component origin point layer number example chip identical alus different points various values 
alus adders components adders smaller components 
obj components overlap layer number specifies relative vertical order 
ffl obj pt means color basic object obj point pt 
specify color property rule syntax require mutually recursive idb relations 
interested reader equivalent rules single relation language supports richer syntax rule bodies 
ffl color obj pt means visible color obj pt looking 
ffl dominated obj pt holds objects components obj overlap point pt object lower layer 
object higher layer overlap color defined point 
formulate rules determining color component obj grid point pt 
color obj pt obj pt color obj pt component obj pt color dominated obj pt dominated obj pt component obj pt color note color depends negatively rule dominated positively 
rule designer expects component relation acyclic second arguments expected subcomponent obj expected acyclicity holds founded model easily just working data structure 
case fitting model valued pc model 
perfect model essentially reason example 
cycle edb color established cycle 
application cycle presumably represents design error 
founded semantics defines color correctly parts chip affected error 
theme runs examples founded semantics frequently agrees semantics avoid awkward cases 
sense quite robust 

computational complexity want formulate reasonable semantics negation want set statements derivable reasonably computable far possible 
unfortunately founded partial model necessarily recursively enumerable difficulty shares semantics discussed 
function free logic programs class come known datalog herbrand universe finite construction effective 
section show data complexity founded semantics defined vardi polynomial 
standpoint competitive methods stratified semantics data complexity studied fitting model remarked 
discussion complexity restrict attention function free programs program herbrand universe just set constants appearing 
consider fixed idb pi allow general function free logic program 
discussed pi thought set inference rules applied various edb sets facts 
predicates appear subgoals pi appear head rule constitute edb predicates 
represent edb pe set positive ground literals ranging edb predicates 
constants pe may may appear pi edb pe form logic program pe pi pe denote founded partial model pe 
regard pi defining transformation pe pe 
definition 
data complexity idb defined computational complexity deciding answer ground atomic query function size edb context founded semantics means deciding ground atom positive founded partial model 
idb fixed predicates founded model fixed number arity width number argument places 
herbrand base size polynomial size edb 
function symbols may add constants appearing query herbrand universe having significant effect size 
idb fixed size herbrand instantiation program polynomial size edb 
theorem 
data complexity founded semantics function free programs polynomial time 
proof 
usual proofs theorems shall show entire founded partial model constructed polynomial time query answered immediately 
wellfounded model fixed point construction iff described definition 
stage induction fixed point reached element herbrand base added iff fixed point reached number steps polynomial size edb 
sort argument standard see similar standard arguments show calculating tp done polynomial time 
need show iff polynomial time 
clearly may restrict attention finite ff 
shall give polynomial time construction set ground atoms gamma iff 
define oe transformation sets ground atoms implicit parameter iff ground atom oe ground instance rule say bn cm ffl subgoal bi cj false iff ffl bi jfl 
clearly oe monotonic jfl reaches limit fl polynomial jhj 
suppose oe jfl due rule shown 
rule shows iff bi set 
trivial induction fl atom fl jfl iff 
show set ground atoms gamma unfounded iff atom 
rule head subgoal violates condition put oe jfl fl 
violation subgoal false iff satisfies condition unfounded set definition violation positive subgoal jfl fl subgoal gamma satisfying condition unfounded set 
follows gamma iff 
key idea proof inductively construct complement greatest unfounded set suggested authors vardi discovered independently schlipf 
fitting model polynomial data complexity function free programs 
proof identical theorem polynomial calculation np see def 
exhibited calculation routine 
contrast marek truszczynski shown propositional general logic programs determining stable model np complete 

final frontier 
major shortcoming founded semantics concerns inability handle reached factoring similar technique ancestor resolution 
techniques known necessary completeness non horn proof systems sets horn clauses 
need factoring arises principally proof cases proof contradiction 
factoring possibilities program carry completed program simplify true valued logic intuitionistic logic 
caution needed keep coherent system 
overly trivial example lead believe factoring capability easily patched just checking negative subgoal complements head rule incorrect shown choose reasonably expected notice hold valued logic 
general recognizing valued logical consequence finite set instantiated rules np complete 
furthermore normally start rules contain variables 
extension logic program semantics depends true non horn reasoning needs undertaken great caution represents significant open problem 

new semantics founded semantics general logic programs extends earlier proposals advantages 
applicable programs 

compared methods larger portion herbrand base tends classified true false 

truth values assigned authors judgement reasonably predictable intuitively satisfying way 
expressive power founded semantics compared forms fixpoint logic 
corresponding procedural semantics reported classes programs 
wish jerzy kolaitis vladimir lifschitz marek rodney topor moshe vardi helpful discussions comments 
anonymous referees careful readings manuscript useful suggestions 
kenneth ross supported part nsf iri ibm afosr contract 
john schlipf supported part nsf iri iri 
allen van gelder supported part nsf ccr iri 
appendix augmented programs certain programs exhibit undesirable behavior interpreted herbrand universe due containing called unsafe negation 
simple way remove behavior augment program described appendix 
proceed informally refer formal discussion 
definition 
general logic program associated augmented program formed adding apparently nonsensical rule symbols occur program 
having extra terms augmented herbrand universe adds infinitely elements herbrand universe elements names original program 
ensures goals free variables room fail instantiated versions 
augmenting achieves effect similar kunen embedding program language infinitely function constant symbols 
example 
program inspecting relation expect hold 
read differs 
underlying idea looking rule expect formula false 
herbrand universe element room fail term 
result fails 
adding apparently unrelated fact program means fail setting 
turn provides true instance allowing proof 
augmenting program avoids bizarre behavior fails cases making provable intuition expects 
see program unsafe negation consider top sequence goal reductions 
rules reduces reduces true reduces 
occurrence free variable negative subgoal called unsafe limited domain 
derivation said floundered 
note program false founded semantics fitting semantics pc semantics kunen semantics 
false valued herbrand model completed program valued models true 
semantics agree true augmented program 
noted herbrand universe augmented program infinite 
result proof polynomial data complexity theorem fails augmented program 
result true augmented programs need modify proof slightly 
extra ground terms respect predicates original language carry construction fixed finite number dependent idb extra ground terms 
essentially need distinct terms variables single rule 
apt blair walker 
theory declarative knowledge 
minker editor foundations deductive databases logic programming pages 
morgan kaufmann los altos ca 
apt van emden 
contributions theory logic programming 
jacm 
bry 
logic programming formalization application databases 
eighth acm symposium principles database systems pages 
ashok chandra david harel 
structure complexity relational queries 
jcss 
chandra harel 
horn clause queries generalizations 
journal logic programming 
clark 
negation failure 
gallaire minker editors logic databases pages 
plenum press new york 
dummett 
elements intuitionism 
clarendon press oxford 
ph 
dung 
natural semantics logic programs negation 
technical report asian institute technology thailand 
manuscript 
fitting 
kripke kleene semantics logic programs 
journal logic programming 
gelfond 
stratified autoepistemic theories 
proc 
aaai 
gelfond lifschitz 
stable model semantics logic programming 
fifth int conf 
symp 
logic programming pages seattle 
gurevich shelah 
fixed point extensions order logic 
annals pure applied logic 
hanks mcdermott 
default reasoning nonmonotonic logics frame problem 
aaai conference pages 
immerman 
relational queries computable polynomial time 
information control 
jaffar 
lassez lloyd 
completeness negation failure rule 
int joint conf 
artificial intelligence pages 
kolaitis 
expressive power stratified programs 
information computation 
kunen 
negation logic programming 
journal logic programming 
kunen 
remarks completed database 
technical report univ wisconsin madison wi 
appeared th int conf 
symp 
logic programming seattle aug 
lifschitz 
declarative semantics logic programs negation 
minker editor foundations deductive databases logic programming pages 
morgan kaufmann los altos ca 
lloyd 
foundations logic programming 
springer verlag new york nd edition 
lloyd topor 
making prolog expressive 
journal logic programming 
maher 
equivalences logic programs 
minker editor foundations deductive databases logic programming pages 
morgan kaufmann los altos ca 
marek 
stable theories autoepistemic logic 
technical report university kentucky 
manuscript 
marek truszczynski 
autoepistemic logic 
technical report university kentucky 
manuscript 
minker 
indefinite databases closed world assumption 
sixth conference automated deduction pages new york 
springer verlag 
moore 
semantical considerations non monotonic logic 
artificial intelligence 
morris 
talk workshop xp oregon graduate center july 
morris ullman van gelder 
design overview nail 
system 
third int conf 
logic programming pages 
moschovakis 
elementary induction structures 
north holland new york 
przymusinska przymusinski 
weakly perfect model semantics logic programs 
fifth int conf 
symp 
logic programming pages seattle 
przymusinski 
declarative semantics deductive databases logic programs 
minker editor foundations deductive databases logic programming pages 
morgan kaufmann los altos ca 
przymusinski 
logic program natural stratification iterated fixed point model 
eighth acm symposium principles database systems pages 
reiter 
closed world databases 
gallaire minker editors logic databases pages 
plenum press new york 
ross 
procedural semantics founded negation logic programs 
eighth acm symposium principles database systems pages 
ross topor 
inferring negative information disjunctive databases 
journal automated reasoning 
schlipf 
negation failure logic programming 
manuscript 
shepherdson 
negation failure ii 
journal logic programming 
shepherdson 
negation logic programming 
minker editor foundations deductive databases logic programming pages 
morgan kaufmann los altos ca 
van emden kowalski 
semantics predicate logic programming language 
jacm 
van gelder 
negation failure tight derivations general logic programs 
journal logic programming 
preliminary versions appeared third ieee symp 
logic programming foundations deductive databases logic programming minker ed morgan kaufmann 
van gelder 
modeling simultaneous events default reasoning tight derivations 
journal logic programming 
van gelder 
alternating fixpoint logic programs negation 
journal computer system sciences 
appear 
available ucsc crl 
preliminary appeared eighth acm symposium principles database systems 
van gelder ross schlipf 
unfounded sets founded semantics general logic programs 
acm symposium principles database systems pages 
moshe vardi 
complexity relational query languages 
th acm symposium theory computing pages 

