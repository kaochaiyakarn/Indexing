ieee transactions knowledge data engineering 
vol 

december prisma db parallel main memory dbms peter apers member ieee care van den berg jan paul grefen martin kersten wilschut full fledged parallel main memory relational database management system design characterized main ideas 
place high performance obtained parallelism query processing main memory storage entire database 
second place flexible architecture experimenting functionality performance obtained modular implementation system object oriented programming language 
describes design implementation detail 
performance evaluation system shows system comparable state art database machines 
prototype implementation system ready runs node parallel multiprocessor 
achieved flexibility system valuable platform research various directions 
index terms parallel main memory relational database man agement system design implementation architecture query execution experimentation integrity constraints 
parallel main memory dbms designed implemented years netherlands scientific commercial research institutions 
fall prisma project started 
goal entire prisma project design realization parallel hardware software implement parallel object oriented programming language pool implementation nontrivial application pool 
dbms chosen application 
prisma db designed implemented pool run node parallel machine pool implemented 
dbms group prisma project wanted study exploit available resources gbytes main memory processing nodes high level parallel programming language 
goal manuscript received march revised august 
apers grefen wilschut university twente ae enschede netherlands 
van den berg kersten center mathematics computer science 
ab amsterdam netherlands 
ieee log number 
main partners project philips research laboratories eindhoven netherlands university twente center mathematics computer science university amsterdam 
ieee design parallel main memory dbms flexible architecture flexible query execution experiments functionality performance system possible 
functionality performance minimum requirements resulting prototype research 
functionality goal implementing relational data base traditional sql interface logical query language called language similar datalog 
furthermore database management system pro vide concurrency control support recovery system failures 
architecture system designed modular way provide opportunities experiment functionality system 
facility currently research area integrity constraint enforcement query optimization 
performance goal understanding influence parallelism main memory performance 
ex obtain performance comparable currently available prototype database machines 
performance obtained parallelism nodes main memory mbytes processor 
study influence parallelism impact main memory character system flexible query execution layer implemented system 
special algorithms exploit main memory character relational algorithms implemented 
facility currently research area parallel query execution 
obviously experimentation central issue project 
cases proper design decisions insufficient insight lack experience 
case system set way various solutions tried final system 
achieved modular architecture flexible allocation mechanism modules processors 
starting point project papers parallel main memory database systems general purpose hardware available 
low costs large main memory system predicted correctly 
main memory costs look gigabyte 
potential benefits problems single prototype implementation shared store developed 
ieee transactions knowledge data engineering 
vol 

december project life cycle increasing number papers appeared address technical issues implementations 
special issue proof evidence 
development related studies influenced recovery issues parallelism large scale comparable disk systems gamma bubba lo hc 
role main memory hold entire database getting support illustrated shared store systems xprs db distributed store system eds 
goals prisma project ambitious 
hard ware system software database management system developed scratch 
period years roughly people worked project directly involved database machine 
halfway project efficiency problems discovered implementation language pool 
half years prototype running node multiprocessor system 
pieces system rewritten obtain better performance 
currently lo join wisconsin benchmark runs research focused topics investigate performance flexibility architecture 
chosen extensively investigate influence main memory parallelism query execution constraint enforcement 
components system concurrency controller shelf solutions chosen case recovery concise study main memory alternatives led implementation parallel algorithm 
main research topics performance evaluation parallel join evaluation main memory environment parallel constraint enforcement 
research revealed main memory character system significant impact parallel behavior specialized main memory algorithms possible profitable performance viewpoint fast read access main memory system allows extensive integrity constraint checks limited performance penalty 
research topic discussed detail 
organized follows 
section briefly introduces node parallel multiprocessor implementation language pool 
section gives overview dbms architecture high lights aspects architecture internal rep resentation queries parallelism data fragmentation transaction management query execution storage recovery 
section iv illustrates dynamic architecture description example query execution 
section describes performance discusses relationship influence parallelism main memory aspects system 
section vi briefly describes current research context prisma db section vi summarizes concludes 

hardware software support prisma db implemented parallel multiprocessor fig 

hardware configuration thc machine called machine 
machine parallel object oriented language pool operating system supports pool implemented 
section summa hardware essential features pool 
machine machine shared parallel mul consists nodes 
describes design rational detail 
fig 
shows hardware configuration 
node consists data processor mbytes memory disk communication processor links nodes bidirectional links 
processor memory consists mbytes board memory memory extension board containing mbytes 
slower memory extension boards results mips processors run mips practice 
nodes ethernet card links system unix host 
nodes linked communication processors developed philips 
various configurations realized 
fig 
shows mesh connection configurations ring connection double linked ring connection possible 
entire system contains gbytes memory 
pool parallel object oriented language programming language pool im plemented machine imple mentation language 
object oriented language pool allows defini tion objects functional units data methods operate data 
pool process objects data objects discriminated 
process objects individual thread control data objects process objects data structures 
discrimination process objects data objects efficiency reasons 
parallelism supplied natural way process objects exist system execute concurrently 
allocation process objects different apers rt db processors really run parallel 
objects created deleted dynamically 
features turn pool program execution flexible structure allows runtime experimentation various forms parallelism 
objects communicate synchronously 
synchronous message object causes sender wait reply 
asynchronous message reply 
synchronous communication objects synchronizes execution may impede effective parallelism 
asynchronous communication drawback 
communication objects allocated different processors automatically translated interprocessor message passing 
pool special facilities implementation dbms tuple types created dynamically 
conditions tuples compiled routines 
feature speed scan operations condition evaluated large number tuples selections joins 
noted language pool developed implemented parallel design implementation prisma db 
consequences development prisma db 
halfway project severe performance problems pool implementation 
consequence evaluate performance try prototype 
pool compiler currently optimized detail 
results performance quite optimal 

architecture section presents software architecture prisma database management system 
overview global architecture 
important aspects architecture discussed detail internal relational language extended relational algebra xra query optimization parallelism query execution transaction management integrity control query execution mechanisms storage recovery aspects 
note section focuses static aspects architecture 
dynamic aspects illustrated section iv examples query execution described detail 
overview fig 
presents overview architecture 
architecture consists number components implemented pool process objects 
components instantiated times system central instantiation serves entire dbms 
architecture dynamic components created deleted dynamically system 
component defined functionality effort put design interfaces components 
modularity function separation high level interfaces important characteristic design system 
result flexibility system architecture allows experiments functionality 
qo ltm ltm ltm ltm ltm ofm ofm ofm fig 

global architecture 
rectangles fig 
represent permanent components components live long system 
ovals represent transient components belonging user session life cycle components related user actions 
dotted ovals show transient components belonging second concurrent user session 
function compo nents interfaces components described 
central components system data dic tionary dd concurrency controller cc 
components instantiated system 
choice central cc dd simplicity reasons 
dd central storage metadata system relation constraint definitions fragmentation information statistics 
contents dd entirely stored primary memory disk copy kept ensure recoverability 
data definition statements result changes dd tables changes immediately written disk 
con currency controller controls concurrent access database 
uses standard phase locking protocol shared exclusive locks 
furthermore equipped deadlock prevention algorithm 
query preprocessing layer system formed query language compiler query optimizer qo components 
shown components instantiated user session 
provides interactive interface user translates queries user language internal relational language system xra see section 
component offers full fragmentation allocation transparency user 
different available standard sql interface logical query interface called allows recursive queries xra interface allows queries internal language system simple data definition interface relations created integrity constraints defined fragmentation relations changed 
translated queries sent qo optimizes parallel execution plans see section 
qo contact dd obtain schema information statistics needed translation optimization queries 
transaction manager tm forms execution control layer system 
component instantiated ltm ieee transactions knowledge data engineering 
vol 
december transaction 
tm coordinates execution transaction interface tm query execution layer system 
furthermore tm contacts cc ensure serializability transaction atomicity recoverability transaction enforced phase commit protocol tm execution layer correctness transaction guaranteed enforcement integrity constraints retrieved dd 
transaction management described detail section 
data storage query execution layer consists fragment managers ofm local transactions managers ltm 
ofm permanent store manage main memory copy fragment relation database logging checkpointing information kept disk recovery 
ltm transient relational engines system 
ltm especially designed main memory algorithms relational operations 
query execution layer described detail section 
design allows parallelism components 
example qo session allocated different processors concurrently forming pipeline 
allocation com ponents second session new set processors yields parallelism query preprocessing level 
allocation ofm ltm different processors leads parallel query execution forms 
issue described section 
main interface language various com ponents formed extension relational algebra called xra 
language provides flexible high level communication various query processing layers system 
language discussed detail 
xra xra internal representation queries system 
full description syntax semantics main features described 
xra contains standard relational operations selection projection cartesian product join union difference intersection update facilities insert delete update extensions grouping operation sorting facilities transitive closure support recursive queries interface 
xra offers flexibility express wide variety parallel query execution plans operand consist multiple tuple streams automatically merged form operand result operation distributed multiple output streams 
distribution result tuples done ways result replicated output streams hash range splitter applied split tuples output streams 
primitives formulate parallel query plans illustrated section iv 
simple projection throw away attributes tuple opposed facility arithmetic operations attributes added language 
operation cheap filter tuples sent processor reduce communication costs 
illustrated section iv 
parallelism data fragmentation prisma db supports parallel query execution 
parallelism completely transparent user 
query preprocessing layer consists qo translates user queries relational level parallel execution plans fragmented database fragmentation scheme stored database account 
section describes generation parallel execution plans 
terminology respect parallelism data fragmentation introduced 
parallelism various forms paral speed query execution 
standard terminology parallelism ll 
complete terminology summarized 
multiple users system concurrently yielding parallelism queries 
query parallelism subdivided par 
orthogonal distinction pipelining contrasted pure horizontal parallelism 
term paral synonym horizontal parallelism 
adopts habit confusion possible 
horizontal parallelism commonly 
term parallelism form parallelism number processors called degree parallelism 
data fragmentation relations hor fragmented number processors 
horizontal fragmentation data enables parallel execution operations data 
example execute selection frag mented relation suffices execute selection data fragments 
uses hash algorithms relational operations hash fragmentation 
arbitrary attribute fragmentation attribute 
distribute tuples relation fragments hash function large range applied specified attribute resulting value modulo gives number fragments relation indicates fragment tuple belongs 
specifying fragmentation attribute number fragments pins fragmentation 
fragment assigned arbitrary processor 
number fragments relation called fragmentation degree relation 
fragmentation strategy offers possibility experi ment schemes relation differ degree fragmentation attribute 
range fragmentation currently supported 
extension easily added xra facility range splitting relation 
fragmentation relation allocation fragments specified user creation time 
apers er ul prisma db relation runtime fragments reallocated processors 
allows experimentation different allocation fragmentation schemes session 
generating parallel execution plans user queries transformed parallel execution plans query pre processing layer 
takes query user languages syntactic semantic checking translated xra relational level xra 
qo transforms xra query parallel ex ecution plan xra xra fragment level 
retrieves fragmentation information dd 
studying problem optimizing complex queries parallel execution see section vi simple optimizations selections projections pushed far possible relational operations distributed unions 
means qo transform join union fragments belong relation union fragment joins generating parallel execution plan join 
fragmentation information taken account process operands join fragmented join attribute number fragments fragments joined directly fragments redistributed join 
way relational operations parallelized 
qo allocates operations parallel schedule processors allocation base fragments account join fragments reside different processors allocated processor larger operand resides data transmission costs minimized 
implementation qo rule approach chosen optimization strategies stored rule base attached optimization engine 
architecture qo facilitates changes optimization strategy research results area parallel query processing easily implemented 
performance optimization process currently research issue 
transaction management integrity control prisma db tm responsible management single transaction 
tm main tasks 
responsible creation control transaction exe cution infrastructure consisting ofm tuple transport channels schedules execution individual oper ations transaction 
secondly takes care transaction properties atomicity transaction execution correctness respect defined integrity constraints serializability respect concurrent transactions recoverability 
tm modular internal architecture design inspired tasks mentioned overview architecture fig 

transaction commands coming query optimizer analyzed 
main goals analysis determine necessary locks execution commands 
locking information passed local scheduler manager tm vi ofm fig 

architecture tm lock manager 
module decides locks owned transaction requested cc 
analyzed commands scheduled parallel execution commands executed early possible 
scheduling takes dependencies various commands availability locks consideration 
commands ready execution sent execution control module 
module responsible control actual execution commands ofm layer system 
necessary creates transient ltm tuple transport channels form execution infrastructure commands transaction 
having created infrastructure sends xra commands appropriate ltm transaction commit time integrity constraints enforced retrieved dd 
syntactic analysis update commands transaction constraints retrieved may violated transaction 
constraints translated xra commands definition time dd simply appended transaction transaction modification principle 
execution constraints exactly mechanism normal query execution 
way constraint enforcement auto matically satisfies serializability transaction atomicity requirements 
transaction execution phase commit protocol executed ensure transaction atomicity tm acts coordinator ofm involved transaction act participants 
query processing section describes query execution layer 
layer consists ofm store manage base data ltm relational engines systems 
fig 
shows organization ofm ltm combination query processing layer 
ofm manages fragment relation permanent component implemented pool process object 
fragment relation unit data allocation dbms allocation facilities pool experiment different allocation schemes fragments stored database 
note approach election predicates updates extended negation constraint predicates 
ieee transactions knowledge data engineering vol 
december fig 

local transaction management environment 
ltm transient object execute relational operations 
typically ltm created fragment operation query 
ltm attached ofm case directly access fragment managed ofm ltm independent operate results previous operations transaction 
stream tuples generated ltm stored result previous operation ltm 
ltm implemented pool process objects form unit parallelism query execution layer dbms 
allocation facilities pool experiment various parallel execution strategies query 
query execution layer designed allow flexible parallelism operand consist multiple input streams merged ltm form operand fig 
ltm produce operand destination ltm 
hand result operation distributed multiple output streams destination 
ofm concurrently accessed multiple transactions reading course case tm attaches private ltm ofm 
main memory character system exploited algorithms relational operations 
general state main memory system allows relatively simple algorithms bothered buffer cache management prob lems 
obviously system allows optimizations yield performance gain main memory environment 
example describe study possible optimizations operations scan large numbers tuples 
shown dynamic compilation expressions evaluated large number tuples yields considerable performance gain 
heavily uses dynamic compilation facility pool 
architecture ltm allows pipelining horizontal parallelism different ltm want study forms interoperation parallelism context main memory system 
shown special main memory algorithms enhance effective parallelism pipelining 
table simple hash join pipelining hash join fig 

simple pipelining hash join algorithm main memory system 
pipelining algorithms aim producing output early possible consumer result start operation 
particular proposes pipelining hash join algorithm 
opposed known simple hash join algorithm symmetric algorithm builds hash table operands see fig 

join process consists phase 
tuple comes hashed probe part hash table operand constructed 
match result tuple formed sent consumer process 
tuple inserted hash table operand 
algorithm produce result tuple soon matching tuples reached join ltm 
pipelining algorithms possible relational operations join operation 
possible pipelining algorithms implementation relational operations 
discusses influence pipelining algorithms performance gain interoperation pipelining 
storage recovery prisma db main memory dbms means entire database stored primary memory ram system 
realistic assumption system provide large amount ram memory 
pro equipped total gb ram 
furthermore scalability hardware architecture allows addition nodes increase amount memory 
hardware equipped stable ram memory 
consequence contents memory lost system crash 
ensure stability database stable storage medium required backup storage main memory database 
uses stable file system purpose 
storage prisma designed main mem ory system traditional dbms storage structures relations re evaluated 
ofm equipped data structures handling tuples data structures available ltm attached ofm see fig 

particular tuple layout index creation storage preservation temporary storage important design 
see instance comparison data structures main memory database systems 
tuple layout critical storage performance 
tuple lengths business applications assumed bytes 
tuples short 
main memory relaxes need physical adjacency apers fields tuple 
pool boundary conditions project impossible exploit clever memory allocation schemes main memory data structures experiment tuple representation 
recovery recovery mechanism prisma phase commit protocol logging checkpointing techniques relation fragment see fig 

ofm participates update transaction records local log file transaction updates transaction decision global abort commit status 
log grows large ofm decide locally write checkpoint file disk clearing log 
system crash ofm recover independently reloading checkpoint disk replaying update statements committed transactions log file 
note prisma architecture designed parallel logging recovery reduce overhead disk cases possible ofm state moment crash 
recovery mechanism ofm find state global transaction time crash 
information kept date global transaction log tm transaction processing 
transaction state active committed aborted 
recovery time ofm retrieves transaction state transaction log 
state aborted active ofm replay update statements transaction log 
database protected media failures stable file system system 
file system employs file replication technique keeps copy file different disk 
media failure system software responsible bringing file system back consistent state 
iv 
query execution example fig 

example database illustrate dynamic aspects dbms architec ture execution example query described 
database fig 
query example borrowed 
relations fragmented attribute 
person drinks fragmented fragments person drink wine fragments wine wine vineyard fragment 
horizontal lines fig 
indicate fragment boundaries 
attributes wine person vineyard unique keys 
domain vineyard fig 

filled example database 
age field person relation restricted interval 
furthermore obvious referential integrity constraints schema person id wine id wine name vineyard name 
corresponding fragments person drinks reside processor fragments private processor 
fig 
shows database stored idle 
ofm components labeled name fragment store label ofm fig 

dotted boxes fig 
represent processors 
physical data organization example database illustrates flexibility data storage system arbitrary number fragments possible relation fragment allocated processor memory space hold data 
retrieval query assume database fig 
stored 
example retrieval query find names persons drink german wine 
sql query language 
select person name person drinks wine vineyard person id wine id drinks wine wine name vineyard name vineyard country germany 
execute query sql compiler created 
compiler checks syntactic semantic correctness query 
semantic checking sql compiler contacts dd supplies information schema ieee transactions knowledge ani data engineering 
vol 
december relations query 
query correct translated xra select germany cp person drinks wine vineyard 
xra construct numbers refer attributes keyword cp cartesian product cartesian product attributes operands concatenated result attributes indicates result operation projected second attribute 
xra query handed qo 
qo compiles query xra optimizes 
just simple optimizations current version selections projections pushed far possible useful joins distributed unions 
proper algorithm decide join order degree parallelism join implemented see section vi 
qo contacts dd get fragmentation information relations query 
dd supply statistics relations fragments qo 
possible resulting xra query cl person person join cl join drinks clo join cl join wine cl cl join wine select germany cl lo join cll cl cl cl join cl cl cl union 
program looks pretty complex corresponding execution infrastructure fig 
illustrates meaning 
facilities xra explained section program 
operand refers operand consists multiple streams input data 
ca 
cb indicates result operation split attribute multiple output streams 
indicates result operation projected attributes person joined drinks relations fragmented join attribute 
person fragments sent drink fragments managed ofm results joins redistributed join wine 
result selection vineyard result join wine redistributed calculate join processors 
results united sent fig 

executing example query 
user 
tuples sent node projected relevant attributes reduce communication costs 
xra program handed tm creates execution infrastructure coordinates execution 
necessary execution infrastructure shown fig 

fragment tm asks lock cc 
lock acquired fragment accessed 
explained section ltm attached ofm execute relational operations base fragments ltm represented half ovals top ofm 
operations base fragment operand executed independent ltm ovals 
tm creates ltm initializes xra statement execute 
half ovals labeled xra statement execute 
setup infrastructure completely self scheduling 
ltm connects destination ref erences incorporated xra statement executed ltm works independently coordination phase intrinsically parallel 
soon ltm connected destinations start processing available data 
base data directly available data coming channels may waited 
infrastructure execution works assembly line ltm workers data flowing 
ltm activated data available 
operation terminates soon operands terminated 
operand terminates eof tuples encountered channels operand 
entire query ready eof tuples reached final union 
ready ltm sends ready message coordinating tm shut execution participants ready 
commit transaction locks released ltm data tm discarded 
appears peter paul care drunk german wine 
example query execution shows forms parallelism 
join relation level executed parallel apers el 
degrees respectively parallelism 
join drinks join wines executed parallel selection vineyard interoperation parallelism 
fact main memory dbms allows pipelining join algorithm see sections iii vi 
algorithm parallel join operations form pipeline levels execute time provided data course 
interoperation pipelining 
short pipeline starts vineyard 
example query execution illustrates flexibility prisma db 
fragmentation degree base relations degree parallelism relational operation allocation ofm ltm chosen freely systems allows experimentation broad class execution strategies 
fig 
executing insert 
inserting tuple example update query show tuple inserted database 
id added database 
phase transaction actual insertion equivalent phase retrieval query sql compiler generates xra insert statement alarm statement generates abort cardinality operand greater zero 
complete execution infrastructure built insert transaction shown fig 

note setup infrastructure constraint enforcement done parallel execution insert query 
insert wine execution insert constraint optimized xra qo program ready tm knows transaction commit 
case abort abort insert wine 
message sent participating base ltm 
note qo replaced insert relation insert fragment relation fragments belong relation 
optimization done single tuple inserts 
transaction commit tm sends message participating base ltm start making insert permanent way described section iii 
commit message ends execution insert statement 
tm generates execution infrastructure query case consists ltm performance attached wine 
explained meaningful performance difference retrieval update queries evaluation possible completion second apparent commit time correctness transaction version 
results performance respect integrity constraints checked tests spring bad due synchronization update permanent ofm 
problems system 
parts system referential integrity constraints defined relation redesigned eliminate problems 
resulting version wine drinks wine wine system completed late fall 
vineyard 
constraint violated insert performance evaluation system described 
wine second checked queries wisconsin benchmark tuple exists vineyard 
check evaluate performance 
describes integrity constraints compiled versions constraints important aspects performance stored dd fragments 
commit time tm main memory system 
full description performance asks dd constraints checked insert wine executed 
dd returns 
xra program tm tm executes program selection queries commits transaction 
case returned xra program looks follows query selects input evaluate performance selection queries 
source relation cl unique wine fragmented number processors selection criterion partitioning attribute fragments cl searched qualifying tuples 
result stored alarm 
fragmented redistribution processors generating ieee transactions knowledge data engineering 
vol 
december io result tuples prisma db main memory system results written disk 
different sizes source relation ranging tuples tuples 
source relation size speedup exper done 
numbers processors adjusted size source relation larger numbers processors larger source relations 
fig 
shows response times resulting selection queries speedup diagrams calculated 
response times milliseconds 
best response time source relation size printed bold type 
response times measure absolute perfor mance system 
absolute performance figures reasonable compared systems 
comparison absolute performance systems hard differences systems hardware functionality give indication fig 
lists response times systems number processors selection look tuples 
absolute performance reasonable data 
main memory system outperform disk systems mentioned fig 

issue discussed presentation performance results 
speedup characteristics illustrate relative perfor mance system 
linear speedup ultimate goal parallel processing 
system uses sequential initialization subtasks parallel execution operation get linear speedup small numbers processors 
performance measurements show phe explain 
response time query consists components 
tm sequentially creates initiates participating ltm 
yields component response time growing linearly number processors 
ltm certain amount local processing 
yields component response time inversely proportional number processors 
simple reasoning leads observation adding processors parallel task ultimately degrades performance system uses sequential initialization lo nodes response speedup diagram fig 

performance selection queries 
fig 

response times parallel dbms selection tuples ms tasks 
possible degrading performance measured occurs larger numbers processors available 
yield degrading performance number processors lower number available processors reason twofold firstly relatively small source relations taken account leads small amount local processing 
speedup diagrams show optimal number processors lower smaller source relations 
second reason main memory nature system 
sequential component response time consists lot coordination message passing 
component benefit main memory nature system 
costs local processing lowered system main memory 
optimal number processors parallel task lower main memory system equivalent disk system 
words say main memory system local processing fast hard start parallel components ready 
extensive formal coverage issue 
observation behavior parallel main mem ory system implications hardware configuration chosen system 
obviously main memory system needs large amount primary memory 
maximal size subtask parallel task directly related size memory processor amount memory processor fairly large yield subtasks large allow performance gain parallelism 
section parallel execution join queries discussed 
join queries expensive selec tions speedup characteristics expected better 
apers er ul join queries response times ms speedup characteristics join query performance experiments query joining tuple relation tuple relation tuple relation matches tuple look relation result consists tuples 
query called query look relation relation 
different execution strategies tested called join sequel relations initially fragmented join tribute equal numbers fragments corresponding fragments reside processor 
join relations fragmented way fragments reside different processors 
fragments sent fragments joining 
join relation fragmented join attribute relation fragmented attribute equal numbers fragments 
fragments reside different pro cessors 
relation redistributed sent relation joining 
join relations fragmented attribute join attribute equal numbers processors 
fragments reside different processors 
relations redistributed sent join processors joining 
strategies tested processors joins combined fragmentation degree initial fragmentation relations 
fig 
shows response times measured experi ment speedup respect response time processor queries 
note case linear speedup yields speedup factor processor queries 
achieved absolute performance join compared systems 
fig 
lists response times query reported projects 
hard compare systems differ ways 
report response time measured prisma db outperforms reported performance figures query 
join join show apart absolute perfor mance speedup characteristics 
speedup slightly superlinear 
caused synchronization fig 

performance join queries 
problems queries processors 
speedup characteristics join disappointing join worse 
reason follows 
join join need redistribution operands 
redistribution expressed xra expression large grows larger degrees parallelism number destinations grows degree parallelism 
tm sequentially sends large expression ltm pool support broadcasting overhead sending xra expression node fragment 
join needs go redistribution operand join redistribute operands making things worse 
point pay forms flexibility offered system 
firstly pool facilitated development flexible architecture high level interface offered pool impossible solve problem sending large xra expressions ltm secondly xra developed express wide variety parallel execution plans expressions generated plans high degree parallelism grow larger want 
problems feel performance reported section offers platform experiment parallel query execution especially study execution complex queries degree parallelism need large 
concluding section discussed performance 
relative absolute performance discussed 
discussion relative performance yielded useful re transactions knowledge data engineering 
vol 

december sults implementation parallel main memory systems 
absolute performance expected main memory system 
specifically 
main memory system outperform disk system order magnitude 
achieve reason fold 
firstly hardware state art prisma project started outdated 
due memory extension boards hardware run full speed see section 
secondly experimental high level programming language performance penalties high level language low level optimizations hard impossible new compiler optimized detail 
high level programming platform profitable sense bother sorts nasty low level details fully functional dbms finished reasonable time frame 
vi 
current research section describes flexibility research parallel query execution integrity constraint enforcement 
queries flexibility query execution layer prisma db study parallel execution complex queries 
complex query query consists multiple relational operations 
queries example complex queries 
important questions consist 
best join order parallel environment 
degree parallelism join operation 
allocate processors join operation 
initial data distribution influence query execution 
reports research 
papers pipelining hash join algorithm see section introduced algorithm fewer constraints order operand tuples processed known hash join algorithms expected yield significant performance gain pipelining 
behavior linear bushy query plans restricted class queries studied simulation analytic mathematical analysis distinction left deep right deep linear plans exist pipelining hash join symmetric algorithm 
simulation time research started final version ready 
results study show effective parallelism achieved join pipeline 
shown join queries small operands better bushy query plan join queries large operands prefer linear schedule 
currently research continued follows 
firstly operational prototype confirm results secondly want extend study broader class queries ation parallelism individual join operations considered 
integrity control current research directions prisma context integrity control parallel main memory database systems 
main topics research software architec tures integrity control effects data distribution parallel enforcement ways improve performance integrity constraint enforcement parallel environments 
emphasis parallelism performance constraint enforcement contrasts research performed context dbms projects starburst 
research basic software architecture integrity control transaction modification principle explained section transaction management 
principle enables standard query execution machinery constraint enforcement deals correctly transaction serializability atomicity requirements 
discussed basic architecture extended number ways obtain better performance integrity control 
effects data distribution parallel enforcement described detail 
attention paid translation constraints functional specification order logic operational specification xra removal fragmentation transparency optimization constraints parallel context mapping constraints parallel query execution machinery 
concepts easily transaction modification context 
performance evaluation enforcement prototype lead important observa tions 
place parallelism proven way deal high processing costs associated constraint enforcement transaction execution times including integrity control strongly improved parallel exe cution 
secondly relative costs constraint enforcement shown quite acceptable comparison transaction execution integrity control typical figures percent simple constraints referential integrity constraints worst case 
fact prisma db uses main memory storage pos itive influence figures constraint enforcement mainly retrieval process update transactions require secondary storage operations 
research performed special purpose commu nication protocols constraint enforcement lower levels 
main goal protocols decrease control overhead imposed transaction management process constraint enforcement 
gains performance expected optimal scheduling constraint enforcement 
vii 
research discussed design implemen apers ul tation parallel main memory rdbms 
design system characterized main ideas parallelism main memory data storage provide high performance query processing high level object oriented language obtain modular flexible system architecture easily experimentation functionality performance 
currently second prototype dbms called running hardware configurations nodes 
prototype provides complete dbms functionality concurrency control integrity control crash recover facilities 
extensions functionality added easily automatic loading unloading mechanisms able handle databases fit main memory system 
absolute performance prototype shown comparable state art parallel database machines 
relative performance respect software hardware configuration led new insight behavior parallel main memory systems 
choice experimental object oriented implementa tion language important impact project 
language proven great advantage obtaining structured flexible software architecture 
mapping dbms components active objects language enables natural modularization system clear interfaces 
hand choice high level implementation language shown drawback obtaining optimal performance explicit control hardware low level processes possible 
experimental platform number research activities 
place experiments queries parallel integrity control described previous section conducted prototype 
furthermore implementation parallel algorithms transitive closure operations enables parallel computation recursive queries prisma dbl 
system experimental implementation platform nf layer supports complex objects flattening complex database schema relational schema yields schema referential integrity constraints queries need join operations layer rely heavily referential integrity control parallel facilities system 
agrawal dewitt recovery architectures cessor database machines proc 
acm sigmod int 
conf management data austin tx may 
america pool parallel object oriented language oriented concurrent programming yonezawa tokoro eds 
cambridge ma mit pp 

america issues design parallel object oriented language comput vol 
pp 

ed proc 
prisma workshop parallel database systems 
new york springer verlag 
si apers processing recursive queries relational algebra proc 
second working conf database semantics portugal nov pp 
van den berg kersten engineering main memory dbms cwi quart 
centre mathematics computer science amsterdam netherlands 
van den berg kersten blom comparison scanning algorithms proc 
int 
conj databases parallel architectures applications miami mar 
valduriez prototyping db shared memory parallel database system proc 
int 
con parallel distributed information systems miami beach fl dec 
pp 

bitton dewitt 
benchmarking database systems systematic approach proc 
ninth int 
con large data bases florence 
italy oct nov 
io boral alexander clay copeland franklin hart smith valduriez prototyping bubba highly parallel database system ieee tram 
know 
eng 
vol 
pp 

boral database machine morphology proc eleventh int 
con large data stockholm sweden aug 
development cross database computers proc 
sixth int 
workshop database machines france june pp 

twist doom decentralized object oriented machine ieee micro oct 
ceri distributed principles systems 
new york hill 
dewitt ghandeharizadeh schneider hsiao rasmussen gamma database machine project ieee tram 
knowl 
data eng vol 
pp 
mar 
dewitt ghandeharizadeh 
schneider mu 
sharma single user evaluation gamma database machine proc 
int 
workshop database machines japan oct 
dewitt katz olken shapiro wood implementation techniques main memory database sys tems proc 
acm sigmod int 
con boston ma june pp 

classification comparison main memory database recovery techniques proc 
database engineering conf pp 

valduriez relational arid bases 
reading ma addison wesley 
grefen apers parallel handling integrity constraints fragmented relations proc 
second 
symp 
databases parallel distributed systems dublin ireland july pp 

integrity constraint enforcement transaction modi fication proc 
nd int 
conj database expert systems applications berlin germany july 
dynamic action scheduling parallel database system proc 
conf parallel architectures arid qe europe paris 


grefen wilschut user manual memo 
inf universiteit twente enschede netherlands 
haas freytag lohman pirahesh extensible query processing starburst proc 
acm sigmod int 
conf data portland may june 
apers 
ceri distributed transitive closure computations disconnection set approach proc 
sixteenth int 
con 
large brisbane australia aug pp 


ceri parallel hierarchical evaluation transitive closure queries proc 
int 
conf parallel distributed systems miami beach fl dec 
wilschut implementation performance evaluation parallel transitive closure algorithm memo 
inf universiteit twente enschede july 
kersten logarithmic code expansion speedup index access foundations organization algorithms new york springer verlag june pp 

van semantic query optimization distributed database systems ph dissertation 
lehman carey 
query processing main memory ieee transactions knowledge data engineering vol 
december database management systems proc 
acm sigmod 
con management data washington dc may pp 

recovery algorithm high performance memory resident database system proc 
acm sigmod int 
conf data san francisco ca may 
leland silicon database machine rational design results proc 
fifth 
workshop database machines japan oct 
garcia molina lipton valdes massive memory machine ieee tram 
comput vol 
pp 
may 
schneider dewitt tradeoffs processing complex join queries hashing multiprocessor database machines proc 
sixteenth int 
conf large data bases brisbane australia 
aug pp 

simon valduriez design implementation extendible integrity subsystem proc 
acm sigmod dit 
management data boston ma june 
hammer lopez reeve townsend wong eds parallel computer system advanced information processing proc 
parallel architectures languages europe paris france june pp 

van der pool implementation proc 
prisma workshop parallel database systems 
netherlands pp 

apers adl algebraic database language proc 
computing science utrecht netherlands nov pp 

stonebraker implementation integrity constraints views query modification proc 
acm sigmod inf 
conj data san jose 
stonebraker katz patterson ousterhout design xprs proc 
conf buses 
los angeles 
ca aug sept 
stonebraker rowe implementation postgres ieee trans 
know 
eng 
vol 
mar 
watson eds parallel relational database system proc 
prisma workshop parallel systems netherlands 
wilschut 
dataflow execution parallel main memory environment proc 
int 
conf parallel distributed info miami beach 
fl dec 
dataflow query execution parallel main memory environment published 
pipelining query execution proc 
int 
ori parallel architectures applications miami mar 
wilschut apers parallel query execution pmc prisma systems netherlands sept 
wilschut apers main memory system performance proc 

conf large bases vancouver canada aug 

wilschut van 
model exe 
cution memo 
inf univ twente enschede netherlands 

wilschut grefen apers kersten implementing proc 
si int 
database machines 
france june pp 
care van den berg received degree computer science university dam netherlands 
currently working ph degree 

working cwi participated database machine design implementation prisma project 
research interests include object oriented data base systems 
performance analysis parallel adaptive systems 
jan received degree computer science enschede netherlands 

research programmer university twente netherlands worked design imple mentation prisma 
currently involved implementation object oriented database specification language tm 
paul grefen received degree computer science ph degree university twente netherlands respectively 
joined prisma project mainly worked field transaction man agement integrity control 
currently assistant professor university twente 
martin kersten received ph degree computer science vrije university amsterdam netherlands 
joined cwi netherlands set database research group 
designer prisma database machine 
int follow esprit project responsible development enhanced version sql cater documents geographical data 

leading national project exploitation amoeba distributed system advanced database management 
currently head computer science department cwi 
associate professor vrije university teaches advanced courses database technology 
current research interests database programming languages distributed parallel object oriented database systems dynamic query optimization performance assessment database systems 
author author technical papers 
dr kersten member acm 
peter apers received ph degree vrije university amsterdam netherlands 
wilschut received de worked researcher uni biology vrije university california santa cruz stanford lands 
currently working university 
currently full professor ph degree 
university twente netherlands joined case center leads group working object oriented data aided design michigan state university complex object databases optimization search assistant 
worked query languages parallelism database search fellow andy tanenbaum group management systems database machines 
vrije university distributed operating systems 
dr apers acm 
currently serves editorial boards joined prisma group university data knowledge distributed parallel database systems 
twente mainly worked parallel query execution 
