fast ltl uchi automata translation paul denis liafa universit paris paris france paul denis liafa jussieu fr 
algorithm generate uchi automata ltl formulae 
algorithm generates weak alternating uchi automaton transforms uchi automaton generalized uchi automaton intermediate step 
automaton simplified fly order save memory time 
usual simplify ltl formula treatment 
implemented algorithm compared spin experiments show algorithm efficient spin 
criteria comparison size resulting automaton time computation memory 
implementation available web address liafa jussieu fr ltl ba prove program satisfies property standard method time logic ltl model checking 
property expressed ltl formula model checker usually transforms negation uchi automaton builds product automaton program checks product emptiness 
focus uchi automaton ltl formula trying improve time space computation size resulting automaton spin popular ltl model checker 
algorithm uses generate uchi automaton ltl formula may quite slow may need large amount memory usual ltl formulae 
particular algorithm bad behaviour fairness conditions impossible spin generate uchi automaton formula containing fairness conditions computation time memory needed 
example consider simple response formula fairness conditions 
pn 
formula type encountered ltl model checking 
fairness conditions right hand side property usually complex 
value greater 
alas case produce uchi automaton reasonable amount time memory see table 
spin ltl ba ltl ba time space time space time time space time space table 
comparison formulae 
time sec space kb 
answer server 
program died giving result spin algorithm improved ltl aut papers modify basis algorithm improved core algorithm rewriting ltl formulae simplifying uchi automaton 
improvements quite efficient actual transformation ltl formula uchi automaton similar construction explained may perform badly natural formulae experiments table 
note written perl spin ltl ba written web server 
figures relevant 
see sect 
details 
new algorithm generate uchi ltl formula 
algorithm tableau construction 
classical construction see alternating automaton ltl formula states size formula 
alternating automaton turns tobe weak shown 
property generating directly uchi automaton states able build generalized uchi automaton uchi automaton labels accepting conditions transitions states states 
generalized uchi automaton important improvements algorithm 
best solution design model checking directly generalized uchi automaton order compare ones existing model checking algorithms trans form automaton classical uchi automaton 
method classical obtain uchi automaton states 
second main improvement stems simplifications au 
construction goes steps able simplify automata step improving efficiency steps 
dramatically reduce number states transitions automata especially generalized uchi automaton 
simpli fication performed fly construction automaton 
thisis major improvement posteriori simplifications 
amount memory size simplified automaton sizeof automaton may quite huge 
time needed reduced dramatically exploring smaller part construction 
new algorithm built tool available web liafa jussieu fr ltl ba 
tool efficient tool tried computation time especially memory 
results algorithm formulae fly simplifications ltl ba posteriori simplifications ltl ba detailed table 
experimental results sect 

size generated automaton 
point view algorithm usually better spin occasionally may produce bigger ton 
note spin ltl ba ltl ba give exactly resulting automaton formulae give bigger automata 
organized follows 
section begins linear temporal logic semantics 
sections describe algorithm proofs correctness 
section presents sect 
describes experimental results 
preliminaries linear temporal logic ltl ltl introduced specify properties executions system finite set prop contains atomic properties states 
standard boolean operators express static properties 
temporal operators release eventually 
definition syntax 
set ltl formulae set prop defined bythe grammar ranges prop 
semantics ltl usually defines execution oe satisfies formula 
semantics depends atomic propositions stand state oe 
purpose sequences sets atomic propositions 
definition semantics 

word sigma sigma prop ltl formula 
relation models defined follows 



basic operators defined 
course operators defined tt def ff def tt def def def tt def ff ltl formula disjunction 
conjunction temporal formula 
ltl formula written negative normal form prop negations operators operation change number temporal operators formula 
suppose ltl formula negative 
example 
running example 
negative normal form ff tt tt ff 
construction algorithm simplifies formula set rules reduce number temporal operators 
relevant complexity algorithm number 

discuss 
ltl weak alternating automata section explains classical construction building 
alternating automata introduced muller schupp 
defined needed words 
described 
definition somewhat different classical 
definition 
uchi weak alternating uchi automaton tuple sigma ffi set states set conjunctions elements empty denoted tt 
identify sigma alphabet sigma sigma ffi sigma transition function set initial states set final states uchi exists partial order states ffi lower equal definition classical alternating automaton condition partial order 
tt ff tt tt tt tt fig 

automaton 
states right removed 
transition function looks different usual definition delta sigma 
changes implementation reasons ease manipulation data structures save time space computation 
classical representation transition delta 
ff ffi ff 
conversely may obtain definition classical disjunctive normal form 
definitions equivalent 
notice transition function sigma sigma tran sitions differ action gathered 
practice usually reduces lot number transitions 
automaton reads sigma 
example 
see representation fig 

states twice 
notice arrows origin represent transition conjunction states 
example ffi sigma tt sigma sigma ffi sigma sigma 
run oe word 
sigma labeled dag partitioned vi labeling function vi ff ffi ui ff 
run oe accepting infinite branch oe finite number labeled uchi acceptance condition 
set exists accepting run note uchi uchi acceptance conditions equivalent replace example 
example accepting run automaton definition associated ltl formula operators 
omega helps treating conjunctions gives roughly dnf allowing restrict states automaton temporal subformulae 
definition 
sigma define omega ff ff ff ff ltl formula define temporal formula 
step algorithm building ltl 
notice number states automaton size formula 
step 
ltl formula set prop 
define set temporal subformulae sigma prop set subformulae formulae type ffi defined follows delta extends ffi subformulae 
ffi tt sigma tt ffi sigma tt sigma sigma ffi sigma tt sigma sigma sigma ffi sigma ffi delta delta omega sigma ffi delta omega delta sigma delta ffi temporal formula delta delta delta delta delta omega delta partial order subformula easy prove weak 

notice elements sigma definition sets sigma sigma sigma denoted con junctions literals examples sigma sigma sigma tt sigma note intersection test inclusion easily representation 
example 
shows result step formula defined ex 

tt tt tt fig 

automaton ga left right simplification theorem 
sigma 
proof 
idea proof show recursively subformula language accepted equal sigma 
difficulties encountered comes play 
ut generalized uchi automata gba point obtained ltl formula 
usual method transform alternating automaton uchi automaton produces automaton big 
gba uchi automaton acceptance conditions transitions states 
definition 
generalized uchi automaton tuple sigma ffi set states sigma alphabet sigma sigma ffi sigma transition function set initial states 
tr tj sigma accepting transitions 
example 
automata fig 
examples 
examples dashed transitions bold transitions 
accept ing run infinitely dashed transitions infinitely bold transitions 
run oe word 
sigma sequence 
elements ffi sigma ui ffi ffi qi ffi qi run oe accepting uses infinitely transitions tj 
set words exists accepting run second step algorithm building gba 
course applied automaton issued step 
ga states acceptance sets 
step 
sigma ffi uchi acceptance condi tions 
define gba sigma ffi identified conjunctions states explained definition ffi 
qn nn ffi ffi set minimal transitions ffi relation ff ff ff ff tf tf ff fi ffi ff fi 

may notice tf intuitive corresponds case inthe run edge ends labeled definition correct 
proof main theorem complicated definition experimental results better simplifications 
example 
shows result step automaton fig 

theorem 
ga 

point need alternating automaton weak theorem false classical alternating automata 
consider infinite branch run word weak labels branch decreasing ultimately constant finite 
having finite number nodes labelled equivalent having infinite number nodes labelled 
thisis crucial proof 
proof 
oe accepting run word 
ei vi vi 
going build new run redefining gradually sets vi ei vi 

suppose defined 
definition run ffx ui ffx ffx ex ffi ex ei ff ff definition ffi ff ffi exists transition ff ffi minimal 
note ui ff ff 
ffi ffi ff ffi ff ff 
tf exists ff ffi ff ff 
elements xand ff ff vi note may 
claim 
property holds ei proof 
claim true 
vi assume definition deduce tf wehave tf deduce easily ex proves claim 
restriction 
construction easily see oe new run oe accepting run 
suppose oe accepting ais weak labels infinite branch run ultimately constant 
oe accepting exists infinite branch oe claim exists oe infinite ultimately labeled impossible oe accepting 
ei 
get ffi ui ffi ei ffi ei transition ga oe 
run ga prove oe accepting 
intend prove depth transition ej ffj ej tf ei 
smallest 
note exists oe ultimately labeled oe accepting 
ej node labeled know ff ffi ej ffj ff 
ej ffj ej tf accepting run oe built accepting run oe word get inclusion ga conversely oe 
accepting run ga word 
ffi ui ffi ffi ei ffi ei 
vi ei vi ei 
definition ffi vi ffx ex ffi ex ei ffi ffx 
ei ffi ei tf ei ffor vi case choose ffx ex ex 
defined vi vi ex easily see oe run suppose accepting proved exist oe infinite nodes ultimately labeled oe accepting tt fig 

automaton bga simplification infinitely transitions tf transition ends labeled corresponding depth 

accepting run oe ga built accepting run oe word proving converse inclusion ga 
ut gba uchi automata ba point obtained gba ltl formula 
simply transform ba complete algorithm 
construction quite easy known sake completeness explain briefly 
defining ba modifications concerning alphabet transition function 
definition 
uchi automaton tuple sigma ffi set states sigma alphabet sigma sigma ffi sigma transition function set initial states set repeated states uchi condition 
run oe word 
sigma sequence 
elements ffi sigma ui ffi ffi qi ffi qi run oe accepting exists infinitely states setof words exists accepting run third step algorithm building ba gba 
states acceptance conditions bg states 
step 
sigma ffi gba 
tr 
define 
sigma ffi ffi ff ff ffi ff 
ae max tk rmax example 
shows result step automaton ga fig 

theorem 
bg 

exist similar algorithms transform gba ba consist building synchronous product gba automaton verifying acceptance condition verified infinitely automaton differs algorithm 
chose gives results size resulting ba simplification 
simplification simplification really important algorithm 
step produces anew automaton result previous step simplify result faster algorithm memory uses step simplify automaton obtained rules simplification occurs state accessible removed transition implies transition removed ff implies ff ff ff gba ff ff ba ff ff states equivalent merged 
equivalent ffi ffi gba ffi ffi ff ffi ff ff ba ffi ffi note gba issued step condition ff tj doesnot depend condition simply ffi ffi simplification procedure really efficient reduce size automata 
strength algorithm simplification fly transition created compared transitions calculated state ones useless immediately deleted transitions state created state compared states created merged states possible 
method important usually states transitions simplified fly saves lot time space 
table results algorithm fly cation compared ltl ba algorithm posteriori simplification 
formula defined gba states simplified gba states 
fly simplification avoids intermediary exponential automaton explains great im provement time memory ltl ba exponential 
experimental results section compare results algorithms ltl formula ba 
spin model checker developed bell labs 
contains transforming ltl formula ba 
program written version 
released aug 
algorithm 
program written perl comparison read amount memory just approximation unix command top 
algorithm 
program publicly avail able demo proposed web 
measure time needed web interface start responding request 
know type machine handles request 
consequently times gave taken caution 
ltl ba program spin order reliable com parison programs 
ltl ba program simplification 
tests sun ultra station gb ram 
explained compared tools usual ltl example formula defined 
result detailed table 
type usual ltl formulae encountered model checking formulae 
pn 
tests table 
algorithm outperforms ones 
spin ltl ba time space time space time time space table 
comparison formulae 
time sec space kb compared algorithms random ltl formulae fixed size tool 
compatibility reasons comparison realize spin 
results test random formulae size algorithms compared formulae 
see table details 
spin ltl ba avg 
max 
avg 
max 
time computation seconds number states number transitions table 
comparison random formulae fixed size 
daniele giunchiglia vardi 
improved automata generation linear temporal logic 
proc 
th international computer aided verification conference pages 

holzmann 
optimizing uchi automata 
proceedings th int 
conf 
concurrency theory concur 

gerth peled vardi wolper 
simple fly automatic verification linear temporal logic 
protocol specification testing verification pages warsaw poland 
chapman hall 

holzmann 
model checker spin 
ieee transactions software engineering may 

kupferman vardi 
weak alternating automata weak 
proc 
th israeli symposium theory computing systems pages 
ieee 

muller schupp 
alternating automata infinite objects determinacy rabin theorem 
proceedings ecole de informatique th automata infinite words volume lncs pages le mont france may 
springer 

muller schupp 
alternating automata infinite trees 
theoretical computer science october 

muller schupp 
simulating alternating tree automata nondeterministic automata new results new proofs theorems rabin mcnaughton safra 
theoretical computer science april 


alternating automata temporal logic ordinals 
phd thesis mathematics university illinois urbana champaign 

somenzi 
efficient uchi automata ltl formulae 
cav international conference computer aided verification 


randomized algorithms translating linear temporal logic formulae uchi automata 
workshop concurrency specifications programming pages warsaw poland 

vardi 
automata theoretic approach linear temporal logic volume lecture notes computer science pages 
springer verlag new york ny usa 
