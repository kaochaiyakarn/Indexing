modular object oriented programming units mixins module class systems evolved meet demand software components 
considerable effort invested developing new module class systems demonstrating promotes code reuse 
relatively little said interaction constructs modules classes improve programs 
demonstrate synergy particular form modules classes called units mixins respectively solving complex reuse problems natural manner 
module class systems promote code reuse 
theory uses classes simulated modules vice versa 
experience shows programmers need constructs serve different purposes 
module delineates boundaries separate development 
class permits fine grained reuse selective inheritance overriding 
modules classes aid different patterns reuse modern languages provide separate constructs 
unfortunately reuse allowed conventional module class systems limited 
systems modules classes hard wired specific context modules specific superclass 
previous separately described novel module class systems mzscheme 
mzscheme modules called units roughly java packages units linked external linking specification fixed internal specification 
mzscheme object language provides mixins java classes mixin parameterized superclass applied multiple times create different derived classes different base classes 
advantages units mixins conventional module research partially supported vaughan fellowship nsf ccr cda ccr texas atp 
appear icfp sept baltimore md robert bruce findler matthew flatt department computer science rice university houston texas class languages follow single language design principle specify connections modules classes separately definitions 
shared principle separating connections definitions units mixins synergistic 
units mixins combined programmer exploit encapsulation linking properties units control application mixin extensions change class extended particular mixin 
section motivate detail design mzscheme units mixins synergy best demonstrated example 
bulk presents depth example showing synergy units mixins solves old extensibility problem natural manner 
section describes extensibility problem section develops rough solution problem conventional classes 
section introduces units mixins refine complete solution 
sections extract lessons example design modular object oriented programming languages 
section relates research 
extensibility problem table summarizes extensibility problem original operations extension original variants extension draw draw draw draw shrink shrink shrink shrink rotate rotate rotate rotate portion table contained dotted box represents program component provides operations draw shrink collection data geometric shapes squares circles 
programmer may wish component different contexts 
programmer may wish include component 
programmer may wish extend datatype variant repositioned shapes adapt collection operations accordingly 

programmer may wish add new operation rotate 
client original datatype client avoid duplicate maintenance component acquired object form component organized programmers add new forms data new operations modifying recompiling original program component existing clients 
program organization dramatically increases potential software reuse enables smooth integration proprietary modules 
standard functional object oriented strategies offer satisfactory way implement component clients 
functional language variants implemented type operations functions type 
approach set operations easily extended adding new variant requires modifying functions 
object oriented language variants implemented collection classes operations methods common classes 
approach datatype easily extended new variant adding new operation typically implemented modifying classes 
existing literature provides solutions problem 
hne solution relies generic procedures double dispatching interfere hierarchical structure program 
palsberg jay solution reflection operators incurs substantial run time penalty 
krishnamurthi felleisen friedman propose efficient solution works standard class mechanisms requires implementation maintenance complex programming protocol 
solutions partial address reuse clients 
contrast combination units mixins solves problem simply elegantly addresses reuse original component clients 
client new variant extensible programming datatypes client client new operation extensible programming classes outlines solution extensibility problem diagram represents original component 
rhombus stands datatype rectangles denote datatype variants 
oval client 
diagram shows datatype extended new variant 
extension contained right inner dashed box 
solid box left represents unmodified datatype code 
original client preserved new client datatype exploits variant extension 
diagram shows extension direction adding new operation datatype 
extension implemented inner dashed box solid box represents unmodified existing implementation 
new squares extension represent implementation operation variant 
existing clients modified refer extended variants 
remainder section develops concrete example evolving shape program 
approximated conventional classes language features available typical object oriented language 
classes section introduces units mixins complete solution 
shape datatype initially shape datatype consists variants operation rectangles circles translated shapes drawing 
rectangle circle variants contain numbers describe dimensions shape 
translated variant consists numbers define shape interface draw define rectangle class null shape width height public draw lambda window define circle class null shape radius public draw lambda window define translated class null shape shape public draw lambda window send shape draw window shape classes define display shape lambda shape 
shape shape error expected shape window send shape draw window display shape object translated object rectangle shape clients shape 
variants drawing operation takes destination window numbers describing position draw shape 
shape datatype defined shape interface implemented classes rectangle circle translated 
subclass declares draw method required implement shape interface 
shows interface class definitions mzscheme class system 
mzscheme class system similar java details see appendix 
contains clients shape datatype 
function display shape consumes shape draws new window 
final expression creates shape displays 
shape datatype extended consider clients affected 
define union class null shape left right public draw lambda window send left draw window send right draw window display shape object union object rectangle object translated object circle variant extension new client define bb shape interface shape bounding box define bb rectangle class rectangle bb shape width height public bounding box lambda object bb width height sequence super init width height define bb circle class circle bb shape radius public bounding box lambda object bb radius radius radius radius sequence super init define bb translated class translated bb shape shape public bounding box lambda sequence super init shape define bb union class union bb shape left right public bounding box lambda sequence super init left right define bb class null left top right bottom define display shape lambda shape 
shape bb shape error expected bb shape bb send shape bounding box window send shape draw window operation extension variant extension create interesting configurations shapes extend shape datatype new variant representing union shapes 
strategy suggested define new union class derived shape 
defines union class shows expression uses new class 
simplicity variant extension reflects natural expressiveness object oriented programming 
object oriented approach lets add variant modifying original code existing clients 
operation extension shapes look better drawn centered windows 
support centered shapes adding operation bounding box computes smallest rectangle enclosing shape 
add operation shape datatype defining new classes derived variants shape section 
defines extended classes bb circle bb rectangle bb translated bb union providing bounding box method 
defines bb shape set 
factory 
display shape send factory union send factory rectangle send factory translated send factory circle revised clients factory interface describes extended shape type bounding box classes just shape describes type original shape classes 
new display shape client uses bounding box information center shape window 
unfortunately modify clients create instances new bounding box classes original shape classes including clients bounding box information 
standard object oriented architecture satisfy original goal support operation extensions shape datatype modifying existing clients 
object oriented programming constructs address problem directly resort programming protocol pattern 
case factory pattern mutable solves problem 
factory pattern relies object called factory create instances shape classes 
factory supplies creation method variant shape clients create shapes calling methods object directly 
change classes instantiated clients necessary change factory stored mutable 
revised client factory shown 
factory pattern implements simple dynamic linker set 
installs link 
separates definition shapes clients specific shape implementation selected time hard wiring particular implementation client 
construct set 
linking obscures intent programmers compiler 
robust solution improve module language 
better reuse units mixins previous section developed shape datatype collection operations showed objectoriented programming supports new variants operations separately developed extensions 
section separate development explicit mzscheme module system basic definitions extensions clients defined separate modules 
mzscheme supports separate compilation modules provides flexible language linking 
linking implemented factory previous section naturally defined module linking 
show mzscheme class module combination provides new opportunities reuse available conventional object oriented languages 
factory method related pattern extra operation datatype create instances separate factory object 
factory method applies interesting special case datatype client datatype implementation making datatype implementation extensible 
define basic shapes unit import export shape rectangle circle translated define shape interface define rectangle class null shape define circle class null shape define translated class null shape creating units define gui unit import shape export display shape define display shape see define picture unit import rectangle circle translated display shape export display shape object see shape clients basic shapes 
shows basic shape classes encapsulated basic shapes unit 
unit imports exports basic shape classes 
body unit contains class definitions exactly appear 
general shape unit expression unit import variable export variable unit body expr centered ellipses indicate repeated syntactic patterns 
unit body exprs form top level scheme expressions allowing mixture expressions definitions define unit expression creates unit local variable top level variable 
unit imported variables bound unit body exprs 
exported variable defined unit body expr 
variables defined unit body exprs private unit 
defines client units basic shapes gui picture 
gui unit provides function 
depends functionality shape type specific variants imports shape 
unit imports shape variants construct instances display shape function exports 
picture invoked part program constructs shape displays 
unit unevaluated bundle code object file created compiling traditional language 
point basic shapes gui defined units shape classes defined instances created drawing window opened 
unit encapsulates definitions expressions evaluating unit invoked just procedure encapsulates expressions applied 
units figures invoked directly unit requires imports 
units linked form program 
define basic program compound unit import link basic shapes gui shape picture rectangle circle translated display shape export invoke unit basic program linking basic shape program linking shape client units units linked compound unit form 
shows link units previous subsection complete program basic program 
picture unit imports priori associated classes basic shapes 
association established compound unit expression established context basic program 
picture unit reused different shape classes compound units 
compound unit form links units called constituent units new compound unit 
linking process matches imported variables constituent unit variables exported constituents variables imported compound unit 
compound unit re export variables exported constituents 
basic program unit imports exports just basic shapes gui evaluation unit bodies occurred 
basic shapes gui units basic program complete program imports 
compound unit expression compound unit import variable link tag expr export tag variable parts import clause lists variables imported compound unit 
imported variables linked constituent unit imports 
link clause specifies compound unit created constituent units 
constituent unit specified expr identified unique tag 
expr link specification provided constituent imports 
link specifications forms form variable links constituent import corresponding import compound unit 
form tag variable links constituent import variable exported tag constituent 
export clause re exports variables compound unit exported constituents 
tag indicates constituent variable variable exported constituent 
define union shape unit import shape export union define union class null shape define basic union shapes compound unit import link basic shapes union shape shape export shape rectangle circle translated union variant extension unit evaluate compound unit expression exprs link clause evaluated determine compound unit constituents 
constituent number variables imports match number provided exception raised 
matched imported variable position 
constituent export variables referenced link export clauses constituent tag 
compound unit constituents linked compound unit indistinguishable atomic unit 
conceptually linking creates new unit merging internal expressions definitions constituent units 
merge variables renamed necessary implement linking constituents avoid name collisions unrelated variables 
merged unit ordered match order constituents compound unit link clause 
invoking unit programs basic program unit complete program analogous conventional application program executed 
languages module systems complete program executed commands outside language 
mzscheme program unit executed directly invoke unit form invoke unit expr value expr unit 
invocation evaluates unit definitions expressions result expression unit result invoke unit expression 
run basic program evaluate invoke unit basic program new units new variant extend shape union variant define extension unit union shape shown 
mzscheme extended unit language signatures linking matches variables name position 
number imports small linking position simpler avoids complex machinery renaming variables 
implementation linking equivalent reduction far efficient 
particular necessary extract expressions constituent units break separate compilation 
define union picture unit import rectangle circle translated union display shape export display shape object see define union program compound unit import link basic union shapes gui shape picture rectangle circle translated display shape union picture rectangle circle translated union display shape export invoke unit union program new client extended program shape class imported union shape union class exported 
terms union shape corresponds smaller dashed box drawn new variant class 
solid box original unmodified basic shapes unit outer dashed box basic union shapes compound unit linking union shape basic shapes 
basic union shapes unit exports variants defined basic shapes union shape serve replacement original basic shapes unit provide functionality new clients 
union program unit demonstrates uses 
new program gui picture clients reused intact original program linked basic union shapes basic shapes 
additional client unit union picture takes advantage shape extension draw superimposed rectangle circle picture 
new units mixins new operation extend shape bounding box operation define bb shapes unit 
unit corresponds smaller dashed box 
bb shapes unit example rely mixins 
bb rectangle class derived imported rectangle class determined unit linked long unit compiled 
bb rectangle defines mixin class extension parameterized superclass 
compound unit basic union bb shapes links basic union shapes unit previous section new bounding box unit exports classes 
bounding box classes exported renamed match original class names bb rectangle renamed rectangle 
renaming affect linking basic union bb shapes affects way basic union bb shapes linked units 
simplified description compound unit section cover syntax renaming exports 
complete description compound unit see mzscheme manual 
define bb shapes unit import shape rectangle circle translated union export bb shape bb rectangle bb circle bb translated bb union bb define bb shape interface shape see define bb rectangle class rectangle define bb circle class circle define bb translated class translated define bb union class union define bb define basic union bb shapes compound unit import link basic union shapes bs bb shapes shape rectangle circle translated union export shape bs bb shape bs bb rename bs bb rectangle rectangle bs bb rectangle rectangle bs bb circle circle bs bb translated translated bs bb union union operation extension unit define bb gui unit import bb shape bb export display shape define display shape lambda shape 
shape bb shape see define bb program compound unit import link basic union bb shapes bg bb gui bb shape bb picture rectangle circle translated bg display shape union picture rectangle circle translated union bg display shape export invoke unit bb program program operation extension basic union bb shapes unit serves replacement basic shapes basic union shapes provides new functionality new clients 
new client bb gui see provides display shape exploits bounding box information center shape window 
bb gui unit replaces gui reuse picture union picture modifying 
factory unnecessary units permit vary connection clients instantiated classes 
putting produces new program bb program bottom 
define color shape unit import shape export shape define shape class shape args rename super draw draw public color black change color lambda set 
color draw lambda window send window set color color super draw window sequence apply super init args define basic union bb color shapes compound unit import link basic union bb shapes cr color shape rectangle cc color shape circle ct color shape translated cu color shape union export shape bb shape bb cr shape rectangle cc shape circle ct shape translated cu shape union reusing class extension synergy shape example demonstrates synergy units mixins 
units separating definition linking modules support reuse picture union picture shape representation evolves 
mixins abstracting class expression imported class enable encapsulation extension unit 
combination units mixins enables direct translation ideal program structure working program 
achieved complete reuse existing code stage extension shape reuse possible 
code illustrates units mixins combine allow extension multiple times 
color shape unit imports shape class extends handle colors 
single unit containing single mixin extend shape variants rectangle circle translated 
compound unit basic union bb color shapes uses color shape unit times obtain set color shape classes 
code uses features described rename clause class expression args stand multiple arguments passed super init apply 
details covered mzscheme manual 
point units mixins open new avenues reuse large scale 
moral story demonstrated units mixins apply specific example general principle specifying connections modules classes separately definitions 
principle key making units mixins succeed distinct purposes module class systems 
module system serves key purposes separate development module encapsulates set definitions clearly delineating interface module rest program 
module developed isolation distributed clients compiled form 
linking modules linked form program 
linking connects definitions module module interfere internal structure module 
contrast class system supports different key services extensible types interface defines extensible type class implements type 
selective reuse class selectively refine implementation superclass preserving inherited definitions overriding definitions 
instantiation class instantiated create object class value encapsulates methods instance variables class 
serve distinct purposes modules classes require distinct constructs programming language constructs interact 
example program collection geometric shapes naturally implemented set shape classes 
implementation shape classes client code uses defined separate modules 
classes represent shapes easy extend shape classes modifying basic definition shape 
separating definition shapes different modules easy replace original shape classes new classes modifying client 
precisely modular object oriented code supposed 
unfortunately existing module class combinations support sort modular object oriented programming 
java example rectangle class extended client module creates rectangle instances modified refer new extended class 
root problem java objectoriented languages connections modules hard wired modules 
example client modules declare import shape module importing shape module 
design module class constructs encourage interaction constructs 
shape example suggests lesson design modules separate module linking specification encapsulated definitions 
words module describe imports detail support separate compilation module specify source imports 
imports supplied externally linking expression 
module system external linking turn constrains design class system 
module may encapsulate class definition imported superclass bb rectangle 
module linking specified outside module superclass determined module linked class expression de facto parameterized superclass 
parameterized class mixin 
mixins tend computationally expensive classes cost small 
parallel lesson modules requirement support mixins stated follows separate class superclass specification extending definitions 
mixins valuable right 
classes enable reuse class extended refined defining new subclasses reuse sided class extended different ways extension applies superclass 
mixin parameterized respect superclass add functionality different classes 
reuse potential mixin greater class 
type challenge explored typed models mixins units separately previous 
addition anticipated extension types including 
safety tests examples showing shape bb shape interfaces linked clients enable tests 
certain challenges remain bringing mixins units single typed model 
mixins previously published type rules assume complete program single namespace mixin names 
units previously published language express kind type relationships necessary importing exporting interface types importing types subtype 
explored similar combination classes modules typed setting 
module systems objective caml oml support externally specified connections class defined module languages provide form mixins 
modules mixins languages fail support synergy demonstrated units mixins 
particular allow operation extension demonstrated section imported class match expected type exactly extra methods allowed 
example picture initially linked rectangle class linked bb rectangle methods objective caml oml allow picture reused way 
example suggests third lesson design module class type systems allow subsumption connections including module linking class extension 
related previous research modules classes focused unifying constructs 
lee friedman investigated languages directly variables bindings provides theoretical foundation implementing modules classes 
similarly jagannathan miller proposed class environments common mechanism 
bracha explored mixins modular object oriented programming ancona zucca provide categorical treatment view 
complementary focus designing constructs programmer method implement constructs 
languages promoted modularization including mesa modula sml provide direct support object oriented programming 
similarly early object oriented languages simula smalltalk provide module system 
contrast languages ada common lisp dylan haskell java modula provide modules classes 
cecil chambers leavens designed module system specifically complement class system multi methods 
unfortunately module class systems support external connections central principle design crucial software engineering see section 
scheme provides specific mechanisms modular object oriented programming 
scheme supports modular programming lexical scope implementations provide separate compilation top level expressions 
programmers regard top level expressions modules hide private definitions letrec 
number scheme systems developed codify module top level idea satisfies criteria section 
contrast kelsey proposed module system captures ideas units 
scheme support objectoriented programming simulating objects procedures classes higher order procedures 
object oriented extensions scheme developed including support mixins 
systems provide complete languages modular object oriented programming 
units mixins promote synergistic integration modular object oriented programming techniques 
combination succeeds due consistent separation definitions encapsulated modules classes connections modules classes units mixins 
bulk explores extensibility problem highlights advantages units mixins 
strictly speaking problem solved conventional module class systems factory pattern 
straightforward datatype implementation units mixins immediately extensible 
natural bias reuse extension essential benefit units mixins 
complete version code see www cs rice edu cs plt publications ff queinnec system provides generic function extensions parameterized generic function parameterized class extensions 
system provide mixins se follows principle separating connections definitions 
authors matthias felleisen cartwright john clements dan friedman shriram krishnamurthi paul anonymous reviewers 
ancona zucca 
algebraic approach mixins modularity 
hanus rodr guez artalejo editors proc 
conference algebraic logic programming lecture notes computer science pages berlin 
springer verlag 
jensen 
implementation pc scheme 
proc 
acm conference lisp functional programming pages 
bracha programming language jigsaw mixins modularity multiple inheritance 
ph thesis dept computer science university utah march 
chambers cecil language specification rationale version 
chambers leavens 
typechecking modules multi methods 
acm transactions programming languages systems november 
clinger rees 
eds 
revised report algorithmic language scheme 
acm lisp pointers july 
cook object oriented programming versus data types 
foundations object oriented languages pages june 
curtis 
module system scheme 
proc 
acm conference lisp functional programming pages 
dahl nygaard 
simula 
common base language 
technical report publ 
norwegian computing center oslo norway may 
feeley gambit portable scheme implementation 
felleisen friedman 
little java patterns 
mit press 
flatt plt mzscheme language manual 
technical report tr rice university 
flatt felleisen 
units cool modules hot languages 
proc 
acm conference programming language design implementation pages 
flatt krishnamurthi felleisen 
classes mixins 
proc 
acm symposium principles programming languages pages 
gamma helm johnson vlissides 
design patterns elements reusable object oriented software 
addison wesley massachusetts 
goldberg robson 
smalltalk language 
addison wesley reading 
gosling joy steele 
java language specification 
java series 
addison wesley reading ma usa june 
harbison modula 
prentice hall 
hudak wadler 
eds 
report programming language haskell 
technical report yale dcs rr yale university department computer science august 
international organization standardization 
ada manual 
language 
standard libraries 
jagannathan metalevel building blocks modular systems 
acm transactions programming languages systems may 
kelsey fully parameterized modules missing link 
technical report nec research institute 
krishnamurthi felleisen friedman 
synthesizing object oriented functional design promote re 
proc 
european conference object oriented programming 
hne translator pattern external functionality homomorphic mappings 
proceedings tools usa pages july 
lang pearlmutter 
objectoriented dialect scheme 
lisp symbolic computation international journal may 
lee 
friedman 
quasi static scoping sharing variable bindings multiple lexical scopes 
proc 
acm symposium principles programming languages pages 
lee 
friedman 
enriching lambda calculus context theory incremental program construction 
proc 
acm international conference functional programming pages 
leroy objective caml system 
url pauillac inria fr ocaml 
miller 
free variables class environments 
lisp symbolic computation international journal 
milner tofte harper 
definition standard ml 
mit press cambridge massachusetts london england 
mitchell sweet 
mesa language manual 
palsberg jay 
essence visitor pattern 
technical report university technology sydney 
queinnec distributed generic functions 
proc 
france japan workshop object parallel distributed computing 
queinnec small efficient enhanced object system 
queinnec de roure 
sharing code class 
proc 
acm international conference functional programming pages 
rees module system scheme 
scheme documentation 
rees adams 
object oriented programming scheme 
proc 
acm conference lisp functional programming pages 
vouillon 
objective ml simple object oriented extension ml 
proc 
acm symposium principles programming languages pages paris france 
reppy riecke 
simple objects standard ml 
proc 
acm conference programming language design implementation pages 
reynolds user defined types procedural data structures complementary approaches data abstraction 
editor new directions algorithmic languages pages 
ifip working group algol 
dylan manual 
addison wesley 
steele jr common lisp language 
digital press second edition 
szyperski import inheritance need modules classes 
european conference object oriented programming volume lecture notes computer science pages 
springer verlag new york 
tung 
interactive modular programming scheme 
proc 
acm conference lisp functional programming pages 
wirth programming modula 
springer verlag 
appendix mzscheme class interface syntax classes shape mzscheme class declaration class superclass expr interface expr init variable instance variable clause centered ellipses indicate repeated patterns 
expression superclass expr determines superclass new class interface exprs specify interfaces implemented class 
init variables receive initialization values class instantiated arguments supplied new java 
instance variable clauses define instance variables class plus expressions evaluated instance 
example public clause declares public instance variables methods 
definition define rectangle class null shape width height public draw lambda window introduces base class rectangle 
indicates rectangle derived class shape indicates implements shape interface width height indicates initialization arguments consumed initializing instance 
instance defines public method draw 
mzscheme object system distinguish instance variables methods 
procedure valued instance variables act methods 
draw declaration rectangle defines instance variable lambda window 
initial value expression evaluated instance 
draw called method object draw may refer object 
objectoriented languages method mzscheme part environment evaluating initialization expression method object closure containing correct value 
instance rectangle created object primitive 
class instantiate object takes initialization arguments expected class 
case rectangle initialization arguments specify size shape define rect object rectangle value instance variable extracted object ivar 
expression calls draw method rect extracting value draw applying procedure ivar rect draw window method calls form common mzscheme provides send macro 
send expression equivalent ivar expression send rect draw window mzscheme approach methods avoids duplicating functionality procedures methods 
design incurs substantial cost practice object record provide slot method class closure created method object 
adding true methods object system methods object oriented languages improve run time performance object system affect essence presentation 
interfaces interface declared mzscheme interface form interface expr variable exprs specify superinterfaces new interface variables instance variables required interface addition variables declared superinterfaces 
example definition define shape interface draw creates interface named shape variable draw 
class implements shape declare draw instance variable 
definition define bb shape interface shape bounding box creates interface named bb shape variables draw bounding box 
shape bb shape class implements bb shape implements shape 
class implements interface specifically declares implementation java 
rectangle class previous section implements shape interface 
derived classes definition define bb rectangle class rectangle bb shape width height public bounding box sequence super init width height derives bb rectangle class implements bb shape 
draw method required implement bb shape inherited rectangle 
bb rectangle class declares new bounding box method 
includes sequence clause calls 
clause declares expressions evaluated instance 
commonly call special super init procedure initializes part instance defined superclass calling super derived class call super init exactly instance 
case bb rectangle calling performs rectangle initialization instance 
bb rectangle provides arguments super init rectangle class consumes initialization arguments 

