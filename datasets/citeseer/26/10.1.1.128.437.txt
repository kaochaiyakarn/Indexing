appear constraints volume number pages unknown kluwer academic publishers boston 
manufactured netherlands 
automatically con guring constraint satisfaction programs case study steven minton minton isi edu usc information sciences institute admiralty way marina del rey ca received 

multi tac learning system synthesizes heuristic constraint satisfaction programs 
system takes library generic algorithms heuristics specializes particular application 
detailed case study di erent distributions ofa single combinatorial problem minimum maximal matching show tac synthesize programs di erent distributions perform par hand coded programs exceed performance known satis ability algorithms 
synthesizing program multi tac bases choice heuristics instance distribution demonstrate capability signi cant impact results 
keywords constraint satisfaction algorithms machine learning con gurable systems 
appropriate heuristic algorithm tremendous di erence time required solve constraint satisfaction problem csp 
algorithm solving moderate sized csp combinatorial problem may extremely time consuming 
reason research area constraint satisfaction largely focused development new better heuristic algorithms 
research lead 
quote zvi galil aptly summarizes view recipes designing cient algorithms 
somewhat unfortunate point view applications anytime design algorithm mayhave start scratch 
fortunate view researchers going run problems challenges 
galil perspective nite number algorithms waiting developed advantage problem speci structure 
hand research csp area purports generic proposed methods intended useful wide variety problems 
invariably pursuit new techniques tension arises ciency generality 
generic algorithms advantage generality may lack ciency problem speci methods 
describe system called multi tac multi tactic analytic compiler advantages generality ciency multi tac automatically synthesizes problem speci versions generic algorithms 
idea specializing generic constraint satisfaction algorithms particular applications new 
instance ac algorithm van deville teng generic arc consistency method specialized functional anti functional monotonic constraints improve ciency 
various toolbox systems proposed frameworks creating specialized algorithms lassila smith transportation scheduling system 
refer systems con gurable systems 
multi tac idea exploited greater extent previous systems 
particular multi tac actively searches space heuristic algorithms conguration process complex interesting search process 
assume user provides set training instances system experiment con guration compilation process 
multi tac auto con gurable system 
system automatically con gures particular problem con gures speci instance distribution represented training instances 
multi tac designed situations combinatorial search problem solved routinely application set manufacturing tasks assigned week set workers 
situation assume compile time minor consideration 
general assumption sensible synthesized code time time spent con guration process amortized runs di erent instances 
scheduling scenario outlined practical applications true 
believe relatively rare application code 
point ignored research constraint satisfaction central assumption underlying 
multi tac objective cient program possible instance population 
practice goal multi tac perform competent programmers 
achieving level algorithms expert desirable scope simply doing competent programmer wide variety challenging 
level system potentially useful relatively simple applications automated due expense programming 
previous minton minton underwood continuing studies evaluated multi tac performance variety problems 
focus single np hard problem matching order carry depth empirical case study di erent distributions instances 
compare backtracking algorithms synthesized multi tac generic algorithms algorithms hand coded di erent distributions 
case study illuminates advantages approach limitations 
begins description multi tac speci cation language 
outline synthesis process describing multi tac searches appropriate heuristic algorithm generates cient implementation algorithm 
series empirical comparisons analyze results 
readers may prefer skip sections describe individual components multi tac architecture return reading results discussion sections 

specifying constraint satisfaction problems input multi tac consists problem description set instances instance generator 
output system lisp program tailored problem instance distribution 
subsections describe language describe problems instances speci cation minimum maximal matching problem 

problem speci cation language order describe problem multi tac formalize integer constraint satisfaction problem set constraints set integer variables 
problem speci cation consists description constraints written rst order sorted logic relatively expressive language describing csps 
instance speci cations separately 
example consider problem graph colorability graph colored colors away vertices color 
vertices represented variables value range 
problem speci cation describes coloring constraint arbitrary vertex color isgiven follows satis es adjacent assigned notation adjacent xy 
read 
indicates color satis es constraints vertex neighboring vertices assigned color 
constraint language includes types relations built system de ned relations assigned problem speci user de ned relations adjacent 
variety system de ned relations equal sum max set union 
special relations creating sets bags 
user de ned relations explicitly listing extension instance speci cation les 
instance speci cation graph colorability describes individual graph indicating number vertices graph number variables explicitly listing vertices adjacent 
graph coloring constraint particularly simple 
language expressive describe wide variety problems including scheduling timetabling bin packing problems name just 

minimum maximal matching problem case study chose np complete problem minimum maximal matching mmm described garey johnson 
problem relatively simple specify 
instance mmm consists graph integer problem determine subset edges share endpoint edge shares endpoint edge see example 

instance mmm 
solution edge indicated boldface 
instance speci cation right 
formulate mmm csp represent edge graph avariable 
edge chosen assigned value assigned value 
conditions avalue satis es constraints variable speci ed follows 
assigned shares endpoint assigned 
assigned exist share endpoint assigned 
cardinality set edges assigned equal 
satis es val rst constraint equal val endpoint endpoint equal assigned second constraint equal val endpoint endpoint equal assigned third constraint set assigned edge cardinality leq description mmm constraints shows constraints formulated multi tac problem speci cation 
mmm instance speci cation indicates number edges graph speci es extension user de ned endpoint relation 
shows mmm instance includes part corresponding instance speci cation illustrative purposes 

overview program synthesis process multi tac algorithm schemas form framework program synthesis process organized 
algorithm schema high level algorithm description automatically re ned produce algorithm 
concept algorithm schema adopted kids algorithm synthesis system smith 
kids schemas mathematical abstractions formal transformation process guided derive algorithm algorithm schema 
multi tac schemas simply high level descriptions generic constraint satisfaction algorithms abstractions re nement process primarily matter lling slots choosing alternative 
procedure solve unassigned variables return solution 
var var repeat empty val var 
var satis ed val assign var val 
constraints solve return solution 
var var val return failure simpli ed description backtracking schema top level multi tac schemas general kids simplistic approach enables re nement process proceed completely automatically 
algorithm schemas currently implemented multi tac backtracking schema developed iterative repair minton schema 
developing branch bound schema 
schemas con gured produce optimizing satisfying algorithm 
research concentrated backtracking schema implemented rst carefully debugged 
remainder focus backtracking schema exclusively 
restrict attention satisfying opposed optimizing algorithms 
generic csp backtracking search successively selecting variable assigning value 
backtracking occurs values variable fail satisfy constraints 
shows simpli ed pseudo code description multi tac backtracking schema 
schema refers rules variable ordering value ordering pruning direct search process 
ags control heuristic mechanisms checking kumar 
rules ags problem constraints schema optimized partial evaluation 
highlight rules ags problem constraints indicated italics schema shown 
simple illustration partial evaluation process works consider line schema 
constraints value ag partial evaluator turn conditional op ag false unconditional call 
backtracking schema exible search strategies 
example pruning rules eliminate individual values exceed resource limitations implement dependency directed backtracking 
schema allows di ering data representations shown gure 
focuses primarily variable value ordering heuristics 
control rules implement types heuristics preference rules score rules 
preference rules compute subset candidates variables values preferred decision point 
instance variable preference rules form var prefer var var isan arbitrary formula true false variable var var free formula var 
score rules compute integer score candidate 
come varieties depending candidate maximum minimum score preferred 
instance variable score rule form score var assign positive score score var score var isa formula true variable var assigned positive score score 
multi tac acquires control rules problem domain operationalizing generic heuristics mostow 
generic heuristics relatively ine cient execute directly 
operationalization process converts ine cient generic heuristics domain speci control rules cient execute 
generic heuristics currently operationalized system produce variable value ordering control rules constrained variable prefer variable fewest possible values left 
constraining variable prefer variable constrains variables 
constraining value prefer value constrains fewest variables 
heuristics known domain speci variable value ordering strategies aware involve combination ideas 
understand heuristics sensible consider decision represents simple choice constraining value chosen represents best chance nd solution 
variable ordering choice intuitive variables instantiated solution best choice minimizes size subsequent subtree explored 
selecting constrained constraining variables tends minimize size subtree explored backtracking occur earlier subtree 
operationalization process described section may produce relatively large set plausible variable ordering value ordering search control rules typically rules experiments heuristic may specialized approximated di erent ways 
control rules empirically tested explained section order nd subset rules performs best 
example mmm rules paraphrased english represent possible ways operationalize heuristic constrained variable choose edge neighbors adjacent edges 
choose edge neighbors assigned values 
choose edge neighbors assigned value 
rules di erent application cost cost evaluating rule runtime ectiveness reduces search 
example rst rule ected variables values 
static order edges prior search making relatively inexpensive 
rule static reapplied time variable takes new value considerably expensive 
comparison list rules produced operationalizing second variable ordering heuristic constraining variable choose edge neighbors 
neighbors assigned value 
choose edge neighbors assigned value 
system con guration consists algorithm schema list heuristic rules list mechanism ags controlling forward checking 
typically list heuristic rules include multiple rules decision point 
multiple rules type ordering rules prioritized order list 
example con guration includes variable ordering rules rst rule higher priority second rule tie breaker rst rule determine unique preferred candidate 
refer lexicographic preference strategy 
scheme outlined far allows wide variety algorithms synthesized including known algorithms 
instance consider method heuristic backtracking algorithm problems turner 
method chooses node color rule choose node fewest possible colors left break ties choosing node highest degree uncolored subgraph 
multi tac synthesize method operationalizing generic variable ordering heuristics described rule prefer node fewest remaining colors produced operationalizing constrained variable heuristic rule prefer node uncolored neighbors highest degree uncolored subgraph produced operationalizing constraining variable heuristic 
rst rule higher priority second rule lexicographic preference strategy gives exactly heuristic 
di erent possible control rules choose rules applied di erent orders search space possible con gurations obviously quite large 
multi tac carries utility evaluation process minton gratch searches ective system con guration hill climbing beam search 
search system evaluates candidate con guration compiling lisp program implements con guration running training instances 

generating search control rules multi tac uses di erent methods generating problem speci search control rules analytic inductive 
cases learning methods operate operationalizing generic heuristics 
analytic method synthesizes control rules analysis problem constraints 
inductive method uses brute force examine plausible control rules restricted language 
methods complement inductive method robust respects rule expressible language 
section outline methods 
detailed descriptions methods minton minton underwood 

analytic approach analytic learning systems characterized theory driven component generates hypotheses analyzing domain minton mitchell keller kedar dejong mooney 
multi tac analytic learning method employs meta level theories enable system reason problem constraints 
analytic method builds search control rules unfolding partially evaluating meta level theory respect constraints 
search control rules operational directly executable approximations meta level theories mostow minton 
example heuristic constrained variable modeled metatheory 
meta theory describes circumstances constrained variable 
circumstance occurs constraint expressed form arbitrary term arbitrary formulas satis es 
px meta theory indicates tightness constraint directly related cardinality set fxj understand consider constraint speci ed section 
notice graph coloring constraint exactly form meta theory tightness constraint vertex dependent cardinality set adjacent vertices degree 
system derives search control rule choose node neighbors plausible particularly variable ordering rule graph coloring 
alternative ways apply meta theory constraint typically variety plausible search control rules generated analysis process 
instance examine rst constraint problem nd multi tac apply analysis subexpression endpoint subexpression endpoint 
subexpressions match requisite form analysis yields di erent search control rules 
rst case analysis generates rule choose edge endpoints useless rule edges endpoints 
second case reasonable rule produced choose edge shares endpoint edges 
paraphrased rule earlier choose edge neighbors 

inductive approach inductive approach employs generate test method refer brute force simplest rst search 
generator enumerates possible search control rules expressible pre speci ed language 
problem instances identify rules bene cial accurately best approximate generic heuristics 
brute force generator enumerates rules starting smallest size rules rst size rule de ned number atomic formulas condition left hand side 
generator starts producing rules size generates successively larger rules recursively de ned grammar predetermined size bound predetermined time bound reached 
generator produces formed formulas expressible subset constraint language referred language bias mitchell 
sublanguage allows arbitrary ers variables includes built user de ned problem speci relations constants integers allowed mentioned problem speci cation 
mmm language includes user de ned relations vertex edge endpoint system de ned relations input parameter integers 
note constant included integers included 
number generated rules grows exponentially size bound increased relatively small rules produced 
instance mmm generator produces variable ordering score rules size process infeasible incorporating pruning heuristics slightly larger rules generated 
signi cant limitation observed computational expense involved matching large rules tends limit utility 
useful rules tend relatively small minton underwood 
example small potentially useful variable ordering rule generated mmm problem 
variables renamed help explicate rule 
rule preference rule size indicates variable var preferred neighbor assigned value 
endpoint var edge endpoint edge rtx assigned edge prefer var fact example rules described section size 
unfortunately useful rules accompanied number rules low utility nonsensical 
instance rule super cially similar rule turns useless mmm 
rule size indicates variable preferred neighbors assigned value 
reason rule useful mmm constraints imply adjacent edges assigned value 
endpoint var edge endpoint edge rtx equal edge ar assigned edge prefer var order identify rules useful multi tac tests generated rules training instances see achieve desired ects generic heuristics 
test rules training instance system runs standard csp solver search heuristics problem instances stops solver randomly selected points 
system generates examples illustrating ects generic heuristics 
speci cally generic heuristic system identi es best choices heuristic problem independent ine cient implementation heuristic 
instance system identify examples constraining variables counting variable constrained eliminated variable chosen 
best choices serve positive examples candidate search control rules prefer 
similar manner system selects choices best generic heuristic serve negative examples 
positive negative examples collected system tests candidate control rules see separating positive negative examples 
process identi es rules appear best job approximating generic heuristic 
expect rules percent correct rules di erent execution costs terms ciency system retains rules correct incorrect 
surprisingly tends lter candidates 
described section utility evaluation process serves nal ltering process selecting best con guration 
comparison inductive analytic learning components minton underwood components tend complement di erent strengths 
cases inductive component generate small rule analytic component missed analytic component considers limited set specializations 
hand inductive component generates smaller rules addition fail identify best rules due statistical nature testing process 
components increases system robustness 
detailed descriptions learning methods examples refer reader previous minton minton underwood 

con guration search candidate control rules produced multi tac nd con guration performs training instances 
con guration corresponds algorithm schema plus list search control rules mechanism ags 
space possible con gurations exponential number available control rules ags 
space large search exhaustively employs beam search cohen feigenbaum form parallel hill climbing heuristically searches small portion space 
beam search takes beam width set training instances instance time bound goal nd con guration performs best training instances 
best con guration solves instances time bound instance 
con gurations solve number instances total runtime preferred 
testing type utility evaluation minton gratch 
step beam search begins set parent con gurations 
initially set consists empty con guration contains control rules ags turned parent con guration system generates child con gurations produced adding additional control rule parent list activating ag 
child con guration includes parent rules ags plus additional 
alluded earlier order rules list important multi tac employs lexicographic preference strategy prioritizing rules choice point order list 
example con guration includes variable ordering rules rst rule higher priority second rule rst rule determine unique preferred candidate 
child con guration tested training set best con gurations survive round 
con gurations parents round process continues parent con gurations improved process interrupted user 
search strategy proven quite ective 
reason success lexicographic preference strategy 
beam search con gurations created choosing rst control rule adding second third 
subsequent rule added list rules list tend primarily tie breaking additional rules diminishing ects 
smooths search space con gurations reducing likelihood hill climbing process trapped local minima 
lexicographic preference scheme implies child con guration performs worse parent new heuristic control rule ag giving advice worse arbitrary tiebreaking simply expensive evaluate case adding control rules improve situation 
diminishing return adding additional control rules con gurations control rules particularly 
con gurations short means early search 
problem initial evaluation system search process quite time consuming primarily time required test con guration training instances 
result heuristics increase ciency search 
example require child con guration solve instances solved parent con guration 
multi tac tests new con guration rst tries instances solved parent recorded parent instances solved child immediately discarded 
conceivably ap proach eliminate con gurations solve larger number instances parent 
practice cases rare 
second drawback beam search occasionally control rules interact synergistically inwhich case may 
instance rules perform quite poorly tested individually perform 
synergistic pairs discovered search con guration 
particular variable ordering value ordering rules may tend interact way 
detect cases multi tac beam search pairs control rules consisting single variable selection rule single value selection rule rule performs individually 
unfortunately number pairs quite large making expensive process expensive 
experiments show synergies important detect occur 

compilation process preceding sections outlined process generating plausible control rules process searching space con gurations 
synthesizing cient algorithm involves nding appropriate conguration requires ciently implementing con guration 
includes generating cient constraint checking code selecting appropriate data structures access functions 
optimizations quite signi cant con guration optimized prior utility evaluation 
optimized code produced stage compilation process 
application reformulations transformations 
simpli cation logical formulas 
partial evaluation unfolding algorithm schema 
code simpli cation rst stage transformation reformulation operations applied carry high level optimizations selection data structures 
logical formulas including constraints left hand sides control rules simpli ed iteratively applying local simpli cations 
third stage partial evaluation unfolding applied tandem 
fourth stage resulting code simpli ed iteratively applying local code simpli cation rules 
describe optimizations important mmm problem show implemented 
purpose give reader feeling processes underlying empirical results described 
complete description optimization methods scope 

finite di erencing ary constraints expensive toevaluate especially checked variable instantiated 
example potentially expensive ary constraint third constraint problem 
checking constraint involves creating set edges variables value checking cardinality set equal recomputing set scratch time constraints checked sense store set incrementally recompute variable assigned 
better simply store cardinality set update iteration 
possibilities involve application nite di erencing 
speci cally transform original constraint checked incrementally 
standard program optimization techniques strength reduction forms nite di erencing 
method focuses logical variables representing sets bags derived computations sets bags occur constraints 
shall refer variables calculated terms constraint overload term variable di erent context 
example third constraint calculated terms targets nite di erencing explained 
better target calculated constraint 
speci cally de ne data ow diagram describes terms logical formula depend diagram directed acyclic graph de ning partial order terms 
current strategy focus nite di erencing process term terms computed late possible maxima partial order presumably result savings 
cases best decision ignores possibility earlier term better large number terms depend practice signi cant issue 
finite di erencing accomplished follows 
calculated term system selected maintain incrementally system generates new predicate de nes term original constraint rewritten accordingly new predicate de nition set edge assigned edge cardinality rewritten constraint speci cation satis es val rewritten third constraint leq system rewrites de nition new predicate separating computation related previously assigned variables incremental computation related newly assigned variables shown 
complete description process scope 
set edge edge cardinality set edge edge cardinality sum de nition rewritten computation related previously assigned variables replaced predicate representing stored value formula simpli ed 
result newly de ned predicate recalculated assignment incremental needs done set edge edge cardinality sum 
dynamic ordering vs pre sorting control rules variable value ordering 
describe optimization reduce cost variable ordering value ordering process optimized similarly 
ordering rules including preference rules score rules classi ed dynamic static semi static static rules static rule test value test variable previously assigned 
instance rule choose edge neighbors adjacent edges static rule 
static rules notable variables pre sorted criteria 
instance sort edges number neighbors 
dynamic rules dynamic rule values previously assigned variables 
instance rule choose edge neighbors assigned value dynamic rule 
dynamic rules pre sort variables ordering state dependent 
semi static rules semi static rules test variables previously assigned test values 
instance semi static rule choose edge neighbors previously assigned 
semi static rules pre sort variables procedure bit complex static rules 
sorting procedure begins arbitrarily selecting variable best variables ordering rst 
recalculates remaining variables best selects continues fashion total order determined 
compiling con guration multi tac classi es rules con guration static semi static dynamic 
types rules grouped instance static preference rules listed consecutively combined single composite rule 
partial evaluation process system determines pre sort variables classi cation control rules priority ordering 
instance rules list rst rules static third dynamic variables pre sorted rst rules third rule dynamically search process break ties 
system maintains information ties pre sorts variables 
rst rule dynamic second rule pre sort variables static appropriate ordering determined advance 

comparison hand coded algorithms section describes set experiments comparing programs synthesized multi tac handcoded programs 
computer scientists participated study subjects 
member multi tac project nasa computer scientists volunteered participate study 
advanced degrees computer science signi cant research experience arti cial intelligence project leaders research associates 
human subjects asked write fastest programs 

describe subject took longer hours design implement program cases spread days 
subject access black box instance generator 
instance generator randomly constructed solvable instances mmm generating subset size adding edges 
generator parameterized produce di erent distributions graphs input parameters speci ed ranges number edges number vertices value conducted separate experiments volunteers 
project member participated experiments 
experiment involved di erent instance distribution 
rst experiment subject project member pm instance generator produced graphs average edges speci cally parameters edges vertices 
told test table 
comparison hand coded programs distributions distribution distribution distribution cpu sec solved cpu sec solved cpu sec solved multi tac proj 
member pm subject subject subject simple csp programs randomly generated instances distribution second time limit instance 
day period subject spent hours pm spent respective programs 
complete experiment multi tac synthesize backtracking algorithm distribution second time limit instance 
generated training instances instance generator instances multi tac required approximately hours nd best con guration 
comparative purposes tested simple backtracking algorithm distribution 
essentially multi tac backtracking algorithm heuristics empty con guration 
serves baseline evaluate multi tac speedup learning system fisher subramanian tadepalli 
table distribution shows results randomly generated instances mmm problem cpu second time bound instance 
rst column shows cumulative running time instances second column shows number problems solved time bound 
results indicate pm project member wrote best program followed closely multi tac subject 
unoptimized csp program far cient 
regarding relative ciencies programs justi ed statistically methodology proposed etzioni etzioni 
speci cally pairwise comparison simple sign test programs completion times test instances statistically signi cant 
fact note rest experiments summarized table similar comparison multi tac program programs signi cant forgo mention statistical signi cance section 
empirical evaluation useful insight gained analyzing di erences programs produced 
particular analysis programs demonstrates critical importance program optimization expertise 
consider subject algorithm shown details omitted 
recursive procedure takes arguments edges subset set remaining edges parameter algorithm adds edges outline subject algorithm procedure solve cardinality ofe greater return failure return solution edge solve feg feg return solution nally return failure outline pm algorithm procedure solve return failure return solve feg newe feg feg edges return solution return failure solve newe feg return solution return solve feg outline multi tac algorithm procedure solve return solution value assign value solve feg return solution return failure mmm algorithms cardinality ofe exceeds solution 
pm algorithm shown improves subject algorithm respects pre sorted edges signi cant improvement involves sorting edges preprocessing phase edges adjacent edges considered rst 
interestingly subject reported trying ordering strategy options experiment su ciently realize value 
eliminated consideration 
redundancy pm algorithm considers adding edge reconsider edge subsequent recursive calls 
source redundancy subject program 
example subject program rst edge fails may reconsidered recursive call 
size incrementally maintained pm program uses counter incrementally track cardinality ofe recursive call 
cient constraint testing show pm represent test consists edges neighbors 
vector ciently updated bitwise operation stored adjacency matrix 
early failure pm program backtracks soon size level earlier subject program 
multi tac program behaves similarly hand coded programs respects 
shows basic control structure multi tac algorithm 
basic control structure shown aspects algorithm suppressed preserve clarity 
multi tac program iterates edges assigning value edge backtracking necessary 
synthesizing program multi tac selected variable ordering heuristic prefer edges neighbors 
specialization constrained variable 
system selected value ordering rule try ect program tries rst add edges searches 
rule specialization constraining value value constraining respect second constraint 
multi tac included signi cant features pm algorithm pre sorted edges multi tac code generator determined heuristic static independent assignments 
edges pre sorted heuristic described section edges adjacent edges considered rst 
redundancy multi tac program free redundancy simply result backtracking csp formalization 
size incrementally maintained accomplished nite differencing third constraint speci es je described section 
additional ciency di erences programs relatively insigni cant 
instance programs recursive multi tac program iterative cient lisp 
shows algorithm recursive program pedagogical purposes 
hand pm multi tac program maintain specialized data structures ciently reasoning set covered edges 
second experiment modi ed original distribution ran similar experiment time subject project member pm 
intended distribution harder unfortunately modi ed instance generator naively simply instances times large generator parameters edges vertices discover instances harder 
table distribution shows results instances cpu second time limit 
program submitted distribution pm program ran quickly distribution didn think improvements signi cant 
multi tac ended essentially program produced rst distribution 
second subject quickly hours developed program performed quite 
turned subject greater experience constraint satisfaction algorithms subjects reason able design program quickly 
program similar pm program simpler main optimizations bit array representation 
subject program fastest experiment multi tac program nished second 
surprisingly pm program slower apparently ect copied state bit arrays iteration signi cant ciency factor distribution larger instance size 
third experiment careful ensure distribution harder 
empirically instances di cult proportion edges nodes decreased modi ed instance generator accordingly raised time bound seconds instance 
instances distribution averaged edges larger graphs rst distribution generally smaller second distribution 
generator parameters edges vertices 
third subject spent hours total task 
experimented backtracking approach eventually discarded favor heuristic iterative repair algorithm 
program edges kept queue size say edge covered adjacent legal solution edge queue removed 
program selects new edge adjacent uncovered edges adjacent edge puts front 
project member pm participated experiment 
took original program spent approximately hours modifying distribution 
modi ed program uses iteration recursion edges number adjacent edges iteration program dynamically selects edge adjacent uncovered edges adds important changes included 
distribution multi tac required hours complete con guration search 
synthesized program interestingly quite di erent previous distributions 
multi tac elected order values tried 
essentially means program considers edge rst tries assigning view program incrementally selecting edges include set complement ordering strategy multi tac selected variable ordering rules 
prefer edges adjacent edges endpoint 
rule static edges pre sorted criterion 

break ties preferring edges endpoints edges connected endpoints assigned 
words edge preferred adjacent edges endpoint assigned better adjacent edges endpoints assigned 

ties prefer edge fewest adjacent edges 
heuristics generated approximations constrained variable 
intuitively speaking rules appear prefer edges sense value ordering rule edges value completely constrained 
shown table distribution multi tac program performed best experiment solved number problems subject program far best run time experiment 
interestingly multi tac synthesized con guration similar pm program rejected utility evaluation 
notable aspect experiment human subjects came algorithm similar multi tac algorithm initially mysterious author project members 
retrospect algorithm sensible explain success follows 
search choice wrong system backtrack entire subtree choice nds solution 
critical choices early choices choices shallow depth 
believe multi tac algorithm third distribution successful reasons variables solution assigned value ordering rule try sensible 
table 
results illustrating distribution sensitivity distribution distribution cpu sec solved cpu sec solved multi tac program multi tac program search multi tac variable ordering heuristics identify edges included assigned value 
important ordering strategy ected variable ordering strategy value ordering variable ordering rules mutually dependent 
results demonstrate multi tac con guration search able deal successfully interaction 

distribution speci city central assumption underlying tailoring programs particular distributions produce superior performance 
experimental results described provide evidence favor claim addition demonstrating multi tac capable generating code par hand generated code 
point clearly table shows multi tac program synthesized instances second distribution performs poorly instances third distribution viceversa 
hand coded programs show trends strongly 
factors explain performance greatly ected distribution 
relationship heuristic power evaluation cost 
programs tailored easy distribution employ heuristics relatively inexpensive useful directing search 
example pre sorting edges number adjacent edges expensive picking edge adjacent uncovered edges iteration greater payo harder problems 
second heuristics con guration may linked produce search qualitatively di erent search di erent con guration 
advice rule mislead system distribution 
evidence experiments 
example third variable ordering rule multi tac third distribution degrades program search second distribution 
program searches fewer nodes rule omitted 

comparison algorithms traditionally alternatives programmer faced csp 
hand code algorithm try pre existing csp algorithm designed di erent problem class generic problem class 
preceding section showed multi tac performed par human programmers synthesizing algorithms mmm 
conceivable picked generic algorithm tried mmm outperform hand coded algorithms described section 
best generic algorithms carefully crafted perform 
section compare multi tac known algorithms mmm benchmark 
selected algorithms comparison forward checking tableau gsat 
forward checking established method popular csp community 
tableau gsat developed boolean satis ability algorithms 

comparison forward checking rst algorithm selected known forward checking dynamic minimal domain variable ordering fc 
popular algorithm csp community part di erent domains 
advantage relatively simple implement 
forward checking enhancement basic csp backtracking algorithm 
variable instantiated uninstantiated variable ltered contain values consistent current assignment 
domain uninstantiated variable empty backtracking immediately occurs 
dynamic minimal domain ordering called search rearrangement backtracking purdom reingold enhancement 
variable ordering strategy form constrained variable rst 
point variable fewest remaining values left preferred 
straightforward test fc mmm tac generate code 
create con guration trivial forward checking ag set true single variable ordering rule implement dynamic minimal domain ordering 
code produced multi tac optimized compilation methods described preceding sections 
table shows results fc mmm distributions 
unfortunately computer previous experiments unavailable results reported table generated di erent similarly con gured machine 
reason regenerated test results original programs produced multi tac regenerated results shown rst row table 
programs opposed generating new programs distribution 
time limits table 
comparison fc tableau algorithms distribution distribution distribution cpu sec solved cpu sec solved cpu sec solved multi tac fc tableau distributions described previous section set instances evaluation process 
fc performed relatively poorly mmm 
rst distribution slower programs synthesized multi tac solved instances time limit seconds problem 
second distribution fc worse solving problems second time limit 
third distribution second time limit problem fc fared quite poorly 
result particularly surprising considers forward checking generally boolean satis ability algorithms 
furthermore di cult see minimal domain variable ordering strategy provides weak guidance boolean problems 
uninstantiated variables partitioned groups values left single value left 
guidance provided strategy select variables immediately instantiated 
helpful apparently helpful variable ordering strategies multi tac 

comparison boolean satis ability algorithms turn attention developed boolean satis ability algorithms tableau gsat 
boolean satis ability subclass csp formalized mmm boolean problem boolean satis ability algorithms appropriate choice comparison 
furthermore considerable attention focused problem class years algorithms standards comparison 
represent latest progress area 
tableau gsat input representation 
instance consists set boolean variables constraints represented cnf formula set clauses 
size clauses xed 
formulate mmm boolean satis ability problem represent edges graph boolean variable multi tac formulation 
representing rst mmm constraints clauses straightforward 
third constraint result exponential number clauses represented naively explicitly disallowing subset edges 
impractical chose alternative representation suggested matt ginsberg 
set auxiliary variables fai jj count cardinality subset sets clauses implement counting process ensuring ai true sum rst edge variables vi ai vi ai ai vi ai de ne set clauses ensure sum rst variables equal ai clauses guarantee cardinality ofe bounded representation concise representation possible virtue relatively simple 

tableau results tableau algorithm described crawford auton heuristic backtracking method originally motivated tableau inference method algorithm 
crawford auton employed versions method mainly experiments determining crossover point sat 
comparisons lisp version implemented crawford 
current algorithm davis putnam method davis logemann loveland depth rst search plus unit propagation 
branching point selects variable assign assigns value true carries unit propagation 
csp terminology unit propagation involves selecting variables single possible value immediately assigning value con ict unit propagations possible 
solution variable assigned true system backtrack branching point try assigning value false continue 
basic method tableau adds optimized unit propagation algorithm important special purpose heuristics selecting variables branch 
speci cally branch point algorithm selects variable binary clauses 
binary clause clause satis ed exactly unassigned 
ect preference binary clauses biases system favor variables assignment result unit propagations 
form generic heuristic constraining variable 
binary clauses exist version tableau nds clauses fewest unassigned variables selects variable occurs frequently clauses 
ties broken arbitrarily 
table 
expansion instance size resulting conversion clause form distribution distribution distribution smallest largest smallest largest smallest largest original form clause form expansion factor form constraining variable 
tableau uses specialized data structures support variable ordering heuristics 
instance algorithm dynamically maintains count binary clauses involving variable 
table row shows results tableau 
rst distribution tableau program slower multi tac program faster multi tac implementation fc easily solved instances time limit 
second third distributions tableau worse solving instances respectively 
tableau poor performance part attributable di erence problem representation 
explained converting instance original representation clause form involves adding auxiliary variables 
number additional variables polynomial instance size expansion factor considerable especially second distribution 
table shows simple statistics indicating expansion factor distributions 
distribution table lists size smallest instance largest instance terms number variables original formulation problem 
table indicates instance listed number variables result conversion clause format 
number edges correlated due way instance generator works smallest instance original formulation expands smallest instance clause form holds largest instance 
expansion factor simply ratio comparing instance size conversion original instance size 
second distribution instances quite large converted clause form 
result simply processing variables iteration time consuming 
experimental results include time load instance lisp load time factor 
attempt quantify table presents statistics re ecting speed algorithms distribution 
rst row shows average number assignments variable instantiations second tableau 
data indicates tableau ran twice slowly second distribution rst distribution result larger data structures involved 
telling statistic revealed second row 
auxiliary variables excluded calculation resulting statistic indicates numberof assigned values second 
see main ect instance expansion 
di erences rst row second row indicate relative rate assignments edge variables low tableau spending table 
statistics summarizing decisions second distribution distribution distribution tableau values sec tableau edge values sec multi tac values sec time instantiating auxiliary variables 
ect especially dramatic second distribution due high proportion auxiliary variables 
comparative purposes third row shows assignment rate multi tac programs 
multi tac tableau substantially different representations data directly compared gures previous rows convey rough idea relative speed programs 
comparing second third rows table see tableau assigning fewer values edges second presume auxiliary variables introduced conversion clause form factor 
better understand situation tried increasing time bound factor reran tableau test instances second third distributions 
rst distribution included tableau solved instances original time bound 
extra time tableau solved additional fty instances second distribution considerable improvement 
third distribution eighteen solved extra time signi cant improvement 
results data table similar data space infer performance problems encountered tableau rst second distributions due large part expansion instance size tableau relatively poor results third distribution explained simply 
credible hypothesis tableau search heuristics provide guidance harder problems contrast distribution speci heuristics synthesized multi tac 
tables provide additional evidence support 
table considers problems solved tableau multi tac shows problems average number assignments multi tac roughly equivalent number assignments tableau edge variables 
contrast table shows results instances solved multi tac solved tableau 
fty instances third distribution number edge assignments tableau greater number assignments multi tac clearly tableau explored options multi tac ignoring assignments auxiliary variables 
supports claim multi tac search heuristics provided superior guidance instances 
comparison instances solved multi tac tableau second distribution number edge assignments tableau number assignments table 
comparison instances solved multi tac tableau distribution distribution distribution number instances solved tableau avg 
assignments tableau avg 
edge assignments multi tac avg 
assignments table 
comparison instances solved multi tac distribution distribution distribution number instances multi tac tableau avg 
tableau avg 
edge assignments multi tac avg 
assignments multi tac 
better search control played role distribution results inconclusive 
say hampered auxiliary variables consequently explore search space 
analyzing tableau heuristics perform distribution wonder algorithm confused auxiliary variables led extra branching 
turns tableau selected auxiliary variables branch prior variable instantiated unit propagation expect 
conclude tableau branching set variables multi tac edge variables xed search heuristics simply focus search aswell 

gsat results alluded earlier tested gsat selman levesque mitchell heuristic iterative repair algorithm minton distributions 
gsat begins initialization phase assigned initial value 
repair phase iteration involves choosing variable ipping value 
gsat heuristic ip value variable increase number satis ed clauses 
unfortunately little learned comparing gsat backtracking programs backtracking heuristic repair paradigms di erent 
anxious try gsat 
expected perform reasonably especially third distribution reported section subject iterative repair method worked distribution 
surprisingly gsat performed quite poorly 
shows results gsat 
unfortunately access version gsat di cult directly compare runtime 
result table 
gsat performance results distribution distribution distribution solved solved solved gsat ips tries gsat ips tries gsat ips tries gsat ips tries gsat ips tries di erent conditions table shows number instances solved trials instance limits ips 
limits su cient executing trials ips generally took signi cantly longer time bound experiments account speed advantage gsat due implemented 
note trials ips number iterations executed gsat higher comparable number backtracks executed tableau 
instance size example trials ips equals total assignments 
backtracking programs executed fewer assignments time allotted 
gsat available variety con gurations 
instance tabu list alternative initialization methods employed 
results reported basic con guration may conguration prove superior 
fact results surprise full con guration search produced better con guration gsat mmm especially subject produced iterative repair program performed distribution 
try con gurations failed produce signi cantly better con guration attempt full con guration search 
summary experiments tableau gsat demonstrated potential drawbacks pre existing algorithms solve problem 
heuristics may suited problem hand 
second pre existing algorithm mayhave map problem awkward representation introduce ine 
believe general problems addressed traditional methods 

discussion evaluated multi tac performance di erent instance distributions mmm problem 
results encouraging programs synthesized multi tac performed best hand coded programs tested 
synthesized programs outperformed developed boolean satis ability programs tableau gsat 
course dangerous generalize basis experiments single problem 
note multi tac done limited tests problems minton 
event focusing single problem able depth performance comparison addition explain speci synthesis compilation mechanisms multi tac contributed results 
experiments described turned remarkably successful respects 
surprised system performed comparison human programmers 
relatively easy learning system improve ciency typically quite ine cient start considerably challenging learning system perform compared handcoded programs 
speed learning programs achieved 
multi tac turned unexpected advantage arena due task 
subjects multi tac experimented wide variety combinations heuristics 
human subjects rarely inclination patience try alternatives occasion incorrectly evaluated alternatives try reported discussion subject program 
second surprise programs synthesized rst distributions substantially di erent program synthesized third distribution 
turned important factor demonstrating advantages compared boolean satis ability algorithms particular tableau 
expectations exceeded multi tac synthesized clever program third distribution 
reported section program operated quite di erently hand coded programs rst didn understand doing 
hindsight accomplishment particularly remarkable believe nice example seemingly creative act result searching large space programs 
study focused distributions single problem stress distributions di ered respect basic parameters described section opposed specially designed way 
specially engineer multi tac solve problem deep analysis problem embarking case study 
selected mmm list np hard problems garey johnson reasonably straightforward specify constraint language unfamiliar 
wanted avoid possibility problem uenced design system 
tac capable synthesizing algorithms problems author project members familiar graph coloring expected new problems challenging 
unfortunately drawback resulting mmm obscurity aware published mmm algorithms algorithms useful comparative purposes 
course mentioned goal simply multi tac programmers opposed algorithms experts lack published algorithms compare particularly troubling 
second reason selecting mmm relatively easy specify 
explain believe factor contributed multi tac exceptional performance system speci cation relatively concise 
sections consider strengths weaknesses approach types problems multi tac best suited 

speci cation size expected performance language things natural specify constraint speci cation language 
pointed mmm relatively simple specify resulting speci cation relatively concise 
problems require complex speci cations 
instance multidimensional crew scheduling problem yoshikawa wada assign crew members tasks tasks time slots 
types variables 
modeled multi tac de ning relation variables distinguish types variables complicates speci cation 
similar complication arises scheduling problems task assigned interval accomplished assigning start time endtime task splitting variables di erent types 
discussing detailed issues modeling simply point larger speci cation multi tac synthesize algorithm 
speci cally avariety system led astray large speci cation 
regard components discussed problems arise brute force inductive learning module brute force smallest rst search obviously limited size control rules learn 
wehave observed larger speci cation larger control rules simply control rules vocabulary introduced speci cation 
instance multi dimensional crew scheduling problem discussed expect control rules distinguish types variables require mentioning relevant relation left hand sides 
high utility control rules large brute force learner nd 
analytic learning module analytic learning process analyzes constraints order devise control rules 
size syntactic complexity constraints increase number alternatives pursued analysis increases analysis produces candidate control rules 
unfortunately guess analysis produce useful rules heuristic process led astray complexity constraints increases 
con guration search size con guration search space directly related number candidate control rules produced learning modules 
analytic learning method produces control rules constraints large con guration search space larger system consequently nd best con guration 
constraint compilation explained section processes rewrite constraints order constraint checking cient 
example nite di erencing rewrites constraints constraint checking done incrementally 
larger constraints opportunity constraint compilation perform signi cant optimizations increased complexity process best formulation result 
multi tac perform worse constraints expressed concisely multi tac constraint language rst order predicate calculus relatively expressive compared languages constraint satisfaction systems 
constraints expressed concisely 
comparison tableau gsat translating mmm constraints restricted clause formulation resulted considerable blowup instance size consequently computational di culties 
multi tac ord highly expressive language precisely compile constraints ciently evaluated 

achieving distribution sensitivity experiments demonstrated utility tailoring programs distribution 
better worse training instances constitute multi tac sole source information instance distribution 
advantage relying training instances reasonably easy collect construct applications 
typically need test cases evaluate hand coded algorithm event 
disadvantages subtle 
training instances constructed hand representative possible types instances encountered application 
may easy accomplish may properties real instances uence relative ciencies di erent con gurations 
related issue application change time ways obvious 
computer training process consideration 
switches faster computer keeps time bound multi tac synthesize di erent program time bound evaluate algorithm instance 
system tailoring algorithm distribution tailoring particular machine time bound 
training instances provide limited amount information instance distribution 
random sample instances system trained produce program possible solves instances time bound 
certainly instances distribution harder training instances resulting program perform poorly hard instances multi tac attempt optimize worst case behavior behavior training instances 
instance system trained third mmm distribution nal con guration solved training instances test instances solved 
exactly situation expect reliance training sample con guration existed solve problems time limit con guration slightly slower training problems case multi tac accept 

con guration plasticity con gurable systems come varieties carbonell 
dimensions characterized plasticity 
systems relatively rigid con gured limited ways 
gsat example relatively rigid con gurable system user set parameters max ips max tries choose xed set options tabu list 
multi tac exible 
xed options algorithm schema forward checking system accepts types control rules arbitrary left hand sides 
combination schemas ags control rules multi tac synthesize wide variety heuristic algorithms 
greater exibility opportunities optimizing performance system 
unfortunately greater exibility dramatically increase complexity con guration search compilation processes 
weaknesses multi tac relatively complex system 
result system prone bugs generated programs essentially di cult multi tac developers understand full set optimizations incorporated program 
con guration hard understand undergoing compilation processes nal program produced relatively 

limitations learning approach learning approach described worked experiments assumption inherent experimental design potentially limits viability approach 
wehave assumed compile time available evaluate con gurations con guration search 
evaluating con guration involves running con guration set test instances time consuming process 
second time limit third distribution multi tac took hours execute con guration search 
time bound times longer multi tac times longer complete con guration search 
unfortunately time bound long competing con gurations compared 
particular time bound short con gurations solve instances rst level beam search con guration search unsuccessful 
ideally time bound long rst round beam search con gurations solve instances 
address problem currently investigating methods evaluating con guration instance running search completion 
certain families heuristic algorithms predict algorithm best running short time allen minton 
identifying secondary performance characteristics tell heuristic having positive ect 
approach generalizes incorporate similar methods multi tac signi cantly harder problems solved 
possible multi tac entirely di erent way create instance speci algorithm 
involve trying di erent con gurations single instance order predict con guration best run longer time instance 
useful hard shot problems amortize time spent con guration search relatively long problem solving run 

related multi tac unique constraint satisfaction systems able distribution oriented information 
small growing body area constraint compilation related spirit 
related systems system yoshikawa predecessor yoshikawa wada alice system abstraction problem solver 
take declarative descriptions csps compile specialized algorithms solving 
compilers search best con guration avery di erent emphasis 
insofar multi tac program synthesis methods concerned approach motivated automated software design notably smith kids system smith employs algorithm schemas framework program re nement 
program transformations including partial evaluation unfolding common program synthesis systems compilers kahn types transformations multi tac motivated previous area knowledge compilation mostow tong tong 
program synthesis systems generate combinatorial search programs 
instance kids develop transportation scheduler signi cantly outperforms general schedulers smith parra illustrating bene ts domain speci customization 
srinivasan sterling framework tailoring generic scheduler particular scheduling domains 
research projects mentioned addressed problem tailoring general algorithms particular applications learning assist customization 
program synthesis systems domain speci design decisions decision making process guided interactively user smith guided heuristic rules advance system designers kant 
systems explicitly search space possible designs 
notable exception smith simulated annealing choose competing data structures heuristic cost function 
contribution lies training instances guide search design space 
machine learning community day zweben developed csp systems attempt improve problem solving experience 
projects involved application single machine learning method xed problem solver largely simplifying avoiding issues involved general con guration search problem 

study demonstrated automatically synthesizing heuristic programs viable approach solving csps 
showed multi tac able produce code performed par human subjects outperformed generic satis ability algorithms 
demonstrated relative utility di erent heuristics depend distribution instances 
humans may patience experiment di erent combinations heuristics results suggest synthesis application speci heuristic programs promising direction ai research 
experiments saw tac creative system take combinatorial problems unfamiliar designers produce interesting respects unanticipated heuristic programs solving problems 
purely result system ability specialize combine set simple generic building blocks 
suggests promising automatically generated constraint satisfaction systems 
acknowledgments research conducted nasa ames research center author employed people nasa signi cant contributions project 
john allen text re ned con guration search process jim blythe helped devise specialization theories search control mechanism gene davis worked original csp engine andy philips developed code generator andrew partial evaluation mechanism code simpli er ian underwood helped develop con guration search process shawn wolfe implemented simpli er utility evaluator parts system 
furthermore ian shawn conducted experiments reported 
jimi crawford matt ginsberg nayak monte zweben wayne iba peter cheeseman contributed helpful ideas matt challenged comparison tableau 
jimi bart selman contributed code gsat tableau respectively 
particularly peter mel montemerlo supporting project anonymous colleagues nasa experiments kowalski minton help revising 
notes 
language speci cations slightly di erent system simpli ed syntax presentation purposes 

reading constraint speci cation helps remember implies 

multi tac currently schemas need method choosing 
user selects schema system simply nds best con guration schema independently selects best con guration 

practice rules generate scores test 
generation process accomplished rewriting declarative form rule 

multiple rules single decision point allowed depends schema particular rules decision question 

call theories meta level theories constraints describe problem see constitute theory whichwe call base level theory 

flags automatically activated needed basis control rules may dependent certain ag controlled mechanisms 
example standard variable control rule dynamically selects variable minimum domain 
rule included con guration forward checking ag turned ag causes variable domains recalculated assignment 

due interactions rules replacing beam search genetic search promising direction explore 
advantage beam search simplicity 

multi tac employs set transformations applied constraints prior nite di erencing rewrite constraints move computations sets bags constraint order increase possible savings accomplished nite di erencing 
pre sorting advantage reducing computational cost control rules drawback reducing randomness search 
sorting process produces total order control rules may induce partial order 
experimental results produced multi tac reported minton 
version multi tac include method pre sorting semi static rules described section 
static rules pre sorted 
addition multi tac analytic method generating rules 
minton underwood showed inductive method improve performance mmm helped problems 
comparisons fc tableau carried multi tac generate code consistency avoid charges modi ed multi tac improve results mmm 
interesting di erence multi tac program hand coded programs multi tac explicitly tests second mmm constraint hand coded programs implicitly ensure constraint satis ed terminate 
cases explicitly testing constraint lead earlier backtracking 
practice appear ect programs performance signi cantly tested 
variable arbitrary choice 
note multi tac slowest third distribution second distribution presumably graphs third distribution denser cost checking constraints greater 
cost checking rst second mmm constraints directly related density graph 
multi tac evaluate constraints ciently tableau clause form constraints quite cient result multi tac exhibits greater sensitivity density graphs 
completeness note problems solved tableau third distribution 
problems tableau average assignments average edge assignments multi tac averaged assignments 
gures ect text 
obviously increasing number tries proportionately increases number problems solved di erence third distribution 
allen minton 
selecting right heuristic algorithm runtime performance predictors 
proceedings canadian ai conference 

automatic programming device control software 
lowry editors automating software design 
aaai press 
reingold 
backtrack 
communications acm 
tong 
automated synthesis constrained generators 
proceedings eleventh international joint conference arti cial intelligence 

new methods color vertices graph 
communications acm 
carbonell etzioni gil joseph knoblock minton veloso 
planning learning prodigy overview integrated 
ram leake eds editors goal driven learning 
mit press 
cohen feigenbaum editors 
handbook arti cial intelligence volume iii volume volume 
william kaufmann los altos california 
crawford auton 
experimental results crossover point satis ability problems 
proceedings eleventh national conference arti cial intelligence 
crawford auton 
experimental results crossover point random sat 
appear arti cial intelligence 
davis logemann loveland 
machine program theorem proving 
cacm 
day 
learning variable descriptors applying heuristics csp problems 
proceedings machine learning workshop 
dejong mooney 
explanation learning alternative view 
machine learning 

abstraction 
inproceedings thirteenth international joint conference arti cial intelligence 
etzioni etzioni 
statistical methods analyzing speedup learning experiments 
machine learning 
fisher subramanian tadepalli editors 
proceedings third international workshop knowledge compilation speedup learning 
galil 
cient algorithms nding maximum matchings graphs 
computing surveys 
garey johnson 
computers intractability guide theory np completeness 
freeman 
gratch 
cient approaches utility problem adaptive problem solving 
technical report department computer science university illinois urbana champaign urbana illinois 
gratch dejong 
approach guaranteed ective control strategies 
proceedings eighth international machine learning workshop 
kahn 
partial evaluation example relationship programming methodology ai 
ai magazine 
kant macgregor wald 
automatic programming device control software 
lowry editors automating software design 
aaai press 
kumar 
algorithms constraint satisfaction problems 
ai magazine 
lassila smith 
flexible constraint tools complex scheduling applications 
proceedings th annual dual technologies applications conference pages 

language program stating solving combinatorial problems 
arti cial intelligence 
minton 
learning search control knowledge explanation approach 
kluwer academic publishers boston massachusetts 
minton 
quantitative results concerning utility explanation learning 
arti cial intelligence 
minton 
analytic learning system specializing heuristics 
proceedings thirteenth international joint conference onarti cial intelligence 
minton 
constraint case study 
inproceedings eleventh national conference arti cial intelligence 
minton johnston philips laird 
minimizing con icts heuristic repair method constraint satisfaction scheduling problems 
arti cial intelligence 
minton underwood 
small beautiful brute force approach learning rst order formulas 
proceedings twelfth national conference onarti cial intelligence 
mitchell keller kedar 
explanation generalization unifying view 
machine learning 
mitchell 
need biases learning generalizations 
technical report cbm tr rutgers university 
mostow 
machine transformation advice heuristic search procedure 
machine learning arti cial intelligence approach pages 
tioga press palo alto ca 
mostow 
transformational approach compilation 
lowry editors automating software design 
aaai press 
purdom jr search rearrangement backtracking polynomial average time 
arti cial intelligence 
selman levesque mitchell 
new method solving hard satis ability problems 
proceedings tenth national conference onarti cial intelligence san jose ca 
automatic selection data structure algorithms 
lowry editors automating software design 
aaai press 
smith parra 
transformational approach transportation scheduling 
proceedings eighth conference software engineering 
smith 
kids knowledge software development system 
lowry editors automating software design 
aaai press 
smith knowledge constraint driven software synthesis 
proceedings seventh conference software engineering 

order logic 
springer verlag new york 
srinivasan sterling 
knowledge framework developing customizing schedulers 
proceedings eighth conference software engineering 
tong 
divide conquer approach compilation 
lowry editors automating software design 
aaai press 
turner 
colorable graphs easy color 
journal algorithms 
van deville 
teng 
generic arc consistency algorithm specializations 
arti cial intelligence 
yoshikawa kaneko watanabe 
constraint approach high school timetabling problems case study 
proceedings twelfth national conference arti cial intelligence 
yoshikawa wada 
constraint satisfaction multi dimensional domain 
proceedings international conference planning systems 
zweben davis 
learning improve constraint scheduling 
arti cial intelligence 
received date accepted date final manuscript date 
