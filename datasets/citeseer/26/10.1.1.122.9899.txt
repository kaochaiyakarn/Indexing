design automation embedded systems vol 
jan kluwer academic publishers boston 
manufactured netherlands 
retargetable code generation structural processor descriptions rainer leupers peter marwedel ls informatik uni dortmund de university dortmund department computer science dortmund germany 
design automation embedded systems comprising hardware software components demands code generators integrated electronic cad systems 
code generators provide necessary link software synthesis tools hw sw codesign systems embedded processors 
general purpose compilers standard processors insu cient provide exibility respect di erent target processors su er inferior code quality 
research code generation embedded processors primarily focussed code quality issues contribution emphasize importance retargetability describe retargetability 
propose usage uniform external target processor models code generation describe embedded processors means rt level 
structural models incorporate hardware details purely behavioral models permitting close link hardware design tools fast adaptation di erent target processors 
mssq compiler part mimola hardware design system operates structural models 
describe input formats central data structures code generation techniques mssq 
compiler successfully retargeted number real life processors proves feasibility approach respect retargetability 
discuss capabilities limitations mssq identify possible areas improvement 
keywords retargetable compilation processor modelling embedded code generation 
embedded systems special purpose computing systems designed installed serve single particular application 
interact larger non electronic environments 
today embedded systems areas everyday life telecommunication control vehicles aircraft home appliances medical equipment 
complexity systems stringent time market constraints demand design automation tools provide cad support right system level 
economically reasonable implementations embedded systems general consist hardware software components resulting problem hardware software codesign 
parts system subject tight computation speed constraints implemented software running programmable embedded processors dsps microcontrollers parts require fast dedicated hardware 
favorable implement system possible software software easier develop usage shelf processors signi cantly leupers marwedel reduces design costs 
software exible hardware allowing accomodation late speci cation changes easier debugging 
widespread approach design automation combined hw sw systems iteratively perform hw sw partitioning followed hardware software synthesis simulation 
concept realized hw sw codesign systems codes 
systems code generation embedded performed fashion hw sw partitioning software synthesis transforms pieces system functionality assigned software internal representation program threads 
program threads linearized sets machine independent operations turn translated high level language source code typically assumed processor speci compilers available mapping machine code standard processors sparc intel 
code intermediate representation cost estimation hw sw partitioning remain coarse possibly leading necessity hw sw partitioning iterations 
disadvantage partially avoided systems directly generate machine code high level language programs permit detailed cost metrics ptolemy capable code generation standard dsps motorola macro expansion 
castle uses compiler maps source code vertical machine code vliw architectures handle prede ned processors non horizontal instruction formats 
synopsys commercial dsp synthesis tool supports assembly code generation 
systems code generation restricted narrow range target processors 
major requirements embedded system design tools capability exploring large design space order nd implementation meets design constraints 
design space exploration includes investigation di erent programmable processors execute software components embedded system implemented 
ideal embedded system cad environment processor type transparent user alternatives tried re compiling software di erent processor 
processor meets constraints minimum costs selected 
degree exibility hardly provided current hw sw codesign tools 
problem ed embedded systems realized single chip systems 
advent deep vlsi technology created trend design complete systems single chip resulting higher speed dependability silicon area power consumption 
vendors texas instruments lsi logic advanced risc machines er standard processors form cores layout instantiated design engineer component library 
particular application require full amount capabilities standard processor 
standard processor cores leads possible waste silicon area power consumption retargetable code generation structural descriptions single chip systems 
consequence system houses starting exible customizable programmable architectures 
term asip instruction set processor created 
industrial system design asips reported instance 
asips coarse architecture xed advance designer trade silicon area computation speed 
asip tailored speci application repeatedly mapping program sources di erent detailed architectures 
process considered hw sw codesign processor level 
removing adding hardware components asip immediate consequences execution speed software 
obviously scenario customization asips demands retargetable compilers 
retargetability code quality major concern particular embedded systems involving signal processing real time constraints 
systems dsps preferred type embedded processors 
standard dsps available software development tools assemblers debuggers simulators compilers 
code quality current compilers dsps poor 
overhead compiler generated code compared handcrafted code reaches percent unacceptable cases 
essentially due fact dsps show highly specialized architectures instruction sets demand dedicated code generation techniques 
instance exploitation potential instruction level parallelism dsps provided current compilers 
code generation standard dsps su ers insu cient code quality compilers situation asips unsatisfactory asips house designs small number applications obsolete hardly high level language compiler support asips 
insu cient quality availability compilers lead fact nowadays dsps programmed assembly languages implies known disadvantages low level programming 
time market important issue vlsi system houses step high level programming mandatory 
summary design automation embedded systems demands code generators systems 
code generators bridge gap software synthesis tools hw sw codesign machine programs running embedded processors 
major areas need tackled order provide powerful code generators currently available retargetability general purpose compilers processor speci di erent target processors investigated embedded system design anumber di erent potentially costly compilers employed 
interfacing problems may arise compiler part larger design environment 
single retargetable compiler capable mapping algorithms di erent target processors alleviates problems 
furthermore usage processor speci compilers restricts range possible target processors leupers marwedel standard components 
due trend single chip systems asips expected gain importance near 
usage asips demands exible compilers close link compilers hardware design tools 
code quality embedded systems operating hard real time constraints insu cient quality compiler generated code may demand higher clock rates necessary 
turn increases power consumption particularly problem portable devices 
case single chip systems program code stored chip rom overhead code quality immediately contributes silicon area requirements 
high code quality important embedded systems general purpose computers 
justi es usage computation time intensive algorithms aiming code optimization scope traditional compilers high compilation speed primary goal 
high quality code generation fact contrast general purpose processing embedded processors highly irregular architectures moderate degree instruction level parallelism 
retargetability related code quality 
compiler tailored certain target processor higher code quality vice versa 
mssq compiler subject degree retargetability xed 
mssq generates code de ned class target processors class aims code optimization mainly exploiting potential parallelism 
show retargetability realized means target processor models speci ed rt level hardware description language 
main advantages approach compared related 
usage hardware description language target processor modelling provides natural link environments 
contrast approaches particular tool speci description formalisms single uniform model su cient complete design process hardware design code generation simulation 
aspects needed code generation automatically derived model 

publications retargetable code generation clearly state range processors handled mssq operates de ned class target processors 
class code generated target processor 

obviously concept rt level results detailed target processor models capture primitive hardware components wires busses multiplexers 
detailed models demand higher description ort compared pure instruction set models natural representation hardware designer point view 
compilers capable instruction set models avoid risks retargetable code generation structural descriptions communication hardware designers compiler writers 
rt level models permit fast adaptation local changes processor architecture global impact equivalent instruction set model 
especially important designs asips 
organization follows section give short overview mimola hardware design system mssq compiler central component 
furthermore outline functionality mssq describe class processors handled compiler 
section discusses previous areas compiler construction microprogramming concerning embedded code generation 
detailed description input format mssq section 
section presents main internal data structures mssq connection operation graph 
code generation techniques data structures described section 
section provides experimental results embedded processors ends concluding remarks 

system overview mimola design system mds high level hardware design environment providing design automation algorithmic register transfer level digital programmable processors 
user interface mds mimola hardware description language 
necessary frontends utilities tools constitute core mds operate common intermediate representation 
performs high level synthesis generates rtl structures behavioral descriptions algorithmic level 
exploits realistic nable component libraries furthermore partially prede ned structures taken account 
details techniques 
mssq contrast mssq maps algorithms completely prede ned rtl structures generating microcode 
design decisions mssq predecessor slow tobe applied real life problems 
msst msst aims exploiting self test capabilities programmable processors 
user de ned high level self test programs compiled machine code prede ned rtl structures 
self test program compiler experiences msst described 
simulator algorithmic level descriptions uses compiled code simulation 
counterpart event driven rtl structure simulator 
leupers marwedel mimola language frontend mimola translator schematics generator mimola design system netlist model target processor controller datapath imperative hll source program linkage information transformation rules mimola language functionality mssq compiler intermediate representation high level synthesis mssq retargetable code generation msst self test program generation behavioral structural simulation processor specific mssq binary machine code exempli ed combination tools permits high level design digital programmable processors realistic conditions 
typically involves design iterations guided user interaction 
fig 
shows functionality mssq compiler 
mssq reads external netlist model target processor 
netlist model comprises retargetable code generation structural descriptions controller datapath 
source algorithm speci ed imperative high level language program 
netlist program described mi language 
additionally user optionally specify information concerning linkage hardware software 
mssq emits processor speci binary machine code implements source algorithm speci ed target processor 
code listing interpreted program rom speci cation embedded processor 
class processors handled mssq de ned characteristics controller mssq assumes controller architecture control lines originate dedicated instruction memory register 
primitive operations steered controller single cycle register transfers rts executable parallel machine cycle 
instruction pipelining multicycle operations assumed invisible level 
detailed instruction format part processor model completely user de nable 
possible instruction formats range purely horizontal vliw strongly encoded formats 
encoded formats inter instruction restrictions derived processor model typically comprises instruction decoders case 
arbitrary datapath datapath arbitrary user de nable netlist hardware components 
basic components registers alus decoders multiplexers memories bus drivers described behavior 
interconnections components described terms wires busses 
assumptions architecture datapath advance 

related early contributions retargetable code generation mainly stem areas compiler construction microprogramming 
code generation embedded processors separate research area established decade evolved rapidly 
divide overview related categories 

compiler construction retargetability goal project 
proposed compile source languages target machine languages frontends compile common intermediate format back ends translate format target language 
way tools required tools direct translation source language leupers marwedel target language 
approach turned infeasible general restricted sets source target languages 
approach machine independent code selectors generated shift reduce parsing source code statements respect instruction set grammar 
satisfactory results reported ibm pdp machines instruction level parallelism treated 
relying de ned formal background parser approach su ers ambiguity grammars leads suboptimal code selection parallel machines 
cattell proposed new target independent code selection method maximal method heuristic tree covering 
machine description formalism isp su ered de cient readability captured parallelism 
survey ganapathi summarizes techniques available early eighties concludes demand shorter compilation times versatile machine description languages 
retargetability put practice gnu project gnu compiler gcc successfully retargeted number cisc risc machines widely spread workstation personal computer environments 
cases gcc outperforms commercial processor speci compilers 
unfortunately gcc requires exhaustive target machine description speci language turn including constructs 
gcc permit frequent changes target architecture instance required customization asips 
furthermore gcc problems dsps 
attempt port gcc motorola dsp results poor terms exploiting parallelism 
retargetability respect code selection provided code generator generators compiler compilers 
tools beg twig iburg capable generating fast processor speci tree pattern matchers descriptions tree grammars 
turn matchers generate optimal covers data ow trees subgraphs control data ow graphs dynamic programming 
strength tools lie fact complex instructions handled 
runtime generated matchers linearly dependent tree size 
cost metrics inherently exclude instruction level parallelism 

microprogramming input embedded code generation comes area microprogramming traditionally uses hardware oriented machine models treats instruction level parallelism central issue 
contrast compiler construction separation assembly level machine level code generation 
approaches microcode generation employ code compaction general idea rst translate source code vertical machine code consisting separate partially interdependent rts 
rts rearranged form valid 
unfortunately resource retargetable code generation structural descriptions constrained scheduling problem optimal local compaction restricted basic blocks np hard 
number heuristic local compaction techniques extensively compared turned useful practice 
rst global compaction technique fisher trace scheduling 
trace scheduling determines critical path set basic blocks respect branching probabilities 
ignoring branches path treated large basic block reveals large amount parallelism 
standard local compaction technique list scheduling applied 
trace scheduling tends signi cantly increase code size due compensation code needs inserted recommendable embedded code generation 
percolation scheduling known technique global compaction applied high level vlsi synthesis 
researchers treated retargetable generation microcode highlevel programming languages 
approaches special machine description languages speci cation instruction formats binary encodings available rts con icts rts due encoding resource limitations 
mpg system focus microcode generation mainframes including complex mechanism address generation control store 
vegdahl emphasized necessity phase coupling microcode generation 
compiler postponed decisions regarding code selection cattell approach compaction phase 
mueller varghese proposed code generation graph model target machine instruction set model 
early approaches required manual interaction user 

embedded code generation embedded processors include microcontrollers publications embedded code generation focus standard dsps asips 
emphasis high quality code generation irregular architectures retargetability 
common nearly assumption controller 
rimey hil nger introduced concept data routing code generation asips operations bound functional units target processor data routing deals transporting data functional units minimize amount transport operations 
greedy scheduling orders operations time information data 
way scheduling register allocation closely coupled 
practical application restricted simple class target processors 
data routing approach re ned hartmann stressed main disadvantage data routing possibility deadlocks scheduling 
consequently complex mechanism deadlock avoidance employed 
hartmann technique applied realistic example high code quality achieved 
wess proposed usage normal form programs dsp code generation 
normal form programs essentially sequences small programs leupers marwedel implementing computation expression tree 
optimal code selection expression trees possible linear time respect number selected instructions 
order account special purpose registers trellis diagrams 
trellis diagrams regarded state diagrams representing possible operations target processor 
iterative code compaction method aims exploitation parallelism 
high quality code generation reported standard dsps dsp tms adsp 
mechanism provided constructing trellis diagrams common models 
cbc compiler hartmann scheduling data routing techniques 
nml language permits concise hierarchical instruction set descriptions 
cbc uses tree covering dynamic programming instruction selection exploits user de ned transformation rules 
nml language 
cbc applied realistic design siemens digital european cordless telephone enhanced global optimization techniques chaining operations basic block boundaries heuristically generalizing code selection directed acyclic graphs dags trees 
nml language data routing approach adopted chess compiler targets asips load store architectures 
far basically modelling results reported 
compiler paulin maps programs machine code industrial house asips 
target processors described separate items set available instruction patterns graph model representing datapath resource classi cation accounts special purpose registers 
code generation follows classical direction code selection performed dynamic programming exploiting available code generator generators 
register allocation user speci ed resource classi cation left edge algorithm 
heuristic postpass compaction phase aims exploiting parallelism 
high code quality achieved results reported asips presumably due fact retargeting requires manual ort 
research spam project focuses code optimization standard dsps retargetability araujo malik partially integrate register allocation code selection account special purpose registers dsps 
theoretical instruction set criterion developed generation spill free schedules possible linear time 
due usage code generator generators approach user retargetable 
optimal code generation data ow trees reported tms dsp excluding consideration parallelism memory addressing mode registers 
liao wang propose address assignment dsp speci address generation units means advanced code optimization provide extensions previous 
investigate improved code selection dag matching tree matching optimization mode register usage 
high code quality techniques tailored retargetable code generation structural descriptions tms 
promising technique delayed memory binding variables code generation standard dsps distributed memory banks motorola technique signi cantly increases parallelism machine program 
worth mentioning mutation scheduling ms nicolau aims code optimization complete phase coupling 
ms dynamically maintains set mutations value occuring source program 
mutations essentially obtained algebraic transformations 
driven ms selects appropriate mutation value computed availability resources 
apparently traversing search space possible mutations crucial ms demands large amount potential parallelism order ective 
intended asip code generation promising results ms far idealized homogeneous processor architectures comprising large number registers parallel functional units 
contrast schenk compiler focuses realistic risc architectures 
complete phase coupling ensured means extensive backtracking ne grain uni ed data structure resource usages 
results reported 
speci contributions embedded code generation wilson philips techniques permit high quality code generation narrow class asips su ciently retargetable 
state art embedded code generation summarized 
main drawn previous related strong trade retargetability code quality 
highest code quality approaches concentrate particular classes target processors provide exibility 
hand hw sw codesign embedded systems demands exibility friendly fashion 
retargetable compiler systems provide user friendly interface editable external processor model 
processor models approaches behavioral pure description 
models problems special purpose registers instruction level parallelism 
compilers chess mixed models instruction set models including structural information 
corresponding processor description formalisms necessarily tool speci contrast approaches mssq compiler uses real hardware description language processor modelling uses purely structural models 
section describes input format mssq 

description source program target processor main concept mssq usage uni ed description language mi target processor application compiled 
advantage uni ed language distortion exists algorithm hardware instance regarding available data types 
mimola leupers marwedel data type bit vector prede ned 
complex data types may de ned user 
contrast vhdl arithmetic interpretation integer unsigned bit vectors encoded mimola operators 
mimola input mssq consists sections algorithm compiled target processor model additional linkage transformation rules 
illustrate language features examples 
detailed description mimola 

program speci cation algorithmic part mimola essentially superset pascal programming language data types set real file available 
extensions pascal include prede ned variable locations statement var reg declares bit variable located register reg 
physical storages variables physical registers memories directly referenced assignment accumulator accu accu bit level addressing subranges operands may referenced appending bit vector index range 
assignment loads variable signi cant bits register accu accu module calls hardware components called procedures parameters enforce execution certain operations 
instance processor description contains component named component called assignment operator binding operations bound certain hardware components assignment addition bound component 
extension optional user select variety programming styles hardware speci pure pascal programs possible programs close assembly level 
retargetable code generation structural descriptions 
processor modeling mimola permits modeling arbitrary programmable non programmable hardware structures 
similar vhdl number prede ned primitive operators exists 
basic entities mimola hardware models modules connections 
module speci ed port interface behavior modules connections form netlist 
example shows description multi functional alu module module alu outp ctr outp case ctr construct includes set concurrent assignments 
example conditional assignment output port outp speci ed depends bit control input ctr 
don care conditions respect control inputs speci ed means case tags 
example shows model register module 
module accu inp outp enable bit clk clock bit var reg case enable clock reg inp outp reg variable reg module accu stores new input value rising clock edge enable signal value 
concurrently register value assigned output port outp 
prede ned statement speci es operation mode 
connections module ports de ned connection statements connections alu outp accu inp accu outp alu leupers marwedel mssq notion bidirectional busses declared bus statements 
presence busses mssq assumes modules driving bus set control signals 

linkage transformation rules case programmable hardware structures distinguished storage locations exist compiler point view program counter instruction memory 
code generator operating hardly identify locations inspecting structure 
locations part netlist model need explicitly labelled 
done location statements location location instructions im location statements may optionally restricting register allocation search space storages identi ed physical locations declared user variables intermediate results 
important feature mssq replacement mechanism 
mechanism works user de ned rewrite rules ways implementing operations algorithm available target processor increasing degrees freedom code generation 
resulting code favorable 
replacement rules may comprise arbitrary mimola expressions formal parameters 
example shows replacement rules 
replace replace conditionally incr rules attribute unconditionally applied intermediate code generation 
example multiplication formal parameter replaced addition rule permits code generation target processor contain multiplier 
rules conditionally attribute applied demand addition required compiler may decide bind addition value resulting code favorable 
means replacement mechanism high degree exibility ered mssq frontend 
indicated examples typical applications replacement rules include implementation operators unimplemented hardware strength reduction arithmetic operators 
furthermore replacement rules permit cope unforeseen idiosyncrasies new target processors 
complete mimola description simple bit processor 
corresponding schematic shown 
retargetable code generation structural descriptions module inp outp structure outermost module structural type fields bit horizontal instruction word imm mux alu byte bit scalar types parts instantiate behavioral modules im module adr byte ins var storage array ins storage adr pc reg module reg bit data byte outp byte var byte data outp module data byte byte outp incr data ram module memory data adr byte outp byte fct bit var storage array byte case storage storage adr data outp storage adr alu module byte outp byte fct denotes binary numbers outp case mux module mux byte outp byte fct outp case connections controller data path pc outp im adr im ins imm mux pc outp data inp mux primary input outp pc data ram outp mux im ins ram adr mux outp alu im ins ram alu outp reg data im ins alu alu reg outp alu im ins mux mux reg outp outp primary output structure location pc location instructions im structure complete mimola description simple bit processor leupers marwedel pc im schematic example bit processor 
internal data structures alu reg outp inp mux ram mssq uses main internal data structures described section 
connection operation graph cog represents rt level hardware structure capabilities rt level functional units 
cog pattern matching intermediate program representation primitive target processor operations 
necessary control codes rt level components involved primitive processor operation maintained means instruction trees trees 

connection operation graph cog mssq internal representation target processor 
cog nodes represent hardware operators module ports represent data ow nodes 
direction edges opposite data ow hardware 
fig 
shows connected rtl modules mimola corresponding partial cog operation dat denotes transparent mode identity operation input data 
module mux perform dat operations input 
edges port re ect selection certain operation depends value assigned control port 
output mux mux connected input port module 
module performs addition subtraction depending value control signal ctr assigns result output port retargetable code generation structural descriptions module mux fct bit case module fct ctr bit case ctr connections mux dat partial connection operation graph mimola modules dat ctr way complete target processor structure represented cog 
variables sequential modules separate read write operation nodes cog 
direction cog edges permits trace back data ow module output ports input ports module output ports 
preprocessing step cog constructed textual mimola processor model 
complexity cog construction linearly depends number hardware operators target processor 
complex target processors tms cog construction takes minute cpu time 
cog nodes representing hardware operations annotated corresponding settings module control ports 
settings directly derived case statements module bodies 
example consider partial cog shown 
dat operation input port module mux selected setting control port mux zero annotated 
similarly annotated node module 
preprocessing mssq checks reachability module control ports control port directly reachable direct connection instruction memory exists 
control port indirectly connected instruction memory combinational modules control ports reachable turn control port called indirectly reachable 
indirect reachability instance important presence instruction decoders processor model 
leupers marwedel xx tree representing 
trees represents xxx xxxx xxx xx mssq assumes module control signals originate labelled instruction memory directly indirectly decoders 
control signals represented partial instructions versions 
target processor instruction aversion bitstring xg processors single cycle operations partial instructions su cient checking encoding resource con icts due explicit modelling multiplexers busses resource con icts re ected instruction con icts 
mssq uses trees ciently dynamically maintaining sets versions checking instruction con icts 
trees constructed code generation 
associated register transfers represent necessary partial instructions possible alternatives 
tree nodes contain instruction eld instruction bit index subrange bitstring xg 
relative position nodes decides relation instruction elds nodes path tree related simultaneously valid 
nodes di erent paths related di erent paths represent alternatives 
set versions represented tree obtained separately traversing paths root leaves 
instruction elds contained path assumed don care 
path instruction elds nodes bitwise combined operation de ned follows value represents error elds simultaneously valid 
case elds called incompatible con icting 
example tree bit instruction word length interpretation 
trees constructed means operations set instruction eld 
tree set constructs single node tree representing version retargetable code generation structural descriptions merge cut 
operations merge cut trees merge tree tree 
tree merge constructs tree represents union version sets 
performed attaching common root 
merge operation alternative versions register transfer detected code generation 
cut tree tree 
tree cut constructs tree represents intersection version sets 
performed appending leaves checking con icts path 
cut may yield void tree case versions represented pairwise con icting 
cut operation code generation di erent partial instructions simultaneously set order activate certain register transfer 

code generation section describes source algorithm mapped target processor data structures 
code generation proceeds sequential phases 
rst phase transforms high level source program rt level program 
second phase integrates code selection register allocation third phase heuristically exploits potential instruction level parallelism 
leupers marwedel 
preprocessing code generation takes place high level source program transformed rt level program 
declared user variables bound storage modules variable substituted corresponding storages 
process variable binding may steered reservations provided user 
variables bound arbitrary storage modules su cient capacity 
furthermore high level control structures repeat loops replaced constructs explicit labelled program counter register 
example shows piece source code corresponding rtl program source code var integer repeat rtl code bound mem mem mem lab mem mem mem mem mem pc mem lab incr pc repeat loop replaced conditional assignment program counter pc 
true loop body branch label lab taken 
pc incremented point instruction loop 
replacement rules high level control structures contained external library edited user 
way appropriate replacements selected particular target processor 
dsp instance replace loops hardware loops 
source code bee transformed rt level program consists sequence possibly conditional assignments storage locations prepared mapped hardware 
statements expressions remaining high level control structures 
hardware constructs correspond multiplexers 

code selection register allocation phase responsible selection instruction patterns implement desired behavior 
simultaneously registers intermediate results allo retargetable code generation structural descriptions cated required 
basic idea perform pattern matching rtl assignments cog subgraphs 
necessary control signals dynamically maintained means trees 
code selection register allocation performed interacting modules pattern matcher temporary cell allocator 

pattern matching single assignments represented trees 
trees pattern matching performed separately 
mssq tries nd subgraph cog matches tree representation assignment 
restricted single cycle operations read write nodes cog crossed pattern matching 
pattern matching exploit transparent modes combinational modules 
pattern matching stops soon rst matching subgraph 
subgraph corresponds register transfer 
mssq generates module control signals required rt cog provides information paths designated instruction memory rt level component 
control port rt level component involved selected rt annotated setting adjusted tracing back path port instruction memory generating appropriate partial instructions say simultaneously required execute selected register transfer corresponding tree computed consecutive cut operations cut cut cut operation yields void tree due con icting settings pattern matching iterated subgraph leading non void tree 
alternative control port settings certain subgraph node exist alternative versions kept tree merge operation 
alternative versions correspond single cycle operation cost function versions versions unit cost 
appropriate version selected code compaction dependent context potentially parallel register transfers 
mssq exploits commutativity neutral elements arithmetic operations order detect alternative versions 
result pattern matching rtl tree representing alternative partial instructions 
fig 
illustrates pattern matching example assignment 
partial structure consists modules instruction memory memory decoder dec computes powers multiplexer mux alu comprising subtraction mode register module attached instruction index subrange controls module dec steered instruction bits addressed instruction bits 
pattern matching assignment tree partial structure delivers versions assignment 
di erence lies control signal mux leupers marwedel way generating constant 
rst version mux passes left input constant allocated instruction bits 
second version exploits dec constant generation mux passes right input 
assuming instruction bits enable register select subtraction alu respectively shows resulting tree 
tree construction con ict detected regarding instruction bits instruction eld simultaneously generating memory address constant case 
rst version discarded 

temporary cell allocation assignments may contain complex expressions computed single machine cycle 
case storage allocation intermediate results required 
binding declared user variables storage locations mssq done code generation linkage speci cation temporary allocation done code generation 
temporary cells may storage cells datapath registers 
temporary allocation activated pattern matching process fails 
case assignment split sequence simpler assignments pattern matcher called recursively 
suppose assignment read load assignment conflict 
dec mux alu tree dec mux alu matching subgraphs pattern matching assignment trees hardware structure retargetable code generation structural descriptions ram ram allocated target processor permits ram access cycle 
temporary cell tmp assignment split sequence tmp ram ram tmp pattern matcher invoked recursively 
recursion terminates sequence successfully allocated allocation process conclusively failed case insu cient hardware resources 
case detailed error message reporting failure reason emitted user may accordingly correct source code hardware description 
basically mssq allocates temporary cells greedy fashion 
results worst case runtime exponential number recursion steps temporary allocation complexity assignments compiled 
possibly vast search space pruned obeying rules allocation temporary cells intermediate results goal directed sense information gained pattern matching exploited 
temporary cells generated subexpression complex expression pattern matcher reported failure 
locations considered speci ed user linkage section processor description 
speci ed locations tried additional recursion stage pattern matching initiated 
prevents temporary allocation generating costly additional control steps avoided di erent temporary allocation 
bitwidth possible temporary locations equal greater required temporary result bitwidth 
case mssq performs sign zero don care extension 
mssq notion distances storage locations 
distance de ned number clock cycles required data location possibly combinational modules 
temporary locations considered distances destination assignment exceed 
fig 
shows example 
strategy inhibits successful code generation special cases registers need passed data transfer turns compromise general restriction search time unacceptable 
temporary allocation mssq keeps track storage contents 
common subexpressions complex expressions identi ed allocated 
common subexpression analysis cross assignment boundaries 
result code selection register allocation general sequence register leupers marwedel bus temporary search space destination register transfers executable single machine cycle 
rts associated tree representing necessary partial instructions possible alternatives 
note code selection register allocation imply decision concerning version selection control step binding 

control ow allocation far allocation data ow related assignments mssq described 
contrast approaches mssq derives possible control ow operations modi cations program counter register pc directly hardware structure 
pattern matching mechanism mssq tries generate versions assignments pc advance pc incr pc increment program counter pc label jump symbolic label pc cond incr pc label conditional branch pc cond label incr pc conditional branch pc cond label label way branch versions assignments exist depends branch logic current target processor 
partial controller structure permitting pc retargetable code generation structural descriptions label incr pc label ctr outp cond pc 
universal branch logic module cond bit ctr outp outp case ctr cond cond cond assignment types depicted possible mimola model pc multiplexer 
mssq tries assignment types implementation conditional assignments conditional branch constructs 
symbolic labels replaced instruction memory addresses 
exist methods implementing conditional assignments hardware conditional branches 
conditional load implemented mssq 
implementation conditional load available assignment condition routed enable input destination 
case pc modi cation necessary 
turn increases freedom code selection 
available mssq allocates conditional jump conditional load versions statements kept compaction phase 
rt operations assignments pc associated corresponding tree 

compaction version selection compaction phase aims exploiting potential instruction level parallelism simultaneously selecting appropriate binary encoding versions 
compaction operates output code selection register allocation sequence rts tree representing alternative versions 
heuristically rts assigned control steps obeying dependencies rts 
rt dependent rt rt reads register value rt rt scheduled earlier rt pairwise independent rts parallel compatible con icts exist respect partial instructions 
compatibility ciently checked means cut operation trees 
leupers marwedel compatible version 
version selection trees current instruction bit index mssq employs modi ed version rst come rst serve fcfs heuristic generated step step starting control step 
control step rst ready rt arbitrarily selected 
rt ready successors respect dependency relations processed 
selected rt current arbitrary version selected tree 
ready rts investigated sequentially 
mssq checks compatible version exists rt packed current 
selection compatible versions trees illustrated 
iterated rt packed 
nished generated way 
compaction terminates rts packed 
complexity compaction heuristic register transfers 
nishing mssq inserts additional partial instructions order avoid undesired side ects 
side ects potentially arise sources unused storages certain set sequential modules registers memories written 
shown example module accu see section sequential modules typically distinguished control ports enabling write operations variables 
module variable contains live value written certain control step ensured value retained corresponds activation prede ned mimola operation 
similar hardware operations associated partial instructions 
mssq perform book keeping live registers rts uses conservative retargetable code generation structural descriptions module inp outp fct ctr bit case ctr outp inp outp inp outp ctr dat 
buses driver mimola driver symbol bus multiple drivers approach operation scheduled unused module variable 
buses modules write bidirectional bus provide operation 
simplest case modules drivers shown 
modules ensure bus con icts avoided disconnecting driver bus 
data transmitted module module bus exactly driver performs dat operation unused drivers perform denoted 
similar mssq packs operations unused bus drivers 
integrated compaction version selection phase concludes code generation mssq 
compaction called rt sequence generated code selection register allocation 
concatenating machine instructions generated compaction yields complete machine program source algorithm 
binding instructions instruction memory addresses insertion jump addresses binary code performed postpass phase 
fig 
illustrates structure code generation process 

results requiring controller mssq dedicated certain processor family 
mssq successfully retargeted variety di erent machines 
table lists target processors mssq generated code far corresponding mimola model sizes 
leupers marwedel source algorithm rtl assignment sequence preprocessor accu pattern matcher rt dependency machine instruction sequence 
overview code generation mssq preprocessor code selection register allocation temp allocator rt sequence trees compaction version selection target processor netlist graph step step step machine program retargetable code generation structural descriptions table 
target machines mssq mimola model sizes machine type rtl modules model size lines amd bit slice processor samp self timed vliw machine vliw prolog processor asip tms digital signal processor dsp digital signal processor pc im base offset mod agu adr ram rom mul 
industrial asip digital audio signal processing data coef add sum detailed descriptions amd samp architectures code generation results machines 
focus architectures table representative embedded processors 

bass boost asip architecture depicted industrial asip area digital audio signal processing 
asip moderately encoded bit format dedicated address generation unit agu supporting ring bu ers bit ram 
arithmetic computations performed bit multiply accumulate section 
filter coe cients stored rom 
functional units parallel order guarantee high throughput 
mssq map digital bass boost dbb algorithm machine code asip 
dbb consists identical stereo channels realizing low pass lter 
mssq provide particular support ring bu ers traded manual description ort code quality di erent mimola descriptions dbb source algorithm clp leupers marwedel table 
results digital bass boost asip programming source code machine cpu seconds style statements instructions sparc high level medium level low level high level rst program dbb algorithm described pure pascal level particular underlying hardware 
ring bu ers replaced successive data moves sample period 
code selection register allocation compaction completely left compiler 
medium level second program storage layout manually prede ned storage binding variables 
includes explicit storage allocation ring bu ers access ring bu er elements means modulo addressing capabilities agu order avoid data moves 
code selection register allocation compaction left compiler 
low level third program freedom left compiler 
mimola program closely re ects machine program prede ning sequence control steps 
variables completely replaced storage register 
compiler responsible binding operators hardware resources translating rts binary machine instructions 
programs separately compiled mssq 
results shown table 
high level program required description ort led inferior code quality essentially due insu cient agu utilization 
problem avoided medium level program reduction number generated instructions obtained 
highest code quality achieved low level program 
extensive manual analysis hardware capabilities high resource utilization ensured resulting machine instructions 
code quality obtained originally completely manual code generation 
ort writing low level program comparatively high 
sake completeness table shows compilation times relatively high rst program versions 
contrast compilers general purpose systems compilation speed plays secondary role embedded code generation 
user compiler workstation hardly willing spend minutes compiling thousands source code lines compilation times hours may regarded acceptable embedded code generation demands compilers higher area 
fact publications embedded code generation retargetable code generation structural descriptions table 
results tms program source code machine cpu seconds statements instructions sparc test test elliptical wave lter greatest common divisor pid control di erential equation solver explicitly mention compilation speed long acceptable amount cpu time exceeded 

tms texas instruments tms popular standard dsp strongly encoded bit instruction format moderate amount instruction level parallelism 
mssq compile high level programs tms code 
include arithmetic test programs realistic dsp algorithms 
results listed table 
analysis generated code yields estimated overhead compared hand crafted code 
overhead mainly due fact mssq maps statement statement perform data ow analysis statements 
results redundant data move instructions 
statement wise mapping mechanism prevents mssq su ciently exploiting instruction level parallelism tms form instructions 
quality generated code bad compared results obtained processor speci compilers 
experimental study revealed current commercial compilers standard dsps yield code similar overheads quality 

dsp dsp member widespread motorola family digital signal processors 
contrast tms moderately encoded bit instruction word signi cant amount instruction level parallelism 
wehave mssq compile set benchmark programs processors tms 
table shows results 
elliptical wave lter program number generated instructions comparable results achieved tms 
code quality worse parallel memory access capabilities dsp exploited 
due fact binding variables memory leupers marwedel table 
results dsp program source code machine cpu seconds instructions statements instructions sparc gnu gcc test test elliptical wave lter greatest common divisor pid control di erential equation solver banks mssq takes place code generation 
architectures parallel memory banks dsp delayed binding variables proposed yields higher utilization parallelism 
comparison purposes applied dsp version gnu compiler gcc benchmark programs 
results optimizations enabled shown rightmost column table 
naturally gcc compiles faster needs fractions cpu second program 
code quality poor 
instruction level parallelism exploited insu cient utilization special purpose registers leads overheads compared mssq generated code 
furthermore mssq requires smaller ort processor modelling mimola model dsp consists approximately lines gnu model comprises lines 

design automation hw sw codesign embedded systems demands exible code generators interface software synthesis embedded processors 
retargetable compilers provide promising solution di erent target processors need investigated hw sw partitioning 
furthermore retargetable compilers necessary single chip designs comprising asips compiler support hardly available far 
contribution mssq compiler 
contrast approaches retargetable code generation embedded processors mssq operates purely structural rt level processor descriptions 
probably important result mssq fact compiler successfully retargeted large variety di erent real life machines 
contrast related practical results reported single target narrow class targets mssq applied general purpose processors standard dsps asips able generate code 
essentially due fact mssq uses detailed processor models derives required information automatically models making assumptions target architecture advance 
furthermore hardware retargetable code generation structural descriptions description language mimola provides de ned exible easy learn interface mssq 
way close link hardware synthesis tools simulators provided 
alternatively corresponding subset vhdl provide compliance existing standards 
limitations current mssq version mainly concern code quality 
quality mssq generated code comparable quality achieved contemporary processor speci compilers advanced code optimization techniques de nitely necessary particular dsps 
considering larger entities single source code statements potential parallelism revealed code compaction 
furthermore mssq bene faster register allocation techniques instance 
research results show structural modelling approach contradict advanced code generation techniques behavioral mixed models constructed structural model means instruction set extraction 
progress overcome limitations mssq 
currently considering special enhancements tailored dsps context maps record compiler projects 
believe usage advanced code optimization techniques retaining exibility achieved structural processor models possible bears potential signi cant progress code generation embedded processors 
acknowledgments authors ralf niemann performing experimental 
material digital bass boost asip provided jef van philips research labs eindhoven netherlands 
nancial support european union esprit project chips gratefully acknowledged 

gupta de micheli system level synthesis re programmable components european conference design automation pp 

chou software scheduling synthesis reactive real time systems st design automation conference dac pp 

ernst henkel benner hardware software microcontrollers ieee design test magazine pp 

veith design hw sw systems vlsi subsystems codes th ieee workshop vlsi signal processing pp 

lee hardware software codesign methodology dsp applications ieee design test magazine pp 

embedded system design design automation embedded systems vol 
nos 

goossens de man integration signal processing systems heterogeneous ic architectures th high level synthesis workshop pp 
leupers marwedel 
paulin may dsp design tool requirements nineties industrial perspective technical report bell northern research 
van jess note cient code generation house dsp cores european design test conference ed tc pp 

dsp oriented benchmarking methodology technical report dept electrical engineering institute integrated systems signal processing university aachen germany 
marwedel new synthesis algorithm mimola software system rd design automation conference dac pp 

marwedel matching system component behaviour mimola synthesis tools european conference design automation pp 

marwedel tree mapping algorithms prede ned structures int 
conf 
computer aided design iccad pp 

kruger hierarchical test generation ieee trans 
cad vol 
pp 

marwedel retargetable self test program generation constraint logic programming nd design automation conference dac pp 

marwedel schenk cooperation synthesis retargetable code generation test generation mimola software system european conference design automation pp 

conway proposal comm 
acm vol 

machine independent algorithm code generation retargetable compilers doctoral thesis university california berkeley 
cattell formalization automatic derivation code generators doctoral thesis dept computer science carnegie mellon university pittsburgh 
ganapathi fischer hennessy retargetable compiler code generation acm computing surveys vol 
pp 
porting gnu cc free software foundation cambridge massachusetts 
landwehr beg generator cient backends acm sigplan conference programming language design implementation pldi sigplan notices pp 

aho ganapathi tjiang code generation tree matching dynamic programming acm trans 
programming languages systems pp 

fraser hanson proebsting engineering simple cient code generator generator acm letters programming languages systems vol 
pp 

dewitt machine independent approach production optimal horizontal microcode doctoral thesis technical report dt university michigan 
davidson shriver mallet experiments local microcode compaction horizontal machines ieee trans 
computers vol 
pp 

fisher trace scheduling technique global microcode compaction ieee trans 
computers vol 
pp 

aiken nicolau development environment horizontal microcode ieee trans 
software engineering pp 
lis nicolau gajski percolation synthesis th design automation conference dac pp 

baba mpg system machine independent cient generator ieee trans 
computers vol 
pp 

vegdahl local code generation compaction optimizing microcode compilers doctoral thesis dept computer science carnegie mellon university 
vegdahl phase coupling constant generation optimizing microcode compiler th ann 
workshop microprogramming micro pp 
retargetable code generation structural descriptions 
mueller varghese flow graph machine models microcode synthesis th ann 
workshop microprogramming micro pp 
rimey hil nger lazy data routing greedy scheduling application speci signal processors st annual workshop microprogramming microarchitecture micro pp 

hartmann combined scheduling data routing programmable asic systems european conference design automation pp 

wess optimal generation signal flow graph computation ieee int 
symp 
circuits systems iscas pp 

aho johnson optimal code generation expression trees journal acm vol 
pp 

wess automatic code generation integrated digital signal processors ieee int 
symp 
circuits systems iscas pp 

translating signal flowcharts microcode custom digital signal processors int 
conf 
signal processing pp 

muller global code selection directed acyclic graphs fritzson ed th int 
conference compiler construction 
goossens de man data routing cient data path synthesis code generation th int 
symp 
high level synthesis pp 

van goossens de man instruction set de nition instruction selection asips th int 
symp 
high level synthesis pp 

van describing instruction set processors nml european design test conference ed tc pp 

may paulin instruction set matching selection dsp asip code generation european design test conference ed tc pp 

may paulin register assignment resource classi cation asip microcode generation int 
conf 
computer aided design iccad pp 

araujo malik optimal code generation embedded memory non homogeneous register architectures th int 
symp 
system synthesis isss pp 

liao devadas tjiang wang storage assignment decrease code size acm sigplan conference programming language design implementation pldi 
optimizing stack frame accesses processors restricted addressing modes software practice experience vol 
pp 

liao devadas tjiang wang code optimization techniques embedded dsp microprocessors nd design automation conference dac pp 

malik memory bank register allocation software synthesis asips int 
conf 
computer aided design iccad pp 

nicolau dutt uni ed code generation approach mutation scheduling chapter 
schenk retargetable code generation parallel pipelined processor structures chapter 
wilson banerji integrated approach retargetable code generation th int 
symp 
high level synthesis pp 

van jess con ict modelling instruction scheduling code generation house dsp cores nd design automation conference dac pp 

marwedel goossens eds code generation embedded processors kluwer academic publishers 
leupers marwedel neumann mimola language technical report university dortmund dept computer science september leupers marwedel 
marwedel implementation statements microarchitecture synthesis system eds synthesis control dominated circuits ifip trans 
north holland pp 

advanced micro devices bipolar microprocessor logic interface data book sunnyvale 
nowak samp general purpose processor self timed vliw structure acm comp 
arch 
news vol 
pp 

schenk high speed prolog implementation vliw processor microprogramming vol 
nos 
pp 

albrecht marwedel neumann schenk design microprocessor th workshop vlsi design training pp 

nowak graph retargetable microcode compilation mimola design system th ann 
workshop microprogramming micro pp 

texas instruments tms user guide rev 
motorola dsp digital signal processor user manual 
leupers marwedel bdd frontend retargetable compilers european design test conference ed tc pp 

leupers marwedel retargetable generation code selectors hdl processor models european design test conference ed tc 
leupers marwedel time constrained code compaction dsps th int 
system synthesis symposium isss pp 

leupers marwedel algorithms address assignment dsp code generation int 
conference computer aided design iccad received date accepted date final manuscript date 
