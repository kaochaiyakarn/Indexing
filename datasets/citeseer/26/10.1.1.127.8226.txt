objective ml effective object oriented extension ml didier vouillon authors address inria rocquencourt le chesnay cedex france 
email didier remy jerome vouillon inria fr objective ml small practical extension ml objects top level classes 
fully compatible ml type system ml polymorphism record types polymorphic access better treatment type abbreviations 
objective ml allows features object oriented languages including multiple inheritance methods returning self binary methods parametric classes 
demonstrates objects added strongly typed languages ml polymorphism 
john wiley sons propose simple extension ml class objects 
objective ml fully conservative extension ml 
beginner may ignore object extension 
notice difference types inferred 
possible type inference algorithm objective ml ml order unification binding polymorphism 
types extended object types similar record types polymorphic access 
status treatment type abbreviations improved order keep types readable 
object oriented features user required write interfaces classes include type annotations defining parametric classes coercing objects counterparts super classes 
objective ml class system provides features object oriented programming 
includes methods returning self binary methods course classes multiple inheritance 
coercion objects counterparts super classes possible 
explicit 
ingredients automatic abbreviations new 
incorporation practical language combining power simplicity compatibility ml new 
john wiley sons objective ml formally defined dynamic semantics proven correct respect static semantics 
language designed minimal calculus objects core real programming language 
particular semantics classes compatible programming imperative style functional style allows efficient memory management methods shared instances class 
organized follows section overview objective ml 
objects classes introduced sections 
coercions dealt section 
semantics language described section 
type inference discussed section 
abbreviation mechanism explained sections 
extensions core language sections 
section compare proposal 

overview objective ml objective ml core langage 
extended language objective ml implemented top caml special light system 
implementation called objective caml 
article completely formalize core language objective ml 
name objective caml refer implementation especially describing minor differences extension core language fully formalized 
examples show process objective caml useful display output typechecker slanted font 
toplevel definitions implicit 

phrase typechecker outputs binding generalized added global environment starting typecheck phrase 
language objective ml class 
objects usually created classes possible create directly described section 
straightforward example class point 
class point struct field ref theory practice object systems vol 
volume number optional issue number ccc information method move class point int sig field int ref method move int int class types automatically inferred 
objects usually created instances classes 
objects class type structure reflecting structure class 
important name object types avoid repeating nested recursive structure objects occurrence object type 
declaration automatically defines abbreviation type point move int int type objects method move type int int 
practice essential order report readable types user 
example shows object abbreviations introduced operator new applied class 
new point int point fun new point value point obj classes derived classes adding fields methods 
example shows object sends messages instance scale formula overridden subclass move method new scale 
methods parent class bound super class variable parent redefinition move method binary operator denotes method invocation objective ml 
class scaled point struct inherit point parent field method scale method move parent move self scale class scaled point int sig field int field int ref method move int int method scale int scaled points richer interface points 
possible consider scaled points points 
useful wants mix different kinds points incompatible attributes ignoring interface points points new scaled point scaled point point new point theory practice object systems value points point list obj obj examples example binary methods appendix 
notation binding pair key element written term type 
bindings may tagged 
instance foo tag write foo foo tags redundant bindings remind kind identifier bound 
term sequences may contain bindings key 
write concatenation sequences juxtaposition 
contrary linear sequences bind key times 
write overriding extension sequence enforce sequences compatible agree intersection domains 
write empty sequence 
sequence function 
precisely domain sequence union written dom projection elements sequence 
element domain mapped value rightmost element sequence projection ignoring tags 
sequence foo composed elements tagged foo 
write foo foo subsequence elements tagged foo stripped tag foo 
write tuple elements ti indexes implicit context 

objects assume set variables sets names 
variables expressions bound fun 
programs considered equal modulo renaming bound variables 
names name field method components objects respectively 
field names method names free subject conversion 
syntax expressions provided 
fun self 
field 
field method 
method operations included constants ellipsis syntax definitions means extending previous definition marks positions arguments prefix infix constants 
ref 
sake simplicity omit formalization examples 
object composed sequence field bindings hidden internal state sequence method bindings accessing modifying fields 
fields called instance variables 
type object type record methods 
object method may return object expect applied object kind 
types recursive 
assume countable collections type variables row variables written collection type constructors written 

rec 
object types row variable named open object types named closed object types 
examples closed object types simply written mi symbol omitted 
row variables open object types left implicit ellipsis mi abbreviations explained section share ellipsis 
formal presentation keep row variables explicit 
label appear object type 
easily ensured sorting type expressions 
distinction guaranteed sorts 
omit distinction simply write 
type equality defined family axioms plus standard rules recursive types rec rec rec contract fold unfold rec rec rec formed recursive types rec formed variable form rec restrictive rec rec rewritten rec 
guarantees contractive ensures rec effectively defines regular tree 
types sorts type equality simplification refer details 
typing contexts sequences bindings field self typing judgments form 
typing rules ml recalled appendix 
typing rules objects 
simple object just set methods 
methods send messages object bound special variable self 
simple object typed follows self mj aj method mj aj mj object instance variables 
instance variables may inside methods defined object 
typechecking instance variables field ui ai object produces typing environment field ui methods typed rules object field 
instance variables provide ability clone object possibly overriding instance variables rule override 
rule types connected 
typing rule object requires type self types instance variables related object 
ensured typing premises context equal field self 
result expression field method method ill typed 
real restriction write ambiguous expression field method method rule send method invocation similar rule polymorphic access records sending message object type object type method type object may methods captured row expression type returned invocation method 
type method invocation may seen send value send 
fun ellipsis stands anonymous row variable means method may defined object row variables provide parametric polymorphism method invocation 
row variables languages subtyping polymorphism 
subtyping polymorphism explicitly declared objective ml see section row variables essential keep type inference 
row variables allow express kind matching bounded higherorder quantification :10.1.1.17.9345
example min leq value min leq bool 
fun binder possible deal open object types occurring times type detailed theory practice object systems field field override field ui ai self ui ai object ai self mj field ui aj field ui ai method mj aj mj rule overridden general rule name 
section 
expanded version type rec leq bool rec leq bool rec leq bool function min object type method leq bool row variable instantiated remaining methods type 

classes syntax classes introduced section formally 
body class sequence small definitions assume collection class identifiers collection super class identifiers written enriched syntax objects reflects syntax classes 
objects built inheritance fields need precede methods 
practice classes appear top level 
simpler leave freedom appear abstraction 
technically possible class allow abstraction classes class types provided explicitly abstractions 
little gain practice probably worth complication class parameterized classes modules 
type class structure sig composed type self type object class type field bindings method bindings 
class types written 
type schemes extended class types 
sig field method super 

concrete syntax combined methods appear flagged virtual defined methods appear type 
necessary type variable bound instance concrete syntax sig virtual copy method int theory practice object systems fig 

typing rules objects expands sig rec copy getx int method getx int 
send typing contexts extended class variable bindings superclass bindings 
super add new typing judgments type class bodies 
redefine field method super self bindings removed 
typing rules 
redefine field self super superclass bindings removed 
generalization class types gen regular types 
variables free class bodies typed adding component inheritance clause field method 
fields typed fields self super bindings visible field expressions 
contrary methods may depend fields super classes previously defined rule method 
inherit rule ensures self assigned type superclass subclass bindings superclass discharged subclass superclass variable type superclass 
superclass variables visible typechecking body class exported type class shown rule 
rule object general overrides corresponds combination rule class body rule new 
value method component redefined type changed previously defined methods assumed old type enforced rule operator requires argument sequences compatible intersection domains 
looks fairly restrictive 
leaves freedom practice 
class type specialized instantiating type variables 
methods returning objects type self correctly typed 
class struct field 
class new expressions fun struct class expressions class bodies inherit field method field field inherit sig self inherit super class body self struct sig super super method class fun fun method copy class unit sig method copy fig 

core class syntax basic method self method method method super new sig method new object self method class app class type bound type self 
objects subclass class types match rec copy class inherited method copy expected type type self 
class point struct inherit inherit point class point int sig field int ref method copy method move int int note ancestors ordered disambiguates possible method redefinitions final method body inherited ancestor appearing 
rule class class inst class fun class app similar rules inst fun fig 

typing rules classes class inst 
class gen class app core ml described appendix 
rules class class inst essential polymorphism class types enables method specialization inheritance explained 
illustration typechecking rules give detailed derivation typing class scaled point appendix 
coercion polymorphism row variables enables write parametric function sends message object method subtyping polymorphism required 
important subtyping inferred objective ml 
notion explicit subtyping allows explicit coercion expression type expression type subtype 
shown example section enables see kinds points just simple points put data structure 
language expressions extended construct 
theory practice object systems corresponding typing rule coerce substitution premise means subtype far typechecking concerned equivalently introduced coercions family constants respective principal types 
free variables indexed pairs types subtyping relation standard 
choose simpler algorithmically efficient presentation 
constraint defined regular trees smallest transitive relation obeys rules closure rules consistency rules shape shape shape subtyping relation enhance subtyping assumptions variables weaker subtyping relation ground types 
instance expression fun type type equivalent expression fun particular instances 
semantics give small step reduction semantics language 
values kinds regular expression values functions object values 
class values class functions reduced class structures 
object values reduced class structures composed methods fields values fields precede methods overridden values 
values evaluation contexts reduction rules 
reduction rule shows objects just restricted view classes instance variables hidden 
chosen reduce inheritance objects classes 
possible reduce inheritance inside classes reorder methods fields 
theory practice object systems choice simpler general classes inherited objects 
reduction object expressions values performed steps described rules objects inheritance evaluation value components reduced top rule remind meta notation stands concatenation sequences components re ordered rule redundant components removed bottom middle rules 
invocation method evaluates corresponding expression replacing self instance variables overriding current values 
substitutions successively applied 
self replaces self 
dom replaces outer instance variable actual value 
inner instances appearing inside object replaced related inner object 
note value contain free fields 

field au au replaces outer occurrence overriding au new object built overriding fields field au inner occurrences appearing inside object replaced related inner object 
note au necessarily value may contain outer overriding fields replaced simultaneously equivalently bottom fashion deeper occurrences replaced 
coercion behaves identity function coercion value reduces value 
subject reduction proved extending type system implicit subtyping rule sub means typed expression reduced may typable rule sub 
surprising explicit subtyping may disappear reduction 
implicit subtyping may required reduction 
possible keep explicit subtyping information reduction avoid need rule sub 
obtained replacing rule rules mi mi mi mi fun fun counterpart types actively participating kept reduction 
formulation chosen simpler semantics clearer reduction untyped 
values 
fun vc fun struct wd field components method components wd method field evaluation contexts new class ec ec ec vc struct fd wd fd inherit ec field classes objects reduction objects new struct inherit struct dom field dom method dom method field field method reduction method invocation dom self field au au reduction coercions reduction expressions context reduction class fun fun soundness language stated theorems 
theorem subject reduction reduction preserves typings 
theorem normal forms typed irreducible normal forms values reduced value 
see appendix proofs theorems 
results easily extend cope constants core ml provided rules constants consistent principal types 

type inference fig 

semantics objective ml types objective ml restriction record types 
order unification record types decidable solvable unification problems admit principal solutions presence recursion 
unification algorithm simplification ml art 
described rewriting process unification problems 
formalism introduced record types 
unification problem called multi set multi equations preceded list existentially quantified variables 
written 

eq 
multi equation multi set types written 
algorithm assumes recursive types encoded equations 

substitution solution multi equation types equal 
solution restriction common solution multi equations outside existentially quantified variables 
theory practice object systems fuse mutate decompose 
generalize 
rule decompose type symbol including 
ensure termination rule generalize restricted case variable appears term variable simplified applying rewriting rules 
structural rules omitted include associativity commutativity extrusion renaming existential variables 
rules fuse decompose generalize standard 
rule fuse merges multi equations variable common 
rule decompose decomposes terms multi equations smaller ones 
rule generalize splits terms smaller terms 
rewritten terms depth 
permits maximal sharing unification 
ensures termination rewriting presence recursive types 
difference unification free algebra mutation rule mute left commutativity 
identifies terms different top symbols provided equality established application axiom root 
algorithm proceeds rewriting multi sets rules 
step preserves set solutions 
process terminates reducing canonical form 
solved form multi equations merged fully decomposed contains non variable term 
principal unifiers read directly solved forms 
canonical solved formed contains clash incompatible types identified solvable 
framework meta theory standard 
equational theory object types sub case general algebra records types details proofs reader referred 
objective ml allow classes class values 
expression fun variable bound class value containing class 
class types need guessed 
polymorphism introduced bindings classes values 
ensures type inference reduces order unification case ml 
consequently objective ml principal type property 
type inference classes straightforward 
links order unification type inference principal types described general setting 
theory practice object systems fig 

unification solving multi sets multi equations theorem principal types typing context program typable context exists type type exists substitution domain intersect free variables 

abbreviation enhancements object types tend large 
type object lists methods types contain object types 
quickly unmanageable 
introducing abbreviations crucial importance 
section presents general abbreviation mechanism objective ml section focuses abbreviating object types 
simple type abbreviation mechanism ml sufficiently powerful abbreviations expanded lost unification interact recursive types 
improvements abbreviation mechanism 
abbreviations kept unification propagated possible 
second larger class abbreviations accepted abbreviations recursive arguments constrained instances types 
implementation types considered graphs 
particular types unified identical separate equal types 
construct added syntax express type graphs construct bind similarly notation rec 
main difference aliases bound outside 
example types different graphs represent regular tree 
reasons considering types graphs 
unification rolls types 
instance unifying types results type instantiating types case 
second unification propagates abbreviations 
abbreviations considered names nodes 
unifying abbreviated type type types abbreviated 
instance unifying argument functional type abbreviated type may propagate abbreviation result type 
demonstrated example 
bump move value bump move int 
fun nodes shared argument type result type 
ellipsis stands anonymous row variable 
typing expression bump type move int type point identified 
type bump abbreviated point 
new point value point obj bump point obj sharing exposed user sharing reveals useless information 
aliasing open object types row variables printed ellipses aliasing defining recursive types printed 
possible remove aliasing type generalization printed types exactly reflect internal representations 
complicate implementation needlessly 
abbreviations recursive 
definition abbreviation type type constructor may occur body long occurrences parameters 
restriction extended mutually recursive abbreviations 
ensures abbreviations expand regular trees 
implementation type constructor standing abbreviation caches expansions abbreviations appears 
abbreviation expanded times traversal type expands time type 
type abbreviations generalized allow constraints type parameters abbreviations 
extension abbreviations lcs 
abbreviation definition parameters types type variables type 
free variables bound 
actual arguments abbreviation instances substitution parameters 
abbreviation expand type 
instance type constructor defined type int bool expand int bool 
expand abbreviation arguments usually substituted parameters 
choose unify arguments corresponding parameters 
constraints need enforced parsing type user 
expansion guaranteed succeed 
substitution applied abbreviation 
expansion equal result applying substitution expansion 
particular constraints preserved substitution 

abbreviating object types describe abbreviation mechanism previous section generate abbreviations objects 
mechanism automatically abbreviate object constructors expression new type 
abbreviation associated class general type abbreviations introduced previous section simplify object types 
sorting types ensure object types formed require stronger condition object types share row variable equal 
eliminates incorrect types types basis record extension rejected 
primitive operation objects exhibits type 
types ruled seriously restricting language 
programs keep principal types 
restriction implemented avoid explaining sorts user 
syntax types somewhat clearer row variables replaced ellipsis 
furthermore sharing described aliasing 
instance written 
class definition class 
automatically generates abbreviation type instances 
specifying needs add type parameters class definitions corresponding abbreviation 
write class 
parameters appear fact abbreviations generated class types 
follows type inference class definition principal class type 
sig 
type matched objects subclasses 
form mi method subsequence mi pathological case class extended new methods row variable 
method exactly mi possible create objects class type 
class virtual inherited class definitions 
free type variables listed automatically define abbreviations type type matches objects subclasses special case abbreviates objects class consider example 
class point type int sig move int int theory practice object systems method move int int 
class point virtual 
abbreviations generated class type point move int int type point move int int check type point abbreviation type objects class point type object subclass class point instance type point 
concrete syntax row variable treated anonymously ellipsis omitted 
abbreviation lower priority regular ones case clash 
vanishes soon row variable instantiated reveal value taken row variable 
fact allow occur definition previous definitions rewritten handle general case correctly 
constrained abbreviations natural abbreviating objects instance sorted list comparable objects parameterized type elements turn type variable 
extension possible avoid row variables type parameters object type appear parameter 
constrained type abbreviations convenient class definition class class type parameters may instantiated types inferring class type 
sig 
abbreviations generated class definition type type unchanged constraints ones implicit second 
class types shown user stripped type parameters 
parameters constraint type abbreviations described constraint clauses class circle struct field point method center point method move point move random int class circle sig constraint move int int 
field point method center method move int int class defines abbreviation type move int int circle center move int int theory practice object systems result abbreviation mechanisms type inference may reject class definitions principal types free variables 
instance variant class point rejected method getx polymorphic class parametric 
class point struct field method getx course choose arbitrary ground class type instance class point int sig field int method getx int ground type int 
decide reject programs 
preserves property typable program principal type useful properties type system 
phenomenon new 
appeared extensions ml 
imperative constructs limit polymorphism 
variables generalizable may occur type top level expression 
case languages reject program 
instance extension ml dynamics rejects fun dynamics dynamic type dynamics statically unknown 
examples principal types long type inference concerned 
argue programs rejected sake simplicity uniformity language failure type inference instance objective ml just omit corresponding abbreviation type parameter missing print warning message error message 

extensions section lists useful features objective ml added implementation 
imperative features ignored formal presentation addition theoretically understood independent presence objects classes 
features important theory useful practice private instance variables coercion primitives 
explore extensions consider interesting restriction language 
recursive types allowed recursion traverses object type objective ml conservative extension ml claimed 
course ml programs defined behave similarly 
programs syntactically ml programs typed ml programs typed objective ml 
implementation objective caml presence modules requires recursive types 
recursive object types may abstracted 
objective caml strictly speaking conservative extension ml 
conservative extension ml recursive types 

imperative features intentionally example 
formalize presentation objective ml preferred keep presentation simple put emphasis objects classes 
addition imperative features objective ml theoretically simple useful practically addition ml 
semantics properties reduction respect typing extend operations store problem 
formalization copies core ml 
fact implementation objective caml allows fields mutable similar way mutable record fields treated caml 
instance written class point struct field mutable method move class point int sig field mutable int method move int int objective caml allows generalization values slightly general class non expansive expressions 
creation object class considered value application function new arguments 
mutable fields classes typed fields mutability properties checked typechecking 

local bindings shown evaluation rules objects value method components bound rightmost definitions 
value components evaluated discarded 
object oriented languages offer security private instance variables 
scope field restricted field visible subclasses 
section presents local bindings visible body class appear 
weaker usually expects private fields class instance inherit field hide subclasses see section 
syntax extended follows 
local fd 
local corresponding typing rule local local local bindings reduced top inheritance local practice local bindings compiled anonymous fields 
methods independent local bindings 
initialization parameters seen local bindings class body compiled anonymous instance variables 
instance definition class point struct method automatically transformed equivalent program class point struct local method way method independent initialization parameter classes reduced class values inheritance reduced local bindings local bindings flattened method overriding resolved 

coercion primitives explicit coercions require domain domain specified 
eliminates need subtype inference 
practice sufficient indicate domain coercion domain coercion function domain 
convenience introduce collection coercion primitives 
free variables defined follows call positive occurrences term reached traversing arrow left hand side 
restrictive usual definition arrow treated contravariantly 
non recursive terms define closed object type occurs positively opened adding fresh row variable 
terms aliases viewed graphs equivalently pairs term list constraints renaming variables fresh variables 
positive occurrence replaced 
return 
theory practice object systems example int bool int bool operator properties gives correctness reduction step 
shows type type 
principal solution operator satisfying 
consider int int 
solutions int int int instance 
counter example shows weakness simulation subtyping row variables especially negative occurrences 
examples failure positive occurrences recursive types 
instance solutions solution general 
choice correspondingly choice coercion primitives arbitrary works practice 
justifies exclusion semi explicit coercions core language leave collection primitives 
fact coercions form 
domain coercion rarely needs 

short section describes possible extensions importance objective ml 
extension requires theoretical design investigation integrated objective caml 

restriction class interfaces section shown field components declared local class 
enable class components hidden posteriori 
assume instance library provides implementation class fields methods module may define class inherits imported class interface restriction class field method 
class import module 
problem corresponds common situation interface restriction reusing code 
interface restriction currently possible 
private fields difficult hide 
hiding methods subclasses conflicts late binding flat method name space 
instance assume method theory practice object systems implicitly hidden inherited class class defines method possibly type 
clearly method hidden class methods replaced calls function representing method complex operation difficult compile 
problem method appears type self 
hiding method requires modify posteriori type self 
correct instance type type method argument 
partial solution give method different view self inside classes 
usually case classes treated collection pre methods 
choice weaker useful split input output view self 
lists methods required enumerates methods provided 
presence type inference solutions tend increase size class point may unreadable 
gain expressiveness weakened detection errors 
clearly error method incompatible required provided types 
detected object created 
design objective ml deliberately limited expressiveness class types keep readable 
variations theoretically possible improve expressiveness significantly sacrificing simplicity 
possibility introduce private methods 
appear type self consequently invoked differently 
private methods scope fields 
particular hidden posteriori 
addition final classes resolve problem 
classes inherited 
class soundly matched final class interface omits methods 

polymorphic methods classical programming style functions data clearly separated 
functions polymorphic applied uniformly different kinds data 
data may structured 
rarely carries functions usually monomorphic 
objects data methods jointly defined stored passed arguments theoretical point view 
bound top level functions methods bound class objects 
unfortunately polymorphism lost transformation 
instance class implementing sets naturally provide fold method 
inferred class type form class set struct method fold rejected variable unbound set 
attempt fix problem parameterize class set replace set definition set 
intuitive object stays parametric fields ground type 
method fold monomorphic applied functions type object bound 
intuition course method fold polymorphic 
class set class type class set struct method fold 
addition polymorphic methods reduce number explicit coercions 
class definition methods may types polymorphic expected 
instance assume class point type class point int struct field int method getx int subclass point typecheck class eq point struct inherit point method eq getx self getx parameter method eq need point object method getx type int 
type getx int bool free row variable 
case set row variable type bound constraint type parameter follows class eq point struct inherit point method eq getx self getx class eq point int sig constraint getx int 
field int method getx int method eq bool intuitive prefer add stronger type constraint 
choice require type self 
unnecessarily eq binary method restricts arguments type eq point 
constraining point definition method eq possibility class eq point struct inherit point method eq point getx self getx class eq point int sig field int method getx int method eq point bool solution general usually requires explicit coercion invoking method eq eq point eq point polymorphic methods allow natural class type eq point definition class eq point int sig field int method getx int method eq getx int 
bool polymorphic anonymous row variable messages sent method eq argument type point eq point 
consider lack polymorphic methods weakness objective ml 
believe polymorphic methods explicit coercions unnecessary 
solutions extend ml exist literature 
simple rudimentary proposals better integration class polymorphism inside objective ml studied :10.1.1.27.5598

integrating classes modules objects classes objective ml orthogonal extensions ml 
particular module system ml extends directly classes objects 
implementation objective ml called objective caml offers rich language modules classes 
classes modules share lot properties offer form abstraction help structuring large applications facilitate reusability code 
fact quite different 
modules general powerful abstraction 
difficult allow recursion modules give meaning self inside modules 
hand classes specialized paradigm proved extremely convenient applications 
objects find limitation multiple dispatch 
hiding components remains difficult task 
historical reasons libraries objective caml implemented modules 
practice libraries rewritten classes 
choosing style insignificant global commitment architecture application 
class version module version libraries similar code currently shared 
course theory practice object systems unsatisfactory 
hope allow better integration modules classes 

comparison works closest objective ml ml art 
object types record types similar expressiveness 
state abstraction explicit existential types ml art objective ml obtained scope hiding explained simple form type abstraction 
coercion permitted ml art objects different interfaces 
unfortunately ml art type abbreviation mechanism 
major drawback motivated design objective ml 
hand classes class values ml art 
think major advantage 
restriction deliberate choice design objective ml keep language simpler 
theory features ml art kept objective ml 
practice changed language significantly 
simplification objective ml classes methods view self type 
required semantics technically relaxed making method types detailed classes see 
extra flexibility worth complication class types 
object types simplification 
simplification possible object types similar record types polymorphic access require counterpart record extension 
discussed implementation assumes stronger condition object types sharing row variable identical 
restriction object types equivalent kinded record types introduced 
ohori proposed efficient compilation polymorphic records scale extensible records 
approach correspondence types domains records applied compilation objects code free coercions 
objects widely studied languages higher order types :10.1.1.17.9345
proposals significantly differ objective ml 
types inferred explicitly user 
type abbreviations user responsibility 
contrary proposals allow implicit subtyping 
calculus differs significantly abadi cardelli primitive calculus objects result design choices 
chosen primitive classes inferred types sets pre methods complex readable see instance 
emphasized role row variables chosen infer subtyping avoiding complicated framework constraint types 
hand included features instance variables theory practice object systems avoid encoding methods involving self keep simple state abstraction mechanism scope hiding 
technically major difference objective ml allow method overriding 
open record types connected notion matching introduced kim bruce 
matching important subtyping object oriented languages 
row variables object types express matching natural way 
explicit matching may require type information type inference object matching practical 
palsberg proposed type inference order version abadi cardelli calculus primitive objects 
language missing important features higher order version 
type inference subtyping constraints technique similar 
proposal closer real programming language suited comparison 
authors subtyping relation expressive prove subtyping assumptions 
infer coercions 
types infer tend large 
abbreviation mechanism 
inheritance weaker explicitly list inherited methods subclasses 
think proposals complementary benefit 
particular interesting adapt automatic type abbreviations constraint types 
problem nontrivial inferred type constraints hard read absence objects 
remainder section dedicated comparison proposals adding objects ml 
implicit subtyping restricted atomic structural subtyping 
result difficulty parameterized classes making impossible relate objects created classes different number parameters objects interface 
instance objects class string incompatible type objects parameterized class vector parameter type character 
objective ml objects mixed 
bourdoncle metz propose language restricted form type constraints 
provide type inference 
proposals include type inference fully polymorphic method invocation typed 
different solutions proposed amount providing explicit type information method invocation 
precisely duggan proposal methods particular type scheme 
methods carry type information data type constructors ml 
instance move assigned type scheme int 
type schemes assigned methods polymorphic arrow types domain variable standing type self 
object types list methods objects type accept 
instance point type move user provide type information objective ml 
method name different objects unrelated types 
objects parameterized classes treated especially constructor kinds 
mentioned objects parameterized class reveal forever parameterized 
instance consider class vectors parameterized type 
methods class type scheme form ype ype 
variable range type constructors 
type self type constructor type hidden 
reveals dependence parameters parameters 
explained methods parameterized classes incompatible methods non parameterized classes 
conversely objective ml currently allow polymorphic methods duggan proposal 
polymorphic method map declared type scheme ype ype 


intuitively map carries implicit universal intros data constructors carry arguments existentially universally quantified types 
recursive kinds allow form polymorphism different polymorphic methods discussed section 
object ml reppy riecke treat objects generalized form concrete data types 
types inferred object ml authors claim principal type property 
method invocation mention class object method belongs 
object tagged constructor carries class object originated 
objects tested membership arbitrary class inheritance relationship 
single inheritance allowed 
subtyping relationship objects declared corresponds inheritance forest 
classes generative objects different classes different types 
types related subtyping instance relationship 
object coercions apparently implicit 
contrary objective ml classes transparent objects types structural describe interface objects objects exactly interface equal types 
objects classes subclass relationship necessarily related type simply instance 
object ml provide inheritance mechanism means encodings 
typing binary methods problem solved runtime class type tests 
objective ml designed core real programming language 
constructs implemented objective caml 
chose class objects approach understood type framework require higher order types 
original part design automatic abbreviation object types 
difficult essential making language practical 
demonstrated fully inferred object types unreadable 
contrary types objective ml clear require extremely little type information user 
knowledge existing approaches require type declarations 
objective ml interesting theoretically row variables 
row variables close matching helpful subtyping common operations objects 
message passing inheritance entirely row variables subtyping lower level 
interesting aspect proposal simplicity 
certainly due fact objective ml close ml 
specifically features rely ml polymorphism 
leads simple typing rules objects inheritance 
coercions subtyping explained 
data abstraction guaranteed scope hiding type abstraction powerful simpler concept 
main drawback objective ml need explicit coercions 
coercions necessary 
think occur places 
explicit coercions burden 
furthermore coercions theory implicit constraint type inference 
implementation objective ml classes modules fully compatible orthogonal 
particularly interesting compare styles largescale programming help better integrate 
important direction 
acknowledgments rowan davies collaborated implementation design precursor prototype objective ml 
notes 
syntax slightly modified order keep concrete syntax syntax closer 

may imagine relaxing constraint allow type redefined method subtype original method 
lose property believe important rule inherit shows type class gives self common instance different types self ancestors consequence type self class unifies type object subclass class 
theory practice object systems mart abadi luca cardelli 
theory primitive objects untyped order systems 
theoretical aspects computer software pages 
springer verlag april 
mart abadi luca cardelli 
theory primitive objects second order systems 
science computer programming december 
preliminary version appeared editor proceedings european symposium programming pages 
springer verlag april 
mart abadi luca cardelli 
theory objects 
springer 
roberto amadio luca cardelli 
subtyping recursive types 
transactions programming languages systems 
acm 
bernard 
programming behaviors ml framework syntax semantics lcs 
research report laas cnrs avenue du roche toulouse france march 
fran ois bourdoncle stephan merz 
type checking higher order polymorphic multi methods 
proceedings th acm conference principles programming languages pages july 
kim bruce 
typing object oriented languages achieving expressiveness safety 
appear 
kim bruce angela robert van gent 
type safe polymorphic object oriented language 
ecoop number lncs pages 
springer verlag 
peter canning william cook walter hill walter john mitchell 
bounded quantification object oriented programming 
fourth international conference functional programming languages computer architecture pages september 
dominic duggan 
polymorphic methods self types ml languages 
technical report cs university waterloo 
smith trifonov 
sound polymorphic type inference objects 
oopsla 
smith trifonov 
type inference recursively constrained types application oop 
mathematical foundations programming semantics 
chin mishra 
type inference subtypes 
esop volume lecture notes computer science pages 
springer verlag 
jacques didier 
extending ml semi explicit higher order polymorphism 
international symposium theoretical aspects computer software japan september 
claude kirchner jean pierre jouannaud 
solving equations algebras rule survey unification 
research report universit de paris sud orsay france april 
dexter kozen jens palsberg michael schwartzbach 
efficient recursive subtyping 
proc 
th symp 
principles programming languages pages 
acm press 
konstantin ufer martin odersky 
extension ml firstclass types 
proceedings acm sigplan workshop ml applications 
xavier leroy 
modular module system 
research report inria april 
xavier leroy 
objective caml system 
software documentation available web pauillac inria fr ocaml 
xavier leroy michel mauny 
dynamics ml 
journal functional programming 
xavier leroy pierre weis 
manuel de rence du langage caml 
inter ditions 
john mitchell 
coercion type inference 
eleventh annual symposium principles programming languages 
theory practice object systems john mitchell furio honsell kathleen fisher 
lambda calculus objects method specialization 
ieee symposium logic computer science june 
martin odersky konstantin ufer 
putting type annotations 
proceedings th acm conference principles programming languages january 
atsushi ohori 
extending ml polymorphism record structure 
technical report csc university glasgow department computer science september 
atsushi ohori 
polymorphic record calculus compilation 
acm transactions programming languages systems 
jens palsberg 
efficient type inference object types 
ninth annual ieee symposium logic computer science pages paris france july 
ieee computer society press 
appear information computation 
benjamin pierce david turner 
simple type theoretic foundations object oriented programming 
journal functional programming april 
preliminary version appeared principles programming languages university edinburgh technical report ecs lfcs title object oriented programming recursive types 
didier 
extending ml type system sorted equational theory 
research report institut national de recherche en informatique bp le chesnay cedex 
didier 
syntactic theories algebra record terms 
research report institut national de recherche en informatique bp le chesnay cedex 
didier 
programming objects ml art extension ml record types 
hagiya john mitchell editors theoretical aspects computer software volume lecture notes computer science pages 
springer verlag april 
didier 
type inference records natural extension ml 
carl gunter john mitchell editors theoretical aspects object oriented programming 
types semantics language design 
mit press 
john reppy jon riecke 
classes object ml 
fool workshop july 
john reppy jon riecke 
simple objects standard ml 
programming language design implementation 
acm may 
mitchell wand 
complete type inference simple objects 
gries editor second symposium logic computer science pages ithaca new york june 
ieee computer society press 
appendices 
typing rules core ml inst 
fun fun app gen generalization gen 
variables free 
example typing derivation section give typing derivation class scaled point 
focus explain type inference simply illustrate typing rules 
assume class point typed type scaled point environment containing class type point abbreviation move int int int sig point field int ref method move int int remind definition class scaled point fun struct inherit point parent field method scale method move fun parent move self scale remainder section proof class scaled point class type scaled point abbreviation move int int scale int int sig scaled point field int field int method move int int method scale int extended int extended self scaled point 
body inheritance clause typed equal 
rule class inst point int sig scaled point field int ref method move int int note chosen instance type class point self type scaled point instance type point 
rule class app point sig scaled point field int ref method move int int applying rule inherits get inherit point parent field int method move int int super parent field int method move int int rest class body typed environment equal extended field int super parent field int method move int int int rule field field field int 
rest class body typed equal extended field int 
int rule method method scale method scale int 
rules send super int int def fun parent move self scale theory practice object systems method move method move int int 
rule applied previous judgment method scale method move method scale int method move int int rule gain applied previous judgement field method scale method move field int method scale int method move int int rule applied previous judgement def inherit point parent field method scale method move def field int method move int int field int method scale int self scaled point applying rule class body leads struct sig scaled point rule class fun get fun struct int sig scaled point 
binary methods objective ml possible define binary methods methods receive parameter object type self 
furthermore class binary methods freely extended inheritance 
course binary methods remains binary subclass 
virtual class comparable template classes binary method leq 
component virtual leq type constraint type self 
method applied object type self 
class comparable struct virtual 
proofs type soundness theorems virtual leq bool class comparable unit sig virtual virtual leq bool class int comparable inherits class comparable 
implements method leq adds method getx 
class int comparable int struct inherit comparable field ref method getx method leq getx class int comparable int sig field int ref method leq bool method getx int method leq expects applied object type self 
type int comparable rec leq bool getx int subtype type comparable rec leq bool inheritance subtyping 
method leq object type expects applied object method getx ensured type 
int comparable instance comparable definition rec leq bool binary methods correctly handled type self kept open typing classes adding method getx class comparable simply amounts instantiating row variable type self getx int 
type self subclass method getx open 
test function min return minimum objects type instance type comparable 
min comparable leq value min comparable fun function applied objects type int comparable 
min new int comparable new int comparable getx int comparable int obj subject reduction straightforward combination redex contraction lemma context replacement lemma 
multiple syntactic categories expressions contexts types convenient introduce meta notations ec fd theory practice object systems meta letters consistently 
instance writing means 
propositions times proof 
proposition stability substitution substitution 
proposition extension environment type environments identical free variables expression 
type environment extends type environment dom 
say instance instance instance say type environment instance type environment type environments domain element domain instance 
proposition strengthening context type environment instance type environment 
lemma somewhat simplifies proofs 
lemma derivation simplification proving implies restrict oneself case derivation rule sub 
general case follows 
proof 
done induction size derivations 
assume derivation ends induction hypothesis sub sub write environment type 
likewise write resp 
environments class body type resp 
class type resp 

subject reduction theorem restated follows 
lemma context replacement context 
proof 
property proved independently arbitrary node context 
lemma follows trivial induction size context 
node context 
type environment type 
show 
lemma assume derivation rule sub 
cases simple similar 
show case example case derivation ends gen induction hypothesis applied premise lemmas simplify proof redex contraction 
lemma append typing environment containing super bindings 
method compatible correct 
proof 
prove general property 
sequence super bindings 
method compatible correct 
easily proved induction 
lemma term replacement variables type environment term expressions type expressions 
gen bound variables free provable 
theory practice object systems proof 
proof induction structure 
lemma assume derivation rule sub 
case consider derivation 
renaming substitution necessary proposition assume free variables appear free derivation 
write ax gen 
show complicated cases 
cases similar simple 
case derivation ends ax ax gen ax ax induction hypothesis applied get 
gen ax 
strengthening environment proposition gen subsequence ax 
conclude rule 
gen 
re ordering hypotheses gen ax gen 
strengthening environment replace ax free type variables free type variables replace gen 
gen 
hand bound extends deduce extension environment proposition 
apply induction hypothesis get 
combining rule 
case fun derivation ends ax fun ax fun 
re ordering type environment premise gen 
generalization gen equal gen gen 
gen 
bound extends deduce 
apply induction hypothesis get 
conclude rule fun case derivation ends self method object ax ay self re ordering type environment premise self gen 
replace gen gen strengthening environment 
generalization gen equal gen self gen ay 
ay gen ay 
just 
apply induction hypothesis ay get ay 
conclude rule object 
lemma term replacement instance variables self environment expression class expression object body object body type 
defines restriction dom fields 
write method assume bound variables free judgments hold self self method 
self field au au 
proof 
proof induction structure 
expression write self field au au class expression defined likewise 
write ay self method 
lemma assume derivation rule sub 
show complicated cases 
cases easy 
theory practice object systems case self hypothesis self method self 
equal 
hand equal conclude rule object case au derivation ends self method object field ay ay au ay au override field 
induction hypothesis applied get 
field field append lemma applied hypothesis self judgment yields self field 
derivation self field method object field lemma term replacement super super bound variables free invocations methods super replaced body corresponding method 
proof 
proof similar lemma 
fact simpler super substituted class object boundaries instance variable definitions 
lemma redex contraction write step reduction empty context 

proof 
proof done independently redex 
cases easy proven right lemmas 
assume equals resp 

show resp 
cases redex resp 

case shown independently 
lemma assume derivation rule sub 
case fun derivation ends fun fun sub fun app fun derivation rewritten fun fun fun sub fun fun fun app cases term replacement lemma applied shows 
case fun similar previous case 
case derivation ends gen term replacement lemma applied shows 
sub app theory practice object systems case class similar previous case 
case new struct derivation ends self class body struct sig method new new struct self method object case remember derivation ends self method object sub send self method object derivation rewritten self method object send send sub seen proof rule sub derivation ignored 
second case need considered 
result proved term replacement lemma 
show hypotheses lemma satisfied 
fields object typed environment object field vu field vu method 
easy induction rules field method yields self method contains field bindings environment extended include method self method term replacement lemma applied yields self field au au case inherit struct derivation ends inherit struct method inherit struct super continued self class body self struct sig inherit inherit struct super theory practice object systems self judgment rewritten 
applying term replacement lemma method environment extended yields method 
append lemma applied judgment gives result case field derivation ends field field field field field field dom fields appear methods easy induction shows 
fields typed environment methods typed environment field added anyway typing field appearing case method derivation ends self method method method method method dom dom method equal 
judgment rewritten method 
case derivation ends coerce sub normal form theorem proved structural induction values lemma 
lemma value 
assume 
functional type function 
object type object 
vc value 
assume vc 
functional type function 
object 
proof 
prove function functional type object object type 
value function object functional types object types incompatible proves lemma 
ignore rule sub derivation change shape type 
case fun derivation ends 
case derivation ends method proof similar class values 
fun fun self method object theory practice object systems theorem normal forms typed irreducible normal forms values reduced value 
proof 
proof structural induction simultaneously expressions class bodies assume resp 
contains field method bindings resp 
reduced 
case expression typed empty environment 
case possible 
derivation shows exists type 
induction hypothesis applied expression shows value 
functional type function fun 
expression reduced 
case possible 
induction hypothesis applied expression shows value 
expression reduced 
case class similar previous cases 
case fun definition expression value 
case possible expression typable empty environment 
case self au previous case 
case possible reduced 
case induction hypothesis shows object body value 
expression value 
case new possible 
derivation shows sig 
induction hypothesis applied shows value 
type structure 
reduced case expression typable empty environment 
case possible 
derivation shows exists type 
induction hypothesis applied expression shows class value 
functional type function fun 
expression reduced 
case fun definition expression value 
case struct induction hypothesis shows class body value 
expression value 
case induction hypothesis shows object component object body normal forms 
field method definition overridden reduced 
case definition object body value 
case inherit possible 
derivation ends self sig inherit inherit super induction hypothesis applied shows class value 
type form struct 
inheritance clause reduced 
case method definition expression normal form 
case field field contains field method bindings 
induction hypothesis expression normal form 
object component theory practice object systems 
