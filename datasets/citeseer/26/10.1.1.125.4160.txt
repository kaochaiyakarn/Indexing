secure multiparty computation approximations joan feigenbaum yuval ishai tal malkin nissim martin strauss rebecca wright approximation algorithms provide efficient solutions efficient exact computation known 
particular approximations useful distributed setting inputs held different parties may extremely large 
furthermore applications parties want compute function inputs securely revealing information necessary 
study question simultaneously addressing efficiency security concerns call secure approximations 
start extending standard definitions secure exact computation setting secure approximations 
definitions guarantee additional information revealed approximation follows output function approximated 
study complexity specific secure approximation problems 
particular obtain sublinear communication protocol securely approximating hamming distance polynomial time protocol securely approximating permanent related hard problems 
increasing number variety real world applications collect massive amount data wish 
example massive data sets arise physical sciences biology astronomy marketing network operations web searches 
search efficient effective data mining algorithms important emerging area research 
example see activities described 
unfortunately useful functions expensive compute 
functions efficiently computable moderately sized data sets efficiently computable massive data sets 
example quadratic algorithms generally considered practical input consisting terabyte data data sets routinely generated daily 
addition efficiency computation important concern security 
distributed setting pieces distributed data set may controlled different parties wish collaborate order compute function data fully revealing piece data parties 
parties may want compute function inputs securely party learns inputs implied output 
example rival preliminary version appeared proceedings th international colloquium automata languages programming icalp 
part done authors labs research 
partial support second fourth sixth authors provided dimacs 
computer science department yale university new haven ct usa 
joan feigenbaum yale edu 
supported part onr nsf ccr 
computer science department technion haifa israel 
cs technion ac il 
supported part israel science foundation 
department computer science columbia university new york ny usa 
tal cs columbia edu 
supported part nsf ccf 
department computer science ben gurion university beer israel 
cs bgu ac il 
partially done weizmann institute 
departments math eecs university michigan ann arbor mi usa umich edu 
stevens institute technology department computer science nj cs stevens tech edu 
supported part nsf ccr 
internet service providers strike peering agreements carries internet traffic cost long characteristics traffic carried peer comparable 
prospective peers data sets describing characteristics traffic verify similarity data sets revealing 
papers considered problem privacy preserving data mining recognizing desirable perform data mining revealing unnecessary information data 
separately concerns previously addressed 
hand cost exact computation function high parties may approximation cases communication small random sample part data set stored remote pieces suffices approximation 
cases communication result local computation depending entire local data set sufficient 
situations approximate computation typically requires communication computation exact computation original data set 
hand secure multiparty computation initiated allows group parties compute function revealing unnecessary information 
address concerns simultaneously 
construct approximation algorithms efficient exact computation maintain privacy data 
note straightforward approach simply computing approximation secure multiparty computation secure computation may leak information output 
information players inputs deducible output deducible output illustrate consider integer valued function approximation outputs 
xn bit possibly flipped bit odd 

xn approximation unnecessarily reveals parity 

provide definitions secure approximate multiparty computation disallow problems information leakage discussed secure approximation protocols natural functions 
massive data sets distance functions important give measure similarity data sets 
example telephone companies may want compute joint statistics calling data isps may want verify similar peering traffic characteristics web search companies may want compare images web 
exact distributed computation hamming distance similar distance functions requires linear communication sublinear communication distance approximations maintaining polynomial computation low storage ideally single pass raw data 
example papers algorithms efficiently approximating lp distances massive data sets :10.1.1.102.5483
approximations suffer kind information leakage described 
main technical contributions secure party protocol approximating hamming distance bit strings requiring communication bits 
relaxed model allowing offline interaction parties know inputs give secure approximation norm hamming distance efficient online communication 
techniques hamming distance protocol independently interesting applications communication complexity 
particular allow parties decide hamming distance inputs sending randomized message length referee 
solves open problem yao asking communication complexity better possible 
approximation algorithms useful setting data involved moderate size function computed computationally hard 
consider case provide secure approximation natural important complete problem permanent 
show techniques applied general class problems known non secure monte carlo markov chain approximations 
summarize main contributions follows definitions secure multiparty approximations application techniques brought attention ziv bar yossef joint jayram ravi kumar independently obtained similar solution yao problem 
sublinear communication solution hamming distance polynomial time solutions natural hard problems including permanent 
related 
communication efficient algorithms approximating hamming distance 
results translate efficient secure approximation protocols discussed section 
approach constructing secure sublinear communication protocols initiated context private information retrieval studied specific contexts general contexts 
naor nissim general methodology transforming protocols communication complexity model secure protocols low communication overhead 
secure protocols obtained applying methodology existing non secure low communication protocols approximate hamming distance yield solutions requiring super polynomial computation 
halevi consider secure approximations np hard functions show negative results 
specifically exist natural np hard functions size minimum vertex cover graph admit non trivial secure approximation admit approximation algorithms security restriction 
relaxation private approximation definition allows leakage little information 
definition demonstrate function admitting deterministic approximation admits private approximation related quality 
particular size minimum vertex cover may approximated factor leaking single bit information 
approach privacy perturbation received increasing attention agrawal srikant try hide sensitive data adding perturbation noise data yielding approximate utility 
suggested measuring privacy terms interval confidence directly related perturbation magnitude 
perturbed data demonstrate estimate underlying distribution 
approach different taken current 
achieve privacy carefully examining functionality approximation function making sure yields safe information implied exact function parties willing compute 
section show limitations types perturbation rounding adding random noise level privacy desired 
approach revisited agrawal aggarwal noted ability estimate underlying distribution significantly reduces interval confidence combination perturbed data consists privacy breach 
suggested measure privacy terms mutual information data perturbed version 
subsequent gehrke srikant noted low mutual information allows severe privacy breaches occur small noticeable probability suggested robust notion privacy breaches 
nissim addressed question functions may computed statistical databases adversely affecting privacy 
considered approximate answers statistical queries showed privacy affected function approximation quality 
particular showed perturbation smaller magnitude size data results strong violation privacy 
approach pursued dwork nissim privacy definition analogous semantic security 
alternative approach data privacy proposed chawla formalizing notion privacy brought attention 
publication earlier version freedman nissim pinkas gave efficient private approximation protocol computing intersection size databases :10.1.1.125.4160
protocols uses generalized version private sample xor protocol section 
organization 
provide background definitions approximations secure multiparty computation section 
give definitions secure multiparty approximations section 
section discuss rounding useful providing private approximations 
main private approximation protocols section hamming distance section hard problems 
conclude section additional discussion 
background section background notation approximation secure multiparty computation 
serves input length parameter 
measure complexity protocols quality approximation success adversary attacking functions function negligible asymptotically smaller inverse polynomial function overwhelming negligible 
standard asymptotic notation slightly nonstandard way 
default assertion form read arbitrarily small constant 
case stronger standard assertion log holds 
fact default cryptographic assumptions replaced stronger ones occurrences replaced log 
see discussion theorem concrete discussion assumptions 
distribution ensemble dx family probability distributions indexed infinite set binary strings 
take case indices viewed natural numbers 
definition distribution ensembles dx statistically indistinguishable written negligible function sd dx sd denotes statistical distance defined sd pr pr 
ensembles computationally indistinguishable written family cn polynomial size circuits exists negligible function length approximations pr cn dx pr cn 
approximation requirement binary relation deterministic real valued function called target function possibly randomized real valued function called approximation function 
relation defines functions considered approximations 
say approximation holds 
say algorithm protocol approximates outputs standard requirement referred approximation defined follows 
definition say approximation inputs probability randomness pr primarily refer approximations 
approximation may functions input length parameter 
omit failure probability case understood negligible 
folklore lemma chernoff bound argument proofs 
informally says random variable variance small compared mean mean estimated efficiently multiple samples lemma real valued random variable suppose ce exists random variable pr function log independent samples proof average independent copies var 
chebychev inequality pr var 
median log independent copies iff half yi yi 
ai yi ai ai 
ai follows pr pr pr follows version chernoff bound see 
secure multiparty computation secure multiparty computation allows parties evaluate specified function inputs hiding inputs 
formally defining security convenient think adversary tries gain advantage corrupting parties execution protocol 
security defined requiring adversary achieves real life execution protocol efficiently simulate ideal process trusted party evaluate function 
protocol prevents adversary gaining extra advantage gained ideal solution 
notions security various degrees strength :10.1.1.21.4870
deal special case private computation assumes adversary passive called honest curious modify behavior corrupted parties 
particular private computation concerned information learned adversary effect misbehavior may protocol correctness 
general definitions apply case active adversary modify corrupted parties behavior arbitrarily 
sequel term secure discussion applies active passive case term private passive case 
distinction different notions security extent transcript produced ideal process adversary resemble produced real life execution protocol 
standard variants perfect statistical computational indistinguishability 
naturally define corresponding notions perfect statistical computational security 
focus mainly party case computational security achieved 
definitions results apply variants 
define private party computation closely definition goldreich 
multiparty definition analogous 
functionality 
party computation task specified possibly randomized mapping pair inputs pair outputs refer mapping functionality simply function 
loss generality assume inputs length case padding may applied 
refer single output functionalities case outputs corresponding output functionality assumed identical 
protocol 
party protocol defined pair probabilistic polynomial time interactive algorithms 
protocol executed follows 
initially alice operates receives input random input ra bob operates receives input random input rb 
assume execution proceeds synchronous rounds round party may send party message specified input random input messages received previous rounds 
round party may decide terminate output value entire view consisting input random input received messages 
private computation 
defining privacy respect functionality convenient notation 
consider probability space induced execution input induced independent choices random inputs ra rb 
view resp view denote entire view alice resp bob execution including input random input messages received 
output resp output denote alice resp bob output 
note random variables defined probability space 
definition set valid inputs pairs equal length binary strings 
protocol private protocol computing properties hold correctness 
joint outputs protocol distributed 
formally output output ga gb ga gb joint distribution outputs 
privacy 
exist probabilistic polynomial time algorithms sa sb called simulators sa ga gb view output ga sb gb output view privacy requirement asserts real life adversary learns passively corrupting party ideal process adversary simulate learning input output party 
note definition consider view corrupted party concatenates view output uncorrupted party 
functionality randomized serves ensure adversary learn additional information output party correlations real life process absent ideal process 
general plausibility results secure computation obtained yao goldreich micali wigderson 
theorem relates complexity privately computing functionality circuit size theorem cn uniform family deterministic probabilistic boolean circuits size input cn viewed pair bit strings output pair strings 
denote functionality computed family assuming existence trapdoor permutations homomorphic encryption schemes privately computed rounds bits communication 
similar statement holds constant number rounds parties adversary active see 
particularly useful private computation task oblivious transfer defined 
definition oblivious transfer choose oblivious transfer protocol security passive adversary abbreviated ot private protocol deterministic functionality parties sender receiver 
sender input bit string receiver input index 
receiver outputs bit xi sender output 
theorem ot implemented nearly linear communication 
ot functionality admits efficient solutions theorem assuming existence homomorphic encryption scheme round ot protocol bits communication :10.1.1.14.1940
probabilistic circuit includes addition standard inputs polynomial number random inputs 
loosely speaking semantically secure encryption scheme said homomorphic plaintexts taken group encryptions group elements possible efficiently compute random encryption 
homomorphic encryption variety intractability assumptions including quadratic residuosity assumption decisional diffie hellman assumption 
complexity vs assumptions 
noted start section asymptotic complexity notation read default arbitrarily small constant 
theorem theorem read logo stronger cryptographic assumptions 
specifically theorem suffices assume trapdoor permutations homomorphic encryption secure sub exponential adversaries theorem suffices assume specific number theoretic assumptions :10.1.1.26.7042
efficiency improvement resulting stronger assumptions significant purposes conservative assumptions default 
secure approximations section definition secure approximations 
preclude computation approximation leaking unnecessary information definitions require computation approximate output reveal parties inputs outputs approximate output approximate output reveal parties inputs outputs exact output 
restrict attention approximation deterministic function mapping input 
xm non negative number string xi input held ith party inputs xi assumed length 
start defining notion functional privacy main definition relies 
informally say possibly randomized approximation function functionally private respect target function output reveals information input 
note inherent property function particular protocol computing notion functional privacy formally defined follows 
definition functional privacy possibly randomized function 
say functionally private respect exists probabilistic polynomial time simulator input distribution indistinguishable 
definition secure approximation requires protocol securely computes functionally private approximation defined single output function fix convention extending multi output function 
party case default interpretation function multi party setting assumes single value sampled output parties 
stress conventions possible general treatment allow specifying admissible collection multi output approximations 
prefer simplicity generality 
discussion formalized definition may instantiated notion security active passive adversary computational statistical perfect indistinguishability 
definition secure approximation 
protocol secure approximation protocol securely computes possibly randomized function functionally private respect approximation intuitively functional privacy respect says input output relation protocol reveal revealed learning secure computation ensures additional revealed computation 
secure approximations useful settings inputs small target function intractable settings inputs massive 
type settings simple corollary theorem definition useful note parties receive identical outputs outputs perfectly correlated 
important cases include single player getting output players getting players getting independent outputs distribution 
note single output case formally private player broadcast answer getting identical output case players exchange roles run new single output protocols getting independent output case 
private single output protocols harder construct simulator output player simulate player view protocol output simulator input 
theorem suppose admits functionally private approximation computed probabilistic polynomial time 
admits efficient secure approximation protocol protocol poly communication computation 
alternative definition describe liberal alternative definition useful protocols 
motivate alternative definition consider artificial protocol invokes secure protocol exactly computing instructs party output functionally private approximation computed output considered secure approximation protocol 
definition generally considered secure value learned parties may reveal strictly information value computed 
reasonable allow protocol messages secure approximation tolerate privacy loss implied exact computation functional privacy bound allows leakage 
fact higher level privacy achieved protocol messages output settling approximate computation necessarily turned requirement 
discussion gives rise definition 
simplicity formulate definition case private party computation modifying definition discuss general case 
definition private approximation liberal definition deterministic functionality mapping inputs single output 
party protocol private approximation protocol liberal sense exists functionally private approximation requirements hold correctness 
joint outputs protocol distributed outputs identical independent 
privacy 
exist probabilistic polynomial time algorithms sa sb sa view output sb output view distinct occurrences expressions assumed take value 
general formulation liberal definition uses relaxation standard framework defining security may viewed generalizing slightly simplified form standard definitions literature 
similar standard definitions compare interaction real life adversary real protocol interaction ideal process adversary ideal function evaluation process involving trusted party 
default definition definition trusted party receives input party sends value parties 
liberal definition definition trusted party computes sends value functionally private approximation 
uncorrupted parties output approximate value exact value ideal process adversary produce simulated transcript 
simplicity restrict attention nonadaptive adversaries decide set corrupted parties execution protocol 
definitions results extend adaptive case 
party protocol adversary corrupting parties 
similarly definitions definition compares interaction adversary real life protocol interaction adversary ideal process evaluating target function real life model :10.1.1.21.4870
real life model defined exactly standard definitions 
interaction adversary real life model captured random variable real 
random variable set view attacking execution input concatenated outputs uncorrupted parties 
adversary view includes inputs random inputs messages viewed corrupted parties 
concatenation view outputs non corrupted parties serves purposes 
captures information adversary may learn outputs uncorrupted parties 
second captures correctness requirement protocol possibly presence active adversary tries alter outputs uncorrupted parties 
ideal process 
describe standard case exact computation address required modification defining secure approximations 
ideal process parameterized target function may general possibly randomized mapping inputs outputs 
context approximations convenient restrict deterministic single output function 
adversary corrupting ideal process referred ideal process adversary simulator 
ideal process proceeds follows 
decides set parties corrupt security threshold 
adversary active may modify inputs parties corrupts observed values 
subsequently parties send inputs trusted party evaluates function hands outputs corresponding party 
single output randomized function convention party receives identical instance output 
inputs outputs corrupted parties adversary produces output supposed emulate transcript real life protocol 
interaction adversary ideal process input captured random variable ideal containing adversary output concatenated outputs uncorrupted parties 
define secure computation approximations modify ideal model defined call ideal model 
single output possibly randomized corresponding random variable ideal defined similarly modification 
sending values single function parties trusted party evaluates inputs receives sends values parties 
uncorrupted passively corrupted parties output value 
function models information allow adversary learn captures correctness requirement outputs uncorrupted parties 
default target function philosophically justified fact approximating function implicitly willing pay privacy compromise implied knowledge cases may desirable choose reveals strictly information formulation provides convenient means formalizing type extra security provided cases 
letting gets precisely default strict notion definition 
formalize liberal definition secure approximation protocol 
definition protocol said perfectly statistically computationally secure approximation protocol liberal sense exists functionally private approximation holds 
probabilistic polynomial time adversary corrupting parties real life model exists probabilistic polynomial time simulator corrupting parties ideal process real ideal denotes perfect statistical computational indistinguishability 
consider default case computationally secure party protocol security holds passive adversary 
comparison definitions 
results quite insensitive distinction definitions instructive compare justify choice stricter definition default 
advantage default definition uses standard notion exact secure computation black box applied conjunction possible definition security 
second advantage subtle applies case function intractable 
liberal definition general form allows ideal process adversary interact trusted party computes exact value setting security active adversary adversary may choose inputs computation view original inputs effectively gains restricted oracle access may potentially perform impossible tasks inverting way function input choice 
contrast default definition allows ideal process adversary learn value efficiently computable function distinction appears blurred fact defining functional privacy requirement simulator access exact value simulating simulator allowed learn value input input control 
note default definition strictly stronger liberal definition securely liberal sense converse statement true general 
indicated positive results obtained remainder apply default definition liberal definition 
main protocol section takes simpler natural form liberal definition 
rounding precision section note obvious approach insecure approximation making secure adding random noise masking low order bits generally 
cases useful 
show rounding generally provide functional privacy 
show adding random noise provide functional privacy generally efficient 
show finite precision approximations real valued functions done way provides functional privacy 
rounding 
consider approximation high probability rounding power 
check result range high probability 
consider function approximation takes real values large range high precision inputs source randomness vary 
suppose sets inputs distributed differently 
satisfies definition functional privacy respect rounding need consider 
perfect indistinguishability setting pr pr 
require private approximation distributions unlucky value happen take values large range pr pr follows rounded power functionally private respect satisfies rounding technique works checked readily 
somewhat weaker conditions possible general rounding provide functional privacy 
adding random noise 
suppose approximation scheme output number factor probability 
construct secure approximation follows 
security parameter distributions considered statistically indistinguishable statistical difference construct approximation output factor 
uniformly random interval 
readily check procedure yields approximation scheme final output private approximation unfortunately procedure efficient approximation usable obtain essentially exact solution small 
definition hard compute approximation factor requires time polylog compute procedure requires time polynomial taken small procedure simple straightforward solution 
finite precision approximations real valued outputs 
approximation algorithms naturally described real valued functions intermediate values outputs 
example approximation section output median means numbers form si ai bi ai bi inputs si unit gaussian distributed random variable 
functional privacy approximation depends fact identically distributed unit gaussian random variable 
extent si true gaussians due rounding distributions identical computationally indistinguishable general 
worry functional privacy destroyed 
generally worry simple symbolic mathematical function straightforward finite precision implementations functionally private respect worse may computable functionally private implementation allowing high cost 
show approximation relation resulting finite precision approximations mathematical functions private adding noise 
give self contained example state theorem argument simple function additive approximation model techniques generalize functions models 
consider function log xy section logarithm base 
symbolic statement 
consider protocol alice computes approximation log bob computes finite precision approximation log output 
straightforward real world implementations function computed functionally private respect practical terms adversary undesirably distinguish inputs exactly roundoff error 
straightforward finite precision computation exact computation finite precision sense functionally private respect symbolic function 
remedy exploit real valued exact computability meaning compute log time log compute private finite precision approximation proceed follows 
security parameter compute add uniformly random noise range 
previous paragraph gives statistically private approximation output 
situation log exactly computable cost compute output just polynomial desired 
general theorem 
theorem multivariate function integers reals short symbolic description 
suppose integer compute value time exists function integers finite precision reals 
approximation 

efficiency 
computable time 
functionally private 
symbolically 
real valued exact computation statistically functionally private parallels discrete situation discrete valued exact computation trivially automatically perfectly functionally private 
sublinear private approximation hamming distance section private party protocol computing approximate hamming distance 
give sublinear communication protocols related problems 
hamming distance protocol allows alice holding input bob holding learn approximation hamming distance negligible failure probability learning additional information party input follows hamming distance 
protocol requires roughly bits communication rounds interaction 
contrast exact computation hamming distance requires communication small failure probability allowed 
dh denote hamming distance wh denote hamming weight bit string describing private protocol instructive consider non private variant problem 
briefly survey known communication efficient solutions explain naive attempt solutions private fails 
known methods approximating hamming distance polylogarithmic communication :10.1.1.102.5483
specifically best approximations require log log communication 
methods viewed sketching approach 
definition sketching protocol argument function defined sketching function mapping input random string sketch consisting typically short string 
deterministic reconstruction function mapping pair sketches approximate output 
inputs protocol proceeds follows 
alice bob locally compute sketch sa sb respectively common random input 
parties exchange sketches locally output sa sb 
denote randomized function defined output protocol inputs sketching protocol said approximate approximates clearly communication complexity sketching protocol proportional sketch size 

definition convenient assume parties share polynomially long common random input string 
assumption dispensed low cost pseudorandomness done protocols 
consider linear sketching functions ax bs vectors scalars arithmetic performed finite field reals 
special case may select sample positions furthermore takes form bs refer single input function reconstruction function 
briefly review efficient sketching protocol hamming distance 
example sketching protocol hamming distance 
common random input define valued matrix log rows columns entry ith row independently takes value probability pi constant depending 
sketching function defined rx viewed matrix vector gf respectively 
sketches ra rb distance dh approximated roughly observing ra rb probability close dh pi probability close dh pi 
generally approximation obtained matrix log log rows 
communication complexity sketching protocol log log assuming common random input available 
goal obtain sublinear communication private approximation protocol hamming distance 
natural approach seek general method converting efficient sketching protocol approximating function private protocol approximating suppose randomized function induced sketching protocol functionally private respect case sketching protocol example sketching protocols hamming distance proposed literature 
approximate privately suffices parties privately compute randomized function theorem general purpose private computation protocol evaluate communication complexity linear obtain sublinear communication private protocol glance straightforward protocol 
parties locally compute sketch individual inputs common random input apply general purpose private computation protocol evaluate sa sb sketches sa sb 
theorem sketches short complex entire protocol implemented sublinear communication 
protocol generally fails private 
consider related protocol computes securely computes clear 
note function functionally private respect dh knowing output random input generate output reveal additional information inputs 
instance protocol alice deduce rb input output common random input hard see dh impossible generate distributed example rb holds overwhelming probability 
instance ei dh equal ith column impossible guess high probability dh 
view alice simulated ideal process naive solution fails 
know sketching method example private sublinear communication able obtain private protocol efficient protocol approximating hamming distance appearing literature 
design new sketching protocol induced randomized approximation privately computed sublinear communication 
solution combination different sketching protocols referred estimators 
estimator sampling gives approximation distance high 
provide special purpose low communication private protocol computing estimator 
heart special purpose private protocol comparing bits random location may independent interest 
second estimator gives approximation distance low fact produces exact result case 
provide alternative implementations estimator hashing reed solomon codes 
case output low distance estimator taken randomness information revealed follows hamming distance 
case general purpose private computation naive approach described loss privacy 
sections describe private estimators separately combine obtain final protocol 
high distance estimator suppose dh guaranteed larger threshold dmin specify 
dmin large alice bob efficiently approximate randomly sampling small number bits matching positions inputs 
viewed simple sketching protocol common random input includes random indices sketch contains bits indexed random input output obtained scaling relative distance sketches 
specifically alice bob count number differences dmin log randomly selected matching bits inputs compute estimate chernoff bound approximation note randomized function induced sketching protocol functionally private respect dh 
show privately compute small communication complexity 
main tool private protocol comparing randomly sampled pair bits 
formally protocol computes randomized function sample xor defined sample xor ar br 
note private protocol sample xor keep choice secret party 
describes private protocol function sample xor uses ot subprotocol 
denote cyclic shift bits left string ith bit xi lemma private sample xor private protocol computing randomized function sample xor 
turns similarly parties general purpose secure computation evaluate sa sb sa sb revealing generally impossible knowing dh generate distributed sa sb 
intuitively information rb leaks rb rb sensitive general 
private sample xor 
alice picks random mask ma random shift amount ra 
def computes bit string ra ma 
symmetrically bob picks mb rb def computes rb mb 

alice bob invoke parallel ot protocols alice retrieves za bob retrieves zb def def bob def alice 

alice sends za ma bob 
bob sends parties locally output def zb mb alice 
private protocol function sample xor proof correctness protocol follows observing za rb ra mb ra rb mb symmetrically zb ra rb ma addition indices taken modulo 
parties output za zb ma mb ra rb ra rb ra rb uniformly distributed index 
intuitively privacy protocol follows fact process obtaining output ra rb ra rb party learns ra rb ra rb ra rb 
formally simulator alice view may proceed follows 
input output value 
pick random ra ma 
def 
za ma 
invoke simulator ot protocol twice alice receiver having input ra output za alice sender having input ra ma 
view view denote views produced simulations 

output ra ma view view 
simulator bob view may obtained similarly 
approximation parameters private sampling estimator high distance case implemented dmin log parallel invocations protocol private sample xor 
properties summarized lemma 
lemma private approximation high distance case 
ot arbitrary ot protocol security passive adversary 
exists protocol high approximating dh communication complexity dmin log times ot round complexity plus ot dh dmin protocol high outputs approximation overwhelming probability 
output high functionally private respect dh 
high privately computes output 
specifically alice resp bob simulate view input conditioned output input resp input 
proof protocol high proceeds described parties invoke protocol private sample xor dmin log times parallel sum outputs output approximation quality output follows chernoff bound functional privacy follows symmetry 
simulators alice bob proceed follows gs pick random tuple 
zs zi invoke simulator private sample xor see lemma times zi output concatenation simulated transcripts 
note sampling estimator give reliable estimate distance significantly smaller dmin variance high 
differences detected 
low distance estimator consider low distance case dmax threshold dmax specified 
design alternative private protocols case sketching protocol properties induced function determined dh 
negligible probability takes specific value determined dh 
value equal dh dh dmax fail 
property implement private computation low distance estimator property guarantees functional privacy output entire range inputs correctness case distance low 
note sketching protocol satisfying property private computation may proceed naive approach described 
parties may locally compute sketches inputs common random input apply general purpose private computation protocol evaluating reconstruction function sketches 
intuitively case common random input gives information inputs follows protocol communication efficient important computed small circuit preferably linear nearly linear sketch size 
describe different sketching protocols 
hashing 
advantages description self contained requires private computation simple reconstruction function 
give alternate protocol reed solomon codes 
reconstruction function quite complex consequently private implementation requires heavy generic private computation asymptotic efficiency purposes 
protocol hashing 
common random input define independent universal hash functions 
correctness parameter log log dmax sufficient guarantee error bound sketch input computed follows 
randomly partition bits dmax buckets equal size 
probability bucket gets log dmax bits differ 

dmax buckets partition bits log dmax sub buckets 
bucket contains log dmax differences sub buckets contains difference constant probability 
repeat procedure independent times denote contents jth sub bucket ith bucket hth invocation dmax log dmax 

hash contents sub bucket bit string 
sketch string consists dmax log dmax strings obtained process 
denote correlated values process applied inputs random input 
lemma suppose dh dmax 
probability dmax dh dmax max log dmax 
proof noted description sketching function attempts secondary hashing succeeds constant probability isolate bit differences mapped bucket 
probability succeeds 
instance probability third level hashing mapping distinct values bit string claim follows union bound argument 
suppose reconstruction function sketching protocol defined right hand side eq 

symmetry output functionally private 
fails determined dh entire range inputs naive private implementation 
case simple modification reconstruction function fix situation 
modified reconstruction computes estimate applying right hand side eq 
sketches outputs dmax output fail 
properties modified sketching protocol denoted summarized lemma 
lemma letting sketching protocol induced randomized function satisfy properties output length dmax circuit size reconstruction function 
dh dmax overwhelming probability 
dmax outputs fail overwhelming probability 
proof specified complexity bounds follow easily description 
particular circuit size required computing right hand side eq 
linear length sketch 
correctness property follows lemma 
second follows fact dmax right hand size eq 
bigger dmax overwhelming probability 
shown similarly proof lemma 
protocol reed solomon codes 
describe alternative sketching protocol section 
protocol satisfies properties guaranteed lemma low distance protocol low lemma 
start describing simpler variant protocol give reliable indication failure case distance high 
variant relies error correcting codes finding locations strings differ 
similar error correcting codes related context previously communication complexity literature cf 

finite field view inputs vectors parity check matrix reed solomon code distance dmax dimension length dmax 
matrix dmax rows columns 
wh dmax uniquely recovered syndrome hx viewed corrupted encoding 
facts imply non private sketching protocol hamming distance promise smaller dmax 
sketching function deterministic defined hx 
reconstruction proceeds follows 
syndromes ha hb compute syndrome 
output dh computed recovering syndrome outputting weight 
choosing field size sketch size dmax log 
follows known methods decoding reed solomon codes circuit complexity reconstruction function dmax required 
output function induced sketching protocol reliably indicate failure distance larger dmax 
follows fact exist wh wh dmax applying decoding procedure hx hx yields different number errors 
modify construction dmax outputs fail overwhelming probability 
modified sketching protocol uses bit random input interpreted key pseudorandom function hr gf 
possible outputs hr define pseudorandom matrix gf satisfying properties ith column computed circuit size nonzero gf probability rx negligible probability uniform choice 
general pseudorandom functions simplicity efficient constructions small bias probability spaces 
sketching function defined hx rx matrix defined hr 
reconstruction proceeds follows 
ha hb decode 
counting number errors time locations test reliably differ exactly specified places 
denote error vector produced decoding algorithm 
note wh dmax dh dmax 
reconstruction procedure tests ra rb rve 
test succeeds reconstruction function outputs number errors outputs fail 
properties hr may conclude reconstruction implemented circuit size ko dmax dmax dh dmax probability dmax outputs fail overwhelming probability 
final sketching protocol satisfies desired properties guaranteed lemma 
application communication complexity 
sketching methods low distance case applied solve communication complexity problem posed yao see footnote section 
suppose alice bob hold input string length common random input 
wish determine hamming distance inputs bounded send message referee output correct answer high probability say greater 
sketching methods low distance case directly yield solutions problem 
method gives protocol communication complexity polylog method reed solomon codes gives protocol communication complexity log 
similar complexity obtained standard party communication complexity model suitable derandomization common random string 
note dependence bound log inherent coding approach sketch reveals number places inputs differ locations 
contrast hashing approach reveals hamming distance inputs 
protocols 
hashing sketching protocol reed sketching protocol private protocol low distance case may constructed outlined section 
lemma private approximation low distance case 
suppose assumptions theorem holds 
dmax exists round protocol low dmax communication dh dmax protocol low outputs exact value overwhelming probability dh dmax protocol low outputs fail overwhelming probability 
output low indistinguishable function functionally private respect dh 
low privately computes output 
proof sketching protocol satisfying properties lemma 
protocol low required may proceed follows 
round alice sends bob seed length pseudorandom generator produce sufficiently long common random input 
party locally applies sketching function input common random input invoke protocol privately evaluating reconstruction function sketches 
theorem requires additional rounds dmax communication 
argue low satisfies required properties 
follow immediately assumptions properties pseudorandom generator 
functional privacy property follows defining dh distance dmax fail 
simulator shows privacy low 
describe alice simulator bob simulator similar 
input pick random seed pseudorandom generator expand common input compute sketch sa feed simulator private protocol denote transcript produced simulator 
output 
correctness simulator follows fact real life execution low output independent seed 
combined protocol protocols low high lemma lemma subprotocols full protocol proceeds follows 
desired approximation quality invoke protocol high lemma parameters dmin 
denote output 
parallel invoke protocol low lemma parameter dmax 
denote output 
fail output output 
lemma protocol private approximation protocol dh liberal sense 
proof randomized function computed obtained outputs high low respectively 
functional privacy properties respect dh see lemmas final output indistinguishable functionally private respect dh 
approximation property follows facts dmax overwhelming probability final output produced high dmax dmin output correct dmax produced low distance subprotocol guaranteed case correct overwhelming probability 
remains show satisfies liberal privacy requirement definition 
usual describe simulator alice 
inputs dh sample conditioned dmax sample binomial distribution parameters number trials protocol high multiply compute dmax fail 
invoke simulator high low 
output concatenation generated transcripts 
correctness simulator follows fact joint distribution induced simulator indistinguishable real life protocol correctness simulators high low 

protocol described satisfy stricter notion private approximation defined definition 
intermediate outputs may give information implied protocol final output specifically output slightly lower threshold dmax output determine dmax output low 
privately compute output point easily modified satisfy stricter privacy requirement 
way achieving hiding intermediate results final outcome 
done modifying high low outputs secret shared parties applying private protocol compute shared refers relaxed notion private approximation defined definition 
modifications satisfy strict definition discussed proof lemma 
outputs subprotocols 
efficient alternative incorporate additional information revealed output achieved slightly perturbing output value encodes significantly changing approximation quality 
substituting complexity parameters subprotocols ot protocol theorem get main result section theorem assuming existence homomorphic encryption hamming distance function privately approximated communication complexity rounds interaction 
section show possible obtain improved efficiency relaxed model offline communication 
polylogarithmic protocol offline communication section obtain efficient private approximation protocols scenario 
suppose alice bob allowed communicate bits zero cost receive inputs 
charge online communication performed learn inputs 
model give private protocols communication cost 
consider distance ai bi ai bi sequences integers 
solution hamming distance follows special case 
essentially verify protocol functionally private efficiently implemented private protocol model 
alice bob share vector si samples gaussian distribution 
samples encrypted homomorphic public key encryption form encryption decrypted knowing secret key encryptions secret key form encryption 
threshold homomorphic encryption scheme alice bob split decrypt decrypt 
prescribed alice form 
context forms follows 
forms si ai time log ai homomorphic properties encryption repeated doubling 
forms homomorphic properties encryption 
alice bob form si ai bi homomorphic properties encryption 
insecure protocol prescribes compute si ai bi repeat take medians means lemma 
setting alice bob perform median means squares decryptions si ai bi values secure multiparty computation 
described small circuit 
correctness easy verify fact expected value 
privacy messages immediate construction 
functional privacy observe result depends ai bi alice bob allowed learn ai bi euclidean distance inputs 
known property gaussian distribution product si gaussians spherically symmetrical distribution 
functional privacy follows immediately 
secure approximations hard functions turn attention securely approximating natural hard problems goal achieve polynomial time secure approximations 
contrast problems massive data sets focusing far polynomial time exact computation possible goal achieve square distance ai bi equivalent distance perspective computation privacy 
henceforth consider easier read square distance 
samples indistinguishable finite precision approximations real valued gaussian samples 
suffices see section 
case assume adversary resources polynomial break encryption 
section need assume cryptographic operations decryption key homomorphic transformation done time polylogarithmic time comparable time needed operations 
similarly assume ciphertext longer cleartext factor polylogarithmic assume exponential strength cryptographic operations 
weaker cryptographic operations available cryptographic operations efficiency bottleneck 
lower complexity sublinear hamming distance case 
section efficient interpreted probabilistic polynomial time 
theorem current setting sufficient design efficiently computable private approximation problem hand 
start observing artificially constructing hard problems satisfy property straightforward 
example consider hard problem output range 
computationally equivalent particular computationally interesting iff values factor private approximation approximation approximate interesting quantity 
general exact hard problem may interesting approximate versions may 
section give private approximations natural hard problems notably permanent known complete problem 
subsections provide motivation problem context protocol securely approximating permanent arbitrary matrix non negative entries algorithm extensions methods hard problems 
permanent applications permanent matrix defined permutations 
contribute sum 
valued matrix counts number perfect matchings corresponding bipartite graph defined adjacency matrix 
counting number perfect matchings hard problem 
expect hard problems permanent applications wide variety counting problems including arise naturally physics 
obvious true natural problems reduce permanent approximation preserving way approximation permanent yields polynomially related approximation problems 
clearly private approximation permanent immediately yields private approximation problem reduces permanent approximation preserving way 
example number tilings certain lattices easily expressed permanent approximation permanent gives approximate count number tilings 
example bond order edge certain graph representation molecule reduces permanent computation approximation preserving way 
omit definition bond order note serves useful theoretical prediction physical strength molecular bond 
secure approximation permanent section show privately compute approximation permanent shared matrix polynomial time 
specifically matrices bit non negative entries 
theorem sufficient obtain efficiently computable functionally private approximation permanent 
non secure permanent string results culminating result jerrum sinclair provides efficient approximation algorithms permanent arbitrary matrix non negative entries 
build techniques construct functionally private approximation 
purposes algorithm may viewed consisting stages 
design efficient randomized algorithm satisfying requirement 
matrix output statistically indistinguishable bernoulli random variable success probability pi pi differs definition determinant sign permutation missing sum 
course permanent quite determinant particular permanent complete 
slightly abusing previous notation total length input 
pi poly 
refer ith coin allows efficiently construct coin success probability differs negligibly pi 

sampling constructed coins approximate pi efficiently 

multiply approximations obtain approximation product 
note central technical component predecessors construction coins stage uses monte carlo markov chain method sample set perfect matchings graph distribution statistically indistinguishable uniform 
achieving functional privacy goal obtain functionally private approximation permanent 
considering algorithm outlined observe sampling approximation pi stage functionally private respect pi 
product approximations potentially leak information factors standard deviation depends factors stage results non private output 
avoid leakage tempted estimate product sample joint distribution coins 
pn output iff coins output 
results coin success probability negligibly different product pi 
approximating product way efficient product may exponentially small polynomial number samples produced approximation zero 
goal reduces designing efficient functionally private approximation product pi coins success probabilities pi 
achieve goal designing coin success nearly done manipulating success probabilities coins produce new coins sub convex combinations original probabilities 
taylor series form ci ci ci positive 
poly approximate kno term taylor polynomial denoted error negligible conclude observing form constructible manipulations coin success poly product power permanent efficiently approximated sampling directly probability construct coin joint distribution coins 
raising power done 
detail 
assume 
efficiently verified 
technique uses rapidly mixing markov chain sample set perfect matchings graph distribution statistically indistinguishable uniform 
approximate permanent follows 
pe denote probability edge random matching pe denote probability random matching edges matching 
find sequence 
en edges pe pe pe take place 
pn high level overview particular 
en perfect matching 
write number perfect matchings pe en en 
approximate pe sample nearly uniformly perfect matchings graph count fraction times occurs 
pe sample times get relative error approximation pe pe 
approximate pe consider graph 
perfect matchings bijection perfect matchings occurs 
approximate sampling perfect matchings counting fraction times occurs 
find suitable sequence edges proceed follows 
edges matching edges edge matchings 
find edge matchings sampling markov chain 
similarly edges remaining removal endpoints matching remaining graph edges edge matchings 
find sampling 
continuing way generates sequence edges 
immediate sampling approximation pe depends pe rest graph 
monte carlo sampling approximation statistically indistinguishable depending pe 
aside conclude probability edge perfect matching graph privately approximable relative error provided probability large inverse polynomial privately approximable additive error case 
discussion difficult see exact version promise problem reducible pe exact version reducible permanent hard 
consider different graphs value permanent corresponding values pe pe different 
general product approximations pe en en graph may different distribution product approximations en 
en graph pe en en en en illustration suppose pe pe pe pe 
samples approximate factor number perfect matchings approximated graph graph number successes independent trials experiment success probability show distributions mean distributions distinguishable 
elementary calculations show variance variance follows statistical difference satisfies sd pr pr pr pr pr pr pr var var 
case useful probability getting useless zero output high general factors discussed paragraph 
statistical distance non negligible polynomial 
note leakage information occur sample perfectly set perfect matchings leakage statistical difference markov chain sample truly uniform sample 
may try estimate product avoid leakage sample joint distribution perfect matchings perfect matchings vertices estimate probability joint event occurs matching occurs matching vertices simplifying amounts estimating probability random perfect matching matching 
en 
general probability minuscule pe large probability resulting estimate zero gives estimate size permanent 
remedy obtain efficient private approximation product start manipulating success probabilities various ways 
coins success probabilities form coins success probabilities joint event complementary event rq flipping flipping qr 
done knowing probability 
manipulations construct coin coin proceeding note exponentially far apart trivial algorithm 
security parameter tiny noise adding technique section 
hand large shown solve permanent problem exactly time polynomial return reasonable values nk term taylor expansion error bounded 
see recall assuming coefficient nj 
nj absolute value negative 
sum absolute values leading coefficient nk term taylor series kn log kn nj assume solve permanent exactly time polynomial kn term taylor series sub convex combination 
kn converges geometric series ratio 
coin unknown success probability construct experiment success probability kn samples coin success probability way ll constructed probability 
illustration consider term expansion square root isolating leading convex combinations sums get denote experiment performing successful performing outputting result performing outputting result suppose event probability suppose ft coin flip success probability event constructed directly form success probability occurrence independent 

polynomial degree appropriate generalization experiment uses just experiments constantly experiments experiment general constructing ft may require repetitions achieve desired accuracy 
coefficients leading sum sum part series implemented construction construction joint event ft theorem matrices bit non negative entries 
poly polynomial time private approximation proof consider construction described 
ideally joint distribution suc cess probability equal factor success probability correct factor joint event success probability correct graphs number perfect matchings construct experiment success probability statistically indistinguishable analysis privacy making exponentially samples able distinguish success probability regard correctness possible recover accuracy polynomial number samples recover sufficient accuracy 
note probability geometric mean approximated probability joint event coins constructed 
average coin tosses success probability expectation variance apply lemma distortion error probability getting probability 
follows power proof completed 
extensions complete problems discussed section secure approximation permanent immediately implies secure approximation large array problems reduce permanent approximation preserving manner examples 
saw proof theorem pe probability edge appears random perfect matching graph privately approximable relative error provided probability large inverse polynomial privately approximable additive error case 
follows directly sampling techniques approximating pe 
discussion proof difficult see hard problem reducible permanent 
turn showing generalize techniques permanent approximation general class problems 
general secure approximations monte carlo methods proof permanent built non secure monte carlo markov chain approximation 
want extend techniques intractable functions polynomial time approximation schemes similar monte carlo markov chain approach 
technique rapidly mixing markov chains inherently suited functionally private approximations definition rapidly mixing markov chain supports sampling distribution items statistically indistinguishable uniform 
sample estimate fraction items satisfying property resulting estimate depends fraction set items input generate 
case permanent want estimate fraction objects satisfying property function fractions product 
techniques manipulating probabilities jth roots taylor expansion estimation useful 
details provided 
assume underlying size security parameter computations correct factor probability 
distributions statistically indistinguishable statistical difference condition similar strength applies computational indistinguishability 
polynomial time means time polynomial denoted poly usual success probability boosted performing log repetitions 
definition intuitively says approximation preserving function 
definition deterministic real function polynomially relatively continuous exists poly 
lemma polynomially relatively continuous function easy compute invert 
suppose pr pr poly event parameterized probability distribution polynomial time sample distribution statistically respectively computationally indistinguishable statistically respectively computationally functionally private approximation computable polynomial time 
proof estimate pr factor polynomial time lemma apply 
see functionally private note simulator construct bit approximation pr 
apply lemma bernoulli random variable success probability indistinguishable pr apply 
result follows 
proceeding consider transformation needed permanent lemma fix known numbers small 
suppose independent tosses coin unknown success probability poly 
suppose rp known poly 
construct coin success probability indistinguishable rp 
proof suppose number coin success probability bounded 
enrich coin factor experiment toss original coin ln times denote number heads obtained 
toss coin success probability min rs output result coin 
denote probability success 
show rp 
observe statement true case min rs rs constructed coin viewed random trial tosses original coin 
fact arbitrary trial original coin right probability 
write probability constructed coin succeeds pr pr pr 
general case direction easy min rs pr rs pr pr rp desired 
need show rp bounding probability min rs 
note rs iff exceeds mean pn chernoff inequality rp occurs probability want suffices log observe bp bernoulli random variable success probability bp min rs pr rs pr rs rs pr rs pr rs pr pr rs rp rs rs pr rs pr pr pr return general monte carlo markov chain methods 
general case permanent monte carlo markov chain approach approximations involves making estimates separate markov chain experiments combining estimates arbitrary way 
claim function monte carlo markov chain approximation functionally private approximation exhibit functionally private approximations large class functions 
theorem polynomially relatively continuous function easy compute invert 
suppose pr pr 
pr ej event probability poly probability distribution nearly sampled polynomial time polynomial sized constant depth arithmetic formula gates form poly poly denotes empty input 
number efficiently constructible th bit computable time polynomial 

ri poly rt promise poly rt poly 
ri ri poly 
tri functionally private approximation computed polynomial time 
proof show gate satisfies invariant input takes values poly poly input approximated polynomial time sampling input polynomial time constructible bernoulli experiment success probability indistinguishable ideal value output satisfies conditions 
takes values poly poly 
approximated polynomial time sampling 
associated bernoulli experiment success probability indistinguishable ideal value 
clear gates 
second follows third hypothesis estimation events ei sampling lemma 
third consider allowed types gates turn 
show gate construct experiment success probability indistinguishable output value coins success probabilities equal input values total number coins required polynomial 
gate discussed section lemma 
lemma follows estimate estimating applying 
lemma see approximation functionally private simulator compute pr pr 
pr ej apply lemma bernoulli random variable success probability indistinguishable apply 
result follows 
result provides private approximations large class functions includes private approximability permanent event occurrence edge random matching particular graph single gate formula consisting geometric mean inputs power 
advances computing power computations larger larger data sets possible 
raises concerns privacy 
addressed efficient privacy preserving computation approximation algorithms 
demonstrated approximation functions may leak information leaked exact functions approximate 
motivated defined notions functional privacy secure multiparty computation approximations 
efficient private approximations hamming distance permanent related problems 
techniques may private approximations problems communication complexity applications 
acknowledgments dana randall suggesting applications permanent section jessica fong helpful discussions collaboration early stages 
agrawal aggarwal 
design quantification privacy preserving data mining algorithms 
proc 
twentieth acm sigact sigmod sigart symposium principles database systems 
agrawal srikant 
privacy preserving data mining 
proc 
acm sigmod conference management data pages 
acm press 
alon gibbons matias szegedy 
tracking join self join sizes limited storage 
proc 
eighteenth acm sigact sigmod sigart symposium principles database systems pages 
alon matias szegedy 
space complexity approximating frequency moments 
proc 
th annual acm symposium theory computing pages 
alon spencer 
probabilistic method 
wiley 
bar yossef 
personal communication 
beaver 
foundations secure interactive computing 
advances cryptology crypto lncs pages 
springer verlag 
beaver micali rogaway 
round complexity secure protocols 
proc 
th annual acm symposium theory computing pages 
ben goldwasser wigderson 
completeness theorems non cryptographic faulttolerant distributed computation 
proc 
th annual acm symposium theory computing pages 
acm press 
broder 
hard marry random 
proc 
th annual acm symposium theory computing pages 
erratum th stoc 
cachin micali stadler :10.1.1.26.7042
computationally private information retrieval polylogarithmic communication 
advances cryptology eurocrypt lncs pages 
springer verlag 
canetti 
security composition multiparty cryptographic protocols 
cryptology 
canetti ishai kumar reiter rubinfeld wright 
selective private function evaluation applications private statistics 
proc 
th annual acm symposium principles distributed computing pages 
acm press 
chaum cr damg ard 
multiparty unconditionally secure protocols 
proc 
th annual acm symposium theory computing pages 
chawla dwork mcsherry smith wee 
privacy public databases 
submitted publication 
chor goldreich kushilevitz sudan 
private information retrieval 
proc 
th ieee symposium foundations computer science pages 
cormode paterson vishkin 
communication complexity document exchange 
th annual acm sigact siam symposium discrete algorithms pages 
dimacs special year massive data sets 
dimacs rutgers edu 
nissim 
revealing information preserving privacy 
proc 
second acm sigact sigmod sigart symposium principles database systems pages 
dwork nissim 
privacy preserving datamining vertically partitioned databases 
advances cryptology crypto 
goldreich lempel 
randomized protocol signing contracts 
communications acm 
gehrke srikant 
limiting privacy breaches privacy preserving data mining 
proc 
second acm sigact sigmod sigart symposium principles database systems pages 
feder kushilevitz naor nisan 
amortized communication complexity 
siam journal computing 
feigenbaum ishai malkin nissim strauss wright :10.1.1.125.4160
secure multiparty computation approximations 
proc 
th international colloquium automata languages programming pages 
springer verlag 
feigenbaum kannan strauss viswanathan 
approximate difference algorithm massive data streams 
proc 
th ieee symposium foundations computer science pages 
freedman nissim pinkas 
efficient private matching set intersection 
advances cryptology eurocrypt lncs pages 
springer verlag 
ishai kushilevitz malkin 
protecting data privacy private information retrieval schemes 
computer system sciences 
preliminary version appeared th stoc 
goldreich 
secure multi party computation working draft version 
available 
ucsd edu books oded sc html 
goldreich micali wigderson 
play mental game 
proc 
th annual acm symposium theory computing pages 
acm press 
goldwasser micali 
probabilistic encryption 
computer system sciences 
halevi kushilevitz nissim 
private approximations np hard functions 
proc 
th annual acm symposium theory computing pages 
indyk 
stable distributions pseudorandom generators embeddings data stream computation 
proc 
th ieee symposium foundations computer science pages 
jerrum sinclair 
approximating permanent 
siam journal computing 
jerrum sinclair 
polynomial time approximation algorithm permanent matrix non negative entries 
proc 
th annual acm symposium theory computing pages 
jerrum valiant vazirani 
random generation combinatorial structures uniform distribution 
theoretical computer science 
yung 
secure games polynomial expressions 
proc 
th international colloquium automata languages programming pages 
kushilevitz nisan 
communication complexity 
cambridge university press 
kushilevitz ostrovsky 
replication needed single database information retrieval 
proc 
th ieee symposium foundations computer science pages 
kushilevitz ostrovsky rabani 
efficient search approximate nearest neighbor high dimensional spaces 
proc 
th annual acm symposium theory computing pages 
lindell 
parallel coin tossing constant round secure party computation 
advances cryptology crypto lncs pages 
springer verlag 
lindell pinkas 
privacy preserving data mining 
cryptology 
earlier version appeared proc 
crypto 
mann 
private access distributed information 
master thesis technion israel institute technology haifa 
micali rogaway 
secure computation 
advances cryptology crypto lncs pages 
springer verlag 
minc 

encyclopedia mathematics applications volume 
addison wesley 
naor naor 
small bias probability spaces efficient constructions applications 
siam computing 
earlier version appeared proc 
nd stoc 
naor nissim 
communication preserving protocols secure function evaluation 
proc 
th annual acm symposium theory computing pages 
naor pinkas 
oblivious transfer polynomial evaluation 
proc 
st annual acm symposium theory computing pages 
acm press 
pang el gamal 
communication complexity computing hamming distance 
siam journal computing 
rabin 
exchange secrets oblivious transfer 
technical report tr aiken computation laboratory harvard university 
stern 
new efficient disclosure secrets protocol 
advances cryptology asiacrypt lncs pages 
springer verlag 
yao 
protocols secure computation 
proc 
rd ieee symposium foundations computer science pages 
yao 
power quantum fingerprinting 
proc 
th annual acm symposium theory computing pages 

