donini lenzerini nardi schaerf woods william 
link foundations semantic networks 
representation understanding studies cognitive science ed 
bobrow collins 

academic press 
republished brachman levesque 
woods william 
understanding subsumption framework progress 
principles semantic networks ed 
sowa 

morgan kaufmann los altos 
woods william james schmolze 

kl family 
semantic networks arti cial intelligence ed 
lehmann 

pergamon press 
published special issue computers mathematics applications volume number 
wright jon gregg karen brown stephen palmer jay berman harry moore 

knowledge con supports sales engineering manufacturing network systems 
ai magazine 
yen john robert neches robert macgregor 

clasp integrating term subsumption systems production systems 
ieee transactions knowledge data engineering 
reasoning description logics levesque 
reiter 
asking database knows 
symposium computational logics ed 
lloyd 
springer verlag esprit basic research action series 
rich charles ed 

special issue implemented knowledge representation reasoning systems 
sigart bulletin 


log algorithm subsumption fl proceedings fourth italian conference computer science ed 
marchetti spaccamela 
world scienti publishing october 
schaerf andrea 

complexity instance checking problem concept languages existential quanti cation 
journal intelligent information systems 
schaerf andrea 

query answering concept knowledge representation systems algorithms complexity semantic issues 
doctoral dissertation dipartimento di informatica sistemistica universita di roma la sapienza 
schaerf andrea 

reasoning individuals concept languages 
data knowledge engineering 
schild klaus 

undecidability subsumption technical report kit report 
berlin germany fb informatik technische universitat berlin 
schild klaus 

correspondence theory terminological logics preliminary report 
proc 
th int 
joint conf 
arti cial intelligence ijcai 
sydney 
schild klaus 

terminological cycles propositional calculus 
proc 
th int 
conf 
principles knowledge representation reasoning kr ed doyle sandewall torasso 
bonn 
morgan kaufmann los altos 
schmidt schau manfred 

subsumption kl undecidable 
proc 
st int 
conf 
principles knowledge representation reasoning kr ed 
ron brachman hector levesque ray reiter 
morgan kaufmann los altos 
schmidt schau manfred gert smolka 

attributive concept descriptions complements 
arti cial intelligence journal 


default inheritance reasoning hybrid kl logics 
proc 
th int 
joint conf 
arti cial intelligence ijcai 
chambery france 
morgan kaufmann los altos 
vardi moshe 
complexity relational query languages 
proc 
th acm sigact sym 
theory computing stoc 
robert diane litman 

terminological reasoning constraint networks application plan recognition 
proc 
rd int 
conf 
principles knowledge representation reasoning kr 
morgan kaufmann los altos 
donini lenzerini nardi schaerf mylopoulos bernstein wong 

language facility designing database intensive applications 
acm transactions database systems 
nebel bernhard 

computational complexity reasoning back 
arti cial intelligence journal 
nebel bernhard 

reasoning revision hybrid representation systems 
lecture notes arti cial intelligence 
springer verlag 
nebel bernhard 

terminological reasoning inherently intractable 
arti cial intelligence journal 
nebel bernhard 

terminological cycles semantics computational properties 
principles semantic networks ed 
john sowa 

morgan kaufmann los altos 
nebel bernhard christof kai von luck ed 

international workshop terminological logics 
deutsches forschungszentrum fur kunstliche intelligenz dfki 
padgham lin bernhard nebel 

combining classi cation non monotonic inheritance reasoning step 
proc 
th int 
sym 
methodologies intelligent systems ismis ed 
komorowski ras 
padgham lin zhang 

logic defaults de nition application 
proc 
th int 
joint conf 
arti cial intelligence ijcai 
chambery france 
morgan kaufmann los altos 
patel schneider 
undecidability subsumption 
arti cial intelligence journal 
patel schneider bill swartout 

working version draft description logic speci cation krss ort june 
unpublished manuscript 
patel schneider peter 
small beautiful knowledge representation 
proc 
ieee workshop knowledge systems 
extended version appeared fairchild tech 
rep tech 
rep october 
patel schneider peter ronald brachman hector levesque 

argon knowledge representation meets information retrieval 
proc 
st conf 
arti cial applications fairchild technical report technical report 
quantz joachim carsten kindermann 

implementation back system version 
technical report kit report 
berlin germany fb informatik technische universitat berlin 
quantz joachim royer 

preference semantics defaults terminological logics 
proc 
rd int 
conf 
principles knowledge representation reasoning kr 
morgan kaufmann los altos 
quillian ross 

word concepts theory simulation basic capabilities 
behavioral science 
republished brachman reasoning description logics donini francesco daniele nardi riccardo rosati 

non rstorder features concept languages 
proc 
th conf 
italian association arti cial intelligence ai ia 
lecture notes arti cial intelligence 
springer verlag 
doyle jon ramesh patil 

theses knowledge representation language restrictions taxonomic classi cation utility representation services 
arti cial intelligence journal 
fitting melvin 

order logic automated theorem proving 
springer verlag 
johnson 
catalog complexity classes 
handbook theoretical computer science ed 
van leeuwen 
chap 

elsevier science publishers 
north holland 
thomas raymond bates gabriel robins 

developments 
proc 
th nat 
conf 
arti cial intelligence aaai 
kindermann carsten 

class instances terminological framework experience report 
proc 
german workshop arti cial intelligence 
springer verlag 
lehmann fritz 

semantic networks 
semantic networks arti cial intelligence ed fritz lehmann 

pergamon press 
lenzerini maurizio andrea schaerf 

concept languages query languages 
proc 
th nat 
conf 
arti cial intelligence aaai 
levesque hector 
foundations functional approach representation 
arti cial intelligence journal 
levesque hector ron brachman 

expressiveness tractability representation reasoning 
computational intelligence 
lifschitz vladimir 

nonmonotonic databases epistemic queries 
proc 
th int 
joint conf 
arti cial intelligence ijcai 
sydney 
macgregor robert 

description classi er predicate calculus 
proc 
th nat 
conf 
arti cial intelligence aaai 
appear 
macgregor robert bates 

loom knowledge representation language 
technical report isi rs 
marina del rey cal university southern california information science institute 
macgregor robert deborah mcguinness eric tom russ ed 

working notes aaai fall symposium issues description logics users meet developers 
boston usa 
mcallester david 

unpublished manuscript 
minsky marvin 

representing knowledge 
mind design ed 
haugeland 
mit press 
longer version appeared psychology computer vision 
republished brachman levesque 
donini lenzerini nardi schaerf doyle sandewall torasso 
bonn 
morgan kaufmann los altos 
de giacomo giuseppe maurizio lenzerini 

boosting correspondence description logics propositional dynamic logics 
proc 
th nat 
conf 
arti cial intelligence aaai 
aaai press mit press 
de giacomo giuseppe maurizio lenzerini 

concept language number restrictions fixpoints relationship calculus 
proc 
th european conf 
arti cial intelligence ecai 
diane litman 

plan terminological reasoning 
proc 
nd int 
conf 
principles knowledge representation reasoning kr ed 
james allen richard fikes erik sandewall 
morgan kaufmann los altos 
donini francesco bernhard hollunder maurizio lenzerini alberto marchetti spaccamela daniele nardi werner nutt 

complexity existential quanti cation concept languages 
arti cial intelligence journal 
donini francesco maurizio lenzerini daniele nardi werner nutt 

complexity concept languages 
proc 
nd int 
conf 
principles knowledge representation reasoning kr ed 
james allen richard fikes erik sandewall 
morgan kaufmann los altos 
donini francesco maurizio lenzerini daniele nardi werner nutt 

tractable concept languages 
proc 
th int 
joint conf 
arti cial intelligence ijcai 
sydney 
donini francesco maurizio lenzerini daniele nardi werner nutt 

complexity concept languages 
technical report rr 
deutsches forschungszentrum fur kunstliche intelligenz dfki 
donini francesco maurizio lenzerini daniele nardi werner nutt andrea schaerf 

adding epistemic operators concept languages 
proc 
rd int 
conf 
principles knowledge representation reasoning kr 
morgan kaufmann los altos 
donini francesco maurizio lenzerini daniele nardi werner nutt andrea schaerf 

queries rules de nitions epistemic sentences concept languages 
proc 
ecai workshop knowledge representation reasoning 
lecture notes arti cial intelligence 
springer verlag 
donini francesco maurizio lenzerini daniele nardi werner nutt andrea schaerf 

adding epistemic operators concept languages 
technical report 
dipartimento di informatica sistemistica universita di roma la sapienza 
preparation 
donini francesco maurizio lenzerini daniele nardi andrea schaerf 

deduction concept languages subsumption instance checking 
journal logic computation 
reasoning description logics italy 
technical report universita di roma la sapienza dipartimento di informatica sistemistica rap 
borgida alexander peter patel schneider 

semantics complete algorithm subsumption classic description logic 
journal arti cial intelligence research 
brachman ronald 
epistemological status semantic networks 
associative networks ed 
nicholas findler 

academic press 
brachman ronald 
reducing classic practice knowledge representation meets reality 
inproc 
rd int 
conf 
principles knowledge representation reasoning kr 
morgan kaufmann los altos 
brachman ronald hector levesque 

tractability frame description languages 
proc 
th nat 
conf 
arti cial intelligence aaai 
brachman ronald hector levesque 

readings knowledge representation 
morgan kaufmann los altos 
brachman ronald victoria gilbert hector levesque 

essential hybrid reasoning system knowledge symbol level accounts krypton 
proc 
th int 
joint conf 
arti cial intelligence ijcai 
los angeles 
brachman ronald james schmolze 

overview kl knowledge representation system 
cognitive science 
buchheit martin francesco donini werner nutt andrea schaerf 

terminological systems revisited terminology schema views 
proc 
th nat 
conf 
arti cial intelligence aaai 
seattle usa 
buchheit martin francesco donini werner nutt andrea schaerf 

re ned architecture terminological systems terminology schema views 
technical report rr 
deutsches forschungszentrum fur kunstliche intelligenz dfki 
buchheit martin francesco donini andrea schaerf 

decidable reasoning terminological knowledge representation systems 
journal arti cial intelligence research 
buchheit martin manfred jeusfeld werner nutt martin staudt 

subsumption queries object oriented databases 
information systems 
special issue extending database technology edbt 
calvanese diego maurizio lenzerini daniele nardi 

uni ed framework class representation formalisms 
proc 
th int 
conf 
principles knowledge representation reasoning kr ed doyle sandewall torasso 
bonn 
morgan kaufmann los altos 
cohen william haym hirsh 

learning classic description logics experimental results 
proc 
th int 
conf 
principles knowledge representation kr ed 
donini lenzerini nardi schaerf baader franz hans jurgen jochen bernhard hollunder jurgen muller bernard nebel werner nutt hans pro 

terminological knowledge representation proposal terminological logic 
technical report tm 
kaiserslautern germany deutsches forschungszentrum fur kunstliche intelligenz dfki 
baader franz bernhard hollunder 

knowledge representation system complete inference algorithm 
proc 
workshop processing declarative knowledge 
lecture notes arti cial intelligence 
springer verlag 
baader franz bernhard hollunder 

embedding defaults terminological knowledge representation formalisms 
proc 
rd int 
conf 
principles knowledge representation reasoning kr 
morgan kaufmann los altos 
baader franz bernhard hollunder 

prefer speci defaults terminological default logic 
proc 
th int 
joint conf 
arti cial intelligence ijcai 
chambery france 
morgan kaufmann los altos 
baader franz bernhard hollunder bernhard nebel hans jurgen pro enrico franconi 

empirical optimization techniques terminological representation systems 
proc 
rd int 
conf 
principles knowledge representation reasoning kr 
morgan kaufmann los altos 
baader franz maurizio lenzerini werner nutt peter patel schneider ed 

working notes description logics workshop 
bonn germany 
deutsches forschungszentrum fur kunstliche intelligenz dfki 
beck navathe 

classi cation query processing technique candide semantic data model 
proc 
th ieee int 
conf 
data engineering icde 
bell john moshe machover 

course mathematical logic 
north holland publ 
amsterdam 
bergamaschi sonia bernhard nebel 

acquisition validation complex object database schemata supporting multiple inheritance 
applied intelligence 
bergamaschi sonia claudio 

taxonomic reasoning conceptual design 
acm transactions database systems 
borgida alexander 

type systems knowledge representation natural semantics speci cations description logics 
journal intelligent cooperative information systems 
borgida alexander ronald brachman deborah mcguinness lori resnick 

classic structural data model objects 
proc 
acm sigmod int 
conf 
management data 
borgida alexander maurizio lenzerini daniele nardi bernhard nebel ed 

working notes description logics workshop 
rome reasoning description logics tively construction knowledge applications domains see example wright con guration software engineering 
seen attempts elds machine learning see example cohen hirsh planning see example litman litman franconi basic formalism extended deal time action 
related elds 
close relationships description logics formalisms developed areas computer science 
particular strict relationship logics programs originally studied program veri cation analysis see schild schild de giacomo lenzerini 
said sections correspondence provided new useful tools studying description logics equipped expressive concept language insights de nitional mechanisms tbox 
strong links eld databases particular semantic object oriented data models see example bergamaschi nebel bergamaschi borgida calvanese 
research direction signi cant exchange techniques results may strong impact development tools database speci cation design 
supported esprit basic research action italian national research council part progetto sistemi ldr 
abrial 
data semantics 
data base management ed 
ko 

north holland publ 
amsterdam 
alessandro enrico franconi 

computational account description logic time action 
proc 
th int 
conf 
principles knowledge representation reasoning kr ed 
doyle sandewall torasso 
bonn 
morgan kaufmann los altos 
attardi giuseppe maria simi 

consistency completeness omega logic knowledge representation 
proc 
th int 
joint conf 
arti cial intelligence ijcai 
vancouver british columbia 
baader franz 

terminological cycles kl knowledge representation languages 
technical report rr 
kaiserslautern germany deutsches forschungszentrum fur kunstliche intelligenz dfki 
abridged version appeared proc 
th nat 
conf 
arti cial intelligence aaai pp 

donini lenzerini nardi schaerf parts axioms concepts tbox representing intensional knowledge assertions individuals abox representing extensional knowledge 
arranged presentation considering di erent tbox abox settings looking corresponding reasoning problems 
research description logics contributions reader nd series workshops speci cally dedicated subject nebel macgregor baader borgida 
brie mention issues outside scope survey 
implementation issues 
implementation dl systems involves aspects computational analysis reasoning problems 
engineering knowledge representation systems illustrated example brachman 
speci cally regard implementation reasoning procedures tableaux reasoning techniques wehave considered survey equipped specialized strategies rule selection application 
approach characterization reasoning methods look existing implementations try characterize computations done system possibly non standard semantics borgida patel schneider 
non rst order features 
analysis developed limited deal rst order formalization knowledge representation systems classes means addressed nonmonotonic behavioral features 
large body research nonmonotonic reasoning taxonomies starting defaults semantic networks frames 
research speci cally addresses issue framework description logics see example baader hollunder quantz royer padgham nebel baader hollunder padgham zhang donini 
knowledge representation systems typically provide forms behavioral features 
methods daemons closely follow object oriented programming paradigm take procedural rules borrowed production rule systems 
production rules forward reasoning nicely formalized description logics epistemic operator de ned section characterize known system donini donini 
applications 
discussed elds application representation reasoning techniques discussed far profitably applied 
description logics predecessors semantic networks frames initially developed applications natural language understanding 
description logics ec reasoning description logics greatest xpoint semantics 
regard descriptive semantics subsumption conp hard pspace known complete pspace 
free tboxes free tboxes sets concept inclusions concept equations see section 
reasoning free tboxes requires di erent techniques studied primitive simple tboxes 
con rmed complexity results language fl reasoning simple tboxes adopting descriptive semantics pspace reasoning free tboxes exptime hard mcallester 
distinction disappears languages containing union negation simulate free tbox primitive concept speci cation interpreted descriptive semantics buchheit 
sake brevity delve details reasoning techniques 
simply note main approaches 
rst approach extension tableaux calculus see buchheit second correspondence description logics logics programs 
correspondence rst discussed schild proved extremely useful devising subsumption algorithms free tboxes expressed powerful languages 
subject de giacomo lenzerini schild 
reasoning complete dl system ultimate goal research reasoning description logics reason complete dl system ht ai tbox abox expressed concept language general problem related reasoning description logics research subject developed 
similarly tboxes main approaches development suitable techniques reasoning complete dl systems 
approaches extending tableaux calculus section deal intensional extensional knowledge exploiting correspondence description logics logics programs 
interested reader referred buchheit de giacomo lenzerini account approaches 
surveyed important issues related reasoning problems arising construction knowledge representation systems description logics 
characterized dl systems composed donini lenzerini nardi schaerf ing equation singles unique subset de nes concept de nition xpoint semantics leads identify 
holds human de nition 
evident help examples 
hand xpoint semantics particularly suitable providing inductive de nitions concepts 
consider case single source directed acyclic graph dag 
empty dag base step 

node connections connections dag dag inductive step 


easily write de nition statement re ecting rst conditions dag node arc arc dag enforce third condition smallest solution corresponding equation 
greatest fixpoint semantics 
speci es interpreted greatest solution exists corresponding equation 
operator associated de nition statement monotonic interpretation satisfying de nition statement corresponding equation singles unique subset de nition greatest xpoint semantics leads interpret class individuals having child generally greatest suitable de ning classes individuals structure circularly repeating 
example class fob forever blond individuals blond generation generation descendant de ned fob blond child fob de nition statement want denote class individuals satisfying equation corresponding de nition statement want greatest solution 
hand interpret de nition statements human horse mammal parent parent human mammal parent parent horse greatest xpoint semantics obtain unintuitive result interpretation satisfying de nition statements human horse computational properties semantics studied baader nebel 
turns language fln subsumption cyclic tboxes pspace complete respect cyclic simple tboxes consider cyclic simple tbox reasoning description logics initial interpretation fa dg ai fa dg easy see ways extend model 
extended fa bg 
extended fa dg 
example shows initial interpretation cyclic tbox unique way extend model determine denotation de ned concepts 
order discuss problems related cyclic de nitions consider tbox constituted single cyclic de nition wherec expression containing semantically sort equation specifying interpretation subsets canbe tied concept solution notice associate de nition statement operator subsets subsets solutions equation correspond xpoints operator 
consider de nition child associate operator fa child sg follows denote operator 
baader nebel de giacomo lenzerini ways interpreting cyclic de nitions discussed semantics descriptive semantics 
stating solution corresponding equation 
example de nition states individuals class class individuals class class speci ed 
general de nition statement descriptive semantics equivalent ag 
follows descriptive semantics appropriate de ning concepts 
hand allows express necessary su cient conditions concepts human mammal parent parent human fixpoint semantics 
speci es interpreted smallest solution exists corresponding equation 
operator associated de nition statement monotonic satisfying de nition statement correspond donini lenzerini nardi schaerf directly uses atomic concept expression ft contains uses denote transitive closure relation directly uses 
simple tbox said cyclic atomic concept uses acyclic 
intuitively cycles correspond recursive de nition concepts 
return question analyze cases acyclic general simple tboxes simply tboxes respectively 
acyclic simple tboxes acyclic simple tboxes acyclic tboxes short ubiquitous 
existing systems allow speci cation cyclic tboxes 
formal properties acyclic tboxes investigated 
nebel shows acyclic tboxes answer question positive acyclic tbox initial interpretation extended model means ambiguity de ned concept basis interpretation primitive concepts 
easy see subsumption simple tboxes reduced subsumption empty terminology 
want subsumed acyclic tbox iteratively substitute occurrence de ned concept corresponding expression ft obtaining expressions acyclic process terminates nite number iterations holds ht result shows reasoning acyclic tboxes reduced reasoning concept expressions 
nebel shows method may lead cost subsumption algorithm size tbox 
surprisingly shows intractability stem method inherent complexity problem determining subsumption acyclic tbox np complete language express expressive fl technique establish result interesting reducing equivalence nondeterministic nite state automata subsumption tests tbox encoding automata 
reason result surprising believed subsumption tbox harder subsumption concept descriptions 
nebel argues exponential worst case occur explain subsumption algorithms acyclic simple tboxes behaved practice 
reasoning description logics database setting models tbox correspond database states assumed nite 
simple tboxes recall concept de nition statement form called de nition intended provide de nitional account concept name simple tbox set concept de nitions obeys syntactic restriction concept name de nition informally de ning concept means set necessary su cient conditions object belong extension de nitions ultimately rely primitive notions left unde ned 
simple tboxes distinguish socalled primitive de ned concepts concepts meaning assumed understood left unde ned tbox concepts characterization tbox terms set primitive concepts roles 
form tbox determines sets primitive de ned concepts de ned resp 
primitive concepts de nition tbox 
intuitively forany simple tbox wewould able assign unique interpretation de ned concepts xed interpretation primitive ones 
order capture introduce notion initial interpretation 
call initial interpretation interpretation function maps atomic concept subset role subset initial interpretation obtain interpretation extending interpretation function concepts roles including complex de ned concepts complex roles 
denotation complex concepts roles obey conditions reported tables respectively 
assign denotation de nition question initial interpretation unique way determine interpretation de ned concepts 
see answer question depends form tbox particular tbox contains cycles 
order precisely de ne notion cycle observe simple tbox associate total function ft atomic concepts concept expressions de ned follows ft ifa ft ifa primitive int nebel say donini lenzerini nardi schaerf statement specify necessary condition instances concept name instances concept 
semantics primitive concept speci cation section 
intuitively speci cation restrict set admissible interpretations obey inclusion condition expressed speci cation 
primitive tboxes provide characterization frames semantic networks database models 
structure intensional base expressed formalisms correctly represented terms set primitive concept speci cations 
papers buchheit calvanese address problems developing suitable reasoning techniques studying computational complexity reasoning primitive tboxes 
buchheit architecture dl systems constituted components 
components called schema just set primitive concept speci cations language obtained fl adding constructors atomic role 
shows subsumption atomic concepts schema decided polynomial time 
schema language enriched inverse roles negation atomic concepts subsumption np hard 
observed dl system architecture carefully designed primitive concept speci cations hand proved useful domain modeling hand increase complexity reasoning 
claim supported case studies primitive described added working systems conceptbase kris 
calvanese primitive tboxes powerful languages investigated 
main language considered called aluni obtained adding constructor inverse roles 
inverse roles shown essential order express modeling constructors semantic conceptual database models 
shown primitive tboxes expressed language exhibit interesting property concept may satis able tbox nite models models nite domains 
words unrestricted concept satis ability di erent concept satis ability problem checking concept nonempty extension nite model tbox 
observe nite satis ability important role usually denoted semantics reasoning description logics computed possibly recursive way due nested occurrences 
operator front role name kp equivalent role form bn role expressible languages despite di erences technique similar reasoning donini prove instance checking alc alck query language pspace complete problem 
result proves answering alck queries worstcase computationally harder answering alc queries 
allows conclude epistemic operators alc substantially increase complexity query answering 
extremely interesting especially light expressive power gained 
show case epistemic operator decreases complexity 
examples may allow express queries ruling case analysis 
particular done replacing concepts form concepts form kr kc 
donini shown replacement lessen complexity reasoning 
precisely considering abox inal possible answer alek queries polynomial time data complexity provided quali ed existential quanti cations form kr ke 
conversely recall answering general ale queries conp hard shown section 
reasoning tbox section deal problem reasoning set 
said section tbox statements specify intensional component base properties classes relationships classes 
basic reasoning services provided tboxes concept satis ability subsumption 
address problems hypothesis knowledge base form ht absence abox assertions 
particular consider types tbox statements correspondingly kinds tboxes simple tboxes free tboxes 
primitive tboxes recalling de nitions section primitive tbox set statements called primitive concept speci cations form donini lenzerini nardi schaerf teaches intermediary courses courses intermediary 
query asks course known taught john known intermediary course 
courses taught john cs cs intermediary courses answer query 
note form closed world reasoning universal quanti cation takes account known individuals 
example consider queries involving nested quanti ers query discussed section report convenience query modi ed version epistemic operator 
query teaches enrolled grad enrolled grad john 
answer 
query enrolled grad enrolled grad john 
answer 
said answer query due case analysis 
hand query asks john known teach course known instance concept enrolled grad enrolled grad 
courses known taught john cs cs conditions required query 
query shows cases rst order semantics agree intuitive reading query 
fact people tend read query requiring reasoning pattern associated semantics query 
reason opinion important operator allows express types queries 
queries possible uses epistemic operator discussed donini donini 
complexity results section address computational epistemic queries 
aim realize interesting relation reasoning epistemic concepts reasoning concepts involving collections individuals 
intuition underlying relation concept form kc considered equivalent concept fa ang exactly individuals ai holds reasoning complex reasoning reasons 
set fa ang reasoning description logics figures replacing example 

epistemic constructor equations satis ed kc kp issues typical rst order modal systems arise 
issues concern interpretation structures dealt assumptions interpretation de ned xed domain called common domain assumption forany interpretation mapping individuals domain elements called xed rigid term assumption 
notice domain xed independently interpretation meaningful refer conjunction extensions concept di erent interpretations 
follows kc interpreted set objects instances interpretation belonging sense kc represents objects known instances abox concept language logically implies assertion lk written true pair andi element ofm 
abox concept individual query unknown 
goal show epistemic operators queries allows sophisticated interaction dl system 
purpose consider abox example provide various kinds queries posed language alek 
particular order understand role epistemic operator consider ale queries modi ed versions including comparison respective semantics highlights role query language 
example consider queries involve universal quanti ers query teaches john 
answer unknown 
query john 
answer 
query asks course taught john intermediary 
answer unknown models john donini lenzerini nardi schaerf queries epistemic operator strengths concept languages settheoretic rst order semantics 
rst order semantics aspects weakness leaves aspects practical systems generally described terms procedural nonmonotonic mechanisms 
appropriate enrich semantics explore novel language features account aspects described standard rst order framework 
need enrichment sort discussed literature see example doyle patil woods easily recognized looking dl systems classic clasp yen 
concerned full treatment issues non rst order extension concept languages provides special forms reasoning abox 
donini donini donini proposed enrich concept languages epistemic operator de ned style levesque reiter lifschitz 
particular focus attention epistemic operator de ne powerful query language 
rst provide examples show epistemic query language allows address aspects external world represented knowledge base aspects knowledge base knows external world 
discuss complexity 
semantics section epistemic concept languages concept languages extended epistemic operator 
details epistemic concept language includes concept constructor kc role constructor kp concept role respectively 
notation call lk concept language obtained adding constructors concept language intuitively kc denotes set individuals known instances concept individuals extension model knowledge base similarly kp 
semantics epistemic operator adaptation framework concept languages proposed lifschitz 
epistemic interpretation pair interpretation set interpretations 
concept role names interpreted independently 
interpretation non epistemic constructors obtained reasoning description logics complexity instance checking consistency extensive analysis complexity abox reasoning languages carried donini 

analysis singles interesting properties 
firstly consistency shown complexity class concept satis ability considered languages 
secondly di erent results obtained instance checking depending language express abox 
particular 
languages polynomial subsumption aln preserve tractability general additional respect subsumption required 

new source complexity singled ale previous section arise languages subsumption np complete 
fact simulate quali ed existential quanti cation abox assertions section express quali ed existential quanti cation query concept explicitly implicitly 
follows instance checking np complete exactly subsumption 

regard languages instance checking complexity class subsumption 
happens navigation knowledge base allowed alu language rich alc subsumption computationally demanding 
analysis complexity instance checking languages including constructor started lenzerini schaerf carried extensively schaerf 
analysis shows languages reasoning services complexity 
due fact individuals appear concept expressions source complexity related treatment impact reasoning concept expressions 
corresponding complexity results show reasoning construct generally hard 
added languages ale complexity reasoning increases 
cases reasoning language including complexity class reasoning language alc algorithms account generally complex terms time space algorithms deal results standard rst order semantics 
semantics employed actual systems variant pure rst order semantics see borgida patel schneider 
general agreement non standard semantics appropriate understandable users 
donini lenzerini nardi schaerf respect size instance checking ale conp hard size knowledge base 
schaerf shows instance checking ale respect data complexity 
problem complete hard 
combined complexity considered donini 
show instance checking ale pspace complete 
results single interesting properties 
reasoning ale su ers additional source complexity instance checking polynomially reducible subsumption subsumption ale solvable means single level nondeterministic choice 

problem instance checking ale data complexity considered pspace complete combined complexity considered 
shows order signi cant complexity measure reasoning problems dl systems pay attention crucial data application 

respect combined complexity ale class pspace complex languages 
expressivity required constructors added increase worst case computational complexity 

source complexity identi ed section related possibility nesting arbitrary number existential universal quanti ers pointed section subsumption ale 
fact leads intractability nested existential quanti ers universal ones 
important observation long chains nested quanti ers appear frequently practice 
regard point may object cases reasoning process underlying source complexity intuition user pointed query 
process ruled reasoner semantics 
contrary cases kind reasoning agree intuition taken account 
section address issue appropriate semantics queries involving existential quanti cations 
particular show possible achieve sophisticated control semantics means epistemic operator query language 
reasoning description logics set models grad susan holds 
models course cs taken graduate susan undergraduate peter 
similarly consider set remaining models ones grad susan holds 
easy see model set course cs time taken graduate mary undergraduate susan 
model cs cs extension enrolled grad enrolled grad 
follows model assertion true proving correct answer 
kind reasoning required example instance checking ale conp hard respect data complexity 
proof reduction suitable variation propositional satis ability problem sat instance checking ale 
dene cnf formula alphabet cnf formula clause exactly literals positive negative ones propositional letters elements ftrue falseg 
furthermore call sat problem checking cnf formula satis able 
problem sat np complete schaerf 
cnf formula cn ci associate abox concept follows 
individual letter individual ci clause ci individual formula plus individuals true false corresponding propositional constants 
roles cl concept name true false cl cl cl cn cn cn cn cn cl intuitively membership extension corresponds truth values true false respectively checking corresponds checking truth assignment forf exists clause positive literals interpreted false negative literals interpreted true clause satis ed 
schaerf proved cnf formula unsatis able 
cnf formula xed independently computed polynomial time donini lenzerini nardi schaerf assertions roles abox 
example query nd individuals teach course graduate student enrolled expressed ale concept teaches enrolled grad 
rst consider data complexity instance checking ale 
regard easy show complexity high complement satis ability np hard 
conp hard 
subsumption ale np complete consequence result assuming np conp instance checking ale strictly harder subsumption 
unexpected result shows instance checking ale su ers new source show reasoning concept expressions see section 
source complexity related quali ed existential quanti cation concept representing query behavior individuals heavily dependent individuals abox 
illustrate point means example 
example abox professor john teaches john cs teaches john cs cs cs enrolled cs mary enrolled cs susan enrolled cs susan enrolled cs peter grad peter grad mary abox shown graphical form 
easily veri ed satis able di erent models 
fact complete knowledge represented world 
example doesn know susan graduate 
consider query abox query teaches enrolled grad enrolled grad john 
query asks john teaches course graduate undergraduate enrolled 
super cial reading query answer 
answer supported fact courses taught john known requested conditions logically implies enrolled grad enrolled grad cs enrolled grad enrolled grad cs 
correct answer order get reason case analysis remarked knowledge base provide information susan graduate undergraduate model 
fact ensures model grad susan grad susan holds 
consider grad jjj reasoning description logics john professor teaches cs cs jjj mary susan peter pictorial representation abox enrolled grad data complexity instance checking complexity respect combined complexity instance checking respect jdj combined complexity usually considered literature concept languages 
measure actual cost instance checking cases abox query comparable size 
hand data complexity important size query negligible respect size abox 
measure widely accepted database community framework concept languages assumption size query negligible reasonable 
worth noticing combined complexity higher equal data complexity 
fact complexity respect jdj obviously includes particular case jdj small respect instance checking ale start analysis abox reasoning studying instance checking particular language ale interesting properties 
ale rich express signi cant classes assertions meaningful queries 
particular virtue quali ed existential quanti cation possible express queries requiring form navigation donini lenzerini nardi schaerf source source absent source aln alu absent ptime conp complete source ale languages alen np complete pspace complete table complexity subsumption languages instance checking 
consider instance checking problem case amounts checking abox implies individual instance concept 
particular address question instance checking solved means subsumption algorithms 
basic technique underlying approaches check consists retrieving assertions knowledge base individual collecting single concept called speci concept msc checking subsumes msc 
technique called abstraction subsumption broadly exploited actual systems see kindermann quantz kindermann nebel 
abstraction subsumption idea applicable number languages 
cases order check necessary consider assertions objects knowledge base di erent method longer applicable 
discuss cases sections 
subsequently section enrich concept languages epistemic operator distinguish knowledge world knowledge state knowledge base 
particular demonstrate epistemic operator introduces sophisticated query mechanism decrease complexity checking 
complexity measures complexity problem generally measured respect size input 
instance section complexity subsumption measured sum size candidate subsumer candidate 
instance checking inputs di erent abox query 
reason di erent kinds complexity measures considered similarly suggested vardi database query answering 
de nition abox concept individual reasoning description logics quanti er qbf way di qi qi concept ci obtained clause gi concept boolean variable occurs positively gi occurs negatively nestings universal role quanti cation encode variable xl 
detail maximum index boolean variables appearing gi 
de nes xl appears positively gi ci xl appears negatively gi ci xl appear gi concept sequence de ned xk appears positively gi xk appears negatively gi 
shown trace constraint system corresponds truth assignment boolean variables traces constraint system form set truth assignments consistent pre conclude satis pspace hard 
combining result polynomial space calculus obtains satis ability subsumption pspacecomplete exponential time behavior calculus improved pspace ptime 
simulation quali ed existential quanti cation reduction prove satis ability subsumption alur pspace hard pspace complete 
similar reduction donini 
proved satis ability pspace hard 
observe languages contain sources complexity 
intuition carries sources complexity absent 
way complexity analysis reasoning completed donini 

language completely classi ed alen sources complexity proved np conp hard combination pspace hardness proof 
results summarized table 
complexity classes mentioned refer subsumption 
complexity satis ability conp interchanged 
reasoning abox section analyze detail problem reasoning abox 
basic reasoning task retrieving information abox donini lenzerini nardi schaerf causes exponential number possible refutations searched refutation clash trace 
source complexity isnot evident propositional calculus similar problem appears predicate calculus interplay existential universal quanti ers may lead nite models 
proof conp hardness satis ability subsumption source complexity described donini 

interesting observe analogously examples source complexity appear explicit presence quali ed existential universal quanti cation 
fact pattern simulated role intersection simulation prove conp hardness satis ability donini 

language containing sources complexity expect code problem involving exploration polynomial depth graphs 
computational analog graphs class problems solved polynomial time alternating turing machine equivalent see johnson pg 
wellknown pspace complete problem quanti ed boolean formulae qbf form xn qi quanti er andf xn boolean formula boolean variables xn decide sentence true 
problem remains pspace complete cnf conjunctive normal form literals clause 
call pre string quanti ers matrix qbf formula problem encoded graph nodes encode quanti ers nodes quanti ers 
analogy illustrate reduction rst published schmidt schau smolka slightly di erent form 
loss generality assume matrix qbf cnf clause appear literal complement 
translate qbf gm alc concept concept formed atomic concept atomic role concept encodes pre form dn dn di corresponds reasoning description logics time needed calculus nondeterministic version deterministic exponential time prove calculus really optimal need reduction pspace complete problem 
consider subsection 
sources complexity note deterministic version calculus seen exploring tree branching corresponds independent check successors variable branching corresponds choices application nondeterministic rule 
realizing see exponential time behavior calculus due independent origins branching responsible exponential size single constraint system responsible exponential number di erent constraint systems 
call di erent combinatorial explosions sources complexity 
branching due presence disjunctive constructors 
obvious disjunctive constructor alu sublanguage study source complexity 
wehave seen disjunction introduced combining role restrictions universal quanti cation example combining number restrictions role intersection example 
source complexity propositional satis ability np hard fact satis ability trivially proved np hard rewriting propositional letters atomic concepts proofs conp hardness subsumption exploiting source complexity levesque brachman nebel reducing np hard problem non subsumption 
branching subtle 
due interplay quali ed existential universal quanti ers ale minimal sublanguage features 
see ects source complexity expanding constraint system fx cg concept taken schmidt schau smolka pn cn pn cn pn clash may independently trace branch ofthe tree variables successor relation 
source complexity donini lenzerini nardi schaerf basic property traces alc constraint system contains contradiction contains trace contains contradiction 
call property independency traces 
traces independent graph associated constraint system tree root 
language traces independent constraint systems checked satis looking traces time 
trace polynomial size respect concept checked pspace algorithm satis ability inl 
constraint systems built propagation rules exactly trees role intersection forces arcs variable nodes see generating rules 
consider successor relation variables forms tree variable direct successor variable 
depth tree bounded thenumber nested quanti ers concept counting restrictions existential quanti ers 
generating depth rst tree shaped constraint system needs just polynomial space depth bounded length concept 
depth rst construction achieved strategy application rules 
apply generating rule rule applicable 
generating rule applicable concept constraint choose concept constraint generated variable 
order polynomial space discard constraints rule applicable successor predecessor modify conditions application rules delve details modi cation 
note till devised calculus working polynomial space deterministic version require explore turn possible applications nondeterministic rules looking choices lead clash 
exploration done depth rst backtracking 
number backtracking points need memorized number constraints form nr number proved polynomially bounded length initial concept 
satis ability concepts decided polynomial space 
noting subsumption rephrased satis ability conclude main theorem subsection 
theorem satis ability subsumption decided polynomial space 
reasoning description logics presence clashes inside 
important properties proved calculus soundness completeness termination 
sketch turn 
soundness 
intuitively calculus add unnecessary contradictions 
deterministic rules preserve satis ability constraint system nondeterministic rules application preserves satis ability 
proof see donini resembles soundness proofs tableaux methods fitting lemma 
non standard constructors number restrictions 
number restrictions generating rules operate introducing new constants di erent 
preserve satis ability example having applied times rule times rule resulting constraint system contains constraints xp omit unsatis able di erent constants 
variables assignments resulting constraint system satis ed ani assignment maps element 
termination 
constraint system complete propagation rule applies 
complete system derived system called completion completions reached nite chain applications rules 
intuitively proved argument rules applied twice constraint rules turn applied variable times number direct successors bounded length concept nally rule application constraint adds constraints strict subexpression completeness 
completion fx cg contains clash possible construct interpretation basis nonempty 
proof straightforward induction length concepts involved constraint 
analyze complexity calculus wecan re ne get optimal upper bound 
traces completions notion constraint system introduced schmidt schau smolka analyze language alc 
key observation schau alc constraint system partitioned traces 
recalling constraint systems regarded graphs traces correspond paths graph starts variable initial constraint system fx cg 
donini lenzerini nardi schaerf 
cg 

pk 
new variable 
successor 
yi ng yj jg 
nr 
pk 
yn new variables 
exist pairwise separated 

nr 
nr successors 
successors separated call rules nondeterministic rules applied di erent ways constraint system 
rules called deterministic rules 
call rules generating rules introduce new variables constraint system 
rules called ones 
verify rules applied system presence constraint condition 
confusion arises tothe constraint variable saying applied constraint system 
building constraint system look evident contradictions see constraint system satis able 
call contradictions clashes 
clash constraint system having forms fx fx ag concept name 
fx nr yi yj jg pk 
clash evidently unsatis able constraint system constraint system containing clash obviously unsatis able 
case clash deals situation avariable restriction set successors identi ed pairwise separated 
purpose calculus generate constraint system look reasoning description logics satis es concept constraint role constraint xp inequality constraint 
constraint system satis able pair satis es constraint ins 
obviously concept satis able constraint system fx cg satis able 
order check constraint system satis ability technique adds constraints evident contradiction generated interpretation satisfying obtained resulting system 
constraints added basis suitable set called propagation rules 
providing rules need additional de nitions evident considering variables constraint system nodes graph constraints xp labeled arcs graph 
constraint system pk role 
successor xp direct successor role successor direct predecessor inverse relation direct successor 
clear context simply say successor direct successor direct predecessor 
transitive closure relation direct successor inverse 
constraint system obtained replacing occurrence variable say separated ins constraint propagation rules calculus 
fx 


fx dg 



fy cg 

successor 
donini lenzerini nardi schaerf cg schmidt schau smolka call generic interpretation built constraint system set constraints incrementally specify properties generic interpretation built satisfy 
interesting property rst order interpretations concept languages 
concepts roles interpreted unary binary predicates interpretation viewed labeled directed graph 
generic element arc relationship variables hold interpretation 
labels arcs primitive roles labels nodes sets primitive concepts negations primitive concepts 
property su cient result graph problems transferred concept languages graph problem graph input nd graph satis es concept 
property useful intuitively explain structural properties constraint systems concept language exempli ed subsection 
case study calculus example devise tableaux deduction method reasoning concept expressions provide calculus expressive language 
introduce alphabet variable symbols elements denoted letters constraint syntactic entity forms concept constraint xp role constraint concept role name 
concepts assumed simple complements contain form concept name 
simple concepts analogous rstorder formulae negation normal form 
arbitrary concepts rewritten equivalent simple concepts linear time donini 
constraint system nite nonempty set constraints 
extend interpretation concepts constraint systems follows 
interpretation de ne assignment function maps variable element reasoning description logics logic re ne operations get reasoning technique optimal worst case behavior 
constraint systems semantics reasoning reasoning technique notational variant ofthe rst order tableaux calculus 
bulk adaptation calculus complexity analyses 
fact obtain optimal algorithms calculus blindly applied general purpose rst order theorem prover 
structures tableaux obtained reasoning concept language carefully analyzed redundant veri cations tableaux eliminated order give strict upper bound complexity method 
give outline devise reasoning technique tableaux calculus general tableaux rst order logic see bell machover fitting 
key idea check formula logical consequence theory try build suitable propagation rules generic model false 
succeed answer logical consequence method complete fail answer looking generic model ensures possible model false logical consequence method sound 
propagation rules come straightforwardly semantics constructors 
give example semantics constructor devise propagation rule 
consider constructor interpretation domain contains element wehave thata semantics element necessarily distinct andb true interpretation interpretations elements say generic interpretation generic element interpretation concept denote generic element relation denote xry andy belongs interpretation denoted 
suppose wewant construct generic interpretation set corresponding concept contains element 
state initial requirement constraint semantics know thats generic element constraints xry hold add new constraints knowing satisfy satisfy rst constraint 
considerations lead propagation rule donini lenzerini nardi schaerf example consider language fl obtained fl adding role restriction role forming constructor 
verify subsumption holds concept subsumes conjuncts considered separately 
conjunction equivalent concept equivalent left hand side concept fact equivalent structural comparison fail recognize subsumption relation 
subsumption fl proved conp hard brachman levesque result sharpened donini 
subsumption fl proved pspace complete 
example consider language back system called convention obtained fl adding role intersection number restrictions negation atomic concepts verify subsumption holds child son child daughter son male child daughter male concept child subsumes left conjuncts considered separately 
case structural comparison reveal subsumption relation 
intuitive reason value restrictions son male daughter male child son child daughter role child force case analysis 
subsumption back concepts proved conp hard nebel result sharpened donini 
subsumption proved pspace complete 
examples show structural subsumption incomplete rst order semantics particular combinations constructors allowed language 
course structural algorithms enhanced account particular combinations constructors see algorithms proposed patel schneider nebel 
di cult part structural algorithms prove completeness prove comparisons considered capture possible interactions 
describe di erent approach developing subsumption algorithms start known tableaux calculus rst order role concept role restriction usually denoted semantics reasoning description logics structural comparison syntax reasoning rst studies computational properties terminological languages due brachman levesque patel schneider 
nebel 
algorithms give computing subsumption structural comparisons concept expressions 
heart structural comparison idea concept expressions compared subexpressions compare separately subexpression concept 
sketch structural algorithm brachman levesque subsumption checking language fl algorithm works phases rst concepts rewritten normal form structures compared 
speci cally 
nested conjunctions attened conjunctions universal quanti cations factorized 
rewritten concepts logically equivalent previous ones subsumption preserved transformation 

ucm 
subsumes di di atomic concept concept form exists cj di cj di concept form exists cj form atomic role subsumes induction nesting quanti ers prove complexity algorithm jcj jdj levesque brachman 
subexpressions concept ordered lexicographically shown complexity linear dominant factor complexity ordering concepts 
algorithm extended language aln complexity 
similar normalize compare algorithms systems classic borgida patel schneider back quantz kindermann loom macgregor 
algorithms incomplete standard semantics concepts assumed 
due interactions constructors taken account structural comparisons 
obvious example concept subsumes concept 
subtle cases interaction 
highlight examples 
donini lenzerini nardi schaerf consistency written problem checking satis able model instance checking written problem checking assertion satis ed model importance concept satis ability subsumption stressed authors see example nebel 
particular subsumption central complex service classi cation concept tbox concepts determine subsumes ord subsumed intuitively nding right place taxonomy implicitly 
consistency verifying information contained base coherent 
instance checking check knowledge base entails individual instance concept considered central reasoning task retrieving information individuals knowledge base donini 
mentioned instance checking basic tool complex reasoning problems 
example retrieval query answering formulated way knowledge base concept nd set fa performed simply iterating instance checking individuals notice languages constructor expressing negation concepts cu gi 
subsumption reduced concept satis ability instance checking consistency 
reasoning concept expressions goal section overview reasoning techniques complexity results reasoning concept expressions 
particular consider subsumption concept satis ability case knowledge base empty 
order simplify notation case write problems rst describe approach structural comparison subsequently discuss approach tableaux 
discuss complexity results various languages highlight corresponding sources complexity 
concentrate called languages languages family 
complexity results satis ability subsumption including constructors donini 
patel schneider schild schmidt schau 
reasoning description logics satisfactory cases baader nebel de giacomo lenzerini schild 
refer section discussion cyclic statements di erent semantics tbox 
interpretation satis es statement statement statement statement model tbox satis es statements extensional knowledge construction extensional component base abox realized permitting concepts roles assertions individuals 
concept language statement inl forms concept membership assertion role membership assertion concept role individuals 
semantics assertions follows interpretation satis ed andr satis ed set assertions called abox 
interpretation said model assertion satis ed said satis able admits model 
knowledge bases concept language base inl pair ht ai tbox inl abox inl 
model model model knowledge base logically implies tbox abox statement written true model reasoning services reasoning services provided dl system 
said section concentrate basic ones formally de ne 
de nition knowledge base ht ai concepts individual call concept satis ability written problem checking satis able exists model subsumption written problem checking subsumed model donini lenzerini nardi schaerf implies di erent strings language 
example language alc 
dl systems knowledge base built description logics formed components intensional called tbox extensional called abox 
intensional knowledge rst focus attention intensional component base tbox 
di erent proposals dl system provide di erent mechanisms expressing tbox 
list types considered literature di erent kinds tboxes di er type tbox statements allow 
language tbox statement inl forms primitive concept speci cation concept de nition concept inclusion concept equation concept name concepts 
tbox tbox composed statements type 
primitive tboxes er nice computational properties see buchheit buchheit 
reason mechanism kind employed elds object oriented databases semantic data models see calvanese 
call simple tbox set statements type 
simple tboxes commonly considered mechanism employed implemented systems classic back 
simple tbox concept name appearing left hand side concept de nition called de ned concept concept name appearing left hand side primitive concept speci cation called primitive concept concept name appearing left hand side tbox statement called atomic concept 
general kind tbox called free tbox obtained admitting general concepts left hand side tbox statement 
free form type particular cases 
free tboxes distinction de ned primitive atomic concepts sense anymore 
di erent semantics proposed various tbox mechanisms depending fact cyclic statements allowed tbox 
consider called descriptive semantics appropriate reasoning description logics quanti cation named schmidt schau smolka language obtained fl adding negation concept names negation form convention identi ed string form indicating constructors allowed language similar way languages fl identi ed string form fl languages consider fl 
interpretation consists nonempty set domain function interpretation function maps concept subset role subset individual element complex concepts roles interpreted semantics tables respectively 
interpretation di erent individuals assumed denote di erent elements pair individuals interpretation ifa called unique name assumption usually assumed database applications 
interpretation model concept nonempty 
concept satis able model unsatis able 
say subsumed interpretation andc equivalent written ifc interpretation important observe semantics constructors independent ofeach 
precisely language constructor say simulates concept expressible language obtained adding exists equivalent expressible 
example su ciently powerful languages concept containing general negation rewritten equivalent containing negation concept names 
fact sign pushed inside obtain negation form reason constructor simulated language 
similar way show alc simulates point assume sake simplicity language constructors simulated available constructor written denotes set objects exists object related means role existential quanti cation ed sense condition stated existence 
donini lenzerini nardi schaerf constructor name syntax semantics concept name top bottom conjunction disjunction negation universal quanti cation fd ig existential quanti cation fd ri ci number restrictions nr fd fd ig ng nr fd fd rig ng collection individuals fa ang fai ain table syntax semantics concept forming constructors 
constructor name syntax semantics role name role conjunction table syntax semantics role forming constructors 
syntax semantics concept languages concept language composed symbols taken set concept names role names names individuals 
concept role individual names alphabet concept languages includes number constructors permit formation concept expressions role expressions set constructors concepts expressions role expressions considered listed tables respectively 
description constructors baader woods schmolze patel schneider swartout schaerf 
concept names denoted letters role names individuals names possibly subscripts 
concept expressions role expressions simply concepts roles denoted respectively letters various languages di er set constructors allow 
concept language uniquely identi ed set constructors 
concept resp 
role obtained constructors called concept resp 
role 
naming concept languages adopt terminology introduced schmidt schau smolka donini 
terminology identifying letter associated subset constructors shown tables 
brachman levesque language including universal quanti cation conjunction ed reasoning description logics technique practical 
languages known complete deduction procedures lead actual implementations adoption clever control strategies see example baader 
analysis pathological cases lead discovery forms incompleteness algorithms developed implemented systems de nition suitable test sets verifying implementations 
example comparison implemented systems described baader 
bene ted results complexity analysis 
survey organized follows section provides formal concept languages construction abox tbox associated reasoning services 
section deals reasoning concept expressions 
start recalling notion structural subsumption show inferences capture 
calculus complexity results satis ability subsumption concept expressions obtained exploiting calculus 
section deals reasoning abox 
consider problem checking set membership assertions logically implies individual instance concept 
introduce epistemic operator provides query facilities go rst order setting concept languages 
show epistemic queries may natural interpretation computational properties 
section deals reasoning tbox 
discuss di erent forms concept de nitions available tbox semantics complexity reasoning 
section brie revises problems related reasoning general setting tbox abox 
drawn section research issues related dl systems addressed discussed 
basic notions section basic notions regarding concept languages knowledge bases built concept languages reasoning services provided inferring information knowledge bases 
donini lenzerini nardi schaerf guage di culty reasoning representations built language 
words expressive language harder reasoning 
provide rst example trade analyzing language fl showing language subsumption problem solved polynomial time adding constructor called role restriction language subsumption conp hard problem 
started large body research aim analyze complexity reasoning di erent concept languages relying standard notions complexity theory particular worst case complexity analysis 
goal progress design reasoning techniques computational characterization reasoning problems arising dl systems 
purpose consider general framework takes account actual reasoning services need available dl systems 
brachman levesque start computational problems arising reasoning concept expressions look mechanisms de ning knowledge base abox requires reasoning individuals tbox requires deal axioms de ning properties concepts 
assumptions underlying research worst case analysis measure complexity reasoning tasks 
assumption criticized see example doyle patil consider outcomes research signi cant 
particular outline main contributions area concept languages generally representation 
study computational behavior concept languages led clear understanding properties language constructors interaction 
valuable theoretical viewpoint gives insight designer deduction procedures clear indications language constructors di cult deal general methods cope computational problems 
example system classic borgida designed account indications complexity analysis choice constructors included language 
secondly complexity results obtained exploiting general technique satis ability checking description logics 
technique relies tableaux calculus rst order logic simpli cation schau smolka 
proved extremely useful studying correctness complexity algorithms 
speci cally algorithmic framework parametric respect language constructors 
general algorithms concept satis ability subsumption obtained directly reasoning description logics concepts represent classes sets individuals roles binary relations specify properties attributes 
concepts denoted expressions formed means special constructors 
example concept expression child male denotes class fathers male parents children male 
symbol denotes concept conjunction interpreted set intersection 
expression child male denotes set individuals children male specifying property relates individuals role child 
expressions form called universal role quanti cations 
child male example existential role quanti cation denoting set individuals male child 
existential role quanti cation ed written child inwhich case denotes set individuals child 
basic language fl includes concept conjunction universal role quanti cation ed existential role quanti cation 
powerful languages de ned adding constructors basic language 
general characteristic dl systems knowledge base di erent components 
informally speaking rst general schema concerning classes individuals represented general properties mutual relationships usually referred tbox second partial instantiation schema containing assertions relating individuals classes individuals usually called abox 
setting inherited brachman schmolze shared proposals database models see abrial beck mylopoulos 
retrieving information dl systems deductive process involving schema tbox instantiation abox 
fact tbox just set constraints possible aboxes contains intensional information classes information taken account answering queries knowledge base 
goal organization main challenges study description logics identify fragment formal logic captures features needed representation purposes allows design ective cient reasoning methods 
aim concept languages considered expressiveness computational complexity studied brachman levesque formally studied properties simple language called fl frame language 
brachman levesque see levesque brachman argue trade expressivity representation lan donini lenzerini nardi schaerf identi ed arcs representing intensional knowledge representing extensional knowledge 
frame minsky usually represents concept class de ned er number elements called slots 
slot corresponds attribute members class 
contains information corresponding attribute default values restrictions possible llers attached procedures methods computing values needed procedures propagating side ects slot lled 
values attributes elements concrete domain integers strings identi ers frames 
frame represent single individual case related attribute instance frame representing class individual instance 
early frame systems su ered problem highlighted semantic networks 
fact semantics frames formally de ned particular distinction di erent types knowledge embedded frame system clear 
attempt providing formal ground semantic networks frames led development system kl brachman schmolze 
subsequently research gone direction providing systems explicit model theoretic semantics see example system omega attardi simi 
kr systems description logics terminological systems proposed successors kl tarskian semantics rst order logic 
family systems includes krypton brachman back quantz kindermann loom macgregor bates classic borgida kris baader hollunder see rich woods schmolze 
description logics systems subject survey focuses particular foundations techniques needed reasoning systems computational properties reasoning mechanisms 
important note foundations useful arti cial intelligence areas programming systems structured formalisms representation knowledge 
description logics systems application areas including con guration natural language processing software engineering see wright 
representing knowledge description logics core kr system description logics dl system concept language viewed set constructs denoting classes relationships classes 
concept languages reasoning description logics donini lenzerini nardi schaerf 
description logics stem semantic networks frames 
deal representation structured concepts reasoning 
structure concept described language called concept language comprising boolean operators conjunction disjunction negation various forms quanti cation attributes roles concept 
noticeable di erence structuring formalisms roles internal structure role expressed conjunction roles 
survey techniques reasoning computational complexity reasoning problems description logics referring di erent settings reasoning plain concept expressions reasoning instances concepts reasoning axioms expressing properties concepts reasoning instances concepts axioms 
mention important aspects description logics dealt survey 
idea developing knowledge representation systems structured representation knowledge rst pursued semantic networks frames 
semantic networks quillian lehmann represent knowledge form labeled directed graph nodes denote concepts arcs represent various relations concepts 
pointed woods brachman despite name early semantic networks su ered drawback clear semantics 
di culties arise fact semantic networks arcs represent di erent kinds relations nodes 
particular woods collection eds 
copyright csli publications 

