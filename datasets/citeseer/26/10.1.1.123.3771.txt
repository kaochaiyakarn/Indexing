unifying hybrid types contracts jessica cormac flanagan university california santa cruz contract systems hybrid type systems provide alternative approaches enforcing precisely defined interface specifications complementary advantages contract systems excel blame assignment hybrid type systems support type static analysis 
unify approaches demonstrating hybrid type checking sufficiently expressive encode higher order contracts proper blame assignment 
particular contract obligation enforces sides contract decomposed type casts enforce side contract 
expressiveness result provides benefits including allowing casts lifted earlier program execution resulting improved contract coverage 
development large software systems requires modular development strategy software modules communicate understood interfaces 
ideally interfaces formally specified mechanically enforced order detect isolate localize software errors 
static type systems dynamic contract systems complementary approaches enforcing software interfaces :10.1.1.11.4081
hybrid type checking combines approaches providing expressiveness benefits contract systems verifying refuting properties compile time traditional type systems 
modern contract systems excel blame assignment 
contract obligation contains labels modules party contract appropriate module blamed contract violation 
blame assignment works correctly presence complex control data flow operations involving higher order functions callbacks hybrid type systems analogous type cast operation contains module label 
difference suggests hybrid type systems weaker blame assignment sense fundamentally expressive contract systems 
investigates relationship approaches depth 
context idealized languages contract language con hybrid typed language :10.1.1.11.4081
surprisingly show sufficiently powerful express programs 
particular doubly labelled contract obligation enforces sides contract equivalent type casts single label enforces side contract 
addition main expressiveness result connection contract systems hybrid type systems yields benefits 
expresses complex construct terms simpler ones improving understandability 
second clarifies relationship type contract systems facilitating cross domains 
third suggests static analysis machinery hybrid type syntax evaluation rules int bool base types types contract contracts vc values blame tc expressions ec evaluation rules const beta true ok contract blame false fail blame blame fun compat blame systems including results decidability type inference applicable contracts programs 
fourth expressing contract casts allows casts lifted exported variable definition variable providing earlier error detection improved contract coverage 
remainder briefly review languages compared sections respectively 
section describes translation contracts types 
section shows enables notion lifting improves contract coverage 
section proves correctness translation 
conclude discussion related 
contract language reviewing see extends simply typed lambda calculus contracts lines findler felleisen :10.1.1.11.4081
language typed includes base types int bool function types addition simple types language includes contracts precisely define module interfaces base contract contract describes set values base type satisfy predicate type bool 
function contract describes functions take argument satisfying contract return values satisfying contract key goal contract system attribute blame contract violations particular program modules 
avoid complicating language module system modules defined expressions 
defines module identified label exports variable type contract code bound expression considered part main module 
execution program pre processed elaborated bound variable different module replaced languages eiffel include type contracts type rules type environment type rules var app blame blame const ty lam oblig contract type rules bool contract func contract obligation xc contract obligation enforces contract blames contract violation server module exports client module imports elaboration process formalized appendix evaluation rules programs straightforward see 
rule const relies auxiliary partial function expression expression define semantics constant functions 
example 
rules beta perform value evaluation function applications expressions 
rule compat compatibly closes evaluation relation evaluation context interesting rules evaluating contract obligation vc base contract contract evaluates false contract obligation reduces fail blame essentially blames server providing inappropriate value evaluates true contract fulfilled rule ok removes contract obligation function contract vc considered value 
value applied argument obligation decomposes smaller obligations argument result fun 
type system defined usual judgement states expression type environment 
auxiliary judgement check contract applicable values type rules defining judgements straightforward see 
illustrate operational semantics contracts consider elaborated program syntax types values blame expressions evaluation context evaluation rules const beta true ok blame false fail blame blame fun ctx blame int int int cpos cpos int int int cpos cpos cpos int base contracts cpos describe positive negative integers respectively 
example includes modules label module exported variable 
program evaluated follows clarity shade contract obligation grey white obligation occurs expression produced module respectively 
int cpos int int cpos cpos int int cpos int int int cpos cpos int cpos int cpos cpos int cpos int cpos cpos 
case contract obligation fails contract labels prove error originated module violated contract cpos cpos 
alternatively literal replaced contract obligation succeed program evaluate int cpos cpos cpos case violation 
large software systems ability detect localize software errors extremely important 
hybrid typed calculus languages eiffel incorporate static type system dynamic contract system unifies interface specification systems single expressive type system 
syntax shown includes types expressions values 
types include expressive refinement types form describe set values base type satisfy predicate example int describes set positive numbers 
types enforced dynamically type cast expression statically typed type cast dynamically enforces value produced type module labeled blamed 
defines evaluation rules particular interest rules type casts 
casting value base refinement type involves checking predicate evaluates true 
function cast considered value argument supplied cast decomposed smaller casts function argument result fun 
function casts involve subtle mix static dynamic reasoning 
original function type evaluation rules ensure applied values type 
argument cast generated fun enforces domain constraint dynamically relies type system ensure type 
function cast types enforced dynamically type system responsible enforcing 
respects type casts contract obligations noticeable difference type casts include blame labels suggests significantly weaker ability assign blame program failures appropriate erroneous module 
address topic section 
type system defined judgement states expression type environment see 
auxiliary judgement checks formed type 
subtyping function types straightforward sub fun 
subtyping refinement types defined sub base 
rule uses auxiliary judgement states true variable substitution consistent type environment 
notion consistency substitution variables values environment formalized final judgement refer interested reader details 
type checking general undecidable 
start typed programs translate expressions manner type preserving generated programs typed construction 
expressing contracts types address key question sufficiently powerful express programs including proper attribution contract violations appropriate modules 
translating types expressive types translation adds trivial refinement predicate true base types 
true translate contracts types translation leverages expressive power refinement types emulate contracts 
contract fv translations shed light relationship types contracts 
suppose contract type 
contract restriction expect subtype 
property holds base contracts function contracts type rules type environment type rules var app blame blame const ty cast lam sub formed types wf fun wf base bool subtyping sub fun sub base implication rule imp 
true implies true consistent substitutions cs empty cs ext contravariance function domains 
may incomparable subtyping relation 
types identical structure precise refinement predicates 
base base function strips refinement predicates types 
base true base base base consider translate expression behaviorally equivalent expression particular translate function contract obligations program cpos program typed type int int 
translated expression type sint sint sint trivial refinement type int true 
attempt translate contract obligation corresponding type cast yielding program sint sint refinement type describes negative integers translation problems 
retains blame label resulting incorrect blame assignment 
second importantly translated program ill typed casted function type applied expression type sint 
program ill typed longer enforces original domain contract 
solve problems need introduce second type cast dynamically enforce domain component function contracts yielding translated program sint sint sint sint essentially second cast dynamically detects client attempts violate original contract annotated client label value produced satisfy interface server blamed 
conversely context abuses interface providing positive arguments example client blamed 
type casts exactly enforce semantics original contract obligation 
complete translation expressions expressions compatible closure rule translating contract obligations tc base base blame blame example illustrate translation apply earlier example yielding program sint sint sint sint sint sint base base sint type encodes original contract 
note includes simple types precise refinement types casts implement contract obligations original program 
program reduces expression sint sint sint sint sint sint sint sint stage cast sint fails correctly blames contract violation 
conversely literal replaced evaluate sint sint sint sint sint case violation 
improving contract coverage program exported variable enclosed cast base mention client module refactor program avoid repeatedly re checking cast check cast defined 
base 
base sint 
refactored program type explicates cast performed 
second cast base remains client module detect attempt pass incorrect arguments refactoring yields main advantages 
evaluating cast base multiple times may result better performance 
second refactoring provides earlier better error detection 
suppose module exported literal clear violation cpos contract 
contract violation detected contract obligation evaluated may course happen certain code paths exercised 
contrast refactored version program letm sint detect error immediately 
refactoring enabled translation permits increased contract coverage correctness translation prove semantics preserving translation 
type preserving maps typed expressions typed expressions 
formal statement proof property relies auxiliary function maps type environments type environments translating types bindings 
theorem type preservation 

second translation preserves operational semantics expression evaluates translated expression evaluates expression reachable 
theorem behavioral equivalence related enforcement complex program specifications contracts subject large body prior :10.1.1.11.4081
contracts typically expressible classical type systems previously relegated dynamic checking example eiffel 
eiffel expressive contract language strictly separated type system 
bigloo scheme compiler introduced higher order contracts 
findler felleisen describe con language higher order contract system provides elegant way introduce propagate enforce contracts assign blame appropriately :10.1.1.11.4081
blume mcallester model con order prove soundness contract checker extend system recursive contracts 
advanced type systems influenced choice express program invariants particular freeman pfenning extended ml form refinement types 
focuses providing decidable type checking type inference supporting arbitrary refinement predicates 
xi pfenning explored applications dependent types dependent ml :10.1.1.41.548
complementary approach chen xi address decidability limitations providing mechanism programmer provide proofs subtle properties source code 
attempts connect fields study developing formal connection type systems contract systems showing hybrid type system express higher order contracts obligations precise blame assignment 
meunier investigated statically verifying contracts set analysis findler blume defined partial order higher order contracts contravariant domain :10.1.1.11.4081
ideas appear closely related corresponding notions type inference subtyping type theory 
plan framework explore kinds deep connections contract theory type theory formal manner 
cross fields may yield additional contributions type theory may help apply existing type theory contract programs 
blume mcallester 
sound complete models contracts 
journal functional programming 
blume mcallester 
sound complete model contracts 
icfp pages 
chen xi 
combining programming theorem proving 
icfp pages 
findler 
personal communication october 
findler blume 
contracts pairs projections 
proceedings symposium logic programming pages 
findler blume :10.1.1.11.4081
contracts pairs projections 
hagiya wadler editors flops volume 
springer 
findler felleisen :10.1.1.11.4081
contracts higher order functions 
icfp pages new york ny usa 
acm press 
findler felleisen 
contracts higher order functions 
proceedings international conference functional programming pages 
flanagan 
hybrid type checking 
popl pages new york ny usa 
acm press 
freeman pfenning 
refinement types ml 
proceedings acm conference programming language design implementation pages 
gomes stoutamire 
language manual sather 
holt cordy 
turing programming language 
commun 
acm 
knowles flanagan 
type reconstruction general refinement types 
esop appear 
lling rosenberg 
blue language specification version 
leavens cheon 
design contract jml 
www cs iastate edu leavens jml 
luckham 
programming specifications 
texts monographs computer science 
meunier findler felleisen 
modular set analysis contracts 
proceedings acm symposium principles programming languages pages 
meyer 
object oriented software construction 
prentice hall 
meyer 
eiffel language 
prentice hall upper saddle river nj usa 
parnas 
technique software module specification examples 
commun 
acm 
serrano 
bigloo practical scheme compiler 
xi 
imperative programming dependent types 
proceedings ieee symposium logic computer science pages 
xi pfenning 
dependent types practical programming 
proceedings acm symposium principles programming languages pages 
elaboration fv contract contract fv blame blame undefined tc elaboration rules contract obligations appear source code inserted elaboration function declared contracts exported variables 
function described performs elaboration 
accepts expression elaborate function label module containing function maps free variables contract label exported variable defining module 
define similar elaboration function contracts 
elaborating variable returns contract obligation current module 
elaborating binding new variable comes scope adds contract label elaborating expressions scope proof type preservation proof type preservation relies simple lemmas lemma formed translations lemma base restatement theorem type preservation 

proof aside relying lemmas proof induction type rule prove judgement lam suppose 
lemma const suppose ty 
true ty var suppose app suppose 
suppose 
lemma blame suppose blame true blame oblig suppose lemma base lemma base base lemma base base base base base base proof behavioral equivalence proof behavioral equivalence relies lemmas lemma lemma translation maps values values 
lemma single step behavioral equivalence proof single step behavioral equivalence proof induction evaluation rules cases fun case 
const suppose 
beta suppose 
lemma lemma lemma suppose 
lemma lemma blame suppose blame blame 
blame blame blame blame ok suppose contract true 
contract lemma lemma fail suppose contract blame false 
contract blame lemma blame fun suppose 

basic refinement type base base base blame cast base succeeds 
consider case basic refinement type vc base base base base base base base base base base lemma base base base base base lemma base base lemma consider case function type usual vc nv base base base base base base base base base lemma ctx case holds inspection 

lemma operational semantics deterministic 
restatement theorem behavioral equivalence proof proof induction length reduction define notation indicate steps occured 
note case trivially true 
true base case 
base case case covered lemma 
inductive case exists unique lemma 
induction know sn sn sn 
lemma know sn sn sn 
consider case 
sn sn evaluation deterministic lemma 
conclude sn sn 
sn finished 
case symmetric 

