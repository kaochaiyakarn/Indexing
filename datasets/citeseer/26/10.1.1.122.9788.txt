korat automated testing java predicates chandrasekhar boyapati khurshid darko marinov mit laboratory computer science technology square cambridge ma usa chandra khurshid marinov lcs mit edu presents korat novel framework automated testing java programs 
formal specification method korat uses method precondition automatically generate nonisomorphic test cases bounded size 
korat executes method test cases uses method postcondition test oracle check correctness output 
generate test cases method korat constructs java predicate method returns boolean method precondition 
heart korat technique automatic test case generation predicate bound size inputs korat generates nonisomorphic inputs predicate returns true 
korat exhaustively explores input space predicate efficiently monitoring predicate executions pruning large portions search space 
illustrates korat testing data structures including java collections framework 
experimental results show feasible generate test cases java predicates search space inputs large 
compares korat testing framework declarative specifications 
contrary initial expectation experiments show korat generates test cases faster declarative framework 

manual software testing general test data generation particular labor intensive processes 
automated testing significantly reduce cost software development maintenance 
presents korat novel framework automated testing java programs 
korat uses specification testing 
formal specification method korat uses method precondition automatically generate nonisomorphic test cases bounded size 
korat executes method test cases uses method postcondition test oracle check correctness output 
generate test cases method korat constructs java predicate method returns boolean method precondition 
key contributions korat technique automatic test case generation predicate bound size inputs korat generates nonisomorphic inputs predicate returns true 
korat exhaustively explores input space predicate efficiently monitoring predicate executions pruning large portions search space 
korat uses optimization generate phic test cases 
optimization reduces search time compromising exhaustive nature search 
korat uses backtracking systematically explore input space predicate 
korat generates candidate inputs checks validity invoking predicate 
korat monitors accesses predicate fields candidate input 
predicate returns reading fields candidate validity candidate independent values fields korat uses observation prune search 
korat lets programmers write specifications language long specifications automatically translated java predicates methods return booleans 
current korat implementation uses java modeling language jml specifications 
programmers jml write method preconditions postconditions class invariants 
jml uses java syntax semantics expressions contains extensions quantifiers 
large subset jml automatically translated java predicates 
programmers korat having learn specification language different java 
jml specifications call java methods programmers full expressiveness java language write specifications 
illustrate korat consider method removes minimum element balanced binary tree 
precondition method requires input satisfy class invariant input binary tree tree balanced 
korat uses precondition predicate generating nonisomorphic balanced binary trees bounded size 
programming practice suggests implementations data types provide predicates test class invariants known repok methods korat generates test cases free 
korat invokes method generated trees checks postcondition case 
method postcondition specified korat test partial correctness method 
binary tree example korat check class invariant remove method verify input tree remains balanced binary tree removing minimum element 
korat test data structures including java collections framework 
experimental results show feasible generate test cases java predicates search space inputs large 
particular experiments indicate practical generate inputs achieve complete code coverage intricate methods import java util class binarytree private node root root node private int size number nodes tree static class node private node left left child private node right right child public boolean repok checks empty tree size zero root null return size set visited new visited add root linkedlist worklist add root worklist isempty node current node worklist current left null checks tree cycle visited add current left return false worklist add current left current right null checks tree cycle visited add current right return false worklist add current right checks size consistent visited size size return false return true binarytree example manipulate complex data structures 
compares korat alloy analyzer generate test cases declarative predicates 
contrary initial expectation experiments show korat generates test cases faster alloy analyzer 
rest organized follows 
section illustrates korat examples 
section presents algorithm korat uses explore search space 
section describes korat checks method correctness 
section presents experimental results 
section reviews related section concludes 

examples section presents examples illustrate programmers korat test programs 
examples binary tree data structure heap data structure illustrate methods manipulate linked data structures array data structures respectively 
binary tree section illustrates generation testing linked data structures simple binary trees 
java code declares binary tree defines repok method 
repok method java predicate checks representation invariant class invariant corresponding data structure 
case method checks input 
object class binarytree represents tree 
size term heap refers data structure priority queues garbage collected memory 
public static finitization int num node finitization new finitization binarytree class nodes node num node node num node nodes add null set root nodes root null node set size num node size num node set node left nodes node left null node set node right nodes node right null node return finitization description example right right right left left right left left left right trees generated field contains number nodes tree 
objects inner class node represent nodes trees 
method repok checks tree empty 
repok traverses nodes reachable root keeping track visited nodes detect cycles 
method add java util set returns false argument exists set 
generate trees number nodes korat search algorithm uses finitization description shown 
statements finitization description specify bounds number objects construct instances data structure bounds possible values stored fields objects 
finitization description shown automatically generated type declarations java code 
parameter num node specifies bound number nodes tree 
field tree null points node objects 
note identity objects irrelevant trees isomorphic branching structure irrespective actual nodes trees 
korat automatically generates nonisomorphic trees number nodes 
example korat generates trees shown 
example korat generates trees second 
illustrate programmers korat check correctness methods 
jml annotations specify partial correctness example remove method removes binarytree node tree 
normal behavior annotation specifies precondition requires conjoined invariant satisfied method postcondition ensures conjoined invariant satisfied method method returns throwing exception 
helper method checks tree contains node 
korat uses jml tool set translate annotations runtime java assertions 
test method korat generates test inputs 
input pair tree node 
precondition defines valid inputs method tree valid node tree 
finitization inputs written public invariant repok class invariant binarytree public normal behavior specification remove requires precondition ensures postcondition public void remove node method body partial specification remove public class private int size number elements heap private comparable array heap elements public boolean repok checks array non null array null return false checks size array bounds size size array length return false int size checks elements non null array null return false checks array array array return false checks non heap elements null int size array length array null return false return true example reusing finitization description trees korat generates nonisomorphic inputs 
number input pairs product number trees number nodes trees 
generating inputs korat invokes method runtime assertions postconditions input reports counterexample method fails satisfy correctness criteria 
heap array section illustrates generation checking array data structures heap data structure 
binary heap data structure viewed complete binary tree tree completely filled levels possibly lowest filled left point 
heaps satisfy heap property node root value parent greater equal value java code declares array heap defines method 
method checks input valid 
elements heap stored 
elements implement providing comparisons 
method repok checks special case array null 
repok checks size heap bounds array 
repok checks array elements belong heap null satisfy heap property 
repok checks array elements belong heap 
generate heaps korat search algorithm uses finitization description shown 
emphasize finitization description shown automatically generated type declarations java code 
public static finitization int max size int max length int max elem finitization new finitization class size max size set size new intset max size set array array length max length new intset max length array null integer max elem new max elem add null return finitization description example size array size array null size array integer size array integer heaps generated size max length elem bound size heap length array elements array respectively 
elements array null contain integer objects integers range elem 
values finitization parameters korat automatically generates heaps 
example korat generates heaps shown 
example second korat generates heaps 
note korat requires repok method finitization generate heaps 
writing dedicated heap generator involved writing repok 
note korat allows repok full java language 
illustrate programmers korat check partial correctness method removes returns largest element 
jml annotations specify partial correctness method 
behavior specifies input heap valid non empty method returns largest element original heap resulting heap execution method valid 
jml keywords result old denote respectively object returned method expressions evaluated pre state 
jml annotations express exceptional behavior methods 
exceptional behavior specifies input heap empty method throws 
check method korat uses finitization generate nonisomorphic heaps satisfy normal behavior precondition behavior precondition 
korat invokes method runtime assertions postconditions input reports counterexample invocation fails satisfy correctness criteria 

test case generation heart korat technique test case generation java predicate finitization input korat automatically generates nonisomorphic inputs predicate returns true 
gives overview korat search algorithm 
public invariant repok public normal behavior requires size ensures result old array public exceptional behavior requires size signals true public comparable method body partial specification void predicate finitization object candidate try invoke candidate output candidate catch exception backtrack pseudo code korat search algorithm korat uses backtracking exhaustively explore state space predicate inputs 
korat generates candidate inputs checks validity invoking predicate 
korat monitors accesses predicate fields candidate input 
monitor accesses korat instruments predicate methods predicate transitively invokes 
predicate returns reading fields candidate validity candidate independent values fields korat uses observation prune search 
korat uses optimization generates nonisomorphic test cases 
section illustrates korat generates valid inputs predicate methods take implicit argument 
section shows korat generates valid inputs java predicates take multiple arguments 
finitization generate finite state space predicate inputs search algorithm needs finitization set bounds limits size inputs 
inputs consist objects classes finitization specifies number objects classes 
set objects class called class domain 
finitization specifies field objects field domain set values field take 
spirit implementation language programmers familiar specification testing korat provides finitization class allows written java 
korat automatically generates finitization skeleton type declarations java code 
repok method binarytree example korat automatically generates skeleton shown 
method specifies input contains num node objects node 
set method specifies field domain field 
skeleton fields root left right specified contain null initial version korat provided special purpose language compact descriptions sketched comments examples figures 
public static finitization int num node int min size int max size finitization new finitization binarytree class nodes node num node nodes add null set root nodes set size new intset min size max size set node left nodes set node right nodes return generated finitization description node object 
size field specified range min size size utility 
korat package provides additional classes easy construction class domains field domains 
korat generates finitization skeleton programmers specialize generalize 
example skeleton shown specialized size size num node 
specialized finitization 
note programmers full expressive power java language writing finitization descriptions 
state space continue example illustrate korat constructs state space input repok finitization 
consider case korat invoked num node 
korat allocates specified objects binarytree object node objects 
node objects form node class domain 
korat assigns field domain unique identifier field objects 
identifier index candidate vector 
example vector elements total fields object fields root size node objects fields left 
example input sample valuation fields 
state space inputs consists possible assignments fields field gets value corresponding domain 
domain fields root left right elements null nodes class domain state space potential candidates 
node state space potential candidates 
shows example candidate valid binary tree nodes 
valuations valid binary trees 
shows example candidate tree repok input 
search systematically explore state space korat orders elements field domain class domain 
candidate input vector indices corresponding field domains 
running example num node assume node class domain ordered field domains left ordered null 
domain size field single element 
ordering candidate vectors field domain order preserve respective class domain orders 
binarytree root size left right left right left right null null null null left right candidate input 
binarytree root size left right left right left right null null null null left right candidate input 
correspond candidate inputs figures respectively 
search starts candidate vector set zeros 
candidate korat sets fields objects values vector 
korat invokes repok check validity current candidate 
execution repok korat monitors fields repok accesses 
specifically korat builds field ordering list field identifiers ordered accesses corresponding field 
consider invocation repok candidate shown 
case repok accesses fields root left right order 
field ordering korat builds 
returns korat generates candidate vector backtracking fields accessed 
korat increments domain index field field ordering 
domain index exceeds domain size korat resets index zero increments domain index previous field field ordering 
section presents korat generates nonisomorphic candidates resetting domain index field zero index exceed size field domain 
continuing example candidate takes value right order fields change 
prunes search candidate vectors form partial valuation root left right 
pruning rule valid data structure read fields irrespective values fields 
continuing example candidate valid tree shown 
input repok returns true field ordering built korat 
note fields field ordering 
repok method accesses fields deterministic order values fields field ordering changed current candidate constructed previous candidate 
algorithm assumes deterministic executions predicate methods methods predicates transitively invoke 
particular algorithm assumes order field accesses solely determined candidate input nal input 
similarly algorithm assumes result predicate method solely determined candidate input 
korat outputs nonisomorphic candidates values accessed fields current candidate 
note may access reachable fields 
search backtracks candidate 
recall korat orders values class field domains 
additionally execution repok candidate imposes order fields field ordering 
orders induce lexicographic order candidates 
search algorithm described generates inputs lexicographical order 
practice search algorithm prunes large portions search space enables korat explore large state spaces 
efficiency pruning depends repok method 
ill written repok example read entire input returning forcing korat explore candidate 
experience indicates naturally written repok methods return false soon invariant violation detected induce effective pruning 
optimize search korat avoids generating multiple candidates isomorphic 
optimization definition isomorphism 
definition 
sets objects classes 
suppose candidates consist objects 
pointer fields objects point objects 
set null values primitive types fields objects contain 
special root object oc set objects reachable candidates isomorphic iff permutation mapping objects oi objects oi oc fields iff iff 
operator java comparison object identity 
note isomorphism defined respect root object 
candidates defined isomorphic parts object graphs reachable root object isomorphic 
case repok root object object passed implicit argument 
isomorphism candidates partitions state space isomorphism partitions 
recall lexicographic ordering induced ordering values field domains built repok executions 
isomorphism partition korat generates lexicographically smallest candidate partition 
conceptually korat avoids generating multiple candidates isomorphism partition follows 
field korat uses field domain index compute corresponding current class domain class domain index 
instance example ordering field domain index root corresponds class domain node class domain index 
field class boolean 
predicate method multiple arguments class boolean repok return method field ordering korat finds mf maximum domain index fields field ordering class domain fields preceding field class domain korat sets mf 
backtracking field ordering korat checks incrementing field domain index field exceeds mf 
korat resets index zero continues backtracking previous field field ordering 
actual korat implementation uses caching speed computation mf example korat generates trees shown 
tree representative isomorphism partition distinct trees 
permutations nodes 
instrumentation executions korat instruments classes objects appear doing source source translation 
classes korat adds special constructor 
field classes korat adds identifier field special get set methods 
code repok methods repok transitively invokes korat replaces field access invocation corresponding get set method 
arrays similarly instrumented essentially treating array element field 
monitor field accesses build field ordering korat uses approach similar observer pattern 
korat uses special constructors initialize objects finitization observer 
search algorithm initializes identifier fields unique index candidate vector 
special get set methods notify observer field access field identifier perform field access return field value assign field 
predicates multiple arguments discussion far described korat generates inputs satisfy repok method 
section describes korat generalizes technique generate inputs satisfy java predicate including predicates take multiple arguments 
shows java predicate takes arguments 
order generate inputs predicate korat generates equivalent repok method shown 
korat generates inputs method technique described earlier 

testing methods previous section focused automatic test case generation java predicate finitization description 
section class binarytree remove binarytree implicit parameter binarytree node node parameter public boolean repok return repok class remove public static finitization remove int num node finitization new finitization binarytree remove class finitization binarytree num node set binarytree class set return finitization skeleton remove presents korat builds technique check correctness methods 
korat uses specification testing test method korat generates test inputs method precondition invokes method inputs checks correctness output method postcondition 
current korat implementation uses java modeling language jml specifications 
programmers jml annotations express method preconditions postconditions class invariants annotations jml keywords requires ensures respectively 
annotation contains boolean expression jml uses java syntax semantics expressions contains extensions quantifiers 
jml specifications express normal exceptional behaviors method 
behavior precondition postcondition method invoked precondition class invariant satisfied behavior requires method terminate postcondition class invariant satisfied 
additionally normal behaviors require method return exception exceptional behaviors require method return exception 
korat generates inputs method behaviors complete method precondition conjunction class invariant disjunction preconditions behaviors 
text follows refer complete precondition simply precondition 
generating test cases valid test cases method satisfy precondition 
generate valid test cases korat creates class represents method inputs 
class field parameter method including parameter predicate uses precondition check validity method inputs 
finitization korat generates inputs repok returns true inputs valid input original method 
illustrate generation test cases method binarytree section 
method input consists pair binarytree node complete precondition 
shows class korat creates method inputs 
class korat creates finitization skeleton reuses finitization binarytree shown 
create finitization binarytree remove programmer modify skeleton replacing get root org binarytree node class set domain parameter domain field root set nodes finitization respectively 
value num node korat generates valid test cases pair tree nodes node tree 
dependent independent parameters remove method precondition parameters explicitly dependent 
parameters independent programmers instruct korat generating test cases separately generating possibilities parameter creating valid test cases cartesian product possibilities 
compare korat straightforward approaches generating valid nonisomorphic test cases 
straightforward approach generating valid test cases cartesian product dependent parameters 
consider parameters 
suppose set possibilities si parameters 
valid test cases sn generated creating tuples product followed filtering 
approach jml junit testing framework combines jml junit 
note approach requires manually constructing possibilities parameters complex data structures 
korat hand constructs data structures simple description fields structures 
terms korat search repok state space approach correspond search tries candidate input 
korat improves approach pruning search accessed fields generating representative isomorphism partition 
checking correctness check method korat generates valid inputs method process explained 
korat invokes method inputs checks output test oracle 
check partial correctness method simple test oracle just post state state immediately method invocation check method preserves class invariant 
result false method test incorrect input provides concrete counterexample 
programmers manually develop elaborate test oracles 
programmers check properties relate post state pre state state just method invocation 
current korat implementation uses jml tool set automatically generate test oracles method postconditions jml junit framework 
jml tool set translates jml postconditions runtime java assertions 
execution method violates assertion exception thrown indicate violated postcondition 
test oracle catches exceptions reports correctness violations 
exceptions different exceptions method specification allows 
korat uses jml check normal exceptional behavior methods 
details jml tool set translation 
korat uses jml junit combine jml test oracles ju testing framework testing activity junit jml junit korat generating test cases generating test oracle running tests table comparison testing frameworks java 
testing activity manual automated 
nit popular framework unit testing java modules 
junit automates test execution error reporting requires programmers provide test inputs test oracles 
jml junit automates test execution correctness checking 
jml junit requires programmers provide sets possibilities method parameters generates valid inputs generating cartesian product possibilities filtering tuples preconditions 
korat additionally automates generation test cases automating entire testing process 
table summarizes comparison testing frameworks 

experimental results section presents performance results current korat implementation 
java implement search valid nonisomorphic repok inputs 
automatic instrumentation repok transitively invoked methods modified sources sun javac compiler 
modified javac automatically generate finitization skeletons 
checking method correctness slightly modified jml toolset building existing jml junit framework 
section presents korat performance test case generation 
compare results test generation uses alloy analyzer 
korat performance checking method correctness 
experiments performed linux machine pentium iii mhz processor sun java sdk jvm 
benchmarks table lists benchmarks show korat performance 
binarytree section 
similar array stacks queues util vectors 
linkedlist implementation linked lists java collections framework part standard java libraries 
implementation uses doubly linked circular lists node sentinel node 
list field 
methods linked lists provide allow stacks queues 
treemap implements map interface red black trees 
implementation uses binary trees parent fields 
node implemented inner class entry key value 
setting value fields null corresponds java util 
implements interface backed hash table 
implementation builds collision lists buckets hash code 
parameter determines increase size hash table rehash elements 
benchmark package finitization parameters binarytree korat examples num node korat examples max size max length max elem linkedlist java util min size max size num entry num object treemap java util min size num entry max key max value java util max capacity max count max hash ins namespace num max child num string table benchmarks finitization parameters 
benchmark named class data structures generated structures contain objects classes 
implements intentional name trees describe properties services intentional naming system ins architecture service location dynamic networks 
node intentional name attribute value set children nodes 
ins uses attributes values classify services properties 
names properties implemented arbitrary strings wildcard matches values 
finitization bounds number objects implement nodes number children node total number strings including wildcard 
korat test case generation table presents results generating valid structures korat implementation 
benchmark finitization parameters set size value 
range size values tabulate time korat takes generate valid structures number structures generated number candidate structures checked size state space 
large state spaces korat effectively generate structures search pruning allows korat explore tiny fraction state space 
ratios number candidate structures sizes state space show key effective pruning backtracking fields accessed repok executions 
backtracking isomorphism optimization korat generate candidates 
isomorphism optimization reduces number candidates mainly reduces number valid structures 
linkedlist treemap numbers nonisomorphic structures appear sloane line encyclopedia integer sequences :10.1.1.46.1556
benchmarks korat generates expected numbers 
comparison alloy analyzer compare performance korat test case generation alloy analyzer aa automatic tool analyzing alloy models 
alloy order declarative language relations 
alloy suitable modeling structural properties software 
alloy models data structures parameter set 
parameter set 
benchmark size time structures candidates state sec generated considered space binarytree linkedlist treemap table korat performance benchmarks 
finitization parameters set size value 
time elapsed real time seconds entire generation 
state size rounded nearest smaller exponent 

models specify class invariants alloy corresponds repok methods korat declare field types corresponds setting field domains korat 
model data structure scope bound number atoms universe discourse aa generate nonisomorphic instances model 
instance relations model constraints model satisfied 
setting scope alloy corresponds setting finitization parameters korat 
aa translates input alloy model boolean formula uses shelf sat solver find satisfying assignment formula 
assignment translated back instance input model 
aa adds symmetry breaking predicates boolean formula different satisfying assignments formula represent nonisomorphic instances input model :10.1.1.46.1556
table summarizes performance comparison 
aa handle arbitrary arithmetic aa 
benchmarks compare total number structures instances time generate range parameter values 
compare time generate structure instance instructing korat aa generating structure instance 
time total elapsed real time seconds experiment took including start 
start time korat approximately sec 
cases generating structures faster gen include start time aa provide generation time generating instances 
eliminate effect cold start executing test twice smaller time 
korat alloy analyzer benchmark size struc 
total inst 
total gen time struc 
gen time inst 
binarytree linkedlist treemap table performance comparison 
benchmark performances korat aa compared range finitization values 
values larger aa complete generation hour 
korat performance larger values table 
erating structure generating structures larger input faster generating structures smaller input 
start time aa somewhat higher approximately sec aa needs translate model start sat solver 
aa uses precompiled binaries sat solvers 
cases korat outperforms aa korat faster smaller inputs completes generation larger inputs aa 
reasons account difference 
aa translates alloy models boolean formulas current implementation translation generates unnecessarily large boolean formulas 
reason aa generates greater number instances korat takes greater amount time 
way reduce number instances generated aa add predicates 
increase size boolean formulas clear trade affect aa performance 
main argument developing korat simple java programmers familiar alloy easier write repok method alloy model 
experience researchers familiar alloy easier write alloy model repok method 
conducting experiments expected korat generate structures slower aa 
intuition korat depends executions repok learn invariants structures aa uses sat solver inspect entire formula representing invariants decide search assignment 
experimental results show assumption incorrect korat generates structures faster aa 
exploring translation alloy models java korat similar search generate instances 
checking correctness table presents results checking methods korat 
benchmark representative method chosen results benchmark method max 
test cases gen test size generated time time binarytree remove linkedlist reverse treemap put add lookup table korat performance methods 
finitization parameters method inputs set maximum size 
sizes give complete code coverage 
times elapsed real times seconds entire generation valid test cases testing methods inputs 
times include writing reading files test cases 
similar methods 
methods remove extract max section 
method reverse java util collections uses list iterators reverse order list elements method static 
method put java util treemap inserts key value pair map method parameters key invokes helper methods rebalance tree insertion 
method add inserts element set 
method lookup ins searches database intentional names query intentional name 
correctness specifications methods specify simple containment properties preservation class invariants 
method min finitization parameters set zero max num parameters size value 
methods checked valid inputs maximum size maximum size 
tabulated sizes inputs give complete code coverage execute reachable statements methods including methods transitively invoke classes tested 
results show practical korat exhaustively check correctness intricate methods manipulate complex data structures 
aa check correctness java methods writing method specifications alloy models defining appropriate translations alloy instances java objects demonstrated testera framework 
large number instances generated aa testera practical korat 
example maximum sizes methods respectively smallest give complete code coverage 
shown table sizes aa reasonable time generate data structures parts inputs methods 

related section presents related korat 
specification testing large body research specification testing 
early goodenough gerhart emphasizes importance 
projects automate test case generation specifications specifications uml statecharts adl specifications 
specifications typically consider linked data structures tools generate java test cases 
testera framework generates java test cases loy specifications linked data structures 
testera uses alloy analyzer aa automatically generate method inputs check correctness outputs requires programmers learn specification language different java 
korat generates inputs directly java predicates uses java modeling language jml specifications 
experimental results show korat generates test cases faster larger scopes aa 
cheon leavens describe automatic translation jml specifications test oracles junit 
framework automates execution checking methods 
burden test case generation programmers provide sets possibilities method parameters 
korat builds framework automating test case generation 
static analysis projects aim developing static analyses verifying program properties 
extended static checker esc uses theorem prover verify partial correctness classes annotated jml specifications :10.1.1.152.4499
esc verify absence errors null pointer dereferences array bounds violations division zero 
tools esc verify properties complex linked data structures 
research projects attempt address issue 
valued logic analyzer tvla static analysis system verify list structure preserved programs perform list reversals destructive updating input list :10.1.1.152.1240
tvla analyze programs manipulate doubly linked lists circular lists sorting programs 
tvla primarily intraprocedural role analysis supports compositional interprocedural analysis verifies similar properties 
pointer assertion logic engine pale verify large class data structures expressed graph types :10.1.1.46.1556
graph types consist data structures represented spanning tree backbone possibly additional pointers add extra information 
graph types include data structures doubly linked lists trees parent pointers threaded trees 
static analysis program properties promising approach ensuring program correctness long run current static analysis techniques verify limited program properties 
example techniques verify correctness implementations balanced trees red black trees 
testing hand general verify stronger program properties inputs bounded size 
jackson propose approach analyzing methods manipulate linked data structures 
approach build alloy model bounded initial segments computation sequences check model exhaustively aa 
approach provides static analysis unsound respect size input length computation 
korat checks entire computation handles larger inputs complex data structures 
korat require alloy jml specifications importantly korat require specifications helper methods 
software model checking lot interest applying model checking software 
verisoft operate directly java respectively program systematically explore state check correctness :10.1.1.32.5769
projects bandera translate java programs input language existing model checkers spin smv :10.1.1.29.3872
handle significant portion java including dynamic allocation object exceptions inheritance threads 
provide automated support reducing program state space program slicing data abstraction 
applying model checking software focused checking event sequences linked data structures 
data structures considered purpose reduce state space explored check data structures 
korat hand checks correctness methods manipulate linked data structures 

korat novel framework automated testing java programs 
formal specification method korat uses method precondition automatically generate nonisomorphic test cases bounded size 
korat executes method generated test cases uses method postcondition test oracle check correctness output 
generate test cases method korat constructs java predicate method returns boolean method precondition 
heart korat technique automatic test case generation predicate finitization inputs korat generates nonisomorphic inputs predicate returns true 
korat exhaustively explores input space predicate efficiently monitoring predicate executions prune large portions search space generating nonisomorphic inputs 
current korat implementation uses java modeling language jml specifications class invariants method preconditions postconditions 
programming practice suggests implementations data types provide methods checking class invariants korat generates test cases free 
illustrated korat testing data structures including java collections framework 
experimental results show feasible generate test cases java predicates search space inputs large 
compared korat alloy analyzer generate test cases declarative predicates 
contrary initial expectation experiments show korat generates test cases faster alloy analyzer 
results checking correctness indicate practical generate inputs achieve complete code coverage intricate methods manipulate complex data structures 

adjie winoto schwartz balakrishnan lilley 
design implementation intentional naming system 
proc 
th acm symposium operating systems sosp kiawah island dec 
gamma 
test infected programmers love writing tests 
java report july 
beizer 
software testing techniques 
international thomson computer press 
chang richardson 
structural specification testing automated support experimental evaluation 
proc 
th acm sigsoft symposium foundations software engineering fse pages sept 
cheon leavens 
simple practical approach unit testing jml junit way 
technical report department computer science iowa state university nov 
corbett dwyer hatcliff pasareanu robby laubach zheng :10.1.1.29.3872
bandera extracting finite state models java source code 
proc 
nd international conference software engineering icse june 
cormen leiserson rivest 
algorithms 
mit press cambridge ma 
iosif 
deadlock detection tool concurrent java programs 
software practice experience july 
detlefs leino nelson saxe :10.1.1.152.4499
extended static checking 
research report compaq systems research center 
gamma helm johnson vlissides 
design patterns elements od reusable object oriented software 
addison wesley professional computing series 
addison wesley publishing new york ny 
godefroid 
model checking programming languages verisoft 
proc 
th annual acm symposium principles programming languages popl pages paris france jan 
goodenough gerhart 
theory test data selection 
ieee transactions software engineering june 
holzmann 
model checker spin 
ieee transactions software engineering may 


improving software tests specifications 
proc 
th international conference users formal specification notation 
jackson schechter 
alcoa alloy constraint analyzer 
proc 
nd international conference software engineering icse limerick ireland june 
jackson sridharan 
mechanism 
proc 
th acm sigsoft symposium foundations software engineering fse vienna austria sept 
jackson 
finding bugs constraint solver 
proc 
international symposium software testing analysis issta portland aug 
klarlund schwartzbach :10.1.1.46.1556
graph types 
proc 
th annual acm symposium principles programming languages popl jan 
lam rinard 
role analysis 
proc 
th annual acm symposium principles programming languages popl portland jan 
leavens baker ruby 
preliminary design jml behavioral interface specification language java 
technical report tr department computer science iowa state university june 
revision aug 
lev ami sagiv 
tvla system implementing static analyses 
proc 
static analysis symposium santa barbara ca june 
liskov 
program development java abstraction specification object oriented design 
addison wesley 
marinov khurshid 
testera novel framework automated testing java programs 
proc 
th ieee international conference automated software engineering ase san diego ca nov 
mcmillan 
symbolic model checking 
kluwer academic publishers 
moeller schwartzbach 
pointer assertion logic engine 
proc 
sigplan conference programming languages design implementation snowbird ut june 
offutt 
generating tests uml specifications 
proc 
second international conference unified modeling language oct 
rumbaugh jacobson booch 
unified modeling language manual 
addison wesley object technology series 
sagiv reps wilhelm 
solving shape analysis problems languages destructive updating 
acm trans 
prog 
lang 
syst january 
sankar hayes 
specifying testing software components adl 
technical report tr sun microsystems laboratories mountain view ca apr 
:10.1.1.46.1556
generating effective symmetry breaking predicates search problems 
proc 
workshop theory applications satisfiability testing june 
sloane borwein :10.1.1.46.1556
encyclopedia integer sequences 
siam review www research att 
com sequences html 
spivey 
notation manual 
prentice hall second edition 
visser havelund brat park :10.1.1.32.5769
model checking programs 
proc 
th ieee international conference automated software engineering ase grenoble france 
