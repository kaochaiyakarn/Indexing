functional programming january cambridge university press higher order functional languages intensional logic rondogiannis department computer science university ioannina box gr ioannina greece mail cs gr wadge department computer science university victoria box victoria bc canada mail lucy uvic ca demonstrate broad class higher order functional programs transformed semantically equivalent multidimensional intensional programs contain nullary variable definitions 
proposed algorithm systematically eliminates user defined functions source program appropriately introducing context manipulation intensional operators 
transformation takes place steps order initial functional program 
step order program reduced final outcome algorithm dimensional intensional program order zero 
resulting intensional code executed purely tagged dataflow way proposed approach offers promising new technique implementation higher order functional languages 
successor rondogiannis wadge formally established correctness transformation algorithm order functional programs intensional programs nullary variables :10.1.1.129.6293
extend investigation broad class higher order functional programs 
particular define algorithm gradually transforms higher order program semantically equivalent intensional program nullary variables 
discussed rondogiannis wadge exists close relationship intensional languages tagged dataflow model computation notion context tag world plays crucial role cases :10.1.1.129.6293
fact tagged dataflow machines provide ideal hardware platform executing intensional languages 
immediate practical outcome rondogiannis wadge algorithm developed technique implementing higher order functional languages purely dataflow way 
noted proposed technique implemented efficiently conventional architectures interesting alternative known graph reduction techniques implementing functional languages 
organized follows section outlines transformation algorithm order programs 
material section brief presentation ideas rondogiannis wadge order self contained :10.1.1.129.6293
complete formal description order case interested reader consult rondogiannis wadge :10.1.1.129.6293
section presents intuitive transformation algorithm higher order programs 
section introduces mathematical notation 
simple higher order functional language fl focus investigation section classical denotational semantics 
higher order intensional language il final zero order intensional language developed section synchronic denotational semantics 
transformation fl derived section correctness transformation demonstrated section 
concludes discussion significance proposed technique implementation issues related directions area intensional transformations functional programs 
assumes basic familiarity intensional programming 
interested reader consult sections rondogiannis wadge quick area :10.1.1.129.6293
order case considering higher order programs outline approach adopt order case initially developed formalized rondogiannis wadge :10.1.1.129.6293
algorithm transforms order program set zero order definitions contain context manipulation operations 
semantics resulting code montague intensional logic thomason resulting definitions referred intensional definitions 
transformation algorithm outlined follows see rondogiannis wadge detailed formal exposition :10.1.1.129.6293
function defined source functional program 
number textual occurrences calls program starting including calls body definition 

replace ith call program 
remove formal parameters definition defined ordinary individual variable 

introduce new definition formal parameter right hand side definition operator actuals applied list actual higher order functional languages intensional logic parameters corresponding formal parameter question listed order calls numbered 
illustrate algorithm consider simple order functional program result translation algorithm produces intensional program result call call call actuals actuals execution model established defining actuals terms operations finite lists natural numbers referred tags contexts 
execution program starts demanding value variable result intensional program empty tag 
operator corresponds operation prefixing tag hand actuals corresponds head tag select ith argument 
formally intensions letting denote consing operation lists semantic equations introduced actuals ai semantic rules intensional program obtained interpreted follows notice different fonts representing elements metalanguage 
functions sets elements object language 
programs expressions 
exact typographic conventions adopt section 
rondogiannis wadge eval call call eval call eval call eval eval eval call eval call eval eval eval eval eval actuals eval actuals eval eval eval eval eval eval eval eval eval actuals eval actuals eval eval technique just described extensively implementations lucid functional dataflow language wadge ashcroft functional languages systems du wadge du wadge 
slight modification technique easier treatment higher order functions 
example consider definition actuals translated program 
rewrite definition case actuals actuals new case operator introduced allows new family actuals operators correspond closely call operator 
semantics new operators follows case ai formalization equivalent previous additional benefit operator unary case operator 
help formulate elegant way certain properties transformation algorithm higher order programs 
higher order case basic idea generalization technique higher order programs wadge extended formalized rondogiannis rondogiannis wadge 
intuitively technique handle higher order programs higher order functional languages intensional logic 
function names passed parameters returned results 

operation symbols order 
conditions certainly impose restrictions higherorder functions 
acceptable class programs remains significant 
useful functional systems higher order functions easily implemented algorithm proposed 
conditions imposed met widely higherorder functions map foldr 
example acceptable program defines uses map result map xs map eq map xs functions obey condition rewritten preprocessing stage way condition satisfied 
notice language adopt higher order uses conventional mathematical notation arguments function call appear parenthesized list directly function name expression 
write map xs curried form map xs usual functional languages 
notation normally interpreted denoting map xs implies map returns function language permit 
second restriction important common operation symbols eq usually order 
rest section give intuitive proposed transformation technique 
main idea generalized transformation order functional program transformed order intensional program similar technique order case 
procedure repeated new program get zero order intensional program 
idea tags general program order sequence sequence length lists list corresponds different order program 
operators general manipulate new complicated tags 
transformation higherorder case consists number stages different set operators stage 
step operators actuals call ranges order case 
second step actuals call 
code results transformation executed basic principles order case 
rest section intuitive level transformation algorithm describe semantics generalized operators 
rondogiannis wadge example transformation consider simple second order program result apply dec apply apply dec function apply second order argument order 
generalized transformation stage eliminates argument apply result apply dec call apply call apply case actuals actuals dec comment notation program call apply equivalent usual notation call apply stands call apply 
see resulting program contains order user defined functions 
exception definition equation function expressions 
easily change introducing auxiliary variable result apply dec call apply call apply case actuals actuals dec notice program functions order zero order arguments 
non standard aspect new program existence certain function calls form en intensional operator calls call apply call apply actuals actuals dec 
calls receive special treatment step transformation 
perform final step transformation result zero order intensional program 
proceed main difference new dimension corresponding new operators 
notice syntactic composition operator introduced notational convenience clearer sections 
particular expression form considered equivalent notationally equivalent en corresponds usual notation functional languages fe en 
higher order functional languages intensional logic notice composition operator binds stronger function application 
result call call apply call call apply apply call dec 
case actuals call actuals call dec case actuals case actuals call case actuals call case actuals actuals actuals actuals transformation similar order case main difference treatment calls form en 
consider example call call apply notice expression actuals actuals appears final program corresponding actual parameter 
new aspect appearance operator actuals call inverse operator call existed initial call 
general inverse vice versa 
second example consider call actuals 
expression results actual parameter actuals call call inverse actuals notions formalized subsequent sections generalized case function calls form en syntactic composition number intensional operators 
informal algorithm higher order case consists repeating steps program zero order 
function current highest order 
number textual occurrences calls program starting 
remove ith call actual parameters order 
prefix call call 
remove definition formal parameters order 

formal parameter eliminated introduce definition 
operator takes arguments calls program 
specifically th argument corresponds th call program expression starting actuals particular call form en syntactic composition number intensional operators inverse taken consideration creating subexpressions details section 
source functional program order execution model final zero order program results transformation requires tags sequences lists natural numbers list corresponds different order initial program equivalently different stage transformation 
notation wm denote tag 
operators call rondogiannis wadge thought operations complicated tags 
semantics described follows tag order select corresponding list tag 
list prefixed returned tag 
hand takes tag list corresponding checks head list equal returns tail list tag 
new semantic equations regarding operators appear final zero order programs result transformation call wm wm wm wm actuals wm wm wm wm case wm wm ai wm wm notice case operator semantic equation specify happens check operator fails 
result case undefined 
test performed fails case programs generated transformation 
evaluation program starts sequence empty lists order 
execution proceeds order case difference appropriate list sequence accessed time 
final zero order programs result transformation easily executed eval function done order case 
eval function defined formally order introduce illustrate ideas formalized parts 
think eval simple interpreter works semantic equations intensional operators 
eval performs simple form substitution time needs evaluate nullary variable program specific context simply replaces variable defining expression continues evaluation 
important note eval compute value program results intermediate step transformation programs contain userdefined functions 
final programs simpler semantics operators described earlier section suffice order compute program output 
execution starts demanding value result empty tag eval result eval call call apply call call apply eval call call apply call call apply calculated computing independently adding results eval call call apply intensional operators appear intermediate steps transformation generally higher order 
semantics operators described section 
higher order functional languages intensional logic eval call call apply calculations similar nature 
show full procedure second easily shown yield value eval call call apply eval call apply eval apply eval call eval eval case actuals call actuals call dec eval actuals call dec eval actuals call dec eval call dec eval dec eval eval eval eval eval case actuals call eval actuals call eval actuals call eval call eval eval case actuals eval actuals eval eval case actuals actuals actuals actuals eval actuals actuals eval actuals actuals eval actuals eval final result calculation sum results subcomputations 
notice calculation relatively lengthy operation takes place step primitive performed efficiently 
noted easily devise certain simple intensional transformations optimizations enhance performance produced code 
rondogiannis wadge example involving recursion consider recursive second order program calculates function factorial result sq sq perform step algorithm getting result call call case actuals sq actuals sq adding variable sides definition get firstorder intensional program result call call case actuals sq actuals sq continue transformation getting zero order intensional program result call call call call call case actuals call sq actuals call sq case actuals actuals actuals actuals case actuals actuals call case actuals call output value program easily computed semantic rules intensional operators 
mathematical notation set natural numbers denoted set functions denoted result applying function argument written special cases fa 
metalanguage consistent object language uses conventional mathematical notation function application metalanguage strictly avoid currying 
composition operator analogous object language 
notational simplicity usually denote tuple zn generalization set products adopted set ai set higher order functional languages intensional logic ai ai ai perturbation function respect function defined follows definition wheres respect defined function xn bn alternative notation xn bn set 
write list set lists elements usual list operations head tail cons adopted 
infix notation cons 
rest assume familiarity basic notions domain theory denotational semantics stoy tennent gunter 
domain partial order element represented respectively 
subscript omitted obvious 
domains set continuous functions adopt certain typographic conventions outlined 
elements object language example code programs function names programs represented typewriter font 
elements meta language divided classes represent usual mathematical objects functions sets adopt italics calligraphic fonts order talk syntax object language adopt boldface font 
years significant progress enriching programming languages wide range data types 
types impose constraints constructs language combined helping way programmer avoid writing meaningless erroneous code 
section define syntax semantics types adopted purposes 
definition set styp simple types set typ types ranged respectively recursively defined follows type single ground type 
notice result component member styp ground 
described shortly languages rondogiannis wadge considered subject restriction sense functions defined type belongs styp 
hand languages considering intensional operators operators call actuals types form 
definition order simple type recursively defined follows order order max order definition denotation type respect domain recursively defined function subscript omitted follows assume existence set constant symbols various types styp 
elements assigned types type assignment function styp 
constants denoted assume existence set var variable symbols various types styp assigned types type assignment function var styp 
variables denoted particular var denote variable symbols type 
variable constant symbols type called nullary individual variables constants 
variables termed function variables 
higher order functional language fl section define syntax denotational semantics typed higherorder functional language fl 
definition syntax functional language fl recursively defined rules ei denote expressions fi denote definitions denotes program var en en var xn xi var fn notice syntax allows nullary constants case written just syntax allows nullary variables nullary variable definitions 
cases empty pair parentheses follow variable symbol omitted 
notice higher order functional languages intensional logic syntax fl restricted typing rules introduced section 
definition xn formal parameters formals ande defining expression body definition fn program 
assumptions adopted 
exactly fn defines individual variable result appear body definitions 
variable symbol defined appears formal parameter function definition exactly program 

formal parameters function definition appear body definition 

variables appear ones defined formal parameters 
set variables defined program denoted func 
typechecking rules language natural deduction rules sequents form 
asserts formed expression type identifiers constants types assigned respectively 
notice definition reflects restrictions mentioned subsection function names passed parameters returned results operation symbols order 
definition set typed expressions recursively defined follows ei en ei en definition definition xn typed xi definition fn typed fn typed definitions 
talk zero order programs order programs 
definition formalizes notions definition rondogiannis wadge fl program 
order defined order max order func domain 
semantics constant symbols fl respect specified interpretation function assigns constant type set expressions fl 
set compatible environments environments var set defined env var semantics fl defined valuation functions exp env subscripts superscripts omitted obvious context 
definition semantics expressions fl respect env recursively defined follows en en en en noted defined overloaded 
accurate definition involve different expression types 
clarity reasons avoided making notation complicated 
theorem tennent page expressions continuous monotonic 
definition semantics program fn fl defined result environment xn dn dn xn dn 
definition specify environment constructed 
theorem states upper bound chain environments thought successive approximations theorem tennent page definition 
upper bound environments uk defined follows 
var func uk 
xn dn dn uk dn uk xn dn uk uk 
higher order functional languages intensional logic lemma direct consequence theorem lemma definition 
xn uk dn uk xn dn higher order intensional languages il section define syntax intensional languages il transformation algorithm il stands intensional language nullary variable intensional language 
language il higher order intensional programs appear intermediate steps transformation belong il 
hand final zero order programs result transformation belong intensional language simpler structure il introduced independently 
difference il fl presence intensional operators 
due nature transformation intensional operators programs il appear specific way 
consider example program obtained step transformation algorithm section result call apply call apply apply dec case actuals actuals dec examine function calls program realize form en 
general function calls appear intermediate programs transformation form en possibly empty sequence syntactic representations intensional operators composed 
final zero order programs constitute output transformation simpler syntax programs appear intermediate steps algorithm 
output programs intensional operators applied function variables expressions happen intermediate programs transformation example consider expression actuals actuals final program example section 
reasons independently define syntax languages il 
definition formalizes syntax sequences syntactic representations intensional operators 
notice denotes empty sequence 
definition set sequences syntactic representations intensional operators rondogiannis wadge ranged recursively defined follows notice elements set syntactic objects sequences textual representations intensional operators sequences elements object language syntactically composed 
corresponds function composition meanings elements sequence discussed subsection 
consideration remarks definition concerning syntax intensional language il definition syntax intensional language il recursively defined rules ei denote expressions denotes body expression definition fi denote definitions denotes program var en en var case er xn xi var fn notice ordinary function calls allowed syntax equal empty sequence 
case parentheses omitted 
notions typed definitions typed programs order program identical ones introduced definitions 
assumptions definition adopted il programs 
final zero order programs result transformation belong language 
syntax defined definition syntax intensional language recursively defined rules ei denote expressions denotes body expression fi denote higher order functional languages intensional logic definitions denotes program var en case er var fn notice language similar defined rondogiannis wadge difference operators multidimensional :10.1.1.129.6293
intensional languages il synchronic semantics section define denotational semantics intensional languages il set possible worlds languages set infinite sequences lists natural numbers list 
notice order functional program contexts need sequences lists natural numbers 
semantics defined general way applicable programs matter order lost assuming contexts infinite sequences lists particular translation finite number lists 
definition set possible worlds il set list 
set possible worlds define set possible denotations type follows definition domain 
set possible denotations styp respect defined words il elements type indexed families conventional type functions conventional type functions complex domain 
defining semantics il follow approach montague giving semantics higher order intensional logic dowty 
approach differs standard techniques assigning denotational semantics functional languages refer synchronic interpretation reasons shortly 
domain 
semantics constant symbols il respect interpretation function assigns languages il constant type function rondogiannis wadge transformation process fl programs function defined terms interpretation function fl 
specifically definition 
semantics intensional operators languages il definition definition list operators call actuals case defined follows call actuals wm tail wm head wm undefined case head wm sequence define meaning composition meanings intensional operators constitute denote meaning sequence similarly write referring syntactic representation single intensional operator meaning proceed define semantics expressions il 
set expressions il 
set compatible synchronic environments defined env var synchronic semantics language il defined valuation functions exp env follows definition synchronic interpretation expressions il respect env recursively defined asfollows en en en en case en case en seen definition semantic equation application non standard involves individual sampling meanings subexpressions current context basic principle value say world value world applied value world application defined pointwise way 
think general timepoint see value time depends value time name synchronic adopted interpretation 
case semantic equation higher order functional languages intensional logic introduce semantics programs definition necessary definition function value equal introduce semantics il 
notice definitions theorems apply programs difference programs allow nullary variable definitions 
definition synchronic semantics program fn il defined result environment definition xn dn dn xn 
definition specify environment constructed 
theorem states upper bound chain environments thought successive approximations theorem definition 
upper bound environments uk defined follows 
var func uk 
xn dn dn uk dn uk xn uk uk 
proof analogous proof theorem 
lemma direct consequence theorem lemma definition 
xn dn uk dn uk xn theorem subsequent sections theorem expressions exp monotonic continuous 
monotonic continuous env rondogiannis wadge properties synchronic interpretation subsection investigate certain properties synchronic interpretation 
initially consider programs il contain operators call actuals case 
notice programs subset fl programs defined standard denotational interpretation see definition 
theorem establishes relationship standard synchronic semantics programs subset theorem il program contain operators call actuals case environments satisfy definitions standard synchronic interpretations respectively 

proof outline suffices show definition xn bf xn dn dn dn double induction outer computational induction approximations inner structural body consider programs 
programs standard denotational interpretation easily defined done rondogiannis wadge page :10.1.1.129.6293
theorem shows standard synchronic interpretations coincide case 
theorem program environments satisfy definitions standard synchronic interpretations respectively 

proof outline suffices show nullary function symbol definition 
follows directly proof procedure similar outlined theorem 
theorems suggest order show correctness transformation algorithm simply rely synchronic interpretation see theorem 
formal definition transformation algorithm purpose section formally define transformation algorithm higher order functional programs intensional programs nullary variables 
algorithm consists number steps step order input program higher order functional languages intensional logic reduced 
transformation ends zero order intensional program obtained 
specifically input algorithm order 
step algorithm order il program obtained 
steps algorithm taken place zero order program resulted 
output transformation 
suffices just describe single step algorithm procedure required transform order intensional program order 
notice procedure applies step transformation consider source fl program il program happens contain intensional operators 
step algorithm intuitively described follows order input program start considering order functions defined 
goal lower order functions eliminating order formal parameters appropriately processing time calls program 
formal removed formal parameter list new definition created added program 
definition gathers actual parameters correspond particular formal appear calls program 
gathering performed operators case actuals 
way input order program transformed order 
procedure described repeatedly formals eliminated functions program 
final result program consists set intensional nullary variable definitions 
preliminary definitions subsection provide certain preliminary definitions helpful formally defining transformation algorithm 
definition syntactic representation intensional operator 
inverse denoted actuals actuals call write easily shown composition defined order equal identity function 
definition qr 
sequence order program 
assume ordering definitions example lexicographic 
allow talk rondogiannis wadge order textual appearance function calls 
sub adopt conventions order function defined set calls function defined calls en sub order function defined cr calls listed order textual appearance function label assigns natural number labels calls way different calls receive different labels label ci min ci cj way function calls numbered order textual appearance function calls occurrences receive label appearance function defined list positions formal parameter list formals order denoted low 
list sorted ascending order 
example zeroth third argument order low 
function defined letx xn formal parameters set formal parameters order equal represented high 
example fourth arguments order high different result type function low defined 
vars 
form list variable symbols satisfies variable list appears program form 
intuitively fresh variables attached sides new definitions result execution algorithm 
definitions transformation algorithm step step form 
processing expressions start defining function processes expressions source program 
specifically elimination order arguments function calls program accomplished ep function defined ep slightly different numbering scheme informal presentation algorithm section 
schemes equally practice 
higher order functional languages intensional logic en ep ep ep en en order low ik label ep call ep ei ep eik en order ep ep ep en rule case possibly higher order variables encountered transformation 
case expression affected transformation algorithm 
second rule applies case constant symbols transformation proceeds arguments constant 
third rule case function call encountered corresponding function order 
arguments cause function order order ones removed call prefixed appropriate intensional operator 
fourth rule applies function consideration order 
case translation proceeds actual parameters function call eliminating 
eliminating highest order formals function dm process definitions removing order formal parameters 
notice time body definition processed function ep definition dm dm xn low ik xi xik ep xn er low ik xi xik ep ep er notice supplied rules case body starts case operator case body ordinary expression 
creating new definitions part transformation algorithm new definition created order formal parameter existed program formally defining function am performs exactly task need define certain auxiliary functions 
order function defined cr different function calls listed labels label label cr 
th formal parameter rondogiannis wadge ci en calls expression inv ci defined follows recall th formal parameter inv ci actuals ep ej expression am creating body new definitions 
function params params inv inv cr words function params gathers inv expressions correspond formal parameter function am creates new definition order formal parameter program formal parameter order function af returns set contains new definition formal 
formal definition am am af func high params ar form af case ar transformation translation order il program order performed function shown dm am order fl program transformation intensional program nullary variables described function step completes formal description transformation 
easily verified programs result intermediate step algorithm syntactically valid il programs final program valid 
correctness proof transformation section rigorous way correctness proof technique higher order programs 
assumption helps simplify notation subsequent presentation 
correctness proof transformation algorithm detail 
discussed previous sections pm order source higher order functional languages intensional logic functional program transformation algorithm applied 
programs result successive stages algorithm pm 
simplify notation assume functions defined pm highest order arguments xn bf function defined pm order order xn 
helps avoid notational complexities arise assumed placement formals arbitrary 
notice property preserved transformation holds pm hold pm easily checked assumption affect generality proof 
lifting assumption alter logic proof simply adds level notational complexity 
definition discussion definition function recursively defined follows wm tail wm head wm undefined qn qn words performs context switch corresponding composition meanings operators sequence 
lemma easily shown lemma defined 
consider program pm 
theorem establishes relationship meaning functions defined pm meaning functions pm 
theorem environments satisfy synchronic interpretation definitions pm pm respectively 
definition xn bf pm ifx xn exists order order order order function call en pm dl dn call dl dn ep ep el dl dn label 
rondogiannis wadge definition xn bf pm ifx xn order order dn dn dn proof proof lengthy general straightforward computational induction stages constructing 
specifically suffices show statements hold approximations uk environment words suffices show statements definition xn bf ifx xn exists order order order order function call en pm dl dn call uk dl dn ep uk ep el uk dl dn label 
definition xn bf ifx xn order order dn uk dn dn demonstrate induction fork trivially hold left hand side statement equal bottom value 
assume claim holds 
show claim 
show definition xn bf ifx xn exists order order order order function call en pm dl dn call uk dl dn ep uk ep el uk dl dn label 
definition xn bf ifx xn order order dn uk dn dn suggested reviewers steps proof underline differences appear step 
intended save reader carefully checking see exactly changed 
higher order functional languages intensional logic semantics call follows statements written definition xn bf ifx xn exists order order order order function call en pm dl dn uk call dl dn ep uk ep el uk dl dn label 
definition xn bf ifx xn order order dn uk dn dn recall xn bf pm xl xn ep bf pm 
idea get equivalent statements involve body function specifically definition replace right hand sides statements theorem replace left hand sides statements notice statements obtain brevity reasons perturbation notation notation definition theorem 
suffices show definition xn bf ifx xn exists order order order order function call en pm dl dn ep bf uk call bf xj xj ep ej uk 
definition xn bf ifx xn order order dn xj ep bf uk bf 
give proof statements 
proof second statement simpler similar way 
notice proof statements uses point induction hypothesis statement 
rondogiannis wadge prove statements consider function program satisfies requirements set statement 
proceed distinguishing cases regarding definition starts case operator 
show proof case proof similar 
proof established structural induction body function showing subexpression bf ep uk call simplicity denote sequence call structural induction basis case equal variable xj xn order 
definition form xj case ar created pm ar derived indicated function params xj 
demonstrate uk xj xj assume form zk zk ek beak tuple ek 

proof follows zi uk xj ar uk definition xj lemma ai uk semantics actuals ep ej uk definition ai function params xj ep ej uk application semantics actuals ep ej uk lemma ep ej uk ej contain zi ep ej uk monotonicity ep ej xj definition result proof 
left hand side higher order functional languages intensional logic statement want establish written ep uk ep xj uk xj xj uk definition ep uk xj variable xj order xj relation xj variable xj gets value xj case equal variable xj xn order 
remind constant intension value vary context context 
left hand side statement want establish written follows ep uk ep xj uk xj xj uk definition ep xj xj order xj xj xj variable xj gets value xj case equal nullary constant symbol proof case straightforward denotation constant intension value independent context 
case equal formal case order strictly order functions full applications pm 
recall outer induction hypothesis functions order specifies uk 
fact depend th dimension get desired result 
structural induction step 
case xj sr xj xn order 
rondogiannis wadge proof uses fact induction basis uk xj xj notice arguments xj eliminated transformation order 
proof follows ep uk ep xj sr uk xj sr xj ep ep sr uk definition ep uk xj ep uk ep sr uk variable xj order xj ep uk ep sr uk uk xj xj xj sr structural induction hypothesis monotonicity xj sr variable xj gets value xj sr case xj sr xj xn order 
xj gets value sides statement want establish 
notice xj constant intension value independent context 
proof similar structure case 
case sr 
proof case simple uses fact constant intension 
case sr sequence intensional operators function defined pm 
proof similar need consider cases order order 
completes proof theorem 
theorem environments satisfy synchronic interpretation definitions pm pm respectively 
definition xn bf pm ifx xn exists order order order order higher order functional languages intensional logic function call en pm dl dn call dl dn ep ep el dl dn label 
definition xn bf pm ifx xn order order dn dn dn proof ideas proof theorem computational induction approximations 
theorem environments satisfy synchronic interpretation definitions pm pm respectively 
definition xn bf pm ifx xn exists order order order order function call en pm dl dn call dl dn ep ep el dl dn label 
definition xn bf pm ifx xn order order dn dn dn proof direct consequence theorems 
notice second statements theorem essential proof induction step second statement uses point induction hypothesis 
theorem demonstrates programs pm pm semantically equivalent synchronic interpretation 
theorem environments satisfy synchronic interpretation definitions pm pm respectively 
pm pm 
proof rondogiannis wadge straightforward applying second statement theorem variable result programs pm pm 
remains show initial functional program pm standard denotational semantics final zero order intensional program 
thisis demonstrated theorem theorem pm order fl program pm intensional programs result successive stages transformation algorithm 
um environments satisfy definitions pm standard interpretations 
pm um proof um environments satisfy definitions programs pm synchronic interpretation 
pm um pm um theorem pm um theorem theorem theorem correctness proof concludes formal presentation transformation algorithm higher order functional programs intensional programs nullary variables 
mentioned proof just serve purpose validating correctness algorithm suggested changes performed initially proposed algorithm wadge 
notice transformation higher order programs sophisticated order case rondogiannis wadge imperative informal intuitions supported formal reasoning :10.1.1.129.6293
significance results results real practical significance provide genuine alternative conventional techniques implementing significant class higher order functional languages 
technique proven practical conventional single processor architectures see section networked coarse grain dataflow system see ashcroft higher order functional languages intensional logic describes eduction implementation multidimensional language glu 
furthermore technique conceivably enhance web tagged demand driven applications intensional html wadge 
proposed approach implement higher order programs fine grain dataflow machines practical issues discussed detail section 
results theoretical significance shed new light relationship extensional functional programming intensional logic 
intensional logics various types proven useful different areas computer science mainly artificial intelligence verification temporal logics 
shown relatively simple intensional logic give new different perspective computations involved evaluating higherorder expressions 
view results predecessor shedding light relationship iteration recursion yin yang computation 
view results generalizations known technique implementing tail recursion conventional iteration 
firstorder case understand translation technique reducing general order recursion branching time iteration 
generalization understood technique reducing restricted typed higher order recursion multidimensional branching time iteration 
results point closer connection notions higherorder multidimensional surface appear case 
multidimensionality playing increasingly important role branches computing example olap multidimensional technologies databases apparently absent functional languages 
shown effect higher order language form multidimensionality built computation model 
suggests explicit added functional languages vice versa creating enormous interaction problems 
implementation issues transformation algorithm developed generalizes firstorder programs formalized rondogiannis wadge :10.1.1.129.6293
seen previous sections algorithm transforms significant class higherorder programs multidimensional zero order intensional programs 
resulting intensional code executed conventional architectures basic principles described rondogiannis wadge section difference contexts multidimensional :10.1.1.129.6293
rondogiannis wadge saw lists natural numbers created execution coded small natural numbers wellknown hash consing technique :10.1.1.129.6293
technique applies functional program contexts required execution sequences lists natural numbers hash consing contexts sequences rondogiannis wadge natural numbers convenient handle 
structure warehouse similar difference tags multidimensional 
words structure implementation proposed technique consists interacting components execution engine implements eval function section 
list store hashing table encoding lists small natural numbers 
warehouse keeping computed results identifiers values particular contexts 
transformation algorithm proposed implemented promising efficiency results rondogiannis wadge rondogiannis rondogiannis wadge 
rondogiannis wadge technique order build compiler iswim functional language uses higher order functions way 
compiler implemented produces code output 
implementation list store closed hash table collisions resolved linear probing knuth algorithm 
words collision occurs position table examined 
warehouse implementation uses open scheme knuth pages collisions resolved chaining 
compiler special optimizations shown performance comparable known implementations graph reduction 
different implementation technique undertaken rondogiannis rondogiannis wadge 
main idea list store warehouse appropriately merged single structure 
achieved incorporating context related information traditional activation records 
new technique appears promising compared previous technique avoids certain overheads associated hashing 
pursue implementation issues 
final comment issues noted intensional approach implementing functional languages poses new set interesting problems opinion deserve investigation 
problem characterization dimensionality variables appear target intensional code 
specifically possible variable zero order program results transformation depend dimensions just 
knowledge dimensionality particular variables crucial 
example variable depend dimension constant context simply need entry warehouse indication variable depend dimension 
way space time savings ensured turn result efficient implementations 
promising approach dimensionality analysis outlined higher order functional languages intensional logic dodd applies different class multidimensional languages 
related connected research higher order removal chin darlington purpose reduce higher order functional program order 
practical outcome techniques resulting order programs executed efficient way source higher order ones 
chin darlington transformation formulated unfold fold rules takes direct approach algorithm 
differs approaches result transformation multidimensional intensional program nullary variables 
goal transform source program form executed dataflow style context manipulation goal higher order removal serve forms optimization source higherorder programs 
despite differences comparison higher order removal intensional technique beneficial reveal potential shortcomings approach 
believe comparison main criteria 
code size 
order comparison take place identify parameters play important role techniques 
example order source program important factor affects final code size case intensional approach 
believe intensional approach may advantage terms code size gathers single definition actual parameters correspond formal parameter function 

execution speed memory requirements 
harder establish comparison due different philosophy techniques higher order removal result conventional functional programs intensional approach results multidimensional zero order programs executed eduction techniques 
comparison require availability robust implementations techniques 
limitation approaches mention fact extended apply fully higher order functional language 
suggests higher order functions fundamental nature elimination functional programs may require sophisticated extensions techniques 
reducing order source program goal technique originally proposed reynolds reynolds 
order achieved data structures introduced program 
resulting code rondogiannis wadge simulates runtime behavior source program 
elegant reynolds technique serve goals technique propose 
formalized technique transforming significant class higher order functional programs zero order multidimensional intensional programs 
transformation propose practical interest order implement functional languages tagged dataflow way 
syntax functional languages considered imposes restrictions higher order functions 
specifically partially applied objects appear program function names 
consider example program result twice add twice add clearly valid program language fl call function twice actual parameter partially applied call add 
demonstrate problems face attempt apply technique developed programs 
highest order formal parameter program formal twice function 
attempt eliminate parameter usual get result result call twice twice add case actuals add notice variable appears free definition bound definition resulting program semantically equivalent initial 
transformation performed different way 
conjecture extended transformation take care variables cause problems formal parameter 
authors currently investigating techniques applying transformation general higher order programs 
interesting problem research consider target multidimensional intensional languages programming languages just transformation related ones investigate potential applications may 
approach direction reported rondogiannis case intensional logic programming languages 
believe similar potential exists area intensional functional programming 
higher order functional languages intensional logic reviewers useful comments suggestions 
particular acknowledge reviewers insightful remarks helped significantly improve quality 
ashcroft jagannathan wadge 

multidimensional programming 
oxford university press 
chin darlington 

higher order removal method 
lisp symbolic computation 
dodd 

rank analysis glu compiler 
pages orgun ashcroft 
eds intensional programming world scientific 
dowty wall peters 

montague semantics 
reidel publishing 
du wadge 

spreadsheet intensional logic 
ieee software july 
du wadge 

implementation dimensional spreadsheet 
software practice experience 


intensional higher order modal logic 
north holland 
gunter 

semantics programming languages 
mit press 
knuth 

art computer programming sorting searching 
vol 

addison wesley 



ph thesis department computer science arizona state university reynolds 

definitional interpreters higher order programming languages 
pages proceedings th acm national conference 
rondogiannis 

higher order functional languages intensional logic 
ph thesis department computer science university victoria canada 
rondogiannis wadge 

dataflow implementation technique lazy typed functional languages 
pages proceedings sixth international symposium lucid intensional programming 
rondogiannis wadge 

compiling higher order functions tagged dataflow 
pages proceedings ifip international conference parallel architectures compilation techniques 
north holland 
rondogiannis wadge 

higher order dataflow implementation stock hardware 
pages proceedings acm symposium applied computing 
acm press 
rondogiannis wadge 

order functional languages intensional logic 
journal functional programming 
rondogiannis 

cactus branching time logic programming language 
pages proceedings international joint conference qualitative quantitative practical reasoning 
lecture notes artificial intelligence vol 

springer verlag 
stoy 

denotational semantics scott strachey approach programming language theory 
mit press 
tennent 

semantics programming languages 
prentice hall 
thomason 
ed 

formal philosophy selected papers montague 
yale university press 
rondogiannis wadge wadge 

higher order lucid 
proceedings fourth international symposium lucid intensional programming 
wadge ashcroft 

lucid dataflow programming language 
academic press 
wadge brown schraefel 

intensional html 
pages proceedings fourth international workshop principles digital document processing 
lecture notes computer science lncs 
springer verlag 


intensional implementation technique functional languages 
ph thesis department computer science university warwick coventry uk 
