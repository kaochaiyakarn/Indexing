complexity flow sensitive dataflow analyses lambda robert muth saumya debray department computer science university arizona tucson az cs arizona edu attempts address question certain dataflow analysis problems solved efficiently 
focus flow sensitive analyses give simple general result shows analyses require relational attributes precision pspace hard general 
show language constructs slightly strengthened allow computation maintain limited summary happens execution path inter procedural analyses exptime hard 
discuss applications results variety analyses discussed literature 
elucidates reasons complexity results number authors improves number complexity results exposes conceptual commonalities underlying results readily apparent 
program analysis involves keeping track properties variables different program points 
general properties different variables may depend 
tracking properties may choose keep track dependencies properties different variables leading analysis information form may choose ignore dependencies leading information form 
jones muchnick refer kind analyses relational attribute analyses kind independent attribute analyses 
tradeoff methods analyses usually efficient precise relational attribute analyses 
addressing program analysis problem useful consider computational complexity obtaining pre lambda supported part national science foundation cda ccr asc 
appear th acm symposium principles programming languages january 
cise upto symbolic execution solution problem precise solution obtained efficiently polynomial time sense try find algorithm obtains solution 
hand existence efficient algorithms compute precise solutions sense sacrifice precision efficiency 
questions computational complexity various program analyses addressed number authors see section 
current state knowledge resulting works large set isolated facts complexities various analyses 
missing insights underlying reasons results 
example landi results complexity alias analysis tell single level pointers sense easy handle multi level pointers don explain exactly multi level pointers hard deal :10.1.1.53.3506
situation results pande show precise construction inter procedural def chains difficult presence single level pointers 
words single level pointers complicate analyses don insights pointers benign situations problematic 
results typically obtained reductions problems known complexity different problem choices different authors differences details reductions different analysis problems difficult see underlying conceptual commonalities different complexity arguments 
main contribution elucidate fundamental reasons certain program analyses carried efficiently polynomial time difficult 
give simple general result applicable wide variety intra inter procedural analyses 
able explain example single level pointers handled efficiently context pointer induced alias analysis def chains :10.1.1.53.3506
little conceptual notational ef determination nontrivial property hold particular program point runtime course undecidable 
standard assumption dataflow analysis literature realizable paths program mean paths subject constraint procedure calls matched correctly returns executable equivalently branch conditional executed 
assumption barth referred precision upto symbolic execution commonly sidestep problem undecidability precision program analyses typically defined respect assumption 
fort number complexity results literature fall directly corollaries result :10.1.1.53.3506
analyses able improve significantly known complexity results reported literature 
example show analyses exptime complete interprocedural pointer alias analysis presence level pointers previous best result pspace hardness interprocedural reaching definitions presence single level pointers previous best result np hardness interprocedural liveness analysis available expressions presence parameters previous best result 
process exposes conceptual commonalities underlying variety program analyses 
maintain continuity proofs results appendix 
preliminaries perspective program analysis may interested different kinds information program variables 
may want know particular variable particular program point context constant propagation may want know relationships set variables variables guaranteed different values particular program point useful reasoning pointers 
refer problem determining kind information single value problem determining kind information simultaneous value problem 
purposes focus restricted classes problems assumption standard dataflow analysis paths program analyzed executable definition suppose program initial assignment values variables xn variables cn values program point single value problem problem form execution path entry node initial variable assignment holds control reaches 
simultaneous value problem problem form execution path entry node initial variable assignment delta delta delta xk ck holds control reaches 
particular simultaneous value problems constants ck referred binary simultaneous value problems 
intuitively obvious solving simultaneous value problem require relational attribute analysis show analysis adequate single value problem situations necessary resort relational attribute analyses single value problems 
intra procedural non recursive inter procedural analyses intra procedural analysis section consider simple language base variables integer valued program consists single procedure containing labelled statements assignments conditionals unconditional jumps primary interest dataflow analyses standard assumption paths program executable branch conditional may executed runtime omit actual expression tested conditional representing 
keep discussion simple focused restrict attention expressions variables constants assuming analysis able arithmetic adds independent source complexity obscure essence results prog stmt stmt var expr stmt stmti stmtn label stmt goto label stmtn expr const var const simplest analyses need keep track relationships variables theorem single value problem programs base solved polynomial time provided primitive operations analysis carried polynomial time 
consider complexity simultaneous value problems base 
context mention result central result historical interest proof appendix essentially isomorphic similar np hardness results acyclic programs number authors :10.1.1.53.3506
applications theorem include intra procedural type inference problems type variable depends types variables see 
theorem corollary give stronger results general classes programs 
theorem binary simultaneous value problem acyclic programs base np complete 
main result section simultaneous value problems programs base 
show class problems pspace complete idea arbitary polynomial space bounded turing machine construct simultaneous value problem program base determine turing machine accepts input 
suppose single tape deterministic polynomial space bounded turing machine sigma gamma ffi sigma input alphabet gamma tape alphabet choose syntax simplicity small amount code duplication straightforward express programs subset consisting assignments conditionals loops break continue statements 
blank symbol ffi theta gamma gamma theta gamma theta fl rg transition function initial state fq set final states halts inputs cells tape 
simplicity assume erases tape halting tape cyclic cell tape wraps cell serious restrictions difficult see turing machine satisfy assumptions transformed 
cyclic tape allows simulate movement tape head left respectively right rotating tape right respectively left tape cell scanned head cell simplifies simulation turing machine don keep track position tape head 
construct program pm emulates input program contains sets boolean variables 
nq jqj gamma variables represent current state intuitively qi denotes state 
tnt ns nt gamma ns gamma gamma variables represent contents tape intuitively ti denotes cell tape contains symbol 
variables temporaries copying tape contents rotate tape 
configuration state qk tape contents snt tape head scanning mth tape square described variable settings qi ae xi ti ae gamma mod nt code corresponding move state qi scanning cell containing symbol sj ffi qi sj represented mov defined follows ffi qi sj qk sm ffi qi sj qk sm qi qk qi qk qk qk goto copy left goto copy right lines code update state variable lines update contents tape cell scanned line corresponds rotation tape simulating movement tape head 
program pm emulates input shown 
initializing ti variables appropriately input program goes loop repeatedly guessing current state symbol tape head updating state tape cell rotating tape appropriately order simulate movement tape head 
wrong guess leads state multiple qi variables multiple ti variables set 
illegal state entered structure program ensures number variables set decrease means subsequent states remain illegal 
allows simultaneous value problem identify legal states pm correspond valid configurations determine accepts input 
notational convenience introduce abbreviations delta delta delta delta delta delta delta delta delta tnt delta delta delta tnt delta delta delta ns ns delta delta delta tnt ns 
intuitively true state variable corresponding final state true variables xi true contents variables ti correspond tape cells containing blank 
proofs lemmas appendix 
lemma polynomial space bounded turing machine accepts input may hold program easy show program pm generated log jmj jxj space lemma 
theorem binary simultaneous value problem programs base pspace complete 
proof sketch pspace hardness follows directly lemmas 
show simultaneous value problem pspace show problem program construct nondeterministic multi tape polynomial space bounded turing machine mp solve problem 
details appendix 
context program analysis representative simplest kind simultaneous value problem distinct properties represented equal equal language minimally interesting set control constructs 
hardness result extends directly complex analysis problems 
pspace hardness result jones muchnick relational attribute analyses result require interpreted conditionals 
words result complies standard assumption dataflow analysis paths program executable 
applicable wider variety dataflow analyses 
inter procedural analysis non recursive programs suppose extend language base procedures parameters passed value resulting language base proc 
non recursive programs language complexity simultaneous value problems change theorem inter procedural simultaneous values problems non recursive programs base proc pspace complete 
program pm emulate polynomial space bounded turing machine input int int tnt ns int delta delta delta tnt ns delta delta delta initialize ti input string initial state start emulation loop clear temps dispatch transitions current state tape symbol 

mov 
mov ns 
mov ns goto done 
final state 


mov nq 
mov nq ns 
mov nq ns copy tape left right copy right ns ns ns 
tnt tnt ns goto start copy left tnt tnt ns tnt tnt gamma tnt ns tnt gamma ns 
ns goto start done program pm emulate turing machine input applications complexity dataflow analyses section discusses applications results previous section various program analyses discussed literature 
intra procedural pointer alias analysis add single level pointers base language yielding language base ptr 
language contains classes variables base variables range integers pointers base variables range addresses assumed disjoint set integers 
new operations language compared base address base variable denoted dereferencing pointer denoted hard see simultaneous value problem case pspace construct polynomial space bounded turing machine solve problem manner similar proof theorem 
contrast language base single value problem complexity single value problem base ptr depends concerned base variables pointers 
single value problem base variable independent attribute analysis sufficient 
illustrated program fragment suppose interested single value problem may hold immediately assignment attribute analysis infer immediately conditional point assignment value may may 
relational attribute analysis hand able infer value indirect assignment 
words precise analysis need relational attributes ability solve simultaneous value problems 
theorem single value problem pointer variables base ptr solved polynomial time 
single value problem base variables base ptr pspace complete 
key idea pspace hardness proof show pointers reduce simultaneous value problem base single value problem base ptr 
program base generate program base ptr variable corresponds pair pointer variables 
contains pair global variables zero initialized respectively value simulated pointer value zero value simulated 
variable variable specifies value specifies recall variable program base take values 
simultaneous value problem delta delta delta xn cn generate additional series indirect assignments xi appended xi ci xi ci 
original simultaneous value problem true indirect assignments write variable zero 
checking single value problem satisfied solve original simultaneous value problem details proof appendix 
example application result immediate corollary precise intra procedural constant propagation base ptr pspace complete 
consider multi level pointers 
simplest case involving multi level pointers level pointers pointers pointers 
case classes variables base variables pointers base variables pointers pointers pointers pointers pointers base variables pointers 
call language base ptr 
role pointers respect pointers language base ptr exactly analogous pointers base variables language base ptr 
particular determine possible aliases pointers need determine values assigned pointers 
direct analogy theorem result theorem single value problem pointers base ptr solvable polynomial time 
single value problem pointers base ptr pspace complete 
landi dissertation shows intra procedural pointer alias analysis pspace complete levels indirection permitted proof adapted require levels indirection 
landi difficulty pointer alias analysis caused multiple levels indirection 
obviously valid get heart matter fundamental difference single level multilevel pointers causes analysis multi level pointers difficult 
answer shown alias analysis presence level indirection carried independent attribute analysis presence levels indirection requires relational attribute analysis 
similar line reasoning derive result chatterjee intra procedural concrete type inference java programs single level types exceptions subtyping dynamic dispatch pspace hard 
intra procedural reaching definitions pointers consider problem computing intra procedural reach ing definitions language base ptr pres ence single level pointers 
example illustrates independent attribute analysis precise solution problem analysis necessary int 
want know definition labelled reach program point labelled analysis infer point conditional assignment kill definition similar reasoning apply indirect assignment 
analysis conclude definition reach relational attribute analysis contrast determine point assignments definitely kill definition definition reach independent attribute analysis precise relational attribute analysis necessary 
theorem discusses complexity precise analyses proof uses reduction similar theorem 
theorem determination precise solutions intra procedural analysis problems base variables programs base ptr pspace complete reaching definitions live variables available expressions 
theorem improves result due pande landi ryder show problem computing interprocedural def chains presence single level pointers np hard 
inter procedural analysis recursive programs study complexity inter procedural analyses presence recursion add limited enhancement control flow constructs language base proc base language procedures 
program distinguished global variable noerr value initially 
add statement error zero gamma behaves follows error zero executed noerr set value modified 
general programming context construct determine example system calls malloc executed errors execution context limited way similar goal determine goes wrong execution path 
refer language obtained adding facility base proc base proc err 
show single value problem arbitrary programs base proc err complete deterministic exponential time 
proof relies result chandra show exptime class languages accepted bounded alternating turing machines exptime dtime deterministic exponential time 
definition single tape alternating turing machine tuple sigma gamma ffi finite set states sigma input alphabet gamma tape alphabet ffi theta gamma theta gamma theta fl rg transition function initial state reject labelling function states general formulation alternating turing machines states labelled negating states labelled 
adds power theorem chandra simplicity restrict alternating turing machines negating states 
simplify discussion follows additionally assume state existential universal exactly successor states tape symbol hard see atm transformed satisfy restriction state single successor tape symbol add second successor accepting state universal rejecting state existential successors tape symbol binary tree transitions 
assume tape wraps cell scanned cell 
configuration atm form qx state tape contents 
notion acceptance alternating turing machines generalization ordinary nondeterministic turing machines main difference successor universal state required lead acceptance 
define formally notion computation trees due ladner 
computation tree atm finite nonempty labelled tree properties node tree labelled configuration internal node tree label qu existential state exactly child labelled qu internal node tree label qu universal state successors qu qu children labelled 
accepting computation tree leaf nodes accepting configurations form qu accepting state 
atm start state accepts input accepting computation tree root labelled 
sigma gamma ffi space bounded atm polynomial input nt jxj gamma ns gamma gamma 
generate program pm base proc err simulates behavior input function fq state function tuple parameters 
tnt ns represents contents tape way conceptually similar construction described section main difference variable locals globals 
state transitions simulated function calls pm moves successors existential state simulated construct moves successors universal state simulated sequence function calls 
crucial point construction error zero gamma construct keep track goes wrong execution path sets global variable noerr initialized execution starts execution path execution path correspond computation pm guesses incorrectly tape cell scanned ii path encounters rejecting state noerr set structure program ensures reset 
execution path value noerr determine path corresponds valid accepting computation code necessary simulate actions transition state qi state qk scanning tape cell containing symbol sj represented transition qi sj qk defined follows ffi qi sj qk sm ffi qi sj qk sm 
tnt ns ns tnt ns ns error zero error zero copy left copy right fqk tnt ns fqk tnt ns lines code assign ti restore contents tape fourth line uses error zero verify symbol scanned tape cell lines update tape 
tape rotated simulate movement tape head copy left copy right corresponding code fragments labelled copy left copy right respectively 
function call simulate computation state control transferred 
corresponding state function fq pm defined follows 
qi accepting state 
function defined tnt ns 
qi rejecting state 
function defined tnt ns error zero 
qi universal state 
successors qi sj qj qj recall assumption qi exactly successors tape symbol function defined tnt ns local ns tnt ns moves sj transition qi sj transition qi sj moves sk transition qi sk transition qi sk 
qi existential state 
successors qi symbol sj qj qj function isdefined tnt ns local ns tnt ns moves sj transition qi sj transition qi sj moves sk transition qi sk transition qi sk entry point program pm function main defined main start local tnt ns init tape initialize ti fq tnt ns dynamic analog call multi graph pm valid call tree finite tree vertex labelled procedure name tuple arguments 
vertex tree children fk uk execution path pm starting call value noerr executes procedure calls fk uk body returns value noerr conditions value noerr ensure gone wrong corresponding execution path 
results establish connection behaviors alternating turing machine program pm ti ss denotes values tuple variables tnt ns pm correctly reflect tape contents proofs appendix 
theorem pm valid call tree root fq ti accepting computation tree root qu ti ss straightforward show accepts pm execution path noerr 
easy show pm generated log jmj log jxj space 
result immediate corollary inter procedural single value problem base proc err exptime hard 
interesting instructive compare result theorem 
intra procedural case considered theorem ordinary assignments program variables keep track execution path program corresponds valid accepting computation turing machine simulated 
don know technique works case interprocedural analysis recursive programs specifically simulating alternating turing machine handling universal states problematic 
language mechanism error zero gamma construct allows accumulate highly constrained summary execution path variable 
allows determine value variable went wrong point execution path 
notice corollary gives complexity result single value problems base proc err availability error zero gamma construct fact allows incrementally accumulate limited way values number variables execution path 
fact intra procedural single value problem base solvable polynomial time adding error zero gamma construct pspace hard simplify proof pointer case theorem 
applications complexity inter procedural dataflow analysis inter procedural pointer alias analyses theorem gives complexity single value problems arbitrary programs base proc ptr 
proof appendix relies indirect assignment pointer set global variable goes wrong execution path simulate error zero gamma construct 
theorem inter procedural single value problem base variables base proc ptr 
corollary complexity precise inter procedural pointer alias analysis presence level pointers exptime complete 
corollary determination precise solutions inter procedural analysis problems base variables base proc ptr exptime complete reaching definitions live variables available expressions 
inter procedural analysis procedures formals consider extending language base di allowing explicit pointers section allow non recursive functions mal parameters 
come surprise independent attribute analysis inadequate solving value problem case 
see consider program var integer main 
proc ref integer integer want know hold immediately conditional main 
need analysis arguments order determine argument second argument value 
analysis inadequate single value problem 
results proofs appendix theorem single value problem base extended procedures parameters pspacecomplete non recursive programs arbitrary programs 
corollary precise inter procedural liveness analysis available expressions analysis base extended procedures parameters pspacecomplete non recursive programs arbitrary programs 
result corrects minor flaw myers original proof difficulty analysis problems 
myers considered inter procedural analyses presence parameters claimed show np completeness liveness analysis np completeness available expressions fact proved hardness results 
results establish membership np holds acyclic non recursive programs theorem stronger results general programs 
inter procedural control flow analysis programs function pointers section consider extending base direction adding style function pointers 
differ general purpose pointers objects pointed functions data ii object obtained dereferencing function pointer modified program 
primary purpose function pointers affect control flow 
corresponding analysis problem control flow analysis problem 
result proof follows lines theorem corollary improves np hardness result zhang ryder theorem precise control flow analysis presence function pointers pspace complete non recursive programs exptime complete arbitrary programs 
summary related contributions summarized follows 
new results best knowledge new results corollary theorem corollary corollary 
improvements existing results theorem corollary improve result pande 
corollary improves result landi :10.1.1.53.3506
theorem corollary improve result myers 

explanations existing results theorems explain underlying reasons landi complexity results pointer alias analysis :10.1.1.53.3506
theorems explain single level pointers hard deal constructing intraprocedural def chains considering intra procedural pointer analyses 
theorem explains difficulty inter procedural control flow analysis presence function pointers 
distinction independent attribute analyses relational attribute analyses defined jones muchnick examined complexity approaches program analysis 
showed independent attribute analyses fixed finite domain worst case complexity polynomial size program relational attribute analysis programs consisting assignments sequencing uninterpreted conditionals assume branch conditional may taken equivalently paths program executable containing loops np hard 
variations basic idea proof np hardness results number authors proof theorem 
jones muchnick show loops interpreted conditionals added problem pspace hard 
unfortunately dataflow analyses practice treat conditionals uninterpreted result directly applicable 
nielson nielson consider general denotational setting number iterations necessary compute fixpoint functional finite lattice various assumptions kinds functions considered aimed finding cost particular formulations dataflow analysis problems 
contrast focuses inherent computational complexity certain kinds program analyses 
number iterations needed attain fixpoint important factor determining amount done analysis factor give complete picture complexity analysis 
see observe restrict attention intra procedural analyses loop free programs resulting dataflow equations recursive single iteration suffices compute fixpoint relational attribute analyses programs np complete theorem 
researchers complexity results specific program analysis problems see example 
exceptions results generally provide insights underlying reasons efficiency lack thereof analyses 
attempts elucidate fundamental reasons precise solutions certain program analyses computationally difficult obtain 
give simple general results relate complexity problem requires relational attribute analysis 
applicability result illustrated number analyses discussed literature able derive complexity results originally authors cases stronger complexity results direct corollaries results little conceptual notational effort 
discussions william landi helpful clarifying complexity questions pointer alias analysis 
barth practical interprocedural data flow analysis algorithm communications acm vol 
pp 

chandra kozen stockmeyer alternation acm vol 
jan pp 

chatterjee ryder landi complexity concrete type inference presence exceptions proc 
european symposium programming 
garey johnson computers intractability guide theory npcompleteness freeman new york 
jones muchnick complexity flow analysis inductive assertion synthesis language due dijkstra muchnick jones eds program flow analysis theory applications chapter pp 

prentice hall 
ladner lipton stockmeyer alternating pushdown automata proc 
th ieee symposium foundations computer science oct pp 

landi interprocedural aliasing presence pointers ph dissertation rutgers university new brunswick nj jan 
landi undecidability static analysis acm letters programming languages systems vol :10.1.1.53.3506
dec pp 

landi personal communication june 
landi ryder pointer induced aliasing problem classification proc 
th acm symposium principles programming languages jan pp 

larus restructuring symbolic programs concurrent execution multiprocessors ph dissertation university california berkeley 
myers precise inter procedural data flow algorithm proc 
th acm symposium principles programming languages jan pp 

nielson nielson bounded fixed point iteration proc 
nineteenth acm symposium principles programming languages jan pp 

pande landi ryder interprocedural def associations systems single level pointers ieee transactions software engineering vol 
may pp 

pande ryder static type determination proc 
sixth usenix technical conference april pp 

reps program analysis graph reachability information software technology nov dec pp 

reps undecidability context sensitive analysis technical report tr computer sciences department university wisconsin madison march 
zhang ryder complexity single level function pointer aliasing analysis technical report lcsr tr laboratory computer science research rutgers university october 
appendix proofs theorems theorem single value problem programs base solved polynomial time provided primitive operations analysis carried polynomial time 
proof straightforward independent attribute analysis suffices case 
jones muchnick section show carried time quadratic size program provided primitive operations analysis checking domain elements equal necessary determine fixpoint reached carried time 
requirement constant time operations relaxed allow polynomial time primitive operations preserve polynomial time complexity 
theorem simultaneous values problem acyclic programs base np complete 
proof proof np hardness reduction sat problem problem determining set clauses containing literals satisfiable 
problem known np complete 
formula delta delta delta delta delta delta um delta delta delta um set variables xng literals uij variable negation generate program variables fx 
nt 
nf 
cmg form nt nf nt nf cm wm cm wm cm wm wij defined follows literal uij variable xk wij kt literal uij negated variable xk wij kf 
intuitively represents assignment truth value true xi represents truth value false 
path group conditionals represents truth assignment variables 
second group conditionals represents evaluation clauses ith clause evaluates true path ith conditional second group assigns variable ci 
simultaneous value problem pose program point labelled cm 
true path statements assigns ci truth assignment variables causes clauses evaluate true 
see simultaneous value problem np acyclic program base simply guess path program check assignments path problem true 
lemma polynomial space bounded turing machine accepts input may hold point pm labelled proof sketch configuration ff correspond state bff pm written ff bff holds ff state qk scanning tape cell tape contents snt bff pm values variables control point labelled dispatch qi ae xi ti ae gamma mod nt notation go configuration ff configuration fi sequence transitions write ff lambda fi path program pm transforms state state control point labelled dispatch case write lambda show configurations ff fi states bff bfi pm ff bff fi bfi ff lambda fi bff lambda bfi 
pictorially ba ba proof induction length transition sequence base case trivial 
inductive case suppose claim holds transition sequences length consider configurations ff fi fl states bff bfl pm ff bff fl bfl ff nm fl fi 
induction hypothesis bff lambda bfl 
suppose transition fl fi goes state qa scanning tape symbol state qb 
pm consider state resulting bfl path point labelled dispatch referred mov examination definition code corresponding mov shows resulting state bfi pm corresponds configuration fi st transition 
claim follows 
definition pm initial configuration corresponds state pm control reaches dispatch follows accepts input halts reaches configuration state tape erased recall final state assumed erase tape prior halting path pm leads corresponding state described 
means holds point 
conversely path pm holds point labelled sequence mov code executed path reconstruct sequence moves leading acceptance 
establishes accepts input path pm consisting guesses holds point 
consider path pm correspond valid computation come bad guess pm state variables qi tape symbol variables tj resulting execution code fragment mov seen definition mov variable setting results control returns point dispatch variables qi set variables ti set 
variable setting called illegal represent valid configuration 
furthermore obtain illegal variable setting turn back legal mov code segments preserves increases number variables set 
means hold path pm follows hold point labelled accepts lemma polynomial space bounded turing machine input program pm illustrated generated space log jmj jxj 
proof suppose turing machine input length space bounded polynomial 
code corresponding program pm divided distinct independent components initialization code code emulation loop consisting code clear variables xi followed code transitions code rotating tape labelled copy right copy left cleanup computation label done 
space requirements components follows initialization step consists gamma theta jxj assignments assignment statement fixed size 
generate code need counter size log gamma theta jxj log gamma log jxj bits 
gamma jmj log log polynomial component requires log jmj log jxj space 
emulation loop clearing temporary variables requires log gamma bits 
outer statement emulation loop consists jqj cases case exception consists inner statement gamma cases consists fixed amount code 
space requirement generating log jqj theta gamma log jqj log gamma log jmj 
total space required component log jmj 
copy right copy left portions program consists gamma gamma theta jxj gamma theta jxj assignments assignment statement fixed size 
cleanup code label done consists gamma theta jxj assignments assignment statement fixed size 
generate assignments need counter size log gamma theta jxj log gamma log jxj bits 
gamma jmj log log polynomial component requires log jmj log jxj space 
total space required log jxj log jmj 
log jxj log jmj jxj log jmj log jmj jxj log jxj log jmj log jmj jxj 
lemma follows 
theorem simultaneous value problem programs base pspace complete 
proof sketch pspace hardness follows directly lemmas 
show simultaneous value problem pspace show problem program construct nondeterministic multi tape polynomial space bounded turing machine mp solve problem 
program input mp consists control flow graph gp initial assignment values variables target program point nt target environment variables fx 

xn 
cng specifies simultaneous value problem xn cn 
want halt iff path initial node gp nt transforms target environment mp copies gp tapes maintains tape tenv contains list variable value pairs program variable 
tenv initialized initial assignment mp starts simulating execution traversing gp vertex control flow graph simulates effects assignments updates tenv appropriately 
branch nodes mp nondeterministically chooses successor continue processing 
mp reaches target node nt checks variable values tenv match desired environment halts case 
clear execution path starting initial variable assignment execution reach point nt desired values variables guess path eventually halt accept input 
conversely mp halts accepts path 
space needs mp bounded space required store gp space required tape tenv space required gp size input program 
assumption fixed number constants deal analysis carried fixed finite domain need bits value variable program point variables space requirements tenv 
follows polynomial space bounded 
theorem class inter procedural simultaneous values problems non recursive programs base proc pspace complete 
proof pspace hardness follows theorem 
see problem remains pspace consider nonrecursive program containing procedures 
runtime call stack program depth nondeterministic turing machine similar show membership pspace proof theorem uses tape times longer 
tape stack procedure call pushes frame copying values arguments current frame tape return procedure pops current frame erasing appropriate tape cells moves frame 
space requirement machine polynomial length input follows analysis pspace 
theorem single value problem pointer variables base ptr solved polynomial time 
single value problem base variables base ptr pspace complete 
proof single value problem pointer variable analysis need concern assignments pointer variables straightforward analysis sufficient 
reasoning theorem shows solvable polynomial time 
prove pspace hardness base variable case show binary simultaneous value problem base reduced single value problem base variables base ptr program base idea generate program follows denote variables denote variables 
program contains variables zero initialized constants respectively 
variable variables 
assignments translated follows assignment translated pair assignments zero assignment translated zero 
assignment translated pair assignments 
intuition tells value original variable tells 
constructs conditionals control transfers remain unchanged translation 
suppose binary simultaneous value problem form delta delta delta xn cn point original program ci 
consider conjunct generated program program want test points zero 
want test points equivalently point zero variables zero base variables program things point equivalently points zero 
program point corresponds point denote points want determine execution path upto zero delta delta delta xn zero xi xi ci xi ci 
inserting code fragment point xi xi xi depending ci just described 
xn goto go pgm halt execution path leading program xi zero xi assignments xi write variable zero 
means initial assignment variable overwritten assignments zero indirect assignments variables xi xi program value point labelled code fragment 
hand execution path leading xj zero case xj means assignment xj overwrite initial assignment 
answering problem value point solve original binary simultaneous value problem program result follows theorem 
theorem pm valid call tree root fq ti accepting computation tree root qu ti ss proof show pm valid call tree tp root fq ti accepting computation tree tm root qu ti ss proceed induction height tm 
base case means accepting state 
suppose root tm labelled qu 
construction pm follows tree consisting single node fq ti ti ss valid call tree 
inductive case assume pm valid call tree root fq accepting computation tree root height ss consider accepting computation tree tm height 
root tm qu suppose ti ss possibilities 
existential state 
definition computation trees tm root single child subtree rooted child accepting computation tree height follows induction hypothesis pm valid call tree root labelled fq ss 
suppose transition occurs tape symbol si 
construction pm function fq contains execution path code defined transition si verifies tape symbol scanned si adjusts variables ti necessary correspond tape contents calls fq 
follows tree root fq ti single subtree valid call tree pm 
universal state 
means tm root children subtrees rooted children accepting computation trees subtrees height follows induction hypothesis pm valid call trees root labelled fq root labelled fq ss ss 
suppose transitions occur tape symbol si 
construction pm function fq contains execution path transition si transition si simulates transitions verifying tape symbol scanned si adjusting variables ti necessary calling appropriate function pm follows tree root fq ti subtrees valid call tree pm proof direction similar induction height valid call trees pm corollary accepts execution path pm program point labelled start labelled noerr proof observe construction pm code point labelled start sets noerr initializes variables ti input suppose accepts accepting computation tree tm rooted 
follows theorem valid call tree tp pm root fq ti ti ss means execution path pm start noerr 
suppose accept accepting computation tree tm rooted 
theorem follows valid call tree pm root fq ti ti ss follows execution path start value noerr remains 
theorem inter procedural single value problem base variables base proc ptr 
proof proof reduction inter procedural single value problem base proc err show program pm base proc err generated atm input discussed section translated program base proc ptr denote variables denote variables 
contains global variables zero initialized respectively 
additionally global variable global pointer variable particular distinguished base variable noerr corresponds global pointer variable noerr initialized value 

argument function function 
pair corresponding functions local variable local pointer variable 
assignment statements translated follows statement translates statement zero variable function calls translated follows call en translates zero ei ei ei variable conditionals translated unchanged 

statement error zero translated noerr 
single value problem noerr corresponds base variable single value problem 
variable translated pointer variable value corresponds pointer base variable zero value corresponds pointer variable 
consider program pm generated atm input corresponding program base ptr variable noerr initially set point value 
consider execution path contain occurrence error zero gamma statement execution corresponding path simply parallels difference values zero 
path contains statement error zero corresponding statement noerr possibilities 
noerr points points value corresponding variables noerr having value 
case assignment noerr effect value variable 
parallels behavior 
noerr points points zero corresponding having value 
case assignment sets variable value 
parallels behavior 
noerr points value due corresponding previous case earlier execution 
case regardless points zero value assignment noerr change value variable 
particular means noerr remains 
parallels behavior execution variable value corresponding execution path value noerr 
reduction described establishes inter procedural single value problem base variables base ptr exptime hard 
show program base proc ptr simulated space bounded atm mp program size 
mp tape divided regions globals locals 
globals contains current snapshot global variables 
shows globals expect return current subroutine 
auxiliary region big hold globals 
locals contains contents local variables subroutine arguments scope variables extends current subroutine parameter passing returning results achieved global variables 
regions obviously polynomially bounded size mp works follows interprets current subroutine updating globals locals appropriately 
nondeterministic uninterpreted conditionals mp guesses branches conditional continue interpreting existential states 
returns mp compares globals goes accepting state equal rejecting state 
key mechanism calls subroutine simulated 
mp copies mp guesses effect subroutine call globals writes guess 
immediately mp switches universal state 
successor state starts interpreting subroutine computation branch reach accepting state guessed correctly 
successor continues interpreting subroutine assuming call behaves expected copies globals back 
subroutine main simulation begins handled slightly differently 
main globals initialized return main mp enters accepting state 
hard see faithfully simulate interested solving single simultaneous value problem assume loss generality posed main mp test condition main go accepting state condition satisfied rejecting state 
theorem single value problem base extended procedures parameters pspacecomplete non recursive programs arbitrary programs 
proof sketch proof similar theorem primary difference explicit pointer variables parameters 
procedure program takes additional arguments global variables zero 
explicit assignments zero construction proof theorem parameters 
remainder proof remains essentially unchanged 
corollary precise inter procedural liveness analysis available expressions analysis base extended procedures parameters pspacecomplete non recursive programs arbitrary programs 
proof proof follows lines theorem modified manner analogous theorem 

