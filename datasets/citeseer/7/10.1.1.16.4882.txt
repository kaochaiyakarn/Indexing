brics rs cattani winskel presheaf models ccs languages brics basic research computer science presheaf models ccs languages gian luca cattani glynn winskel brics report series rs issn november copyright gian luca cattani glynn winskel 
brics department computer science university aarhus 
rights reserved 
reproduction part permitted educational research condition copyright notice included copy 
see back inner page list brics report series publications 
copies may obtained contacting brics department computer science university aarhus ny munkegade building dk aarhus denmark telephone telefax internet brics brics dk brics publications general accessible world wide web anonymous ftp urls www brics dk ftp ftp brics dk document subdirectory rs presheaf models ccs languages gian luca cattani computer laboratory university cambridge england luca cattani cl cam ac uk glynn winskel brics university aarhus denmark brics dk november aim harness mathematical machinery presheaves purposes process calculi 
joyal nielsen winskel proposed general definition bisimulation open maps 
show open map bisimulations range presheaf models congruences general process language ccs related languages easily encoded 
results transferred traditional models processes 
establishing congruence results presheaf models general proofs congruence properties provided awkwardness caused traditional models possessing cartesian liftings break process operations side stepped 
results applied show hereditary history preserving bisimulation congruence ccs languages added refinement operator event structures proposed van glabbeek goltz 
author supported epsrc gr calculi interactive systems theory experiment 
basic research computer science centre danish national research foundation 
contents preliminaries traditional models 
bisimulation open maps 
presheaves non deterministic processes 
left kan extensions 
fibred categories 
grothendieck construction 
general process language categorical models denotational semantics proc 
presheaf models proc grothendieck construction presheaf models 
semantic constructions groth concrete models revisited refinement event structures joyal moerdijk open maps led view bisimulation applicable models concurrency categories lines handbook chapter 
central idea define bisimulation span open maps explore consequences models concurrency ranging interleaving models transition systems independence models event structures petri nets concurrency parallelism actions expressed relation independence 
takes suggestion study presheaf models concurrent computation 
reasons doing 
reason passes barrier presheaves form intuitively appealing model nondeterministic computation 
nondeterministic computations identified presheaves path category objects path category specify possible shapes computation paths morphisms specify path extended 
presheaf category equivalent category obtained freely adjoining colimits original path category individual presheaf obtained ect identifying subpaths collection computation paths 
argued presheaf models promising generalisations existing models 
known models synchronisation trees labelled event structures embed fully faithfully appropriate presheaf categories general reasons presheaves support operations coming kan extensions 
particular kan extension resulting functor presheaves pomsets advanced candidate operation refinement kind proposed event structures 
shown kan extension acts restricted presheaves associated event structures way refinement operation event structures proposed goltz van glabbeek 
highlight gain working level common concurrency theory exploit important general result colimit preserving functor presheaf categories automatically preserves open maps :10.1.1.120.180
particular result specialises show refinement obtained kan extension preserves open maps open map bisimulation 
point approaching models concurrency categories operations fundamental process calculi appear automatically built universal constructions 
obvious question universal constructions preserve open maps bisimulation 
approach prove operations presheaves preserve open maps transfer preservation properties concrete models synchronisation trees event structures canonical embeddings results proposition 
working presheaves avoids obstructions treatment weak bisimulation independence models topic dealt 
general probably important motivation presheaf models hope give making concurrency separate study 
presheaf models trying bring concurrency theory domain theory proviso understood liberally include generalisations domain theory envisaged axiomatic domain theory 
presheaves models concurrency confined languages expressible proc 
instance treatment presheaf categories domains devised applied shows functor preserves open maps bisimulation 
contrast aim take advantage preservation properties universal constructions strategy proposed 
constructions presheaf models sophisticated languages :10.1.1.120.180
applications nondeterministic dataflow fairness weak bisimulation 
specifically builds analysis handbook chapter open map bisimulation mind axiomatise presheaf semantics general purpose process language proc treated :10.1.1.21.5791
top categorical structure needed semantics proc phrased terms fibrations require satisfaction conditions borrowed categorical logic beck chevalley condition frobenius reciprocity law 
conditions important proving general congruence results bisimulation expected 
analysis constructions involved semantics proc corresponding preservation properties open map bisimulation form core 
application general congruence results show hereditary history preserving bisimulation congruence proc conclude proving refinement event structures proposed preserves hereditary history preserving bisimulation 
organised follows 
section recall basic definitions results concurrency category theory need order reasonably self contained 
section introduces language proc discusses appropriate notion categorical model 
section defines presheaf models proc section relevant semantic constructions discussed proved preserve bisimulation 
section applications hereditary history preserving bisimulation event structures discussed 
earlier extended appeared :10.1.1.120.180
preliminaries section recalls fundamental models concurrent computation provides categorical background 
traditional models focus traditional models concurrency transition systems synchronisation trees event structures see background 
transition system structure tran set states initial state set labels tran transition relation 
usually transition written tran tran transition systems 
morphism pair partial function satisfy tran defined tran tran undefined 
synchronisation tree transition system transition graph form tree root initial state 
definition categories st define category objects transition systems arrows transition systems morphisms 
composition arrows defined componentwise 
define st full subcategory synchronisation trees 
transition systems synchronisation trees called interleaving models represent parallel concurrent composition nondeterministically interleaving actions processes 
contrast event structures represent class independence models petri nets concurrency represented directly form causal independence 
define labelled event structure structure con consisting set events partially ordered causal dependency relation consistency relation con non empty family finite subsets events labelling function satisfy finite con con con con con events subsets events said concurrent causally independent con 
set events said configuration downwards closed consistent finite con 
morphism event structures consists con con event structures partial function events partial function labelling sets ii configuration configuration images defined definition category event structures define es category objects event structures arrows event structures morphisms 
composition arrows defined componentwise 
definition morphism event structures abruptly see motivation 
categories st es related inclusion functor st right adjoint unfolding transition systems trees functor st es identifying synchronisation tree event structure right adjoint event structure synchronisation tree 
categories models described fibred respect labelling sets 
definition st es set labels define subcategory objects labelled morphisms identity relabelling part 
bisimulation open maps describe characterisation bisimulation open maps proposed refer detailed discussion 
need fix idea computation paths model 
instance computation path transition system labelling set reasonably taken finite sequence transitions transition system perform 
shape string labels definition finite strings regarded category set 
define partial order finite non empty strings regarded category 
convenient identify strings equivalent subcategory st consisting special synchronisation trees consisting finite single branch nonzero length 
define extension finite strings 
take account added independence structure event structures shape computation paths taken finite pomset 
definition labelled pomsets set 
category pom taken subcategory es labelling set consisting finite non empty event structures subsets events consistency relation 
words objects pom triples finite non empty set partial order function 
morphism pom injective function preserve labelling send downward closed sets downward closed sets define pom extension pom include empty pomset 
operation adjoining empty string empty pomset pom special cases lifting construction categories meet definition accounts notation definition 
obtain general definition bisimulation open maps 
roughly speaking open maps morphisms property extension computation path range matched extension domain 
definition open maps assume category models choice path category subcategory consisting path objects morphisms expressing extended 
arrow say open map morphism square commutes meaning path extended path necessarily unique morphism diagram triangles commute meaning path extended path matches objects said bisimilar span open morphisms case traditional models obtain known equivalences 
st bisimulation coincides park milner strong bisimulation event structures es pom bisimulation coincides hereditary history preserving bisimulation due refining ideas van glabbeek goltz 
easy prove preservation property 
proposition suppose products 
open maps 
open 
presheaves non deterministic processes presheaf categories central mathematical notion built 
category 
shall call path category thinking objects specifying computation path shapes morphisms path extensions 
category presheaves denoted set op category objects contravariant functors set category sets functions arrows natural transformations functors 
category free sense obtained equivalence categories freely adding possible colimits diagrams category rich structure known example topos details toposes functor categories see 
category presheaves accompanied functor yoneda embedding fully faithfully embeds category presheaves 
object presheaf contravariant hom functor object associates set arrows arrow associates function sends arrow yoneda embedding regard essentially full subcategory situation fitting needed defining open maps bisimulation lines section 
yoneda lemma see provides natural bijection 
justifies intuition presheaf op set thought specifying typical path object set computation paths shape presheaf acts morphism give function saying paths restrict paths 
turns rule unfortunate case arrows initial empty presheaf presheaf open convenient define open map bisimulation presheaves respect strict extension yoneda embedding 
definition category define category new initial object added 
define strict initial object preserving extension yoneda embedding shall see universal arrow associated characterisation presheaf category free connected colimit preserving completion definition open maps presheaves small category arrow presheaves define open simply open confusion arises open definition respect embedding considering open maps respect obtain open maps necessarily pom open maps contrast pom open maps transition systems event structures respectively 
proposition arrow presheaves category open pointwise surjective function open respect yoneda embedding model transition system labelled event structure gives rise presheaf 
category models choice path category forming subcategory canonical functor category models category presheaves functor takes object presheaf intuitively takes model presheaf path object yields set paths canonical functor takes morphism natural transformation component object earlier rooted presheaves category rooted presheaf presheaf set singleton 
note subcategory rooted presheaves isomorphic category presheaves connected colimit completion function path taken path generally functor define def objects act composition morphisms 
canonical functors synchronisation trees st presheaves event structures es pom full faithful canonical embeddings 
generally canonical functor full faithful path category dense category models see maclane remarked 
canonical embeddings dense preserve existing limits 
hand expect preserve general colimits proposition asserts colimits certain diagrams preserved shall need section 
proposition category category functor functor small category satisfying property density respect colimiting cone exists factorisation exists colim 
proposition statement replace condition saying connected chain spans mn odd odd open map bisimulation clearly preserved canonical functors full faithful reflected case synchronisation trees event structures 
proposition joyal nielsen winskel synchronisation trees labelling set bisimilar strong bisimilar corresponding presheaves canonical embedding related span open maps 
ii event structures labelling set pom bisimilar equivalently hereditary history preserving bisimilar corresponding presheaves canonical embedding related span pom open maps 
having established link categories models categories presheaves appropriate path categories look general constructions presheaves useful modelling processes preserve openness bisimulation 
left kan extensions constructions 
introduce powerful operation mention simple property straightforward verify canonical embeddings st synchronisation trees esl event structures shall need section 
proposition canonical embeddings st es preserve coproducts initial objects 
left kan extensions introduce notion left kan extension construction extensively 
definition left kan extensions functors says pair left kan extension functor hf natural transformation satisfying universal property pair kf exists unique 
usual abuse language call functor left kan extension write lan indicate 
note triangle need commute natural isomorphism 
happens cases interest 
proposition full faithful lan exists natural isomorphism 
cocomplete essentially small lan exists computed pointwise see colimit 
left kan extensions compose sense left kan extension left kan extension left kan extension lan lan lan category 
mentioned earlier free colimit completion detail proposition yoneda embedding satisfies universal property functor cocomplete category colimit preserving functor unique isomorphism isomorphism functor left kan extension lan 
conversely colimit preserving functor isomorphism lan 
fact lan right adjoint functor presheaf right adjoint left kan extension lan isomorphism 
key result theorem entails left kan extensions described preserve open maps powerful tool showing operations preserve bisimulation theorem colimit preserving functor open map open map 
proof theorem appears :10.1.1.120.180
shall interested colimit preserving functors similar preservation property larger class functors proved :10.1.1.120.180
theorem connected colimit preserving functor functor preserves colimits connected diagrams open map open map 
operations modelling process constructors presheaves fall class connected colimit preserving functors 
enable establish open map bisimulation presheaf models congruence general process language 
connection strict extension yoneda embedding connected colimit preserving functors 
proposition see small category :10.1.1.120.180
respect embedding category free connected colimit completion functor category connected colimits universal extension lan recall kan extensions arising important special case 
functor gives rise triple adjoint functors see described lan qf lan yq lan yq instantiating obvious embedding deduce 
proposition obvious embedding preserves connected colimits 
proof wrote lan 
straightforward calculation shows proposition connected colimit preserving 
notice defined concretely acting presheaf way 
shall great definition 
definition functor preserves initial object 
consider composite functor define def lan def lan 
proposition respect definition 

connected colimit preserving 

colimit preserving 
proof 
proposition instantiated 

left kan extensions compose def lan lan lan proposition deduce preserves connected colimits 

remarked earlier left kan extensions respect yoneda embedding correspond colimit preserving functors isomorphism 
recall proof proposition yq notice colimit preserving functors preserve left kan extensions see 
establish chain isomorphisms def lan lan yq lan def 
fibred categories indexing structure plays fundamental role categorical analysis models concurrency 
context categorical models ccs languages consider presheaf categories indexed category labelling sets 
tight correspondence indexed categories fibrations represent class fibrations definite coherent choice cleavage 
introduce section basic terminology fibred category theory pointers related notion elementary existential doctrine presheaf models section example 
detailed fibrations 
definition cartesian arrows functor 
arrow cartesian respect arrow exists unique fh definition fibrations functor fibration exists cartesian arrow codomain 
arrow called cartesian lifting respect 
definition functor arrow said vertical definition functor object define fibre respect subcategory objects arrows fibration choice cartesian arrows induces cartesian lifting functors fibres proposition cartesian lifting functors fibration 
arrow object chosen cartesian lifting respect 
choice induces cartesian lifting functors objects chosen arrows defined unique arrow square commutes choice cartesian arrows fibration called cleavage fibration chosen cleavage called fibration 
choice cleavage functorial fibration said split 
extensive dual notion cofibration definition functor cofibration dual functor op op op fibration 
functor fibration cofibration called bifibration 
dually talks cocartesian arrows cocartesian liftings cocartesian lifting functors functorial 
grothendieck construction fibrations equivalent indexed categories 
fact indexed category gives rise construction due grothendieck fibration vice versa fibration induces indexed category 
definition indexed categories category 
indexed category cat pseudo functor op cat associates object category arrow functor natural isomorphisms arrows satisfying coherence conditions commutativity diagrams oo arrow definition grothendieck construction indexed category op cat define category groth see example precise account statement 
objects pairs 
arrows pair arrow arrow arrow 
composite pair arrow coherence conditions definition ensure associativity composition 
obvious projection groth projects pair second component fibration 
cartesian lifting respect pair 
main example bifibration elementary existential doctrine sense lawvere categories attributes presheaf categories 
consider conditions fibrations usually arise context categorical logic 
definition op cat pseudo functor 
arrow write 
suppose left adjoint 
beck chevalley condition say satisfies beck chevalley condition pullback square monic square commutes natural isomorphism oo oo frobenius reciprocity law suppose binary products 
say satisfies frobenius reciprocity law square commutes natural isomorphism oo oo round section facts fibrations indexed categories need 
proposition op cat pseudo functor satisfying condition monic arrow satisfies frobenius reciprocity law monic arrow functor preserves products 
proof easy proof statement see 
second categorical folklore proved easily follows 
objects 

property frobenius reciprocity law result prove fact products proposition useful section prove parallel compositions respect bisimulation 
need lemma 
lemma op cat pseudo functor satisfying condition frobenius reciprocity law 
square pullback monomorphisms objects proof hypothesis 
frobenius proposition hypothesis hypothesis beck chevalley 
frobenius right adjoints 
proposition op cat pseudo functor satisfying beck chevalley condition frobenius reciprocity law 
diagram oo oo oo oo oo oo oo oo limiting cone object isomorphism 
proof observe limit diagram oo oo oo oo oo obtained pullbacks limiting cone constructed follows oo oo oo oo oo oo aa aa quadrilaterals diagram pullbacks 
loss generality assume 
deduce natural isomorphism beck chevalley proposition 
beck chevalley 
similarly deduces 
lemma 

beck chevalley 
proposition 
proposition fibration cofibration 
class diagram shapes class categories 
suppose object fibre limits colimits diagrams shape suppose limits colimits diagrams shape 
limits colimits diagrams shape 
proof simply give description build limiting cone diagram shape 
functor 
consider assumption exists limiting cone lim corresponding edge cone 
family cartesian arrows 
family induces functor assumption exists limiting cone functor 
cone post composing corresponding cartesian arrows obtains limiting cone morphisms transition systems synchronisation trees consist pairs component partial function labelling sets 
projecting component obtain functors set st st set es es set categories models set category sets partial functions 
proposition implicit functors set st st set 
functor es es set cofibration 
exist cartesian liftings monomorphisms 
notation sets write categorical product objects set concretely realised disjoint union sets lm lm usual cartesian product sets 
general process language categorical models introduce process language proc class ccs languages expressed 
distinctive feature proc parallel composition operator general product di erent parallel compositions constructed help restriction relabelling operations 
noted terms proc interpreted categories labelled structures labelled transition systems event structures convenient regard categories fibred labelling sets precisely category set sets partial maps 
viewed way obtain universal characterisations operators associated restriction relabelling terms cartesian liftings 
prefixing requires ad hoc treatment 
define terms language proc nil rec label subset labels total function labels labels drawn infinite set variables denote ars 
handbook chapter analysis categorical status operations involved semantics proc 
structure left somewhat implicit leads axiomatisation categories models proc 
emphasise role partial relabelling functions substitution operators impose frobenius reciprocity law beck chevalley condition section definition models proc categorical model proc functor set binary products 
set fibre initial object binary coproducts colimits chains 
inclusion sets exists cartesian lifting functor mm total function exists cocartesian lifting functor mm set label exists prefixing endofunctor re preserves colimits existing cocartesian lifting functors partial maps defined partial map defined exists square commutes coherent isomorphism re mm re mm applicable required cartesian arrows exist frobenius reciprocity law beck chevalley condition definition hold 
models considered ranging interleaving models transition systems synchronisation trees non interleaving models event structures petri nets transition systems independence 
recall briefly structure required definition give semantics terms proc derive properties models 
fact model proc described definition necessarily cofibration 
cocartesian liftings deduce corollary proof proposition corollary set model proc initial object binary coproducts colimits chains 
denotational semantics proc operation model nondeterministic sum 
operation contrasts categorical sum labelling set nondeterministic sum obtained union disjoint union labelling sets components 
definition set model proc object object define 

sets construction induces functor choice union disjoint set labelling sets lift functor mm defined action arrows 
fact possible define arbitrary arrows definition possible agree 
occurs arrows common fibre identity function 
generally define bifunctor subcategory arrows inclusion sets 
set model definition 
describe denotational semantics proc inductively structure typed terms assuming environment ars function objects nil nil initial object variables sum product restriction relabelling relabelling function 
defined prefixing re 

recursion term variable possibly free 
environment term variable determine endofunctor chain derivable nil define recx colim constructions involved denotation term colimits preserving functors colim fixed point interpretation terms proc objects involved frobenius reciprocity beck chevalley condition 
shall see section conditions come play equipping models notion bisimulation 
presence conditions matter constrain action cartesian arrows objects needed showing bisimulation congruence 
presheaf models proc saw previous section denotation term proc mainly terms universal constructions products cartesian liftings fixed points 
ad hoc treatment prefixing exception 
definition bisimulation open maps hope obtain proofs congruence respect bisimulation 
task impossible respect general definition model proc 
specialising presheaf models exploit richness constructions obtain general congruence theorem 
canonical embeddings traditional models presheaf categories preserve reflect bisimulation process algebra operations 
consequently congruence results presheaf models transferred traditional models section event structure model proc 
describing need build presheaf model proc 
require family path categories indexed sets labels 
partial relabelling functions associated functors mapping computation paths possibly empty computation paths need functors represent prefixing time derived basic functors associated lifting 
definition path structure proc path structure proc consists functor set cat category small categories sends 
functors preserve initial objects 

set element explicitly prefixing functor pre satisfying commutativity diagram obvious embeddings pre pre pm defined process labelling set denote presheaf grothendieck construction section mind sees path structure proc defines split cofibration set example 
define set cat functor associates set partial ordered set regarded category finite non empty strings elements partial map monotone map functor pointwise string string sending letter undefined empty string 
prefixing functors defined usual prefixing strings pre 

define pom set cat functor associates set category non empty pomsets labelled pom pomm functor objects possibly empty pomset defined 
arrows arrow pom simply restriction prefixing functors obvious ones prefixing pre pomset obtained adding new event labelled placed events causal order relation 
recall definition functor preserves initial object small categories derive pair adjoint functors connected colimit preserving 
grothendieck construction path structure proc derive bifibration fibres categories grothendieck construction presheaf models path structure glue fibres consisting categories presheaves form fibration set call groth objects pairs set presheaf arrows pairs 
composition arrows 
clearly projection object part functor groth set intuitively grothendieck construction various fibres adds arrows presheaves possibly di erent fibres allow possibility partial relabelling actions 
adjunctions ensure grothendieck fibration fact bifibration cocartesian lifting respect component unit adjunction fibres presheaf categories satisfy colimit completeness requirements definition 
applying proposition deduce groth binary products 
functor induces split cofibration fibres categories set extended groth property lost 
hand defined composition groth split fibration 
definition presheaf models proc presheaf model proc consists path structure definition satisfying extra condition induced bifibration groth satisfies frobenius reciprocity law beck chevalley condition 
presheaf models proc induce categorical models sense definition 
theorem presheaf model proc groth model sense definition prefixing functors defined follows re pre 
recall pre 
lan pl pre defined section 
prove theorem need lemma lemma functor obvious embeddings square commutes natural isomorphism proof observe arrows square connected colimit preserving functors 
easy calculation show isomorphic proof theorem thing need check prefixing functors satisfy condition definition 
check provided chain isomorphisms re pre 
definition re 
pre 
proposition 
pre 
definition pre 
embedding pre 
lemma re definition re 
equip model canonical notion bisimulation 
bring objects common fibre see open map bisimilar 
definition open map bisimulation groth objects groth 
say open map bisimilar related span open maps set inclusions notation remainder shall write mean open map bisimilar say open bisimilar 
definition immediately see moving objects di erent fibres cocartesian liftings preserves bisimulation 
deduce bisimulation congruence respect process operations 
proof relies mainly theorems 
observing groth exists subset inclusion function 
proposition groth 
inclusions obvious pullback square inclusions proof equality holds obviously 
bisimilarity need show assumption theorem beck chevalley condition composing square inclusions commutative know corollary groth exists subset inclusion function 
proof take equal intersection inclusion function 
definition groth say reduces subset 
subset reduced say support presheaf paths reduces presheaf paths means described bisimulation presheaf results yield characterisations bisimilarity 
proposition objects groth bisimilar reduce corollary objects groth bisimilar set support shall see operations involved semantics proc preserve bisimulation 
going semantics proc presheaf models recall instantiation proposition groth 
proposition set cat presheaf model proc monomorphism set injective total function 
facts hold pl preserves products fibres presheaves symbol indicate product objects category irrespective fact products taken di erent categories appear expression 
believe reader disambiguate context 
semantic constructions groth analyse constructions groth give semantics proc section show preserve bisimulation 
products said category groth products 
constructed cf 
proposition products fibres follows 
groth 
define projections product set proposition open map map bisimilar open map bisimilar product open map bisimilar product 
proof consider diagram oo oo oo oo oo oo obvious projecting partial functions 
observe set included upper diagram lower limiting cones vertex respectively 
proposition isomorphisms pn consequently prove assuming theorem deduce proposition note proof essential beck chevalley condition frobenius reciprocity law proposition 
sum groth 
define obvious set inclusions 
proposition functor preserves open map bisimulation open map bisimilar open map bisimilar open map bisimilar proof proof straightforward application theorem 
consider diagram inclusions oo oo oo oo oo oo assumption 

























sum construction coproduct choice labelling set sum 
shown mediating map coproduct sets 
restriction set groth 
consider inclusion map define restriction proposition functor preserves open map bisimulation open map bisimilar open map bisimilar proof consider diagram inclusions oo oo squares readily seen pullbacks beck chevalley assuming deduce theorem relabelling total 
take usual define relabelling relabelling preserves bisimulation proposition open map bisimilar open map bisimilar proof straightforward application theorem 
consider commuting diagram oo oo knowing 

obtain 







prefixing prefixing dealt functors re defined theorem 
preservation property bisimulation automatically ensured 
proposition open map bisimilar re open map bisimilar re recursion letting groth groth functor define rec colimit colim groth 
unique isomorphism presheaf consists pair ln express colimit pair colimit set colimit cocartesian liftings edges cocone observed operations groth associated term constructors functors sum sum functorial restricts groth subcategory groth morphisms pairs inclusion sets 
having groth groth define rec 
notice inclusion sets 
constructions continuous respect chains particular kinds connected diagram restrict groth rec determines fixed point derived denotation term section 
construction yields denotation recursively defined process terms colimit presheaves common path category 
deduce bisimulation recursive processes rec rec bisimulation open terms open terms give rise endofunctors groth start extending notion open map bisimulation functors 
definition say arrow groth groth open 
definition arrow groth open transpose respect adjunction pm open 
proposition open sense definition open reduces proof adjunction unit adjunction know isomorphism monomorphism cf 
proposition composite open maps open 
obvious question proposition statement 
need extra assumption presheaf model obtain converse implication 
instance lemma ii obtain proposition set cat presheaf model injective total function monomorphism set objects pm pm ip ip pm support counit adjunction pm open 
seen proposition induces converse proposition notice presheaf models example satisfy condition required proposition 
back recursion definition groth functors 
natural transformation 
say open open definition 
consider endofunctors groth bisimilar endofunctor span open natural transformations relating 
proposition category initial object 
natural transformation endofunctors induces natural transformation defined inductively proof inductively define 
def 
def second equality holds naturality 
check natural transformation need show square commutes proof goes routinely induction 
base case follows immediately initiality 
assuming see definition definition functoriality inductive hypothesis functoriality naturality definition 
deduce proposition endofunctors groth natural transformation 
natural transformation open preserve open morphisms open 
proof proposition instantiated groth proves part 
second part immediately verified inspecting definition open maps preserved passing colimit particular proposition functors natural transformation open map 
map colim colim colim uniquely determined universal property colimits open map 
proof commutative square objects colim colim colim 
colim colim colimits chains exists number arrows diagram commutes pn rn colim colim qn fn colim edges corresponding colimiting cones 
assumption open exists splitting leftmost square commutative triangles 
def arrow colim splits diagram commutative triangles 
natural transformation obviously colimits presheaf categories calculated pointwise colim 
calculation colimits chains groth reduced calculating colimiting fibre proposition yields proposition groth proposition open adjoint transpose arrow colim colim colim uniquely determined universal property colimit open map fibre colimiting labelling set 
proof remarked colimits chains groth obtained union labelling sets chain calculating colimit chain induced fibre cocartesian liftings explanation precise order show functor part colim arises situation satisfying hypothesis proposition 
need notation 
write 
simplicity assume transposes 
take naturality means square commutes indicated isomorphisms uniquely determined universal property left kan extensions kn rn jn fn writing colim calculated colimit chain rn similarly calculates colim commutativity diagram follows diagram commutes inclusion function rn ki ki jn fn unique mediating morphism colimiting cones connected natural transformation pointwise open map vertical arrow diagram isomorphism open map transformation colimit preserving functor open map open map theorem 
falls hypothesis proposition pm open 
consequently endofunctors ranging groth bisimilar preserve open maps colimits rec rec bisimilar 
term free variable built constructions section determine endofunctor groth preserves open maps section propositions 
follows open terms bisimilar induce bisimilar functors recursive definitions rec rec bisimilar 
concrete models revisited mentioned full embeddings st es pom equivalence categories 
second strict inclusion instance terminal presheaf represented event structure preserves reflects bisimulation see proposition 
consider presheaf models groth groth pom example 
transfer results presheaf models concrete models synchronisation trees event structures noting canonical embeddings fibres st es pom extend full faithful embeddings st es corresponding presheaf models 
particular embedding st groth equivalence 
illustrate situation event structures 
recalled proposition functor es es set cofibration 
provide functorial cf 
section es es set split cofibration 
con event structure partial function 
define 
con consist defined con con straightforward verify 
event structure pair truncation identity functions events event structure morphism 
proposition event structure con partial function event structures morphism cocartesian arrow 
write 
induced cocartesian lifting functor es es restrict construction pomsets obtain functor pom pom example 
easy verify choice cocartesian lifting functors functorial proposition event structure con partial function hold 
identity morphism 
partial function 
notation event structure morphism write unique function restriction elements 
way equal set defined 
call transpose notation mind define es groth pom objects con arrows es es defined composition transposition recall pomsets name fp defines functor proposition fp gfp equalities deduces gf 
proposition sees arrow fp fp acts restricted es proposition functor es groth pom dense full embedding 
proof straightforward fact extends dense full embeddings fact cocartesian liftings arrow objects groth pom di erent fibres uniquely determined arrow fibre 
known dense full embedding preserves limits 
direct calculation shows respects relabelling cocartesian liftings cartesian liftings inclusions 
proposition partial function natural isomorphism inclusion map right adjoint defined objects follows con con con con unique element 
noticed preserves coproducts proposition 
proposition know coproducts category built coproducts fibres cocartesian liftings preserves coproducts 
summarising proposition embedding es groth pom preserves limits exists es coproducts cocartesian liftings cartesian liftings inclusion 
denotational semantics proc es corresponds described abstractly section 
proposition ensure embedding semantics es correspond groth pom theorem es groth pom stand respective semantics proc 
ars es environment function es groth pom proposition ii open maps bisimulation coincide canonical embeddings es fibre groth pom 
transfer congruence property deduced presheaf semantics deduce particular hereditary history preserving bisimulation congruence language proc 
theorem hereditary history preserving bisimulation congruence language proc respect event structure semantics language proc 
refinement event structures example application theorem prove refinement operator event structures proposed preserves hereditary bisimulation abbreviated 
definition cf 
section refinement function function pomm objects pomm element sent non empty pomset definition refinement functor refinement function definition induces refinement functor pom pomm acting follows objects pomset define 
arrows pom define 
see inducing refinement functor say es event structures 
con event structure es defined pomsets con es con 
remarked functor obtained left kan extension candidate extension refinement presheaves including corresponding event structures 
functor act operation refinement es event structures 
precisely es pom esm pomm denote canonical embeddings square commutes natural isomorphism 
es es pom esm pomm embark proving 
lemma event structure es pomset es es esm refinement functor 
es exists pomset pom morphism exists morphism es es factorisation es es es exists unique mediating morphism pomsets es proof define order relation induced exist 
verification properties straightforward 
proposition pom es pomm esm inclusion functors es lan 
proof recall pom dense es es colim pom es lemma di cult verify es colim pom pomm esm 
deduce es lan 
fact es es esm functor natural transformation exists unique es 
show observe natural transformation satisfying es es 
fact es naturality equation 
es holds exists unique es satisfying es commutativity naturality squares follows universal property colimits 
need prove es diagram commutes es es es show es es es 
follows calculation es equation gf functoriality es gf equation es es functoriality es functor pom pomm extended follows poml es es lan pom pom pom pomm esm pomm want show square right commutes natural isomorphism 
show es lan lan pomm fact follow left kan extensions compose cf 
section lan pomm lan lan pomm lan es full faithful cf 
proposition lan pomm lan es es prove es lan apply proposition 
proposition natural isomorphism es lan proof proof immediate consequence proposition lemma 
fact saw proof proposition lan expressed colimit lemma ensures conditions proposition met 
theorem deduce preserves open map bisimulation 
proposition refinement function pomm associated refinement functor pom pomm preserves open map bisimulation pom open bisimilar presheaves 

pomm open bisimilar 
consequence proposition corollary refinement function pomm associated refinement functor es es esm preserves hereditary history preserving bisimulation hereditary history preserving bisimilar event structures es es es hereditary history preserving bisimilar 
proof pom open bisimilar pomm open bisimilar es pomm open bisimilar es es es due gordon plotkin suggested improvements 

hereditary history preserving bisimulation power perfect program logics 
technical report polish academy sciences 
borceux 
handbook categorical algebra volume encyclopedia mathematics applications 
cambridge university press 
cattani :10.1.1.120.180
presheaf models concurrency 
phd thesis university aarhus 
cattani fiore winskel 
theory recursive domains applications concurrency 
lics proceedings thirteenth annual ieee symposium logic computer science pages 
ieee computer society press 
cattani stark winskel 
presheaf models calculus 
proceedings th international conference category theory computer science ctcs number lecture notes computer science pages 
springer verlag 
cattani winskel :10.1.1.120.180
presheaf models concurrency 
van dalen bezem editors computer science logic 
th international workshop csl annual conference european association computer science logic 
selected papers volume lecture notes computer science pages 
springer verlag 
cattani winskel 
profunctors open maps bisimulation 
manuscript preparation 
cheng nielsen 
open maps behavioural equivalences congruences 
theoretical computer science 
fiore 
axiomatic domain theory categories partial maps 
distinguished dissertations computer science 
cambridge university press 
fiore cattani winskel 
weak bisimulation open maps extended 
lics proceedings fourteenth annual ieee symposium logic computer science pages 
ieee computer society press 
fiore plotkin power 
complete sets axiomatic domain theory 
lics proceedings twelfth annual ieee symposium logic computer science pages 
ieee computer society press 
van glabbeek goltz 
equivalence notions concurrent systems refinement actions 
mathematical foundations computer science number lecture notes computer science pages 
springer verlag 
grothendieck 
groupe volume lecture notes mathematics 
springer verlag berlin 
de du bois marie sga par alexandre grothendieck 
de deux exposes de raynaud 
hermida 
fibrations logical predicates indeterminates 
phd thesis university edinburgh 
available technical report daimi pb computer science department university aarhus 
hildebrandt 
fully presheaf semantics sccs finite delay 
proceedings th international conference category theory computer science ctcs entcs 
elsevier 
appear 
hildebrandt panangaden winskel 
relational model non deterministic dataflow 
sangiorgi de simone editors proceedings th international conference concurrency theory concur volume lecture notes computer science pages 
springer verlag 
jacobs 
categorical logic type theory 
number studies logic foundations mathematics 
north holland amsterdam 
joyal moerdijk 
completeness theorem open maps 
annals pure applied logic 
joyal nielsen winskel 
bisimulation open maps 
information computation 
lawvere 
equality hyperdoctrines comprehension schema adjoint functor 
applications categorical algebra proc 
sympos 
pure math vol 
xvii new york pages 
amer 
math 
soc 
mac lane 
categories working mathematician volume graduate texts mathematics 
springer verlag 
mac lane moerdijk 
sheaves geometry logic topos theory 
springer verlag 
nielsen winskel 
petri nets bisimulation 
theoretical computer science 
plotkin 
algebraic completeness compactness enriched setting 
invited lecture workshop logic domains programming languages 
darmstadt 
pratt 
modelling concurrency partial orders 
international journal parallel processing 

behaviour structures nets 
fundamenta informatica 
winskel 
category labelled petri nets compositional proof system 
lics proceedings third annual ieee symposium logic computer science pages 
ieee computer society press 
winskel 
presheaf semantics value passing processes extended montanari sassone editors concur proceedings th international conference concurrency theory volume lecture notes computer science pages 
springer verlag 
winskel nielsen 
models concurrency 
handbook logic computer science vol 
oxford sci 
publ pages 
oxford univ press 

lecture notes topoi 
world scientific publishing nj 
brics report series publications rs gian luca cattani glynn winskel 
presheaf models ccs languages 
november 
ii pp 
rs zolt 
preserving local edge connectivity graphs 
november 
pp 
rs flemming 
wavelet compression large volume data supporting fast random access 
october 
pp 
rs luca aceto zolt anna ing 
algebra natural numbers finite equational basis 
october 
pp 
appear theoretical computer science 
rs luca aceto francois 
model checker time 
complexity model checking timed modal logics 
october 
pp 
appears editors mathematical foundations computer science th international symposium mfcs proceedings lncs pages 
rs ulrich kohlenbach 
foundational mathematical uses higher types 
september 
pp 
rs luca aceto willem jan fokkink chris verhoef 
structural operational semantics 
september 
pp 
appear bergstra ponse smolka editors handbook process algebra 
rs riis 
complexity gap tree resolution 
september 
pp 
rs thomas hildebrandt 
fully presheaf semantics sccs finite delay 
september 
pp 
appear category theory computer science th international conference ctcs proceedings entcs 
rs olivier danvy ulrik schultz 
lambda dropping transforming recursive equations programs block structure 
september 
pp 
appear november issue theoretical computer science 
revised report supersedes earlier brics report rs 
