preserving termination tabled logic programs unfolding michael leuschel bern martens sagonas leuven department computer science celestijnenlaan heverlee belgium mail bern cs kuleuven ac 
provide investigation specialisation transformation tabled logic programs unfolding 
show surprisingly unfolding determinate worsen termination behaviour context tabling 
establish criteria ensure avoided 
briefly discuss influence transformation techniques termination efficiency tabled logic programs 
tabling logic programming emerge powerful evaluation technique allows bottom evaluation incorporated top framework combining advantages 
concept tabled execution logic programs decade see practical systems tabling appear 
early experience systems suggests practically viable 
particular xsb system slg resolution computes memory queries order magnitude faster current semi naive methods evaluates prolog queries little reduction performance compared known commercial prolog systems 
high level top tabling systems evaluate programs recording subgoals referred calls provable instances referred answers table 
predicates designated priori tabled clause resolution basic mechanism program evaluation proceeds follows 
predicates call resolved program clauses 
tabled predicates call new evaluation entered table prolog style program clause resolution compute answers recorded table 
hand variant call table resolved recorded answers 
answer tables resolving subsequent invocations call tabled tabling evaluation methods variant checks slg resolution subsumption checks 
specified assume tabling variance refer reader section discussion issues involved choice 
evaluation strategies prevent cases infinite looping normally occur prolog style sld evaluation 
result termination characteristics tabling logic programming systems substantially better prolog 
relative novelty tabling implementations promising avenues substantially improving performance tabled programs remain explored 
research topic mainly addressed issues related finding efficient data structures tabling suggesting low level modifications slg wam 
deviate path investigate issues related optimisation tabled programs portable techniques specialisation unfolding similar program transformations 
program transformation widely accepted technique systematic development correct efficient programs 
program aim program transformation produce efficient program solves problem equivalent meaning original semantics choice 
various systems program transformation developed usually fold unfold framework 
framework dates back introduced logic programming community seminal tamaki sato subject considerable research see successfully partial evaluators prolog style execution 
unfortunately methodology transformation specialisation tabled logic programs exists 
techniques stay context execution 
initially may expect results established classic ld setting carry 
turns far obviously true differences execution models significant 
mainly concentrate issues related safety unfolding tabled logic programs 
context program specialisation unfolding important ingredient 
instance partial deduction basically employs unfolding 
execution logic programs unfolding problematic 
example preserves herbrand model set computed answer substitutions semantics context unfair prolog selection rule worsen universal termination behaviour program 
tabled execution unfolding determinate may transform terminating program non terminating naturally situation better avoided 
reason unfolding tabled logic programs describe framework captures termination left right selection rule define applicability conditions ensure intended equivalence property original program transformed 
framework prove certain non trivial commonly practice types unfolding safe respect termination 
summary results regarding unfolding context tabled execution follows prove left unfolding unfolding left propagation bindings preserves termination tabled logic programs 
show left propagation bindings unfolding worsen termination characteristics tabled programs grounding substitutions safe wrt termination 
rest organised follows 
section introduce preliminaries section show example unfolding termination tabled programs 
reason preservation termination unfolding section introduce notion quasi termination tabled programs notion section prove results 
extended discussion effect commonly transformation techniques termination efficiency tabled programs 
preliminaries denote non ground extended herbrand base set atoms modulo variant equivalence relation defined 
define notations set variables occurring inside expression denoted vars domain substitution defined dom fx range defined ran fy vars define vars dom ran restriction substitution set variables fx vg 
mgu denote substitution idempotent relevant vars vars vars general unifier expressions remainder notations hd bd refer head body clause respectively 
program transformation process starting initial program sequence programs pn called transformation sequence program obtained application transformation rule may depend formally define unfolding slightly adapted 
definition 
unfolding rule contain clause positive literal possibly empty conjunctions literals 
suppose 
fd clauses program language usually inferred program queries consideration 
prevent confusion standard definition herbrand base 
stipulates allow selection atom unifies clause 
deletion clauses finitely failed body rule circumstances 
effectively allow case 
unifiable hd hd dn general unifiers 
clause bd binding vars vars called left propagated binding 
unfold wrt dn derive clauses cn get new program fcg fc cng 
exactly clause head unifiable unfolding called determinate 
left unfolding unfolds literal bd empty 
example fp rg unfold wrt deriving clause get fp rg 
note contrast treat programs sets clauses sequences clauses 
pure tabled programs order multiplicity clauses difference termination properties primarily interested preserving order clauses order solutions incidence universal wrt entire computation process termination affect existential termination discussed section 
unfolding termination context program specialisation unfolding important transformation rule 
instance partial deduction basically employs unfolding limited form implicit folding obtained lloyd shepherdson closedness condition see 
order study specialisation transformation tabled logic programs concentrate behaviour unfolding 
logic programs negation executed sld nf variants thereof unfolding totally correct modify termination behaviour program see 
context fixed unfair selection rule prolog left right rule unfolding improve termination cf 
worsen 
prolog setting take clause order depth strategy account unrestricted unfolding affect existential termination programs unfolding change order solutions 
determinate unfolding modify backtracking behaviour beneficial efficiency leading smaller sld nf trees 
unfolding problematic ordinary setting influence efficiency termination involved context tabled execution 
hand contrary prolog style execution unfolding datalog propositional programs safe wrt termination slg terminates programs 
hand soon function symbols introduced unfolding determinate ruin termination 
note left unfolding allowed instantiate head unfolding left propagation 
suppose simplicity presentation predicates tabled 
suppose predicate defined clause 
example 
program 
left right selection rule program fails finitely selected atom variant call answers produced terminates query 
program obtained unfolding atom see fig 
fig 

slg forests query unfolding example 
infinite slowdown course highly undesirable 
remainder develop criteria ensure termination preserved unfolding 
quasi termination start formalisation termination left right selection rule setting tabled execution logic programs 
definition 
call graph program call graph graph nodes elements contains directed edge denoted precisely iff exists renamed apart clause bn ffl unify mgu ffl gamma gamma denote transitive reflexive closure atom define fb bg 
subset said closed iff implies example 
program 
fp full call graph depicted fig 

oe oe oe oe fig 

call graph example define notion quasi termination tabled logic programs term borrowed defining similar notion context termination line partial evaluation functional programs 
definition 
quasi termination program subset said quasi terminating wrt iff set finite 
quasi terminating iff quasi terminating wrt program example quasi terminating wrt entire definition essence means starting evaluation produces finite number different calls 
equivalently ld tree sld tree left right selection rule ag contains finite number selected atoms modulo variable renaming 
equivalent stating slg forest left right selection rule ag contains finitely slg trees 
means non termination occur call produces infinite number computed answers 
universal termination holds iff quasi termination finitely selected atoms thorough discussion termination issues tabled execution see transformation sequence preserves set holds transformations interested preserving quasi termination equivalent preserving universal termination 
preserving quasi termination unfolding problematic example unfolding left propagated binding atom 
left propagation sequence ld resolution changed see behaviour problematic non logical built var preserved see 
prove restricted unfolding safe wrt quasi termination tabled logic programs 
theorem 
obtained sequence leftmost unfolding steps unfolding steps left propagated bindings 
quasi terminating wrt proof 
appendix explore extensions basic result left propagation bindings highly beneficial allows evaluation focus relevant data lead dramatic pruning search space see 
considerable care taken performing instantiations context tabled logic programs 
illustrated danger unfolding left propagation bindings 
note just instantiate query leave clause program example unmodified quasi termination destroyed 
hope instantiating query leaving program unmodified safe wrt quasi termination 
alas subtle reason left propagation bindings endanger termination 
termination ordinary sld nf resolution property 
definition 
termination evaluation strategy closed iff program query terminates instance 
surprisingly property carries tabled evaluation 
show termination quasi termination slg resolution closed counterexample 
example 
tabled predicate defined clause 
variant subsumption tabling query terminates 
fig 

slg forests queries 
side comment note termination tabled execution closed tabling systems forward subsumption unpredictable termination characteristics general termination queries depends chronological order encountering tabled calls 
purely practical perspective seen advantage tabling systems variance subsumption 
example adapted show left propagation bindings introduce new structure dangerous terminates program containing 
variant example shows left propagation bindings variables appear head ruin termination seen unfolding atom clause left propagation instantiation context tabled execution logic programs hopeless endeavour formally establish non trivial class substitutions safely 
definition 
substitution fl called grounding substitution iff fl ground term 
say fl structurally simpler grounding substitution oe denoted fl theta oe iff fl exists oe subterm note term considered subterm 
example 
oe fx bg grounding substitution 
oe fz bg fx ag structurally simpler oe possible disallow case refined definition required purposes 
fz fx cg structurally simpler oe 
interest relation theta context quasi termination derives proposition 
lemma 
oe grounding substitution atom 
set fa fl fl theta oeg finite variable renaming 
proof 
vars fx xng fl theta oe 
fl fl subterm oe 
finitely bindings oe finitely subterms construct finitely different atoms fl variable renaming 
prove lemma capturing interesting property grounding substitutions 
lemma enable show left propagation grounding substitutions safe wrt quasi termination 
lemma 
fl grounding substitution derivation leading rq corresponding derivation leading rq grounding substitution fl theta fl rq proof 
appendix put lemmas 
theorem 
program atom oe grounding substitution 
finite aoe proof 
lemma know aoe bfl grounding substitutions fl theta oe 
means fb fl fl theta oeg safe approximation superset aoe apply lemma deduce finite theorem 
obtained left unfolding steps unfolding steps left propagated binding grounding substitution 
quasi terminating wrt quasi terminating wrt proof sketch 
full proof obtained adapting proof theorem theorem left propagated grounding substitutions 
tricky aspect instantiating body atom clause bfl theorem tells terminating bfl terminating infer bfl terminates nc fc cng take account fl repeatedly applied derivation uses clause problem fl theta fl fl fl theta fl meaning lemma theorem holds grounding substitution repeatedly applied 
similar result hold tabling subsumption variance shown example 
example 
program quasi terminating wrt fqg subsumption checks variant checks 
unfolding clause result left propagation grounding substitution fx ag produce clause 
resulting program longer quasi terminating wrt fqg subsumption checks term depth abstraction spirit oldt resolution required ensure termination 
extensions efficiency considerations mixing tabled prolog style execution far assumed predicates tabled 
predicates tabled safely left propagate substitution un tabled predicates call tabled predicates problem similar example arise left propagation call defined 
ensure unfolding replace tabled predicate un tabled 
termination affected example shows 
example 
program tabled queries finitely fail program terminating 
determinate unfolding clause wrt program right side query non terminating 
fig 

obtained unfolding wrt 
renaming partial evaluators technique called renaming see remove redundant structure specialised program ensure independence condition avoiding abstraction allowing unlimited 
context sld nf execution additional increase code size beneficial terms size run time sld nf trees 
example shows context tabled execution appropriate care taken 
example 
program containing arbitrary definition predicate 
specialising obtain program definitions 
query call executed program clauses original program specialised program executed 
specialised program efficient original conservative safe approach apply renaming atoms independent just remove superfluous structure specialised program independence condition ensured abstraction 
similar difficulties arise performing conjunctive partial deduction tupling deforestation specialises entire conjunctions renames new atoms 
renaming conjunction new atom diminish possibility tabling possibility reusing earlier computed results 
rename conjunction pq query reuse part results computed renamed query pq reuse results computed pq 
note efficiency unfolding left propagation execution left propagation substitutions usually prunes search space beneficial efficiency query evaluation 
tabled execution program clause resolution substituted resolution answers tables retrieved recomputation left propagation grounding substitutions may worsen performance course vastly improve 
example tabled program analysers usual practice employ known general call optimisation compute analysis information general form predicate retrieve information tables appropriately filtering explicit equality constraints 
basic idea approach illustrated simple interpreters shown 
definition fact predicate tabled predicate interpreters assumes program clause gn represented fact form pc gn 
top level query fact head pc head body prove body prove prove fact prove gs fact head pc head body prove body prove prove fact prove gs fig 

meta interpreters concrete evaluation 
gers computation program non ground minimal model gets recorded tables 
table created interpreter general call optimisation shown right side 
interpreter left side number tables depends number distinct variance instantiation patterns calls fact 
overhead space associated performance cost especially complicated domains see information experimental evaluation technique variety domains 
program clause order account existing implementations tabling program clause resolution performed style similar prolog visiting clauses textual order 
consequently tabled programs quasi terminating nondeterminate unfolding left propagation worsen existential termination 
turn affect behaviour optimisations involve pruning existential negation 
illustrate problem example extends similar example 
example 
assuming scheduling strategy returns answers calls soon generated program produces answer query loops program loops producing answers 
fail fail fail fig 

obtained unfolding wrt discussion conclude brief discussion possible application optimising integrity checking updates recursive databases specialising meta interpreters 
hierarchical databases successful results achieved 
unfortunately moving recursive databases proven difficult loop check necessary termination requires ground representation sld nf execution 
imposes large initial overhead leads difficulties terms specialisation 
writing integrity checker tabled environment non ground representation techniques explored obtain effective specialised update procedures recursive databases 
note setting deductive databases left propagation grounding substitutions corresponds wellknown optimisation principle making selections occurs naturally 
michael leuschel supported belgian goa non standard applications interpretation 
bern martens post doctoral fellow leuven research council 
sagonas post doctoral fellow flemish fund scientific research fwo 
danny de schreye interesting discussions ideas comments 

hill 
supporting transformations partial evaluation logic programs 
journal logic computation october 

burstall darlington 
transformation system developing recursive programs 
journal acm 

chen warren 
tabled evaluation delaying general logic programs 
journal acm january 

codish bruynooghe garc ia de la banda hermenegildo 
exploiting goal independence analysis logic programs 
journal logic programming september 

codish sagonas 
general purpose semantic program analysis xsb 
leuven technical report cw 
december 

de schreye leuschel martens sagonas 
termination analysis tabled logic programming 
proceedings logic program synthesis transformation leuven belgium july 

falaschi levi palamidessi martelli 
declarative modeling operational behavior logic languages 
theoretical comput 
sci 

gallagher 
system specialising logic programs 
technical report tr university bristol november 

gallagher 
tutorial specialisation logic programs 
proceedings pepm acm sigplan symposium partial evaluation program manipulation pages copenhagen denmark 
acm press 

gallagher bruynooghe 
low level transformations logic programs 
bruynooghe editor proceedings meta workshop meta programming logic pages leuven belgium 

gluck jrgensen martens 
controlling conjunctive partial deduction definite logic programs 
swierstra editors proceedings international symposium programming languages implementations logics programs plilp number lncs pages aachen germany september 
springer verlag 
extended version technical report cw leuven 
accessible www cs kuleuven ac 

holst 
finiteness analysis 
hughes editor proceedings th acm conference functional programming languages computer architecture fpca number lncs pages 
springer verlag august 

leuschel de schreye 
creating specialised integrity checks partial evaluation meta interpreters 
proceedings pepm acm sigplan symposium partial evaluation semantics program manipulation pages la jolla california june 
acm press 

leuschel de schreye de waal 
conceptual embedding folding partial deduction maximal integration 
maher editor proceedings joint international conference symposium logic programming jicslp pages bonn germany september 
mit press 
extended version technical report cw leuven 
accessible www cs kuleuven ac 

leuschel martens 
partial deduction ground representation application integrity checking 
lloyd editor proceedings ilps international logic programming symposium pages portland usa december 
mit press 
extended version technical report cw leuven 
accessible www cs kuleuven ac 

leuschel schreye 
logic program specialisation specific 
swierstra editors proceedings international symposium programming languages implementations logics programs plilp number lncs pages aachen germany september 
springer verlag 
extended version technical report cw leuven 
accessible www cs kuleuven ac 

lloyd shepherdson 
partial evaluation logic programming 
journal logic programming 


transformation logic programs foundations techniques 
journal logic programming may 


partial deduction system 
technical report ecrc ecrc munich germany 


unfold rule full prolog 

lau clement editors logic program synthesis transformation 
proceedings workshops computing university manchester 
springer verlag 


semantics preserving transformation rules prolog 
proceedings acm symposium partial evaluation semantics program manipulation pepm sigplan notices vol 
pages yale university new haven 

ramakrishnan rao sagonas swift warren 
efficient tabling mechanisms logic programs 
sterling editor proceedings th international conference logic programming pages japan june 
mit press 

sagonas 
slg wam search efficient engine founded evaluation normal logic programs 
phd thesis department computer science suny stony brook august 

sagonas swift warren 
xsb efficient deductive database engine 
proceedings acm sigmod international conference management data pages minneapolis minnesota may 
acm press 


automatic partial evaluator full prolog 
new generation computing 

tamaki sato 
unfold fold transformations logic programs 
editor proceedings second international conference logic programming pages uppsala sweden 

tamaki sato 
old resolution tabulation 
shapiro editor proceedings third international conference logic programming number lncs pages london july 
springer verlag 
proof theorem theorem 
obtained sequence left unfolding steps unfolding steps left propagated bindings 
quasi terminating wrt proof 
pr transformation sequence obtain prove induction number unfolding steps intermediate program transitive closure smaller worst case equal transitive closure ensures quasi termination preserved 
obtained unfolding clause wrt dn trivially part call graph modified hand removed replaced clauses fc cng definition 
br bq gamma bq bq br possibilities 
implies applied unfolding left propagation left unfolding atoms left unfolded atom bk 
know fc cng bindings left propagated rest 
relation unfolding possibly ways establish removed arrow going removed termination improved pruning non terminating computation 

case unfolding preserves set computed answers 
precisely definition know bk gamma consider auxiliary clause aux aux bq bk gamma variables body aux 
know unfold aux wrt bq set computed answers query aux preserved selection rule left right 
means bq bk gamma computed answer similar computed answer unfolded program bk 

case way establish replaced possibly new arrows 
bk gamma consider case unfolding left propagation performed cs bd ds unfolded clause mgu bq hd ds 
cs number atoms bd ds new arrow ds take clause ds hd ds bd ds 
clause bq bd ds resultant simple derivation length bq lemma deduce computed answers instance bq resolving ds resolving induction hypothesis know transitive closure possibly new arrow transitive closure case left unfolding performed empty cs bd ds mgu bq hd ds 
note contrast unfolding left propagation head cs necessarily equal similar application lemma deduce influence apply reasoning 
new arrows added transitive closure new transitive closure smaller arrows removed equal proof lemma lemma 
atoms vars vars 
oe fx tg grounding substitution vars mgu mgu aoe 

dom oe 

dom exists substitution fl theta oe fl 
proof 
point 
vars property trivial aoe identical ran idempotence 
vars 
dom ground definition composition substitutions oe oe oe 
aoe oe oe oe oe unifier aoe general unifier exist substitution fl fl oe oe instance establish turn instance oe prove oe 
oe oe substitution unifier hoe vars aoe aoe exist substitution fl fl oe mgu 
means dom fl fl fl ground 
hoe fl established instance oe 
point 
term fl sfl oe unifier see proof point 
substitution fl fl oe oe ground sfl fl flj vars fx xn tng 
subterms strict subterms 
words fl theta oe 
prove fl 
fl definition fl find substitution fl oe ground 
fl unifier aoe aoe fl ground aoe fl fl 
fl instance mgu fl fl instance secondly mentioned fl oe vars holds oe grounding substitution ran oe vars 
hoe hoe fl fl ground turn instance fl 
lemma follows immediately definition 
lemma 
fl fl oe oe grounding substitutions dom oe dom oe 
fl theta oe fl theta oe fl fl theta oe oe lemma 
atoms vars vars 
oe grounding substitution dom oe vars mgu mgu aoe 
exists substitution fl theta oe fl 
proof 
induction number elements oe lemma lemma 
lemma follows immediately definition 
lemma 
fl theta fl fl theta fl fl theta fl prove lemma 
proof lemma 
induction length derivation lemma derivation step fact unifiers relevant head clauses renamed apart meaning fl implies body body fl implies fl fl rq lemma 
article processed macro package llncs style 
