reprinted conference record th annual acm symposium principles programming languages popl stochastic lambda calculus monads probability distributions norman ramsey avi pfeffer division engineering applied sciences harvard university probability distributions useful expressing meanings probabilistic languages support formal modeling reasoning uncertainty 
probability distributions form monad monadic definition leads simple natural semantics stochastic lambda calculus simple clean implementations common queries 
monadic implementation expectation query cient current best practices probabilistic modeling 
language measure terms denote discrete probability distributions support best known modeling techniques 
give translation stochastic lambda calculus measure terms 
translates probability monad measure terms results translations denote probability distribution 

researchers long modeled behavior agents logic logical models poor choice dealing uncertainty real world 
dealing inherent uncertainty incomplete knowledge probabilistic models better 
variety representations reasoning techniques probabilistic models 
techniques include bayesian networks pearl kinds graphical models jordan centered structuring decomposition probability distributions 
focuses scaling techniques deal large complex domains 
domains require large scale modeling techniques include medical diagnosis jaakkola jordan military intelligence mahoney laskey 
models grow large important able build easily reuse parts con permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
popl jan portland usa acm isbn 
sidered programming languages techniques build probabilistic models weak 
draw large body knowledge programming languages design language supports probabilistic modeling 
stochastic lambda calculus denotations expressions probability distributions values suitable basis language 
express semantics stochastic lambda calculus exploit monadic structure probability distributions jones plotkin 
contributions show probability monad leads simple elegant implementations queries commonly posed probabilistic models expectation sampling support 
monad intermediate form simplifies proofs desirable properties sampling function draws values model appropriate probabilities 
show monadic implementation expectation potentially cient techniques currently probabilistic reasoning 
problem arises monad exploit intensional properties functions applies functions 
support alternative implementation expectation translate stochastic lambda calculus simple language call measure terms 
algebraic manipulation measure terms express variable elimination standard technique ciently computing expectation 
measure terms denote measures translation measure terms consistent monadic definition stochastic lambda calculus 
implications design implementation probabilistic languages 
design show support cient probabilistic reasoning simply adding choose operator ordinary functional language necessary include language features expose common implementation techniques variable elimination 
implementation show standard techniques programming language implementation monadic interpreters algebraic manipulation programs including common subexpression elimination apply probabilistic languages 
probabilistic reasoners enjoy benefits higher order typed languages requiring undue ort implementors 

probabilistic models queries simplest language describe probabilistic models lambda calculus expressions denote probability distributions 
primary means creating interesting probability distributions new construct probabilistic choice 
choose represents linear combination distributions 
operationally take value combined distribution probability take value probability take value 
example model illustrate ideas simple model tra lights drivers haskell notation 
tra lights probabilistically red yellow green 
tra example light dist red yellow green dist version choose extended combine weighted distributions 
means light value red probability value yellow probability value green probability 
drivers behave di erently depending colors lights see 
cautious driver brake aggressive driver 
tra example cautious driver light case light red dist braking stopped yellow dist braking driving green driving aggressive driver light case light red dist braking stopped driving yellow dist braking driving green driving estimate drivers go single light di erent streets probability crash 
tra example crash light light driving light driving false red green green red yellow yellow 
queries having defined probabilistic model wish ask questions 
example drivers cautious aggressive approaching light probability crash 
question answered kinds queries expectation sampling support 
expectation function mean distribution 
expectation subsumes queries special cases 
mean value distribution language models queries stochastic lambda calculus probability monad measure terms expectation sampling support expectation ovals representations boxes queries implementation paths expectation identity function 
probability outcome satisfying predicate expectation function 
conditional probability computed probability 
example answer question probability crash building probability distribution crash cautious driver aggressive driver light computing probability identity predicate 
sampling means drawing value distribution 
sampling repeatedly approximate expectation get idea shape distribution function distribution 
true experimental data samples fit analytic solutions equations monte carlo techniques physical sciences rely sampling 
support tells subset entire sample space sample drawn nonzero probability 
seldom interesting implementation support easier compute expectations ciently 
support plays significant role implementation 

implementing probabilistic models presents representations useful answering queries probabilistic models probability monads measure terms 
shows translations involved 

user writes model query domainspecific probabilistic language 
take language stochastic lambda calculus defined formally section 
practice prefer richer language providing types modules explicit fixed point operator recursion equations 
practice stochastic lambda calculus useful intermediate form 

translate model restricted target form value probability monad measure term 
section gives translation probability monad semantics explain section 
section gives translation measure terms 

target form answer query 
probability monad answer kinds query measure terms designed answer expectation queries ciently 
probability monad easy implement haskell section haskell embedded domain specific language probabilistic modeling 
cient implementation measure terms di cult current implementation written objective caml order exploit mutable state pfe er 

semantics probability probability monad 
measure theory discrete continuous probability easily described measure theory borrow notation rudin 
values probability distribution defined drawn space observable events experiment typically represented subsets call subsets measurable sets require entire space measurable measurable sets closed complement countable union measurable sets form algebra 
classical definition measurable function function topological space inverse images open sets measurable 
restrict attention functions measure spaces define measurable functions inverse images measurable sets measurable way composition measurable functions measurable 
measure function maps measurable set real number range countably additive 
disjoint countable collection measurable sets 
probability distribution measure 
greek letters stand measures 
integration plays significant role probability 
real valued measurable function measurable space measure measurable subset write lebesgue integral set expression appears free write 
queries define queries terms measure theory integration 
simplest query define expectation 
probability distribution space expectation function 
support distribution measurable set outside distribution zero 
set support distribution measurable set 
language real analysis support concentrated 
support easier compute expectations exploiting 
ways formulate sampling 
define sampling function probability distribution infinite sequence values prefer define sampling directly terms measure theory 
accordingly say measurable function sampling function measurable set lebesgue measure describes uniform distributions 
formulation practical value give way sampling uniformly unit interval applying ll give way sampling probability distribution 
equation implies drawn uniformly unit interval probability probability 

probability monad long known probability distributions form monad lawvere jones plotkin 
section recapitulate previous discussing relationship monad operations probability 
monadic bind operation particular provides functionality needs create interesting probability distributions models 
section extend probability monad additional operations support queries 
category theoretic notation write return unit operation bind monadic extension 
notation familiar haskell programmers readers wadler 
denotation unit operation simplicity return stands distribution measure assigns unit probability measurable set containing zero probability measurable set containing return measure called unit mass concentrated 
enjoys property measurable function dm return 
proof appeals directly definition lebesgue integration 
property plays key role proofs monad laws probability measures 
motivate definition monadic bind appeal conditional probability 
denotes probability measure space denotes function values probability measures space may interpreted defining conditional probability denotes probability applying chain rule says joint probability equal probability times conditional probability get probability integrating wish denote probability define dm 
notation may confusing integral uses measure function integrated 
property monadic bind plays significant role proofs dm dm dm properties straightforward prove definitions return satisfy monad laws 
create interesting distributions need operation monad 
choose function argument version dist section 
probabilistic choice linear combination measures choose symbol stands multiplication 
choose su ces create distribution finite support 
creating kinds distributions including interesting continuous distributions require additional operations 
create continuous distributions limits discrete distributions finite support 
easy show induction structure monad value created return choose denotes probability measure interesting step uses property 

probability mass density functions possible directly probability measures easier functions map values probability probability density 
nonnegative lebesgue integrable function defines measure bounded measure function defined measure 
furthermore measurable theorem plays significant role proof associativity law probability monad 
better measures described function radon nikodym theorem says bounded implies absolutely continuous respect exists nonnegative integrable case write function radon nikodym derivative 
implementations probability functions justified measure derivative respect underlying measure probability discrete continuous depends underlying measure 
discrete probability countable sets measurable appropriate measure counting measure 
measure useful countable spaces measure set number elements contains 
counting measure assigns measure zero empty set discrete probability distribution radon nikodym derivative distribution represented probability mass function assigns nonnegative probability element satisfies 
counting measure may symbol integral 
continuous probability real variables may model processes queueing radioactive decay appropriate measure lebesgue measure real numbers 
lebesgue measure interval length interval see rudin explanation extend measure larger class sets 
provided assigns zero probability sets lebesgue measure zero continuous probability distribution represented integrable function assigns nonnegative probability density point satisfies du 
interesting continuous distributions fall class 
computing probabilities infinite data structures counting measure lebesgue measure necessarily useful 
example consider infinite sequences flips fair coin uncountably sequences probability particular sequence zero counting measure useless 
know questions sensibly ask infinite data structures need know measurable sets 
place start smallest algebra containing sets ux defined ux finite 
subject technical conditions borel algebra scott topology partially ordered set smyth 
probability measures algebra answer questions probability sequence begins consecutive heads 
clear radon nikodym derivatives mass density functions exist kinds measures 
easier mass functions measures give definitions monad operations terms functions 
definitions apply discrete probability 
return choose 
stochastic lambda calculus semantics formal calculus expressing probability distributions give denotational definition probability monad 
simplify presentation pairs general products binary sums general sums binary choice choose general dist choose case er case expression may need explanation expression sum type left right 
left apply carried value apply er case analogous function standard haskell prelude 
semantics probability monad type constructor unit bind choose operations 
type type probability measures semantically wish limit attention measures restrict continuous evaluations probabilistic powerdomain jones plotkin 
probability monad define semantics stochastic lambda calculus 
suitable domains translation denotational semantics stochastic return return return return return fst return snd choose choose return left return right case er er translation stochastic calculus probability monad lambda calculus jones chapter 
translation significant properties denotations expressions kinds objects appear environments 
expressions denote probability distributions environments bind identifiers values distributions 
denotation lambda abstraction type function values type probability distributions values type properties rest translation expect find monadic semantics call value language imperative features probability monad state monad 
expect analogous lazy semantics exist explored avenue 
denotational definitions fashion 
don syntactic theory operational semantics denotational definition easier show mathematical foundations probability apply semantics probabilistic languages 
denotational definitions correspond closely structures implementations 
drawback reader harder see denotation choose unit mass concentrated 
words reducing lambda terms permissible duplicate redex 

probability monads haskell haskell implemented probability monad discrete distributions 
taken advantage haskell system type constructor classes provide specialized implementations kind query 
probability monad provides choose inherits return class monad 
simplicity represent probabilities double precision floating point numbers 
haskell type classes support general representations details distracting 
probability monads type probability double number class monad choose probability monad probability monad needs operation observes inside monadic computation hughes 
obvious observations queries 
require implementation support queries structure code provide di erent implementations kind query 
distributions created interface countable support easiest represent support distribution set elements 
code readable lists sets permit elements appear need haskell programmers eliminate duplicates list nub 
probability monads class support support return support concat support support choose support support comments show algebraic laws support satisfy support monad simple extension list monad 
law give choose value support choose depend 
remove signature choose get known nondeterminism monad 
law choose sound chosen simplicity really oversimplification 
practice important add side condition add laws cover cases 
probabilities arise real models idiomatic translations bayesian networks cutting support possible save significant computation 
easy show implementation support satisfying laws produces list values taken set forms support measure denoted monadic value 
proof relies discreteness measure inductive hypothesis implies support simplicity define expectation real valued functions 
di cult define version expectation monad compute expectation function range vector space reals 
expectation monad laws follows 
probability monads class expectation double double expectation return expectation expectation expectation expectation choose expectation expectation property section easy prove implementation expectation satisfying laws computes expectation defined measure 
stipulating true real number arithmetic infinitely bits precision laws sampling function 
distribution fst sample sampling function sense section 
probability monads sample return sample sample sample sample choose sample law choose interesting law uses bits precision needed compare remaining bits samples 
computation happens output arithmetic coder witten neal cleary 
proof correctness sampling laws di cult proof 
key finding induction hypothesis distribution real function defined product space sample dm unit interval lebesgue measure 
hypothesis straightforward show fst sample fst sample sampling function 
definition sampling useful implementation single random number arbitrarily bits precision 
consistent haskell standard library generator sampling probability monads class sample sample return sample sample sample sample choose random sample give denotational semantics sampling monad purely terms sampling functions sampling monad appealing operational interpretation monad random experiments 
class value type represents experiment returns value type 
unit computation return represents experiment returns computation produced bind represents experiment begins running generate intermediate value applies value get second experiment returns result second experiment 
choose represents experiment runs probability probability algebraic laws lead directly implementations monads 
additional notation needed legal haskell code appears appendix 
performance monads compute support sampling ciently possible asymptotically speaking 
expectation monad contrast inherently ine cient terms stochastic lambda calculus may perform exponentially worse algorithms 
problem monadic computation expectation compute expectation don information structure function apply value domain cost proportional size domain 
defined product domain may possible compute expectation lower cost depending structure example domain product space exist functions similarly split xy 
cost computing left hand side cost computing right hand side 
computing expectation function large number variables expected number heads sequence coin flips monad take exponential time solve linear problem 
functions wish take expectations structure exploited 
example probabilistic grammar natural language model say sentence noun phrase verb phrase 
models probabilistic context free grammars charniak phrases define independent probability distributions probability distribution string generated verb phrase depend generated noun phrase 
want compute expected number words sentence number words noun phrase plus number words verb phrase structure required 
noun phrase verb phrase quite independent verb phrase influenced word noun phrase verb phrase conditionally independent remaining words noun phrase word independence exploited 
probability monad exploit independence produce entire sentence including phrases apply su ces apply values support refinement important practice ect asymptotic costs 
sat sat formula satisfied assignment bound variable sum distinct variables union defined variable appear pair 
syntax semantics measure terms 
term language computing discrete expectation probability monad leads elegant implementations queries monadic computation expectation product space take time exponential number dimensions space 
rest devoted di erent abstraction measure terms 
measure terms expose structure rewrite sums integrals product spaces products sums reducing cost computing expectation measure terms define measures product spaces 
simplest kind term weighted formula generalization unit mass assigns real nonnegative weight set product space 
set defined formula simply predicate 
angle brackets colon serve delimit weighted formula semantic significance 
measure terms may multiplied added sum variables 
syntax measure terms follows write terms assuming binds tightly scope extends far right possible 
notation subtlety colons indicate summation symbol syntax 
mean summation semantic domain measurable space write reason measure terms able choose order sums 
representation product spaces identify dimensions name way ordered 
particular represent dimensional product space set pairs name measurable space 
represent value product space environment mapping names values domain environment 
name defined environment identifies dimension product space 
measure term denotes measure product space denotation may depend context product space interested 
specify product space giving semantics term 
analogy type environments write product space 
write value product space 
xn vn 
gives meanings terms 
function defines probability mass function get measure integrate counting measure 

context plays role evaluation need prove translation stochastic lambda calculus measure terms equivalent translation probability monad 
measure terms obey useful algebraic laws term true unit term product false unit term addition 
term product sum obey associative commutative distributive laws 
rename variables sums binding instance 
interchange sums di erent variables 
move terms outside sums provided free soundness laws follows immediately definition laws possible implement variable elimination code improving transformation reduces moving products outside sums 
full treatment variable elimination scope state idea briefly 
terms contains free variables appear free laws enable convert sum products product sums 
example free free 
cost computing left hand side cost computing right hand side 
rewriting term minimize cost computing np hard problem heuristics practice jensen 

measure terms probability represent probability distribution measure term distinguished free variable arbitrarily called pronounced result 
shows translate term stochastic lambda calculus measure term additional free variable 
left domains variables sums domains computed support function uses may require explanation 
write substitution superscripts subscripts stands xa xa va xa va xa va choose true true xnew xnew xnew xnew left right case er er support function gives set possible values expression evaluate environment compute support 
variables xnew xf xa unique fresh variables 
notate substitution superscripts subscripts stands measure term expression substituted variable functions left right predefined functions support sum types name represents literal value variable 
translation stochastic calculus terms measure term expression substituted variable rule application product symbol metalanguage symbol part measure term language stands large multiplication 
multiplication device applying functions get measure terms 
write multiplication record maps xa va va 
making variable elimination ectively results translation requires steps shown introducing multiple variables product spaces manipulating translation choose keep independent terms separate 
single free variable stands value product space need way split variable constituent parts 
product spaces isomorphic take equivalent equality change variables terms 
equality supports additional algebraic law translation choose shown terms combined addition 
consequence terms contains free variables able move addition outside sums free variables 
implementation apply law translation choose true true xnew bool xnew xnew xnew xnew 
right hand side chance move sums inside xnew 
equivalence translations term stochastic lambda calculus denotes probability measure compute measure probability monad measure terms 
claim central contribution linking elegant techniques defining languages cient techniques probabilistic reasoning 
proof requires technicalities associated denotations functions 
problem translation denotation lambda abstraction function returning value probability monad translation denotation lambda abstraction function returning measure term prove equivalent need reason functions returning probability measures 
di erent spaces values call monadic space term space value space 
show translations equivalent need able map space space space 
define mappings need type indexed family transformations call lift atomic zero order value integer string lift pair lift lift lift similarly sum types 
function define lift lift lift 
lift transformation closely related reify transformation type directed partial evaluation danvy 
having defined lift extend expressions formulas environments saying lift expression obtained replacing literal values lifted forms similarly formulas environments 
particular syntax lift lift adjust definitions return lift lift lift sat lift new definitions lambda term translated probability monad literal values live space lambda term translated measure terms literal values live space denotations probability measures apply values space 
lift machinery need state translations equivalent 
proof structural induction lambda terms induction hypothesis em lambda terms lift em lift em lift gives names types variables domain type measurable space drawn 
follows lambda term literals zero order literals integers translate way get probability distribution 
lemma applies frequently proof adding variables environment term doesn matter provided appear domain free lemma arbitrary 

expectation measure terms speed computation expectation function provided expose structure variable elimination algorithm 
implementation doesn compute expectations general functions expressed lambda terms computes expectations functions expressed form sat wn sat 
function define expectation wn 
equivalence previous section hard show suitable closed lambda term expectation expectation 
variable elimination left hand side produce exponential speedups functions 
related monads study language features implementation programming languages wadler introduces motivates topic 
monads come category theory category theorists long aware monadic structure probability lawvere 
support sampling monads known programming community especially support monad describes nondeterministic choice 
appears expectation monad known inherent ine ciency 
tool called quickcheck uses sampling monad generate random values testing functional programs claessen hughes 
quickcheck operator called choose somewhat di erent produces integer distributed uniformly specified range 
version choose simulated 
quickcheck provides frequency function analogous dist claessen hughes presents generator transformers existing generators build new ones ways done monadic bind 
obvious idea relates general probability monad 
substantial ort devoted developing domain theory help specify semantics probabilistic languages 
shows complete partial order structure probability distributions domain 
jones plotkin uses evaluations measures build probabilistic powerdomains 
jones doctoral thesis slightly accessible amateur section provides brief guide literature 
pleasant extend calculus recursive functions recursion equations fixed point operator give careful semantics extended calculus require domain theory category theory analysis scope 
particularly sticky bits permitting probability distributions functions wish models 
identified related languages support recursion 
presents probabilistic version lcf expressions base types integer boolean denote probability distributions expressions function type denote functions distributions functions 
language includes call name call value abstraction constructs values base types may passed call value functions 
presents denotational operational semantics shows equivalent 
jones chapter presents call value language closer 
major distinctions language includes fixed point operator syntactic categories expressions function expressions 
expressions denote probability distributions function expressions denote functions values probability distributions 
syntax structured function expressions applied fixedpoint operator applied function expressions ordinary expressions 
syntax meaning corresponds monadic unit operation function expression ordinary expression reverse path 
language support recursive functions possible apply function stored tuple passed argument 
thesis presents denotational operational se mantics language shows equivalent 
avoid di culties product spaces denotational semantics uses evaluations measures represent probability distributions 
modulo di erence omission recursive functions denotational semantics appears isomorphic 
benveniste 
gupta jagadeesan panangaden discuss languages description concurrent probabilistic systems 
di ers flavor combines probabilistic specification stochastic behavior unquantified constraintbased non determinism 
result program may may define single probability distribution 
language probabilistic non determinism program defines unique probability measure 
significant body available variable elimination 
pearl popularized graphical models including bayesian networks polytree reasoning algorithm 
commercial reasoning systems commonly junction tree algorithm lauritzen spiegelhalter 
zhang poole describes variable elimination algorithm bayesian networks li ambrosio presents algebraic variation 
dechter shows polytree junction tree algorithms forms variable elimination variable elimination framework unites probabilistic reasoning variety tasks constraint satisfaction 
arnborg lays graph theoretic foundations variable elimination 
implementations variable elimination specialized representations 
example basic unit representation may table corresponds measure term form ij path 
kn ij value don care 
generality measure terms significantly simplifies implementation appears impose unacceptable ciency costs 
learning algorithms variable elimination combine memoization frequently called caching probabilistic reasoning literature 
believe achieve similar performance gains introducing mutable state implementation introducing binding measure terms hash consing implement common subexpression elimination 
researchers probabilistic modeling languages resemble stochastic lambda calculus 
koller mcallester pfe er presents simple lisp language coin toss function giving operational semantics sampling experiments 
muggleton presents similar extension logic programs 
proposes stochastic lambda calculus traditional reduction semantics foundation probabilistic modeling languages 
lambda terms reduced sets value probability pairs additional rules needed distribute function application sets framework monadic bind solves problem 
argues debruijn indices easy identify equal values support memoization 

discussion elucidated connections basis probability monadic techniques describing programming languages variable elimination techniques cient probabilistic reasoning 
monad describe stochastic lambda calculus entertaining reduces proof obligations 
example theorems various probability monads take probabilistic language translate probability monad sure sampling consistent expectation 
monad enables separate structure semantic domain details particular probabilistic language 
clear retain advantages exploit greater ciency measure terms 
create instance probability monad produces measure terms cost obvious algorithm proportional size product space 
open question create instance probability monad produces measure terms cost greater cost evaluating terms variable elimination 
techniques inspired type directed partial evaluation produce syntax native functions solve problem danvy 
challenge add recursion calculus 
point view probability monad appear di culties 
suppose wish define recursive function appear free key consider meaning stand function probability distribution functions 
di cult classical style fixed point combinator 
easy style takes fixed points syntactic lambda abstractions write fix fix fix fix 
generalizing construct mutually recursive functions straightforward appel 
jones explains fixed point exists 
unfortunately clear recursive functions measure term translation 
practical build evaluate infinite measure terms sort approximation necessary 
pfe er koller presents approximation technique probabilistic relational knowledge bases expressed infinite measure terms 
remains seen extend techniques arbitrary measure terms approximate expressions involving higher order recursive functions produce measure terms 
presentation probability monad general laws sample expectation focused discrete distributions finite support 
moment introduce recursive functions probability monad define distributions uncountable support 
example uncountably infinite sequences tosses fair coin 
lazy variant stochastic lambda calculus embed probability monad haskell perfectly reasonable write functions produce infinite data structures queries 
queries depend finite sub structures probability tosses coin come heads computable finite time lazy evaluation 
extend monadic implementation incorporate infinite models answer queries ectively 
natural measurable space queries sense borel sets scott topology 
long term explore bayesian learning monadic framework 
bayesian paradigm parameters passed choose known exactly defined probability distribution 
bayesian experiment consists model prior distribution parameters set observations result posterior distribution parameters 
example bayesian experiments estimate probability aggressive driver runs red light 
incorporate bayesian approach monadic framework need parameter expression value 
extension provide useful declarative foundation active area machine learning 
acknowledgments simon peyton jones helped discussions measure terms variable elimination 
bob muller helped lift guided domain theory 
enjoyed stimulating discussions members cs seminar especially chung shan dylan thurston 
jon eddy simon peyton jones chung shan provided helpful comments manuscript 
anonymous referees directed useful related suggestions helped improve significantly 
supported nsf ccr alfred sloan research fellowship harvard university 
appel andrew 
compiling continuations 
cambridge cambridge university press 
arnborg stefan 

cient algorithms combinatorial problems graphs bounded decomposability 
bit 
benveniste albert bernard levy eric fabre paul le guernic 

calculus stochastic systems specification simulation hidden state estimation mixed stochastic systems 
theoretical computer science 
charniak eugene 

statistical language learning 
mit press 
claessen koen john hughes 
september 
quickcheck lightweight tool random testing haskell programs 
proceedings fifth acm sigplan international conference functional programming icfp sigplan notices 
danvy olivier 

type directed partial evaluation 
conference record rd annual acm symposium principles programming languages pages new york ny 
dechter rina 
august 
bucket elimination unifying framework probabilistic inference 
proceedings th conference uncertainty artificial intelligence uai pages san francisco 
michele 

categorical approach probability theory 
bernhard editor categorical aspects topology analysis vol 
lecture notes mathematics pages 
springer verlag 
gupta vineet radha jagadeesan prakash panangaden 
january 
stochastic processes concurrent constraint programs 
conference record th annual acm symposium principles programming languages pages 
hughes john 
april 
functional programming matters 
computer journal 

design pretty printing library 
jeuring johan erik meijer editors advanced functional programming vol 
lecture notes computer science 
springer verlag 
jaakkola tommi michael jordan 

variational probabilistic inference qmr dt network 
journal artificial intelligence research 
jensen finn 
bayesian networks 
new york springer 
jones claire 
july 
probabilistic non determinism 
phd thesis department computer science university edinburgh 
laboratory foundations computer science technical report ecs lfcs 
available online 
jones claire gordon plotkin 

probabilistic powerdomain evaluations 
proceedings fourth annual ieee symposium logic computer science pages 
jordan michael editor 

learning graphical models 
kluwer 
koller daphne david mcallester avi pfe er 

ective bayesian inference stochastic programs 
fourteenth national conference artificial intelligence aaai pages 
lauritzen ste en david spiegelhalter 

local computations probabilities graphical structures application expert systems 
journal royal statistical society pages 
lawvere william 

category probabilistic mappings 
unpublished 
li bruce ambrosio 

cient inference bayes nets combinatorial optimization problem 
international journal approximate reasoning 
george dan 

stochastic calculus 
technical report tr cs department computer science university new mexico 
mahoney suzanne kathryn laskey 
july 
constructing situation specific belief networks 
proceedings th conference uncertainty artificial intelligence uai pages 
morgan kaufmann 
muggleton stephen 

stochastic logic programs 
journal logic programming 
accepted subject revision 
pearl judea 

probabilistic reasoning intelligent systems networks plausible inference 
san mateo ca morgan kaufmann 
pfe er avi 
august 
ibal probabilistic rational programming language 
seventeenth international joint conference artificial intelligence ijcai pages seattle 
pfe er avi daphne koller 
july 
semantics inference recursive probability models 
proceedings th conference artificial intelligence aaai pages menlo park ca 
ramsey norman 
september 
literate programming simplified 
ieee software 
rudin walter 

real complex analysis 
series higher mathematics 
second edition 
new york mcgraw hill 
september 
probabilistic lcf 
jozef editor proceedings th symposium mathematical foundations computer science vol 
lecture notes computer science pages 
springer 
september 
cpo measures nondeterminism 
theoretical computer science 
smyth michael july 
power domains predicate transformers topological view 
josep editor automata languages programming th colloquium icalp vol 
lecture notes computer science pages barcelona spain 
wadler philip 
january 
essence functional programming invited talk 
conference record th annual acm symposium principles programming languages pages 
new york ny acm press 
witten ian radford neal john cleary 
june 
arithmetic coding data compression 
communications acm 
zhang nevin david poole 

simple approach bayesian network computations 
tenth biennial canadian artificial intelligence conference 
implementations probability monads implementations derived algebraic laws section techniques explained hughes 
prepared noweb system literate programming ramsey haskell code automatically extracted run glasgow haskell compiler version 
support monad support monad represent distribution list values contain 
probability monads newtype support support instance monad support return support support support concat instance support choose support support support instance support support support expectation monad represent expectation monad function computes expectation directly 
probability monads newtype exp exp double double instance monad exp return exp exp exp apply exp arg arg apply instance exp choose exp exp exp instance exp expectation exp sampling monad represent sampling monad suitable function 
probability monads newtype sample sample instance monad sample return sample sample sample sample instance sample choose sample sample sample random random instance sample sample sample addendum overlooked relevant pieces related 
filinski doctoral dissertation presents probability monad 
david published relevant esop 

