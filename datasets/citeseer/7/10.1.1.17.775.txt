heuristic randomized optimization join ordering problem michael guido moerkotte kemper universitat passau universitat mannheim fakultat fur mathematik lehrstuhl fur praktische und informatik informatik iii passau germany mannheim germany kemper db fmi uni passau de pi informatik uni mannheim de developments database technology deductive database systems rise demand new cost effective optimization techniques join expressions 
different algorithms compute approximate solutions optimizing join orders studied traditional dynamic programming techniques appropriate complex problems 
possible solution spaces space left deep bushy processing trees respectively evaluated statistical point view 
result common limitation processing trees advisable certain join graph types 
basically optimizers classes analysed heuristic randomized genetic algorithms 
extensively scrutinized respect working principle fitness desired application 
turns randomized genetic algorithms suited optimizing join expressions 
generate solutions high quality reasonable running time 
benefits heuristic optimizers short running time outweighed merely moderate optimization performance 
years relational database systems standard variety commercial scientific applications 
queries stated non procedural manner need optimizers arises transform straightforward translation query cost effective evaluation plan 
due high evaluation costs joins primary target query optimizers 
queries stated interactively generally relations involved 
optimization expressions carried exhaustive search possibly enhanced pruning techniques exclude candidates solutions 
instance system sac dynamic programming algorithm employed optimization joins 
approach works long relations joined join expression consists relations dynamic programming techniques quickly prohibitively expensive 
queries kind encountered developments deductive database systems join expressions may consist large number relations 
source queries query generating database system frontends complex views 
cases complex queries may issued user aware fact 
objectoriented database systems km complex join expressions may encountered forward traversal object usually supported specialized access mechanisms treated ordinary join operations true backward traversal 
require appropriate index structures access support relations km processing turn involves handling potentially complex join expressions initial materialization maintenance 
demand optimization techniques cope complex queries cost effective manner 
shall examine approaches solution problem assess advantages disadvantages 
rest article organized follows section shall give exact definition problem terms cost models shall analysis 
section deals problem different solution spaces evaluation strategies 
section describe common optimization strategies varying working principle subject quantitative analysis section 
section concludes 
problem description problem determining evaluation strategies join expressions addressed development relational database systems wy yw sac 
area divided major streams development efficient algorithms performing join second algorithms determine nesting order joins performed 
article shall concentrating generation low cost join nesting orders disregarding specifics join computing provides overview subject 
relational database systems queries stated interactively join expressions involve relations rarely encountered 
computation optimal join order lowest evaluation cost exhaustive search perfectly feasible takes seconds cpu time 
relations joined generally np hard problem determining optimal order ik solved exactly anymore 
rely algorithms compute hopefully approximate solutions 
algorithms fall classes augmentation heuristics build evaluation plan step step certain criteria second randomized algorithms perform kind random walk space possible solutions seeking solution minimal evaluation cost 
definition terms input optimization problem query graph join graph consisting relations joined nodes joins specified edges 
edges labelled join predicate join selectivity 
join predicate maps tuples cartesian product adjacent nodes trueg depending tuple included result 
join selectivity ratio number tuples result number tuples cartesian product 
special case cartesian product considered join operation join predicate true join selectivity 
search space solution space set evaluation plans compute result 
point solution space particular plan solution problem 
solution described processing tree evaluating join expression 
point solution space cost associated cost function maps processing trees respective costs 
processing tree binary tree consists base relations leaves join operations inner nodes edges denote flow data takes place leaves tree root 
goal optimization find point solution space lowest possible cost global minimum 
combinatorial explosion exhaustive enumeration possible solutions infeasible np hard characteristic problem implies presumably exist faster algorithm rely heuristics compute approximate results 
cost models investigations cost models discussed subsection 
cost models measures cost number pages read written secondary memory 
execution environment distributed 
database assumed larger available main memory costs neglected introducing large error 
cost models parameters listed table 
join operations 
common term cost formulae cost writing result join operation secondary memory 
parameter meaning jrj cardinality number tuples relation ts tuple size relation bytes bs size disk block bytes ps size tuple tuple identifier tid ms main memory size bs units oe join selectivity join gamma oe jr gammar jr thetar number blocks occupied relation fo fanout internal tree node fo delta bs ks pr ks key size pr size page xr height tree index join attribute minus xr log fo gamma assuming ps ks pr selection cardinality join attribute average number tuples value join attribute table cost model parameters cost write gamma oe delta jr delta jr bs ts nested loop join cost performing nested loop join depending presence index structures en 
index support nl gamma read ms gamma delta read perform join 
primary tree index join attribute nl gamma read jr delta index find matching tuple 
secondary tree index join attribute nl gamma read jr delta index find matching tuple 
hash index join attribute nl gamma read jr delta index find matching tuple average number page accesses necessary retrieve tuple key 
value primary hash index secondary hash index 
sort merge join cost performing sort merge join operation en sm gamma cr cr cr resp 
cr computed cases 
relation sorted join attribute primary tree index join attribute crx rx cost reading relation 

secondary tree index join attribute crx jr delta ps delta bs rx leaf nodes index tree assumed full scanned pointers tuples relation blocks containing tuples read 

sort order join attribute explicit sorting required crx rx log ms rx rx assume merge sort algorithm applied number merge passes depends amount main memory available 
hash join assume hybrid hash join carried 
algorithm performs large range available main memory 
cost sha delta delta gamma denotes fraction hash table fits main memory 
computed ms gamma deltab ms gamma constant accounts hash table load factor 
gamma gamma delta delta delta gamma gamma gamma gamma delta delta delta computation processing tree costs cost entire processing tree order estimate cost evaluating entire processing tree cost node computed recursively bottom right left sum cost obtaining son nodes cost joining order get final result 
outer relation cost formulae base relation join algorithm nested loop join assume pipelining possible saves costs writing intermediate result disk read back main memory 
instance processing tree join nodes supposed nested loop joins evaluated follows 
join operation gamma node performed 
operands base relations cost reading included estimate 
furthermore result operation written disk intermediate relation 

join operation gamma node performed 
operands base relations cost scanning counted 
contrast node intermediate result written disk tuples pipelined node root processing tree 

node intermediate results gamma gamma joined order compute final result 
gamma need read disk due pipeline node gamma read back final result written disk 
note boxed join nodes results written secondary memory 
considerations valid processing nodes question nested loop joins 
node node example tree nested loop joins cost writing intermediate result disk reading back memory charged 
solution space join ordering problem generally solution space defined set processing trees compute result join expression contain base relation exactly 
leaves processing trees consist base relations inner nodes correspond join results appropriate sons 
join operation commutative associative number possible processing trees increases quickly increasing number relations involved join expression question 
traditionally subset complete space set called left deep processing trees special interest researchers sac sg swa 
shall study characteristics complete solution space subset left deep trees interesting special cases tree shapes contemplated right deep trees zig zag trees mainly interest distributed computing environments cf 
left deep trees subset consists processing trees inner relation join base relation 
fixed number base relations specification left deep leave degrees freedom concerning shape tree 
ways allocate base relations tree leaves 
argued solutions exist trees trees capable exploiting cost reducing pipelining technique join processing nodes 
case processing tree consists solely nested loop joins index support single intermediate result materialized secondary memory 
bushy trees solution space permit join nodes operands composites base relations 
solutions space way restricted 
consequently solution space includes left deep special tree shapes strict subsets 
shape possible processing trees arbitrary cardinality set higher cardinality left deep space base relations gamma gamma gamma 
different solutions 
degrees freedom constructing bushy trees higher capability exploiting pipelining technique restricted subset tree join processing nodes 
shape tree tends right deep join nodes left operands base relations smaller size subset 
right deep tree join processing nodes capable pipelining 
ol adaptable plan enumeration strategy linear chain star shaped join graphs proposed reduces number plans costs evaluated considerably 
denotes number relations join graph gamma bushy tree solution space resp 
gamma left deep tree solution space feasible joins linear graphs 
star graphs gamma delta gamma bushy tree solution space feasible joins 
approach requires especially tailored join plan enumerator class join graphs encountered arbitrary join graphs entire solution space considered order guarantee optimal solution missed 
join ordering strategies problem finding nesting order relational joins tackled different ways 
deterministic algorithms algorithm class constructs solution step step deterministic manner applying heuristic exhaustive search 

randomized algorithms algorithms class pursue completely different approach set moves defined 
moves constitute edges different solutions solution space solutions connected edge transformed exactly move 
algorithms performs random walk edges certain rules terminating soon applicable moves exist time limit exceeded 
best solution encountered far result 

genetic algorithms genetic algorithms randomized search strategy similar biological evolution search problem solutions 
aspect genetic algorithms resemble randomized algorithms discussed approach shows differences warrant consideration 
basic idea start random population generate offspring random crossover mutation 
fittest members population cost function survive subsequent selection generation 
algorithm terminates soon improvement predetermined number generations 
fittest member population solution 

hybrid algorithms hybrid algorithms combine strategies pure deterministic pure randomized algorithms solutions obtained deterministic algorithms starting points randomized algorithms initial population members genetic algorithms 
deterministic algorithms algorithms discussed section employ heuristics pruned search solution space order optimize join expression 
shall take closer look different algorithms class varying complexity performance 
dynamic programming classical algorithm join order optimization system sac 
searches solution space left deep processing trees 
set partial solutions initialized possible scan nodes relation attributes participate query 
instance index attribute index scan ordinary file scan considered feasible partial processing trees 
step element cheaper equivalent alternative pruned set possible partial solutions alternative considered equivalent joins set relations sort order partial result 
loop algorithm constructs kth iteration set relation partial solutions set gamma relation partial solutions 
loop terminates set consists possibly equivalent optimal solutions 
pseudo code rendering algorithm shown 
apart removal equivalent alternatives cheapest original algorithm cited performs pruning search tree defers cartesian products partial solutions long possible removing candidates optimal solution 
strategy reduces computational complexity result longer guaranteed optimal 
major disadvantage algorithm high memory consumption storing partial solutions 
exponential running time application queries involve fifteen relations prohibitively expensive 
vance maier vm devised efficient socalled light weight implementation dynamic programming bushy tree join optimization 
method allows optimize join queries relations albeit simplified cost model 
function inputs rels set relations joined outputs pt processing tree fall scans attributes remove elements equivalent lower cost alternative pt rels pt pt omega omega pt ffl ffi fi fl gamma remove elements equivalent lower cost alternative return arbitrary element algorithm dynamic programming minimum selectivity solutions generally characterized intermediate results small cardinality 
minimum selectivity heuristic builds left deep processing tree step step trying keep intermediate relations small possible 
regard resembles ingres decomposition strategy wy strategy considers operands cardinalities minimum selectivity heuristic selectivity factor oe join gamma achieve small intermediate results 
set relations joined divided subsets set relations incorporated intermediate result denoted initially empty set relations joined intermediate result denoted remaining initially consists set relations 
step algorithm relation remaining lowest selectivity factor oe fi fi fi fi fi gamma gamma ru fi fi fi fi fi jr delta fi fi fi fi fi gamma ru fi fi fi fi fi function inputs rels list relations joined outputs pt processing tree pt nil pt nil relation smallest cardinality pt ffl ffi fi fl relation rels smallest selectivity factor join pt pt omega omega pt ffl ffi fi fl gamma rels rels rels return pt algorithm minimum selectivity joined far intermediate result moved remaining shows complete algorithm left deep processing trees 
krishnamurthy boral zaniolo algorithm foundation law ms ibaraki kameda showed ik possible compute optimal nesting order polynomial time provided query graph forms tree cycles cost function member certain class 
result krishnamurthy boral zaniolo developed kbz algorithm called kbz algorithm computes optimal solution tree query time number joins 
step relation plays turn role root query tree 
roots tree linearized means ranking function establishes optimal evaluation order particular root 
linearized tree obeys tree order words parent node placed son nodes 
evaluation order lowest cost result algorithm 
transforming query tree rooted tree parent node node uniquely identified 
selectivity join basically edge attribute query graph assigned nodes 
cost function expressed gamma jr delta jr arbitrary function join cost assigned particular node 
principle possible nested loop join algorithms merge join hash join algorithms 
cost computed recursively follows denotes empty sequence partial sequences jr root node jr auxiliary function defined empty sequence oe jr oe denotes selectivity join parent node 
algorithm called adjacent sequence interchange property ik cost functions expressed gamma jr delta jr 
join graph rooted tree sequences nodes non null partial order defined violated av ub av ub rank rank rank non null sequence defined rank gamma cost minimized sorting ranking function rank provided partial order defined tree preserved 
algorithm computing minimum cost processing tree consists auxiliary function linearize main function kbz 
join tree linearized function linearize bottom merging sequences ranking function performed 
step root node head sequence derived 
possible root node higher rank sons normalization sequence carried 
means relation sequence root node joined successor 
necessary step repeated order sequence correct 
cost sequence computed recursive cost function function linearize inputs root root partial tree outputs chain optimal join order tree shaped join graph root root chain succ sons root lin linearize succ merge lin chain ranks chain root chain normalize root node root cf 
text return chain auxiliary function linearize function kbz inputs outputs join order tree minimum spanning tree mincost forall node tree lin linearize node undo normalization cost cost lin cost mincost lin mincost cost return kbz algorithm main function kbz procedure carried relation join graph acting root node 
sequence lowest total cost result optimization 
algorithm extended general cyclic join graphs straightforward way reducing query graph minimal spanning tree kruskal algorithm kru 
weight join graph edges determined selectivity appropriate join minimal spanning tree determined tree lowest product edge weights sum edges weights usual applications kruskal algorithm 
extension suggested kbz 
join graph cyclic result longer guaranteed optimal heuristic approximation 
speak kbz algorithm sections refer extension computation minimal spanning tree join graph 
due working principle kbz algorithm requires assignment join algorithms join graph edges optimization carried 
requirement restrictions concerning cost model main drawbacks kbz algorithm 
sophisticated detailed cost model kbz optimal result inevitably crude approximation different real optimum 
furthermore separating tasks join order optimization join method assignment invalidates main advantage kbz algorithm yield optimal solution time 
section algorithm discussed tries remedy situation 
ab algorithm ab algorithm developed swami iyer si 
kbz algorithm various enhancements trying remove restrictions imposed join method placement 
algorithm permits different join methods nested loop sort merge 
cost model simplified swami iyer conforms requirements kbz algorithm gamma jr delta jr function cf 
section 
algorithm runs follows cf 

randomize methods join join graph assigned randomly selected join method 
join graph cyclic random spanning tree selected 

resulting tree query optimized kbz algorithm apply kbz 

change order attempts reduce cost swapping relations interesting orders exploited 
function ab inputs outputs join order number iterations randomize methods number iterations apply kbz change order change methods post process return ab algorithm 
step comprises single scan join order achieved far 
join attempt reduce total cost changing join method employed change method 

steps iterated improvement possible iterations performed number joins join graph 

steps repeated long total number iterations inner loop exceed 
post processing step post process order relations changed attempt reduce cost 
ab algorithm comprises elements heuristic randomized optimizers 
inner loop searches heuristically local minimum outer loop random starting points generated manner iterative improvement algorithm cf 
section 
ignoring contribution kbz algorithm ab extension hardly possible sophisticated cost model 
randomized algorithms randomized algorithms view solutions points solution space connect points edges defined set moves 
algorithms discussed gamma delta delta gamma delta delta gamma gamma delta delta delta delta gamma delta delta gamma delta delta commutativity associativity gamma gamma gamma gamma gamma gamma gamma gamma delta delta delta delta gamma gamma delta delta delta delta gamma delta delta gamma delta delta gamma delta delta gamma delta delta left join exchange right join exchange gamma gamma gamma gamma gamma gamma gamma gamma moves bushy tree solution space traversal perform kind random walk solution space edges defined moves 
kind moves considered depend solution space left deep processing trees desired solution represented uniquely ordered list relations participating join 
different moves proposed sg swa modifying solutions swap cycle 
swap exchanges positions arbitrary relations list cycle performs cyclic rotation arbitrary relations list 
instance point solution space application swap lead cycle yield complete solution space arbitrarily shaped bushy processing trees considered moves depicted introduced ik traversal solution space 
iterative improvement solution space join optimization problem contain global cost minimum local minima simple hill climbing algorithm finding minimum 
solution space contain local minima hill climbing certainly yield 
iterative improvement algorithm sg swa ik tries overcome problem way selecting random starting point algorithm seeks minimum cost point strategy similar hill function outputs optimized processing tree mincost state random starting point cost cost state newstate state random move cost newstate cost state newstate cost local minimum reached cost mincost state mincost cost time limit exceeded return iterative improvement climbing 
starting point random neighbour point reached exactly move selected 
cost associated neighbouring point lower cost current point move carried new neighbour lower cost sought 
strategy insofar different genuine hill climbing attempt determine neighbour lowest cost 
reason behaviour generally high number neighbours checked 
holds check point local minimum 
systematically enumerating possible neighbours checking individually point assumed local minimum lower cost neighbour certain number tries 
procedure repeated predetermined number starting points processed time limit exceeded 
lowest local minimum encountered result 
function inputs state random starting point outputs optimized processing tree state cost cost state mincost cost temp starting temperature newstate state random move cost newstate cost state newstate cost probability temp state newstate cost cost mincost state mincost cost equilibrium reached reduce temperature frozen return simulated annealing simulated annealing iterative improvement suffers major drawback moves accepted improve result obtained far possible high number starting points final result unacceptable 
case especially solution space contains large number local minima 
case algorithm gets easily trapped high cost local minima 
simulated annealing variant iterative improvement removes restriction iw sg 
simulated annealing move may carried neighbouring point higher cost 
algorithm get trapped local minima easily iterative improvement 
name simulated annealing suggests algorithm tries simulate cost starting state ii minimum sa iterative improvement vs simulated annealing annealing process crystals 
natural process system eventually reaches state minimum energy 
slower temperature reduction carried lower energy final state large crystal lower energy smaller ones combined 
illustrates behaviour iteration iterative improvement stops local minimum simulated annealing overcomes high cost barrier separates global minimum sa algorithm accepts moves lead lower cost state accepts moves increase costs probability depends temperature difference actual new state cost 
course exact behaviour determined parameters starting temperature temperature reduction stopping condition 
variants proposed literature shall detailed parameters section analyse compare sa variants 
phase optimization basic idea variant combination iterative improvement simulated annealing order combine advantages ik 
iterative improvement applied repeatedly capable covering large part solution space descends rapidly local minimum simulated annealing suited thoroughly covering neighbourhood point solution space 
phase optimization works follows 
number randomly selected starting points local minima sought way iterative improvement 
lowest local minima simulated annealing algorithm started order search neighbourhood better solutions 
close proximity local minimum needs covered initial temperature simulated annealing pass set lower simulated annealing algorithm run 
simulated annealing approach similar phase optimization proposed context distributed computing environment 
simulated annealing simulated annealing tours different starting points performed 
starting point derived deterministic algorithm greedily builds processing trees augmentation heuristic 
instance minimum selectivity heuristic discussed section provide starting points 
similarly phase optimization main benefit simulated annealing reduced running time 
starting temperature different tours set lower times initial plan cost simulated annealing random starting point annealing process spend time accepting moves improve current solution 
random sampling radically different idea pursued 
randomized algorithms discussed far transformations attempt reduce solution evaluation cost set rules improvement achieved 
analysis cost distribution solution space reveals significant fraction solutions close optimum 
algorithm draws truly random sample solutions contain fraction solutions entire space designing algorithm selects processing tree equal probability trivial 
mentioned algorithm designed acyclic join graphs application appropriate reasonably evaluation cost times minimum cost evaluation plan identified quickly experimental results indicate 
genetic algorithms genetic algorithms designed simulate natural evolution process 
nature fittest members population survive propagate features offspring genetic algorithms propagate solutions problem generation generation combining achieve improvement 
provide brief overview terminology working principles genetic algorithms 
comprehensive reader referred gol 
terminology genetic algorithms designed simulate biological evolution terminology describe borrowed biology 
important characteristics genetic algorithms single solution set solutions population 
single solution called phenotype 
solutions represented strings chromosomes composed characters genes take different values alleles 
locus gene corresponds position character string 
problem solved genetic algorithms solutions represented character strings appropriate encoding 
fitness solution measured objective function maximized minimized 
generally designed genetic algorithm average fitness fitness best solution increases new generation 
basic algorithm working principle genetic algorithm optimize join expressions generic algorithm described 
population random character strings generated 
zero generation solutions 
generation determined follows ffl certain fraction fittest members population propagated generation selection 
ffl certain fraction fittest members population combined yielding offspring crossover 
ffl certain fraction population necessarily fittest altered randomly mutation 
loop iterated best solution population reached desired quality certain predetermined number generations produced improvement observed certain number generations 
section shall examine generic algorithm adapted problem optimizing join expressions 
genetic algorithm optimizing join expressions genetic algorithms nearly studied intensively join order optimization randomized algorithms shall discuss questions associated employment genetic algorithms optimizing join expressions detail 
particular merely provide techniques implemented alternatives considered tested 
basic algorithm remains unmodified variations solution encoding selection crossover mutation may contemplated 
encoding genetic algorithm applied solve problem appropriate encoding solution objective function chosen 
join optimization solutions processing trees left deep bushy objective function evaluation cost processing tree minimized 
encoding processing trees considered different schemes 
ordered list left deep trees solutions represented ordered list leaves 
instance processing tree gamma gamma gamma gamma encoded 
bushy trees bushy trees cartesian products encoded ordered list join graph edges 
scheme proposed bfi 
example encoding scheme represent processing tree depicted character string 
preliminary step edge join graph labelled arbitrary number 
processing tree encoded bottom left right just way evaluated 
join tree joins relations edge join graph 
steps joined contributing edges respectively 
final encoding sample processing tree 

ordinal number encoding left deep trees chromosome consists sequence ordinal numbers processing tree list leaves 
instance processing tree gamma gamma gamma gamma encoded follows ffl ordered list participating relations instance indices 
gamma gamma gamma delta delta delta gamma gamma gamma gamma join graph processing tree encoded tree encoding bushy processing trees ffl relation processing tree relation list index gene chromosome 
removed list 
ffl second relation processing tree third relation list second gene chromosome 
removal 
ffl process repeated list exhausted 
example final encoding processing tree 
bushy trees bushy trees ordinal numbers chromosome denote join nodes similar ordered list join edges described 
specifying join node corresponding join graph edge join operands purpose 
instance processing tree encoded follows ffl ordered list participating relations exactly left deep tree encoding 
ffl join node processing tree gamma involves index respectively gene chromosome 
replaced 
ffl node processing tree joins relation result gamma index yielding gene 
ffl repeating process leads complete chromosome 
actual implementation chromosome genes carry additional information operand order encoding join algorithm encoding population nr 
string cost fraction wheel sum spinning wheel new generation nr 
string selection schemes 
selection selection operator separate bad solutions population 
motivation remove bad solutions increase share solutions 
mimicking nature selection realized shown 
sample population consists solutions objective function cost minimized 
cost value solutions listed table 
solution assigned sector size inverse proportional cost value biased roulette wheel 
spins wheel yield result second table solution selected extinct due lack adaptation 
selection scheme fitness ratio members population better member satisfies objective function dominates wheel relative super population member may cause premature convergence mediocre solution disappearance members features 
features may valuable solution high quality 
avoid ranking selection 
means value objective function rank biasing selection wheel 
instance cost values determine fraction wheel solution assigned phi phi phi phi hj parents offspring crossover subsequence exchange ordered list encoding just rank value solution solution solution solution 
general experience shows ranking selection usually evolution process advance slowly risk losing important information contained weaker solutions lower 
variant keep best solution case 
strategy referred elitist helps speeding convergence near optimal solution risk losing solution eliminated 
crossover crossover operator means combining partially solutions order obtain superior result 
realization crossover operator depends heavily chosen encoding 
instance crossover operator sure characteristics particular encoding violated 
characteristic uniqueness character string ordered list encoding scheme 
crossover operator encoding scheme tightly coupled implementation particular crossover operator facilitated possible particular encoding scheme 
basically considered different crossover operators subsequence exchange subset exchange 
follows 
subsequence exchange ordered list encoding example application operator shown 
assumes ordered list encoding scheme 
offspring chromosomes random subsequence permuted genes order appearance parent 
instance subsequence selected string 
gene offspring remains parent 
second gene taken gene parent 
second gene parent third gene offspring taken third gene parent 
continuing process yields offspring chromosome 
determining second offspring carried similarly 
phi phi phi phi hj parents offspring crossover subsequence exchange ordinal number encoding phi phi phi phi hj parents offspring crossover subset exchange 
subsequence exchange ordinal number encoding operator slight variation 
intended conjunction ordinal number encoding 
contrast version sequence exchange operator subsequences selected parents equal length 
subsequences simply swapped 
feasible ordinal number encoding worry duplicated characters 
shows sample application operator 

subset exchange ordered list encoding basic idea operator avoid potential problems duplicated characters simply selecting random subsequences equal length parents consist set characters 
sequences simply swapped parents order create offspring 
depicts example application crossover operator 
mutation mutation operator needed introducing features member population 
mutation carried random alteration randomly selected chromosome 
operator introduce duplicate characters ordered list chromosomes random genes simply swapped order carry mutation ordinal number encoding random gene chromosome assigned new random value 
due character mutation spice evolution process applied liberally lest process may severely disrupted 
chain star cycle grid join graphs usually mutations performed generation 
elitist variant selection operator consider best solution population mutated 
reasons doing explained paragraph describing selection operator 
quantitative analysis preliminaries generation queries benchmarks permits independent setting parameters ffl class join graph ffl distribution relation cardinalities ffl attribute domains shape join graph chosen classes chain star cycle grid cf 
respectively 
relation cardinalities domain sizes fall categories xl specified table instance relations comprise tuples 
figures chosen join results cost values small error introduced due page granularity cost model large loss accuracy due limited floating point arithmetic resolution 
query specified relations particular join graph joined selectivities associated graph edges computed estimate system sac oe min dom attribute dom attribute 
index structures hash tables trees facilitate read access percent relation attributes 
constructing join graph relation cardinalities attribute domain sizes class relation cardinality percentage xl class domain size percentage xl relation cardinalities domain sizes table relation cardinalities domain sizes drawn independently various sanity checks ensure instance relation cardinality exceed product attribute domain sizes 
point diagrams represents average optimized queries proved compromise conflicting goals avoidance spurious results due atypical behaviour single runs running time preliminary tests showed 
optimization strategies discussed section implemented algorithms system algorithm minimum selectivity heuristic kbz algorithm class deterministic optimizers simulated annealing iterative improvement genetic variants class randomized genetic optimizers 
deterministic algorithms yield solutions subspace left deep processing trees randomized genetic algorithms operate entire solution space bushy trees 
cost figures scaled respect best solution available apart system system algorithm run parameter settings due high running time 
instance solution scaled cost twice expensive evaluate best plan computed algorithm particular query 
curve algorithm compute best solution necessarily shown plot 
words set algorithms compete best solution regardless subset depicted particular plot 
solution spaces presenting benchmark results take closer look solution spaces 
left deep tree space subset bushy tree space expect lower running times optimizers operate left deep space 
hand danger missing solutions left deep trees 
order get insight advantages solution space determined left deep optimal bushy optimal solutions randomly selected queries participating relations 
histograms different join graph types chain star cycle grid left deep vs bushy processing show percentage cases left deep tree optimum bushy tree optimum equal cost optimal solution fact left deep tree labelled 
left right percentages cases bushy tree optimum percent percent lower cost left deep tree optimum 
considering histograms apparent shape join graph big difference chain cycle find half cases better solution bushy tree solution space cycle fifth cheaper best left deep tree solution 
consequently investment searching bushy tree solution space profitable 
hand star join graphs cases optima left deep trees anyway tree shapes necessarily comprise cartesian products 
grid join graph situation clear optima left deep trees non fraction bushy tree optima far cheaper left deep counterparts 
choice favour bushy tree solution space depend heavily scaled cost number relations kbz system deterministic algorithms chain join graph optimization algorithms capability locate solutions cf 
ik 
remainder section investigate bushy tree optimizers exploit potential solutions bushy tree solution space 
benchmark results deterministic algorithms series benchmarks shall examine deterministic algorithms 
figures show results system algorithm section minimum selectivity heuristic section kbz algorithm section 
cost formulae section fulfils kbz algorithm requirement simple approximation counts processed tuples nested loop join considering index structures order able run algorithm 
cost complete evaluation plan derived computed exact formulae 
diagrams scaled cost cost optimized evaluation plan divided cost best plan derived optimization algorithms discussed section system plotted number relations participating query join graph type noted respective 
please note smaller scale axis star join graph 
deterministic algorithms yield left deep processing trees addition best join method determined locally join node proceeding bottom selecting costly join method node 
results system optimization plotted participating relations order provide absolute basis comparison purposes 
scaled cost number relations kbz system deterministic algorithms star join graph scaled cost number relations kbz system deterministic algorithms cycle join graph scaled cost number relations kbz system deterministic algorithms grid join graph despite simple cost approximation running kbz algorithm optimizer turns best heuristic deterministic optimizers chain star cycle join graphs 
especially solutions star join graph hardly improved algorithms tested deterministic randomized genetic 
cycle grid results quite competitive join graphs cyclic spanning tree selected prior application kbz algorithm 
effect especially apparent grid join graph minimum selectivity heuristic performs best 
system algorithm computes optimal left deep processing tree cartesian products achieves average cost factor slightly solutions cost factors better approximate solutions 
reason cost factor higher due limitation system algorithm left deep processing trees cartesian products 
summarize results heuristics optimizers note points discussed optimizers short running time kbz algorithm managed compute results relation star queries cpu seconds minimum selectivity heuristic tenth second queries 
second performance terms quality star join graphs small queries competitive kbz performs best join graphs low connectivity minimum selectivity grid join graph 
small queries probably want rely heuristic algorithms compute optimal solution kind search strategy 
benchmark results randomized genetic algorithms set benchmarks carried randomized algorithms cf 
section genetic algorithms cf 
section 
compare variants iterative improvement called iij sg ik simulated annealing called sah sg ik variants genetic algorithms genetic 
furthermore results system optimization shown participating relations 
parameters algorithm derived cited ii sa determined preliminary tests genetic 
addition algorithms generating left deep trees search proceeding leaves tree root performed trial solutions order determine appropriate join method join node 
exactly set benchmarks heuristic algorithms scaled cost plotted number relations participating join please note different scale 
parameters algorithms mentioned follows 
ffl move swap cycle left deep processing trees considered 
ffl starting temperature chosen moves accepted 
ffl number iterations inner loop number joins query 
ffl iteration inner loop temperature reduced old value 
ffl system considered frozen best solution encountered far improved subsequent outer loop iterations temperature reductions percent generated moves accepted 

sah ffl move swap cycle left deep processing trees considered 
ffl starting temperature determined follows standard deviation oe cost estimated set sample solutions multiplied constant value 
ffl inner loop performed cost distribution generated solutions sufficiently stable details cf 
sg 
ffl iteration inner loop temperature multiplied max gamma oe oe see 
ffl system considered frozen difference minimum maximum costs accepted states current temperature equals maximum change cost accepted move current temperature 

ffl moves chosen join method change commutativity associativity left join exchange right join exchange 
entire solution space bushy processing trees considered 
ffl starting temperature twice cost randomly selected starting state 
ffl number iterations inner loop sixteen times number joins query 
ffl iteration inner loop temperature reduced old value 
ffl system considered frozen best solution encountered far improved subsequent outer loop iterations temperature reductions temperature fallen 

iterative improvement iij ffl starting points chosen randomly 
ffl algorithm iix moves chosen set corresponding sax algorithm 
ffl local minima determined sg iij ik solution considered local minimum randomly selected neighbours fail improve result 
number join graph edges iij number neighbouring states 
ffl order perform fair comparison iterative improvement simulated annealing total number solutions considered approximately corresponding iix sax algorithms 

phase optimization scaled cost number relations genetic sah iij system randomized algorithms left deep tree solution space chain join graph ffl random starting points ii phase 
ffl sa phase starts minimum ii phase starting temperature times cost 

genetic algorithms genetic ffl solution space left deep processing trees bushy processing trees ffl encoding ordered list leaves ordinal number encoding ffl ranking selection operator ffl sequence exchange crossover operator ffl population ffl crossover rate members population participate crossover ffl mutation rate solutions subject random mutation ffl termination condition generations improvement generations improvement figures results left deep tree optimizers depicted 
parameter setting sah iij similar note scaled cost number relations genetic sah iij system randomized algorithms left deep tree solution space star join graph variants perform poorly join graph types 
sah perform better turn sah superior 
cases sah genetic algorithm computed best evaluation plans left deep tree optimizers slight superiority genetic algorithm 
apparently sophisticated equilibrium freezing condition sah main reason results 
closer look benchmark data revealed visited solution alternatives sah 
iterative improvement variants designed consider different solutions respective simulated annealing algorithms reflect fact achieves better results iij 
apart quality derived results important criterion selecting optimizers running time investigate 
look performance optimizers operate bushy tree solution space 
optimizers po genetic algorithm compared figures 
addition best left deep optimizers curves sah genetic included order facilitate direct comparison 
turns terms quality implemented algorithms performed better phase optimization algorithm po regardless join graph type gap simulated annealing iterative improvement phase optimization quite narrow 
contrast left deep case genetic algorithm showed slight superiority simulated annealing results case scaled cost number relations genetic sah iij system randomized algorithms left deep tree solution space cycle join graph scaled cost number relations genetic sah iij system randomized algorithms left deep tree solution space grid join graph scaled cost number relations genetic sah po randomized algorithms bushy tree solution space chain join graph bushy tree solution space 
genetic algorithm perform particularly poor quite equal quality simulated annealing phase optimization 
star queries algorithms exhibit similar behaviour divergence just percent algorithms running time decisive factor case 
join graphs bushy tree optimizer easily outperforms best implemented left deep tree optimizer confirms algorithms capable locating superior solutions bushy tree solution space 
look running times different optimizers 
quality generated solutions important characteristic running time algorithm considerable impact final choice 
intended application area determines time spent optimization queries stated interactively run warrant amount optimization compiled queries repeated hundreds thousands times 
average running times genetic sah po system plotted number relations participating queries chain join graph 
running times various algorithms determined sparcstation mp denote cpu time 
randomized genetic algorithms longest running times cpu seconds relation queries 
scaled cost number relations genetic sah po randomized algorithms bushy tree solution space star join graph scaled cost number relations genetic sah po randomized algorithms bushy tree solution space cycle join graph scaled cost number relations genetic sah po randomized algorithms bushy tree solution space grid join graph total running time sec der relationen genetic sah po system total running times cost units running time sec genetic sah po approach final solution phase optimization algorithm po yields slightly better solutions requires running time cpu seconds half time 
expected left deep tree optimizers sah genetic run faster bushy tree optimizers gain speed paid loss quality 
surprisingly algorithm runs faster left deep optimizers yields solutions theirs handle relation queries average just seconds 
contrast randomized genetic algorithms computation optimal left deep tree cartesian products implementation queries involving twelve relations feasible instance thirteen relation queries require average optimization time hour 
algorithms approach respective final solutions shown 
time currently best solution improved gain absolute cost units noted axis time occurrence axis 
single optimization run relation query chain join graph plotted draw far reaching curves reflect algorithms typical behaviour observed quite 
simulated annealing algorithms sah spend deal total running time investigating high cost processing trees required seconds reach cost level times cost final solution 
sah ran faster took long time approach final solution 
hand phase optimization po iterative improvement achieved result resp 
seconds running time 
genetic algorithms especially reach acceptable solutions quickly 
initial population consisted member evaluation cost low running times long 
drawing initial population guaranteed unbiased implementation note genetic algorithms nicely supplement approach section step random sample drawn algorithm second step initial population genetic algorithm 
summary comparing performance various optimization algorithms draw algorithms perform exhaustive near exhaustive enumeration solution space dynamic programming compute optimal result high running time application feasible queries complex fifteen relations left deep processing trees 
reason searching bushy tree solution space carried simple queries experiments relations advantages solution space hardly exploited 
heuristic optimizers avoid high time complexity exhaustive enumeration results especially complex queries participating relations rarely acceptable 
kbz algorithm yielding optimal left deep solution certain circumstances difficult apply practice need cost model approximations problems concerning join method assignment limits usefulness 
star queries kbz algorithm competitive short running time compared alternative algorithms especially randomized genetic solution choice 
randomized genetic algorithms operating bushy tree solution space appropriate optimizers general case provided problems complex tackled exhaustive enumeration 
discussed algorithms adequate depends particular application area short running time best optimization performance primary goal 
solutions highest importance phase optimization algorithm performed best experiments choice simulated annealing variants instance simulated annealing tsa implement achieve quite similar results 
pure simulated annealing algorithm higher running time yielding significantly better solutions 
short running time important iterative improvement genetic algorithm lesser extent phase optimization po feasible alternatives 
especially degrade gracefully preempted example run achieved acceptable results second 
mentioned genetic algorithms combined approach 
studied algorithms optimization join expressions 
due new database applications complexity optimization task increased relations participate join expressions traditional relational database queries 
enumeration possible evaluation plans longer feasible 
algorithms compute approximate solutions heuristic randomized genetic algorithms show different capabilities solving optimization task 
heuristic algorithms compute solutions quickly evaluation plans cases far optimum 
randomized genetic algorithms better suited join optimizations require longer running time results far better 
question adequate solution space exception star join graph bushy tree solution space preferable spite fact pipelining avoiding write intermediate results secondary memory carried mainly left deep processing trees 
consideration extensibility randomized genetic algorithms designed optimize merely pure join expressions complete relational queries 
addition iterative improvement genetic algorithms easily modified parallel computer architectures 
referees valuable comments suggestions earlier draft colleagues countless cpu hours workstations 
partially supported dfg ke sfb 
bfi bennet ferris ioannidis 
genetic algorithm database query optimization 
proc 
fourth intl 
conf 
genetic algorithms pages san diego usa 
en elmasri navathe 
fundamentals database systems 
benjamin cummings redwood city ca usa second edition 
kersten 
fast randomized join order selection transformations 
proc 
conf 
large data bases vldb pages santiago chile september 
gol goldberg 
genetic algorithms search optimization machine learning 
addison wesley reading ma usa 
ik ibaraki kameda 
optimal nesting computing relational joins 
acm trans 
database systems 
ik ioannidis kang 
randomized algorithms optimizing large join queries 
proc 
acm sigmod conf 
management data pages atlantic city usa april 
ik ioannidis kang 
left deep vs bushy trees analysis strategy spaces implications query optimization 
proc 
acm sigmod conf 
management data pages denver usa may 
iw ioannidis wong 
query optimization simulated annealing 
proc 
acm sigmod conf 
management data pages san francisco usa may 
kbz krishnamurthy boral zaniolo 
optimization nonrecursive queries 
proc 
conf 
large data bases vldb pages kyoto japan 
km kemper moerkotte 
access support relations indexing method object bases 
information systems 
km kemper moerkotte 
object oriented database management applications engineering computer science 
prentice hall englewood cliffs nj usa 
kru kruskal 
shortest spanning subtree graph travelling salesman problem 
proc 
amer 
math 
soc 
law lawler 
sequencing jobs minimize total weighted completion time subject precedence constraints 
ann 
discrete math 
valduriez zait 
effectiveness optimization search strategies parallel execution spaces 
proc 
conf 
large data bases vldb pages dublin ireland 
mishra 
join processing relational databases 
acm computing surveys march 
ms monma sidney 
sequencing series parallel precedence constraints 
mathematics operations research 
ol ono lohman 
measuring complexity join enumeration query optimization 
proc 
conf 
large data bases vldb pages brisbane australia 
sac selinger astrahan chamberlin lorie price 
access path selection relational database management system 
proc 
acm sigmod conf 
management data pages boston usa may 
sg swami gupta 
optimization large join queries 
proc 
acm sigmod conf 
management data pages chicago il usa may 
sha shapiro 
join processing database systems large main memories 
acm trans 
database systems september 
si swami iyer 
polynomial time algorithm optimizing join queries 
proc 
ieee conf 
data engineering pages vienna austria april 
swa swami 
optimization large join queries combining heuristics combinational techniques 
proc 
acm sigmod conf 
management data pages portland usa may 
vm vance maier 
rapid bushy join order optimization cartesian product 
proc 
acm sigmod conf 
management data montreal canada june 
wy wong 
decomposition strategy query processing 
acm trans 
database systems 
yw wong 
query processing relational database management system 
proc 
conf 
large data bases vldb pages rio de janeiro 

