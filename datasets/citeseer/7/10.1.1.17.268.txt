modular interpreters sheng liang paul hudak mark jones yale university department computer science new haven ct hudak jones cs yale edu show set building blocks construct programming language interpreters implementations building blocks capable supporting commonly known features including simple expressions different function call mechanisms call name callby value lazy evaluation assignment nondeterminism class continuations program tracing 
underlying mechanism system monad transformers simple form abstraction introducing wide range computational behaviors state continuations exceptions 
significant respects 
succeeded designing fully modular interpreter monad transformers includes features missing steele espinosa wadler earlier efforts 
second new ways lift monad operations monad transformers particular difficult cases achieved moggi original 
third demonstrated interactions features reflected liftings semantics changed reordering monad transformers 
implemented interpreter gofer constructor classes provide just added power haskell type classes allow precise convenient expression ideas 
implementation includes method constructing extensible unions form subtyping interesting right 
related discusses construct programming language interpreters modular components 
show interpreter language features composed building blocks implementing supported advanced research project agency office naval research arpa order contract 
current address department computer science university nottingham university park nottingham ng rd england 
email mpj cs nott ac uk 
appear conference record popl nd acm sigplan sigact symposium principles programming languages san francisco ca january 
specific feature 
interpreter writer able specify set incorporated features high level 
motivation building modular interpreters isolate semantics individual programming language features purpose better understanding simplifying implementing features interactions 
lack separability traditional denotational semantics long recognized 
algebraic approaches mosses action semantics related efforts lee wand appel jim kelsey hudak attempt solve parts problem fall short crucial ways 
ground breaking attempt better solve problem began moggi proposal monads structure denotational semantics 
wadler popularized moggi ideas functional programming community showing type constructors list monads monads variety settings imperative feel peyton jones wadler 
wadler interpreter design treats interpreter monad monolithic structure reconstructed time new feature added 
steele proposed pseudomonads way compose monads build interpreter smaller parts failed properly incorporate important features environment store struggled restrictions haskell type system trying implement ideas 
fact pseudomonads really just special kind monad transformer suggested moggi potential way leave hole monad extension 
returning moggi original ideas espinosa nicely formulated scheme system called semantic lego modular interpreter monad transformers laid issues lifting 
espinosa reminded programming language community including distracted monads moggi responsible ways interest monadic programming focussed importance monad transformers 
realizing limitations moggi framework espinosa implementation particular difficulty dealing complicated operations callcc investigate common programming language fea cartwright felleisen independently proposed modular semantics emphasizing direct semantics approach somewhat complex precise relationship approaches clear 
type term arithmetic functions assignment lazy evaluation tracing callcc nondeterminism type interpm statet store memory cells envt env environment contt answer continuations statet string trace output errort error reporting list multiple results type value int fun modular interpreter tures interact 
doing able express modularity language features previous solving open problems arose moggi steele espinosa 
shares results jones duponcheel composing monads 
independently espinosa continued working monad transformers recognized limitations earlier approaches proposed solution quite different 
new approach relies notion higherorder monads called situated monads relate different layers monad transformers investigated semantic implications order monad transformer composition 
clear new approach relates 
gofer syntax similar haskell 
choose gofer haskell extended type system choose functional language mathematical syntax reasons just concise mathematical syntax emphasizes fact ideas implementable debugged shows relatively new idea constructor classes represent complex typing relationships 
course monads expressed variety higher order programming languages particular sml type system equally capable expressing ideas 
system expressed scheme course lose benefits strong static type checking 
gofer source code available anonymous ftp nebula cs yale edu directory pub yale fp modular interpreter 
appreciate extent results gives high level definition interpreter constructed modular way supports arithmetic different kinds functions call name call value lazy assignment nondeterminism class continuations tracing 
rest provide details type declarations expand full interpreter component built 
just note equivalent domain sum operator term value interpm denote source level terms runtime values supporting features regarded run time system respectively 
int fun semantic domains integers functions 
syntax arithmetic terms function lack space include proofs constructs monads monad transformers liftings expressed gofer code verified satisfy necessary properties stated 
expressions type constructors statet contt monad transformers add features transform monad list monad interpm interpreter 
see term value interpm constitute modular interpreters section walk simple examples 
example conventional interpreter maps say term environment store answer 
contrast monadic interpreter maps terms computations details environment store hidden 
specifically interp term interpm value interpm value interpreter monad final answers 
interpreter modular components term type value type monad configurable 
illustrate initially wish interpreter small arithmetic language fill definitions follows type value int type term type interpm errort id line declares answer domain union integers unit type base type 
second line defines terms syntax arithmetic operations 
final line defines interpreter monad transformation identify monad id monad transformer errort accounts possibility errors case arithmetic exceptions 
point interpreter behaves calculator 

error divide wish add function calls extend value domain function types add syntax function calls term type apply monad transformer envt introduce environment env 
type value int fun type term type interpm envt env errort id lack space omit details parsing printing 
test run 
nx 
error unbound variable adding features arrive go interpreter 
process adding new source level terms new value domain boolean needed extend value type add new semantic feature store continuation apply corresponding monad transformer 
monads 
sense monads example data abstraction 
just happen particularly abstraction disciplined appropriate way generally obtain structured modular programs 
application surprisingly useful essence wide range programming language features abstracting away low level details 
monad transformers put individual features piece piece different orders create full featured interpreters 
constructor class system readers familiar gofer type system particular constructor classes section provides motivating example 
constructor classes support abstraction common features type constructors 
haskell example provides standard map function apply function element list map define similar functions wide range datatypes 
example data tree leaf node tree tree maptree tree tree maptree leaf leaf maptree node node maptree maptree maptree function similar type functionality map 
mind shame different names variants 
gofer allows type variables stand type constructors haskell type class system extended support overloading 
solve problem map introduce new constructor class functor categorical sense class functor map standard list list user defined type constructor tree instances functor instance functor list map map xs map xs instance functor tree map leaf leaf map node node map map interpreters find constructor classes extremely useful dealing multiple instances monads monad transformers type constructors 
extensible union types discussion key idea framework values terms may expressed extensible union types 
facility monads 
disjoint union types captured datatype 
data perform conventional injection summand type union conventional patternmatching projection 
injections projections know exact structure union particular extensible union may arbitrarily nested single pair injection projection functions constructions 
achieve define type class capture summand union type relationship refer subtype relationship class subtype sub sup inj sub sup injection prj sup sub projection data just datatype projection function may fail 
express relationships desire instance subtype inj prj just prj instance subtype subtype inj delta inj prj prj prj see example value domain interpreter example earlier constructed type value int fun type fun interpm value interpm value definitions gofer type system infer int function subtypes value coercion functions inj prj generated automatically 
note representation function quite general maps computations computations 
seen generality allows model call name call byvalue semantics 
point typing problems steele encountered disappear extensible union types particular need steele towers datatypes 
interpreter building blocks example section term type constructed extensible union subterm types 
define additionally class characterize term types wish interpret class interp interpm value behavior interp unions terms obvious way instance interp interp interp interp interp function mentioned opening example just method associated top level type term 
remainder section define representative interpreter building blocks instance class written monadic style 
formally define monads note interpreter monad interpm comes equipped basic operations unit interpm bind interpm 
interpm interpm intuitively interpm denotes computation returning result type unit null computation just returns result bind runs passes result rest computation seen unit bind interpreter building block operations specific purpose 
arithmetic building block tiny arithmetic sublanguage data num int add term term monadic interpretation instance interp num interp add interp ni interp nj int unit delta inj bind na case prj just err run time type error err string interpm defined note simple inj prj inject project integer result value domain regardless value eventually defined tad easier 
err operation reporting errors defined 
function building block function sublanguage data var name name term cbn name term cbv app term term supports kinds abstractions call byname call value 
assume type env environments associates variable names computations corresponding closure mode evaluation operations name env interpm value name interpm value env env type name string addition define monadic operations rdenv inenv return current environment perform computation environment respectively rdenv interpm env inenv env interpm interpm interpretation applicative sublanguage 
difference call value call name clear reduces argument evaluating function body 
function application function evaluated checks function 
computation packaged current environment form closure passed just easily realize dynamic scoping passing closure computation 
applying call value function build computation gets evaluated immediately entering function body 
semantically correct correspond efficient implementation 
practice expect presence kind type information special syntax call value application enable optimize away overhead 
note steele felt unsatisfactory interpreter environment argument function building block 
abstracting environment related operations functions inenv rdenv achieve exactly steele wished 
assignment building block sublanguage assignment data ref term deref term assign term term heap memory cells functions managing interpm loc loc interpm value loc interpm value interpm type loc int give appropriate interpretation new language features instance interp var rdenv bind case env just val val err unbound variable interp rdenv bind inenv arg env interp interp rdenv bind arg bind nv inenv unit env interp interp app interp nf rdenv bind inenv env interp function building block instance interp ref interp bind bind loc unit val bind loc interp deref interp loc interp assign lhs rhs interp lhs interp rhs bind loc unit val bind unit val lazy evaluation building block heap memory cells implement lazy abstractions data name term operational semantics implies caching results 
instance interp rdenv bind bind thunk arg bind nv loc unit bind unit loc thunk bind inenv loc env interp entering lazy function interpreter allocates memory cell stores thunk updatable closure 
argument evaluated function body interpreter evaluates thunk stores result back memory cell overwriting thunk 
program tracing building block function write string interpm writes string output continues computation define tracing sublanguage attaches labels expressions cause trace record invoked expression evaluated data trace string term instance interp trace write enter bind interp bind nv write leave show bind unit see features system easily incorporated interpreter 
continuation building block class continuations included language data callcc callcc semantic function defined callcc interpm interpm interpm give interpretation callcc instance interp callcc nf nf callcc nk 
na bind callcc interpreted strict builtin function 
interp case inject project values right domains 
feature function error handling err string interpm nondeterminism merge interpm interpm environment rdenv interpm env inenv env interpm interpm store interpm int int interpm value int interpm value interpm int string output write string interpm continuations callcc interpm interpm interpm table monad operations interpreter nondeterminism building block nondeterministic sublanguage data amb term function merge interpm interpm merges list computations single nondeterministic computation nondeterminism interpretation expressed instance interp amb merge map interp monads operations mentioned earlier particular monads operations unit bind 
section clear operations listed table supported 
building interpreter traditional way time set domains implement functions listed table 
major drawback monolithic approach take account features define operation specific feature 
define callcc example decide interacts store environment want add features semantic domains functions table updated 
monad transformers hand allow individually capture essence language features 
furthermore concept lifting allows account interactions various features 
topics sections 
simplify set operations somewhat note store output tracer notion state 
define write terms just function update interpm suitably chosen read state passing update identity function change state passing state transformer 
example write msg update sofar sofar msg bind unit monad transformers get intuitive feel monad transformers consider merging state monad arbitrary monad example adapted jones constructor class type statet note type variable stands type constructor fact automatically determined gofer kind inference system 
turns monad statet 
statet monad transformer 
example substitute identity monad type id monad transformer arrive statet id id 
standard state monad example wadler 
power monad transformers fold 
add operations introduce new features monad 
statet monad transformer example adds state monad applied resulting monad accepts update legitimate operation 
second monad transformers compose easily 
example applying statet statet identity monad get statet statet id 
statet id 
expected type signature transforming states reader note immediate problem resulting monad state update act 
general problem lifting monad operations transformers addressed detail 
define monads monad transformers formally describe monad transformers covering features listed section 
formally define monads follows fact statet legal current version gofer statet datatype type synonym 
limit results introduce superfluous data constructors slightly complicate presentation type declarations worked data declarations 
class monad unit bind 
map join map bind na unit join bind id functions map join unit provide equivalent definition monads easily defined default methods terms bind unit 
monad bind unit satisfy known monad laws left unit unit bind right unit bind unit associativity bind na 
bind bind bind define monad transformer type constructor monad laws 
express verification laws generally undecidable constructor class monadt class monad monad monadt lift member function lift embeds computation monad monad 
furthermore expect monad transformer add features changing nature existing computation 
introduce monad transformer laws capture properties lift lift delta unitm lift bindm lift lift delta laws say lifting null computation results null computation lifting sequence computations equivalent lifting individually combining lifted monad 
specific monad transformers described remainder section 
statet contt errort appear form moggi note 
environment monad similar state reader wadler 
state environment monad transformers related ideas jones duponcheel 
state monad transformer recall definition state monad transformer statet type statet instance declarations wish declare statet monad monad statet monad transformer monad transformers defined subsequent subsections exactly thing 
establish monad definition statet involving methods unit bind instance monad monad statet unit ns unit bind ns bind note definitions recursive constructor class system automatically infers bind unit appearing right monad define statet monad transformer instance monad monad statet monadt statet lift ns bind nx unit note lift simply runs new context preserving state 
explained earlier state monad support operation update 
keep things modular define class state monads class monad statemonad update particular statet transforms monad state monad update applies state returns old state instance monad statemonad statet update ns unit environment monad transformer envt transforms monad environment monad 
definition bind tells subsequent computation steps run environment 
compare state monad second computation run state returned computation 
lift just performs computation depend environment ignores environment 
inenv ignores environment carried inside monad performs computation environment 
type envt instance monad monad envt unit nr unit bind nr bind na instance monad monad envt monadt envt lift nr class monad env inenv env rdenv env instance monad envt inenv rdenv nr unit error monad transformer monad error completes series computations succeed aborts soon error occurs 
monad transformer errort transforms monad error monad 
data error ok error string type errort error instance monad monad errort unit unit delta ok bind bind na case ok error msg unit error msg instance monad monad errort monadt errort lift map unit class monad err string instance monad errort err unit delta error continuation monad transformer define continuation monad transformer type contt ans ans ans instance monad monad contt ans unit nk bind nk na contt introduces additional continuation argument type ans definitions unit bind computations monad contt ans carried continuation passing style 
lift cont ans turns bind 
easy see type signature 
callcc invokes computation passing continuation applied throws away current continuation denoted invokes captured continuation instance monad monad contt ans monadt contt ans lift bind class monad callcc instance monad contt ans callcc nk na list monad jones duponcheel shown lists compose special kinds monads called commutative monads 
clear lists compose arbitrary monads 
useful monads state error continuation monads commutative define list monad transformer adds operation merge monad 
fortunately monad transformer considered takes arbitrary monads 
lists base monad transformers applied 
instance monad list unit bind xs bind xs bind class monad merge instance list merge concat lifting operations introduced monad transformers add useful operations monad addressed operations carried layers monad transformers equivalently monad transformer lifts existing operations monad 
lifting operation monad monad transformer results operation type signature derived substituting occurrences type 
example lifting inenv results operation type 
types operations monad type constants type variables 
function types product types monad types de mapping types monad transformer dae dae dm de moggi studied problem lifting categorical context 
objective identify liftable operations type signatures 
unfortunately useful operations merge inenv callcc failed meet moggi criteria left unsolved 
individually consider lift difficult cases 
allows definitions just types find ways lift monad transformers studied far 
exactly monad transformers provide opportunity study various programming language features interact 
easy lift cases correspond features independent nature involved cases require deeper analysis monad structures order clarify semantics 
unfortunate consequence approach consider monad transformers number possible liftings grows quadratically 
different kinds monad transformers may instances monad transformer statet 
introduced far able model commonly known features sequential languages 
strictly necessary 
environment example simulated state monad instance monad statemonad inenv update bind bind nv update bind unit rdenv update id known error reporting implemented callcc 
correctness criteria basic requirement lifting program added features behave way monad transformer applied 
monad transformer laws introduced section meant guarantee property lifting single computation 
monad operations general types 
deal operations arbitrary types extend moggi corresponding categorical approach define natural lifting operations type monad transformer de la id la id nf delta delta 
lm lift delta map constant types integer type variables depend particular monad 
see cases 
hand expect lifted function applied value lifted domain original function return lifting result applying original function value 
relationship precisely captured equation corresponds commuting diagram lifting tuples straightforward 
lift operator come monad transformer lifts computations expressed monad types 
note mapped result computation may involve computations 
note provide gofer definition overloaded lifting function clause third equation specifies constraint definition practice find hand lift operation certain class monad transformer equations verify lifting natural 
generally require operations lifted naturally seen certain unnatural liftings change semantics interesting ways 
easy cases err update handled lift merge benefits list base monad 
instance monadt err lift delta err instance statemonad monadt statemonad update lift delta update instance monadt list list merge join delta lift lifting callcc lifting callcc envt discards current environment invoking captured continuation execution continue environment captured callcc invoked 
instance monadt envt envt callcc callcc nr callcc nk na nr appendix shows flip order monad transformers apply contt envt env case lifting callcc necessary current environment passed continuation 
see fix carefully recovering environment lift inenv moment 
general swap order monad transformers statet envt doing contt may effect semantics 
consistent filinski observations practice provides opportunity fine tune resulting semantics 
lifting callcc statet choice passing current state captured state usual semantics callcc useful tolmach appel approach debugging 
instance monadt statet statet callcc callcc ns callcc nk na ns shows usual callcc semantics changed debugging version passing lifting inenv errort appendix 
lifting inenv consider lifting inenv contt appendix shows lift inenv monad transformers 
instance monadt contt ans contt ans inenv nk rdenv bind inenv inenv delta rdenv lift rdenv restore environment invoking continuation sort popping arguments stack 
hand interesting natural way lift inenv instance monadt contt ans contt ans inenv nk inenv rdenv lift rdenv environment restored invokes reflects history dynamic execution 
shown modular monadic interpreter designed key ideas extensible union types monad transformers implemented constructor classes 
key technical problem overcome lifting operations monads 
approach helps clarify interactions various programming language features 
realized moggi idea modular presentation denotational semantics complicated languages cleaner traditional approach 
practical side results provide new insights designing implementing programming languages particular extensible languages allow programmer specify new features top existing ones 
dan rabin zhong shao rajiv anonymous referees helpful suggestions 
andrew appel trevor jim 
continuationpassing closure passing style 
acm symposium principles programming languages pages january 
bloss paul hudak jonathan young 
code optimization lazy evaluation 
lisp symbolic computation 
robert cartwright matthias felleisen 
extensible denotational semantics 
proceedings symposium theoretical aspects computer software pages 
david espinosa 
modular denotational semantics 
unpublished manuscript december 
david espinosa 
building interpreters transforming stratified monads 
unpublished manuscript ftp ai mit edu pub dae june 
andrzej filinski 
representing monads 
conference record popl st acm sigplan sigact symposium principles programming languages portland oregon pages new york january 
acm press 
paul hudak simon peyton jones philip wadler 
report programming language haskell nonstrict purely functional language version 
technical report yaleu dcs rr yale university department computer science march 
acm sigplan notices vol 
may 
mark jones 
gofer 
ftp nebula cs yale edu directory pub haskell gofer september 
mark jones 
system constructor classes overloading implicit higher order polymorphism 
fpca conference functional programming languages computer architecture copenhagen denmark pages new york june 
acm press 
mark jones luc duponcheel 
composing monads 
research report yaleu dcs rr yale university department computer science new haven connecticut december 
richard kelsey paul hudak 
realistic compilation program transformation 
acm symposium principles programming languages pages january 
amir paul hudak charles consel 
monitoring semantics formal framework specifying implementing reasoning execution monitors 
proceedings acm sigplan conference programming language design implementation pages june 
peter lee 
realistic compiler generation 
foundations computing 
mit press 
robin milner mads tofte robert harper 
definition standard ml 
mit press 
eugenio moggi 
view programming languages 
technical report ecs lfcs laboratory foundations computer science university edinburgh edinburgh scotland 
peter mosses 
basic semantic algebra 
gilles kahn david macqueen gordon plotkin editors semantics data types international symposium sophia antipolis france pages 
springer verlag june 
lecture notes computer science 
simon peyton jones philip wadler 
imperative functional programming 
proceedings th symposium principles programming languages pages 
acm january 
guy steele jr building interpreters composing monads 
conference record popl st acm sigplan sigact symposium principles programming languages portland oregon pages new york january 
acm press 
joseph stoy 
denotational semantics scott strachey approach programming language theory 
mit press 
andrew tolmach andrew appel 
debugging standard ml reverse engineering 
proceedings acm conference lisp functional programming nice france june 
philip wadler 
essence functional programming 
conference record nineteenth annual acm symposium principles programming languages albuquerque new mexico pages january 
philip wadler 
comprehending monads 
proceedings acm conference lisp functional programming 
mitchell wand 
semantic prototyping system 
sigplan notices acm symposium compiler construction 
ordering contt envt interesting compare callcc functions monad composed contt ans envt different order 
case type contt ans envt ans ans callcc nk na eta convert nr nr nk nr na nr case type envt contt ans 
ans ans callcc nr callcc nk na nr nr nk 
nk na nr na nr nk na nr expansion type case see result environment passed continuation 
callcc invokes continuation passes current captured continuation 
callcc function case works opposite way 
lifting callcc errort instance monadt errort errort callcc error error error callcc callcc nk na ok lifting inenv envt statet errort instance monadt envt envt inenv nr inenv rdenv lift rdenv instance monadt statet statet inenv ns inenv rdenv lift rdenv function type maps error error inenv stays lifted errort 

