appears technical memo mit lcs tm mit laboratory computer science june correctness proof practical byzantine fault tolerant replication algorithm miguel castro barbara liskov laboratory computer science massachusetts institute technology technology square cambridge ma lcs mit edu developed practical algorithm state machine replication tolerates byzantine faults 
algorithm described 
offers strong safety property implements linearizable object operations invoked object execute atomically despite byzantine failures concurrency 
previous algorithms works correctly asynchronous systems internet incorporates important optimizations enable outperform previous systems order magnitude 
byzantine fault tolerant algorithms subtle important reason formally 
presents formal specification unoptimized version algorithm section proves safety liveness 
specification uses automaton formalism tuttle lynch proof invariant assertions simulation relations 
specification proof interesting novel properties independent algorithm 
automaton formalize correct behavior byzantine fault tolerant object implementation 
technique benign failures believe byzantine faults 
advantage automaton formalize correct behavior enables state proof techniques simulation relations 
techniques stylized trace proof techniques convincing amenable machine verification 
second formalization accounts byzantine faults replicas clients 
trace formalization linearizability presence byzantine faulty clients proposed 
formalization advantage enables simulation relations 
differs authentication access control explicit formalization 
access control powerful defense byzantine faulty clients 
research supported part darpa contract monitored air force research laboratory part nec 
assumes reader familiar automata invariant assertions simulation relations 
lynch book provides description formalism proof techniques 
third structure proof assumptions authenticated communication isolated small number invariants proofs small number simulation steps 
leads simpler proof 
organized follows 
section presents high level model system assumptions 
section formalizes correctness condition algorithm simple automaton specification correct behavior 
section defines automata compose replicated system implementation 
attempt explain algorithm 
reader referred natural language description algorithm easier understand 
section proves safety algorithm invariant assertions simulation relations show implements automata defined section implement simplified version algorithm garbage collect information 
section defines version algorithm garbage collection proves safety simulation relation show implements simplified version algorithm 
model goal algorithm provide byzantine fault tolerant implementation atomic object variable type atomic object implementation uses replication enable concurrent sharing variable clients distributed system 
ensures linearizability operations invoked variable execute atomically despite byzantine failures concurrency 
start defining variable type describe architecture atomic object implementation 
variables type value set initially equal behavior defined function arguments function client identifier operation set encodes operation identifier arguments operation initial value 
arguments mapped result operation new value variable 
require total 
achieved practice having map pairs invalid operation pair error result argument value 
client identifier included explicitly argument clear return different results different clients 
particular perform access control client allowed perform argument operation return special access error leave variable value unmodified 
additionally access control depend state service allowing atomic access revocations 
access control access important defense byzantine faulty clients 
model atomic object implementation clients set automata 
client unique identifier set modeled client automaton composition clients denoted atomic object automaton composition types automata proxy multicast channel replica 
shows architecture system presents external interface node node request reply request reply client failure client failure mc node node implementation architecture replica failure replica failure proxy automaton client provides input action client invoke operation shared variable request ouput action learn result operation requested reply communication involve network assumed execute node distributed system 
communicates set server replicas implement interface offers client 
replica unique identifier set modeled automaton assume jrj positive integer threshold maximum number replica faults tolerated system 
resiliency algorithm optimal minimum number replicas allow asynchronous replication system implement atomic object replicas faulty see proof 
assume replicas execute different nodes distributed system 
communication proxy set replicas replicas performed multicast channel automaton mc 
automata access state components automata running nodes distributed system 
multicast channel automaton mc may fail deliver messages may delay duplicate deliver order 
assume synchrony 
nodes part asynchronous distributed system known bounds message delays time automata take enabled actions 
byzantine failure model faulty automata may behave arbitrarily restrictions discussed 
client failure replica failure actions model client replica failures 
failure action occurs corresponding automaton replaced arbitrary automaton external interface remains faulty rest execution 
assume arbitrary automaton state component called faulty set true 
important understand failure actions faulty variables formally model failures correctness proof algorithm know client replica faulty 
input request client replica output reply external signature allow strong adversary coordinate faulty nodes delay communication delay correct nodes order cause damage replicated service 
assume restrictions adversary faulty nodes controls automata unforgeable digital signatures authenticate communication collision resistant hash functions 
assumptions defined detail 
unforgeable signatures non faulty client proxy replica automaton authenticate messages sends multicast channel signing 
denote message signed hmi high probability automaton send hmi directly part message multicast channel value collision resistant hash functions automaton compute digest message high probability impossible find distinct messages 
assumptions probabilistic exist signature schemes hash functions believed hold high probability 
assume hold probability rest 
correctness condition specify correct behavior automaton external signature say correct implements simple atomic object variable type defined follows signature input request client replica internal execute faulty request output reply andr state val initially vo initially fg initially fg req initially req rep initially rep faulty client bool initially faulty client false faulty replica bool initially faulty replica false faulty jf faulty replica true gj transitions faulty request eff req req req cig client eff faulty client true replica eff faulty replica true reply pre faulty client true hr ci eff cig faulty request pre faulty client true eff cig execute pre ho ci eff cig rep val val cig rep definition self explanatory issues deserve clarification 
model fact behave correctly replicas byzantine faulty behavior left unspecified faulty may behave arbitrarily restriction faulty client faulty replica variables value true modified 
faulty request actions model execution requests faulty clients bypass external signature injecting appropriate messages multicast channel 
similarly reply precondition weaker faulty clients allow arbitrary replies clients 
req component distinguish requests execute operation rep remembers value req associated operation executed models formedness condition non faulty clients expected wait reply requested operation issue request 
requests may execute client may unable match replies requests 
system section defines multicast channel proxy replica automata 
multicast channel automaton multicast channel automaton models communication network connecting proxy replica automata 
single multicast automaton system send receive actions proxy replica 
actions allow automata send messages universal message set subset automata identifiers channel automaton provide authenticated communication receive actions identify sender message 
defined follows 
signature input send internal misbehave output receive andx state wire initially fg transitions send eff wire wire receive pre wire eff wire wire fxg misbehave pre wire eff wire wire misbehave actions allow channel loose messages duplicate receive actions defined messages may reordered 
additionally automaton defined message sent channel remembered replayed 
proxy automaton client interacts atomic object proxy automaton defined follows 
signature input request receive ri client output reply send andx state initially initially fg initially fg req initially bool initially false faulty bool initially false transitions request eff req req req ci cg fg false receive ri eff fg req ri ig client eff faulty true reply pre fg jrj req ri eff max req ri fg send mod pre eff true send pre eff replica automaton replica automaton defined follows 
signature state input receive ci receive hpre prepare mi receive hprepare ji receive ji receive hview change ji receive hnew view ni replica internal send pre prepare send commit execute view change send new view output send fd vali initially vo initially ini initially fg outi initially fg initially null rep rep ti initially rep ti initially initially bool initially false auxiliary functions tag hu primary mod jrj primary mod jrj prepared hpre prepare mi primary jrj primary hprepare ki prepared prepared ini prepared prepared prepared prepared prepared prepared ini committed hpre prepare mi primary ini ini jrj ki ini correct view change hview change ji hpre prepare primary prepared merge hview change ki max max prepare mi mg correct new view hnew view ni primary jv jrj correct view change prepare primary prepared merge prepare primary max prepared merge new view ini correct new view input transitions receive ci eff ci rep outi outi rep ig ini ini fmg primary outi outi fmg receive hpre prepare mi eff primary new view hprepare ii ini hprepare ii ini ini prepare mi pg outi outi fpg ci ini ini fmg receive hprepare ji eff primary ini ini ji receive ji eff ini ini ji receive hview change ji eff hview change ji correct view change ini ini fmg receive hnew view ni eff hnew view ni ii prepare correct new view new view ini ini fmg outi replica eff faulty true output transitions send fig pre outi tag request tag reply eff outi outi fmg send pre outi tag request eff outi outi fmg send ri fcg pre ri outi eff outi outi ri ig internal transitions send pre prepare pre primary seqno new view ci ini hpre prepare mi ini eff seqno seqno hpre prepare mi outi outi fpg ini ini fpg send commit pre prepared ii ini eff ii outi outi fcg ini ini fcg execute pre committed eff null ci rep rep rep rep vali vali outi outi rep ig ini ini fmg send view change pre eff fhm prepared hm ni fp hprepare ki prepare mi primary hview change ii outi outi fmg ini ini fmg send new view pre primary ini jv new view jrj hview change ki eff prepare mi ij prepared merge prepare null ki ijn max prepared merge hnew view ni seqno max ini ini fmg outi fmg safety proof section proves safety algorithm proves implements proving invariants 
invariant true reachable state execution tag reply hmi inj hview change ki inj hmi hnew view ni inj hmi hmi merge hmi ini true replaces fm proof reachable state message value reply message replica faulty state hmi hmi additionally hmi true state execution remains true subsequent states execution faulty 
inspection code automaton conditions true action inserts message hmi inserts action removes message signed assumption strength authentication guarantees automaton impersonate non faulty replica sending hmi values multicast channel 
signed message hmi state component non faulty automaton necessary send hmi executed value earlier point execution 
precondition execution send action requires hmi conditions prove invariant 
invariant true reachable state execution replica faulty false 
hprepare ii ini hprepare ii ini 
primary hpre prepare mi ini hpre prepare ini 
hpre prepare mi ini primary seqno 
hpre prepare mi primary ini hnew view ni primary ini correct new view 
hnew view ni primary ini correct new view 
hview change ji ini correct view change 
hprepare ii ini hpre prepare mi primary ini 
hpre prepare mi primary ini primary hprepare ii ini 
hpre prepare mi primary ini proof proof induction length execution 
initializations ensure ini fg conditions vacuously true base case 
inductive step assume invariant holds state execution length show invariant holds step extension condition violated action may insert prepare message signed ini executes 
actions form 
receive hpre prepare 
receive hprepare ji 
receive hnew view ni type action violate condition condition statement ensures hprepare ii inserted exists hprepare ii similarly second type action violate condition inserts argument prepare message signed replica case actions type effects state ri 
case apply inductive hypothesis conditions conclude existed hprepare ii ini state exist new view message view ini state 
precondition actions type prevent executing state 
actions type may insert multiple prepare messages signed ri ini chance violate condition 
happen actions enabled argument new view message correct definition correct new view ensures pre prepare message sequence number condition violated execution action types 
receive hpre prepare 
receive hnew view ni 
send pre prepare 
send new view actions types violate condition insert pre prepare messages signed actions third type violate condition inductive hypothesis condition precondition send pre prepare action ensure pre prepare message inserted sequence number higher sequence number pre prepare message view signed actions fourth type violate condition 
enabled 
inductive hypothesis condition precondition send new view action ensure pre prepare view action executes definition ensures pre prepare message sequence number condition potentially violated actions insert pre prepares modify seqno exactly actions types listed condition 
actions types violate condition insert pre prepare messages signed modify seqno send pre prepare action preserves condition increments seqno equal sequence number pre prepare message inserts send new view actions preserve condition shown actions type execute pre prepare view execute set seqno max equal sequence number pre prepare view highest sequence number violate condition action insert pre prepare message remove new view message action removes new view messages actions may insert pre prepare messages exactly actions types listed condition 
type action list violate condition statement body ensures argument pre prepare message inserted new view true 
second type action inserts pre prepare messages view argument new view message correct case inserts argument new view message second type action preserves condition 
precondition send pre prepare actions ensures send pre prepare actions preserve condition 
send new view actions preserve condition effects inductive hypothesis condition ensure correct new view message view inserted pre prepare view inserted conditions violated 
received new view view change messages checked correctness inserted second effects send actions inductive hypothesis condition precondition send view change actions ensure correct view change messages inserted third inductive hypothesis condition effects send new view actions ensure correct new view messages inserted condition violated action removes pre prepare actions insert hprepare ii actions form receive hpre prepare receive hnew view ni insert hpre prepare mi primary condition violated actions insert pre prepare messages prepare messages removed exactly actions listed condition 
types actions preserve condition insert pre prepare message insert matching prepare message 
types actions violate condition insert pre prepare messages views primary actions violate condition actions insert pre prepare messages view smaller 
actions view smaller actions may violate condition exactly listed condition 
statement type action ensures inserts pre prepare messages view number equal view statement second type action ensures inserts pre prepare messages view number greater equal view types actions preserve invariant 
precondition third type action effects fourth type action ensure pre prepare messages view number equal view inserted types actions preserve invariant 
definition faulty jfi invariant true reachable state execution faulty faulty faulty prepared prepared proof contradiction assume invariant hold 
prepared true prepared true values 
replicas condition definition prepared predicate imply jrj hpre prepare mi primary hprepare ki hpre prepare primary hprepare ki faulty replicas size condition implies faulty false hpre prepare mi primary hprepare ki hpre prepare primary hprepare ki invariant imply faulty false hpre prepare mi primary hprepare ki hpre prepare primary hprepare ki condition contradicts invariant conditions 
invariant true reachable state execution faulty faulty hnew view ni ini prepared merge prepared merge proof invariant condition ensures new view message non faulty satisfies correct new view proof invariant minor modifications 
invariant true reachable state execution faulty ii ini prepared true proof proof induction length execution 
initializations ensure fg condition vacuously true base case 
inductive step actions violate condition insert commit messages actions form receive ji send commit actions type violate lemma insert commit messages signed replicas precondition send commit actions ensures insert ii prepared true 
invariant true reachable state execution faulty committed jrj faulty faulty false prepared proof definition committed predicate committed true implies jrj ki 
invariant implies jrj faulty faulty false ki 
invariant prove invariant 
invariant true reachable state execution replica faulty false 
hview change ii prepared prepared 
hnew view ni primary prepared defined follows prepared prepared prepared prepared 
proof proof induction length execution 
initializations ensure ini fg condition vacuously true base case 
inductive step actions violate condition insert view change messages ini insert pre prepare prepare messages ini prepare message removed ini 
actions schemas 
receive hview change ji 
view change 
receive hpre prepare 
receive hprepare ji 
receive hnew view ni 
send pre prepare 
send new view actions type violate lemma insert view change messages signed replicas effects actions second type ensure view change message hview change ii inserted condition true prepared prepared 
condition invariant condition imply condition invariant 
types actions assume exists view change message signed types actions executes lemma vacuously true pick hview change ii inductive hypothesis ensures condition holds actions execute prepared prepared sufficient prove actions preserve condition 
logical value prepared change view change messages immutable 
prove value prepared preserved prove invariant reachable state execution non faulty replica ri view change message hview change ii ini proof induction length execution 
vacuously true base case 
inductive step actions violate actions insert view change messages signed actions view smaller 
actions view smaller actions form view change effects actions form ensure invariant preserved setting view view number view change message 
easy see types actions violate condition lemma 
insert pre prepare prepare messages view number equal view action executes 
invariant guarantees view greater equal view number view change message actions change value prepared condition lemma violated actions insert new view messages remove pre prepare messages action removes pre prepare messages actions violate condition receive hnew view ni send new view type action preserves condition inserts pre prepares inserts argument new view message second type action preserves condition similar way 
invariant true reachable state execution faulty faulty jrj faulty prepared hpre prepare primary ini proof proving invariant directly prove condition true faulty faulty jrj faulty prepared hnew view ni primary ini hpre prepare mi primary condition implies invariant 
invariant condition states pre prepare message view correct new view message view 
correct new view message hnew view ni primary invariant condition implies condition imply hpre prepare mi primary invariant conditions implies different pre prepare message sequence number view proof induction number views base case condition vacuously true 
inductive step assume condition holds show holds assume exists new view message hnew view primary ini vacuously true 
invariant condition message verify correct new view 
implies contain correct view change messages view replicas set 
assume condition true jrj faulty false prepared true vacuously true 
replicas intersect replica replica faulty call replica view change message hview change ki non faulty prepared true invariant implies prepared true 
conditions true 
prepared 
prepared condition implies invariant inductive hypothesis implies second case 
invariants imply prepared condition invariant fact correct new view true imply conditions true 
prepared merge 
prepared merge case obviously true 
case holds invariant invariant condition imply exists non faulty replica hpre prepare primary condition implies invariant inductive hypothesis implies second case 
invariant true reachable state execution faulty jrj prepared jr prepared proof assume loss generality case negation invariant implies exist requests sequence number non faulty replicas prepared true prepared true contradicts invariant 
assume invariant false 
negation invariant definition prepared predicate imply faulty jrj faulty prepared faulty hpre prepare primary ini contradicts invariant long probability negligible 
invariant true reachable state execution faulty faulty faulty committed committed invariant true reachable state execution faulty faulty committed jr faulty prepared proof invariant implied invariants 
proving implements directly prove implements implements better suited proof 
start defining set auxiliary functions useful proof 
definition define functions inductively val rep 

rep 
val rep null rep rep val hn ci rep hn ci rep hn ci rep hn ci rep rep hn ci rep val automaton signature addition internal action execute null 
state components val component replaced sequence operations hist initially new seqno component seqno initially 
similarly transitions defined faulty transitions identical defined bellow 
execute pre ho ci eff seqno seqno cig rep hist hist hist ci rep cig execute null eff seqno seqno execute null actions allow seqno component incremented removing tuple 
useful model execution null requests 
theorem implements proof proof uses forward simulation defined follows definition subset states states element written conditions satisfied 
state components name equal 
val val hist 
rep rep hist prove fact forward simulation prove true 

start start fg 
trans wherex reachable state reachable exists execution fragment starting trace trace 
clear verifies condition variables name initialized values hist initially equal val val rep rep 
case analysis show second condition holds acts 
actions execute null consist single step 
execute null clear satisfies second condition actions execute 
execute definition inductive hypothesis val val hist rep rep hist ensure 
definition define function prefix 
follows prefix subsequence obtained removing tuples component greater invariant true reachable state execution hn ci hist rep prefix hist proof proof induction length execution 
initial states verify condition vacuously hist initially inductive step actions violate invariant modify hist execute 
actions modify hist rep hist 
invariant true reachable state execution 
hn ci hist faulty req 
ho ci faulty req proof proof induction length execution 
initial states verify condition vacuously hist initially empty 
inductive step action decrements req changes faulty true false actions violate invariant append tuples non faulty client hist execute request 
execute actions append tuple hn ci hist ho ci inductive hypothesis condition implies preserve invariant 
request actions preserve invariant tuple ho ci inserted equal value req action executes 
theorem implements proof prove implements implies implements theorem 
proof uses forward simulation equal output actions external signature hidden 
defined follows 
definition subset states states element satisfied 
faulty faulty replica 
faulty faulty client satisfied faulty 
faulty req req 
faulty seqno 
faulty vali val prefix hist 
faulty rep rep prefix hist 
faulty rep rep prefix hist 
seqno hn ci hist jrj faulty faulty prepared ci jrj faulty rep prefix hist faulty prepared ci jrj faulty faulty prepared 
ri outi faulty hn ci hist rep prefix hist 
hn req ci hist faulty fg rep prefix hist req ci 
mc faulty ini merge fm hview change ji jjm mc hnew view ni mc faulty ci mc hpre prepare mi mc ho ci hn ci hist note conditions definition need hold faulty faulty relation behavior unspecified 
prove fact forward simulation prove true 

start start fg 
trans wherex reachable state reachable exists execution fragment starting trace trace 
easy see condition holds 
case analysis show second condition holds acts non faulty proxy actions 
request client failure reply consist single step 
preserved trivial way client failure action 
request action modify variables involved conditions definition 
condition preserved increment req condition preserved invariant implies tuples hist timestamp req add tuple hist 
inserts new request condition preserved inserts ho ci 
reply action enabled action enabled 
faulty replicas precondition ensures nonfaulty replica view req ri fg 
inductive hypothesis conditions implies hr ci reply enabled 
preserved ensures fg 
receive send preserves preconditions require reply message received tuple wire request message sent internal channel actions 
misbehave action preserved add new messages wire retains tuple wire 
non faulty replica actions 
actions replica failure execute clear violate conditions actions modify state components involved conditions 
violate condition messages removed non faulty replica prepared true remains true entire execution replica faulty 
actions violate conditions request reply messages add wire directly part messages wire replica failure consist single step 
violate conditions definition conditions change variables involved conditions vacuously true 
condition satisfied trivial way sets faulty replica true 
condition violated size sets condition allowed decrease additional replicas faulty 
non faulty replica execute non null request 
execute ci cases exec seqno consist execution single execute action faulty request case faulty true 
cases clear conditions violated 
case conditions preserved trivial way 
conditions consider cases rep 
precondition ensures committed ci true 
case precondition invariant definition condition imply tuple hist sequence number equal hn ci 
conditions preserved 
case precondition invariant definition condition invariant imply tuple sequence number hist 
conditions preserved case 
case enabled actions enabled case faulty faulty request enabled execution enables execute 
condition definition precondition imply execute enabled easy see conditions preserved 
condition consider cases rep 
cases precondition ensures committed ci true 
precondition invariant fact appends tuple hy seqno ci hist ensure condition preserved case 
case precondition invariant assumption rep ensure condition preserved case 
non faulty replica execute null request 
execute null ifx exec seqno consist execution single execute null action 
execution null request increments exec increment seqno 
conditions violated 
condition violated increments seqno case exec seqno 
case conditions violated append new tuple hist tuples hist sequence number seqno prefix hist exec prefix hist exec 
precondition implies committed null true invariant ensures condition preserved case 
case consists execute null step committed null faulty invariant definition condition imply tuple hist sequence number exec prefix hist exec prefix hist exec 
faulty replica actions 
action faulty replica faulty true modify faulty faulty replica forge signature non faulty automaton preserves trivial way 
faulty proxy actions 
action faulty proxy faulty true consist single step request reply client failure actions actions 
modify faulty faulty clients forge signatures non faulty automata preserves trivial way 
additionally reply action enabled enabled garbage collection section describes modified version algorithm garbage collects messages replica logs 
proves modified algorithm gc safe proves implements modified algorithm client proxy multicast channel automata identical gc replica automaton modified follows 
signature remains actions listed 
input receive ji receive hview change ji internal collect fd state components remain addition new variable new initial value ini initially hv null rep ki rg initially fh hv null rep iig stable ni min fn ig stable ni auxiliary functions description replica automaton remain defined stable ni max wv correct view change hview change ji jrj ki hpre prepare primary prepared max merge hview change ki max max prepare mi hview change ii mg correct new view hnew view ni primary jv jrj correct view change prepare primary max prepare primary max max prepared merge take mod int int int max update state nv max stable ni ini ini pick hview change max ki ini ini ini max ii ig outi outi max ii ig max ii prepared merge fp hn max max sij hview change max ki vali rep rep stable max actions automaton modified new functions remain identical 
exceptions listed input transitions prepare mi eff primary wv new view hprepare ii ini hprepare ii ini ini prepare mi pg outi outi fpg ci ini ini fmg receive hprepare ji eff primary wv ini ini ji receive ji eff ini ini ji receive ji eff ini ini ji jg receive hview change ji eff hview change ji correct view change ini ini fmg receive hnew view ni eff hnew view ni correct new view new view outi fg ini ini fmg hpre prepare outi outi ii ig stable ni ini ini ii ig update state nv ini ini ci rep internal transitions send pre prepare pre primary seqno wv new view ci ini hpre prepare mi ini eff seqno seqno hpre prepare mi outi outi fpg ini ini fpg execute pre committed eff null ci rep rep rep rep vali vali outi outi rep ig ini ini fmg take rep rep ii ii outi outi fm ini ini fm fhn rep rep send view change pre eff fhm prepared hm ni fp hprepare ki prepare mi primary fm stable ni stable ki hview change stable ni stable ii outi outi fmg ini ini fmg send new view pre primary ini jv new view jrj hview change ki eff prepare mi ijn max prepared merge prepare null ki max prepared merge hnew view ni seqno max ini ini fmg outi fmg update state nv ini ini ci rep collect pre jrj ki ini eff ini ini fm hpre prepare jjm ini ng ini ini fm hprepare ji jjm ini ng ini ini fm ji jjm ini ng ini ini fm ji jjm ini ng fp hn ng safety proof section proves gc implements start introducing definitions proving invariant 
definition define functions inductively rm ci cg val rm rep rm 

rep rm 
val vo rep null rep rep rm val null val rep null rep rep null rep ci rm rm rep ci rep rep ci rep rep val val ci rep ci rep ci val ci val rep ci rep rep ci rep definition define subsets predicate wire wire wire wire wire io wire inj committed wire mn rm val rep rep jrj mk qi wire hpre prepare primary wire mk wire invariant true reachable state execution gc 
faulty faulty rm committed wire val rep rep exec view 
faulty faulty hs ti ii rm committed wire wire io hview change ji wire io hnew view ni wire io hview change qi proof proof induction length execution 
base case initializations ensure vali val rep rep rep rep 
obviously true base case true checkpoint messages hs ti ii vali rep rep inductive step assume invariant holds state execution length show lemma holds step extension actions violate actions change vali rep rep exec decrement remove messages wire actions decrement 
similarly actions remove messages wire wire remembers messages sent multicast channel messages removed non faulty replica sent multicast channel 
actions violate 
receive hnew view ni 
execute 
send new view inductive hypothesis condition ensures actions third type violate condition set val rep rep exec corresponding values checkpoint message non faulty replica 
actions second type violate inductive hypothesis executed request verifies committed view exec 
committed true commits necessary committed wire hold messages received multicast channel messages case sent multicast channel 
actions violate condition insert checkpoint messages 
receive ii 
receive hview change qi 
receive hnew view ni 
send 
execute 
send view change 
send new view non faulty replica 
actions types preserve checkpoints insert action executes inductive hypothesis 
actions types may insert new checkpoint message preserve condition message sequence number checkpoint digest checkpoint message non faulty replica action executes inductive hypothesis 
argument show actions fifth type preserve shows preserve condition 
invariant true reachable state execution faulty rm committed wire committed wire length length rm proof contradiction suppose invariant false 
may exist sequence number length different requests mk mk jr qi wire jr qi wire invariant invariant contradict invariant 
theorem gc implements proof prove gc implements implies implements theorems 
proof uses forward simulation gc gc equal gc output actions external signature hidden 
definition subset states gc states element conditions satisfied replica faulty false replica 
values state variables equal corresponding values wire ini outi 

ini fm hpre prepare mi hprepare ji ji ini stable nig fm ini tag view change tag new view ini fm hpre prepare mi hprepare ji ji ini stable nig fm ini tag checkpoint tag view change tag new view 
consistent vc hview change hs ti ji hview change ji gc correct view change correct view change fm hpre prepare hprepare ki consistent vc set consistent vc consistent vc vci change ji ini vci change hs ti ji consistent vc set vci vci true 
consistent nv set fm hnew view hnew view ni consistent vc set gc correct new view correct new view fm hpre prepare max fm hpre prepare max nvi view ni ini nvi view ni ini consistent nv set nvi nvi true 
ng 
consistent tag view change consistent vc tag new view consistent nv set fmg fm tag view change tag new view xi outi fm tag checkpoint yi outi consistent xi yi 
faulty faulty hmi faulty faulty hmi consistent faulty faulty 
hri wire hri wire additionally assume faulty automata faulty identical actions state 
note conditions definition need hold faulty forn faulty fthe behavior unspecified 
prove fact forward simulation gc prove true 
start gc start fg 
trans state gc gc reachable exists execution fragment starting trace trace 
condition holds initial state gc clear satisfy clause definition initial value variables mentioned clause gc clauses satisfied ini contains checkpoint messages ini outi outi wire andy wire empty 
prove condition showing holds action gc 
start defining auxiliary function compute sequence actions starting state simulate receive message automaton client replica identifier wire wire receive misbehave fag 
receive wire faulty false outi send fag receive receive enabled state defined actions enabled ifm checkpoint view change new view message consistent vc ifm view change message consistent nv set fmg fm ifm new view message guaranteed clauses definition proceed cases proving condition holds acts gc non faulty proxy actions 
action non faulty proxy automaton receive ri consist single step 
receive actions 
case enabled actions enabled starting inspection code shows state relation defined preserved cases 
internal channel actions 
misbehave action cases enabled contain single step 
case preserved 
add new messages wire 
receive request pre prepare prepare commit 
actions receive syntactically valid request pre prepare prepare commit message transforms modify wire way preserves clauses 
receives request messages add messages preserving state correspondence defined message types definition definition wv ensure condition true condition restrictive gc andx ini ini prepare commit messages sequence numbers higher stable ni 
case state correspondence defined preserved 
possible condition true false cause message added ini possibly outi added ini outi 
happens sequence number message received lower equal stable ni state correspondence preserved case 
garbage collection 
receive ji collect garbage condition holds clear condition holds type action 
second type condition satisfied messages removed sequence number lower equal action sets stable action sets stable removes triples sequence number lower triple sequence number existence triple guaranteed precondition collect garbage action requires checkpoint message sequence number inserts checkpoint messages inserts corresponding checkpoint receive view change 
receive hview change ji consistent vc 
definition consistent vc ensures messages incorrect correct 
case modify destination set messages wire insert view change message case state correspondence defined preserved 
receive new view 
receive hnew view ni consider cases 
firstly condition outer satisfied consistent nv set fmg fm 
clear ensures assumption 
secondly condition outer satisfied executes execution sequence actions 
actions hnew view nv set fmg fm 
sequence tuples vn rn mn rm conditions true max ii vn rn mn vn rn vn mn ki wire hpre prepare primary wire mn wire vn rn mn order increasing execute cn vn mn ki rn enabled pn hpre prepare primary mn execute mn vn definition clauses ensures receive new view message executes condition outer true exactly satisfied state executes show empty max exec 
true set view add pre prepares consistent new view messages 
adds pre prepares violate ensures stable greater equal sequence numbers pre prepares 
add prepares adds prepares added extra prepares sequence numbers equal stable empty max exec possible requests execution reflected checkpoint may executed 
extra actions ensure 
show defined exists sequence tuple exec max satisfies conditions ii 
hview change max hs ti ki view change message checkpoint value hs ti assigned val rep rep 
correct contains checkpoint messages sequence number max digest hs ti 
bound number faulty replicas invariant condition imply sequence requests committed wire max 
inductive hypothesis commit pre prepare request messages corresponding wire actions actions enabled starting tuples receive nk insert nk similarly receive pre prepare request insert matching pre prepare request enables execute invariant condition asserts exists sequence requests committed wire val rep rep exec view 
inductive hypothesis commit pre prepare request messages corresponding wire invariant imply 
execution val rep rep exec required send 
send single send step checkpoint view change view tag action enabled ifm checkpoint tag action enabled message channel 
single send step view change tag action enabled consistent vc 
single send step new view tag action enabled consistent nv set fmg fm 
send pre prepare send commit 
send pre prepare send commit contain single step 
ensures actions enabled enabled insert remove messages execute 
execute contain single step 
action enabled enabled enabled stable pre prepare commit messages sequence numbers greater stable requests 
easy see state correspondence defined preserved inspecting code 
view change 
view change contain single step 
action enabled enabled value insert messages respectively ini outi clear ensures provided consistent vc true 
clause definition ensures contain messages component sequence numbers greater stable ni consistent vc true 
send new view 
send new view execution sequence actions 
send new view step consistent vc set 

sequence tuples vn rn mn rm conditions true max ii vn rn mn vn rn vn mn ki wire hpre prepare primary wire mn wire vn rn mn order increasing execute cn vn mn ki rn enabled pn hpre prepare primary mn execute mn vn simulation argument preserves similar receives new view messages 
failure 
replica failure client failure contain single step 
easy see 
actions faulty nodes 
action faulty automaton contain single step 
definition ensures enabled enabled modifications internal state faulty automaton violate actions potentially violate sends 
possible faulty automaton forge signature non faulty 
fips 
secure hash standard 
nist dept commerce 

bellare rogaway 
exact security digital signatures sign rsa rabin 
advance cryptology eurocrypt lecture notes computer science vol 
maurer ed springer verlag 
bracha toueg 
asynchronous consensus broadcast protocols 
journal acm 
miguel castro barbara liskov 
practical byzantine fault tolerance 
proceedings third symposium operating systems design implementation new orleans la february 
herlihy wing 
axioms concurrent objects 
acm symposium principles programming languages 
moser melliar smith 
securering protocols securing group communication 
hawaii international conference system sciences 
lamport 
time clocks ordering events distributed system 
communications acm 
nancy lynch 
distributed algorithms 
morgan kaufmann publishers 
malkhi reiter lynch 
correctness condition memory shared byzantine processes 
submitted publication september 
reiter 
rampart toolkit building high integrity services 
theory practice distributed systems lncs 
schneider 
implementing fault tolerant services state machine approach tutorial 
acm computing surveys 

