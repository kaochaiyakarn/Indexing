streamit compiler streaming applications william michal michael gordon david maze jeremy wong henry hoffmann matthew brown saman amarasinghe hank morris lcs mit edu laboratory computer science massachusetts institute technology cambridge ma february streaming programs represent increasingly important widespread class applications holds unprecedented opportunities high impact compiler technology 
sequential programs obscured dependence information complex communication patterns stream program naturally written set concurrent lters regular steady state communication 
streamit language aims provide natural high level syntax improves programmer productivity streaming domain 
time language imposes hierarchical structure stream graph enables novel representations optimizations streamit compiler 
de ne stream dependence function fundamental relationship input channels lters stream graph 
describe suite stream optimizations denotational semantics validating optimizations novel phased scheduling algorithm stream graphs 
addition implemented prototype streamit optimizing compiler showing promising results 

years seen proliferation applications notion stream 
evidence streaming media applications consuming cycles consumer machines continuing grow 
stream abstraction central embedded applications hand held computers cell phones dsp high performance applications intelligent software routers cell phone base stations hdtv editing consoles 
despite prevalence applications surprisingly little language compiler support practical large scale stream programming 
example number grid architectures emerging particularly suited stream programming common machine language programmer exploit common properties hiding di erences 
programmers turn generalpurpose languages implement stream programs resorting low level assembly codes loops require high performance 
practice labor document mit laboratory computer science technical memo lcs tm february 
error prone costly sections re implemented target architecture 
general purpose languages provide natural intuitive representation streams having negative ect readability robustness programmer productivity 
streamit language compiler speci cally designed modern stream programming 
goal raise abstraction level streaming domain providing natural high level syntax conceals architectural details sacri cing performance 
accomplish goal compiler needs stream aware needs able recognize analyze manipulate data streams expert assembly programmer lowering application target 
contributions structured streams language construct enabling novel compiler analyses stream programs 
identi cation fundamental property stream graph stream dependence function establishes notion relative time dependence information 
semantic model structured stream programs allows formulate validate stream transformations 
parallel fusion transformation collapses lters 
suite optimizations speci streaming domain 
novel phased scheduling algorithm nds minimal latency schedule structured stream graph 
prototype implementation streamit optimizing compiler showing promising results 

streamit language section provide brief overview streamit language please see detailed description 
current version streamit legal java syntax simplify presentation implementation designed support streams static input output rates 
designing cleaner syntax considering dynamically varying rates subject 
class adder extends filter int void init int input new channel float type output new channel float type void float sum int sum input output sum public class equalizer extends pipeline void init float int add new splitjoin void init int bottom int top duplicate int add new bottom top round robin add new adder class extends pipeline void init add new datasource add new add new bandwidth add new equalizer add new speaker parts fm radio streamit 
filters basic unit computation streamit filter 
example filter adder component software radio see 
filter contains init function called initialization time case adder records number items lter 
user instantiate lter constructor init function called implicitly arguments passed constructor function describes ne grained execution step lter steady state 
function lter communicate neighbors input output channels typed fifo queues declared init function 
channels support intuitive operations push value pop peek index peek returns value position index dequeuing item 
rationale streamit representation lter improvement general purpose languages 
procedural language analog lter block statements complicated loop nest 
clear abstraction barrier lter high volume stream processing global variables control ow 
loop nest re arranged input output ratios design unnatural necessary allow inlining section java syntax 
lter changes scheduling optimizations inhibit readability code 
object oriented language implement stream abstraction library 
avoids problems associated procedural loop nest programming model complicated eciency concerns optimize cache performance entire application processes blocks data complicate obscure underlying algorithm 
contrast alternatives streamit places lter independent unit making explicit parallelism inter lter communication hiding details scheduling optimization programmer 
connecting filters basic construct composing lters communicating network pipeline fm radio 
filter pipeline init function called instantiation 
function input output channels implicit stream behaves sequential composition lters speci ed successive calls add init 
stream constructors pipeline splitjoin see 
word stream refer instance filter pipeline splitjoin 
splitjoin specify independent parallel streams diverge common splitter merge common joiner 
kinds splitters duplicate replicates data item sends copy parallel stream roundrobin wn sends rst items rst stream items second stream 
roundrobin type joiner support function analogous round robin splitter 
roundrobin written weights assume 
splitter joiner type speci ed calls respectively see parallel streams speci ed successive calls add th call setting th stream splitjoin 
note roundrobin function exclusive selector weights zero 
control construct provides way create cycles stream graph 
contains joiner body stream splitter loop stream set calls respectively 
feedback loop special semantics stream rst starting run 
items feedback path rst stream inputs items function de ned index provides th initial input feedback joiner 
call init function user specify items calculated joiner looks data items feedback channel 
evident examples feature streamit syntax inlining 
de nition stream lter inlined point instantiation preventing de nition small classes providing syntax reveals hierarchical structure streams tion level code 
java syntax anonymous classes inlining 
rationale streamit di ers languages imposes de ned structure streams stream graphs built hierarchical composition pipelines 
contrast environments generally regard stream arbitrary network lters connected channels 
arbitrary graphs hard compiler analyze equally dicult programmer describe 
programmers resort straight line code links lter making hard visualize stream graph ad hoc graphical programming environment awkward admits textual representation 
contrast streamit clean textual representation especially inlined streams easy see shape computation indentation level code 
comparison streamit structure arbitrary stream graphs likened di erence structured control ow goto statements 
structure restricts expressiveness programmer gains robustness readability compiler analysis immense 
nal bene stream graph construction streamit ability parameterize graphs 
instance equalizer inputs parameter controls number parallel streams contains 
improves readability decreases code size 
messages streamit provides dynamic messaging system passing irregular low volume control information lters streams 
messages sent body lter function change parameter lter 
central aspect messaging system sophisticated timing mechanism allows lters specify message received relative ow information sender receiver 
due space constraints describe syntax message statements consider semantics message timing section 
streaming model computation section develop model streaming computation serve basis reasoning program transformations compilation techniques streaming domain 
stream graph di ers traditional sequential program lters graph implicitly running parallel execution order constrained availability data channels lters 
lters communicate immediate neighbors removing notion global time non local dependences lter 
properties merit development new model computation notions timing scheduling dependence analysis terms relative lter graph global characteristics program 
arrive notion relative timing dependence stream dependence function sdep pipeline 
bm bm bm splitjoin 
fj fj fs fs fj body fj loop fs fs 
streamit structures labeling 
de ned stream graph 
section provide de nition sdep notation 
motivate sdep function deriving concept relative time meaning streamit messaging system 
section turn deriving expressions sdep function sections employ function respective contexts program veri cation denotational semantics program optimization 
notation notation tape nite history values pushed channel lters 
os denote input output tapes stream respectively numbering distinguish multiple input output tapes see 
represents number items tape point execution 
say lter upstream lter equivalently downstream directed path stream graph oa ib terminology tapes lters 
number items pushed popped lter single execution function denoted popa respectively 
note includes items popped popa ready give de nition stream dependence function sdep definition 
sdep minimum number items appear tape items tape downstream think sdep inter lter data dependence mapping 
actual data stream program appear functions aggregate dependence restricts lter ring items input tape satisfy internal assume ring atomic 
sdep function generalizes dependence answer di erent question items needed lter input tape lter re 
sections provide additional intuition meaning applications sdep function 
information flow sdep function described terms data dependences 
think function de ning common timing mechanism asynchronous lters synchronize events 
timing mechanism terms information ow believe central concept streaming domain 
information wavefronts item enters stream carries new information 
execution progresses information cascades stream ecting state lters values new data items produced 
refer information wavefront set lter executions rst sees ects input item 
lter function invoked asynchronously notion global time invocations function occur information relative time operate information wavefront 
sdep function give precise de nition information wavefront 
interpretation sdep item position tape latest item tape ect item position tape item tape produced tape contains items 
note ect control dependence data dependence instance item needs pass round robin joiner data stream routed tape choose information ow data ow describe timing concept 
message timing sdep function give precise meaning message delivery guarantees streamit 
give details due space constraints see careful treatment general idea follows 
lter send message lter communicate low bandwidth asynchronous data 
send message needs upstream downstream path stream graph lters need directly connected 
message statement appears function includes speci ed latency indicates target lter receive message 
streamit language speci cation measures latency terms information wavefronts upstream receive message immediately preceding rst invocation function reads items ected output th invocation function 
message handler invoked sees information wavefront sees execution steps 
cases ability synchronize message information wavefront useful 
instance input port hand held computer detects change networking protocol send recon guration message downstream lters latency 
guarantees lter recon gure just time understand new protocol process previous elements pipeline old protocol 
stream dependence function turn deriving sdep pairs tapes lter graph upstream filters derive ia represents time shift single lter lter produces items invocation invoked push produce th item 
invocation consumes popa items additional popa items 
total number items input ia popa popa pipelines derive expression sdep case pipeline 
base case consider lters connected output feeding input see 
seeking ia minimum number items appear tape ia items tape ob observing minimum ib items appear tape ib ib equal oa lters connected see minimum ia ib items appear ia denote function composition ia ia ib identical reasoning composition law holds pipelined streams lters 
pipeline streams sn sdep function sdepo 
sdepo sn sn tempted de ne sdep function pair connected tapes composition functions operators connecting tapes 
definition turns problematic splitjoin constructs require slightly di erent composition law components shown 
extend notation include components streams connected pipeline 
tapes contained stream constructs respectively belong pipeline streams sn sdep sdepo sdepo 
sdep derive sdep expressions components splitjoin splitjoin construct 
denote output tapes splitter input tapes joiner see 
duplicate splitter 
consider th output tape way duplicating splitter 
splitter duplicates input item output tape sdepo table sdep values round robin splitter closed form solution appears equation 
items items yields simple expression sdep sdepo round robin splitter 
consider way splitter weights wn denote sum weights th output tape denote sum weights 
output tape derive sdepo reader referred table lists sdep number representative inputs 
generally speaking table illustrates set items appearing tape splitter executed full round 
additionally items gone splitter rst item appear reader verify expression gives values sdep shown table sdepo mod note equation give negative value sdep case 
problematic output tape contain zero items regardless number items input 
general sdep meaningful domain strictly positive tape values 
round robin joiner 
consider way joiner weights wn input tape values sdepo representative inputs shown table 
items required tape items output joiner rst items drawn tapes 
joiner reads tape outputs items requiring items produce output joiner read th input tape round producing item 
cycle repeats 
reader verify expression gives correct values sdep sdepo min max mod splitjoin construct 
pipeline construct derive sdep function entire splitjoin composition component functions 
oj sdepo oj table sdep values round robin joiner closed form solution appears equation 
splitjoin di ers pipeline joiner imposes control dependence parallel streams 
items output joiner sdepo items input tape applying composition law pipelines equation follows sdepo items output tape splitter 
minimum number items appearing input tape splitter maximum item requirement output tape reasoning sdep function splitjoin follows sdepo max sdepo sdepo sdep function feedback loop requires extra care 
feedback splitter fs serves normal splitter sdep function derived feedback joiner fj slightly di erent due initialization phase loop 
sdep function compose components loop con icting de nitions paths circle loop times 
feedback joiner 
feedback loop delay feedback joiner fabricate rst input values items pushed loop tape fj means set sdep function rst items direct inputs joiner appearing items input tape 
denote round robin joiner considered expression sdep function feedback path sdepo fj fj sdepo remains unchanged respect input main stream sdepo fj fj sdepo feedback components 
feedback loop tape downstream tape uniquely de ned composing directed acyclic path require acyclic path avoid successive passes loop prevent unique de nition function 
denoting path tapes tn composition follows form equation sdep sdep sdep sdep tn note functions composed constructs neighboring feedback loop obtain instance relation loop tape fj downstream pipeline application equation 
feedback loop construct 
special case equation see feedback loop composition main path sdepo fs fj sdepo sdepo intuitively semantically correct stream program loop guaranteed inputs feed joiner output tape feedback loop places restriction input tape feedback loop 
summary preceding sections derived components stream construct stream construct 
application equation yields function sdep pair tapes downstream program verification number program analysis techniques immediately orded 
particular simple compute program deadlock result starved input channel bu er grow bound steady state execution program 
deadlock detection 
deadlock detection algorithm takes advantage fact loops stream graph part construct 
stream graph deadlock free feedback loop produces data satisfy feedback joiner 
formulated terms considering sdep data tape feedback loop requires 
didn de ne circular paths stream graph denote function de ne loop input feedback joiner sdepo fj fj fj fj loop deadlock free 
condition follows directly causality th item produced production depends subset items channel 
ow detection 
places bu er grow unbounded size stream graph 
rst feedback loop 
items feedback tape enables production additional items grows asymptotically position tape constant consumption rate keep growing production rate bu er ow 
second case bu er ow parallel streams splitjoin asymptotically di erent production rates 
stream splitjoin construct bu er corresponding joiner input tape ow stream splitjoin sdepo sdepo sdepo sdepo cases detected compiler verify bu ers ow steady state execution 
denotational semantics section develop denotational semantics obtaining meaning entire stream graph 
section semantics show optimizing transformation stream graph preserves meaning entire program 
denotational semantics contains algebras literal streamit syntax intermediate syntax semantic analysis 
purpose intermediate algebra provide simpli ed syntax developing stream transformations away streamit speci aspects program 
provide informal description translate back forth streamit programs syntax consider formal valuation functions determining meaning syntax semantic algebra 
analysis assume lters stateless stream program semantically correct 
intermediate algebra intermediate algebra provides common mathematical representation manipulating stream programs 
referred algebra providing syntax stream programs representation strictly mathematical framework semantic domains program execution 
lisp syntax allows think representation program amenable straightforward transformation techniques 
domains intermediate algebra shown figures 
algebra represents tape nite mapping indices items 
generally stream constructs represented lists component streams lters functions encoded lists push statements transform local indexing global tape position return mapping tape output item 
converting intermediate algebra 
straightforward generate expression intermediate algebra re ects meaning streamit program 
due space limitations consider translation functions 
translation lter function contains steps 
function arranged canonical form pushed item direct function items pop statements function 
consider function item index index index tape index item op peek push 
tape item semantic domains shared intermediate transform algebras 
stream ilter splitjoin ilter push pop peek stream splitjoin stream int stream semantic domains speci intermediate algebra 
tape tape semantic domains speci transform algebra 
rates push pop peek 
canonical form function gives element syntactic domain void output push input peek input peek peek output push input peek input peek peek int input pop model computation function pure mathematical functions injected semantic domain 
simplify notation de ne valuation terms example syntactic function 
valuation alternate application push statement function index expressions transformed local index global index input tape peek converting intermediate algebra 
convert back streamit perform inverse translation shown push statement function local index expression place global index 
common sub expression elimination eliminate duplicate peek statements shared portions 
transform algebra transform algebra designed express meaning stream graph transformation input tape output tape 
semantic domains figures 
goal express meaning stream intermediate algebra transform algebra 
introduce domain element maps call 
intuition represents relative indexing function imposed enclosing stream construct 
instance way splitjoin roundrobin splitter splitjoin construct imposes second parallel stream component 
index component stream input tape corresponds index input tape splitjoin 
component stream transforming input tape entire splitjoin apply original index 
denote valuation functions stream stream meaning top level stream follows denotes identity function meaning entire stream program simply stream program applied identity function index top level enclosing stream constructs tape transformation relative input tape stream 
turn attention deriving filters pipelines 
letting denote mod function lter filter push pop peek push local sdepo peek local value lter pushes th position output tape calculated function index push 
de nition sdep index set value lter sdepo denote input output tapes lter shown equation pure function push pop peek 
set rst value lter sdepo peek obtain global index adding set local index local pipeline transform function simply composition transforms component streams 
internal connections pipeline index transform identity function start pipeline apply transform interface pipeline outside connection 
pipeline sn sn 
denotes identity function valuation function splitjoin follows idea notation slightly heavier 
round robin joiner weights wn rst represent parallel stream computes th output joiner min mod th tape position assumes value produced stream splitjoin value interest appears position sdepo output tape stream 
indexing function transforms stream local index local input tape corresponding index sdepo local input tape splitter splitjoin sn local sdepo local sdepo completes description transform algebra formulated valuation function 
valuation functions express meaning combination pipelines mathematical transformation nite tapes 
utilize formulation prove certain transformations stream graph preserve meaning program 

optimization turn attention problem optimizing stream program 
program domains principle aim compiler optimization shorten total execution time distinct optimization metrics streaming applications including throughput latency data size code size 
especially important embedded domains memory short supply latency critical real time applications throughput interest 
section transformations improve stream program metrics 
tradeo throughput latency code size data size optimality stream program depends metric interest 
fusion transformations primary stream optimization fusion multiple lters streams single atomic unit 
bene cial throughput latency data size data bu ers eliminated favor local variables short live ranges 
fusion important adapting ne grained stream program coarse grained target programmer bene ts dividing program modular components losing performance single integrated procedure 
algorithm fusing pipeline lters contain push pop statements 
stream program pays consider vertical fusion pipeline constructs horizontal fusion parallel streams splitjoin 
transformation syntax section collapses splitjoin construct containing parallel lters sn single lter sc 
denote weights joiner wn merge sn filter op roundrobin op duplicate max shift sc sc lcm lcm lcm wn op pop si push si shift sj sdepo sj sj sdepo sj sc local shift local proven transformation preserves meaning program respect transform algebra case duplicate splitter 
proof involves straightforward algebra omit due space constraints 
transformation powerful allows fuse set parallel lters splitjoin construct single lter regardless splitter joiner types push pop peek requirements 
implemented transformation streamit compiler cases duplicate splitter lters output rates matching joiner weights performance improves signi cantly see section due decreased channel operations 
sections follow give overview optimizations implementing streamit compiler 
due space limitations describe level detail 
fission transformations machine target ne grained stream graph advantageous break lters smaller pieces hardware resources utilized 
propose transformations 
parallelizing stateless lters 
lter state gain data parallelism duplicating lter times embedding way splitjoin round robin splitter joiner 

parallelizing stateless feedback loops 
body feedback loop stateless input output rates evenly divide delay loop entire loop replicated parallelized quantity delay new loops approximately equal quotient old delay body stream rates 
exploits fact certain feedback loops interleaved subsequences input stream transformed completely independently loop 

splitting stateful lters 
lter persistent state gain pipeline parallelism breaking lter stage pipeline state communicated data channels 
steady state invariant code motion streaming domain analog loop invariant code motion motion code steady state function init function depend quantity changing steady state execution lter 
quantities compiler detects constant execution assigned elds init function referenced 
induction variable detection function analyzed body loop see induction variables steady state execution 
analysis useful strength reduction adds dependence invocations converting expensive operation cheaper incremental data parallelization removes dependence invocation changing incremental operations lter state equivalent operations privatized variables 
decimation propagation decimation refers regular discarding fraction lter input items reduce sampling rate stream 
streaming domain analog dead code elimination propagation decimation stream graph eliminating computations produce unused items 
synchronization removal streamit graph splitjoin construct provides way de ne independent units parallel computation 
connected pipeline joiner splitter pair serializes items passing joiner splitter round robins equal weights node eliminated favor single splitjoin sc th parallel stream sc pipeline corresponding streams 
scheduling tradeo di erent optimization criteria particularly pronounced scheduling stage streaming compiler 
shown extreme ends optimization space schedules minimize code size expense latency bu er size minimize bu er size latency expense code size 
give overview scheduling space new phased scheduling technique takes advantage structured streams streamit obtain minimum latency schedule large increase code size 
initialization vs steady state firstly note streamit programs require separate schedule initialization steady state 
steady state schedule periodic execution preserve number live items channel graph 
need separate initialization schedule lter peek pop periodic schedule eliminate live items lter input channel needed return graph initial con guration 
streamit compiler initialization schedule constructed symbolic execution pop push pop push pop push pop push single appearance schedule pull schedule phased pull schedule di erent scheduling schemes 
channels labeled number live data items contain 
stream graph lter peek pop items input channel 
graphs nd unique minimal set multiplicities periodic schedule periodic schedules multiple 
challenge scheduling impart order steady state execution set metric optimized 
follows consider approaches problem 
minimizing code size schedule minimal code size single appearance schedule sas node appears exactly loop nest denoting schedule 
lot attention sas minimal code size allows extensive function inlining enables compiler optimizations improves performance 
streamit compiler compute simple sas hierarchical ordering original stream structure 
problem sas data bu er size grow quite large motivates techniques 
inlining bene ts orded sas important streamit compiler consider inter procedural optimizations 
minimizing buffer size spectrum minimize bu er size implementing pull schedule lters executed demand driven order re output node stream 
pull schedule guarantees minimal static bu er size assuming lter input bu er channel exceeding gcd gcd pull schedule irregular require exponential number instructions encode 
minimizing latency pull schedule minimizes average latency benchmark lines filters graph size pca demo fm radio gsm decoder table application characteristics stream important real time applications 
de ne latency output item number functions executed stream item output stream average latency taken output items 
pull schedule sucient minimize latency possible factor schedule shared loop nests 
notion phased schedule 
phased schedules invented phased schedules rely heavily structured streams streamit achieve minimum latency schedule risking code explosion pull schedule see 
phase possibly non periodic schedule stream structure bottom lter structure res exactly 
phases stream component phase associated push pop peek count 
base case lter just phase push pop peek 
stream constructs list phases determined simulating phased pull just pull schedule child streams execute steps phases 
due space limitations give detailed description phased scheduling algorithm 
case phased schedules minimum latency invoke set lters pull model output item ordering lter executions rearranged improve code size 
respecting message constraints responsibility scheduler streamit satisfy message delivery guarantees 
downstream message negative latency imposes lower bound bu er size source target lter 
likewise upstream message positive latency imposes upper bound bu er size 

implementation evaluation implemented fully functional prototype streamit optimizing compiler extension java compiler component open source project 
compiler generates code compiled streamit runtime library produce nal executable 
developed library java allows streamit code executed pure java providing veri cation mechanism output compiler 
compilation process streaming programs contains novel aspects basic unit computation stream procedure 
order compile stream modules separately developed runtime interface analogous procedure call traditional codes speci es interact black box streaming computation 
stream interface contains separate phases initialization steady state execution streamit hand coded benchmark baseline fusion spectra pca demo fm radio gsm decoder table performance results sec output execution phase interface includes contract input items output items possible message production consumption 
interface relies sdep function specify message timing terms stream input tape 
evaluated compiler streamit versions applications gsm decoder takes gsm encoded parameters inputs uses synthesize audible speech system polymorphic computing architecture pca encapsulates core functionality modern radar sonar communications signal processors software fm radio equalizer performance test system implements orthogonal frequency division multiplexor ofdm 
table gives characteristics applications including number lters implemented size stream graph coded 
table evaluate performance compiler comparing streamit implementation implementation case gsm hand optimized version 
high performance runtime library streaming programs implemented 
streamit language ers higher level abstraction see section streamit compiler able beat performance factor pca demo fm radio 
gsm application extensively hand optimized version incorporates transformations rely high level knowledge algorithm streamit performs order magnitude slower 
streamit compiler infrastructure far complete 
process discovering optimization possibilities new domain 
code generation strategy currently plan generate optimized assembly code interfacing code generator 
strongly believe improve current performance order magnitude uniprocessors take advantage inherent data pipeline parallelism streamit programs parallel execution 

related large number programming languages included concept stream various semantic formalisms see survey 
related static rate version streamit synchronous data ow languages lustre esterel require xed number inputs arrive simultaneously ring stream node 
special purpose stream languages functional imperative contain features messaging support modular program development essential modern stream applications 
languages lack structured streams streamit enable suite hierarchical compiler optimizations clean semantics ver program transformations 
level stream graphs streamit share number properties synchronous data ow sdf domain considered ptolemy project 
node sdf graph produces consumes number items delays arcs nodes corresponding loosely items streamit 
streamit sdf graphs guaranteed static schedule testing deadlock decidable orts minimize memory requirements 
nodes round robins cyclic pattern rates fall outside sdf cyclo static domain fewer scheduling results 
best knowledge phased scheduling algorithm minimal latency novel 

implemented prototype optimizing compiler streamit high level stream language aims raise abstraction level stream programming sacri cing performance 
demonstrated hierarchical structure imposed language enables new compiler analyses optimizations streaming domain 
particular believe stream dependence function critical compiler representation streaming applications comparable distance direction vectors scienti applications 
believe optimizing compilers immense importance streaming domain 
compiler match performance hand coded applications ripe eld optimizations enabled structured nature stream programming model 
young domain languages tools lacking performance critical developers interacted eager explore new language compiler solutions 
age skeptical utility traditional compiler optimization hope streaming domain proves important frontier 

berry gonthier 
esterel synchronous programming language design semantics implementation 
science computer programming 
bhattacharyya murthy lee 
software synthesis data ow graphs 
kluwer academic publishers 
pages 
goddard je ay 
managing memory requirements synthesis real time systems processing graphs 
pages 
gosling joy steele 
java language speci cation 
addison wesley 
gao desai 
minimizing memory requirements rate optimal schedules 
proc 
intl 
conf 
application speci array processors san francisco 
halbwachs caspi raymond pilaud 
synchronous data ow programming language lustre 
proceedings ieee september 
ade 
geometric parallelism cyclo static data ow grape ii 

computing architecture pca example applications description 
external report lincoln laboratory massachusetts institute technology august 
lee 
overview ptolemy project 
ucb erl technical memorandum ucb erl dept eecs university california berkeley ca march 
mai ho dally horowitz 
smart memories modular architecture 
murthy bhattacharyya 
shared bu er implementations signal processing systems lifetime analysis techniques 
ieee transactions computer aided design integrated circuits systems february 
proebsting 
filter fusion 
symposium principles programming languages pages 
dally lopez mattson owens 
bandwidth ecient architecture media processing 
hpca dallas tx november 
nagarajan burger 
technology scalable architecture fast clocks high ilp 
university texas austin department computer sciences technical report tr 
stephens 
survey stream processing 
acta informatica 
tennenhouse bose 
approach wireless signal processing 
wireless networks 
amarasinghe 
streamit language streaming applications 
mit lcs technical memo lcs tm cambridge ma 

vincent gay para thomas graf wais 
manual 
www dms docs html 
taylor sarkar lee lee kim frank finch barua babb amarasinghe agarwal 
software raw machine 
mit lcs technical report tr cambridge ma 

