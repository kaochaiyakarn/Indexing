analytical taxonomy naming systems bryan department computer sciences university texas austin tr december naming system consists mechanisms govern definition binding access names communication active objects parallel distributed system depends 
concurrent algorithm may require certain patterns communication objects 
naming systems differ significantly patterns communication support diversity suggests existence efficiency tradeoffs specialization various approaches 
enable impact differences structure concurrent computations examined systematically taxonomy naming systems isolates small set fundamental naming system properties ranks naming systems partial order expressiveness derive properties 
compare properties naming systems underlie representative concurrent programming systems give examples algorithms require specific naming system properties 
keywords classification communication properties concurrent programming expressiveness naming systems 
important component parallel distributed system naming system underlies communication active objects 
naming system consists mechanisms define names accessible objects bind names objects resolve name execution 
mechanisms incorporated concurrent programming languages runtime environments 
certain fundamental properties naming systems affect structure computations may expressed concurrent programs enabling prohibiting specific patterns communication objects 
naming systems differ significantly properties thorough understanding naming systems useful designers users parallel distributed systems 
important elements systems synchronization resource allocation scheduling naming systems widely studied independent problem domain 
particular lack precise understanding role binding name access modification set names known object communication contributes difficulty concurrent programming 
role naming systems communication concurrent computation consists set active communicating objects 
object process task similar entity 
order object successfully initiate communication object exist name known bound name symbol directly points active object denotes passive point interaction objects channel port mailbox shared variable 
irrespective mechanism communication occurs source object destination object name 
relationship name destination object called binding 
function naming system establish necessary bindings control names known object 
fundamental role names bindings distinguishing objects great variety ways names bindings established manipulated 
naming systems differ example number bindings name may simultaneously appear set bindings may modified execution 
diversity suggests existence tradeoffs specialization various approaches 
leads search unifying framework tradeoffs design choices systematically evaluated 
concurrent algorithm may require certain patterns communication objects 
identified fundamental properties naming systems determine ability express patterns 
example naming system may allow single name bound set objects enable broadcasting may allow name object exclusive access channel 
consequently algorithm specification may exist straightforward implementation naming system algorithm may awkward inefficient implement naming system 
constraints form implementation clients may poll servers may preclude existence solution altogether 
taxonomy define ranks naming systems partial order expressiveness derive properties 
preliminary example resource tracking consider system set resources shared objects communicate message passing 
resource specific type exists exactly instance type 
resource owned object time accessed owner 
time object may relinquish ownership resource response request object new owner resource 
periodically object acquire resources order perform operation 
sends requests current owners needed resources waits relinquish resources proceed 
aside possibility deadlock fundamental problem encountered implementing system locating current owner resource request issued 
suppose wish solve problem central coordinator keeps track ownership resources 
communication primitive send name message natural solution object simply executes send owns resource request requires resource solution assumes name owns resource fact bound correct object rebound ownership changes 
ability rebind name execution property naming system called dynamic binding define formally section 
property objects execute complex efficient protocol sending request objects forwarding request chain previous owners requested resource 
section discuss naming systems differ allow dynamic binding 
simple generalization resource tracking problem allow multiple instances type resource 
case suffices object acquire instance resource type request delivered objects hold instance requested type 
support naming system allow name owns resource bound set objects hold instance multiplicity property defined section 
impact naming systems apparent definitions names bindings quite broad 
concept name encompasses familiar items process identifiers entries includes things unbound variables parallel logic languages data values satisfying condition selective accept statement concurrent 
similarly binding may reflected association constant value object static naming processes csp explicitly storing name naming data structure opening port may implicit state object executing selective accept particular expression 
important step identifying properties naming system determine names bindings represented naming system 
give examples procedure section 
significant characteristics concurrent systems influenced properties underlying naming system 
ffl blocking queueing communications initiating communication name bound object may cause communication block queued name bound 
ffl modularity independent specification shared components system servers requires accessed clients shared names 
ffl dynamic structures allow creation new communicating objects computation naming systems enable objects learn new names names objects created fly permit existing names dynamically bound new objects 
ffl abstraction typical communication primitives specify communication objects 
allowing objects referenced indirect names allowing names bound sets objects communication may specified higher level abstraction 
syntax vs semantics naming system consists complementary sets mechanisms establish bindings names objects subsequently bindings resolve name 
comer peterson observed name resolution strictly syntactic process semantic information meaning name respect particular concurrent computation resides bindings names objects 
name meaning binding object set objects meaning independent method name resolved 
analogy compilers serves illustrate relationship binding resolution compilation program requires language definition step assigns operations syntactic constructs translation step takes syntactic construct generates corresponding operations 
resolution binding translation language definition 
overview typically influence communication mechanisms naming systems structure concurrent computations examined ad hoc manner 
shown example limitations ada rendezvous mechanism relies restrictive naming system lead programs poll requirement communicating processes csp name precludes certain desirable communication patterns 
improvements suggested languages 
analyses useful shortcomings lack generality stated terms syntax semantics particular language system question clearly distinguish roles names bindings critical 
results extend obvious way concurrent systems 
taxonomy enables systematic analysis naming systems impact structure computations defining set naming system properties independent particular concurrent programming language system 
particular subset properties shown hold naming system possible determine naming system permits communication patterns necessary solution problem 
attempting implement solution necessary determine high level naming system properties required problem 
structure taxonomy naming system properties defined model concurrency differs conventional models ways 
distinguishes exactly part state computation enables determine bindings known names exist point computation 
second specifies communication computation name carrying communication 
capture relationship names bindings communication augmenting standard partial order model concurrency information state naming system follows computation partial order events interconnected explicitly represented communications 
event execution action object 
events annotated names known bound object event occurs 
communications triples containing source destination events name communication occurs 
significant characteristics events annotations positions partial order constitutes computation participate communication 
naming system property predicate order logic describes structure computations 
naming system said property iff computations permits satisfy predicate 
ordering properties orthogonal pairs defines lattice structured hierarchy categories ranks naming systems expressiveness 
category combination properties naming system member category iff corresponding properties 
characteristics taxonomy summarize model concurrency properties hierarchy form taxonomy naming systems characteristics 
ffl specification communication semantics naming systems naming concurrent systems focused resolution syntactic aspect naming 
taxonomy identifies semantic properties significant specification communication received little previous systematic study 
ffl separation concerns naming systems examined isolation characteristics concurrent systems implementation details naming system properties 
ffl utility hierarchy enables systematic evaluation relative expressiveness naming systems 
includes selection design naming system particular problem domain comparison different implementations equivalent naming systems checking tractability problem naming system prior implementing solution 
ffl coverage taxonomy covers naming system properties underlying variety communication models including message passing systems shared data structures rendezvous dataflow variables parallel logic languages 
models differ substantially respects naming system properties common 
rest organized follows section give definitions properties hierarchy 
section traces path hierarchy illustrates correspondence successively expressive naming system properties increasingly general communication mechanisms parallels evolution concurrent systems csp ada concurrent linda 
definitions model concurrency computation partially ordered multiset pomset events multiset communications 
pomset set element may occur ordering relation 
relation defined distinct occurrences elements pomset 
think individual occurrences particular element indexed distinguished 
similarly equality relation holds occurrence element distinct occurrences element considered equal 
objects behaviors objects computation communicating entities comprise concurrent system 
examples objects csp processes ada tasks clause evaluations parallel logic languages 
behavior object linear sequence events execution thread event occurrence action 
object exists program specifies finite set possible actions possibly infinite set possible behaviors object 
actions distinguished values variables refer 
computation object exhibits exactly behaviors 
names name tuple containing identifiers specify destination communication 
identifier appears action initiates communication send msg send message receiver case correspondence identifiers messages 
naming systems multiple identifiers specify communication 
csp example sender receiver message identify type message transmitted see section 
characteristics events event distinguished exactly attributes object occurs binding domain see section position partial order events computation 
definition set events theta theta set objects set domains set bindings respectively 
notation denote components event object domain binding events endpoints communications objects event may source destination communications 
needn represent underlying execution action corresponding event 
interesting events participate communications state naming system changes set names known bound object modified 
communications communication source event name destination event triple 
name appears communication element domain source event binding destination event indicating name known object source event occurs bound object destination event occurs 
source destination events communication temporally ordered source event precedes destination event 
examples source destination event pairs sending receiving message writing reading shared variable invoking accepting remote procedure call 
definition set communications theta theta notation denote components communication source name destination domains bindings generalizing definitions resolution mechanism function arguments name context 
context function names sets objects defined set tuples 
tuple binding 
name 
function returns set objects bound context states mechanisms context component state naming system 
resolution function reads modify state 
possible define analogous functions mechanisms modify state naming system 
mechanism responsible modifying contexts binding mechanism name context set objects 
function binds set objects context possibly objects 
replaces previous set objects bound 
naming system state consists contexts set names known object 
corresponding function modifies component state object set names function objects sets names representing names known object defined set tuples object 
function replaces previous set names known object resolution outside scope orthogonal model concurrency assume resolution succeeds affect structure computations may expressed naming system 
consequently simplification immediately assume single universal context global namespace 
loss generality assume exists single space known names 
annotation computations state naming system point result applying binding resolution functions finite sequence starting initial state 
model concurrency partial orders events state transition model enables simpler definition concept communication central subsequent definitions naming system properties 
capture information state naming system event computation annotated appropriate elements annotations event called domain binding event elements correspond elements known names function context respectively 
definition domain binding event set names known bound object event occurs occurrence event 
domain event object knows name point behavior iff originate communication name free execute actions point 
finite set actions object execute gamma initial subsequence possible behavior object 
event occurrence action events naming system allows computation behavior gamma appears substituted computation contains communication name domain note gamma necessarily possible behavior object object free execute actions 
indicates set names accessible object point event occurs 
binding event domain event describes maximal set communications may originate point behavior event occurs binding event describes maximal set communications may terminate point behavior event occurs 
name may known point behavior possible object name 
name bound object exactly possible communication terminate event 
defining binding event confine attention possible behaviors object initial prefixes possible behaviors object identical event differs 
naming system allows computation containing computation contains communication binding object capable receiving communication name point behavior occurs bound object correspondence direct correspondence domains bindings certain sets events global state naming system 
consider snapshot consistent cut computation 
cut constitutes globally consistent state 
context exists simply union binding annotations events immediately precede cut 
similarly set known names exists union domain annotations events immediately precede cut 
domain event determined semantics actions identifiers created destroyed propagated objects 
example identifiers treated data items name may added domains subsequent events receiving message containing name 
conversely protection scheme may cause name removed domains subsequent events revoking access rights name 
binding event determined semantics actions identifiers bound explicitly implicitly objects 
examples actions cause bindings modified attaching message port process executing read operation channel instantiating new unbound variable parallel logic language 
computations definition precedes 
events 
relation 
indicates necessarily precedes time 

transitive antisymmetric irreflexive 
definition events concurrent iff 

definition computation fl pair pi delta pi pomset ei delta multiset communications pi pi delta 
pi 

pi 
delta 

universal constraints structure computation source event communication precedes corresponding destination event second total ordering events object 
addition non collocated events ordered exists computation transitively communication events 
naming systems differentiated additional constraints impose computations 
shows possible computation objects 
computation contains communications object object object object 
name domain event binding event name domain event binding event naming systems definition naming system specification allowable domains bindings communications order events computations 
naming system exists maximal computation set gamma set computations specifiable naming system admits existence particular domains bindings communication patterns exist computations maximal computation set 
naming system properties defined characterize naming systems stating existence nonexistence computations maximal computation set 
properties naming systems orthogonal characteristics naming systems mutability bindings runtime name access ability objects learn new names execution binding names sets objects shared access names descriptive names binding multiple names object 
naming system property statement presence absence characteristics set computations may specified naming system 
properties meet criteria properties holds naming system properties reflect design decisions development naming system 
property may necessary may preclude existence solutions certain classes problems properties relevant selection naming system appropriate solution problem 
definition naming system property specify property implemented 
definitions quantification elements maximal computation set gamma 
sake brevity shorthand notation event means pi fl gamma behavior means fl gamma communication means delta fl gamma communication set delta means delta fl gamma name means delta fl gamma definitions properties refer auxiliary function definition fi delta delta function fi delta denotes set objects destination event occur communications delta source event name common 
mutability bindings naming system provides mechanism altering bindings runtime said dynamic binding property 
dynamic binding property provides abstraction indirect naming comparable abstraction provided pointers 
property required name service remain constant object bound server implements service varies computation 
naming systems allow dynamic binding significant exceptions 
csp languages explicitly eschew dynamic binding favor statically named processes static binding ada names communication concatenation task id entry id 
dynamic binding typically achieved associating fixed port mailbox successive objects making shared data conduit channel accessible multiple objects 
definition dynamic binding events communication set delta name fi delta fi delta definition static binding name access properties dynamic domain static domain characterize ability objects learn new names computation 
dynamic domain property holds names typically treated ordinary data values may passed object object execution appear arguments communication primitives 
set objects object able communicate may grow computation progresses 
property required problems having inherently dynamic structure new objects new names created computation 
examples include simulations physical processes data parallel algorithms number worker processes created varies size workload 
nearly concurrent programming languages allow names manipulated data csp notable exception 
definition dynamic domains event name events 
definition static domains multiply bound names name may simultaneously bound multiple objects sets objects naming system said multiplicity property 
complementary property multiplicity 
multiplicity provides abstraction allowing communication arbitrary groups objects broadcasting 
communication multiply bound name generalization communication exactly objects 
property required size set objects communicate transparent originator communication 
common systems objects replicated fault tolerance group broadcast isis example group communication primary mode object interaction systems bsp broadcast channels associative broadcast 
addition concurrent systems objects communicate shared data structures linda multiplicity property multiple objects may read value written data structure 
definition multiplicity event communication set delta name jfi delta definition multiplicity multiply named objects naming systems allow object refer object name 
dual multiplicity called aliased names property 
object known object name computation names property holds 
typically multiple aliases required name signifies action performed destination object entry ada remote procedure call 
multiple aliases enable destination object selectively accept communications source object 
selectivity required prevent polling see section 
definition aliased names communications definition names name sharing shared name accessible object communications single name may initiated distinct objects 
naming systems permit behaviors said shared name property names accessible object naming system private name property 
shared names required object exactly name bound destination communications source object names passed data objects 
naming systems permit name sharing desirable prevent nondeterminism arise multiple communications name 
bsm system designed real time process control allows process receive messages process 
restriction assumes process name names shared bindings mutable 
section show csp naming system permit names shared requires senders receivers name sender receiver identifier pair constitutes unique name 
definition shared names communications definition private names descriptive names descriptive names carry information states objects bound 
associating arbitrary identifiers objects process useful able assign meanings identifiers idle bound objects exactly corresponding state 
naming system provide mechanisms establishing removing bindings reflect current states objects 
descriptive name reflects object state range states potentially infinite possible name infinite set names bound object computation 
naming systems said descriptive property naming systems names uninterpreted identifiers characterized 
descriptive required identities set objects participate communication depends local states potential participants 
example initiator deadlock detection computation may need send message processes waiting resource 
conventional naming systems support descriptive 
designers concurrent addressed limitations ada due lack descriptive introducing selective accept action effectively binds descriptive name object process executes see section 
associative broadcast linda integrate descriptive dynamic binding multiplicity allowing dynamic descriptively named sets objects specified destinations communications manner implement naming system properties differ fundamentally 
definition descriptive behavior countably infinite definition hierarchy naming systems mutually exclusive pairs naming system properties form axes coordinate space exists complete lattice naming system categories 
category unique point coordinate space having property axis 
definition coordinate properties fb rg definition satisfies gamma maximal computation set coordinate 
gamma satisfies iff fl fl gamma true fl 
definition subsumes coordinates gamma set maximal computation sets distinct coordinates 
reflexive asymmetric transitive relation gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma respective definitions follows definition axis ordered sets coordinates definition category tuple coordinates axis definition category 
naming system member iff gamma definition subsumes categories categories 
iff coordinate subsumes corresponding coordinate portion hierarchy core hierarchy subsumes relation 
distinct coordinates related larger set computations satisfies larger set contains computations violate weaker constraint naming system property allows computations obtained naming system property category subsumes category naming system member allows computations obtained naming system member examples naming system belongs categories hierarchy exhaustive classification existing naming systems scope 
section illustrates relation representative categories traversal possible paths hierarchy category called 
intervening categories contain familiar naming systems 
shows portion hierarchy representative naming systems category 
lines categories labeled properties categories differ 
solid outlines indicate categories discussed section 
classification procedure classify naming system member particular category show property coordinate category naming system maximal computation set satisfies property 
step procedure identify elements computations objects names communications domains bindings example concurrent system may define terms processes process identifiers communication operators messages 
section contains detailed classification csp 
csp influenced design concurrent programming systems classification provides relatively understood starting point traversal hierarchy naming systems 
subsequent sections examine successively expressive naming systems 
interest brevity full classification omitted properties differ discussed detail 
classification csp communicating sequential processes model concurrent computation emphasizes simplicity communication order reasoning interactions processes manageable 
classifying taxonomy show naming system correspondingly simple fact differs category containing simplest possible naming systems aliased names property 
comparing position csp naming system hierarchy positions naming systems gain precise understanding relative simplicity csp applicability problems require specific naming system properties 
elements csp program specifies behavior fixed set processes 
process labeled unique identifier 
communication csp consists synchronous message passing exactly sender receiver participants communication fixed program text 
value variable local process assigned variable process executes statement executes statement optional constructor called message type 
action csp process send action receive action internal action 
ffl objects object distinct csp process 
ffl names set possible csp process identifiers set possible constructors 
name sender id constructor receiver id triple set theta theta ffl communications communication arises execution corresponding pair send receive actions 
event execution send action process labeled event execution corresponding receive action process labeled computation contains communication iff identifier triple 
ffl domains identifiers appearing send actions fixed program text 
domain event contains name iff identifier triple process identifier send action process variable ffl bindings csp processes choose nondeterministically execute finite set receive actions 
initial prefix behavior process identifier event receive action chosen nondeterministically set ft variable name binding iff identifier triple 
example consider simple csp program jjq jjr jq process single behavior consisting events sequential send actions 
behavior receive action followed send action possible single event behaviors receive domain events behavior domain events behavior binding event binding second event null 
domain single event possible behaviors null case binding properties csp naming system member category ffl static binding name appears binding event identifier see bindings 
csp process identifiers unique events collocated naming system static binding property 
ffl static domains events naming system static domains property 
ffl multiplicity static binding events name bound object naming system multiplicity property 
ffl binding event behavior fixed program text specifies possible actions process 
set possible actions finite receive action specifies finite set sender ids 
behavior finite holds 
ffl aliased names identifier process actions 
identifier process actions 
exists computation containing communications events events 
naming system allows aliased names 
ffl private names name iff event process identifier communications naming system allows private names 
category csp vs csp naming system resides category immediately greatest lower bound lattice category containing simplest naming systems hierarchy 
general purpose models concurrency literature naming systems reside specialized naming systems described members category 
instructive study lower limit expressiveness naming systems 
naming systems reside higher hierarchy presumably incur overhead implementation 
additional complexity justified naming systems expressive 
may question instance naming systems csp simplicity primary design goal members aliased names property particular additional expressiveness csp 
resource allocation problem combination properties comprise sufficiently restrictive simple problems impossible solve efficiently 
consider simple resource allocation algorithm client objects request release units single resource centralized manager object 
limit overhead manager queue requests immediately satisfy 
unsatisfiable requests rejected may subsequently reissued client 
particular communication mechanism assumed specified communication synchronous asynchronous 
purposes example ignore issues fairness 
objects act follows 
types communications clients manager signals request signals release 
clients issue request release arbitrary order provided releases issued succeed responses received 
clients wait succeed fail response manager issuing subsequent requests 

types communications manager client signals success preceding request signals failure request 
receiving request manager responds succeed fail processing requests releases 

request succeeds iff initial resource units gamma succeed issued releases received 
manager may refuse accept release 

communications clients 
implementation algorithm naming system straightforward 
inefficient relies polling 
polling occurs unbounded number communications may pass objects object progress 
case client requires request succeed order progress manager may issue unbounded number failures client issuing success response 
tendency poll viewed artifact synchronization mechanism simply poor programming practice 
show alluded polling consequence restrictive naming system 
avoiding polling order prevent clients polling manager eliminate condition manager forced issue failure response request 
problem specification states manager responds immediately request fail free resources eliminating possibility fail responses implies manager receive request prepared issue succeed 
possible specify type communication manager accept point behavior 
theorem non polling solution resource allocation problem requires aliased names property 
proof consider computation consisting manager clients manager issues fail 
behavior manager event manager issues succeed number free resources 
source event communication source event communication concurrent 
condition request release 
conditions clients information state state manager 
communication may request release 

communication originating request communication originating release communication exist manager issue fail communication exists manager may refuse release condition possible communications exist 

communication originating release communication originating request communication exists communication exist 

request release may originate step step 
distinct names aliased names property holds 
informally polling avoided distinct names requests releases known client manager accept releases request result failure response 
client may communicate manager single name impossible determine manager receive request release point 
may refuse accept releases refuse accept requests may forced respond fail 
non polling solution resource allocation problem exist naming system member 
csp naming system subsume properties necessary non polling solution 
expressiveness principle manager queue requests clearly unsatisfiable request blocked queued depending synchronization properties communication level order avoid polling 
observe responsibility queueing requests merely shifted communication subsystem 
true fact desirable circumstances implement necessary queuing communication subsystem repeatedly object level 
note possible force communication subsystem handle queueing requests place exists action communication subsystem informed manager prepared accept request 
action precisely binding name associated requests manager object turn requires existence distinct names requests releases 
illustrates general principle relationship naming systems communication expressive naming system alter communication requirements algorithm 
allows required actions queueing specified interface objects communication subsystem allows actions implemented lower level 
category ada vs csp ada language designed concurrent programming mind addresses perceived limitations csp 
ada allows objects called tasks created fly allow existing tasks learn names newly created ones 
ada relaxes constraint csp requires objects identify order carry communication 
communication ada means rendezvous entry call accept action 
task initiates communication specifying task identifier entry identifier called task 
task identifier denotes task execute accept action specified entry 
properties ada naming system name defined ada naming system pair destination task id entry id 
differs csp source task identified 
domain event determined types identifiers entry identifiers identifiers declared tasks specified constants program identifiers created tasks pointer values assigned local variables task 
name domain event iff entry id fixed program text task declared task id fixed program text task created task id assigned local variable task occurrence event 
ada naming system dynamic domains property shared names property 
ada support dynamic domains general tasks learn new entry identifiers learn identifiers declared tasks 
task access identifiers specified constants program 
ada tasks may choose nondeterministically accept set entries 
binding event accept action identifier task event occurs entries specified accept action 
csp ada aliased names property names may coexist domain 
static binding property multiplicity property name bound events object identifier task identifiers globally unique 
holds binding event fixed program text specifies constant finite set entry identifiers 
advantages ada naming system early criticisms csp symmetric names receivers identify senders prevented problems require anonymous senders 
example case object implements service operating system network routing protocol receive communications indeterminate set clients 
accurate say limitation csp due symmetric names important note symmetric names possible manifestations private names property 
shared names property ada naming system distinguishes csp naming systems allow private names regardless ada permits tasks share variables semantics shared variables completely specified 
private names property realized 
examples systems communication objects specified private names include dataflow languages streams parallel logic languages single assignment variables point point channels 
ada naming system distinguished csp dynamic domain property 
property required implementation reactive systems events environment user login necessitate creation new objects runtime 
dynamic domains useful data parallel computations number objects data set partitioned varies size input 
category concurrent vs ada concurrent extension language supports distributed programming 
resembles ada computation consists dynamic set processes communicate rendezvous mechanism transactions equivalent entries ada 
process initiates communication executing transaction call 
transaction call completed destination process executes accept action transaction 
designers concurrent observed ada benefit ability accept outstanding entry calls conditionally values parameters 
concurrent accept action may augmented qualifier suchthat expr causing outstanding transaction call accepted expr true parameters transaction call 
generalization accept principle advantage concurrent naming system ada implements descriptive property 
properties concurrent naming system transaction call specifies static identifiers indicate called process transaction process respectively 
respect concurrent names resemble defined ada naming system 
suchthat qualifier concurrent names third component consisting values parameters transaction call name triple process id transaction id parameter list 
event execution action accept suchthat expr process identifier name binding event iff parameter list expr evaluates true 
expr may refer local variables process set names bound object event may depend local state object 
turn implies set names may bound object entire behavior potentially infinite descriptive property holds 
remaining properties concurrent naming system identical ada naming system 
way concurrent implements dynamic domains general ada implementation process identifiers transaction identifiers values passed process 
object may number names bound name bound bound object process identifiers unique static 
section discuss naming systems combine descriptive dynamic binding multiplicity 
preemptive scheduling problem descriptive property required set communications object prepared receive varies state object state space object potentially infinite 
consider problem managing prioritized access single resource specialized processor device controller 
resource allocation problem described section client objects request release resource manager object manager queue requests 
associated request integer priority determine client may preempt accessing resource 
objects act follows versions concurrent allow asynchronous communication 

clients may initiate request communication release communication manager integer priority 
clients wait succeed fail response manager issuing subsequent requests 
receiving succeed client issues release issuing request iff received preempt subsequent succeed 

types communications manager client signals success preceding request signals failure request preempts succeed receiving request manager responds succeed fail processing requests releases 

request succeeds iff resource currently free priority successful request 
case manager issues preempt client issued succeed responding succeed current request 

manager may refuse accept release satisfiable request 

communications clients 
resource allocation algorithm client may unbounded number unsuccessful attempts obtain resource succeeding 
case sufficient naming system allow manager distinguish requests releases distinguish satisfiable unsatisfiable requests 
avoiding polling revisited eliminating polling requires manager forced issue fail response request 
manager satisfy request priority request exceeds priority successful request 
name request communication initiated encode priority request name bound manager object exactly able satisfy request 
theorem non polling solution preemptive scheduling problem requires descriptive property 
proof assume set names may bound manager object contains names 
consider computation consisting manager clients manager issues fail 

conditions event client may initiation request communication events may concurrent priorities requests may distinct 

requests initiated concurrently gamma names bound manager exist communications initiated common name 
source event communication request 
source event second request 
common name 

behavior manager event manager issues succeed response request priority possible communication manager may refuse satisfiable requests condition 
bound manager event concurrent bound possible communication 
condition manager issue fail event case 
contradiction 

step names bound manager 
number names bound manager grows bound descriptive property holds 
note necessary clients order generate set requests require names bound manager need requests originated concurrently 
assumptions merely shorten proof 
example illustrates principle mentioned section descriptive name visible interface communication subsystem portion state object bound 
allows decisions blocking queueing communications lower level decisions function local states objects 
mechanism implements descriptive useful set names bound object computation potentially infinite finite large 
clear concise efficient write accept suchthat concurrent instance enumerate family entries ada possible value category 
linda associative broadcast exist naming systems members category subsumes categories hierarchy 
despite existence naming systems preferable expressive naming system implemented efficiently 
seen aliased names descriptive properties may require communication subsystem block queue communications may desirable cases 
similar tradeoffs exist naming system properties 
example naming systems relies logically shared data structure difficult realize distributed architectures processors share physical memory 
contrast naming systems linda associative broadcast members order show naming systems properties identical may markedly different implementations 
linda processes associative broadcast objects communicate asynchronous message passing subject weak ordering constraint 
shows set properties constitutes category implemented absence logically shared data structures 
linda linda program specifies set processes communicate inserting reading removing tuples data values logically shared data structure called tuple space ts 
tuples stored unordered ts 
processes manipulate ts operations removes tuple ts places ts read reads remove 
data value tuple type 
may pattern contains formal parameter fields 
tuple returned read operation data values match types formal parameters 
example operation size var type integer match tuple size 
tuple ts matches chosen arbitrarily 
match operation blocks process inserts matching tuple ts 
associative broadcast associative broadcast uses message broadcasting fundamental mode communication objects 
communication sender specifies target set objects receive message 
communication merely special case broadcast size target set 
associated object profile consists set attributes 
attribute symbol simple attribute symbol value pair compound attribute 
symbols may treated data values passed object message 
attribute may represent type object operations supports abstraction object state 
example distributed hashing algorithm profile find min max indicate object supports insert find operations key values range 
object consists set local data structures set operations 
receipt message causes operation indicated message executed 
operation may modify local data alter profile object broadcast messages 
message tuple selector arg selec tor propositional formula attributes specifies target set message 
example broadcast insert min send value object min attribute cause perform insert operation value message broadcast selector contained message matched profile object 
selector true object profile message received object 
broadcast primitive atomic 
profile object may change message transit 
case object guaranteed receive message 
messages guaranteed arrive order sent sent object 
elements ffl communications linda execution action may give rise number communications including 
number communications defined number subsequent read actions tuple placed ts 
communication occurs event execution action corresponding read 
associative broadcast communication execution broadcast action receipt message 
ffl names communication linda ts effect content addressable buffer 
name communication transmission tuple occurs tuple set names defined linda naming system exactly set tuples may appear ts 
names data linda 
associative broadcast names simply selectors appearing messages 
ffl bindings event execution action read linda process pattern 
exactly set tuples match associative broadcast binding event determined composition profile object event occurs 
event receipt message profile object occurrence iff satisfies message may received selector satisfied ffl domains names data tuples linda name known linda object exactly knows elements name 

iff constant fixed program text object occurs value local variable object 
similarly object associative broadcast knows name selector knows symbols appearing formula constitutes name 
properties differs significantly categories discussed earlier combines descriptive property multiplicity dynamic binding 
dynamic domains shared names aliased names properties linda associative broadcast similar naming systems examined earlier omit discussion properties 
ffl dynamic binding number copies linda tuple may appear ts sequentially simultaneously 
possible communications exist occurrences distinct actions occurrences distinct read actions 
may occur distinct objects linda naming system dynamic binding property 
dynamic binding holds associative broadcast 
communications may satisfied profile profile profiles distinct objects 
ffl multiplicity execution executions read distinct objects 
communications satisfy definition multiplicity property 
similarly message associative broadcast may received distinct objects 
ffl descriptive action linda process pattern containing formal parameters range infinite formal parameters type integer exists infinite partitioning edges objects set tuples match set names bound occurrence action infinite 
associative broadcast set potential profiles object infinite 
profile exists distinct set selectors satisfied profile 
infinite behavior infinite set names may bound object 
communication abstraction communication abstraction extends communication principles abstraction commonly applied data types synchronization control sequencing 
naming system properties enables communications specified level significantly naming systems properties absent 
description form abstraction provided descriptive incorporates state object names bound 
combined grouping abstraction multiplicity arbitrary sets objects descriptively named 
dynamic binding adds indirection allowing membership descriptively named group vary 
forms abstraction respectively generalizations structured naming space uncoupling continuation passing properties linda mentioned 
distributed cycle detection problem manager object section represents special case descriptively named groups group size possible member group 
exist problems naturally engender groups objects object potential member group membership group dynamic determined input environment 
cases group membership determined global state execution 
problems difficult solve distributed global data structures symmetric objects execute identical programs object distinguished coordinator algorithm absence descriptive dynamic binding multiplicity 
consider problem detecting cycles dynamic graph stored partitioning edge set set objects 
edge ordered pair nodes stored exactly object 
graphs arise instance precedence relation transactions replicated distributed database 
necessary check graphs cycles determine transactions executed network partition failure serializable 
solution uses probe communications objects traverse graph place 
graph frozen cycle detection occurs edges may added graph concurrently ongoing executions algorithm 

types communications add communication environment probe propagation object causing add edge set edges maintains 
receiving probe causes object propagate probe edges reachable node 
receiving add object propagates new unique probe graph 
node object labels nodes traversed edge issues probe node encountered traversal 
node labeled twice cycle exists 

receiving probe propagated starting node 
object receives probe node edges maintains 
provision objects communicate edges object coordinate instance algorithm implementation symmetric distributed 
furthermore condition requires minimal communication object may receive probe maintains edge probe propagated 
disallows brute force implementation object receives probe 
algorithm requires descriptive property requirement minimal communication object maintains subset infinite set possible nodes 
multiplicity required node may belong number edges probe traverses edge incident node reach objects appears 
dynamic binding required edges may added probes traversing graph set objects node appears may differ communication probe 
omit formal proof favor giving example algorithm expressed associative broadcast 
object identical specification initially profile nodes add receiving add add nodes nodes fug unique id probe receiving probe probe foreach local node reachable labeled declare cycle label broadcast probe nodes principle expressiveness applies 
descriptive dynamic binding multiplicity properties associative broadcast allow specify algorithm leaves naming system ensure probe message delivered correct set recipients 
absence properties necessary objects explicitly implement protocol done naming system 
require stated assumptions removing minimal communication requirement brute force approach breaking symmetry algorithm 
designing naming system faced tradeoffs expressiveness complexity result diversity ways names bindings may established manipulated create patterns communication objects 
decisions awareness range possible choices impact structure programs computations choice 
taxonomy naming systems described intended allow alternatives examined systematic way 
sought identify set fundamental properties clarify role names bindings concurrent programming capture practical distinctions naming systems implicit informal comparisons concurrent programming systems 
arrangement properties orthogonal sets mutually exclusive elements simplicity regularity structure taxonomy ensures naming system belongs categories hierarchy 
taxonomy tool comparing selecting evaluating naming systems position naming system hierarchy determines set naming systems properties subsumes 
algorithm required naming system properties known taxonomy allows selection naming system having necessary properties 
may appropriate measure determine naming system best possible implementation properties target architecture cf 
linda vs associative broadcast 
seen expressive naming systems allow operations queueing filtering communications implemented object level 
eliminates error prone duplication effort encourages efficient implementation operations offers possibility exploiting developing specialized features underlying architecture 
composition taxonomy driven extent observation sought define properties capture significant distinctions existing naming systems affect ability naming system express solutions important classes problems 
possible suitability taxonomy particular purpose may improved adding axes coordinate space contains lattice categories subdividing coordinates axis improve resolution hierarchy 
changes invalidate results obtained current structure 
modifications approached caution complicate process classifying naming systems 
fact taxonomy simplified significantly course development 
explicitly avoided discussing resolution resolution mechanism naming system orthogonal binding name access mechanisms 
properties resolution mechanisms may cases influence patterns communication structure computations 
account effects taxonomy augmented properties resolution orthogonal existing sets properties 
ackerman dataflow languages ieee computer vol 
feb ahamad bernstein application name addressing low level distributed algorithms ieee trans 
software eng vol 
se jan associative broadcast comprehensive approach naming concurrent programming phd 
dissertation dept computer sciences univ texas austin expected may birman joseph reliable communication presence failures acm trans 
comp 
systems vol 
feb chandy lamport distributed snapshots determining global states distributed systems acm trans 
comp 
sys vol 
feb comer peterson names name resolution concurrency control reliability distributed systems bhargava ed van nostrand reinhold davidson optimism consistency partitioned database systems acm trans 
database systems vol 
sept department defense manual ada programming language ansi mil std dod washington jan naming object rigorous model phd dissertation proposal ut austin cs dept july francez script communication abstraction mechanism proc 
acm symp 
principles distributed computing aug gehani concurrent software pract 
exper vol 
sep gehani concurrent programming ada language polling bias software pract 
exper vol 
may gehani broadcasting sequential processes bsp ieee trans 
software eng vol 
se july gelernter generative communication linda acm trans 
prog 
languages systems vol 
jan partial orders axiomatic theory shuffle phd 
thesis computer science dept stanford univ dec broadcasting source addressed messages proc 
th int 
conf 
distributed computing syst may hoare communicating sequential processes cacm vol 
pp 
aug kernighan ritchie programming language prentice hall englewood cliffs lamport time clocks ordering events distributed system cacm vol 
july oppen dalal clearinghouse decentralized agent locating named objects distributed environment xerox office products division research report oct pratt modeling concurrency partial orders int 
journal parallel programming vol 
feb saltzer naming binding objects operating systems advanced course bayer eds springer verlag takeuchi furukawa parallel logic programming languages proc 
rd int 
conf 
logic prog springer verlag berlin pp 

