chapter approximate tree pattern matching dennis shasha zhang book study strings 
chapter trees 
graphs geometry 
trees generalize strings direct sense string simply tree single leaf 
unsurprising consequence algorithms specialize strings happy consequence algorithms efficient best string algorithms 
point view additional pragmatic advantage relationship trees strings techniques strings carry trees suffix trees show promise don know exploits 
provides example area applications techniques 
second friends may wonder easy reduction take tree edit problem map strings solve string domain map back 
don believe see tree editing inherently data dependence string editing 
specifically dynamic programming approach string editing local operation depending left upper upper left neighbor cell 
tree editing upper left neighbor usually irrelevant relevant cell depends tree topology 
belief theorem state right outset key open problem tree edit problems ordered trees trees order siblings matters reduced efficiently string edit problems back 
rest article proceeds assumption question negative response 
particular discuss best known algorithms tree editing variations having subtree removal variable length don cares alignment 
discuss sequential parallel algorithms 
negative results having unordered trees trees sibling order arbitrary approximation algorithms 
discuss problem finding commonalities set trees 
editing problem unordered trees np complete say possible map string problem 
chapter 
approximate tree pattern matching preliminary definitions early history trees free tree connected acyclic undirected graph 
rooted tree free tree vertices distinguished called root 
refer vertex rooted tree node tree 
unordered tree just rooted tree 
term unordered tree distinguish rooted ordered tree defined 
ordered tree rooted tree children node ordered 
node children designate child second child kth child 
stated trees consider ordered labeled rooted trees unordered labeled rooted trees 
tree usually convenient numbering refer nodes tree 
ordered tree left right postorder numbering left right preorder numbering number nodes jt size tree unordered tree fix arbitrary order node tree left right postorder numbering left right preorder numbering 
suppose numbering tree 
ith node tree numbering 
denote subtree rooted 
brief review algorithmic results exact tree matching distinguish exact approximate matching follows 
match objects exact matching relation member 
sense strings ing matches willing defined match sequence non blank characters 
match objects matching relation inexact approximate isn exact 
example ing matches widen approximately 
case approximate match distance normally monotonic function smallest changes result objects respectively member 
edit distance ing matches widen distance number changes widen transform wing 
concerned approximate matching trees review results exact matching trees extremely brief serving give pointers important papers hint algorithmic idea 
exact tree matching variables pattern target ordered labeled trees size respectively matches node exists mapping nodes nodes 
root maps 
maps labels 
maps leaf ith child maps ith child 
imply maps subtree rooted merely degree degree 

preliminary definitions early history obvious algorithm takes nm time 
classic open problem bound improved 
kosaraju broke nm barrier problem nm algorithm 
note polylog introduced new techniques suffix tree tree convolution tree string partitioning trees chains anti chains 
galil improved result giving algorithm 
result truncated suffix trees roughly speaking shorten representation paths root pattern descendants root length periodical strings 
string ff period string fi fi prefix ff galil construct truncated suffix tree sigma time 
depending leaves sigma cases ffl sigma leaves 
show possible roots target tree 
find possible roots check see match time 
ffl sigma leaves 
show properties periodical strings matching time 
gives time algorithm 
exact pattern matching variables exact pattern matching applications term rewriting systems code generation logic programming particularly restricted form unification 
application patterns constructed recursively single wild card variable constant function arguments patterns language 
patterns 
recursion induces tree expression parent arguments children subpatterns 
pattern matches general holds 

inclusive 
note allows variable match entire subtree isn variable function symbol 
set patterns subject pattern multi pattern matching problem find set elements match subpattern subtree approaches problem algorithms start roots trees top start leaves bottom 
bottom approaches require significant preprocessing time patterns handle subject faster time proportional size subject plus number matches 
rewriting systems subject constantly changing bottom attractive 
development rewriting systems construction conventional compilers pattern matching backend code generation phases patterns change frequently 
compiler constructed patterns static 
basic technique bottom algorithms construct set pf subpatterns exponential size space time requirement large effort gone finding data structures hold set 
chapter 
approximate tree pattern matching basic algorithm pattern matching variables due hoffman donnell 
improvements better data structures variations algorithm proposed chase cai paige tarjan 
thorup presents short algorithm subtle amortized analysis improves space complexity usually time complexity preprocessing simple patterns size log time space 
edit operations edit distance edit operations consider kinds operations ordered labeled trees 
changing node means changing label deleting node means making children children parent removing inserting complement deleting 
means inserting child parent consecutive subsequence current children edit operations consider kind operations unordered labeled trees 
case insertion operation change consecutive subsequence subset 

preliminary definitions early history suppose node label symbol chosen alphabet unique symbol denote null symbol 
represent edit operation label node tree label node tree call change operation delete operation insert operation tree results application edit operation tree written sequence edit operations 
derivation tree tree sequence trees gamma fl cost function assigns edit operation nonnegative real number fl 
constrain fl distance metric 
fl fl ii fl fl iii fl fl fl 
extend fl sequence edit operations letting fl jsj fl 
edit alignment distances edit distance trees defined considering minimum cost edit operations sequence transforms tree 
formally edit distance defined min ffl ed operation sequence alignment distance trees defined considering edit operation sequences insertions precede deletions 
reason called alignment distance clear discuss 
note edit distance fact distance metric alignment distance satisfy triangle inequality 
early history approximate tree matching algorithms tai classical kuo chung tai gave definition edit distance ordered labeled trees non exponential algorithm compute 
algorithm quite complicated making hard understand implement 
space complexity large practical 
sketch algorithm 
tai preorder number number trees 
convenient aspect notation jt nodes tree rooted 
trees edit distance 
approach sequence editing 
assume gamma gamma gamma gamma known extend 
involved substitution exactly sequence editing 
just need gamma gamma plus cost deleting inserting 
difficult case occurs substitute 
case ancestor ancestor substitute chapter 
approximate tree pattern matching 
furthermore nodes path deleted nodes path inserted 
difficult case optimal edit sequence gamma gamma may find pair 
means general derive gamma gamma 
order deal difficulty tai introduces measures trees resulting algorithm quite complex time space complexity jt theta jt theta depth theta depth 
lu algorithm edit distance algorithm ordered trees reported lu 
lu definition edit operations tai 
algorithm lu compute edit distance defined 
provide edit distance 
briefly discuss algorithm show properties 
children children 
algorithm consider cases 

deleted 
case distance match subtrees delete rest subtrees 

inserted 
case distance match subtrees insert rest subtrees 

preliminary definitions early history 
matches 
case consider subtrees sequences individual subtree entity 
sequence edit distance determine distance 
description easy see difference distance edit distance 
algorithm considers subtree entity 
allow subtree map subtrees definition edit distance delete root subtree map remaining subtrees subtree subtrees 
lu distance different edit distance shows example 
edit distance need delete node distance lu algorithm delete node tree replace node directly delete node map subtree rooted map subtrees tree resulting distance 
level trees algorithm fact compute edit distance ordered trees trees levels 
variants problem selkow gave tree edit algorithm insertions deletions restricted leaves trees 
leaves may deleted node may inserted leaf 
case easy see maps parent map parent 
reason deleted parent deleted inserted 
means nodes matched parents matched 
yang give algorithm identify syntactic differences programs 
algorithm basically variation selkow 
easy design algorithm string edit algorithm subroutine solve problem 
time complexity jt theta jt 
mannila introduced tree inclusion problem 
pattern tree target tree tree inclusions asks embedded alternative definition get deleting nodes ordered trees unordered trees considered 
may exponentially ordered embeddings concept called left embedding avoid searching embeddings 
assume roots chapter 
approximate tree pattern matching label algorithm tries embed embedding subtrees deeply far left possible time complexity algorithm jt theta jt 
showed unordered inclusion problem np complete 
tree edit tree alignment algorithms ordered trees notation computing tree tree edit distance compute subroutines distance certain pairs subtrees certain pairs ordered 
ordered tree collection subtrees appearing order appear specifically left right postorder numbering nodes trees 
tree represents ith node tree represent subtree rooted represent ordered obtained deleting 
desc denote set descendants denote substructure induced nodes numbered inclusive 
general ordered forest 
children 
represent forest consisting subtrees 

postorder number leftmost leaf descendant subtree rooted 
leaf notation gamma 
depth represent depth tree leaves represent number leaves tree deg represent degree tree basic tree edit distance computation mapping edit distance edit operations give rise mapping graphical specification edit operations apply node trees ordered forests 
mapping shows way transform corresponds edit sequence delete node label change node label label insert node label 
formally define triple mapping set pair integers satisfying jt jt pair iff left iff left sibling order preserved ancestor iff ancestor ancestor order preserved 
tree edit tree alignment algorithms ordered trees mapping confusion 
mapping cost defined follows fl fl fij mg fl fjj mg fl mappings composed 
mapping mapping define ffi easy show ffi mapping fl ffi fl fl 
relation mapping sequence edit operation follows sequence 
edit operations exists mapping fl fl conversely mapping exists sequence editing operations fl fl 
implies fl mapping specifically nodes untouched correspond deletions nodes connected correspond null edits connected nodes label relabelings connected nodes different labels nodes untouched correspond insertion operations 
mapping idea design algorithm subsection concept mapping easy visualize order independent 
general formula distance denoted forestdist simply forestdist context clear 
abbreviated notation certain special cases 
distance denoted treedist 
lemmas give algorithm 
lemma forestdist ii forestdist forestdist gamma fl iii forestdist forestdist gamma fl desc desc chapter 
approximate tree pattern matching proof trivial 
lemma desc desc 
forestdist min forestdist gamma fl forestdist gamma fl forestdist gamma gamma forestdist gamma gamma fl proof compute forestdist trying find minimum cost map forest forest 
map extended ways 
touched line forestdist forestdist gamma fl 
touched line forestdist forestdist gamma fl 
touched lines 
suppose gamma right right sibling condition mappings 
impossible forest 
similarly proper ancestor proper ancestor ancestor condition mappings 
impossible 
symmetry ancestor condition mappings node subtree touched node subtree 
forestdist forestdist gamma gamma forestdist gamma gamma fl 
cases express possible mappings yielding forestdist take minimum costs 
lemma proved 
lemma desc desc 
forestdist min forestdist gamma fl forestdist gamma fl forestdist gamma gamma fl forestdist min forestdist gamma fl forestdist gamma fl forestdist gamma gamma treedist proof immediately lemma 

tree edit tree alignment algorithms ordered trees algorithm edit preprocessing compute lr lr lr lr compute treedist output tree dist jt jt computing treedist 
algorithm lemma important implications 
formulas yields suggest dynamic programming style algorithm solve tree distance problem 
second lemma observe order compute treedist need advance values treedist root subtree containing root subtree containing suggests bottom procedure computing subtree pairs 
third lemma observe path path need compute treedist separately 
subtree distances obtained byproduct computing treedist 
implications lead definition algorithm 
define set lr tree follows lr fk exists lr root left sibling 
intuitively set roots subtrees tree need separate computations 
easy see linear time algorithm compute function set lr 
assume result array lr 
array lr order elements increasing order 
ready simple algorithm computing edit distance 
dynamic programming compute treedist 
forestdist values computed put temporary array freed corresponding treedist computed 
treedist values put permanent treedist array 
chapter 
approximate tree pattern matching computation treedist strong lemmas 
algorithm procedure treedist forestdist forestdist forestdist gamma fl forestdist forestdist gamma fl calculate forestdist lemma 
treedist forestdist put permanent array calculate forestdist lemma 
output treedist desc desc 
computing treedist 
easy see subtree pair time complexity treedist jt theta jt provided necessary treedist values available available 
compute treedist bottom compute distance time complexity algorithm bounded jt jt jt theta jt jt jt theta jt jt jt theta jt theta depth theta depth gamma fact complexity bit better 
careful analysis show complexity jt theta jt theta min depth leaves theta min depth leaves 
leaves number leaves implication algorithm compute distance strings time jt theta jt 
pattern trees variable length don cares problems strings solved dynamic programming 
similarly algorithm applies tree distance variety tree problems time complexity 

tree edit tree alignment algorithms ordered trees approximate tree matching variable length don cares approximate tree matching generalization approximate string matching 
trees view tree pattern tree data tree 
want match approximately pattern tree data tree 
match allow pattern tree match part data tree 
purpose allow subtrees data tree cut freely 
allow pattern tree contain variable length don cares length don cares suppress details data tree interested 
intuitively vldc match part path subtrees branching path 
give formal definitions cut variable length don cares approximate tree matching 
cutting node means removing subtree rooted 
set nodes 
define set consistent subtree cuts implies ancestor 
cut represent tree subtrees rooted nodes removed 
subtree set possible sets consistent subtree cuts 
term approximate tree matching vldc defined computing tree cut min subtree cut intuitively distance pattern tree cut data tree cut yields smallest possible distance 
consider vldc node pattern tree substitute part path root leaf data tree 
node pattern tree substitute part path subtrees emanating nodes path possibly lowest node path 
lowest node symbol substitute set leftmost subtrees set rightmost subtrees 
call path vldc umbrella vldc shape impose tree 
pattern tree contains umbrella path data tree 
vldc substitution replaces path vldc path nodes umbrella vldc umbrella pattern nodes require mapping resulting vldc free pattern map substituting nodes 
cost induced vldc substitutions 
approximate matching defined tree vldc tree cut 
tree vldc min ftree vldc set possible vldc substitutions 
algorithm lemma shows kinds presence free subtree cuts 
lemma path vldc substituted umbrella vldc vice versa changing mapping distance value allow subtrees cut freely text tree 
case matching cuttings involved 
case consider kinds separately need auxiliary suffix forest distance measure dealing umbrella 
chapter 
approximate tree pattern matching proof trivial 
compute tree vldc jp jt intermediate steps need calculate forest vldc algorithm considers cases separately forest trees 
strategy try find best substitution ask cut 
note algorithm fl fl 
lemma forest forest vldc min forest vldc gamma forest vldc gamma fl forest vldc gamma fl forest vldc gamma gamma tree vldc proof cut forest vldc forest vldc gamma 
consider minimum cost mapping performing optimal removal subtrees 
distance minimum cases 
touched line 
includes case replaced empty tree 
forest vldc forest vldc gamma fl 
touched line forest vldc forest vldc gamma fl 
touched lines 
includes case replaced path nodes ancestor sibling conditions mappings ancestor condition mapping node subtree rooted touched node 
forest vldc forest vldc gamma gamma tree vldc 
lemma forest vldc min forest vldc forest vldc gamma fl forest vldc gamma fl forest vldc gamma gamma fl proof cut distance forest vldc 
consider minimum cost mapping performing optimal removal subtrees 
cases 
depending touched line argue similarly lemma 

best substitution replaced empty tree case forest vldc forest vldc gamma fl 
tree edit tree alignment algorithms ordered trees replaced case forest vldc forest vldc gamma gamma fl 
distance minimum cases 
forest vldc gamma fl forest vldc fl forest vldc forest vldc gamma forest vldc gamma gamma fl 
add additional item forest vldc gamma fl minimum expression obtaining formula asserted lemma 
lemma forest vldc min forest vldc forest vldc gamma fl forest vldc gamma fl forest vldc gamma gamma fl min ftree vldc children proof cut distance forest vldc 
minimum cost mapping performing optimal removal subtrees 
cases 
best substitution replaced empty tree 
forest vldc forest vldc gamma fl 
best substitution replaced nonempty tree touched line forest vldc forest vldc gamma fl 
best substitution replaced nonempty tree touched line replaced path tree rooted 
path node 
children left right order 

subcases 
replaced 
forest vldc forest vldc gamma gamma fl 
child path 
cut subtrees sides path 
forest vldc tree vldc 
value ranges distance minimum corresponding costs 
lemmas suggest algorithm 
omit initialization steps 
fast parallel algorithms small differences research imported technology developed strings develop fast tree algorithms 
particularly example algorithm unit cost edit distance unit cost means node deletions node node insertions cost 
algorithm starts ukkonen technique computing waves center diagonals distance matrix 
stage distances gamma computed 
stage computes parallel distances suffix trees landau vishkin perform computation fast 
string case distance gamma gamma 
main difficulty tree case chapter 
approximate tree pattern matching procedure tree vldc calculate forest vldc lemma calculate forest vldc lemma calculate forest vldc lemma tree vldc forest vldc computing tree vldc 
preserving ancestor relationships mapping trees prevents analogous implication holding 
addition compute distance forests stage requires knowing contained subtrees distance apart 
overcome problems studying relationship identical distance mappings 
find relevant identical forests suffix trees corresponding different traversals 
preprocessing time complexity dominated cost constructing suffix trees 
bounded log jt jt log theta min jt jt log min jt jt log 
time complexity algorithm theta log theta log min jt jt actual distance tree alignment problem known edit alignment equivalent notions sequences 
particular sequences edit distance equals value optimal alignment edit alignment turn different trees see 
introduce notion alignment trees measure similarity labeled trees 
notion natural generalization alignment sequences 

tree edit tree alignment algorithms ordered trees definitions labeled trees 
alignment obtained inserting nodes labeled resulting trees topologically isomorphic identical labels ignored overlaid example alignment shown 
edit cost defined pair labels 
value alignment sum costs pairs corresponding labels 
optimal alignment minimizes value possible alignments 
alignment distance value optimal alignment tree 
tree 
optimal alignment easy see general edit distance smaller alignment distance trees 
reason alignment trees corresponds restricted tree edit insertions precede deletions 
note order edit operations important sequences 
alignment charges structural dissimilarity top levels trees lower levels edit treats levels 
notion alignment easily extended ordered forests 
change possible insert node root join consecutive subsequence trees forest 
denote alignment distance forests 
denote empty tree fl denote cost opposing letters fixed ordered labeled trees section 
formulas node node suppose degrees number children respectively 
denote children 
children 

represent forest consisting subtrees 

convenience denoted 
note 
defined similarly 
lemmas form basis algorithm 
lemma trivial 
lemma fl fl 
chapter 
approximate tree pattern matching lemma min min rn fa gamma min rm fa gamma fl proof consider optimal alignment tree 
cases label labels labels labels need consider case case delete nodes add new root resulting better alignment 
case 
root labeled 
clearly fl 
case 
root labeled 
case node min rm fa gamma case 
similar case 
note implies required computing 
lemma min gamma gamma gamma gamma fl min fa gamma gamma fl min fa gamma gamma proof consider optimal alignment forest 
root rightmost tree labeled 
case label 
case rightmost tree optimal alignment 
gamma gamma 
case label 
case aligned gammak 
key observation fact subtree gammak split alignment 
subcases 
gammak 
gamma 
gammak 
case 
general case 
easy see fl min fa gamma gamma case label 
similar case 

tree edit tree alignment algorithms ordered trees input 
procedure forest align gamma gamma gamma gamma gamma gamma gamma gamma compute lemma 
output computing fa js fixed algorithm follows lemmas pair subtrees compute need align conversely align 
note align arbitrary forest arbitrary forest 
time complexity higher 
fixed procedure computes fa js assuming known known obtain calling procedure forest align times calling procedure forest align times 
algorithm compute 
input running time procedure forest align bounded gamma theta gamma theta gamma gamma theta theta pair algorithm align spends theta theta time 
time complexity algorithm align jt jt theta theta jt jt theta theta deg deg chapter 
approximate tree pattern matching algorithm align jt initialize lemma jt initialize lemma jt jt call procedure forest align call procedure forest align compute lemma 
output jt jt computing 

algorithms hardness results unordered trees deg deg theta jt theta jt jt theta jt theta deg deg degrees bounded constant time complexity jt delta jt 
note algorithm computes 
data materializing optimal alignment back tracking 
complexity remains 
tree pattern discovery problem briefly discuss pattern discovery problem 
matching problems pattern need find distance pattern objects discovery problems contrast objects target distance asked find largest portions objects differ distance 
specializing discovery problem pair trees want find largest connected component tree distance target distance value 
consider connected component trees 
connected rooted node generated cutting subtrees 
means naive algorithm tree pattern discovery consider subtree pairs subtree pair possible cuts subtrees 
number possible cuts exponential naive algorithm clearly impractical 
compound form dynamic programming 
compound mean dynamic programming applied compute sizes common patterns subtree pairs set cuts find cuttings yield distances equal target compute optimal cuttings distance optimal cuttings distances gamma 
computation optimal solution distance value solve problem unique trees 
consider pair subtrees roots map optimal solution distance value general subtree pairs map 
determine distance value distributed subtree pairs obtain optimal solution 
solve problem partitioning subtrees respectively forest subtree 
compute distance size values forest forest subtree subtree 
general framework solve tree pattern discovery problem edit alignment distance measures 
target distance value time complexity algorithm edit distance measure depth leaves depth leaves time complexity algorithm alignment distance measure theta jt theta jt theta deg deg 
algorithms hardness results unordered trees recall unordered labeled trees rooted trees nodes labeled ancestor relationships significant left right order siblings significant 
trees arise naturally genealogical studies example parts explosions 
chapter 
approximate tree pattern matching applications useful compare unordered labeled trees meaningful distance metric 
editing distance metric success ordered labeled trees natural metric 
alignment distance metric 
section presents algorithms complexity results metrics 
hardness results reduce exact cover sets problem computing edit distance unordered labeled trees 
means computing edit distance unordered labeled trees np hard 
assume edit operation unit cost fl exact cover sets instance finite set jsj collection element subsets question contain exact cover subcollection ae element occurs exactly member fs ft ij construct trees 
reduction lemmas show treedist gamma exists exact cover 
problem clearly np lemmas show problem np complete 
proofs lemmas left exercises 

algorithms hardness results unordered trees lemma mapping nodes mapping fl gamma lemma treedist gamma 
lemma exact cover treedist gamma gamma 
lemma treedist gamma exists exact cover 
fact stronger results concerning hardness computing edit distance alignment distance unordered labeled trees 
computing edit distance unordered labeled trees max snp hard trees binary 
computing alignment distance unordered labeled trees max snp hard trees allowed arbitrary degree 
techniques proofs similar just 
reduction maximum bounded covering sets optimization version exact cover sets 
algorithm tree alignment heuristic algorithm tree edit degrees bounded compute alignment distance modified version algorithm align 
lemmas 
difference computation 
revise recurrence relation lemma follows forest ft 
forest ft 
min min gamma ft gamma ft min gamma ft gamma fl minc gamma gamma ft fl bounded computed polynomial time 
fact binary trees algorithm simplified shown easy see time complexity algorithm jt delta jt 
edit distance efficient enumerative algorithm 
algorithm runs polynomial time trees bounded number leaves 
general cases developed heuristic algorithms probabilistic hillclimbing 
way deal hardness results add constraints way transform tree 
leads constrained edit distance unordered trees 
complexity algorithm jt theta jt theta deg deg theta log deg deg 
chapter 
approximate tree pattern matching algorithm align jt jt minf fl fl fl fl minf fl fl fl fl fl output jt jt 
aligning unordered binary trees 
discovered making tree comparison software generally available applications require comparison trees 
biology rna secondary structures topological characterizations folding single strand nucleotides 
determining functionality structures depends topology comparing different ones topology interest 
networks connections starting single point describe trees 
comparing may give hint structure 
genealogy unordered trees interest may give hints origins hereditary diseases 
language applications comparing parse trees interest 
currently developing package enable users compare structured documents tree edit distance 
informative utilities unix diff 
algorithmically tree comparison bears similarity string comparison 
tree comparison uses dynamic programming suffix trees parallel versions counter diagonals 
reason analogy developing new algorithms 
reason believe may discipline study talented tired dimensional structures 
tree string problems different reduction send email re interested 

exercises appears possible certainly unordered trees np completeness result conjecture ordered trees 
pursuing new applications letting lead new algorithms currently working problem tree pattern discovery 
philosophy best shown distinction described far 
date consisted primarily finding distance pattern tree data tree pattern metric 
contrast tree pattern discovery consists producing pattern tree distance metric close collection data trees 
tree motifs characterize collection trees representing phenomenon nature 
currently working secondary structure viruses 
exercises 
counter diagonal dynamic programming matrix extends location 
trees strings elements counter diagonal computed parallel 
design parallel version algorithm edit 
hint complexity jt jt 

suppose interested editing distance trees assuming differed algorithm return exact distance equal return different 
time complexity case 
hint complexity proportional square 
pruning tree node means removing children removing 
define optimal pruning distance pattern tree data tree minimum distance tree followed pruning 
hint algorithm variant algorithm cuts 

consider procedure tree vldc eliminating path free matched variable length don care 
consider metric inserts deletes replacements cost deletions paths text tree subtrees unit cost 
design algorithm compute cost 

prove lemma lemma 
try show max snp hardness result mentioned section reduction maximum bounded covering sets 

geographical data structures quadtrees rotation invariant suppose wanted find editing distance trees allow rotations children roots 
ordered rooted trees find distance rotation children root rotation children root distance minimum rotations hint degree root trees greater depth trees complexity greater algorithm edit 
chapter 
approximate tree pattern matching 
suppose pair ordered trees define edit distance trees edit distance rooted trees isomorphic isomorphic distance minimum edit distance pairs rooted trees isomorphic isomorphic hint algorithm developed previous question subroutine 
bibliographic notes attempt generalize string edit distance ordered trees due selkow 
gave tree edit algorithm insertions deletions restricted leaves trees 
edit distance ordered trees introduced tai 
edit base distance introduced lu 
lu treated subtree entity allow subtree match subtrees tree 
tanaka tanaka introduced strongly structure preserving mapping gave algorithm kind mapping 
algorithm lu algorithm 
yang gave algorithm mapping nodes mapping implies parents mapping 
edit distance unordered tree considered zhang statman shasha 
jiang wang zhang considered tree alignment distance problem 
tree inclusion problem introduced mannila 
algorithm edit distance chapter due zhang shasha 
alignment distance algorithm due jiang wang zhang 
open time complexity algorithm improved 
non trivial lower bound result problems 
parallel algorithm unit cost edit distance discussed chapter due shasha zhang 
open restriction unit cost removed 
approximate tree match considered zhang shasha 
extended handle case pattern tree variable length don cares 
algorithm due zhang shasha wang 
np completeness results edit distance unordered trees due zhang statman shasha 
max snp hard result due zhang jiang 
open problems approximated constant 
cai paige tarjan 
efficient bottom multi pattern matching trees theoretical computer science pp 

chase 
improvement bottom tree pattern matching proceedings th annual cm symposium principles programming languages pp 

galil 
faster tree pattern matching jacm pp 

hoffman 
pattern matching trees jacm pp 


jiang wang zhang 
alignment trees alternative tree edit proceedings fifth symposium combinatorial pattern matching pp 

mannila 
ordered unordered tree inclusion appear siam computing 
kosaraju 
efficient tree pattern matching proceedings th annual ieee symposium foundations computer science pp 

landau vishkin 
fast parallel serial approximate string matching algorithms pp 
lu 
tree tree distance application cluster analysis ieee trans 
pami pp 
selkow 
tree tree editing problem information processing letters pp 
shapiro zhang 
comparing multiple rna secondary structures tree comparisons comput 
appl 
biosci 
pp 
shasha wang zhang 
exact approximate algorithms unordered tree matching ieee trans 
systems man cybernetics pp 
shasha zhang 
fast algorithms unit cost editing distance trees algorithms pp 
tai 
tree tree correction problem acm pp 
tanaka tanaka 
tree tree editing problem international journal pattern recognition artificial intelligence pp 
thorup 
efficient preprocessing simple binary pattern forests proceedings th scandinavian workshop algorithm theory lecture notes computer science pp 

ukkonen 
finding approximate patterns strings algorithm pp 
wang zhang jeong shasha 
system approximate tree matching ieee trans 
knowledge data engineering pp 
yang 
identifying syntactic differences programs software practice experience pp 
zhang 
constrained editing distance unordered labeled trees appear algorithmica 
zhang jiang 
max snp hard results concerning unordered labeled trees information processing letters pp 
zhang shasha 
simple fast algorithms editing distance trees related problems siam computing pp 
zhang shasha wang 
approximate tree matching presence variable length don cares algorithms pp 
chapter 
approximate tree pattern matching zhang statman shasha 
editing distance unordered labeled trees information processing letters pp 
