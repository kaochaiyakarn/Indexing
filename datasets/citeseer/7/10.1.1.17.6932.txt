speeding douglas peucker line simplification algorithm john hershberger dec systems research center lytton ave palo alto ca usa src dec com jack snoeyink department computer science university british columbia vancouver bc canada snoeyink cs ubc ca analyze line simplification algorithm reported douglas peucker show worst case quadratic number input points 
give algorithm path hulls uses geometric structure problem attain worst case running time proportional log best case douglas algorithm 
give complete code compare algorithms theoretically operation counts practically machine timings 
important task art extracting features detailed data representing simple readable map 
computers increasingly involved automated cartography efficient algorithms needed tasks extraction simplification 
identified line simplification problem important part representing linear features 
ordered set points plane fv forms polygonal chain sequence line segments gamma chain segments line simplification problem asks chain fewer segments represents 
assume chain simple self intersections 
cartographic applications self intersections indicate errors digitization 
require approximation simple indication computationally infeasible 
representing possible meanings 
example may require close distance area small critical points incorporated measures curve discrepancy small 
mcmaster gives detailed study mathematical similarity discrepancy measures 
ranks method reported douglas peucker mathematically superior 
white performed study simplification algorithms marino critical points psychological measure curve similarity 
showed douglas peucker method best choosing critical points reports generalizations produced douglas algorithm overwhelmingly percent sample subjects deemed best perceptual representations original lines 
douglas method advantages 
easy program wade give complete fortran code 
second simplification produces hierarchical structure exploited jones abraham scale independent cartographic databases 
surprise method independently proposed contexts 
examples papers image processing rote computational geometry 
analyze algorithms implement douglas peucker simplification method different data structures 
section give basic simplification method discuss compare algorithms 
section give theoretical analysis douglas peucker implementation show worst case running time shows quadratic growth number input segments increases 
section give new algorithm path hull data structure worst case running time asymptotically best case douglas peucker algorithm 
subsections describe geometric structure problem define path hull data structure exploit analyzes new implementation results 
section gives timings sample runs 
simplification method douglas peucker method douglas peucker best described recursively approximate chain start line segment farthest vertex segment distance ffl accept approximation 
split chain vertex recursively approximate pieces 
algorithm precise 
array vertices call simplifies subchain procedure 
find vertex farthest line dist distance 

dist ffl 
split approximate 
recursively 
output approximation algorithm basic line simplification method familiar original douglas peucker recursive procedure equivalent iterative method heuristic improvement stacking anchors 
stated recursive procedure see justification anchor stacking 
notice algorithm uses subset original vertices fv form approximate chain 
statement line seen way choose vertex splitting vertex 
primary difference douglas peucker algorithm path hull algorithm choose splitting vertex 
notice calls order 
describe algorithms sections say words compare 
course compare implementations timing sample data section 
timings tell specific problem instance know extrapolate timing instances encounter practice 
understand capabilities algorithms knowing best worst case data design better test sets interpret results tests accurately 
theoretical analysis algorithms counts number operations algorithm uses function number input segments 
familiar analysis safely skip remainder section 
differences machines compilers qualitative behavior counts revealing quantitative behavior 
define commonly big notation illustrate examples 
integer functions say constants ag say theta positive constant cg infinitely integers statement involving big gives upper limit increase running time statement involving big theta gives upper lower limit 
example call finds splitting vertex outputs line segment know gamma calls compute approximate chain having segments 
give weaker qualitative bounds theta calls calls different computer systems different costs associated making call actual count slightly informative asymptotic count difficult obtain 
sections see running times douglas peucker algorithm path hull algorithm worst cases theta steps theta log steps respectively 
qualitative difference implies size problem increases worst case time increases fold 
increases factor go go 
furthermore technology improves fold handle problem times greater allows jumps 
best case algorithms theta chain approximated single segment 
approximated best cases theta log theta respectively 
way data structure gives reason look case key idea run recursive simplification algorithm tolerance ffl simplification occurs keep track splitting points distances 
scale dependent tolerance ffl algorithm rerun need search splitting vertex 
course comes practical implementation factors constants matter 
example douglas algorithm records geometric structure expected lower constant algorithm 
theoretical analysis substitute running test cases discovering machine dependent quantitative behavior 
qualitative behavior reveals important understanding algorithm designing test cases interpreting results 
simple implementation step obvious way find splitting vertex step algorithm find point farthest line compute distance point fv keep maximum 
algorithm implements idea 
find splitting vertex farthest line evaluating distances keeping maximum 
return distance dist procedure dist set dist gamma fi fi fi fi fi fi fi fi fi fi fi fi fi fi gamma gamma dist set dist set algorithm douglas peucker algorithm finding splitting vertex time consuming part procedure evaluation distance formula count occurs 
original chain line segments points approximate chain segments know step executed times execution distance evaluations 
upper bound kn 
careful analysis worst case easier assume actual simplification occurs know splitting behaviour total number distance evaluations counted function number input segments best outcome split lie middle chain 
number distance evaluations satisfies recurrence gamma solution gamma log log 
theta log 
worst case split take just segment chain gamma gamma gives worst case performance gamma gamma theta 
qualitative difference significant larger larger problem instances considered see concrete evidence section 
furthermore vast difference best worst case problem parallel applications fast slowest task interactive applications users want predictable response time 
reason inefficiency worst case easy see look vertices find splitting vertex resulting split leaves problem nearly large original 
section show exploit information geometric structure problem find splitting vertex inspecting log vertices 
see maintain structural information performing splits 
allows improve worst case log time 
single user batch system concerned worst case performance concerned expected running time typical data 
mathematically define probability distribution certain data occur compute expected time summing running time times probability possible instance 
way exactly define distribution look data sets simplified 
compare algorithms data sets involve running algorithm data set find fastest solutions known fastest algorithm simply outputs known solution 
define probability distribution allows predict typical running times solving possible problems practically impossible 
consider problems may typical best worst case look number distance calculations random vertex chosen splitting vertex 
give recurrence relation gamma gamma gamma gamma solution theta log 
analysis shows splits occur random vertices average running time factor log greater best 
programmer concerned efficiency squares distance ffl wade computing square roots time consuming 
portions determinant computation depend taken loop 
changes reflected timings algorithm section 
path hull algorithm section give new algorithm method douglas peucker theta log worst case running time 
subsection show splitting vertices chain convex hull 
define path hull data structure give path hull algorithm line simplification momentarily assuming existence procedures build split path hulls find extreme vertices 
subsection outline structure path hulls procedures operate 
analyze asymptotic running time new implementation subsection 
splitting vertices convex hulls tangents convex set definitions 
set convex points segment pq ae line tangent intersects lies entirely side closed set tangents parallel direction illustrated 
tangents touch extreme points lemma convex set line points max distance lie tangents parallel 
proof points equal distance lie lines parallel 
point achieves maximum distance consider line parallel 
point lie opposite side tangent 
convex hull set points smallest convex set containing boundary hull denote ch polygon consisting points segments joining 
lemma vertices ch need considered farthest points 
central task maintain search convex hulls efficiently 
dobkin developed path hull data structure similar hull maintenance problem modify structure slightly 
define path hull chain consist tag vertex vm pair boundaries convex hulls tag vertex ch vm ch 
assume operations path hulls 
build ph build path hull ph choosing middle vertex tag computing convex hulls 
split ph path hull ph chain split chain return path hull subchain containing tag vertex 
path hull subchain rebuilt 
ph find farthest vertex ph line 
algorithm uses operations compute simplification douglas peucker algorithm 
section path hull data structure operations 
implementing path hulls path hull consists arrays storing vertices convex hulls left stores ch vm right stores ch 
array history stack 
subsection outline efficient implementations path hull operations algorithm 
interested readers compare path hulls dobkin 
implementation operation ph 
find farthest vertex separately find farthest left right hull select correct vertex 
concentrate finding farthest vertex convex polygon ch 
ph contains path hull subchain call ph simplifies subchain 
procedure ph 
ph 
distance ffl 
output accept approximation 
tag vertex 
split ph form ph 
ph 
build ph build ph 
ph 
split ph form ph 
ph 
build ph build ph 
ph algorithm path hull algorithm line simplification positive angle angle tangent suppose edges ch listed counter clockwise ccw order oriented left right illustrated 
tangent convex hull touches vertex ch 
rotate tangent counter clockwise pivots vertex encounters outgoing segment ch switches pivot vertex ccw order 
implies vertices tangents parallel separate ch chains edges form positive angles ffi edges form negative angles 
abbreviation call positive negative edges 
find farthest vertex step process find positive negative edge separate ch pieces contain extreme point 
second binary searches locate vertex piece edge angles change sign 
third compute compare distances extreme points determine greater 
perform step choose arbitrary edge ch base edge 
assume positive task find negative edge 
choose edge splits ch equal pieces 
negative done step 
positive look segment drawn dashed endpoint endpoint positive discard hull edges positive 
negative discard portion choose new divides remaining portion equal halves repeat 
perform halving log times finding negative edge searching negative edge second step positive edge negative edge search portion vertex adjacent positive negative edges 
look middle edge positive replace negative replace testing log edges find vertex tangent parallel 
third step easiest compute distances squares compare 
log operations report farthest point ch available array 
build operation modification convex hull algorithm 
algorithm algorithm valid underlying path self intersections usually desired case vision applications 
algorithm computes right convex hull ch incrementally successively adding vertices vm double ended queue implemented right array 
initially queue contains bottom top vm vm vm insert queue storing hull ch gamma right hull edge top queue pop top vertex queue 
right hull edge bottom queue pop bottom vertex 
vertex popped push top bottom queue 
algorithm computes desired convex hull intermediate hulls 
modify algorithm store sequence pushes pops vertices involved right history stack 
construct left convex hull ch vm adding vertices vm record pushes pops left history stack 
completes build operation 
split ph operation quite easy 
play back history hull contains splitting vertex undo operations reach operation pushes analyzing running time section analyze running time path hull algorithm algorithm 
consider total cost calls calls split build 
lemma total cost calls log proof noticed section calls 
call performs log tests halving operations total cost calls log 
relate cost split cost build lemma cost calls split cost calls build 
proof calls split operations pop history stack 
operation pop history stack simply undoing effect build 
account done build operations credit scheme call number credits pay build body recursive calls 
give log credits call show calls credits pay recursive calls 
lemma total cost build operations log 
proof number internal vertices left right tag vertex call 
internal means neglect endpoints chain edge split 
show call log rg credits pay build operation give correct number credits recursive calls pay build operations 
credits spent follows 
index splitting vertex algorithm credit function symmetric respect left right assume left tag 
line algorithm call gamma log gamma rg gamma log rg credits pay calls build 
line spend credits call build constructs path hull bs internal vertices side tag 
line give log bs log gamma log rg gamma credits recursive call 
summing credits spent build find total expenditure log rg credits 
give call total log credits sufficient credits pay calls build 
lemma shown done line algorithm bounded log 
completes analysis 
comparing running times section compare machine timings implementations line simplification algorithms sun 
basic douglas peucker implementation described section 
second incorporates suggestions section speeding search splitting vertex squared distances compared loop invariants moved outside loop 
third uses path hulls find splitting vertex 
analysis done sections run algorithms inputs reveal best worst cases 
case example douglas peucker points evenly spaced circle 
readily seen best case standard implementation splits occur chains worst case path hull algorithm convex hull subchain includes points 
path hull implementation records structural information considered standard implementation surprising slower 
time secs algorithm pts pts pts worst case standard implementation zig zag spiral split chops single segment 
improvement path hull implementation dramatic 
time secs algorithm pts pts pts mentioned section difficult test algorithms typical data 
test set monotone chain random coordinates 
input algorithms comparable performances 
time secs algorithm pts pts pts mathematical analysis line simplification algorithm reported douglas peucker shows worst case running time quadratic 
theta time required simplify polygonal line input points 
investigation geometry simplification method reveals maintain structure guarantee running time log asymptotically matches best case standard algorithm 
implementation shows new algorithm factor slower best case standard algorithm due extra structural information maintains far faster factor points worst case standard algorithm 
fact variance running time new algorithm small may suitable interactive parallel applications 
buttenfield 
treatment cartographic line 


hierarchical methods line simplification 
cartography geographic information systems 
dobkin guibas hershberger snoeyink 
efficient algorithm finding csg representation simple polygon 
computer graphics 
proceedings siggraph 
douglas peucker 
algorithms reduction number points required represent line caricature 
canadian 
guibas hershberger mitchell snoeyink 
minimum link approximation polygons subdivisions 
hsu lee editors isa algorithms number lncs pages 
springer verlag 
jones abraham 
line generalisation global cartographic database 

knuth 
mathematical analysis algorithms 
proceedings ifip congress pages 
north holland amsterdam 
marino 
identification characteristic points naturally occurring lines empirical study 


mcmaster 
statistical analysis mathematical measures linear simplification 
amer 

mcmaster 
automated line generalization 


line construction convex hull simple polyline 
info 
proc 


iterative procedure polygonal approximation plane curves 
comp 
vis 
graph 
image proc 
rote 
quadratic convergence sandwich algorithm approximating convex functions convex figures plane 
proc 
second 
conf 
comp 
geom pages ottawa ontario 
white 
assessment line generalization algorithms characteristic points 
amer 

wade 
douglas peucker line simplification algorithm 
bulletin society university 
appendix code define epsilon error tolerance define error tolerance squared define define define define operation names saved history stack define define define xx define yy define ww typedef double point typedef double typedef struct half path hull elt double ended queue storing convex hull top bot ends 
history stack points op operations hp stack pointer 
int top bot hp op point elt define min define max define sgn define cch cartesian cross product ww xx yy yy xx xx yy yy yy xx xx define dotprod ch cartesian dot product ww xx xx yy yy define determine point left line xx xx yy yy xx xx yy yy define return sign projection gamma normal line sgn xx elt xx elt xx yy elt yy elt yy define push element path hull elt top elt bot hp op hp define pop top hp elt top op hp define pop bottom hp elt bot op hp define initialize path hull history elt elt top elt bot hp op point vertices input chain int number vertices left right path hull pointers left hull right hull tag vertex 
point void line dist return extreme vertex hull respect line 
return distance dist register line point register double dist int sbrk mid lo brk hi double top bot points hull just look 
lo bot hi top hi lo line sign base edge brk lo hi binary search edge opposite sign sbrk brk brk line lo brk line lo brk hi brk sbrk brk sign changes base edge brk 
binary search extreme point 
lo mid lo mid mid line lo mid mid brk sign changes brk base 
binary search 
hi mid hi mid mid line hi mid mid compute distances extreme points dotprod ch elt lo line dotprod ch elt line dist 
elt lo elt points hull search brute force dist mid bot mid top mid dotprod ch elt mid line dist dist elt mid void add hull implements convex hull algorithm 
register point register int elt top elt top elt bot elt bot new point outside hull pop points convexity ensured elt top elt top elt bot elt bot push new point top bottom deque void build build path hull chain vertex vertex point register point middle vertex tag left build left hull left right build right hull right void split split hull point leaving hull tag register point register point register int hp loop reach push op op hp hp hp switch undo operation case top bot break case elt top break case elt bot break point recursively simplify chain vertex returns point simplified chain 
point point extrema left right hulls distances double rdist line double point tmp cch line compute line line xx line xx line yy line yy vertices simplification complete 
return left line right line rdist rdist see split occurs right left rdist rdist return split needed tolerance build split occurs tag rebuild split right 
split right simplify split 
build rebuild path hull simplify split 
return return split needed tolerance split left split left 
simplify split save output 
tmp build rebuild path hull simplify split 
return tmp void main read points build path hull call simplify 
get points allocate memory init build build initial path hull dp simplify 
