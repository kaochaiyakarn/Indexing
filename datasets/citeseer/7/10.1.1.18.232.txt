linkoping electronic articles computer information science vol 
nr linkoping university electronic press linkoping sweden www ep liu se ea cis algorithms graph partitioning survey department computer information science linkoping university linkoping sweden published september linkoping university electronic press linkoping sweden linkoping electronic articles computer information science issn series editor erik sandewall fl typeset author formatted style recommended citation author 
title 
linkoping electronic articles computer information science vol 
nr 
www ep liu se ea cis 
september 
url contain link author home page 
publishers keep article line internet possible replacement network period years date publication barring exceptional circumstances described separately 
line availability article implies permanent permission read article line print single copies personal 
permission revoked subsequent transfers copyright 
uses article including making copies classroom conditional consent copyright owner 
publication article date stated included production limited number copies archived swedish university libraries written works published sweden 
publisher taken technical administrative measures assure line version article permanently accessible url stated unchanged permanently equal archived printed copies expiration publication period 
additional information linkoping university electronic press procedures publication assurance document integrity please refer www home page www ep liu se conventional mail address stated 
graph partitioning problem follows 
graph set weighted nodes set weighted edges positive integer find subsets 

sums node weights respectively 
cut size sum weights edges crossing subsets minimized 
problem interest areas vlsi placement routing efficient parallel implementations finite element methods 
survey summarize state art sequential parallel graph partitioning algorithms 
keywords graph partitioning sequential algorithms parallel algorithms 
funded center industrial information technology linkoping university 
graph partitioning problem follows 
graph set weighted nodes set weighted edges positive integer find subsets 

sums node weights respectively 
cut size sum weights edges crossing subsets minimized 
set fn pg called way partition satisfies condition 
part partition 
bisection way partition 
partition satisfies condition balanced partition 
see 
example graph partitioned parts 
graph partitioning problem interest areas vlsi placement routing ak efficient parallel implementations finite element methods 
application main motivation survey illustrate need graph partitioning example area 
suppose want solve heat conduction problem dimensional domain 
solve problem numerically original problem replaced discrete approximation 
finite element methods partitioning domain finite elements simple convex regions triangles tetrahedra threedimensional domains 
boundary finite element composed nodes edges faces 
domain partition represented graph 
finite element graph node node partition edge edge partition 
temperature nodes partition solving system linear equations form ku vectors element node matrix element nonzero nodes share edge domain partition 
iterative method solves system repeatedly computing vector kx 
note compute value node need know value nodes neighbors node finite element graph 
parallelize matrix vector multiplication assign node processor 
value node nonzero elements th row stored specific processor 
mapping nodes processors done processors computational load number arithmetic operations 
see number arithmetic operations compute value node proportional degree node balancing computational load try reduce communication time 
compute value node processor needs values neighbors node assigned neighbor processor corresponding value transferred processor interconnection network 
time takes depends factors 
cut size number edges finite element graph nodes mapped different processors clearly influence communication time 
communication time depends factors dilation maximum number edges processor interconnection network separates adjacent nodes finite element graph congestion maximum number values routed edge interconnection network 
example shows graph partitioning problem approximation problem need solve parallelize finite element methods efficiently 
reasons researchers developed algorithms graph partitioning 
observed problem np hard gjs 
polynomial time algorithm finds optimal partition 
algorithms guaranteed find optimal solution algorithm graphs nodes slow larger graphs 
practical algorithms heuristics differ respect cost time memory space required run algorithm partition quality cut size 
example graph change computations 
weights assigned nodes edges change consequently need partition graph fixed value 
call static case 
applications graph changes incrementally phase computation 
example adaptive finite element methods nodes edges may added removed computations 
called dynamic case graph partitioning needs done repeatedly 
doing algorithms static case possible probably better algorithms consider existing partition 
situation interested algorithms partition graph compute partition graph identical call algorithms repartitioning algorithms 
researchers begun develop parallel algorithms graph partitioning 
reasons 
sequential algorithms give high quality partitions quite slow 
parallelization algorithm possible speed computation 
graph large generated parallel algorithm sequential partitioning algorithm inefficient impossible 
reason need dynamic graph partitioning 
mentioned involves repeated graph partitioning 
sequentially inefficient require parallel algorithm 
goal survey summarize state art graph partitioning algorithms 
particular interested parallel algorithms 
organization report follows 
section describe sequential algorithms 
section consider parallel partitioning repartitioning algorithms 
section offers 
sequential algorithms graph partitioning researchers developed sequential algorithms graph partitioning section give brief descriptions algorithms 
divide algorithms different categories depending kind input require 
section ends summary experimental comparisons algorithms 
give available graph partitioning software packages 
local improvement methods local improvement algorithm takes input partition usually bisection graph tries decrease cut size local search method 
solve partitioning problem algorithm combined method methods described section creates initial partition 
possibility generate random initial partitions apply algorithm partition best cut size 
local improvement method takes bisection input apply recursively way partitioning obtained 
example bisected graph 
nodes shaded area int ext int ext 
cut size 
node edge weights assumed equal 
kernighan lin kl proposed earliest methods graph partitioning local improvement methods variations method 
initial bisection kernighan lin kl method tries find sequence node pair exchanges leads improvement cut size 
fn bisection graph 
node weights assumed equal 
define int ext index part node belongs weight edge 
total cut size ext 
gain moving node part currently belongs part ext gamma int decrease cut size moving denote gain exchanging gamma 
see 
iteration kl algorithm follows 
input iteration balanced bisection fn unmark nodes 
repeat procedure times min jn jn 
find unmarked pair maximum necessarily positive 
mark update values remaining unmarked nodes exchanged 
values neighbors need updated 
ordered list node pairs find index maximum 
sum positive exchange node pairs iteration kl algorithm 
terminate algorithm 
single iteration kl method requires jn time 
dutt shown improve jej jn deg max time deg max maximum node degree 
fiduccia mattheyses fm fm kl inspired algorithm iteration done jej time 
kl method fm method performs iterations node moves best bisection observed iteration corresponding gain positive input iteration 
selecting pairs nodes fm method selects single nodes 
step iteration unmarked node maximum value alternatingly selected fm method extended deal arbitrary number parts weighted nodes hl 
local improvement method monien dmp 
method notion helpful sets bisection fn set ae ae helpful move reduce cut size suppose ae helpful set ae balancing set sj jsj gammak helpful 
moving moving cut size reduced 
iteration algorithm follows 
input consists balanced bisection fn positive integer search helpful set set exists look set highest helpfulness 
set positive helpfulness set 
search balancing set set move set 
set bl 
start new iteration 
details helpful balancing sets see dmp 
simulated annealing sa kgv general purpose local search method statistical mechanics 
kl fm methods sa method greedy 
easily trapped local minima 
sa solve optimization problem select initial solution initial temperature 
step performed times 
called temperature length 
random neighbor current solution selected 
ffi gamma quality solution ffi new current solution 
ffi replaces probability gammaffi iterations certain stopping criterion satisfied terminate algorithm 
set rt cooling ratio round steps performed 
johnson jams adapted sa graph compared experimentally kl algorithm 
sa performs better kl types graphs conclude sa best algorithm graphs sparse local structure 
supported results obtained williams wil 
tabu search glo glo general combinatorial optimization technique 
rolland rpg successfully method graph 
starting randomly selected balanced bisection iteratively search better bisections 
iteration node selected moved part currently belongs part 
move node kept called tabu list certain number iterations 
move results balanced bisection smaller cut size previously encountered balanced bisection bisection recorded currently best bisection 
better bisection fixed number consecutive moves algorithm increases imbalance factor factor limits cardinality difference parts bisection 
initially factor set zero reset zero certain intervals 
selection node move depends factors 
moves result larger cardinality difference allowed current imbalance factor forbidden 
moves involving nodes tabu list allowed lead improvement currently best bisection 
allowed moves algorithm move leads greatest reduction cut size 
rolland experimentally compare algorithm kl sa algorithms find algorithm superior respect solution quality running time 
genetic algorithm ga gol starts initial set solutions chromosomes called population 
population evolves generations stopping condition satisfied 
new generation obtained selecting pairs chromosomes current population 
selection probabilistic selection scheme 
crossover operation pair combined produce offspring 
mutation operator randomly modify offspring 
replacement scheme decide offspring replace members current population 
researchers developed gas graph partitioning sr las bm 
briefly describe bisection algorithm bui moon bm 
reorder nodes new order order nodes visited breadth search starting random node 
initial population consisting balanced bisections generated 
form new generation select pair bisections 
bisection selected probability depends cut size smaller cut size greater chance selected 
pair parents selected offspring balanced bisection created 
refer bm description done 
try decrease cut size offspring applying variation kl algorithm 
solution current population selected replaced offspring 
refer bm description done 
bui moon experimentally compare algorithm kl sa algorithms 
conclude algorithm produces partitions comparable better quality algorithms 
global methods global method takes input graph integer generates way partition 
methods recursive bisect recursive methods graph 
bisection step applied recursively subsets nodes 
global methods combination local improvement method 
geometric methods node graph associated geometric location 
algorithms information call geometric partitioning algorithms 
geometric algorithms completely ignore edges graph methods consider edges reduce cut size 
node edge weights usually assumed equal 
simplest example geometric algorithm recursive coordinate bisection rcb bb 
method closely related multidimensional binary tree tree data structure proposed bentley ben 
obtain bisection selecting coordinate axis 
usually coordinate axis node coordinates largest spread values selected 
find plane orthogonal selected axis bisects nodes graph equal sized subsets 
involves finding median set coordinate values 
inertial method fl elaboration rcb selecting coordinate axis select axis minimum angular momentum set nodes 
dimensional space axis equal eigenvector associated smallest eigenvalue matrix xx xy xz yx yy yz zx zy zz xx gamma gamma yy gamma gamma zz gamma gamma xy yx gamma gamma gamma yz zy gamma gamma gamma xz zx gamma gamma gamma jn denotes coordinates node continue exactly rcb method find plane orthogonal axis minimum angular momentum bisects nodes graph equal sized subsets 
inertial method successfully combined kl method 
recursive step bisection computed inertial method improved kl method lh 
miller teng thurston vavasis designed algorithm bisects dimensional graph graph nodes embedded dimensional space finding suitable dimensional sphere dividing nodes interior exterior sphere 
sphere randomized algorithm involves projection nodes surface dimensional sphere 
specifically algorithm finding bisecting sphere follows 
project nodes dimensional unit sphere 
node projected point line north pole sphere intersects sphere 

find center point projected nodes 
center point set points dimensional space point hyperplane divides fairly evenly ratio better 
set center point linear programming 

conformally map points sphere 
rotate origin center point point axis 
second points projecting rotated points back dimensional space scaling projected points multiplying coordinates gamma projecting scaled points dimensional unit sphere 
center point conformally mapped points coincides center dimensional unit sphere 

choose random hyperplane center dimensional unit sphere 

hyperplane previous step intersects dimensional unit sphere great circle dimensional sphere 
transform sphere reversing conformal mapping projection 
obtained sphere bisect nodes 
practical implementation algorithm gilbert miller teng gmt 
implementation includes heuristic computing approximate center points method improving balance bisection 
apply algorithm nodes graph randomly selected subset nodes 
obtain partition randomly selected hyperplanes tried 
hyperplane compute resulting cut size hyperplane gives lowest cut size 
nicol bcn describe sequential parallel algorithms parametric binary dissection generalization recursive coordinate bisection consider cut size 
specifically suppose want bisect graph cut plane orthogonal axis 
position plane chosen max delta delta minimized 
number nodes subset lying left right plane number edges exactly node left right subset parameter 
coordinate free methods applications graphs embedded space geometric algorithms 
graph embedded embeddable space geometric methods tend give relatively high cut sizes 
section describe algorithms consider combinatorial structure graph 
recursive graph bisection rgb method sim begins finding pseudo peripheral node graph pair nodes approximately greatest graph distance graph 
graph distance nodes number edges shortest path nodes 
breadth search starting selected node graph distance node node determined 
nodes sorted respect distances sorted set divided equal sized sets 
called greedy method uses breadth search starting pseudo peripheral node find parts far cjl 
recursive spectral bisection rsb method psl sim uses eigenvector corresponding second lowest eigenvalue laplacian matrix graph 
define laplacian matrix graph gammaa diagonal matrix expressing node degrees adjacency matrix 
eigenvector called fiedler vector contains important information graph difference coordinates fiedler vector provides information distance corresponding nodes 
rsb method bisects graph sorting nodes respect fiedler coordinates dividing sorted set halves 
fiedler vector computed modified lanczos algorithm lan 
rsb generalized consider node edge weights hl 
rsb method combined kl method results lh 
multilevel recursive spectral bisection multilevel rsb method proposed barnard simon bs uses multilevel approach speed computation fiedler vector 
experiments show multilevel rsb order magnitude faster rsb produces partitions quality 
algorithm consists phases coarsening partitioning uncoarsening coarsening phase sequence graphs constructed original graph 
specifically graph approximation obtained computing maximal independent subset independent subset subset nodes subset share edge 
independent subset maximal node added set 
set equal constructed follows 
node associated domain initially contains 
edges unmarked 
long unmarked edge follows 
belong domain mark add domain 
node say belongs domain mark add domain 
different domains say mark add edge belongs domain process edge stage 
point obtain graph small lanczos algorithm compute corresponding fiedler vector denoted small amount time 
obtain approximation fiedler vector initial graph reverse process uncoarsening phase 
vector obtain vector interpolation improvement interpolation step follows 
set equal average value components corresponding neighbors 
denote component vector corresponding node 
vector improved 
done rayleigh quotient iteration see bs details 
multilevel kl algorithm hl bj kk kk gup example multilevel approach obtain fast algorithm 
coarsening phase algorithm creates sequence increasingly coarser approximations initial graph 
sufficiently coarse graph enter partitioning phase coarsest graph bisected kk partitioned parts hl kk 
uncoarsening phase partition propagated back hierarchy graphs 
kl type algorithm invoked periodically improve partition 
give detailed description phase descriptions karypis kumar kk kk 
analysis multilevel kl methods see kk 
coarsening phase approximation graph obtained computing maximal matching recall matching subset edges subset share node 
matching maximal edges added matching 
maximal matching obtained collapsing matched nodes 
nodes replaced node weight sum weights edges incident union edges incident minus edge 
unmatched nodes copied see 
maximal matching ways 
experiments indicate called heavy edge matching gives best results see kk kk 
works follows 
nodes visited random order 
visited node unmatched match unmatched neighbor edge unmatched neighbor heavier edge 
partitioning phase coarsest graph example graph coarsening 
node edge weights upper graph assumed equal 
numbers close nodes edges lower graph node edge weights 
bisected kk partitioned directly parts hl kk 
case multilevel bisection algorithm needs applied recursively obtain way partition 
case graph needs coarsened 
kk methods bisecting coarsest graph tested best results obtained variant greedy algorithm see 
specifically starting randomly selected node grow part adding fringe nodes nodes currently neighbors part 
fringe node addition part result largest decrease cut size added 
algorithm executed repeatedly bisection smallest cut size 
uncoarsening phase partition successively transformed partition original graph specifically node index part partition graph belongs 
obtained follows 
initial partition constructed projection corresponds matched pair nodes 
initial partition improved variant kl method 
describe called greedy refinement method kk :10.1.1.133.6013
part index define fp ext int ext gamma int part index define corresponding part weight weight move node part index satisfies balance condition cw gamma constant larger equal 
just fm method greedy refinement algorithm consists iterations 
iteration nodes visited random order 
node moved part index conditions satisfied 
positive maximum moves satisfy balance condition 
gamma 
node moved values part weights influenced move updated 
observe fm method greedy refinement method moves nodes nonnegative values 
experiments show greedy refinement method converges iterations 
evaluation algorithms partitioning methods described evaluated experimentally respect partition quality execution time 
section try summarize results 
purely geometric methods rcb inertial method fast produce partitions relatively high cut sizes compared rsb 
geometric method implemented gilbert gmt produces partitions comparable produced rsb random hyperplanes tried bisection step 
combinatorial algorithms rsb recursive kl random initial partitions tried give partitions relatively slow 
multilevel approach multilevel rsb methods results faster algorithms degradation partition quality 
karypis kumar kk report multilevel way algorithm produces better partitions multilevel rsb orders magnitudes faster :10.1.1.133.6013
compute way partition node finite element mesh seconds sgi challenge 
potential disadvantage multilevel approach memory intensive 
combining recursive global method local improvement method leads significantly reduced cut sizes inertial rsb methods give better cut sizes combined kl method 
multilevel kl method gives cut sizes rsb kl time 
multilevel kl rsb kl give better cut sizes inertial kl slower inertial kl lh 
methods helpful sets competitive multilevel kl method dmp 
available software packages section list available software packages graph partitioning ffl chaco hl 
developed hendrickson leland sandia national labs 
contains implementations inertial spectral kernighan lin multilevel kl methods 
ffl metis 
karypis kumar kk kk dept computer science univ minnesota 
developed parallel algorithms described section kk kk 
ffl mesh partitioning toolbox 
developed gilbert includes matlab implementation algorithm gmt 
ffl 
developed walshaw univ greenwich 
ffl top sf 
developed simon includes implementations greedy rgb inertial rsb algorithms 
parallel algorithms graph partitioning algorithms section parallel formulations methods previous section 
methods particular geometric methods relatively easy parallelize 
hand kl sa methods appear inherently sequential shown complete sw 
multiple runs kl method course done parallel different processors 
section parallel approximations kl method 
rsb multilevel methods difficult parallelize geometric methods 
methods involve graph computations finding maximal matchings independent sets connected components nontrivial parallel case 
local improvement methods algorithms described subsection take input partition graph try improve 
specifically methods take input balanced bisection try improve cut size 
compute way partition algorithms need applied recursively 
assume exceed number processors parallel computer executing algorithm 
remaining algorithms repartitioning algorithms take input way partition may need improved respect balance cut size 
mentioned repartitioning algorithms required example adaptive finite elements methods graph may refined coarsened parallel computation 
situation part partition corresponds nodes stored processor computational load processor equal weight corresponding part 
efficient repartitioning algorithm improve balance cut size partition try achieve minimizing node movements processors 
gilbert gz proposed earliest parallel algorithms graph bisection kl algorithm see 
algorithm consists sequence iterations input iteration balanced bisection fn bisection corresponds balanced bisection fp set processors node adjacency list stored processor belonging step iteration select processor subset processors leader subset 
node gain computed reported corresponding leader 
done processor storing adjacency list node leader nodes part bisection 
procedure repeated min jn jn times 
leader selects unmarked nodes part bisection node largest value marks node 
observe selection different kl algorithm edge selected nodes ignored 
leaders request adjacency lists selected nodes update values unmarked nodes adjacent selected nodes 
pairs nodes selected leaders decide example quotient graph corresponding partition numbers denote part weights tree formed requests loads 
node pairs exchange procedure kl algorithm 
nodes adjacency lists exchanged subsets processors new iteration begun 
savage wloka sw propose mob heuristic graph bisection 
method applied graph embedding problem sw 
algorithm consists iterations 
input iteration bisection fn positive integer size subsets computed swapped 
swap resulted increased cut size reduced predetermined schedule iteration begins 
selection mob size done follows 
socalled 
node denote decrease cut size caused moving part bisection 
consists nodes values largest value nodes 
mob nodes selected randomized procedure 
guaranteed exactly nodes 
mob heuristic implemented cm implementation virtual processors 
specifically implementation uses linear array edge appears twice 
edges sorted left node edge stored address twin 
virtual processor associated edge 
processor associated group edges left node represents node 
data structure easy compute cut sizes gains select 
shephard flaherty give repartitioning algorithm iterative local load exchange processors 
describe algorithm introduce quotient graphs 
partition fn pg graph quotient graph graph node represents part edge nodes see 
algorithm correspondence nodes processors 
nodes stored processor form part partition 
adjacent nodes quotient graph need correspond processors adjacent interconnection network parallel computer 
apply procedure repeatedly balanced partition obtained 

processor informs neighbors quotient graph computational load 

processor neighbor heavily loaded requests load heavily loaded neighbor 
requests form forest trees 

processor computes load send receive 
decision nodes send node weight gain cut size 

forest edge colored colors possible edges colored edges incident node quotient graph color 

color nodes transferred processor pairs connected edge color 
algorithm implemented maspar mp computer 
chung yeh liu cyl give repartitioning algorithm torus mesh connected parallel computer wrap connections 
assume torus number rows columns 
algorithm consists steps 
step computational load equally balanced row 
second step computational load equally balanced column processors 
balancing row done follows 
processor numbered column balances right neighbor left neighbor 
repeated row balanced 
decision nodes transfer neighboring processors aim reduce communication processors 
columns balanced similarly 
algorithm implemented evaluated processor ncube 
performance evaluated applying sequence refinements finite element mesh 
results show repartitioning algorithm faster parallel version rcb partition scratch refinement step 
ou ranka propose repartitioning algorithm linear programming 
suppose graph refined adding deleting nodes edges 
new partition computed follows 
new vertices assigned part 
node determined neighbor part closest 
current partition balanced amount node movements parts minimized 
specifically ij denote number nodes part part closest neighboring part 
compute ij number nodes need moved part part achieve balance solve linear programming problem minimize jp ij subject ij ij ip ji gamma ij gamma denotes current weight part 
simplicity node edge weights assumed unit value 
step algorithm ou ranka aimed reducing cut size maintaining balance 
done solving linear programming problem 
sequential version algorithm compared rsb algorithm 
produced partitions quality rsb algorithm orders magnitude faster 
parallel implementation processor cm times faster sequential algorithm 
walshaw cross everett describe iterative algorithm graph repartitioning 
algorithm decide weight transferred adjacent parts achieve balance 
enter iterative node migration phase nodes exchanged parts 
step algorithm done algorithm hu blake hb decide weight transferred adjacent parts solve linear equation laplacian matrix see quotient graph gammaw current weight nodes part diffusion solution describes weight transferred parts achieve balance 
specifically parts adjacent weight equal gamma moved part part experiments carried sun sparc ultra show orders magnitude faster partitioning scratch multilevel rsb 
karypis kumar sequential parallel repartitioning algorithms multilevel approach 
briefly algorithms consist phases graph coarsening multilevel diffusion multilevel improvement coarsening phase exactly kk see subgraphs partition coarsened phase essentially parallel :10.1.1.133.6013
subgraph corresponding subset ae graph 
goal multilevel diffusion phase obtain balanced partition 
done moving boundary nodes nodes adjacent node part overloaded parts 
balance obtained boundary nodes fine graph level process repeated 
manner nodes moved parts undirected directed case balance obtained local information 
second case algorithm hu blake see compute weight needs moved neighboring parts 
goal multilevel improvement phase reduce cut size 
specifically phase similar uncoarsening phase kk see 
implemented repartitioning algorithms cray mpi library communication 
algorithms evaluated graphs arising finite element computations 
experimental results show compared partitioning scratch algorithm kk repartitioning algorithms take time produce partitions quality 
graph nodes seconds processor cray 
global methods parallel global graph partitioning algorithms primarily useful need partition graphs large conveniently partitioned sequential computer 
principle dynamic graph partitioning results previous section indicate dynamic case better handled repartitioning algorithms 
section denotes example ibp method shuffled row major indexing 
number parts partition number processors parallel computer executing algorithms 
geometric methods parallel geometric methods section operations sorting reduction finding medians 
principle easy implement 
particular recursive methods may involve data movement efficient way carry movements may depend characteristics parallel computer 
ou ranka fox orf propose index partitioning ibp 
method follows 
bounding box set nodes computed 
box divided identical cells 
cells indexed indexes cells geometrically close numerically close generalization shuffled row major indexing 
see 
nodes sorted respect indexes cells contained 
sorted list partitioned equal sized lists 
ou describe graph geometric positions nodes change nodes added deleted 
algorithm analyzed coarse grained parallel machine experimentally evaluated processor cm 
experiments show ibp method orders magnitude faster parallel version rsb method 
cut size worse 
jones jp propose unbalanced recursive bisection 
rcb see cut planes perpendicular coordinate axis 
require cut plane subdivide nodes graph equal sized subsets 
sufficient subdivides nodes subsets sizes integer multiples jn denote width set points coordinate direction define aspect ratio set points max min bisect graph jones find cut plane yields smallest maximum aspect ratio subsets nodes lying side plane 
subdivide resulting subsets proportion sizes 
number nodes subset integer subdivided eventually equal sized subsets obtained 
nak presents algorithm similar bisect graph tries find plane cuts edges possible 
number edges cut plane calculated exactly approximated node coordinates 
experiments show algorithm usually computes partitions higher quality standard rcb 
hendrickson dph give algorithms parallel versions inertial method see local improvement heuristic fiduccia mattheyses see 
inertial method relatively straightforward parallelize 
initially processors collaborate compute bisection 
bisecting cut plane entire graph computed 
set processors bisected nodes lying side cut plane moved subset processors 
continues recursively subsets nodes processors 
see ding df 
fm kl methods closely related fm method inherently sequential 
briefly describe parallel variant fm method processors form pairs nodes exchanged paired processors 
algorithm called inertial interleaved fm parallel variant fm applied bisection performed parallel inertial method 
second algorithm inertial colored fm graph completely partitioned parallel inertial method 
pairs processors subsets nodes share edges apply fm improve partition 
specifically quotient graph edge colored see pairwise fm applied simultaneously edges color 
experiments suggest superior concerning partitioning time partition quality 
reduces cut size compared pure parallel inertial method order magnitude slower particular parts 
ranka give detailed description analysis parallel algorithms constructing multidimensional binary search trees called trees 
particular study different methods find median coordinates 
suggested point coordinates dimension better median finding algorithm bisection step 
results show randomized bucket median finding algorithms outperform 
propose method reduce data movements sorting median finding 
due close relationship trees rcb method see results highly relevant parallelization rcb related methods 
coordinate free methods sequential coordinate free methods algorithms breadthfirst search finding maximal sets matchings graph coarsening nontrivial parallelize 
local improvement steps multilevel methods difficult efficiently parallel 
methods section various approaches problems 
parallel implementation rsb method see connection machine cm described johan mathur johnson hughes 
barnard bar gives parallel implementation method see cray 
coarsening phase pram algorithm luby lub compute maximal independent sets 
karypis kumar kk give parallel version bisection method kk see 
recall bisect graph compute sequence successively smaller graphs obtained sufficiently small graph coarsening phase 
graph bisected resulting bisection successively projected back bisection uncoarsening phase 
uncoarsening phase partition periodically improved version kl method 
describe parallel version coarsening phase convenient regard processors arranged dimensional array 
assume integer power 
graph obtained graph follows 
assumed divided equal sized subsets processor contains graph see 
construct processor computes maximal matching edges union local matchings regarded matching processor sends example graph decomposition kk 
graphs top bottom numbers nodes show subset belong 
processor row column 
obtained modifying matching 
coarsening phase small values number nodes successive coarser graphs substantially decrease current graph copied lower quadrant processor array 
current value halved 
way get nodes edges active processor find larger matchings 
procedure continues current graph copied single processor coarsening done sequentially 
sufficiently small graph obtained bisected sequentially parallel 
uncoarsening phase simply reversal coarsening phase local improvement method applied step improve current partition 
describe parallel implementation improvement step 
coarsening phase assume nodes divided subsets processor contains graph assume node processor knows gain cut size obtained moving part currently belongs 
gain node computed adding th processor column 
assume stored processor parallel local improvement method consists iterations 
iteration diagonal processor selects parts set ae consisting nodes positive values 
nodes moved part 
mean moved processor 
diagonal processor broadcasts selected set row column gain values updated 
improvements cut size impossible maximum number iterations reached iteration started 
part nodes moved alternates iterations 
necessary local improvement phase ended explicit balancing iteration 
algorithm implemented processor cray library communication 
experimental evaluation shows compared sequential algorithm kk partition quality parallel algorithm speedup varies depending properties graph 
graphs tested took seconds compute way partition processors 
karypis kumar kk kk give parallel implementations multilevel way partitioning algorithm kk :10.1.1.133.6013
description algorithm kk 
consider matching graph computed 
assume nodes colored colors node color different colors neighbors 
coloring described 
assume evenly distributed processors node adjacency list stored exactly processor 
matching algorithm consists iterations 
th iteration processor visits local unmatched nodes color node unmatched neighbor selected heavy edge heuristic 
local node matched 
processor creates request match 
local unmatched nodes color visited processor sends match requests appropriate processors 
matching request sent processor adjacency list node processors receiving matching requests process follows 
single matching request received node request accepted immediately heavy edge heuristic reject requests 
accept reject decisions sent requesting processors 
point decided processors collapsed nodes nodes graph stored 
matching computed processor knows nodes associated adjacency lists send receive processors 
coarsening phase ends graph nodes obtained 
partitioning coarsest graph done parallel follows 
copy coarsest graph created processor 
recursive bisection method 
processor follows single root leaf path recursive bisection tree 
phase nodes stored processor correspond part way partition 
usual uncoarsening phase reversal coarsening phase local improvement phase applied step 
describe initial partition graph improved parallel version greedy refinement method see 
assume nodes adjacency lists randomly distributed processors nodes colored colors 
recall single iteration sequential greedy refinement node visited node movements satisfy certain conditions cut size reduction weight balance carried immediately 
node moved values part weights influenced move updated 
parallel formulation greedy refinement method iteration divided phases th phase nodes color considered movement 
nodes satisfying conditions moved group 
values part weights influenced moves updated phase color considered 
karypis kumar kk give parallel algorithm graph coloring 
algorithm uses simplified version luby parallel algorithm finding maximal independent sets lub 
coloring algorithm consists iterations 
input iteration consists subgraph initial graph 
subgraph independent set nodes selected follows 
random number associated node number node smaller numbers neighbors selected 
selected nodes assigned color 
color iteration 
input iteration obtained removing selected nodes graph 
graph partitioning algorithm implemented processor cray library communication 
experimental evaluation shows compared sequential algorithm kk partition quality parallel algorithm speedup varies depending properties graph :10.1.1.133.6013
graphs tested took second compute way partition processors 
kk karypis kumar propose parallel multilevel way partitioning algorithm specifically adapted message passing libraries architectures high message startup 
observe algorithm kk slow implemented mpi library 
due high message startup time 
remedy introduce new algorithms maximal matching local improvement require fewer communication steps 
new matching algorithm consists iterations processor tries match unmatched nodes heavy edge heuristic 
specifically suppose th iteration processor wants match local node node local processor matching granted right away 
processor issues matching request processor storing 
odd 
denotes unique index associated processor processes requests rejects requests case conflicts 
karypis kumar report satisfactory matchings iterations 
new local improvement method greedy refinement method see 
iteration divided phases 
phase nodes moved lower parts second phase nodes moved opposite direction 
researchers developed sequential algorithms static graph partitioning relatively long time 
multilevel kl method best general purpose method developed far 
methods produce significantly better partitions cost 
multilevel rsb method may produce partitions quality appear slower multilevel kl 
possible sa methods produce partitions higher quality multilevel kl sa methods slow 
purely geometric methods may faster multilevel kl methods general coordinate free generate lower quality partitions 
coordinates available inertial kl algorithm may fast give reasonably cut sizes 
karypis kumar kk tested multilevel way algorithm graphs largest nodes edges :10.1.1.133.6013
graphs took seconds compute way partition 
need research sequential graph partitioning algorithms 
partition larger graphs may run memory find algorithms spend time external memory accesses 
cases alternative partition graph parallel 
second problem may solved algorithms designed external memory accesses possible 
increased interest sequential algorithms extremely large data sets see cgg ks 
partitions produced multilevel kl methods known close optimal graphs little need develop approaches 
usually hard know far away optimal generated partitions 
analysis evaluations partition quality obtained methods interesting 
parallel algorithms static graph partitioning essentially known sequential algorithms 
parallel multilevel kl algorithms kk kk kk perform coarsening partitioning uncoarsening slightly differently sequential counterparts produce partitions quality 
parallel multilevel kl algorithms faster parallel multilevel rsb see kk far know parallel multilevel kl compared parallel versions geometric methods inertial inertial kl 
possible methods require time space multilevel kl methods producing partitions acceptable cut sizes 
parallel multilevel kl methods algorithms solving graph problems finding maximal matchings inde pendent sets graph contraction problems independent interest research practical parallel algorithms problems valuable 
graph partitioning problem approximation problem need solve parallelize specific applications efficiently 
point cut size may important measure partition quality 
multilevel kl algorithm may suitable partitioner applications 
propose evaluation partitioning algorithms focus reductions parallel application running time cut sizes 
simplify evaluations researchers select set benchmark applications 
situation pronounced dynamic graph partitioning 
example dynamic finite element methods possible strategies ranging doing doing local balancing doing local balancing cut size improvement partitioning scratch 
strategies best algorithms implement depend application may unfortunately depend parallel computer 
repartitioning algorithms section fairly obvious approaches repartitioning starting points programmers developing software specific applications 
research general purpose repartitioning algorithms set benchmark applications selected problem properly formalized 
alternative include selection appropriate model computation bulk synchronous parallel bsp model val ranka 
parallel construction multidimensional binary search trees 
proc 
international conference supercomputing ics 
ak alpert kahng 
directions netlist partitioning survey 
integration vlsi journal 
bar barnard 
parallel multilevel recursive spectral bisection 
supercomputing 
bb berger 
partitioning strategy non uniform problems multiprocessors 
ieee transactions computers 
bcn nicol 
parametric binary dissection 
technical report institute computer applications science engineering nasa langley research center 
ben bentley 
multidimensional binary search trees associative searching 
communications acm 
bj bui jones 
heuristic reducing fill sparse matrix factorization 
th siam conf 
parallel processing scientific computing pages 
bm bui moon 
genetic algorithm graph partitioning 
ieee transactions computers 
bs barnard simon 
fast multilevel implementation recursive spectral bisection partitioning unstructured problems 
proc 
th siam conf 
parallel processing scientific computing pages 
sangiovanni vincentelli 
parallel graph partitioner distributed memory multiprocessor 
proc 
frontiers 
fifth symp 
frontiers massively parallel computation pages 
cgg yi jen chiang goodrich tamassia vitter 
external memory graph algorithms 
proc 
th annual acm siam symp 
discrete algorithms pages 
cjl ciarlet jr 
recursive partitioning methods greedy partitioning methods comparison finite element graphs 
technical report cam ucla 
cyl 
chung 
yeh 
liu 
parallel dynamic load balancing algorithm solution adaptive finite element meshes tori 
concurrency practice experience 
df ding 
element concurrent partitioner unstructured finite element meshes 
proc 
th international parallel processing symposium pages 
dmp monien 
helpful sets improve graph bisections 
technical report tr rf dept comp 
science university paderborn 
dph hendrickson leland 
parallel algorithms dynamically partitioning unstructured grids 
proc 
th siam conf 
parallel processing scientific computing pages 
dutt 
new faster kernighan lin type algorithms 
proc 
ieee intl 
conf 
computer aided design pages 
far 
simple efficient automatic fem domain 
computers structures 
fl 
automatic partitioning unstructured meshes parallel solution problems computational mechanics 
internat 
numer 
meth 
engrg 
fm fiduccia mattheyses 
linear time heuristic improving network partitions 
th ieee design automation conference pages 
gjs garey johnson stockmeyer 
simplified np complete graph problems 
theoretical computer science 
glo glover 
tabu search part orsa comput 
glo glover 
tabu search part ii 
orsa comput 
gmt gilbert miller 
teng 
geometric mesh partitioning implementations experiments 
proc 
international parallel processing symposium pages 
gol goldberg 
genetic algorithms search optimization machine learning 
addison wesley 
gup gupta 
fast effective algorithms graph partitioning sparse matrix ordering 
ibm res 
develop 

gz gilbert 
parallel graph partitioning algorithm message passing multiprocessor 
international parallel programming 
hb hu blake 
optimal dynamic load balancing algorithm 
technical report dl laboratory warrington uk 
hl hendrickson leland 
chaco user guide 
version 
technical report sand sandia national laboratories 
hl hendrickson leland 
improved spectral graph partitioning algorithm mapping parallel computations 
siam sci 
comput 
hl hendrickson leland 
multilevel algorithm partitioning graphs 
proc 
supercomputing 
jams johnson aragon mcgeoch schevon 
optimization simulated annealing experimental evaluation part graph partitioning 
oper 
res 
johan mathur johnsson hughes 
efficient communication strategy finite element methods connection machine cm system 
technical report tr parallel computing research group center research computing technology harvard univ 
johan mathur johnsson hughes 
parallel implementation recursive spectral bisection connection machine cm system 
technical report tr parallel computing research group center research computing technology harvard univ 
jp jones 
computational results parallel unstructured mesh computations 
technical report ut cs computer science department univ 
kumar gupta karypis 
parallel computing 
benjamin cummings publishing 
kgv kirkpatrick gelatt vecchi 
optimization simulated annealing 
science may 
kk karypis kumar 
analysis multilevel graph partitioning 
technical report university minnesota department computer science 
kk karypis kumar 
fast high quality multilevel scheme partitioning irregular graphs 
technical report university minnesota department computer science 
kk karypis kumar :10.1.1.133.6013
multilevel way partitioning scheme irregular graphs 
technical report university minnesota department computer science 
kk karypis kumar 
parallel algorithm multilevel graph sparse matrix ordering 
technical report university minnesota department computer science 
kk karypis kumar 
parallel multilevel way partitioning scheme irregular graphs 
technical report university minnesota department computer science 
kk karypis kumar 
coarse grain parallel formulation multilevel way graph partitioning algorithm 
proc 
eighth siam conference parallel processing scientific computing 
kl kernighan lin 
efficient heuristic procedure partitioning graphs 
bell system technical 
rendl clausen 
solving graph bisection problems semidefinite programming 
technical report diku tr dept computer science univ copenhagen 
ks kumar schwabe 
improved algorithms data structures solving graph problems external memory 
proc 
th ieee symp 
parallel distributed processing pages 
lan lanczos 
iteration method solution eigenvalue problem linear differential integral operators 
res 
nat 
bur 
stand 
las laszewski 
intelligent structural operators way graph partitioning problem 
proc 
fourth int 
conf 
genetic algorithms pages 
lh leland hendrickson 
empirical study static load balancing algorithms 
proc 
scalable highperformance comput 
conf pages 
lub luby 
simple parallel algorithm maximal set problem 
siam scientific computation 
miller 
teng thurston vavasis 
automatic mesh partitioning 
george gilbert liu editors graph theory sparse matrix computation volume ima volumes mathematics applications pages 
springer verlag 
nak 
bucket modification parallel recursive coordinate bisection algorithm 
linkoping electronic articles computer information science 
see www ep liu se ea cis 
shephard flaherty 
parallel adaptive mesh refinement redistribution distributed memory computers 
computer methods applied mechanics engineering 

ou ranka 
parallel remapping algorithms adaptive problems 
technical report center research parallel computation rice university 

ou ranka 
parallel incremental graph partitioning 
ieee transactions parallel distributed systems 
orf 
ou ranka fox 
fast parallel mapping algorithms irregular problems 
journal supercomputing 
psl pothen simon liu 
partitioning sparse matrices eigenvectors graphs 
siam matrix analysis applications 
rpg rolland glover 
tabu search graph partitioning 
ann 
oper 
res 
sf simon 
top software mesh partitioning parallel processing 
technical report rnr nasa 
sim simon 
partitioning unstructured problems parallel processing 
computing systems engineering 
karypis kumar 
multilevel diffusion schemes repartitioning adaptive meshes 
technical report university minnesota department computer science 
karypis kumar 
parallel multilevel diffusion schemes repartitioning adaptive meshes 
technical report university minnesota department computer science 
sr saab rao 
stochastic evolution fast effective heuristic genetic layout problems 
proc 
th acm ieee design automation conf pages 
sw savage wloka 
parallelism 
journal parallel distributed computing 
sw savage wloka 
mob parallel heuristic graph embedding 
technical report cs brown univ dep 
computer science 
val valiant 
bsp computers 
bulk synchronous parallel computers 
proc 
th international parallel processing symp pages 

conventional mesh partitioning algorithms minimum edge cut criterion impact realistic applications 
proc 
th siam conf 
parallel processing scientific computing pages 
walshaw cross everett 
mesh partitioning load balancing distributed memory parallel systems 
proc 
parallel distributed computing computational mechanics 
walshaw cross everett 
parallel dynamic graph partitioning unstructured meshes 
technical report im university greenwich centre numerical modelling process analysis 
wil williams 
performance dynamic load balancing algorithms unstructured mesh calculations 
concurrency practice experience 
