parameterized programming software architecture joseph goguen university california san diego discusses approach software architecture concepts parameterized programming particularly language module expressions 
module expression describes architecture system interconnection component modules executing expression builds system 
language features include modules parameterized theories declare interfaces number module composition operations views binding modules interfaces vertical horizontal composition 
modules may involve information hiding theories may declare semantic restrictions axioms views assert behavioral satisfaction axioms module 
laws software composition showing various module composition operations related 
show variety architectural styles supported approach extended support evolution traceability 
intended ease development large systems particular reuse effective practice 
presents approach software architecture concepts parameterized programming 
parameterized programming focuses design module composition times compile run times addresses architectural level software 
supports system generation software reuse controlled evolution management configurations versions families documentation module expressions parameterized programming constitute module connection language abbreviated mcl called architecture description language adl 
mcl may 
descriptively specify analyze design 
constructively build new system existing modules executing design 
research supported part office naval research ada joint project agency arpa domain specific software architecture project uk science engineering research council cec esprit bra core compass information technology promotion agency japan part new models software architecture project sponsored 
leave oxford university computing lab 
detailed design coding unnecessary construction description suitable database called library specifications relationships available 
parameterized programming supports construction description assuming availability library contains 
module expressions describing systems interconnections modules 
module graph describing modules relationships 
module graph incorporate executable code modules specifications software objects 
executing module expression presence suitable module graph yields executable system constructed manipulating linking implementation modules 
parameterized programming approach software architecture validated experience mcl ada implementation anna specification 
developed part adage project sponsored arpa 
implementation done tracz federal systems navigation software 
approach especially useful software factory situations helicopter navigation software facility number similar systems produced time 
cases systems able save great deal software development time significant initial investment may needed accumulate information library 
formal semantics category theory ideas developed clear specification language set theoretic semantics 
semantics general apply languages ada anna language pair satisfies certain axioms 
properties interconnection modules related straightforward way components semantics module expressions 
reported ideas developed reported suggested design lil library interconnection language ada see 
architecture 
term architecture discussed literature large family partially overlapping definitions 
situation suggests arguing meaning single popular term develop new terminology distinguishes important concepts involved 
subsection suggests terminology ideas parameterized programming 
narrow meaning architecture concerns static aspects systems components relationships components configurations communication style wider sense concerns evolutionary aspects software development changing design code relationships including traceability back changing requirements artifacts 
may call evolutionary architecture aspects evolutionary architecture discussed section 
important distinguish architecture particular system knowledge needed constructing family related systems developing large complex evolving system 
suggest calling system architecture domain architecture respectively 
parameterized programming module expression captures particular system architecture module graph captures architectural domain 
needed support large scale system development efforts 
organized follows section discusses basic concepts approach including theories views module graph section discusses parameterization instantiation distinction vertical horizontal structure section discusses module expressions give easy way describe system architectures software laws section sketches evolution traceability supported section gives final discussion 
tracz useful discussions suggestions help examples 
wish collaborators drs 
burstall diaconescu malcolm meseguer 
word framework collection modules capturing common aspects applications certain problem domain 
module graphs parameterized programming assumes modules associated specifications serve headers information particularly source code compiled code 
specifications need complete include syntax exported module syntax interface parameterized names modules inherits 
parameterized programming specification code modules collected information form module graph describes organization system development database including information relevant system domain architecture module graph node may header ffl theory specification ffl package specification ffl module expression edge module graph may labelled module relationship ffl inheritance ffl view ffl parameterization ffl instantiation 
package specifications intended associated executable code 
theory specifications discussed subsection 
software objects associated nodes edges discussed 
module graphs ideas call 
relevant ideas summarized follows ffl modules associated clusters ffl specifications headers cluster ffl implementations may package specification including source code compiled code ffl plus optionally test cases performance data documentation term similar ideas arpa community 
module graph abstraction organization 
various reasons including efficiency structure existing database systems information structure implemented may quite different suggested mathematical structure graph 
administrative information programmer date change rationale links software objects 
cluster node module graph 
software objects referred point requirements dataflow diagrams transcripts interviews review documents attached clusters associated nodes module graph 
package specification stack integers package intstack inherit integer type stack exception exception function isempty stack return boolean function stack return boolean function push integer stack return stack gamma gamma gamma gamma 
raise function pop stack return stack gamma gamma gamma gamma isempty 
raise function top stack return integer gamma gamma gamma gamma isempty 
raise gamma gamma axiom gamma gamma integer stack 
gamma gamma gamma gamma pop push gamma gamma top push gamma gamma intstack specifications need developed extent practically useful just syntax 
specification incomplete define functions full empty 
theories views theory specifications called theories short describe generic module interfaces may contain axioms serve semantic constraints actual modules allowed interface 
implementation modules associated theories 
simplest theory just says type provided theory triv type element triv non empty module matched triv designating exported types 
theory axioms provide semantic constraints fit interface defines saying type partial order structure theory poset type element function element return element gamma gamma axiom gamma gamma element 
gamma gamma gamma gamma gamma gamma gamma gamma poset views bind actual values modules generic module interfaces theory modules order instantiate generics 
modules may involve information hiding views assert behavioral satisfaction axioms source theory target module proving axioms satisfied necessarily part system intended practical ordinary 
views recording programmer belief axioms source theory hold target module 
support belief may provided line back envelope giving formal mechanical proof extremes belief may left unsupported recommended 
nature support scanned image envelope back source file machine proof stored view module graph 
view asserts relation 
integers ada package standard satisfies axioms poset instantiate generic package sort yielding package function sorts integers descending order 
view geq poset 
standard types element 
integer ops 
geq views assert global properties systems giving view system represented module expression saying system composed lower level modules see section theory axioms giving properties means axioms need appear hold possible experiments module involving externally visible operations called observational satisfaction 
asserted 
axioms need behaviorally satisfied 
parameterized modules characteristic feature parameterized programming parameterization modules interface declarations module fits interface substituted parameterized module yielding new module instance instantiation original module 
interface described theory 
code parameterized version intstack module earlier material intstack indicated generic package stack element triv type stack function push element stack return stack function top stack return element 
gamma gamma axiom gamma gamma element stack 
gamma gamma stack generic package specification sorting program parameterized poset theory says partially ordered set supplied order program correctly generic package sort item poset inherit list item function sort list return list function sorted list return bool gamma gamma axiom gamma gamma list 
gamma gamma sorted sort true gamma gamma 
sort modules inherit modules 
simple syntax illustrated package inherit sys inherit sort integer 
inherited submodules shared new copies produced 
instantiation sort program specified instantiated view geq simply writing sort geq results program sorting integers descending order 
similarly instantiate sort partial ordering relation divisibility natural numbers writing sort div div suitable view 
default views enable obvious views replaced name target module name type 
example write view poset standard mapped type elt integer operation symbol 
just write sort integer 
default views computed certain set default rules capture intuitions obvious 
instantiations default views stack integer stack list integer stack stack float 
default views implemented obj partially implemented 
interface theory call operation type views express bindings interfaces 
generic modules parameterized interface defined theory 
multiple views needed instantiate modules 
vertical composition vertical structure describes lower layers virtual machines horizontal structure describes layer distinction vertical horizontal structure named formalized goguen burstall provides direct support layered architectural styles 
parameterized programming provides parameterization instantiation vertical horizontal structure 
generic package specification horizontal vertical parameter generic package sort item poset list item function sort list return list function sorted list return bool gamma gamma axiom gamma gamma list 
gamma gamma sorted sort true gamma gamma 
sort note horizontal interface theory parameterized instantiated horizontal formal parameter 
default view triv poset involved vertical instantiation sort wants poset list wants triv 
note notation horizontal parameterization vertical 
conventions apply instantiation illustrated module expression instantiation uses default view sort natural list natural graphical relationships inheritance horizontal parameterization vertical parameterization 
note horizontal instantiation actual parameters shared vertical new copies 
module imported module th horizontal interface theory vertical interface theory 
vertical horizontal parameterization important architectural decision implications sharing 
module expressions want module expressions compact definitions system architectures 
requires go parameterization instantiation operations implemented ffl module aggregation simple combination account shared inherited modules parameterization ffl deleting functionality ffl modifying functionality ffl adding functionality 
operations types renamed deleted added exceptions axioms horizontal vertical instantiation 
module expressions illustrate syntax sys sys sys rename op put 
write sys delete op undo stack rename type stack 
stack integer stack rename type stack 
stack list float adds modules forms system containing summands summation associative see section number summands 
see related 
command executes module expression build sub system give name store environment 
illustrate sys stack stack float sys delete op undo sys command parameterized sys poset sort list sys course command results previous sys sys sys float sys furthermore statement impose sharing parameters constituents poset sort list stack module expression introduced added node module graph module expression evaluated executable code generated attached cluster module expression 
module expression evaluation implemented manipulating intermediate compiled code ada intermediate compiled code language diana 
intermediate compiled code easier manipulate object code source code required information sufficiently explicit form 
gets benefit able put manipulated code compiler backend including optimization 
module expressions implemented obj system different techniques attached code separate programming language 
mathematical semantics module expression evaluation colimit diagram extracted module graph simpler set theoretic semantics 
provides graphical layout editor module expressions notation typically engineers boxes arrows 
helps users edit existing module expressions define new sub systems define scratch wish 
architectural styles different architectural styles supported parameterized programming including different communication styles shared variables pipelining message passing 
described shared submodules various ways 
cell simple object sense object oriented programming easily specified 
example cell module encapsulates variable modules inherit share system communicate 
similarly post office module inherited set modules passing messages 
pipelining special case shared variable communication modules share cell cells represent pipes inheriting module reading variable writing 
th oe param vertical param horizontal vertical composition example modules inherit cell modules inherit cell short pipeline 
subsection sketches ways describe portions avionics architectures module expressions 
modules encapsulate various digital signal processing subsystems shared cells represent wires pass signals 
describing avionics systems interesting example module takes module parameter kalman filter module needs model aircraft situation expressed simple module expression 
sense parameterize filter different aircraft models 
consider flight control system needs guidance system needs describe situation module expression 
omit details code 
assuming modules parameter interface theories gs ac respectively views needed match ac gs natural expect default views examples 
simple approach instantiating parameterized modules works system architecture linear generally tree adequate sharing modules feedback loops 
feedback necessary avionics software feedback control crucial technique 
example suppose value floating point variable needs capture encapsulating letting inherit system described simple module expression 
approach provide new parameter floating point cell case system described module expression 
example highlights importance sharing module interconnect formalism 
shown parameterized programming accomplish sharing ways 
capability difficult impossible handle feedback variables shared modules 
software laws relationships various operations modules important considered laws software 
inherits notation indicates inherits module indicates inherits set modules 
laws parameterization see proofs 
laws implementation simplifying module expressions 
evolution traceability traditional view software engineering evolution occurs initial development complete 
contrast consider evolution include involved changing system plus relationships things system lifetime 
word evolution focuses attention change inevitable software development 
large complex systems inevitably embedded complex evolving social contexts necessarily evolve contexts sense affect evolution 
see discussion evolution social context 
ubiquity change motivates iterative lifecycle processes especially prototyping quickly building evaluating series prototypes concrete executable models selected aspects system 
ability parameterized programming describe software architectures domain systems senses greatly facilitate prototyping 
cases need done edit module expression 
cases module graph may need updating writing new modules modifying old ones 
executing module expression yield running prototype gracefully evolved actual system evolved 
additional information needed cope dynamic evolution families software systems provided enriching module graph relevant relationships various software objects requirements rationales 
rationales considered part evolution support architecture evolve objects concern 
subproblems include formalizing dependencies developing methods calculating dependencies propagating implications changes 
traceability centre requirements foundations oxford projects improve acquisition traceability accessibility modularity reusability numerous objects arise manipulated software development particular focus role requirements 
initial study administered detailed stage questionnaire software engineers large firm traceability considered important outstanding problem 
analysis showed different traceability problems treated different ways 
major distinctions pre rs requirements specification traceability post rs traceability forward backward traceability 
tracing back far requirements important developing large software systems 
difficult overhead maintaining huge mass dependencies objects produced large software development effort 
dependencies reaching far development cycle significant 
formal representations objects involved formal models dependencies tool support managing impossible know effect change particular know objects may changed maintain consistency 
hypergraph model maintaining evolving dependencies suitable basis tool development structure applied give model evolving module graphs 
capturing domain knowledge methods sociology particularly ethnomethodology disciplines interaction analyses 
information research may 
developing system called support tracing dependencies evolving objects particular show decisions grounded prior objects 
approach called builds parameterized programming intended support social context decisions traceability linking related objects broad view context requirements suggested 
supports user definable relations allow differentiating different links objects 
allows declaring mathematical properties relations transitivity give additional power flexibility tracing links specifiable compositions relations 
supports different trace modes including browsing regular expression search object relation definition intuitive template driven graphical interfaces 
support reuse generalized notion relation linking objects requirements design specification coding documentation built foops general object oriented language specification capabilities 
particularly suitable object oriented development paradigm 
uses foops modules declare software objects relations automatically create links objects interconnected evolve 
provides hypermedia facilities html closer analysts intuitions natural activities 
example graphs charts videos objects conventional documents 
discussion seen parameterized programming provide systematic approach design manipulation software architectures theories views powerful methods combining modifying components form new systems underlying module graph data structure 
notions module expression module graph believe add clarity discussions nature software architecture 
illustrated module expressions achieve different architectural styles 
parameterized programming extends support evolution including software objects module graph requirements rationales documentation relations support traceability 
enables design objects relations managed systematic way significant impact reusability code reuse design information 
support evolution allows integration prototyping traceability natural way 
reusability supported systematic cataloging information evolving module graph 
hoped ideas help development large complex systems reliable efficient today 
don batory sean malley 
design implementation hierarchical software systems reusable components 
technical report tr department computer sciences university texas austin 
revised may 
barry boehm william scherlis 

proceedings software technology conference pages april 
rod burstall joseph goguen 
putting theories specifications 
raj reddy editor proceedings fifth international joint conference artificial intelligence pages 
department computer science carnegie mellon university 
rod burstall joseph goguen 
semantics clear specification language 
bjorner editor proceedings copenhagen winter school software specification pages 
springer 
lncs 
david garlan mary shaw 
software architectures 
advances software engineering knowledge engineering 
joseph goguen 
suggestions organizing libraries software development 
editors proceedings international conference supercomputing systems pages 
ieee 
supercomputing systems editors elsevier 
joseph goguen 
principles parameterized programming 
biggerstaff perlis editors software reusability volume concepts models pages 
addison wesley 
joseph goguen 
formal approach software environments 
proceedings symposium formal approaches software environment technology 
joint system development tokyo japan january 
joseph goguen 
requirements engineering reconciliation social technical issues 
goguen editors requirements engineering social technical issues pages 
academic press 
joseph goguen 
formality informality requirements engineering 
proceedings international conference requirements engineering appear march 
joseph goguen rod burstall 
cat system structured elaboration correct programs structured specifications 
technical report report csl sri computer science lab october 
joseph goguen 
formal methods social context software development 
mosses nielsen schwartzbach editors proceedings tapsoft pages 
springer 
lncs 
joseph goguen malcolm 
proof correctness object representation 
william roscoe editor classical mind essays honour hoare pages 
prenticehall 
joseph goguen jos meseguer 
unifying functional object oriented relational programming logical semantics 
shriver wegner editors research directions objectoriented programming pages 
mit 
joseph goguen tracz 
implementation oriented semantics module composition 
preparation 
joseph goguen timothy winkler jos meseguer futatsugi jean pierre jouannaud 
introducing obj 
goguen malcolm editors algebraic specification obj 
cambridge appear 

requirements traceability 
technical report centre requirements foundations oxford university computing lab december 
higgins 
adage layout editor user manual 
technical report adage lor federal systems july 
bernd krieg bruckner david luckham 
anna language annotating ada programs 
sigplan notices november 
david luckham 
programming specifications anna language annotating ada programs 
springer 

software evolution rapid prototyping 
ieee computer 
joseph goguen 
formal methods problems promises 
ieee software appear july 
francisco pinheiro joseph goguen 
object oriented tool tracing requirements 
ieee software appear march 
special issue papers 

design implementation evaluation declarative object oriented language 
thesis programming research group oxford university 
tracz 
parameterized programming 
proceedings second international workshop software reuse march 
italy 
tracz angeline shafer lou 
experience avionics domainspecific software architecture 
proceedings pages may 
gio wiederhold peter wegner stefano ceri 

communications acm 
