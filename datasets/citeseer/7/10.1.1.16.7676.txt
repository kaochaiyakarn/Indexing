vmgen generator efficient virtual machine interpreters anton ertl david gregg andreas krall bernd institut fur technische universitat wien wien austria department computer science trinity college dublin ireland 
munchen germany summary virtual machine interpreter code virtual machine instruction similarities code instructions 
interpreter generator takes simple virtual machine instruction descriptions input generates code processing instructions ways execution virtual machine code generation disassembly tracing profiling 
generator designed support efficient interpreters supports threaded code caching top stack item register combining simple instructions superinstructions optimizations 
generator create interpreters forth java 
resulting interpreters faster interpreters languages typically times slower code produced native code compilers 
results effects individual optimizations supported generator 
key words interpreter virtual machine generator stack architecture superinstruction byte code interpreters popular approach implementing programming languages 
advantages interpreters attractive ffl ease implementation 
ffl portability 
ffl fast edit compile run cycle 
implementation techniques provide advantages interpreters provide 
popular choice implementing interpreters virtual machine vm intermediate representation similarities real machine correspondence anton ertl institut fur technische universit wien wien austria mail anton mips tuwien ac bibtex entry available www tuwien ac papers 
published preprint article published software practice experience pages www interscience wiley com code particular vm code consists sequence vm instructions 
designs interpretive system divided front compiler produces vm code vm interpreter executes code 
advantages approach efficiency vm usually designed interpreted minimal interpreter overhead clean interface modules interpretive system 
known examples virtual machines java jvm ly prolog wam ak smalltalk vm gr 
virtual machines designed stack architectures reasons easy generate stack code languages stack vm instructions require decoding overhead register vm instructions execute faster ert 
automation creating vm interpreter repetitive pieces code code executing vm instruction similarities code executing vm instructions get arguments store results dispatch instruction likewise vm disassembly vm code generation 
code dealing vm instruction distributed places vm interpreter engine vm disassembler vm code generation support functions 
want change add vm instruction typically places updated 
issues suggest generating code processing vm instructions common vm instruction description 
generator vmgen 
single simple vm instruction description file section generates code ffl executing instruction operand access debugging support instruction dispatch generated automatically see section 
ffl routines generating vm code front interpretive system see section 
ffl disassembling vm code useful debugging front see section 
ffl profiling vm instruction sequences section 
ffl combining instructions superinstructions section 
vmgen special support stack vms 
special support register vms features useful working vms stack operand access generation stack access optimizations useless register vms 
efficiency addition reducing writing maintaining interpreter vmgen easy write fast interpreters supporting efficient implementation techniques number optimizations 
usual meaning virtual machine interpreter construction item doc ic ac uk cgi virtual machine 
vm code vm instruction routines machine code iadd dispatch instruction machine code dispatch instruction iadd iadd 
gnu alpha assembly ip ldq load vm instruction ip addq increment vm instruction pointer goto jmp jump vm instruction threaded code vm code representation instruction dispatch argue efficiency important interpreters slow anyway 
attitude lead interpreter factor slower native code produced optimizing compiler slowdown efficient interpreters factor 
difference slow fast interpreter larger difference fast interpreter native code 
argument interpreted programs spend time native code libraries speeding interpretive engine provide speedup programs 
amount time spent libraries necessarily known start project prospect slowdown library cover significant amount computation performed simple operations daunting 
having efficient interpreter increases number applications library dominates run time 
example consider application spend time libraries compiled optimizing native code compiler efficient interpreter spend time library slowdown optimized native code inefficient interpreter spend time library slowdown 
vmgen supports techniques optimizations writing efficient interpreters ffl threaded code section 
ffl scheduling dispatch vm instruction section 
ffl keeping top stack register section 
ffl combining vm instructions superinstructions section 
ffl eliminating stores unchanged stack items section 
ffl improving branch prediction accuracy section 
threaded code threaded code bel represents vm instruction address routine implements instruction 
threaded code code dispatching instruction consists fetching vm instruction jumping fetched address incrementing instruction pointer 
technique implemented ansi implemented gnu values extension 
shows threaded code instruction dispatch sequence 
popular technique implementing vm interpreters represents vm instruction integer byte sized uses switch statement dispatch 
advantages threaded code switch dispatch short fast instruction dispatch sequence better branch prediction accuracy machines branch target buffers 
disadvantage threaded code compared bytecode larger vm code size 
vmgen overview shows source files vmgen interpreter compiled generated files involved 
input vmgen file contains type stack definitions instruction specifications see section details 
vmgen outputs files containing code files included wrapper function vmgen comes example example wrapper files usually changes exception rule compiler contains front interpretive system quite different different languages 
interpreter compiled vm profiling enabled running interpreter produces vm profile addition usual results vm profile useful selecting vm instruction sequences combined superinstructions 
input shows simplified grammar vmgen input language 
shows complete useful vmgen style virtual machine specification explained 
simple instruction specifications typical example simple instruction description jvm instruction iadd iadd extension include commonly extension header indicates declarations macro definitions 
vm gen labels profile peephole engine compiler profile peephole engine compiler profile peephole profile interpreter cc cc cc cc cc ld cpu vmgen wrapper generated file description input vm description section engine vm vm instruction execution section engine labels vm instruction address array section vm code disassembler section compiler gen vm code generation section profile profile vm instruction sequence profiling section peephole peephole superinstruction tables section files processing steps interpreter generation vmgen extracts lot information line instruction specification generates lot code code part just verbatim generated files 
particular parenthesized part line stack effect contains lot information number items popped pushed stacks order stack type name referred code 
example iadd pops integers data stack executes code pushes integer data stack 
stack effect responsible lot generated code declaring variables stack items accessing arguments results description 
comment escape 
newline newline newline 

newline comment 
newline escape 
newline 
stack 
stack prefix 
single double type prefix simplified ebnf grammar vmgen input stack definitions stack data stack sp cell stack prefix definitions inst stream stack prefix type prefix definitions int single data stack type prefix simple instruction definitions iadd ipush superinstruction definitions ipush iadd simple virtual machine specification outputting arguments results traces dealing immediate arguments vm code generation disassembly 
special macros user supplied code contain macros special meaning vmgen 
set ip macro sets vm instruction pointer 
implementing vm branches 
indicates vm code basic block profiling 
super basic block instruction set ip profiling see section 
example jvm implementation uses super vm instructions return engine 
tail macro indicates execution current vm instruction ends invoked 
macro necessary want middle user supplied code vmgen automatically appends code needing tail 
vmgen expands tail 
example macros consider conditional branch ifeq tail prefix indicates immediate argument see section 
improve branch prediction accuracy tail falling see section 
types type stack item specified prefix hungarian notation fortran 
example stack items prefix indicates bit integer 
types prefixes specified start file int single data stack type prefix int indicates type prefix int single indicates type takes slot stack currently vmgen supports types slots data stack default stack stack items type see section name prefix 
matching prefixes longest 
stacks vmgen supports virtual machines stacks 
treats instruction stream stack respects approach convenient way automate treatment immediate arguments 
accesses non default stack specified prefix part name argument 
example consider code vm instruction ipush pushes constant stack ipush prefix instruction stream ipush just takes value instruction stream pushes stack 
define stack stack data stack sp cell generalization jvm instructions 
inspired immediate addressing mode syntax data stack name stack prefix definitions refer name sp name stack pointer cell type generic stack item type stack pointer points 
instruction stream works somewhat differently stacks predefined stack pointer ip type cell 
define stack prefix inst stream stack prefix inst stream name stack stack predefined prefix 
conversion generic stack item type type particular stack item performed conversion macros accessing stack item see section 
superinstructions superinstruction performs sequence simple instructions 
defined ipush iadd ipush iadd name superinstruction ipush iadd names component instructions arbitrarily components 
virtual register machines ways vmgen defining register vm direct way define instructions take register numbers immediate arguments stacks add reg reg reg indirect way define hybrid stack register vm register accesses transfers registers stacks full register instructions defined superinstructions load reg store reg add load load iadd store advantages indirect approach vmgen tracing feature produces useful output reports values loaded stored registers easier deal instructions specialized hardcoded registers load 
course hybrid stack register vm choose stack registers short lived intermediate results profiling decide sequences superinstructions resulting best worlds vm 
label int declarations stack items int int dispatch instruction part sp fetch argument stack items sp stack pointer updates user provided code line mini dispatch instruction part vmi cell store result stack item dispatch instruction part simplified version code generated iadd vm instruction vm file see text description output interpreter engine shows simplified commented version vm output vmgen generates iadd vm instruction 
starts label vm instruction 
stack items instruction declared 
macros instruction dispatch sequence 
assignments stack accesses arguments vm instruction 
stack pointer updated stacks grow lower addresses 
piece code code instruction specification 
apart dispatch code stack access result instruction 
stack accesses top stack sp enable top stack caching see section 
vm cell vm cell macros changing type stack item generic type type actual stack item defined program includes vm file defined cell integer type casts macros alternative define cell union 
code looks long inefficient complete version longer gcc optimizes quite produces optimal code shown fig 
alpha architecture 
produces optimal code iadd architectures looked 
debugging typical debugger suited debugging interpreter debugger works low level know ldl sp ldq load vm instruction addq sp addq increment vm instruction pointer addl jmp jump vm instruction alpha code produced iadd name iadd print vm inst 
name vm registers 
fetch stack items ifdef print arguments endif 
user provided code ifdef print result endif 
store stack items dispatch tracing code generated iadd vm instruction vm file see text description interpreted program stepping interpreter tedious debugger offer support stepping interpreted program 
vmgen supports debugging vm level ways vm disassembler see section trace mechanism described section 
note debugging vm level useful debugging interpretive system usually debugging user program interpreter writer may want provide additional facilities debugging user programs 
shows tracing code left fig 

name macro output instruction name contents interesting vm registers instruction pointer stack pointers 
trace written file vm directed stdout stderr 
user defines functions control arguments results displayed useful types functions better displayed symbolically 
tracing outputs surrounded avoid influencing code quality non debugging version interpreter cell ip synthetic names stack item vars cell sp cell sp ip cell fetch superinstruction arguments sp cell stack pointer update ipush component instruction ipush int declare ipush stack items ip fetch ipush argument ipush user supplied code sp vmi cell store ipush result iadd component instruction iadd int declare iadd stack items int int sp fetch iadd arguments sp iadd user supplied code sp vmi cell store iadd result cell sp store superinstruction result simplified version code generated ipush iadd superinstruction vm file see text description surrounded vm debug allow switching tracing run time debugger 
superinstructions shows code vmgen produces superinstruction ipush iadd 
introduces additional variables stack items involved superinstruction loads arguments variables start stores results arguments performs combined stack pointer updates start example change sp ip updated ip macro 
code generated component instruction superinstruction ldq ip cell ldq load vm instruction addq increment vm instruction pointer addl jmp jump vm instruction alpha code produced ipush iadd similar code generated instruction simple instruction arguments fetched results stored stack item variables superinstruction stack pointer updates instruction dispatch code 
approach relies heavily optimization capabilities compiler particular copy propagation 
fortunately gcc quite shown fig 

code shorter code iadd sp updated 
see combining instructions superinstruction optimizes dispatches away stack accesses stack pointer updates 
debugging code shown inserted component instructions superinstruction advantages approach arguments results reported meaningful names output comparable diff instructions combined superinstructions disadvantage superinstructions visible debugging output 
labels implement threaded code gnu labels values feature 
problem approach labels visible function containing interpreter engine 
need know labels functions generate vm code 
solution store labels array return array special call engine function globally accessed variable vm inst 
vmgen supports approach generating contents array initializer file labels example iadd generates label gnu syntax address label iadd 
vm code generation support vmgen generates functions generating vm code file gen example function generate ipush instruction ipush pushes constant stack takes immediate argument bit interesting iadd course goto labels occur engine function 
passed outside order avoid having put vm code generation code engine function 
void inst ctp int ctp ctp pointer generated code pointed ctp incremented gen inst vm inst contains label ipush 
advantages providing functions front symbolic name having refer vm inst increasing readability maintainability passing immediate argument function increases readability type checker compiler check number types arguments 
example shows functions frontend written yacc expr num expr expr disassembler having vm disassembler useful debugging front interpretive system 
information necessary vm disassembly instruction descriptions vmgen generates instruction specific parts automatically ip ipush int ip ip goto endif example shows code generated disassembling vm instruction ipush 
condition tests current instruction ip ipush vm inst 
prints name instruction arguments sets ip point instruction 
printing instruction address done enclosing loop 
sequence ifs results linear search existing vm instructions chose approach simplicity disassembler time critical 
profiling vmgen supports profiling vm level 
goal provide information interpreter writer frequently occurring statically dynamically sequences vm instructions 
interpreter writer information select sequences combining superinstructions 
ends goto endif long cascade overruns parser stack gcc ifs 
switch vm inst valid case label 
approach profiling taken record vm control flow branches vm branch target 
conditional branches path counted branch target 
run counts vm basic blocks entered fall conditional branch corrected basic blocks disassembled subsequences output attached execution frequencies 
scripts aggregating output totals static occurences dynamic execution frequencies process superinstruction rules file 
counting approach quite fast slowdown factor profile long running applications 
support profiling comes parts ffl file profile contains routines profiling 
ffl code produced vm branch vm instruction set ip contains call super near interpreter writer just needs define super vm count block ip profiling version interpreter 
ffl vmgen generates file profile performs disassembling profile profile code instruction similar disassembler code ip ipush ip goto endif disassembling basic block ends ip points start basic block code instruction contains set ip super 
profiling approach notice basic block boundaries arising targets branches taken profiling run 
front register additional basic block boundaries explicitly additional precision desired 
peephole optimization current approach combining instructions superinstructions simple peephole optimizing approach invocation gen inst see section checks new instruction combined instruction superinstruction course instruction superinstruction 
instructions combined vm branch targets branch middle superinstruction accurate reporting vm branch targets essential usually easy front knows branch targets vm code generation 
vmgen supports approach routines peephole generating tables peephole mapping instructions superinstruction rule combining ipush index iadd index ipush iadd index 
peephole optimization transparent human written code generation code example call gen ipush followed call gen iadd code generation support code automatically generates ipush iadd 
additional requirement report basic block boundaries arising branch targets 
done add delete superinstructions rebuild interpreter new superinstructions automatically 
optimizations vmgen implements number optimizations supports 
optimizations performed combining instructions superinstructions described section 
scheduling prefetching vmgen generate single dispatch vm instruction macro invocation code instruction gcc able schedule code processed parallel rest code instruction rest code ends basic block boundary store potential aliasing load start dispatch code 
vmgen generates macro invocations dispatch distributes code instruction 
various ways define macros related ones add ip set ip optimize specific properties architectures microarchitectures number registers latency vm instruction load dispatch jump addressing mode 
scheme allows prefetching vm instruction gforth interpreter built vmgen uses powerpc architecture advantage speedup see section 
shows example scheduled code code dispatching instruction interleaved code 
vmgen supports scheduling ways stack pointer updates loads stack user provided code fill latency loads means code fills update store latency address generation interlock processors 
top stack caching vmgen supports keeping top stack item tos stack register level local variable 
optimization benefits ffl reduces number loads stores stack vm instruction takes arguments produces restrict feature iso avoid aliasing available originally encountered problem 
results stack 
halves number data stack memory accesses gforth ert 
ffl remaining loads stores placed away instructions produce result supporting parallelism especially important floating point operations order execution cpus 
downside optimization requires additional register possibly spilling different vm register memory 
see speedup gforth register starved ia pentium athlon architecture 
vmgen performs optimization replacing tos referencing stack items 
addition cases consider ffl vm instruction takes arguments stack produces results flush store tos stack memory start vm instruction tos results 
ffl vm instruction produces results stack takes arguments refill load tos stack memory vm instruction 
ffl vm instruction access stack tos need spilled 
see benefits optimizations fig 
memory access stack accesses fig 
stack memory accesses remaining 
long stack accesses managed vmgen optimization transparent interpreter writer apart need define macros 
interpreter needs access stack items memory jvm locals set stack pointer jvm return instructions 
vm contains instructions user options ffl disable top stack caching 
ffl flush top stack cache explicitly stack access stack pointer change reload 
eliminating stack stores vm instructions dup naively generated code store twice store bottom element memory location loaded 
store redundant compiler reliably optimize away 
vmgen optimizes away code level 
uses name stack item indication result stack item name argument stack item coming location vmgen suppresses store 
vmgen requires user supplied code change argument stack items optimization incorrect 
currently requirement checked enforced declaring argument stack item variables const initialization assignment variable 
complications top stack caching enabled bottom element store dup example longer redundant comes tos register store memory conversely top store tos register gcc optimizes away example vmgen generates code conditionally compiling store 
complication store optimization hard superinstructions require tracking stack items components 
vmgen currently perform store optimization superinstructions 
branch prediction mispredictions indirect branches major component run time efficient interpreters 
current processors branch target buffer btb predict indirect branches predict target address particular indirect branch execution branch 
ideally different indirect branch vm instruction different time indirect branch executed 
general scope means vm instruction separate indirect branch threaded code dispatch macros ensure vm instruction superinstruction occur inner loop frequently vm instructions problem superinstructions mitigate 
conditional branch vm instructions possible vm instructions different idea different indirect branches 
vmgen supports optimization macro tail see section 
vmgen expands macro part vm instruction superinstruction including code storing stack items appropriate memory locations top stack register 
experience vmgen implement interpreters gforth portable product quality interpretive implementation forth ert 
forth stack language gforth stacks data stack return stack floating point stack vm instructions directly forth words 
gforth vm specification lines contains vm instructions vmgen generates lines superinstructions 
gforth project started gforth distributed gnu package 
vmgen start proved useful just allowed adding new vm instructions little effort easy generate additional output formats envisioned originally tags file supporting fast navigation vm description emacs 
interpreter implemented threaded code variant cacao jvm jit compiler 
goals project see useful vmgen interpreters gforth add missing functionality build high performance interpreter jvm 
order achieve goal decided translate original bytecode threaded code jvm vm jit compiler fashion 
avoids performance penalties bytecode interpretation particular immediate operand access allows having vm instructions including superinstructions 
manually written vm specification lines contains vm instructions mapping jvm instructions vm addition vm instructions jni functions generated automatically vmgen generates lines code superinstructions vmgen works threaded code cacao added new features project necessary gforth generating vm disassembler vm code generation support unexpected 
vmgen cacao straightforward gforth 
vmgen byte code interpreter possible vmgen currently supports types stack slots dealing immediate operands bytes coming instruction stream stack currently require manual construction operands smaller fragments 
presence superinstructions interesting effect wrote threaded code cacao cases considered introducing new vm instruction just sequence existing vm instructions new vm instruction introduced automatically sequence executed frequently 
superinstructions just run time optimization help optimizing programming time 
vmgen needs seconds run 
compiling resulting files take minutes fast machines functions compiled huge including generated code lines engine function cacao superinstructions 
main practical limit memory compilation compiling gforth superinstructions requires mb bit machine mb bit machine 
compiling cacao superinstructions requires mb bit machine severely mb machine 
historically root vmgen experience gained writing prolog interpreter wam anton ertl thomas graf andreas krall gl interpreter stack vm anton ertl projects done dms decision management systems gmbh vienna 
gforth project started knew repetitive automatable parts writing interpreter wrote generator emacs lisp rewrite forth version emacs slow hard modify current version consists mainly line forth program 
early experiences influenced modifications performed generalized generator tailored gforth gforth requires additional twists basic implementation model indirect threaded code dew code deals additional complication small create automatic support 
needs general vm interpreter generator 
performance section basic performance data evaluate effect various optimizations 
optimizations evaluated earlier papers contribution section detailed evaluation measurements modern hardware branch prediction hardware big difference 
earlier measurements performed environments different environment different vms different dispatch method different hardware performed measurements validate earlier results quantify effects optimizations interpreters generated vmgen modern hardware 
benchmarks environment forth benchmarks sieve bubble matrix fib small integer benchmarks 
brainless alphas chess program written david lines 
brew evolutionary programming simulation written robert lines run benchmark alphas bit clean 
puzzle solver written bruce lines 
jvm benchmarks javac jdk java compiler compiling 
db spec jvm benchmark db 
sieve small integer benchmark 
suml tiny benchmark increment long variables 
designed maximize speed difference native code cacao interpreters uses jvm requires vm instructions incrementing long int long version 
value benchmark providing worst case performance numbers interpreters realistic numbers 
table shows environments benchmark runs exceptions noted occur 
machines gcc compiling code 
baseline interpreters sections optimizations applied peephole optimization superinstructions apply superinstructions baseline experimenting bugs cacao original native code version prevented running spec jvm 
cpu arch 
clock system os athlon ia mhz kt linux glibc pentium iii ia mhz linux glibc ppc powerpc mhz linux glibc ppc powerpc mhz linux glibc alpha mhz linux glibc alpha mhz pc lx linux glibc alpha mhz xp linux glibc table hardware os benchmarking athlon sieve bubble matrix fib brainless brew 
gforth win forth pfe javac db suml cacao native cacao int dec jvm native dec jvm int osf jvm int javac db suml cacao native cacao int dec jvm native kaffe int table relative user times running benchmarks gforth cacao int competitors smaller better selection right superinstructions superinstructions increase chances cache conflicts cause large performance variations may hide performance effects 
ia compiled gforth versions compare explicit register allocation important vm registers gcc spills memory resulting significant slowdown factor athlon 
basic performance section compares performance interpreters generated vmgen performance systems 
table compares performance interpreters generated vmgen gforth cacao int language implementations hardware 
results execution times relative fastest implementation smaller better 
relatively simple forth native code compiler uses macro expansion peephole optimization code generation pay gforth times slower athlon pentium iii factors similar 
small slowdown brew probably caused library functions implemented efficiently gforth right superinstructions gforth beats brew 
win forth forth interpreter written assembly language 
ran windows measured elapsed time 
win forth slower factor excluding gforth 
main reasons win forth uses position independent image format relocates run time requires additional computation memory access image gforth avoids overhead relocating load time 
win forth uses indirect threaded code indirection vm instruction dispatch gforth slowdown caused indirect threaded code 
gforth speedup win forth shows possible create fast interpreters vmgen 
pfe forth interpreter written execution speed secondary goal development 
faster forth interpreters gnu global register variables configure option regs done 
gforth speedup pfe interpreters shows speedup different interpreters larger speedup fast interpreter native code generalize performance interpreter interpreters general 
cacao native jvm jit compiler allocates locals stack items registers performs loop optimizations affects sieve results 
shares code garbage collector synchronization cacao int 
small benchmarks slowdown cacao int factor worst case slow larger ones slowdown factor 
important reason gprof benchmarks cacao int spends time routines synchronization garbage collection speed implementations infinite speedup rest cacao native get speedup 
ran dec jvm osf jvm digital unix 
dec jvm native jit versions beat cacao int lot small benchmarks slower cacao int large benchmarks 
dec jvm know due slow implementation synchronization kp 
moral results speeding run time system routines synchronization impact probably costs effort implementing jit compiler native code 
interpretive jvm implementations slower cacao int factor benchmarks believe speed advantage due threaded code implementation performance features cacao int derives vmgen 
superinstructions performance interpreters generated vmgen competitive relative interpreters slowdown native code compilers limited 
gforth linux elapsed time close user time benchmark writes lot terminal expect timings comparable times 
ppc ppc speedup sieve bubble matrix fib brainless brew speedup prefetching powerpc default scheduling support speedup early fetch alpha default prefetching speedup early fetch alpha default scheduling support speedup early fetch tos caching scheduling support tos caching comparing dispatch code scheduling variants scheduling prefetching gforth defines macros differently different architectures mainly support compiler scheduling code selection addressing modes 
particular alpha architecture early fetch vm instruction support filling delay slots load instruction power powerpc gforth pre fetches instruction cpus usually particularly long load jump latency cycles ppc 
schedule instruction fetch early ia increase register pressure cause spilling 
shows results evaluations different scheduling strategies alphas 
prefetching gives speedup scheduling long load jump latencies 
compare early fetching scheduling powerpc expect results similar results alphas 
alphas little difference scheduling strategies 
small difference early fetching prefetching case fig 
easily explained fact alphas relatively short load latency prefetching help resources additional move necessary prefetching hurts little 
surprised small difference early fetch scheduling alpha case fig 

looking machine code gcc managed schedule load ahead jump cases vm instructions store basic block boundary impede scheduling 
disabled top stack caching variants case fig 
scheduling support provided significant speedups scheduling support vm instructions perform store near 
significance experiment vms stores basic block boundaries near vm instruction frequent baseline gforth explicit early fetching may value athlon pentium iii ppc ppc speedup sieve bubble matrix fib brainless brew speedup base system version top stack caching general apparent results case best performance dispatch macros defined processor specific way fortunately interpreter writer gforth macros starting point cacao int 
top stack caching evaluate effect top stack caching compiled gforth machines top stack caching requires just defining preprocessor symbol tos compared result base system 
find results fig 

ia processors particular athlon top stack caching provides surprisingly large speedup architecture register starved optimization increases register pressure looking machine code frequently executed vm instructions see additional spill code 
speedup larger expected machine lots registers 
surprise speedup top stack caching alphas particular relatively small benchmarks slowdown 
apparently processors resources process additional loads stores incurred top stack caching apparently additional latencies problem masked parallel processing data vm instruction fetch 
explain slowdowns non monotonic effects instruction issuing inserting instruction cause speedup explanation supported fact benchmarks show slowdown large speedup vice versa 
top stack caching provides performance benefit processors size benefit hard predict 
eliminating stack stores evaluated store elimination optimization disabling vmgen building version gforth redundant stores measuring athlon 
benchmarks sieve bubble profit significantly store elimination vm instructions inner loops profit optimization 
see little difference benchmarks 
athlon performance monitoring counters see larger benchmarks optimization reduces number instructions executed athlon brew brainless small slowdown caused higher number branch mispredictions probably different code placement leads different conflicts btb 
optimization provides minor benefits 
branch prediction evaluated effect different indirect jumps different outcomes vm conditional branches comparing athlon base gforth system version built variant file eliminated uses tail macro 
small benchmarks see speedups tail 
large benchmarks see speedup 
looking performance counter results large benchmarks branch prediction results mixed apparently variation prediction accuracy resulting code placement differences larger prediction accuracy benefits get tail 
see reduction number executed instructions large benchmarks looking machine code see gcc performs additional optimizations tail 
tail gives mixed results branch prediction produces minor additional benefits 
superinstructions cacao int selected superinstructions profiling javac db making superinstructions vm instruction sequences length occured run training programs maximum lengths provided versions cacao superinstructions 
similarly gforth brainless brew training runs memory compiling result training runs produced unique sequences reduced number resulting superinstructions throwing sequences dynamic execution count training run 
shows number superinstructions generated variant 
see nice speedups small benchmarks factor matrix athlon focus larger benchmarks section small benchmarks sensitive presence absence specific superinstructions general indicators performance 
shows superinstructions affects execution time different processors measured brainless superinstructions derived brew results benchmarks similar magnitude speedups varies 
brainless brew db javac 
length number superinstructions generated different training programs different maximum sequence lengths athlon pentium iii ppc ppc 
length speedup cycles instructions cache misses branches mispredictions 
length results brainless superinstructions brew training run 
left speedup various cpus 
right various performance metrics athlon indicate different scaling factors 
displays performance counter results athlon benchmark superinstructions reduce number native instructions bit factor number native branches number mispredicted branches 
number cycles athlon strongly influenced number mispredicted branches misprediction costs cycles instructions mispredicted branch spending majority cycles mispredicted branches explains relatively low number instructions cycle triple issue machine 
branches gforth indirect branches dispatching vm instruc brainless javac db 
length speedup brainless javac db 
length speedup speedup achieved superinstructions consisting simple instructions varying maximal length trained brew db tion responsible high misprediction rate mispredictions caused occurences vm instruction working set superinstructions reduce 
number cache misses low performance effect negligible engines fit athlon cache surprising 
performance counter results help explain differences various processors 
athlon pentium iii btb indirect branch predictors mispredict penalties cycles profit branch prediction improvements see greatest speedups superinstructions 
large cache pentium iii fast cache 
processors predict indirect branches profit mainly reduction indirect branches 
small direct mapped caches may reduce benefit superinstructions 
shows effect superinstructions various large benchmarks 
results jvm benchmarks show slowdowns superinstructions 
explanation slowdowns cache misses uses kb direct mapped cache backed slow cache ns load load latency pointer chasing benchmark 
performance counters digital unix investigate cache misses see fig 
javac db spend significantly time cache misses brainless 
db spend time cache misses 
results explain slowdowns missing speedups 
believe additional cache misses db conflict misses caused different placement vm code vm code smaller superinstructions capacity misses reduced 
see interpreter sizes fig 
interpreters measuring cache misses gforth brew cacao db 
base cacao interpreter engine support functions fits cache misses base version come conflicts support memory constraints prohibited compiling larger interpreters digital unix 
brainless db javac 
length run time gforth brainless gforth brew cacao db cacao javac 
length bytes left time spent cache misses running interpreters trained brew db 
right interpreter engine size supporting functions alpha 
ing functions garbage collection synchronization cache misses javac db threaded code interpreter larger interpreters majority misses threaded code interpreter 
large threaded code interpreters necessarily cause cache thrashing gforth brew max 
superinstruction length times large cache brainless thrash cache running interpreter 
differences may caused locality differences interpreted programs 
investigated different speedup behaviour forth jvm benchmarks caused differences selecting superinstructions gforth cacao selected cacao superinstructions selected gforth superinstructions sequences dynamic executions 
saw improvement slowdowns hardly speedup java benchmarks large difference compared gforth speedups 
interesting compare effect training programs input data perfect training measured run training run see gain improving superinstruction selection see fig 

see training just large program get surprisingly close optimum 
superinstructions provide large optimization potential especially processors btb branch predictors 
related generators producing front compilers interpretive systems yacc code generator generators producing brainless brainless brainless brew brew brainless brew brew 
length speedup speedup achieved athlon superinstructions selected different training runs measured run training run 
back native code compilers burg 
know general tool constructing back interpretive system 
ambitious projects vmgen take description syntax semantics language input produce interpreter language output 
main disadvantage systems restricted certain class languages vmgen flexible combined front long call functions 
closest vmgen generators authors sophisticated vm interpreters main difference generators vmgen extended tested general vm interpreter generator specific project 
scheme system kr uses accumulator stack vm 
vm interpreter specified scheme subset pre scheme compiled code 
generated code similarities vmgen output uses vm instruction scope variables intermediate storage 
input appears similarities described sufficient detail allow detailed comparison interpreter specification macros portrayed pre scheme application separate package 
apart specific language implementation generator differs vmgen performing implicit top stack caching vm uses accumulator support explicit stack caching visible vm level extra push instruction required get values accumulator stack 
interpreter hti pro uses tree vm linearized form derived lcc intermediate representation 
vm interpreter created tree parser generator contain superoperators 
vm instructions specified tree grammar superoperators correspond nontrivial tree patterns 
main difference generator www imm dtu dk works general stack vms corresponding dags represented data flow graphs vmgen input specify dup expressed tree operator 
differences superoperators superinstructions consequences superoperators combine instructions sequence iload isub trees may intervene superinstructions combine vm instructions tree patterns frequent sequence jvm interpreter iload iload 
proebsting reports higher speedups superoperators see superinstructions believe due differences vms differences benchmarks hardware may play role draw value superoperators vs superinstructions 
project allows defining vms fpr 
define new vm instructions terms existing vm instructions starting base primitive instructions superinstructions vmgen 
main differences vmgen vmgen define arbitrary vm instructions terms limited predefined primitives consequence vmgen interpreter build time dynamic allows loading run time 
il low level language writing porting apl interpreters easier retarget il compiler port apl interpreter written assembly language il portable assembly language vmgen interpreters 
il automate tasks vmgen automates 
hand written interpreters usually extensive macros kaffe demonstrates tasks writing interpreters quite repetitive 
advantages vmgen general macro processor users need design macro package vmgen things optimizations typical macro packages 
vmgen performs tasks done easily macro processor vmgen defers tasks macro processor gforth macro processor preprocess vmgen input 
performance enhancing techniques vmgen published earlier threaded code decoding speed bel kli scheduling software pipelining dispatch ert ha stack caching ert ert combining vm instructions pro pr 
new optimizations store optimization section comes generator vmgen human programmer generate stores place tail duplication improve indirect branch prediction section 
interesting works interpreters general dv kra semantic content virtual machine design time space tradeoffs pit various optimizations sc 
code generation libraries vcode eng gnu lightning allow user generate native code fixed register programming interface 
implement programming languages probably offer higher execution speed vmgen interpreters shortcomings lack portability targets supported system fixed interface contrast defining vm tailored language debugging support 
vmgen generator virtual machine vm interpreters 
automates repetitive writing interpreter supports writing highperformance interpreters 
automatically generates code accessing vm instruction operands results dispatching vm instruction tracing vm instruction execution vm code disassembly supporting vm code generation profiling frequent vm instruction sequences aiding selection superinstructions vmgen supports encourages writing high performance interpreters supporting techniques threaded code keeping top stack register speedup scheduling dispatch code fetch vm instruction early prefetching speedup having different instances dispatch code better branch prediction eliminating superfluous stores combining vm instructions superinstructions speedup athlon 
superinstructions interpreters generated vmgen faster competing interpreters slowdown native code compilers usually factor low 
vmgen available www tuwien ac anton vmgen 
acknowledgments referees john aycock manfred provided valuable comments earlier drafts 
ak hassan ait kaci 
wam real tutorial 
warren machine tutorial reconstruction 
mit press 
alfonseca selby wilks 
apl il interpreter generator 
ibm systems journal 
bel james bell 
threaded code 
communications acm 
dew robert 
indirect threaded code 
communications acm june 
dv eddy jan van 
interpretation instruction path 
mit press 
anton ertl david gregg 
behaviour efficient virtual machine interpreters modern architectures 
euro par pages 
springer lncs 
eng dawson engler 
vcode retargetable extensible fast dynamic code generation system 
sigplan conference programming language design implementation pages 
ert anton ertl 
portable forth engine 
conference proceedings mari 
ert anton ertl 
stack caching interpreters 
sigplan conference programming language design implementation pages 
fpr ian fabio riccardi 
dynamically configurable multi language execution platform 
sigops european workshop 
david gregg anton ertl andreas krall 
implementing efficient java interpreter 
high performance computing networking europe pages 
springer lncs 
gr adele goldberg david robson 
smalltalk language implementation 
addison wesley 
ha jan lex 
pipelined java virtual machine interpreters 
proceedings th international conference compiler construction cc 
springer lncs 
jan lex jeroen rik van de 
code compression system pipelined interpreters 
software practice experience september 
kli paul klint 
interpretation techniques 
software practice experience 
kp andreas krall mark probst 
monitors exceptions implement java efficiently 
concurrency practice experience 
kr richard kelsey jonathan rees 
tractable scheme implementation 
lisp symbolic computation 
kra glen krasner editor 
smalltalk bits history words advice 
addison wesley 
ly tim lindholm frank yellin 
java virtual machine specification 
addison wesley reading ma usa second edition 
pay bernd 
ein forth compiler 
dimension september 
pit thomas pittman 
level hybrid interpreter native code execution combined space time efficiency 
symposium interpreters interpretive techniques sigplan pages 
pr ian fabio riccardi 
optimizing direct threaded code selective inlining 
sigplan conference programming language design implementation pages 
pro todd proebsting 
optimizing ansi interpreter superoperators 
principles programming languages popl pages 
theodore romer dennis lee geoffrey voelker alec wolman wayne wong jean baer brian bershad henry levy 
structure performance interpreters 
architectural support programming languages operating systems asplos vii pages 
sc santos costa 
optimising bytecode emulation prolog 
lncs proceedings ppdp pages 
springerverlag september 

