chapter higher order programming florian matthes technical university hamburg hamburg germany persistent tycoon polymorphic summary text provides tycoon open persistent poly morphic programming environment 
tycoon language tl expressive orthogonal naming typing binding concepts required example advanced data intensive applications 
characteristic language mechanisms tl arc class functions modules parametric subtype polymorphism extended fully higher order type system 
tycoon programs statically typed may include explicit dynamic type variables inspected run time 

motivation tycoon system open persistent polymorphic programming environment higher order language concepts designed robust linguistic architectural framework definition integration interoperation generic services represented polymorphically typed libraries 
architecture tycoon system described chapter 
tycoon language tl described activities database application programming see strongly typed high level application programming tl plication programmers implement full functionality data intensive applications require tight controlled interaction objects screen objects main memory objects disk objects wire 
example value screen form may passed parameter transaction stored database transmitted remote log server 
tl supports programming tasks providing uniform generalized naming typing binding concepts specifics underlying object servers gui toolkits programming languages database systems rpc services 
particular tycoon type system statically detects attempt apply inappropriate operation server object server 
seen contrast current practice data intensive applications virtually inter server consistency checking due lack integrated type system model 
generic server integration different fourth generation languages high level application programming tycoon system restricted builtin object types tables forms reports 
virtue tycoon polymorphic tycoon typed communicating objects open environments 
tl tycoon language 
florian matthes higher order type system possible integrate pre existing independently developed generic servers object oriented databases gui rpc communication services strongly typed parametric ty programming environment 
systems developed tl fit smoothly open system architectures 
idea open approach system construction currently pursued system frameworks distributed object models similar expressiveness 
tycoon aims higher system development productivity language framework characteristics improved language orthogonality language entities 
values functions modules types class status 
example possible write tl function receives type argument returns module aggregates set dynamically constructed functions fresh data type 
higher order language concepts particularly helpful repetitive programming tasks individual applications shared reusable library code 
increased type system expressiveness tl combines subtype parametric polymorphism 
furthermore forms polymorphism generalized higher order type operators supporting type definition highly po morphic system libraries 
orthogonal persistence abstraction tl programmers don distinguish local volatile data shared global persistent data 
consequence programmers fully store properties size main memory garbage collection transfer primary secondary store data format conversion nodes heterogeneous networks 
reflective programming support system tasks data intensive ap plications query optimization transaction scheduling gui generation run time reflective programming techniques 
run time linguistic tion denotes ability system inspect parts system query expressions transaction instruction sequences type structures run time dynamically extend modify system outcome inspection 
example tr programming environment exports strongly typed function reflect optimize takes tl function value re invokes tl compiler back function returns optimized version function 
con static code optimizations limited static context single function single module dynamic code optimizations exploit run time information available dynamic context function external function implementations values data types 
detailed discussion rationale tycoon 
readers interested formal definition tl semantics referred text organized follows section gives quick overview tycoon language comparison modern persistent programming languages 
subsequent sections section provide step step tycoon language concepts functional setting values types bindings signatures predefined type value constructors user defined types type operators sub type parametric polymorphism 
section explains concepts inter act imperative concepts tycoon mutable variables destructive assignment sequential execution exception handling 
section discuss alternative approaches structuring large tycoon software systems interfaces modules libraries 
section important system oriented aspects tycoon transparent persistence management bindings external libraries 
higher order persistent polymorphic programming tycoon 
language classification section intended primarily readers familiar state art programming language research interested rough tl language classification 
programming language tl evolved experimental languages quest quest :10.1.1.117.1304
semantic concepts languages supported tl varied syntactic 
tl ad hoc restrictions quest language 
furthermore introduces new language concepts subtyping type operators recursive type operators extensible record values scopes modules interfaces 
syntactic structure module concept tr similar languages modula family modula oberon modula modula add 
regarding semantics tr closely related polymorphic functional languages ml language family 
semantic concepts tr derived language formal basis study modern type systems 
tr intended programming system program ming tasks 
virtue polymorphic type system tl data language 
respect tr resembles lisp development systems commercial object oriented languages smalltalk 
integrated database programming languages ps algol napier see chapter amber quest mentioned tycoon inherits elementary kernel concepts persistence abstraction type complete data struc turing iteration abstraction 
motivated analysis conceptual technological foundations ex database languages see chapter tycoon system pursues idea strictly reduced kernel language supporting naming binding typing pre defined semantic objects variables functions type variables type operators 
hand possible extend language kernel external seman tic objects integers floating point numbers strings arrays relations views files windows generic functions associated objects completely type safe way add vs built 
tr enables programmer different modelling styles 
functional imperative programming supported directly 
due variants object oriented programming style supported tl 
relational logic programming supported directly unification evaluation models declarative approaches deviate strongly functional imperative structures 
tycoon system offers interactive programming environment 
envi ronments known functional systems ml lisp 
distinguishes ty system conventional translation systems example modula add compilers 
due interactive environment ad hoc tr database queries possible addition tl database programming language 
persistence concept enables user perform incremental system development spanning sessions 
time concept tl supports controlled shared data programs users 
quest quantifiers subtypes 
quest quest system extended orthogonal persistence concept florian matthes 
lexical syntactical rules section introduces important lexical syntactical rules tl construction symbols reserved identifiers productions 
symbols character set predefined system partitioned disjoint classes letters digits delimiters printable special symbols non printable formatting characters 
basis classification sequence characters divided atomic symbols numbers identifiers 
tl distinguishes alphanumeric identifiers infix symbols 
alphanumeric identifiers consist character followed sequence characters digits infix symbols composed solely special symbols 
space required alphanumeric identifiers infix symbols appear direct succession 
reserved keywords reserved keywords infix symbols user defined identifiers infix symbols 
reserved keywords written bold face programming examples 
facilitates distinction rest symbols examples italics 
keywords associated types start capital letter keywords lower case characters 
advisable adopt rule convention identifiers improve readability programs 
comments tl comments enclosed 
arbitrary nesting comments possible 
comments may include arbitrary printable non printable characters span lines 
comment 
factoring expressions operators represented infix symbols left associative equal precedence 
parsing type value expressions containing infix symbols controlled curly brackets 
consequently expressions equivalent 
int mul int sub int infix symbols starting colon weaker precedence infix symbols 
operators left associative 
bracketed expressions examples show factoring corresponding expressions brackets 
higher order persistent polymorphic programming tycoon coercion overloading automatic coercions integers real numbers tl 
example type error caused expression 
argument type mismatch builtin 
int expected real checking function argument anonymous symbolic alphanumeric identifiers may overloaded 
reason example necessary different operators infix symbols addition integers real numbers respectively 
int real 
predefined values functions section presents basic semantic rules tl 
naming binding typing contrary traditional programming languages base types constants defined predefined identi base types bool 
constants base types bool 
true bool false defined base types imported ex rom modules standard library 
obey syntax typing evaluation rules user defined types values 
approach give predefined user defined data types equal status language 
order avoid notational disadvantages resulting rom approach base types defined base types bound symbolic identifiers infix symbols respective initial context defined system started 
identifiers appear built system environment including language sections phrases predefined base types predefined 
florian matthes literals enumeration hsts examples values base types int rem char string bool respectively left right 
string true note tl avoids overloading 
purpose negative integer numbers marked prefix 
symbol reserved integer subtraction 

user defined values functions binding user defined identifier semantic object repeated identifier expressions denoting bound object basic concept tl 
furthermore signature assigns static type information form type expression identifier 
signature restricts set possible semantic objects bound identifier 
possible control correct identifiers expressions 
section discussion naming scoping concepts restricted value bindings 
orthogonal extension concepts type bindings section gives rise expressive power tl 
static bindings static value bindings tl defined follows 
evaluating term variable statically bound value 
subsequent identifier expression evaluates bound value 
letx int sequences bindings interpreted sequential bindings tl 
letx identifier second binding refers binding established line example 
order achieve simultaneous binding single bindings connected keyword 
true variable bound value expression 
associated binding expression determined static scoping rules tl 
higher order persistent polymorphic programming tycoon scope local identifiers restricted block keywords see section 
reason identifier bound value denoted global identifier local identifier bound value denoted local identifier bindings described determined basic rules local declarations precedence global declarations identifier expression refers binding identifier 
block tl evaluates value binding 
illustrated example 
true true evaluation blocks yields value true result evaluating block canonical value ok type ok second third example contain called anonymous bindings bindings identifier 
signatures assign static type information bindings ordered sequences pairs consisting identifier type 
signatures bindings established previous example considered illustrative 
int boot int boot int boo empty signature possible declare type bound value binding explicitly 
declaration optional 
type specification omitted inferred compiler expression binding 
int boo true recursive bindings construction recursire cyclic data structures 
tl pointer types necessary purpose 
bindings introduced keyword tee 
examples recursive value bindings section section combination functions data types 
problem uninitialized identifiers avoided completely identifiers introduced bindings furthermore recursive bindings subject static constraints avoid access uninitialized variables 
dynamic bindings dynamic bindings passing parameters functions 
addition simple recursive functions known programming languages tl supports higher order functions polymorphic functions 
simple recursive functions higher order functions sections 
description polymorphic functions postponed section reasons 
matthes simple functions 
functions introduced keyword fun 
tl functions bc defined binding identifier 
function abstraction consists ordered possibly empty list formal parameters signatures expression defining body function 
fun int body function refer identifiers different scopes 
formal parameters introduced signature function global identifiers static scope function identifiers defined locally inside function visible function body 
global fun int function defined function abstraction bound identifier 
sacc fun int add fun rem rem sacc sacc function succ expects parameter type int returns value type int result 
computes successor integer value passed parameter 
second function add adds real numbers 
takes parameters type rem returns value type rem 
third identifier succ bound function denoted succ 
syntax supports abbreviated notation 
succ int add rem type result explicit improving readability program omitted inferred compiler 
succ int int add rem rem infix symbols chosen names functions binary infix operators 
example function concatenating strings string 
concat bound infix symbol string 
concat function bound infix symbol applied different ways standard prefix notation infix notation concat shown example infix symbol prefix notation lead unexpected results factoring rules expressions 
concat higher order persistent polymorphic programming tycoon expression causes syntax error compiler recognizes ex pression form concat nation 
usual problems avoided brackets control parsing expressions 
concat recursire 
tl supports definition recursive functions 
recursive bindings introduced keyword tee purpose 
contrast normal bindings types bound values inferred compiler specified recursive bindings 
wellknown computation factorial function example recursive function binding 
tee fac int fac mentioned tl support overloading operators 
oper ator test doubled equality sign simple equality sign bindings 
polymorphic operator tests simple values numbers booleans equality checks structured values tuples arrays identity equality values tuple array components tested 
mutually recursive functions defined parallel 
tr bindings connected keyword purpose 
parity test illustrative example 
tee bool true odd odd int bool false types 
function types prerequisite definition higher order functions introduced anticipation discussion section 
function type defines signature function value names types formal parameters function result type 
function types introduced keyword lun 
types previously defined functions succ add succ examples 
succ fun int add un real real real succ fun int abbreviating notation supported succ int add real real real higher order 
higher order functions functions accept ing functions parameters returning functions result 
functions twice examples higher order functions 
twice fun fun int int fun int int int fun int int functions written concisely 
tw int ino function twice receives parameters 
parameter function mapping integer value integer value second integer 
function body twice function twice second 
twice succ int tc fu int example result 
ppc returns computes 
le dd dd int int example cn performed single step steps 

predefined value type constructors predefined type constructors tl tuple tuple variants record section 
function types introduced section 
tuple types tuple types resemble records pascal modula structures tuple type labelled cartesian product type 
fields tuple described ordered possibly empty sequence signatures 
signatures may contain anonymous identifiers 
person tuple name string age int tuple int int values arc ordered lists bindings 
peter tuple name peter age paul tuple paul tuple scope field names name age restricted block limited keywords tuple 
components tuples referenced dot notation 
peter 
age int higher order persistent polymorphic programming tycoon rules type compatibility tl conversion anonymous non anonymous field names possible 
conversion takes order fields defined binding account 
person paul name paul string tuple int pair int tl possible include functions tie ds tup es 
combining concept recursive bindings possible capture concept methods known object oriented programming 
examples sections 
variant types tup es variants resemble variant records pascal modula 
tuples tuples variants represent ordered sequences signatures 
address tuple case national street city string zip int case street city state string zip string variants national international example common prefix 
prefix extracted variants placed front 
tuple street city string case national zip int case state string zip string signatures variants empty tuple type variants degenerates enumeration type 
day tuple case mon rue wed thu fri sat sun definition value tuple type variants consists choice variant definition corresponding bindings 
tuple case address street city hamburg zip keyword definition address optional possible anonymous bindings tuples variants 
florian matthes address tuple case address hamburg value type day bc defined follows 
today tuple case mon day projection fields prefix fields variants requires distinct notations 
fields prefix accessed dot notation case simple fields 
address street string fields variants complete case incomplete case analysis case necessary 
case address national fmt int zip international zip complete case analysis avoids unexpected runtime errors ensuring extensions tuple type new variants accompanied corresponding extensions case analysis 
incomplete case analysis form 
case national fmt int zip incomplete case analysis lead runtime errors branch specified situation 
case national fmt int zip national abbreviating notations simple test variants variants arc 
national examples equivalent expressions 
case national true mse case national raise line column national higher order persistent polymorphic programming tycoon variant projection opens scope selected variant 
address national zip int record types contrast types record types represent possibly empty sets non anonymous signatures tl 
names fields different 
person record name string age int record values unordered sets non anonymous bindings 
peter record age name peter tuple values scope field names name age restricted block enclosed record 
fields record accessed dot notation 
peter 
age int contrast tuple values record values extended dynamically bindings losing identity 
keyword extend provided purpose 
process extending record uniqueness field names ensured 
extend peter semester infix operator checks identity values 
peter true bool record value fulfills type specifications see sec 
record name string age int semester int record age int name string semester int record semester int name string age int record name string age int recursive data types defined data structures lists sets trees play central role computing science 
tl provides means definition recursire data types enabling defined data structures 
recursive type definition introduced keyword rec tl 
supertype definition list integer values example 
rec tuple case case cons car int cdr florian matthes expressions show construction empty hst con struction new hst rom existing possibly empty hst appending new element 
tuple case tuple case cons car cdr example shows definition recursive value 
case recursive type value 
tee tuple case cons dynamic data types data intensive programming situations context generated context context share common type information supporting static checking 
situations desirable deer type checking defined points program evaluation 
tl keywords dyn typecase provided purpose 
illustrated example 
auto tuple dyn ok int letx tuple dyn string hello auto string typecase int fmt int string tuple name string name tuple tuple discussed structural equivalence prerequisite dynamic type checking persistent distributed systems 

subtype relationships subtype polymorphism tr signature form considered partial specification 
value bound variable fulfil specification defined type underlying partial order types precise described higher order persistent polymorphic programming tycoon inductively defined subtype relationship 
supertype non parameterized types ok 
represents trivial specification fulfilled values 
example illustrates type ok functions fst snd discard parameters 
type parameter needs just trivial specification 
fst int ok int snd ok int int fst fst true snd snd true int int int int kind polymorphism represented functions fst snd called subtype polymorphism 
subsumption principle dynamic binding formal parameters static type values arbitrary subtype possible 
subtyping predefined types predefined base types fulfil trivial specification int rem fun int int tuple int non trivial subtype relationships form int base types tycoon 
possible define subtypes types tycoon libraries example directory 
directory 
represent syntactically correct path names file system strings 
reverse true 
subtyping tuple types tl subtyping tuple types structural compatibility 
subtype relationships defined tuple types variants tuple types variants tuple type tuple type variants 
tuple type variants subtype tuple type variants signatures prefix signatures student tuple name string age int semester int person tuple name string age int car tuple name string age int machine tuple name string fuel string tuple name string subtype relationships hold student car florian matthes car hand described tycoon subtype relationship restricted systematically explicitly defined subclasses ensuring example car 
person 
holds 
subtype tuple type defined specializing types tuple fields 
example definition student tuple name ok age int semester int implies subtype relationship 
student tl subtype defined repeating explicitly components supertype 
keyword repeat purpose 
definition type student basis type person may look follows 
student tuple repeat person semester int notation signatures expected function signatures 
corresponding construct exists value level 
keyword open supports repetition existing bindings 
value peter defined section example extended specifying semester 
student tuple open peter semester major advantage subtyping fact functions working type accept values arbitrary subtypes type 
subtyping facilitates extension programs particular extension data structures new components 
functions written original type applicable values new type 
values recognized instances old type 
function expecting parameters type works values types student car machine 
boot string 
name name fiat machine tuple name uno fuel peter fiat false boot tuple type variants subtype tuple type variants ordered sequence variant names prefix sequence variant names signatures si variant arc corresponding variant signatures si example relationship tuple case red green blue color tuple case red green blue cyan yellow relationship address section address defined follows higher order persistent polymorphic programming tycoon address tuple case street city string zip int case street city state string zip string case unknown tuple type variants having signatures subtype tuple type variants signatures tuple signatures variant relationship holds tuple street city string zip int subtyping record types case tuple types subtypes record types constructed specialization types existing components extension new components 
additional fact signatures record types ordered taken account subtyping rules 
record type signatures subtype record type signatures signatures contain subset signatures person record name string age int student record name string semester int employee record string salary real tutor record name string age semester int salary real types subtype relationships hold tutor enabling application functions defined arguments types person student employee values type tutor 
furthermore possible construct heterogeneous data structures consisting example values types person tutor 
subtyping hierarchies record types restricted tree structures case tuple types 
directed acyclic graphs possible making representation multiple inheritance hierarchies possible 
subtyping function types interpretation types signatures partial specifications subtypes specification refinements implies known contravariance rule subtyping function types 
rule function type signatures formal parameters result type subtype function type signatures result type iff natures words function specialization function assumption preconditions hold postconditions fulfil postconditions preconditions restrictive preconditions 
example assuming relationship student result types function types covariance relationship 
matthes fun person fun student function types fun person ok fun student ok relationship parameters contravariant 

parametric polymorphism type system tl supports kinds polymorphism subtype polymorphism parametric polymorphism 
subtype polymorphism previous section 
parametric polymorphism topic section 
type parameters function type definitions possible 
function definitions parameters describe polymorphic functions type parameters type definitions results type operators 
type operators functions mapping types types 
introduce parametrization type declarations 
type restricted subtype type kind polymorphism called bounded parametric polymorphism 
polymorphic functions function polymorphic generic extending signature type parameters 
type parameters type expressions function applied 
polymorphic identity function simple example polymorphic func tion 
id function ca led type int value type actual parameters 
id nt int id string peter peter string specification type argument omitted cases inferred system value passed parameter 
id int id peter peter string instantiation type parameters restricted base types 
arbitrary user defined types type person value peter chosen parameter polymorphic function higher order persistent polymorphic programming tycoon id peter tuple name peter age person parametric polymorphism possible write functions working uniformly arbitrary types 
polymorphic functions describe behaviour 
separate functions considered parameter type necessary purpose languages modula 
power tl results possibility combining concepts polymorphic higher order functions 
illustrated polymorphic sorting function 
pure sorting process permutation elements type independent 
described polymorphic function 
hand comparison elements sorting process type dependent 
task solved passing function compares elements parameter polymorphic sorting function 
signature polymorphic function sorting arrays arbitrary element type follows 
sort order sort array specific type sufficient write function element comparison array 
sorting persons ascending age considered example 
older person boot age age call function sort sorts array persons age 
sort person older type parameter omitted 
sort older examples polymorphic functions sections 
bounded parametric polymorphism bounded parametric polymorphism restricted form parametric polymorphism introduced polymorphic functions specifying type bound formal type parameter signature 
subtypes type passed parameters functions 
employing subtype polymorphism function comparing component age values arbitrary subtype type person defined way 
person person pl age 
age pl peter student tuple name peter age semester paul student tuple name paul age semester peter paul tuple name paul age person florian matthes considering function result displayed system seen attribute semester paul missing 
consequence fact type information lost compile time 
order avoid loss attributes subtypes defined polymorphic function 
pl age 
age pl peter pau tuple name paul age semester student result integrating type information function definition attributes arc taken account 
introducing specification function polymorphic contrast unrestricted parametric polymorphism polymorphism restricted subtypes type person 
type variable intended relationship type formal parameters type result function 
type operators polymorphic functions support description type independent behaviour 
similarly type independent patterns type level lead generic type expressions form type operators bc concrete types 
simple type operators 
simple example type operator identity function type level corresponding polymorphic identity function 
id oper similar function definition abbreviated notation possible 
id operator id maps type passed parameter 
int boot practical application type operators description optional values 
opt tuple case case vat syntax application type operator equivalent syntax function application 
opt person id opt id person higher order persistent polymorphic programming tycoon identifiers bound type operators infix notation 
infix operators type level left associative precedence 
classical binary type operators functional programming languages introduced tl way 
preceding examples restricted order type operators 
tl supports definition higher order type operators 
higher order type operators example type operators accepting type operator parameter applying different types body 
examples type operators generating type operators result non parametrised types passed parameters 
coding case selections type level considered illustrative example 
boolean true cona cond true int string cond int string peter recursire type opera ors 
addition recursive types tl supports recursive type operators 
type operator list maps type type hst elements type purpose type parameter introduced definition hsts section 
rec list ok tuple case nil case cons car cdr list corresponding hst operations implemented polymorphic functions 
new tuple case nil list cons tuple case cons list head tail polymorphic functions new generates empty lists elements arbitrary specific type 
elements added list function cons 
contrast commercial programming languages generic list set tree types polymorphic operations types defined reducing number functions implemented 
concepts polymorphic functions type operators complement 
generic code bc description structures behaviour 
florian matthes data types data type adt consists data type set operations defined data type 
name type names signatures operations visible programs adt 
implementation type operations hidden adt 
operations provided adt possible legal ones adt 
protects values adt undesired manipulations 
implementation hidden changed locally invalidating programs adt 
different implementations exist adt implementations exchanged dynamically 
general functional stack example 
stack declared employing polymorphic data type 
stack tuple ne empty push pop top implementation interface module list 
stack tuple new empty push list cons element stack pop top example defined type operator operations new empty push pop top implemented polymorphic functions 
stacks arbitrary data types generated 
adts concept type signatures tuple types 
leads concept semi data types tl 
example signature type operator adt stack modified order exhibit information implementation adt 
stack tuple ei list module standard implementing polymorphic hsts associated operations 
higher order persistent polymorphic programming tycoon stack tuple users adt stack apply operations expect values type list 
values type 
addition defined stack 
hand value type list 
incompatible defined 
tl subsignature relationship signatures adts defined stack tuple signature local type binding visible globally 
stack tuple list 
type definitions particularly useful interfaces modules program ming libraries see section 

imperative programming discussions previous sections restricted functional concepts underlying language tl 
imperative programming features described section 
imperative programming mutable variables global possibly persistent store 
flow control operations allocation inspection destructive update objects store determined constructs sequences loops 
mutable variables binding value identifier construct equivalent definition constant update value bound identifier possible 
binding existing identifier new value employing construct establishes new constant 
tl bindings identifiers mutable variables marked keyword vat 
subsequently existing mutable variable updated new values employing destructive assignment 
vat vat xy int ok ok xy florian matthes int int ok ok xy int int anonymous variables inside tuple values keyword vat precedes value initialize variable 
tuple var text var destructive assignment defined function signa ture 
signature function defines assignment evaluates trivial value ok type ok case empty block 
note infix symbol keyword 
bound locally user defined polymorphic function 
tl realizes parameter passing mechanisms functions concept value parameters call value section concept variable parameters call 
concept illustrated example 
swap tmp tmp letvar swap int ab int int applied function swap values mutable variables formal parameters signature 
return function values mutable variables swapped 
concept higher order functions section supports dynamic generation encapsulated state variables shared functions shared variables 
example variable state updated inspected respectively defined functions 
var state tuple reset ok state ok state state int state cntr cntr 
ok ok int int higher order persistent polymorphic programming tycoon mutable function bindings enable programmer override functions 
vat int int un int int subtyping rules mutable bindings details interaction subtyping rules destructive assignment important type safety polymorphic programming languages 
tl follows example language quest loosely related concepts disallows application subsumption rule mutable variables 
reason fun person person ok un student student ok tuple int tuple ok holds subtyping relationships hold tl fun vat person person ok tuple vat int tuple vat ok concept bounded parametric polymorphism supported tl definition type safe polymorphic function update working uniformly arbitrary subtypes type person possible 
update person var possible tl type mutable variable aggregate value 
consequence liberal subtyping rules applied read access value variables tuple var int tuple int tuple ok control structures addition sequences tl offers control structures conditional expressions kinds loops structured exception handling supporting flexible imperative programming style 
sake completeness concepts introduced previous sections mentioned 
sequences 
sequence describes sequential execution expressions 
mentioned section expressions enclosed keywords order form block 
type sequence determined type expression binding block 
text int conditional expressions 
simplest form conditional expres sion described expression tl 
result types ll branches branch bc compatible 
elsif conditions bc conjoined operators tl 
precedence arc evaluated left right expression equivalent complex expression constructs conditional expressions arc provided tl scc sections 
day boo case mon wed thu ri msc dyn ok string typecase int mt int higher order persistent polymorphic programming tycoon string loops 
loops enclose sequences expressions purpose iteration 
general kind loop introduced keyword loop 
result type loops kind ok loop exit furthermore special forms loops enumerating loops 
function computing greatest common divisor integers considered example loop 
gcd tat tat var vn var vm vn vm vn vm vn vn vm vn vn versions enumerating loops distinguished tl counting upwards upto counting downwards downto 
vat downto tnt note necessary declare loop variable local scope 
section example loop counting upwards 
exception handling 
exception important struc turing facility 
tl integrated smoothly type system 
exceptional situations handled caused partially defined functions example int div division zero overflow partially represented domain 
furthermore projection variants described section raise exceptions tl exception returns exception package containing string supports identification exception outermost level 
exception tat error exception occurs inside composite expression evaluation aborted exception package propagated 
florian matthes int int try int example propagation exception stopped 
case construct result types blocks match 
addition standard exceptions tl supports user defined exceptions 
definition exception includes identifier exception optionally signature exception arguments 
definition introduced keyword exception 
exception cri type exception defines signature identity 
exception int raise expression returns exception result identity exception 
depending exception signature cn bindings 
withdraw vat count int mount inq mount raise mount exception propagate nested expressions dynamic hierarchy exception block enclosed try nd mn program 
try print string succeed exc print string unexpected exception occurred similar case expressions exc try construct cn bindings exception type wy exception cn propagated refusing 
example lso shows exceptions functions exported re bound exported user define exceptions 
try int int int error print string division zero types tl terminating computations 
reson arbitrary type cn terms containing raise exit see section higher order persistent polymorphic programming tycoon raise int int string raise int string fact reflected type rules raise nok nok exit nok nok denotes subtype non parametrised types tl nok property type nok frequently definition polymorphic null elements 
rec tuple empty boo get nok rest exception empty stream tuple empty bool true get nok raise rest raise arrays array indexing array ordered possibly empty sequence anonymous bindings mutable variables common supertype indexed non negative integers 
size array fixed statically generated 
size modified dynamically elements array updated dynamically destructive assignments 
check index bounds performed runtime 
tl array types defined constructor array array values initialized enumerating elements inside array block 
elements array accessed indexing 
indices expressions type int enclosed square brackets 
array int array loop possible define example summation function accepting arrays arbitrary size 
sum art array int int var result upto extent art result result art result examples function sum illustrating notation functions arrays tl 
sum array sum matthes 
multi paradigm programming tycoon design tycoon system support generic naming binding typing providing environment open services 
tl support programming styles differ substantially scc 
illustrated hcrc concepts data types object oriented encapsulation 
different programming styles concepts arc supported language constructs tl primitives naming binding typing 
order implement concept data types primitives tl bc combined different ways 
possible aggregate opaque type functions working type 
approach bc implemented purely functionally state resulting variants 
third variant aggregates methods hidden state 
different arc called functional encapsulation imperative encapsulation method encapsulation 
generic stack implementation compare different 
provides type operator maps element type stack tuple type 
cases tuple type aggregates opaque stack type common stack operations empty push pop top function new creation new empty stacks 
third type aggregates stack operations 
represents type stack 
function new bc defined outside type signature 
functional encapsulation 
functional modified stack re turned update operations 
result type functions opaque type tuple empty stack boo push element stack pop stack top stack data type implemented parametrised variable 
provides tuple value consisting definition representation type functions type 
generic service list providing hst type operations type functional implementation 
ok tuple ok list 
new list new empty stack boo list empty stack comparable implementation types modula module concept language 
higher order persistent polymorphic programming tycoon new stack elements type int containing element created function calls intstack int intstack push intstack 
imperative update operations change state stack passed parameter side effects 
contrast solution stacks returned function results 
reason result type operations ok le ok ple ok new empty bool push element ok pop ok top representation type implementation defined tuple type mutable component 
update operations re implemented 
le ok le ok ple vat st le new le vat st new le empty bool st empty 
push element stack ok stk st cons element stk 
leg pop stack stack st ta stack leg top stk st 
case new stack integer created function cs le le new push 
third encapsulation technique binds functions shared mutable 
function signatures defined tuple type 
type represents type stack object 
le ok ple empty bod push element ok pop ok top florian matthes implementation stack functions provided new function bc create objects type 
implementation methods arc components objects 
implementation framework method overwriting subtype objects aso bc scc 
reason encapsulation method called object oriented 
avoids opaque type input parameters type 
ok var state tuple empty bool list empty state push clement ok state list cons clement state ok state list 
tail state topo list head state variant creation integer stack element looks follows int push 
programming large function abstraction modularization important structuring modern programming languages 
large programs split interfaces modules tl 
possible group interfaces modules libraries 
structuring mechanisms introduce new concepts naming bind ing typing 
just deliberately restrict existing concepts tl 
modules interfaces interfaces define signatures exported functions types type 
interfaces viewed named tuple types containing explicitly imported modules bool interfaces visible global scope 
interface list import export nok error exception nil cons empty car cdr operations expecting input parameter opaque type lead recursive type definitions implementation style 
higher order persistent polymorphic programming tycoon interfaces include type bindings 
definition types visible users interface 
types imported modules name interface name module employed qualifying identifiers 
module defines tuple value aggregating bindings interface 
tl arbitrary number modules exist single interface 
module list import boo export rec tuple case case cons hd tl nok error exception empty list tuple case cons tuple case cons hd tl cons empty car try cons hal raise error cdr try cons 
tl raise error type bindings established interface repeated module 
modules interfaces class objects language 
bound identifiers passed parameters functions 
modules interfaces imported modules interfaces employing import clause 
library unique interface assigned module name 
interfaces modules definable top level interactive programming environment 
definition implicitly generates persistent data structures describing types interfaces values modules respectively 
importing module components referenced dot notation 
module main import list print export list cons list nil list 
list nil list empty print int list car libraries rapidly growing number modules real systems necessity tools supporting consistent system restructuring persistent systems necessary organize modules interfaces libraries suggests library concept language tl 
library defines scope names local modules interfaces supports definition subsystems encapsulating hidden modules interfaces 
definition standard library simple example 
library interface bool int char rem module boot boot int int char char real real interface list module list list order names modules listed matters 
module import modules declared module library boo import list 
consequence cyclic dependencies ruled 
modules standard library introduced previous example imported library 
library import list list iter iter interface set bag assoc dictionary module set set set module bag bag assoc assoc dictionary dictionary hide varlist varlist purpose libraries defined order parts enclosing library 
library root library interface test module test test example library illustrates library concept ti 
modules bc hidden library employing hide clause 
furthermore possible specify different modules single interface set 
tl supports hierarchic library structures names modules accs libraries inside library bc unique 
components defined hidden 
higher order persistent polymorphic programming tycoon 
persistence garbage collection tycoon difference persistent temporary data 
object persistent 
persistence defined reachability linked library module local name space user top level 
persistence concept works values functions dynamic type bindings 
consistent states object store marked explicitly object store 
module store provides function stabilise purpose 
call function stabilises actual state object store 
import store store stabilise operation store stabilise generates checkpoint 
user quits session command exit system crash occurs changes objects persistent store performed checkpoint undone rollback 
session object store state checkpoint 
furthermore possible rollback explicitly state checkpoint leaving system 
accomplished function restart mso exported module store 
effect functions stabilise restart illustrated example 
import store list vat list nil list cons list cons store stabilise object store list containing elements stabilised list cons store restart rollback checkpoint insertion list car objects longer reachable automatically deleted object store garbage collector 

external libraries tycoon provides bidirectional programming interface tl features seamless integration languages function paradigms 
external functions integrated tl ordinary function values 
tl functions wrapped way possible directly function pointers 
function calls tycoon external libraries tycoon provides generic mechanism system functionality implemented external languages 
binding tl identifiers external function values achieved predefined function bind 
function signature florian matthes bind function parameters bind function meaning function describes type resulting tl function 
form lun 
library parameter string identifies file contains required external function 
full path name dynamic string result functions exported module see table belonging tycoon 
description library identifies core tycoon runtime system identifies standard library identifies dynamically bound libraries identifies statically bound label parameter string contains original source text name function 
format parameter string specifies assumed parameter format function 
single character string corresponds parameter 
specifies conversions tagged untagged data representations happen call 
parameter order left right function result type 
character mandatory 
table contains set characters denote parameter formats 
format tl type type description int long integer number real double floating point number char char ascii character bool long boolean value see text string char zero terminated string ok void return value word 
void bit word predefined type boolean values boolean tl values converted long values follows 
true false value produces tl boolean values true alse format character string parameter call enclosed automatic fix operations argument 
result fix operation main memory pointer passed refers valid string tycoon strings represented zero termination 
shared library referenced times path exactly 
dynamic linker loads instances shared object 
means consuming process memory necessary leads subtle bugs global variables defined multiple times process 
higher order persistent polymorphic programming tycoon return value position format character causes strings returned copied newly created store objects copy 
suppose usr lib contains function example takes string argument returns bit integer number 
example assumed match declaration extern long example char appropriate binding example tl ccm example bind un string int usr lib example si value ccm example type un string int 
function follows 
result int ccm example favorite string note external bindings persistent portable host architectures 
example value transferred dynamic 
extern intern binding re established automatically 
calls external libraries tycoon programming interface tl bidirectional 
possible call functions tl call back tl 
order minimize programming effort callbacks side desirable tl functions appear ordinary function pointers 
indispensable situations external software component requires callbacks changed 
module exports type 
represents function pointers refer callbacks 
creation function values type 
signature new function value argument function new function restriction checked 
function signature mirrored format string specifies arguments resulting callback converted tl values 
single character string corresponds parameter 
parameter order left right function result type character 
mandatory 
format characters shown table section 
format character parameter string argument copied newly created store object copy 
case return value string copied chunk memory allocated 
parameter passing semantics copy apply strings 
format character specifies function result value ok irrespective actual value returned parameters format code tl type equivalent word 
instance word 
handle 
particular callbacks conform word 
handle 
simple example follows florian matthes import mt intr rem string fmt int fmt rem new test bind fun int 
ok example test test resulting console output pi ok assuming corresponding program example 
looks include void test long char message long double printf pi sn message callbacks bc address spaces arc control tycoon system general way determine temporal extent automatically 
callbacks persistent 
callbacks occupy memory resources released explicitly free callback invalid 
subsequent usage cause strange system behaviour crashes 
attentive readers may noticed problems example manner result string message get allocated side passed pr ntf charge releasing memory done 
current solution character return value position causes allocation appropriate memory block calling 
block released programmer call free 
program example written include include void test long char message long double char message printf pi sn fee higher order persistent polymorphic programming tycoon research supported esprit basic research project fide 
tycoon system described developed andreas bernd florian matthes rainer 
section text written bernd developed tycoon external language bindings 
author claudia gerald schr der andreas dominic careful reviewing numerous hints helped improve presentation material 

atkinson 
types persistence database program ming languages 
acm computing surveys june 

atkinson chisholm cockshott 
ps algol algol persistent heap 
acm notices july 

bobrow de michiel gabriel keene kiczales moon 
common lisp object system specification 
acm notices september 

cardelli 
amber 
combinators functional programming languages volume lecture notes computer science 
springer verlag 

cardelli 
typeful programming 
technical report digital equipment systems research center palo alto california may 

cardelli 
quest language system tracking draft 
technical report digital equipment systems research center palo alto nia 
shipped part quest system distribution 

cardelli martini mitchell scedrov 
extension system subtyping 
ito meyer editors theoretical aspects computer software tacs lecture notes computer science pages 
springer verlag 

field harrison 
functional programming 
addison wesley publishing 

goldberg robson 
smalltalk language implementation 
addison wesley publishing 

hudak 
conception evolution application functional programming languages 
acm computing surveys september 

programming language ada manual 
technical report mil std ansi 

iso iec jtc sc wg 
interim version dth working draft modula standard 

kernighan ritchie 
programming language 
prentice hall englewood cliffs new jersey 

matthes 
und 
springer verlag 
german 

matthes schmidt 
object stores servers persistent programming environments quest experience 
fide technical report series fide fide project coordinator department computing sci ences university glasgow glasgow qq july 

matthes schmidt 
database application systems types kinds open invitations 
proceedings east west shop generation database technology volume lecture notes computer science april 
appeared tr fide 
florian matthes 
matthes schmidt 
definition tycoon language tl preliminary report 
informatik fbi hh fachbereich universitt hamburg germany november 

matthes schmidt 
system construction tycoon environment architectures interfaces gateways 
spies editor proceedings euro arch congress pages 
springer verlag october 

mauny 
functional programming caml 
technical report inria domaine de voluceau rocquencourt le chesnay cedex france ber 

minker 
foundations deductive databases logic programming 
morgan kaufmann publishers 


language processors object stores interface design implementation 
master thesis fachbereich informatik johann wolfgang universitt frankfurt germany november 
german 

nelson editor 
programming modula series innovative technology 
prentice hall englewood cliffs new jersey 

levin wick 
extending modula building large integrated systems 
technical report digital equipment systems research center palo alto california january 

schmidt matthes 
language technology post relational data systems 
editor database os volume lecture notes computer science pages november 

stemple stanton sheard morrison kirby fegaras cooper connor atkinson 
type safe linguistic reflection generator technology 
research report cs university st andrews department computing science july 

wirth 
programming language oberon 
technical report department informatik eth switzerland 
