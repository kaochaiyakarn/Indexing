esterel synchronous programming language design implementation ard berry georges gonthier ecole nationale sup rieure des mines de paris centre de place sophie sophia france institut national de recherche route des lucioles en informatique automatique sophia antipolis inria france research funded french coordinated research program 
esterel programming language oldest presently developed member novel family synchronous languages includes lustre signal languages statecharts formalism 
languages specifically designed program reactive systems variety computerized systems includes real time systems kinds control automata 
mathematical semantics esterel developed language implementation esterel simply physical realization semantics 
presents language concepts constructs mathematical semantics esterel implementations distribution 
see complete manuals short esterel programming style 

reactive systems programs computer applications involve programs maintain permanent interaction environment reacting inputs coming environment sending outputs 
follow harel pnueli call reactive programs call system main component reactive program reactive system 
real time process controllers signal processing units digital watches video games typical examples reactive systems 
operating system drivers mouse keyboard interface drivers menubar scrollbar drivers communication protocol emitters receivers examples reactive programs embedded complex systems 
notice input driven character reactive programs 
convenient consider reactive programs composed layers interface environment charge input reception output production 
handles interrupts reads sensors activates effectors transforms external physical events internal logical ones conversely 
reactive kernel contains logic system 
handles logical inputs outputs 
decides computations outputs generated reacting inputs 
data handling layer performs classical computations requested reactive kernel 
rest shall concerned reactive kernels constitute central difficult part reactive systems 
fact esterel full fledged programming language program generator program reactive kernels way yacc program parsers grammars 
interface data handling specified host language 

deterministic reactive programs determinism important characteristic reactive programs 
deterministic reactive program produces identical output sequences fed identical input sequences 
examples deterministic physical time considered input 
importance determinism overestimated deterministic systems order magnitude simpler specify debug analyze non deterministic ones 
purely sequential systems obviously deterministic 
determinism ot mean sequentiality 
reactive systems decomposed deterministic subsystems cooperate deterministic way 
example typical digital wristwatch contains stopwatch alarm naturally cooperate deterministically 
deterministic concurrency key modular development reactive programs shall see supported synchronous languages esterel 
complex reactive systems involve subsystems running concurrently different pro cessors communicating asynchronous links distributed robot arm controller 
systems longer globally deterministic 
think wise isolate deterministic reactive subsystems specific techniques 
extend hoare communicating sequential processes approach general asynchronously communicating deterministic reactive systems approach 

current tools reactive programming presenting esterel briefly review tools currently reactive programming automata called state program relatively small reactive kernels typically protocols controllers 
interface part realized operating system facilities 
data handling done calling routines written conventional languages 
automata obviously yield excellent run time efficiency 
mathematically known 
non trivial correctness proofs performed automatic temporal logic formula checkers emc mec automata observation systems auto 
human design maintenance automata turns difficult error prone 
nontrivial automata difficult draw impossible understand drawn 
small changes specifications involve deep changes automata 
run time actions duplicated transitions increasing chance action 
automata purely sequential support concurrency combining concurrent automata single automaton easy task 
petri net inspired tools widely programmable controllers 
run specific machines easily communicate conventional computers 
include crude concurrency primitives support proper hierarchical development 
interface data handling facilities support simple data types boolean integers reals 
programming debugging tools poor 
tasks running real time operating system widely 
provide kind concurrency splitting complex system simpler communicating tasks automata 
inter task communication done sharing memory known errorprone 
system communication primitives generally low level differ system yielding ad hoc highly non portable programs 
internal program behavior non deterministic applications wants treat 
task handling incurs run time overhead 
execution times hard control 
generic simulation debugging tools 
ada occam elaborate 
naturally permit hierarchical modular program development 
tasking mechanism communication primitives defined language level portable 
provide user interface data manipulation facilities allowing program single language layers defined section 
debugging environments exist exist 
classical concurrent languages non deterministic 
semantics time handling primitives somewhat vague 
execution overhead important execution times unpredictable 
quite amazingly available techniques force user choose determinism concurrency base concurrency models processes non deterministically compete computing resources 
leads problems really unnatural programming reactive systems reasoning programs reactions compete 
new inputs arrive reaction actions communications charge performing current reaction compete actions communications charge starting new reaction 
rule telling signal sent process reach destination systematic way telling reaction complete 
practical solution guarantee atomicity reaction 
generally supported systems languages easy hand 
temporal primitives watchdogs task seconds tentative meanings forces accurately executed 
usually play crucial role real time process control generally adds priority systems improve user confidence time manipulations 
additions burden programs completely rigorous 
subprocess perception system 
guaranteed distinct subprocesses perceive environment 
instance single sensor read concurrent processes single reaction probably return different values read operations done different times 

synchrony hypothesis problems disappear adopts reaction assumed atomic possible sense 
synchrony amounts saying underlying execution machine takes time execute operations involved instruction sequencing process handling inter process communication basic data handling additions 
take time understood strong sense 
reaction takes time respect tte remains invariant 
second subprocess takes time respect ay subprocess subprocesses react instantly 
synchronous languages inter process communication done processes share vision environment 
statements take time ad riley say temporal statements mea exactly riley say 
instance statement await millisecond lasts exactly milliseconds statement millisecond emit second means second signal sent exactly millisecond asynchronous formalism second synchronous millisecond 
time taken statement need measured predefined universal time unit 
write exact statements millimeter emit meter synchrony certainly natural user point view user watch worry internal reaction times long perceives watch reacts instantly commands 
synchrony natural programmer point view allows reconcile concurrency determinism write simpler rigorous programs reason synchronous systems compose logic system implementation dependent features reaction times 
course wonder realistic hypothesis implementor point view 
turns synchronous programs efficiently compiled automata yielding excellent run time efficiency predictability 
performance carefully hand written code 
obtained automata automatically implemented classical programming language achieving object code portability 
input automata verification systems 
stress esterel yielding small efficient object code simply idealized specification language forces user rewrite program specification finished 
notice synchrony hypotheses classical physics instantaneous body interaction basis newtonian mechanics instantaneous propagation electricity basis laws 
broad application range reasoning world simpler exact non deterministic models quantum mechanics 
vlsi circuits rely similar weaker syn hypothesis reactions take oe clock cycle matter complex inside sml reactive language hypothesis 
kind half way synchrony accurately reflects circuits 
belief lacks compositionality properties basis general reactive programming language 

esterel imperative programming language mentioned languages formalisms fully adopted synchrony hypothesis 
roughly power differ programming style 
lustre signal declarative data flow languages kahn mac queen style 
statecharts hierarchical presentation automata graphical structures named support concurrency communication 
esterel adopts classical imperative style 
esterel statements handle classical assignable variables local concurrent statements shared communicate environment concurrent processes 
signal carries status presence absence reaction carry value arbitrary type 
law signals instantaneous broadcasting reaction statements program see status value signal 
events statements react composed possibly simultaneous occurrences signals 
esterel statements fall classes standard imperative statements assignment signal emission sequencing conditional loop trap exit exception block definition explicit concurrency 
statements supposed executed infinitely fast machine null statement time 
temporal statements triggers await event watchdogs watching event temporal loops loop event 
seen milliseconds millimeters temporal primitives applied signal signal thought defining independent time scale 
style promote esterel consists independent time scales 
favors primitives watchdogs define long body executed nesting primitives 
typical esterel statement looks step emit jump watching meter exactly means jump step meters 
step statement forever killed meter enclosing watching statement statement terminate 
small example esterel programming section 
elaborate examples 
esterel modules module interface declarations section 
esterel statements steps 
set esterel statements section intuitive semantics notion duration richer set ai esterel statements section 
show accurately expand plain esterel statements basic esterel 

mathematical semantics esterel intuitive semantics section turned formal globally defines output sequence program function timed input sequence 
denotational semantics detailed useless compiling algorithms 
compute billiard ball trajectories quantum mechanics 
detail mathematical semantics plotkin style rewrite rules behavioral semantics computational semantics 
input program determine output new program suited treat remaining inputs 
global temporal treatment statements replaced local computation reaction 
behavior program input sequence computed step step fashion 
behavioral semantics section 
defines globally reaction 
electrical laws values solutions fixpoint equations express sharing law determine instantaneous information exchanges concurrent statements 
want language deterministic require solutions exist unique 
equations involve non monotonic operators negative tests signal presence 
immediate way solving knowing unique solutions exist 
exhibit section kinds paradoxical programs close electronic analogues 
example show program mean emit signal signal electronic analogue gate output plugged input 
show program mean current integer value signal satisfies electronic analogue positive feedback obtained plugging output amplifier input 
nonsense programs equations solution 
exhibit programs semantic equations solutions 
section computational semantics programs 
defining behaviors global way compute results sequences actions execution machine 
signals implemented shared memory read write discipline enforce sharing law signal read longer written apparently simpler disciplines fail reject incorrect programs 
calculus potentials allows compute action sequences satisfy new law detect sequences exist 
state main theorem correct action sequences exist terminate yield results technical terms computational semantics church rosser strong normalization properties furthermore results exactly defined behavioral semantics 
theorem establishes deterministic character correct reactions 

rom esterel programs automata computational semantics programs efficiently implemented serve basis esterel interpreter 
interpreter fast actual real time applications 
step compile esterel programs sequential automata 
purpose section 
variant brzozowski derivative algorithm originally designed transform regular expressions automata :10.1.1.98.4378
idea formally iterate computational semantic calculations building graph nodes esterel terms arcs bear action sequences 
starting node bearing initial program compute possible reactions iteratively 
time new reaction computed target esterel term compared previously computed terms 
process easily shown terminate 
compiling fast esterel system original esterel language kernel reactive language described 
instance digital wristwatch described compiles seconds sun yielding state automaton involving actions 
automaton easily translated lisp ada generally suitable host language 
final machine code occupy bytes memory fast predictable reaction times comparable hand coded automata 
perform behavior analysis proofs automaton input mentioned automata verification systems emc auto mec 
translation automata justifies synchrony hypothesis 
instantaneous run time reactions fast 
microstep sequences contain actions done run time 
process handling synchronization done compile time produce actions 
clearly best way infinitely fast 
far code size concerned produced automata turn minimal cases know exactly 
asynchronous formalisms automata explosion rule 
programs yield unreasonably big automata esterel system gives way replace normal single automaton cascade small automata behave equivalently 
see details 

esterel module structure global declarations basic plain esterel programming unit module 
declaration part body ends period module declaration part body module name declaration part declares external objects module data objects implemented data handling layer signals sensors define reactive interface 
declarations inter dependent signals sensors carry values types declared data declarations 
objects declared 
declarations similar basic plain esterel restrictions apply interface signals basic esterel 
body executable statement written restricted instruction set basic esterel user friendly instruction set plain esterel 
instruction sets detailed sections 

data declarations data declarations declare types constants functions procedures manipulate data 
esterel primitive types described compound type constructors record array 
complex data handling done level data types manipulated ab functions procedures known names implemented host language 
see connecting esterel declarations actual definitions host languages 

type declarations basic esterel primitive types integer boolean constants true false triv unique constant called triv 
types necessary translate plain esterel basic esterel triv turn plain esterel pure signals basic esterel valued signals type triv see 
user convenience plain esterel defines basic types string float classical syntax string float literals 
user declare types listing type keyword type double time 
constant declarations declare constants predefined types constant measure number integer pi double noon time course types declared 
values host language 

function declarations functions declared usual function qrt double double equal time time time boolean lexical aspects esterel classical keywords lower case reserved write identifiers upper case compulsory 
functions assumed free side effects 
implementation written host language 

procedure declarations procedures argument lists procedure call list contains variables passed subject side effects var parameters pascal inout parameters ada second list contains expressions passed value val parameters pascal parameters ada 
declaration argument types declared 
example add place number seconds time declare procedure increment time seconds time integer 
interface declarations declare seal ors constitute module reactive interface sensor degenerate kind signal available plain esterel 
declare restrict possible input events important compiling programs 
signals instantaneous ticks interrupts serves temporal statements described section 
clock pulses button message arrivals typical examples ticks 
signal persistent value type accessed time esterel programs expression 
example value message signal contents message 
relation ticks values assumed hold input signals value signal change tick occurs case new value instantly replaces old value lost 
message example message value change new message received 
program driven message ticks guaranteed correctly treat messages 
fundamental relation ticks values automatically hold output local signals see sharing law section 
plain esterel special declaration passive external devices yield values demand generate ticks 
value access operation available sensors 

basic esterel interface declarations basic esterel kinds interface signals input signals output signals 
input signals come environment emitted internally basic esterel 
declared form input type conversely output signals emitted environment module emit statement emit exp emits signal value expression exp control transmission instantaneous esterel emitters emit signal time different values emit emit esterel parallel operator 
call phenomenon collisions occur define actual value signal 
milner associate associative commutative function comb signal emitters emits values actual value output signal declaration form output combine type comb type comb declared comb declared function comb type type type useful combination functions 
ethernet local networks signal broadcasting physically realized cable 
special value nak represents collision messages 
sets comb nak 

request handling mechanism processes request resource simultaneously say broadcasting name 
natural choice take result set names 
appropriate combination operation set union 

digital watch programmed stopwatch alarm operate 
beeps second stopwatch beeps twice second alarm beeps times second 
units beep resulting number beeps second obtained adding individual numbers 
beeps second occur units beep 
simply define beep signal carries integer representing required number beeps choose integer addition comb function 

plain esterel interface declarations practice uses pure control signals values meaningless second meter basic esterel declare signals type triv 
plain esterel simply omit type declaration writing input second meter output alarm may know collisions take place signal tends default case 
combination function omitted output speed float esterel compiler checks collisions appear 
basic esterel establishes sharp distinction input output signals 
restriction relaxed plain esterel allows signals input output 
natural example inputoutput bus request semantics inputoutput signals bit delicate detailed 
see details 
sensors declared way sensor temperature fahrenheit compiler check temporal instructions delays applied sensors remember operator applies 

relation declarations relation declarations restrict possible input events module 
kind relations 
incompatibility relations form relation states signals mutually exclusive input events 

relations form relation tells input event example relation declarations relation left button right button second second reasons input relations 
specification may require signals appear watch sense go simultaneously stopwatch alarm mode 
second relations essential reduce size generated automaton 
see section details 

basic esterel instruction set naive semantics describe expressions statements basic esterel intuitive semantics 
basic statements form heart esterel 
independent 
meta variables type exp star range types expressions statements self explanatory meta variables italic necessary 
esterel expressions statements manipulate variables signals declared locally point 
variables signals strongly differ signals shared 
statements difference input output local signals 

expressions expressions classical way denote values 
built constants variables signal values operators function calls 
strongly typed classical way see precise type checking laws 
constants natural numbers boolean constants true false userdefined constants declared module constant declaration part 
variables classical identifiers see variable declarations 
signal type type expression type type denotes current value signal time express evaluated see 
operators usual integer boolean operators function declared module declaration part 

basic statements list basic statements halt exp call variable list expression list emit exp loop star exp tat tat tat watching stat tat trap star exit vat type signal combine type tat dummy statement halting statement assignment statement external procedure call signal emission sequence infinite loop conditional test signal presence watchdog parallel statement trap definition exit trap local variable declaration local signal declaration emit watching statements specific esterel deal uniformly input signals output signals local signals declared local signal declarations 
exit statement exits control block defined trap statement 
kind construct known lisp catch throw tag exit construct ml failure construct ada exception construct 
case interaction exit parallel statement carefully defined shall give class semantic status trap exit statements explaining loosely control flow 
statements common imperative languages 
notice parallel statement level static notion process csp 
compound statements sequencing operator priority parallel operator 
necessary statements grouped bracketing square brackets stat star star 
variables signals trap labels declared 
declarations static scope 
input inputoutput output signals global scope 
variables shared variable updated branch parallel statement read updated branch variable updated assignment procedure call appears argument list 
additional restrictions apply basic esterel programs input signals internally emitted 
statement value access allowed output signals 
restrictions simplify mathematical semantics 
suppressed plain esterel compiler produces warnings satisfied 

intuitive semantics intuitive semantics describes behavior module input history 
call input occurrence possibly simultaneous input signals coming environment 
module reacts input event updating local variables emitting local output signals 
emitted output signals output sent module environment 
process called input event 
reaction assumed instantaneous output event synchronous input event 
sequence input events called events define history 
reactions occur input events underlying execution machine inactive input events 
signals constitute events obey lav signal fixed status reaction preset 
signal input event input signal emitted program local output signal 
signal unique value reaction 
signal reaction value current input value signal input combination emitted values signal output local 
signal absent current value previous reaction 
emission value local output signal undefined value intuitively sharing law imply program determinism shall see section true correct programs 
variables shared statements updated times single reaction 
initial value key idea intuitive semantics describe formally performed statement memory updates signal emissions tests instant performed 
signal current values general subprocess interaction defined solely terms timing 
describe timing structural way semantics relies notions 
context statement program determines instant statement starts executing second internal execution statement determines 
statement terminates instant starts say 
esterel instantaneous expression computations memory updates communication control transmission 
third esterel block exits execution statement determine exits trap statement exits trap ot terminate sense inactive 
statement terminate exit trap instantly said take 
statement aborted killed part program instant prevented performing actions terminating exiting 
semantics structural describes relations notions statements module body starts reception input event 
terminates implicitly followed sequence halt statement 
performs action terminates instantly 
halt performs action terminates exit traps 
assignment updates memory terminates instantly 
procedure call updates memory terminates instantly 
long computations performed program running realized procedure calls 
realized sending arguments external computing devices waiting results signals value communication 
specific time consuming exec primitive added esterel subsequent versions 
starts emit statement evaluates expressions value emits signal value terminates 
statement sequence starts sequence starts 
statement exits trap sequence second statement starts 
statement terminates second statement starts instantly sequence behaves second statement 
body loop starts loop starts 
body terminates loop instantly restarted 
loop terminates 
body exits trap loop exiting outer trap way exit loop 
started conditional instantly evaluates condition 
condition true statement starts instantly conditional behaves statement 
behavior symmetric condition false 
statement acts conditional condition presence signal current reaction notice condition expressed boolean expression 
star watching statement gives execution body star limit reaction 
body starts instantly watching statement starts 
body terminates exits trap st occurs watching statement 
watching statement terminates soon occurs 
case body instantly killed executed performs action exits trap 
languages implicit loop watching statement restarted terminated 
branches parallel start parallel starts 
branches exits trap parallel statement branches inactive 
branches exit traps simultaneously parallel exits outermost trap discarded 
parallel statement terminates branches terminated 
trap construct defines exit point body 
body starts instantly determines behavior trap statement terminates exits trap 
body terminates exits trap statement instantly terminates 
body exits outer trap trap statement 
exit statement exits doesn terminate 
local variable declaration declares variable initialized behaves body 
local signal declaration declares signal initialized behaves body 

remarks imperative statements reaction instantly execute actions 
statement executes successive assignments signal emissions reaction starts careful reaction starts watching statement taken account termination watching statement described called watching older versions esterel default version 
emit emit done simultaneously variable updates done specified order expected final value 
contrary sharing law ordering signal emissions immaterial 
just put parallel 
problem loops 
write absurd loops loop instantaneously execute infinitely additions memory updates 
forbid situation impose body loop terminate instantly started detected compile time 
notice introduced conditional statements tests boolean expressions tests presence signals 
introduce boolean expression true current reaction form test presence signals booleans behave differently presence value signal uniquely defined reaction boolean variable updated times instant watching primitive available signals boolean expressions 
conditionals allow suppress statements appearing keywords corresponding keyword 
example exp star stands exp star star stands sta form especially useful statement star test absence illustrate interaction exit parallel statements analyze toy example trap trap exit exit assignments performed simultaneously actions parallel branches 
assignment performed follows sequence exit statement terminate 
parallel branches exits 
trap construct encloses trap exit discarded exited 
statement terminates instantly assignment executed 

remarks temporal statements sharing law simultaneous actions executed signal environment signals visible statements 
realizes communication instantaneous broadcasting emitters receivers 
consider example integer signal addition combination function emit emit emissions simultaneous statement sees receive value equal 
way statement take time involve halt statement takes infinite amount time conversely watching statement limits time taken body 
temporal manipulations basic esterel combinations halt watching statements 
simplest example interaction construct waits occurrence terminates halt watching plain esterel construct abbreviated await 
simplify examples abbreviation basic esterel examples 
illustrate temporal behavior watching statement look simple example 
assume input signals output signals 
statement emits receives plain esterel immediate emit see section 
statement watching emit emits receives reaction occurs input event initial reaction excluded occurs emitted body watching statement executed emitted watching statement terminates 
behaviors input output input output input output input output trap watching statement body executed reception terminates watching construct 
want motivate important choice 
notice choice execute body action instant terminate coded terminate exit terminate await exit terminate trap construct exited star terminates occurs 
case tat executed instant occurs precedes exit statement sequence 
simple reverse coding exists obtain original semantics watching alternative 
second nesting watching statements establishes priorities signals 
consider example await watching behavior follows el occurs strictly el occurs set construct terminates 
stt sl construct terminates occurs assignment executed 
sl simultaneously body watching executed signals occurs construct terminates executing assignment previous case 
outermost signal instantaneous pt ity innermost signal asynchronous languages usually possess watchdogs analogous watching statement restricted absolute time measured seconds worse machine dependent unit 
semantics completely rigorous 
esterel watching statements defined applicable signal just absolute time nesting watching statements different signals basis esterel programming style see section 
mention subtlety concerning local signals local signal emitted simultaneously ent scopes 
consider example module input sl integer output integer integer loop signal integer emit await emit emit await emit loop starts emitted value output value 
occurs emitted value output value parallel local signal declarations terminate body loop restarted instantly reinitialized instantly emitted value instantly output value 
simultaneous emissions don occur instance local signal declaration don combined clear unfolds loop executing 
semantics treats correctly example initial semantics esterel esterel system treated incorrectly 

plain esterel instruction set kinds extensions available plain esterel extensions concerning signals signal interface user friendly statements directive modular programming 
detailed plain esterel signals section directive described section 
extended instructions derived basic ones macro expansion 
powerful control structure trap exit mechanism heavily expansions seen example previous section 

miscellaneous easy extensions give extensions detail see exact expansions 
initialize variables declaration time appropriate assignment generated 
declare variables signals local variable signal declaration 
define repeat loop form repeat exp times star repeat construct expands loop nested trap statement exiting trap count expires 

occurrence counts timeouts watching statements watching statements convenient distinguish body normal termination timeout termination caused occurrence signal 
adds timeout clause tat watching timeout star expansion easy trap terminate exit terminate watching stat basic time limit occurrence event plain allows forms time limits 
ence count form exp exp integer expression 
instance build seconds milliseconds wy loop await emit second heavy improved 
theoretical expansion uses auxiliary local signal repeat loop leave reader 
practice occurrence counters useful built primitives actual esterel systems 
second generalized occurrence form called immediate form 
remember starting event taken account timeout watching statement 
form takes account star watching immediate expansion tat watching occurrence counts immediate occurrences available temporal statements described 

upto statement upto statement similar watching statement doesn terminate body terminates timeout terminates upto statement 
construct star upto expands star halt watching body exits enclosing tag upto statement guaranteed take exact time mentioned time limit 
careful watching immediate called watching older versions esterel 
upto statement taken primitive older versions esterel 
define watching upto watching advantages semantic primitive see 

await statements written await halt watching 
point dependency statement arrival signal write await star await star 
general form await statement multiple 
example write await case second case meter star case immediate alarm elapsed delay determines case execute 
similar selection statement classical asynchronous languages deterministic 
delays elapse simultaneously case list order selected 
instance alarm meter second reached simultaneously executed 
see expansion 

temporal loops come back production seconds milliseconds programmed 
simpler form millisecond emit second expansion stat simply await loop sa upto waits signal signa occurrence count 
starts body star body afresh occurrence signal signal occurrence count 
temporal loop similar body started loop star expands loop sa upto 
exceptions plain esterel includes genera exception handling mechanism extends basic trap mechanism allowing exit handlers value passing 
example genera construct trap alarm combine integer zero divide terminate handle alarm handle zero divide call star body stat stat exception handlers 
body contain generalized exit statements form exit alarm exp exit zero divide 
statement executed executing body body instantly exited corresponding handler instantly started terminate handler 
far values concerned valued exits behave signals exit alarm exp raised value alarm exit obtained combining values addition function value accessed alarm handler special expression alarm double question mark distinguish exceptions normal signals signals exits don belong name space 
expression alarm allowed alarm handler 
different exits raised simultaneously 
belong different trap construct outermost ones matter 
belong single trap construct corresponding handlers executed parallel 
see general expansion statement 

plain esterel limited form modularity module appear statement place 
replaced text copied module consistency verifications interface declarations 
copying recursire nested depth 
renamings allowed copying process see 
see section annex example 

programming example simple illustrative example program reflex game machine described detail complex wristwatch example appears 
fuji esterel reflex game program shown annex 

reflex game specifications player controls machine commands putting coin slot start game pressing ready button start reflex measure pressing button measure 
machine reacts commands operating devices numerical display display shows reflex times amp signals measure game amp game red amp player tried cheat abandoned game bell rings player hits wrong button 
machine turned display shows game amp red amps 
player starts game inserting coin 
game composed fixed number measure number reflex measures 
measure starts player presses ready button random amount time amp turns player press button fast 
lamp turns reflex time measured milliseconds displayed numerical display 
new measure starts player presses ready 
cycle measure number measures completed average reflex time displayed pause pause length milliseconds game amp turned 
exception cases 
simple mistakes bell ring player presses ready start measure player presses ready measure cases red game amps turned amp turned game ends player press ready button limit time milliseconds expected assumes player abandoned game player press button limit time milliseconds expected light turns assumed abandon player presses button pressed ready button machine turns go light tte sane happens cheat 
anomaly appears player inserts coin game 
new game started afresh 

declarations reflex game parameters game declared integer constants 
notice values esterel program host language 
determine random delay length external function random defined host language 
input declarations declare millisecond time unit ms user commands 
notice absolute time predefined esterel time just signal 
far input relations concerned input signals assumed incompatible ms player presses simultaneously occurrence ms terminates random delay considered cheater 
control lamp say go introduce output signals go go 
single signal conveying boolean value wristwatch example 
output signals display ring bell 

average submodule general purpose submodule compute average response time 
simple module emits average value receives increment average new argument module average input increment average integer output average value integer var total number integer immediate increment average total total increment average number number emit average value total number 

body reflex game body composed successive parts initializations main loop single game restarted coin inserted 
main loop simply controlled coin statement 
single game declare error exit handle cheating game exit handle normal game termination need exit actual statement treats single game put parallel copy average module terminates 
single game sequence measure loop termination action turning game 
measure divided phases 
phase waits ready time limit limit time ms ringing bell pressed 
easily written nesting temporal statements bearing different time units emit ring bell upto ready watching limit time ms timeout exit error phase consists waiting random phase waiting button 
phases pressing ready rings bell treated putting ready statement parallel phase phase sequence 
phase specification says pressed random ms rewrite positive form random ms occur time limit esterel await random ms watching timeout exit error shows useful temporal statements arbitrary signals just privileged absolute time unit 
full code annex 
self explanatory 

behavioral semantics esterel purpose give mathematical definition semantics basic esterel 
intuitive semantics terms statement duration measured signal occurrences 
formal denotational semantics corresponding intuitive concept 
behavioral semantics section different spirit suited practical implementations 
program input event determines output event generated program reaction new program able handle subsequent input events 
duration semantics replaced shot semantics involving program rewritings spirit natural deduction semantics structural deduction rules 
usual natural deduction semantics executable rules directly building interpreters 
behavioral semantics doesn property treatment sharing law involves fixpoint operation local signal declaration rule 
behavioral semantics serves definition esterel operational semantics agree far input output behavior concerned 
section effective complex execution semantics theorem ensures agrees behavioral semantics 

definitions events histories event 

set signals simultaneously emitted corresponding values 
appears value write write empty event called contains signal 
semantic rules replace esterel notation comb signal value combinations collisions convenient notation extend combination operation events defining synchronous product events componentwise signals vl vl vl sv vl se clearly holds event events contain positive information emitted signals 
model persistence values introduce complete events include value information absent signals 
call set signals sort 
complete event signal sort appear emitted value emitted current value history eo possibly infinite sequence events denotes finite tory eo complete history sequence complete events respects persistence law signal values 
satisfies implies implies assume signals history belong sort completion respect defined follows iff iff example consider sort 
history completion sl sl 
sl 
sl 
mc signal th step history 
module derivatives input history program computes output history th output event depends input sequence formed events classical idea natural semantics compute output history step step fashion 
apply idea build sequence form ot pll pn io basic esterel programs complete events completed input history associated need complete input events treat fact input signal values permanent 
key point rewrite step program new program called derivative respect derivative esterel program computes output history starting step input history starting step 
declarations different body 
simple illustrative example plain esterel constructs module input second output deep await second emit deep halt 
derivative empty event program 
derivative second event program having body await second emit deep halt reception second deep emitted program stops body statement halt accepts input produces output 
derivative technique transforms temporal problem instantaneous ones find reaction input find derivative 
technique introduced brzozowski compute automaton recognizing language generated regular expression 

inductive rules relation programs deduced similar relation statements defined deduction rules determine transition esterel construct transitions 
order handle control transmission expression computation relation components relation 
form conventions memories allocate free variables star memories described 
complete event represents complete signal environment star executed 
sort set input signals local signals visible star 
event contains signals emitted star values 
sort set output signals local signals visible star 
termination boolean having value ff star terminates ff 
set trap labels contain labels exit statements executed star 
treatment parallel exits slightly differ gave intuitive semantics remain equivalent said arms parallel exit traps simultaneously outermost trap matters ones discarded 
mimicking statement semantic equations require preorder trap labels heavy compute structural way 
formal solution retain labels exited parallel set choose action perform trap statement level trap statement considered exited body exactly exits set simply propagates exits memories manipulated follows empty memory allocates variable 
memory allocates set variables variable 
memory allocates 
allocates denotes value defined 
allocates denotes memory receives new value formally 
ix 
ix 
notice memory handling respects static scoping memory may allocate times variable accesses concern allocation 
position define relation technical reasons simpler assume program body terminates adding halt statement sequence needed 
set pi iff star body memory exited label set empty deal syntactically correct programs free variables free exits 
structural induction computes difficulty correctly compute status presence absence signals values 
key idea behavioral semantics directly exploit synchrony hypothesis statements signal visible see status value signal 
input signals status value simply determined input event global program 
local signal seen statements scope emitted local signal rule expresses consistency constraint simple non effective way 

expression evaluation addition inductive rules statements need expression evaluation rules form exp constant semantic value rule rule variable signal rule value access rules operators function calls obvious left reader 

inductive rules statements 
axiom statement terminates leaves memory unchanged 
axiom halt halt statement doesn terminate reproduces halt 
rule assignment assignment statement updates memory terminates 
rule procedure call procedure call rule similar assignment rule left reader 
expression list computed current memory signal environment external procedure updates memory 
procedure call terminates 

rule emit emit statement emits expression value terminates 
rules sequence statement doesn terminates behavior sequence statement 
sequence rewritten sequence derivative second statement stat star star stat pt statement terminates second statement executed memory state produced global rewriting second statement emitted signals merged stat stat stat stat stat stat 
rule loop rule performs instantaneous unfolding loop sequence 
note loop terminate 
staff staff 
rule boolean expression instantly evaluated selected branch instantly executed 
rule true case exp true stat pt exp tat tat rule false case symmetric false tat 
rules rules similar rules 
signal current event clause instantly executed tat tat clause instantly executed stat tat 
rule watching star watching statement executes body star yields derivative star 
derivative watching statement watching star watching immediate plain esterel receiving input derivative terminate instantly behave star watching absent 
precisely intuitive behavior watching 
star star star watching star watching 
rule parallel branches executed independently signal environment 
output events merged 
shared variables branches update variable resulting memory merge pt obtained follows pt pt pt 
pt stat stat ut stat merge 
rules trap trap terminates body terminates body exited label set contains exactly trap label stat stat trap statement behaves body label removed exited label set handles correctly parallel exits nested traps 
jj ff 
axiom exit exit doesn terminate puts label exited label set ff halt 
rule local variable declaration order retain value variables step step reacting input history slightly modify basic esterel variable declaration construct 
new construct var star operator transforms semantic value esterel constant appropriate type 
new construct allows save current value variable program text 
standard basic esterel declaration initially sets value 
rule allocates variable currently saved value executes body saves new value step star 
rules local signal declaration fixpoint rules realize sharing law 
respect declared signal require body environment build self 
retain values execution steps operator introduced variables 
slight problem due static scope signals event may contain different signal having name introduce notation denote complete event obtained removing component 
rule applies signal emitted body signal received body emitted received values coincide new signal value stored local signal declaration derivative ks tat second rule applies signal emitted 
received previous signal value retained declaration ks tat star 
simple example simple example study reactions program module input integer output combine integer signal integer emit emit emit halt await 

input assume value 
intuitive semantics guess emitted value emitted twice values yielding combined value 
derivative body halt 
reaction sketch proof omitting expression evaluations memory part useless 
body declaration analyzed guessed complete event 
guess branches parallel statement analyzed order 
start analyzing 
emit rule yields tt emit emit second sequence rule yields emit emit tt rule yields tt half parallel rule emit yields emit tt axiom halt second sequence rule yield emit halt ff halt rule yields halt rule parallel combines emissions terminations branches halt apply local signal rule 
yields signal signal halt guess easily seen possible 
reaction deterministic 

input signal absent intuitive analysis shows emitted 
parallel statement computed complete event 
statement emits signal terminates second statement part evaluated halt watching rules definition await await await parallel rule yields ii ii await apply second local signal rule emitted body resulting parallel statement 
possible proof reaction deterministic 

determinism program correctness establish behavioral semantics proof guess presence absence local signals values 
example unique correct guess intuitive semantics 
build simulators compilers need effective process determine presence values signals 
process section 
section study determinism behavioral semantics 
design rationale want programs deterministic unique behavioral semantics input 
sharing law guarantee determinism programs semantics semantics 
simplify discussion examples closed programs inputs yield problems execution initial reaction 
start pure signal examples 
program semantics signal emit signal consistently considered emitted emitted 
cases body signal 
changing yields program behavioral semantics signal emit signal emitted clearly nonsense 
example similar involves signals signal emit ii emit possible behavioral semantics emitted emitted 
changing yields program form nondeterminism signal emit ii emit solutions emitted emitted emitted 
problems appear valued signals 
consider program signal integer emit integer constant 
emitted value satisfy value equation solution infinitely solutions 
programs clearly rejected 
nondeterminism necessary condition rejection build pc changing type integer type triv value semantics pc unique semantics esterel programs depend type implementation details pc rejected common reason 
problems due fixpoint form local signal rule respect intuitive sequentiality constraints program reactions 
infinitely fast machine run programs behave sequentially far sequential control transmission concerned 
statement semicolon executed second statement test conditional statement computed statements started 
consequence second statement semicolon resp 
arms conditional statement interfere execution statement resp 
test 
programs rejected reason 
similarly value signal read emitted reject pc 
similar problems exist synchronous circuits logical behavior circuit defined fixpoint equations transistor states provided circuit contain races races appear sequential propagation electrical currents compatible topological structure 
program pu esterel version gate output plugged input 
formally say signal written emit statement read test operator 
say relation generated sequences tests 
right correctness condition follows signal read written 
determines correct executions program correct input correctly executed 
note simpler correctness condition signal written read reject programs 
determining signal written position program general unfeasible particular uninterpreted conditionals 
obtain necessary sufficient correctness conditions 
need sufficient conditions effective efficient compilers 
perform static dependency analysis signals structural control flow analysis analysis produces signal dependency contains arrow read written possible execution path 
program yields cyclic dependency graph rejected 
technique proved correct esterel compiler 
drawbacks rejects correct programs graph cyclic debugging information limited list cycles graph hard exploit 
gonthier consider esterel program executed conventional sequential machine zero time reaction hypothesis amounts observing computation time 
signals handled shared memory read write discipline 
technique technically involved yields better results 
esterel compiler 
section 
notion correctness local reaction 
program correct input incorrect 
assume input signal 
program incorrect received signal emit say program locally correct correct inputs 
program incorrect reactions signal await emit program locally correct receiving locally incorrect program say program globally correct locally correct sequence reactions produces locally correct programs 

execution semantics section presents execution semantics local correctness criterion 
underlying execution machine conventional sequential machine 
signals implemented controlled variables read write discipline ensures signal unique defined status emitted emitted unique defined value reaction 
reaction realized execution sequence elementary actions called microsteps followed expansion step prepares program reaction 
expansion step applied execution properly 
program said correct input halted execution input 
reaction completed respecting signal memory read write discipline 
actions determined structural operational rules 
parallel operator interleaves actions branches usual asynchronous models 
execution correct programs nondeterministic 
reactions correct programs deterministic main theorem states halted executions correct programs yield final results agree behavioral semantics expansion furthermore behavioral semantics correct programs unique 
read write discipline correct realization sharing law law sense 
proofs omitted sketched require technical concepts outside scope 
see complete proofs 

implementation signals structure signal memory similar standard memory variables primitives allocate cells write cells reads cell values 
cells contain status information written exponent describes current status content 
cell forms cell written current reaction content previous reactions 
st cell written current reaction current content read write operations occur 
cell written current instant longer written 
content read current value signal known current reaction 
cell written current reaction longer written 
content read current value signal known absent current reaction 
sigal constructed empty signal memory signal memory 
sx signal memory 
read operation performed cell status sx simi ar test status signa memory ifs iff ifs result writing value cell signal memory denoted 
writing done allocated occurrence signal cases actual writing 
memory written new value replaces old value memory state goes st signal written new value combined old combination function associated 

st 
st way write cell form 
potential rules show memory goes 
relate execution semantics behavioral semantics relate signal memories complete input events output events 
program input sort output sort associate signal memory complete input event 
memory allocates signals composed cells output signals order cells oi immaterial 
conversely associate final signal memory output event containing st cell sort set output signal gets gets status matter read internally 

computing actions execution semantics set rules determine actions form action rules determine statements update memories 
writing triples assume allocate free variables signals star 
need auxiliary sets rules rules arrows equations equal signs difference somewhat immaterial exp evaluation ules govern evaluations form signal memory discipline expresses operator evaluated exponent 
tc compute partial function cr stat termination boolean set exited trap labels behavioral semantics 
termination rules terms perform action 
execution termination treated behavioral semantics simpler separate rules execution termination 
termination rules places detect completion current reaction second start executing second statement sequence statement terminated terminated statement form trap exit 

compute 
tat statement set signals ta emit execution 
potentials change status local signals signal memory signal goes longer emitted belong potential current term 

action rules assignment act expression evaluated rule procedure calls similar left reader 
emission executed expression computed updates signal memory described earlier xp statement sequence act sequence statement sequence terminated second act rule connects execution termination rules loop act iff body unfolds acts compute condition 
selects corresponding branch true tat false tat similarly statement act soon signal status selects corresponding branch essential statement applied output signals get status tat tat watching statement acts body remember temporal guard take effect immediately watching parallel statement act branches standard interleaving semantics trap statement act iff body local variable declaration execute body binding variable 
value variable kept variable declaration behavioral semantics local signal declaration binds signal current signal memory 
behavioral semantics binding stored signal declaration store value current signal status 
signal longer emitted body set place potentials 
execution new signal state stored signal declaration 
define auxiliary operation local signal rule star stat stat stat star star 
expression evaluation variable evaluated usual signal value accessed status operator operate soon arguments computed 
termination termination function computed execution longer possible 
assignments emi statements conditionals statements directly act termination rule 
termination stat pair termination status exited label set say star terminated say star ff clearly terminated halt halted halt ff sequences cases 
statement termination terminated sequence statement terminated termination second statement defined sequence termination second statement rules handles sequences exit star ff ff stats tt stat body loop terminated 
termination body 
oo na ff watching statement termination body star watching star behavioral semantics termination statement obtained termination branches stat star stat terminations trap exit computed behavioral semantics tra bv stat exit local variable signal declarations simply propagate termination body var star stat signal star 
potential rules potential stat statement star set signals emit executions 
compute potentials simple structural control flow analysis 
perform structural induction compute extended potentials stat potential star boolean termination status true iff star terminate execution path exited label set set trap labels star exit execution path 
potential statement star defined stat iff stat computed termination status similar termination status computed termination rules really statically computed approximation represents termination information get executing statement 
termination status obtained termination rules obtained computing potentials represents information statement terminate exit trap labeled exp exit extended potentials halt assignments trivial halt ff emit statement adds signal potential terminates statement sequence terminate extended potential sequence statement statement sequence terminate extended potential sequence obtained union potentials second statements termination boolean second statement labels potentially exited statements tat tat stat stats ih extended potential loop obtained body returning ff boolean termination status loop terminate loo star conditional statement potential union potentials branches 
conditional terminate iff branches label exited iff exited arm tat star bl potential rules implemented esterel system bit finer see 
sta extended potential watching body ao potential parallel union potentials branches parallel terminate branches terminate exit label arm stat stat ab potential rap statement body rap statement terminate ff body terminate exit label removed exited label set trap star bv exit generates corresponding exited label ex ff local variable declaration affect potentials var star stat local signal declaration removes signal potential signal star 
confluence properties executions reaction realized finite terminated execution sequence 
behavioral semantics shall assume program body followed sequence hal statement halt terminate 
shall assume local signals initial status value local signal signal star initially replaced signal sz star 
definition execution sequence 
maxima ff action 
halted ff stat 
halted execution called result execution 
halted execution sequences exist 
statement loop maximal halted execution sequences 
programs section halted execution sequences 
consider example statement signal emit empty variable signal memories 
potential statement 
signal execution rule imposes find execution triple rule applied triple requires exponent 
action step possible 
execution empty 
termination undefined termination rule emit 
possible execution halted 
programs ppc rejected way rule rule ps halted executions exist executions reaction parallel execution rule non deterministic branches parallel act parallel act 
confluence properties ensure sequences yield result words order actions immaterial 
property classically called strong confluence theorem strong confluence theorem distinct actions ol exists star theorem easy deduce global confluence property halted execution sequences really expresses determinism reactions corollary confluence theorem program body star input event corresponding signal memory 
halted execution sequence infinite execution sequence maximal sequences halted yield result 

expansion step behavioral semantics statement appears result reaction directly ready reaction 
things done reset local signal status local signal declarations 
turn star watching statements star watching 
expansion done fly behavioral semantics see rule watching 
easier execution sequences execution semantics 
perform cleanup example halted term halt transformed halt match behavioral semantics 
equations describe expansion step halt halt stat stat tt loop stat stat loop stt stat watching stat watching stt ii stt stt ii stat trap stt trap stt trap stt var stt var stat signal signal 
equivalence behavioral execution semantics position state main theorem execution semantics matches behavioral semantics 
associate reaction halted execution sequence followed expansion step definition program body stat complete input event 
say causally correct write pp stat halted execution sequence form body equal stat equal output event determined 
theorem correctness determinism theorem program complete input event causally correct exist unique program unique output event pp 

execution example illustrate execution semantics sketch executions example section module input integer output combine integer signal integer emit emit emit halt await 

input assume value 
initial signal memory 


entering body local signal declaration compute potential add signal memory 
statement act execute statement 
statement selects branch 
ends action yields term signal emit emit emit halt await potential unchanged 
execute emit statement sequence 
cell signal memory sl 
second action yields term result signal sl emit emit halt await potential body 
cell signal memory body executes 
terminated emit statement executed 
choose 
choose 
third action yields term signal emit emit halt emissions executed order 
corresponding actions get halted term signal halt signal memory 


output 
expansion step clears status second leaving term signal halt 
input absent enter local signal declaration 
action statement selects second branch leaves signal memory unchanged yields term signal emit halt halt watching potential body body signal memory 
second action selects branch statement yielding halted term signal halt watching execution finished 
expansion step prepares term reaction transforming signal halt watching 
compiling esterel programs deterministic automata execution semantics effective basis building language 
interpreters exist esterel esterel systems 
performances reasonable say reaction times second sufficient real time applications 
section show produce efficient sequential automata behaviorally equivalent source esterel program 
algorithm similar brzozowski algorithm translating regular expressions finite automate see :10.1.1.98.4378
discuss pros cons compiling technique practical validity synchrony hypothesis 

compiling pure synchronization programs study simple case pure programs contain pure signals variables constants values kind 
programs presence absence signals matter 
memory parts useless semantics equations 
pure synchronization program finite possible input events corresponding sets input signals 
finite immediate derivatives theorem shows property holds general derivatives programs obtained arbitrary long sequences reactions pi theorem pure synchronization program finitely derivatives 
completely replace program considered finite state automaton derivatives states 
automaton starts state current state input automaton emits output event goes state iff reaction graph fully computed com ilc run time program texts useless simply replaced state numbers 
example program module input output signal emit loop await await emit 
yields automaton state output output state goto goto state goto await emit goto goto output goto means goto treat reaction kom state 
body signal await emit await emit loop await await emit await emit notice algorithm translates concurrent program sequential 
concurrency treated compile time run time 
notice local signal completely pea compiled code 
local signal acts auxiliary non terminal parser generator 
writing modular programs local signals better architecture yields run time overhead 

compiling general esterel programs manipulate data general esterel programs translated automata simply pure synchronization ones 
key idea keep memory actions formal compile time performed run time 
automaton transition consists sequence run time actions precisely tree actions due conditionals 
actions operate globally allocated variables 
object code variable allocated explicitly declared variable valued signal source code 
implicit variables allocated occurrence repeat loop counters booleans indicating input signal presence actions appear transitions generated source assignments explicit implicit variable initializations valued signal emissions source emit statement generates assignment signal variable 
procedure calls generated simply source procedure calls 
tests 
kinds tests generated boolean expression tests appearing conditionals decrement tests internal counter variables signal occurrences repeat statements tests presence input signals generating transition input event suggested better practice test presence input signals call need basis 
output sigal transmit emission signal program environment 
actions gathered action table transitions referring entries table 
notice synchronization needed internal communication values simply implemented order assignments transitions generates code 
reflex game program generates state automaton annex 
see details 

time space efficiency generated code run time efficiency automaton object code obvious 
actions done runtime appear transitions 
mentioned communication pure internal generate code way say really infinitely fast 
communication valued local signals done assignments fast possible 
process handling overhead 
infinitely fast generated code essentially fast comparable carefully handwritten low eve code 
synchrony hypothesis code fast target machine implementation desired reactive program machine east reasonable cost 
furthermore code sequential reaction speed measurable processor 
user verify speed requirements wi satisfied run time 
general result concerning space efficiency question ess clear 
grammar parsers easy build examples produce exponential mow size 
practice obtained automata tend reasonable size minimal close minimal property holds brzozowski original algorithm reason completely understood 
produced host language automaton generated compact byte code form 
example reflex game automaton occupies bytes automaton wristwatch program occupies kbytes 
causes size explosion number transitions state number states 

section allow control case 
program input signals possible input events sets input signals 
input relations dramatically reduce number 
example signals declared incompatible number input events decreases including empty event 
relations game example decrease number input events 
user aware importance relations compiling programs 
number states controllable parser generators 
size practical applications time say states 
notice internal moves program generate states asynchronous formalisms states really correspond observable input output states 
belief major advantage deterministic synchronous formalisms non deterministic asynchronous ones 
furthermore possible obtain dramatic size reductions splitting big automata cascades small automata 
esterel compiler automatically perform splits particular cases 
shall discuss subject see details 

efficiency compiling process derivative algorithm esterel system written le lisp 
involves expensive operations symbolic evaluation programs inputs storing comparison program text trees 
involves complex dynamic memory handling requires garbage collection practice 
fix ideas standard wristwatch example average size non trivial program compiles seconds sun machine mbyte memory 
bigger programs require order magnitude time space 
esterel compiler deeply optimized version algorithm similar simpler optimization original brzozowski algorithms regular expressions 
esterel programs translated low level intermediate code compiles away 
structure preserving concurrency 
translation structural application directive inter module linking done code level 
code symbolically executed extract automaton 
done operating code 
machine simple execution states basically described pair stacks simple operations 
derivatives represented sets program pointers easy compare inexpensive store 
execution machine outputs automaton transitions directly stream backpatching 
operates little memory simple allocation strategy garbage collection 
compiler implemented traditional imperative language chose 
compiler considerably efficient predecessor 
sun workstation wristwatch example compiles seconds bytes 
payoff larger bigger programs compiler immune garbage collector thrashing occurs larger examples 
compiling qualitatively different performance compiler limited size output time space requirements 

details esterel programming language temporal constructs synchrony hypothesis mathematical semantics currently available implementations esterel esterel translate concurrent synchronous programs sequential automata 
esterel implementation developed industrial basis 
numerous examples successfully treated different areas real time process control graphics communication protocols 
believe practical interest synchronous programming compared classical asynchronous programming established framework reactive systems 
pursue areas kernel synchronous calculus developed second author allow implement temporal statements available esterel process weak module structure esterel extended support hierarchical module definitions standard ml module structure 
esterel compiler efficient 
gain speed improving internal coding objects 
codings output automaton available match various time space ratio constraints 
currently building interactive programming environment centaur system 
plan implement advanced features visual source stepping programs course harder concurrent language sequential determinism help keep environment simple 
source stepping facilities available source compiled code know maintain object source correspondences low cost 
esterel program important area practice reactive programs control devices safety critical 
mentioned various kind available proof techniques 
evaluated real examples 
build nice interfaces esterel compilers proof systems non specialists perform proofs 
large scale obviously synchronous programming style completely stood 
large applications clear mixed synchronous asynchronous strategies needed 
technical difficulty asynchronously run communicating synchronous automata 
experiments show reasonable put boundary synchronous asynchronous techniques 


ideas design esterel continue participate project designed correct behavioral semantics author initial version implemented esterel system authors analyzed causality problem proposed alternative semantics wrote esterel compiler kernel bernhard 
saint 
wrote rest esterel system careful proof reading 
ad programming language ada manual springer verlag lncs 
arnold construction analyse des de transitions le mec acres du colloque cnrs 
barendregt lambda calculus syntax semantics north holland 
berry 
esterel high level language real time applications proc 
ieee real time systems symposium ieee catalog ch pp 

berry programming language esterel mathematical semantics seminar concurrency springer verlag lncs 
berry gonthier des le langage esterel techniques sciences de informatique vol 
pp 

berry gonthier programming reactive esterel inria report 
berry gonthier esterel system manuals collection technical reports ecole des mines inria sophia antipolis 
berry gonthier esterel programming examples collection technical reports ecole des mines inria sophia antipolis 
berry sethi regular expressions deterministic automata theoretical computer science pp 

le editions 
clement despeyroux kahn lang centaur inria report 
boudol communication abstraction acres du colloque cnrs inria report 
boudol castellani semantics concurrency partial orders transition proc 
coil 
trees algebra programming caap pisa italy 
browne clarke sml high level language design verification finite state machines mellon university report cmu cs 
une du langage esterel inria report 
brzozowski derivatives regular expressions jacm vol 

pike squeak language communicating mice bell laboratories report bell laboratories murray hill new jersey 
caspi pilaud halbwachs plaice lustre declarative language realtime programming proc 
conf 
principles programming languages munich 
le manuel de rdf rence inria technical report 
clarke emerson sistla automatic verification finite state concurrent temporal logic practical approach department computer science report carnegie mellon university 
clement behavior graphical objects esterel inria report 
op du langage esterel de de nice 
gonthier des application esterel informatique universit orsay 
le guernic benveniste gauthier signal data sigal irisa report irisa rennes france 
harel visual complex systems science computer programming vol 
pp 

harel pnueli tle reactive systems logic ad models systems proc 
nato advanced study institute logics models verification specification concurrent systems nato asi series vol 
springer verlag pp 

harel pnueli schmidt sherman tte formal proc 
symposium logic computer science pp 

hoare comm 
acm vol 
pp 

huet properties ad term systems journal acm vol pp 

inmos tte occam prentice hall international 
johnson yacc compiler compiler bell laboratories murray hill new jersey 
kahn mac queen md networks processes proc 
ifip northholland amsterdam pp 

kahn natural proceedings stacs conference lecture notes computer science vol 
springer verlag 
mac queen modules ml polymorphism 
milner calculi ad theoretical computer science vol 
pp 

mitchell harper tte ml proc 
acm conf 
principles programming languages 
plotkin structural lectures notes aarhus university 

sifakis md systems cesar proc 
international symposium programming springer verlag lncs 
stroustrup tte addison wesley 

des programmes esterel automates th se de cycle de nice 
memos automata inria report 
de automates par le syst auto informatique universit de nice 
annex reflex game esterel program module reflex game constant limit time measure number pause length integer function random integer input ms coin ready relation ms coin ready coin ready output display integer go go game game red red ring bell initializations emit display emit go emit game emit red loop single game coin initializations emit display emit go emit game emit red exception handling trap game error signal increment average integer average value integer average ii repeat measure number times phase emit ring bell upto ready watching limit time ms timeout exit error phases trap measure ready emit ring bell ii phase await random ms watching timeout exit error emit go reflex game esterel program second version phase var integer ns upto emit display emit average watching ns timeout exit error emit go exit final display await pause length ns emit display 
average value exit handle error emit red emit go game emit ver 
reflex game esterel program second ver ion annex reflex game automaton 
memory allocation vo boolean presence signal ms boolean presence signal coin boolean presence signal ready vs boolean presence signal integer value signal display vs integer value signal increment average integer value signal average value 
integer count variable integer count variable integer count variable integer source variable time vii integer count variable integer count variable integer source variable total integer source variable number 
actions test expressions input signals vo presence ms presence coin presence ready presence output signal actions ut display alo ut go ut go ut game ut game ut red ut red ut ring bell assignment actions measure number limit time random limit time pause length test expressions reflex game esterel program second version decrement test expressions deer deer deer deer deer 
automaton full automaton states 
list states ready pressed waiting go go emitted waiting 
input tests recall input signal 
output actions recall output signal red ff 
state ins goto goto coin display ff ver ff red ff goto display ff ver ff red ff goto ready ring bell goto ff ver alo red goto goto reflex game esterel program second version state ms go game red goto display go goto display go goto goto coin display go game red goto display go game red goto ready ring bell goto display go goto display go goto goto 
