reprinted proceedings acm conference programming language design implementation pldi single intermediate language supports multiple implementations exceptions norman ramsey harvard university eecs 
harvard 
edu simon peyton jones microsoft research simonpj microsoft com mechanisms enable compiler target language express best known techniques implementing exceptions single uniform framework 
define mechanisms precisely formal operational semantics 
show exceptions need require special treatment optimizer introducing extra dataflow edges standard optimization techniques programs exceptions 
approach clarifies design space techniques allows single optimizer handle variety implementation techniques 
ultimate goal allow source language compiler freedom choose exception handling policy encapsulating architecture dependent mechanisms optimization implementation compilers source languages 

compiler target language intended independent source programming language target architecture peyton jones oliva nordin peyton jones ramsey 
design accommodates variety source languages leaves room backend optimization upcalls back front 
universal intermediate language conway write run intermediate language lindholm yellin 
encapsulates compilation techniques understood difficult implement 
techniques include instruction selection register allocation instruction scheduling scalar optimizations imperative code loops 
encapsulates architecture specific run time support required high level run time services garbage collection concurrency debugging exception dispatch 
inappropriate back implement services challenge identify low level primitive permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific fee 
pldi vancouver british columbia canada 
copyright acm 

mechanisms back provide top client implement high level services 
explains encapsulates techniques compilers support exception dispatch 
contributions mechanisms uses specify interprocedural control flow weak continuations outlive procedure activations call site annotations section 
mechanisms support single framework known ways implementing exceptions 
supports continuation passing style fourth implementation technique 
native code compiler aware uses techniques implement exceptions 
define mechanisms precisely intermediate language formal operational semantics section 
easily derived source 
immediately obvious standard analyses optimizations implemented presence exceptions 
algorithm converting dataflow graph section 
may novel way documenting intermediate representation directly useful implementors standard dataflow analyses produce accurate safe code presence exceptions exception handlers exceptions need treated special cases 
single optimizer suffice programs regardless original source language 
approach simple applied intermediate forms illuminates design space exception dispatch mechanisms 
new 
example compiler writer thinks hard may decide extra flow edges express optimization constraints exceptions hsieh gyllenhaal hwu 
literature optimizing presence exceptions sparse hennessy chase rare exceptions 
know presents language independent techniques optimization 

problem 
intend provide exception mechanisms suffice support variety programming languages surveying mechanisms widely 
aware techniques transfer control point source language exception raised point exception handled 
stack cutting sets stack pointer program counter point directly handler 
compiler technique fast restore values callee saves registers general values may distributed stack 
technique may best suited implementations callee saves registers 
objective caml uses technique common lisps pre scheme lisps 
code setjmp longjmp cut stack typically save restore lots state size buf pointers pentium linux sparc solaris alpha digital unix 
entire buffer significantly expensive native code stack cutter saves pointers 
sparc pays additional penalty flushing register windows 
performance penalty implementations compile src modula 
run time stack unwinding uses run time system unwind stack frame time handler reached 
run time system restores values callee saves registers unwinds stack typically interpreting tables deposited back 
operating systems may provide support run time stack unwinding example mips abi provides run time procedure table digital unix includes specified abi call stacks 
back ends polytechnic modula technique java virtual machine compilers 
native code stack unwinding uses specialized code procedure unwind stack nonlocal return exceptional termination called 
compiler generates native code unwinding interpretive overhead involved 
self compiler uses technique 
continuation passing style potential exception handlers represented exception continuation 
generated code raises exception making tail call continuation 
continuation decides handler applies 
compiler generates specialized code handler 
standard ml new jersey uses technique 
supports continuation passing style fully general tail calls peyton jones oliva nordin require explanation 
discuss mechanisms 
mechanisms understood supporting requires intimate cooperation optimizer code generator run time system 
ordinary recursion export sp spl bits bits return spl return tail recursion export sp sp bits jump sp help loops export sp sp bits bits loop return goto loop sp help bits bits bits return jump sp help procedures compute sum product written 
correct exception dispatch depends semantics exceptions source language representation call stack target machine interactions may subtle 
optimization fundamentally affected exceptions 
optimizing compilers may ad hoc modifications optimizers right thing exception semantics particular language 
easy way code generator know language specific details exception semantics run time system know code generator stack layouts register saving protocols 
intimate cooperation available reusable code generator support multiple source languages multiple target architectures 
main contribution show reusable code generator cooperate front ends arm length support variety exception semantics architecture independent way 
key observation language provide su flexible interface 
includes language cooperates source language compiler run time system cooperates source langage run time system 


portable assembler discussing deals exceptions sketch language run time system details peyton jones oliva nordin peyton jones ramsey 
give feel presents procedures computes sum product integers language unremarkable 
parameterized procedures declared local variables 
procedure body consists sequence statements include assignments conditionals gotos calls jumps tail calls 
illustrates features common assemblers common programming languages 
procedure may return multiple results 
example procedures return results sp contains call multi result procedure sp 
second procedure may explicitly tail call procedure 
example sp tail calls sp help jump tail calls 
tail call semantics regular procedure call followed return guaranteed deallocate caller resources notably activation record call 
extremely modest type system types words floating point values various sizes bits bits bits bits float float 
target architecture implementation designates types native data pointer type native code pointer type 
example name procedure sp denotes immutable value native code pointer type 
intent type system protect programmer sole purpose direct compiler machine resources particular mapping variables registers 
example check number types arguments passed procedure 
local global variables model machine registers memory locations 
variables addresses possible back maps registers 
permits programmer declare names refer blocks memory allocated globally procedure activation record names stand variables stand addresses memory blocks denote immutable values native type 
memory access explicit 
example statement bits bits loads bit word memory location address variable increments stores memory location address variable programs graphs regard program textual description control flow graph set named control flow graphs procedure 
syntax designed intraprocedural control flow edges explicit 
example label loop sp names node graph goto creates edge specified label 
target goto label procedure 
label value target goto computed run time goto statically identify possible targets compiler include edges control flow graph 
run time systems assume executable program built linking parts may object flies libraries combination 
front translates high level source program modules compiler translates generated object code 
front comes probably large front run time system 
run time system implements policy mechanisms depend source language 
may include garbage collector exception dispatcher thread scheduler front run time system written programming language designed humans sume written implementation comes hopefully small run time system 
run time system encapsulates architecture specific mechanisms provides services front run time system language run time interface peyton jones ramsey 
different front ends may interoperate run time system 
main service provided run time interface state suspended computation thread stack activations 
operations provided walk stack get information activation particular activation topmost change resumption point topmost activation 
operations summarized table operations discussed section 
knowledge stack layout implementing operations straightforward representation activation include copies callee saves registers pointer activation record real call stack 
syntax enables front associate call site arbitrary static data blocks descriptors allocated initialized front 
syntax important 
run time run time interface provides returns th descriptor associated particular ac 
control transferred running computation run time system 
front runtime may create threads coroutine call front runtime request services thread switching exception dispatch 
runtime may create single thread runs system stack requests services making ordinary calls front runtime 
case thread initiates interaction calling special procedure yield 
resume resumes thread sets currently executing activation thread mutates point activation return normally caller 
arranges thread resume execution activation arranges thread resume execution unwinding th continuation activation set resume 
arranges thread resume execution cutting stack continuation returns pointer location th parameter currently set continuation returned thread returns pointer th descriptor associated activation table run time interface 

implementing high level ex turn attention exceptions 
details exceptions change flow control 
destination exceptional control transfer usually called handler finding handler transferring called exception dispatch 
models handlers continuations provides control transfer mechanisms 
uses annotations call sites tell optimizer exceptional control transfers take place 
annotations help implement control transfer mechanisms 
section describes mechanisms appendix shows examples 
continuations model exception handler continuation bit label parameters 
bits bits float cuts may cut calls return continuation code mentioning 
continuation passed continuation declared inside procedure 
continuation binding instance formal parameters continuation variables enclosing procedure need type declarations 
continuation denotes value transfer control shown section 
value encapsulates stack pointer program counter 
continuation value may passed procedures stored data structures type native data pointer type 
activation dies continuations die 
invoking dead continuation unchecked run time error high level front avoid 
continuations powerful say scheme continuations implemented efficiently stack copying 
avoid unchecked errors front protect invocations run time check impose invariants guarantee dead continua tion invoked 
stack walk required 
execute ii generated cut return code run time system alternatives control transfer 
annotation cuts call site indicates control flow call directly dis call site annotations section 
transferring control continuation procedure transfer control continuation ways different cost model 
mechanisms provides offer compiler writ ers alternatives trade offs 
raising exception involve walking stack 
walking stack raising exception expensive cheaper enter scope handler 
bulk done generated code run time system 
generated code results larger executables may faster 
shows mechanisms support alternatives 
row primitives result generated code 
second row entry points run time interface table 
describe design choices turn starting top left corner working counterclockwise 
stack cutting column continuation value primitive cut invokes continuation transfering control directly continuation walking stack 
cut arguments continuation value passed example section 
cut primitive transfers arguments conventional locations truncates stack activation sets program counter program locations typically registers determined calling convention private 
counter 
takes constant time stack walk 
cut program may yield front run time system 
finds continuation value duplicate effect cut 
calling table cuts stack 
calling identifies locations continuation expects parameters 
storing actual parameters locations 
calling resume pass control back generated code 
stack cutting takes constant time imposes cost recording continuation value cut 
places constraints identification target continuations different front ends different implementation techniques 
common choices program keep track single exception continuation register 
commonly control transferred continuation updates register point new exception continuation 
keep global stack continuations choose topmost 
alternatively keep information exceptions handled continuation choose applies tion 
choices impose small cost execution enters leaves scope exception handler regardless exception raised 
stack cutting technique reduces utility registers 
normally keep registers call stack cutting technique restore values entering 
values spilled activation stack activation place exception raised 
stack cutting imposes small performance penalty call cut continuation callee saves registers considered killed flow edges call cut continuations 
penalty paid regardless continuation 
stack unwinding second column known alternative stack cutting walk stack activation time discover topmost activation handle exception 
idea cost enter leave scope handler exchange willing pay raise exception 
supports approach 
unwinding technique program may yield front run time system indicating manner knows cares exception raise 
front runtime initialises activation handle walks stack table 
activation calls find static descriptor deposited activation front compiler 
descriptor indicates activation handle exception front runtime uses arrange execution resume activation identified 
suspended call site activation look unwinds kl kl continuations defined procedure call unwinds annotations indicate control flow just cuts annotation discussed section 
addition unwinds supports run time interface call table 
front runtime uses ar range execution resumed resume th continuation unwinds list call site 
find store parameters continuation resume resume execution 
appendix shows details 
unwinding technique described far somewhat interpretive front runtime walks stack looking descriptor information finds handler 
possible compile stack walk allowing procedure return abnormally caller return return values tells caller abnormal return con addition normal return point causes return index 
normal return call site written return return values call site call returns specify precisely correct number returns continuations specified return statement returns kl kl continuations declared procedure call site 
statement return return continuation passing return site parameters 
normal return continuation normal return case return return equivalent return return transfers control procedure caller procedures cooperate get effect compiled unwinding 
language specifies statically exceptions procedure may raise compile call site abnormal return continuation possible exception 
alternatively single abnormal return continuation dispatch exceptions 
supports styles efficiently leaving choice implementor front 
abnormal returns implemented 
possible simply return additional value procedure caller test see callee requested stack unwinding normal return 
test add overhead call 
overhead eliminated means clever trick 
call site call instruction followed code executed normal re instructions leading call call instruction delay slot instructions normal continuation instructions leading call call instruction delay slot ba unconditional branch ba kl unconditional branch kl instructions normal continuation standard sparc instruction sequence call site 
normal return imp 
sparc instruction sequence branch table method 
normal return return continuation zi 
turn table branches continuations atkinson liskov 
figures show example sparc instruction set 
shows instruction sequence ordinary call site 
call instruction leaves address register instruction delay slot executed immediately call control transferred standard return instruction skips past instruction delay slot resumes executing normal continua tion 
shows instruction sequence annotated call site returns kl 
callee uses normal return uses return continuation kl 
tech nique dynamic overhead normal case 
abnormal case dynamic overhead branch branch cheaper branch followed test conditional branch 
atkinson liskov calls technique branch table method noting adds words call site space overhead may considerable 
processor architectures run time overhead may considerable unusual return address normal case may require extra instructions may confuse branch prediction hardware 
branch table method self compiler implement nonlocal returns 
support efficient implementation vectored returns glasgow haskell compiler peyton jones 
stack walk implemented run time system native code nonlocal return easily restore values callee saves registers 
branch prediction hardware may head standard sparc calling convention procedures return private communication craig chambers january 
automatically 
un winding technique allows callee saves registers call site values continuation 
primitive operations fail expressions represent pure computations values evaluated side effects occur result assignments calls 
computations fail fault detected hardware operating system 
example divide instruction traps divisor zero 
operation provide variants fast dangerous variant say generates shortest possible code sequence usually instruction behavior unspecified fails 
cause interrupt kill process silently give wrong answer 
exact behavior vary architectures 
alternative guarantee process abortion certain processors alternative impose run time costs annoying cases divisor provably non zero 
slow solid variant maps failure yield 
example indistinguishable procedure defined follows bits bits yield return may different callee saves registers different call sites continuation may need different different call sites 
roughly correspond ssa form 
dispatcher choose prologue appropriate call site suspended 
luckily choice hidden run time interface 
note run time system fails unwind cut stack behavior subsequent call unspecified 
takes form procedure call annotations 
making control flow explicit writing faulting operations calls ensures operations evaluated defined order 
implementation choose perform test zero explicitly slow easy catch interrupt map yield fast tricky 
informing optimizer exception dispatch changes flow control 
optimizer knows control transferred unexpectedly continuation pessimistic assumptions example ada compilers require exception handler uses variable variable kept memory 
example compilers pessimistic assumptions local variables presence 
portable way guarantee local variables right values declare volatile compilers interpret mean keep values variables stack 
supports aggressive optimization requiring front tell optimizer explicitly exception dispatch change flow control 
information conveyed annotations attached call sites mentioned 
example shows complete set cuts kl unwinds returns aborts normal case call returns value placed call raises exception exception dispatcher may cut stack invoking continuation kl loss callee saves registers unwind stack continuations return alternate continuation abort execution procedure activation containing call unwinding cutting stack past activation 
names appearing annotations kl names continuations declared procedure call site annotations may name variables expressions 
annotations add extra flow edges call site specified continuations exit node procedure case aborts 
edges express precisely constraints exception handling imposes 
annotations reasonably inferred compiler front compiler knows calls flow continuations calls abort 
control flow de accurately front decides approximation useful 
cuts annotation may attached cut statement 
cut considered simply exit current procedure cut transfer control continuation procedure cuts annotation naming con 

operational semantics far treatment informal com mon descriptions exception handling 
precise specification impossible say sure particular optimization changes behavior program 
risk front compiler compiler disagree happens obscure circumstance 
accordingly section describe formally precisely 
define language resembles flowgraph representations optimizing compilers give formal operational semantics 
operational semantics uses transition rules specify permissible behaviors generated code run time system 
sketch translation implementation hardware 
program partial map names procedures 
procedure control flow graph formed nodes defined table 
range includes nodes form entry fcp yield 
mutable state machine com ponents 
control represents current node 
local environment maps names values 
set cs containing variables stored callee saves registers 
unique integer uid enforce restriction dead continuations 
memory mapping addresses values 
argument passing area list values 
stack empty tuple consisting continuation bundle local environment callee saves variable set unique id stack 
continuation bundle encodes possible outcomes procedure call 
write state follows cs uid environments values expressions environment partial function names values 
write empty environment 
define environment maps write 
generalize notation list variables list expressions length 
define environment undefined variables set write ml community long standing tradition mal definitions analyses exception 
straightforward generalize machine separate address spaces instructions data 
entry fcp exit copyin cs assign branch pt call jump ec yield unique entry node procedure continuations node normal exit procedure representing return continuation call site exactly alternate return continuations tagged returns 
put results call parameters procedure continuation variables continue values expressions results call parameters procedure continuation continue cs set variables callee saves registers spilling reloading continue assign continue branch pt pf true false 
call procedure returning nodes continuation bundle continuation bundle quadruple iy abort nodes continuations listed returns plus node normal returns nodes continuations listed unwinds nodes continuations listed cuts abort true call site annotated aborts false 
tail call procedure ef 
exits current procedure 
cut stack continuation exits current procedure 
execute procedure run time system 
table kinds nodes control flow graph 
enable variables denote procedures continuations basic values define value forms bits 
code cont bit value pointer node continuation node stack frame unique id expressions side effects give semantics expression simply giving evaluation function pm 
exact definition relevant abbreviated definition gives idea 
simplicity assume names local variables different names procedures dom dom 
assumption pm defined follows pm dom pm code type pm pm ei pm ni rules rule apply built operators 
operations native byte order target machine 
transitions machine machine executes program entering initial state main nil empty machine transitions reaches state transitions possible 
state control exit stack empty say program terminated normally gone wrong 
set transition rules describes allowable transitions 
transition rule form state state machine state matching state move step state suitably instantiated 
rest section gives transition rules 
procedure entry node binds procedure continuations empty environment 
incoming environment discarded 
values parameters bound copyin node 
entry cs uid uid uid pair creates bindings follows uid empty cont uid uid followed 
sequence lists continuations declared procedure body 
pair name continuation graph node representing 
exit pops activation returning return continuation named return 
value passing area may hold return values placed preceding node 
exit cs uid cs uid cs uid fj fj abort value passing area holds arguments results passed procedures continuations 
copyin nodes transfer values area 
enable implementation reuse registers specify copyin replace empty list nil 
may overwrite state 
copyin cs uid cs uid nil cs uid cs uid pm optimizer may move values callee saves registers 
cs cs uid cs uid nodes introduced optimizers part direct translation program 
node corresponds mix spills reloads 
assignment variable changes local environment assignment memory changes memory 
assign cs uid pm cs uid assign type cs uid cs uid pm pm 
conditional branch straightforward branch pt cs uid pm cs uid call pushes new activation 
parameters placed node 
continu ation bundle saved stack callee caller determines executed call 
activation record unique uid 
call ei cs uid cs uid ei pm code pi fresh unique identifier 
tail calls simpler appropriate continuation bundle stack 
jump cs uid el pm code pl fresh unique identifier 
machine tries cut continuation belonging activation different current uid removes frame stack tries 
real implementation cuts stack constant time machine removes activations time go wrong suspended call aborts annotation 
ec cs uid cs uid ec cs uid ec pm cont uid uid uid machine finds right activation uid uid checks call site cuts annotation transfers control appropriate continuation 
uid check ensures machine invokes dead con program tries goes wrong 
discussed section cut restore values stored callee saves registers model behavior removing saved environment 
ec cs uid cs uid cs uid ec pm cont uid uid uid fir pc abort yield node models execution run time system 
rules rules yield fully specify transitions take place states transition permitted 
underspecification allows run time system implement variety different high level exception semantics respecting single semantics 
run time system may unwind stack suspended procedure aborts annotation yield cs uid cs uid yield cs uid true 
run time system may change memory transfer control normal return continuation contin uation listed returns unwinds annotation 
transition restores callee saves registers 
yield cs uid cs uid ts pd pd abort right length 
run time system passes parameters continuation values parameters unspecified exactly parameters expects 
entry fcp exit copyin cs assign assign type branch pt call ef ffr abort jump ec yield def 

def procedure 
eli effect dataflow 
fv 
der fv 
def fv fv ef der parameters call 
edge clef 
clef der 
cs code executed kill abort yue place edge exit node 
ef jump 
cut 
optimized procedure 
fv free variables possibly including variable represents memory 
table dataflow rules 
run time system may transfer control continuation listed cuts annotation restoring callee saves registers 
yield cs uid cs uid cs uid ff pd abort right length 
run time system form garbage collector may read write values memory live values stored stack machine 
possibility expressed formal semantics require complicated machine record set live variables call site 
translating translation continuations calls jumps cuts obvious 
translate continuation create copyin node naming parameters continuation successor statement continuation 
associate node continua tion 
translate call create node puts values parameters value passing area successor call node containing expression designating procedure called 
call node continuation bundle computed annotations described 
call returns values normal continuation copyin node binding return values variables left hand side call 
jumps cuts translated similarly simplification return 
implementing machine machine designed real machine hiding details registers calling convention instruction set 
control corresponds program counter 
local environment corresponds parameters local variables stored registers activation record set cs identifies variables stored callee saves registers 
node changes cs implemented instructions move values callee saves registers 
instructions include spills reloads reg shuffles 
translation callee saves registers node including node enable represent results code improvement puts values callee saves registers 
course code improvements take account control flow cuts edges flow destroys values stored callee saves registers 
value passing area abstraction representing registers set aside passing values results overflow areas may reserved stack 
abstraction may different concrete representations different call sites 
supports multiple named calling conventions calling convention may dictate different representation intend optimizers free choose customized value passing mechanisms possible passing parameters procedures call sites known 
stack corresponds machine stack activation records 
stack continuation bundle represented just program counter pc general points branch table section 
run time system needs find pc look table 
uid exists ensure program tries dead continuation goes wrong 
dead continuation unchecked run time error uid need represented implementation 
may useful represent explicitly order debug frontend compilers generate code goes wrong 
values form bits course basic values machines 
value form code represented pointer instructions ways implement continuation value cont 
possible implementation allocate words current ac record represent cont pointer pair 
bit cleverness may possible allocate program counter current activation record pointer location initial stack pointer continuation 
case continuation values need encapsulate locations store parameters fit registers 
information implicit 

optimizing programs table gives rules adding dataflow information procedure terms definitions uses copies kills 
information enable standard optimizations common subexpression elimination partial redundancy elimination constant propagation copy propagation elimination code motion optimizer perform usual rearrangements provided respects dataflow doesn insert code exit jump abort part continuation bundle 
shows example procedure shows translation dataflow formation attached 
dataflow infor mation expressed static single assignment ssa numbering variables alpern wegman zadeck rosen wegman zadeck appel 
elements array may mapped different hardware registers depending nodes define conventions passing parameters return values 
example variables mapped register holding parameter call variables mapped register holding result call 
intend compiled continuation passing style course easily represent highlevel programs compiled continuation passing style 
front perform cps transformation build explicit closures represent continuations 
code closures represented procedures control transferred jump 
weak continuations useful nonlocal exits representing class continuations 
operation kill may defined assigning bogus value og computation depends og may defined gone wrong 
bits bits unwinds return continuation return example procedure 
def def def bl def def 
example procedure translation dataflow graph ssa form 

related discusses low level implementation exceptions drew cough complements presenting taxonomy high level designs models 
chase provide helpful clear explanations techniques required implement synchronous asynchronous exceptions 
liskov snyder discusses programming methodology exceptions efficiency implementation 
drew gough discusses implementation stack unwinding technique zero dynamic overhead enter scope exception handler 
register allocator unaware control flow edges call sites exception handlers variable mentioned body handler allocated stack 
unwinds annotation en able optimizers avoid performance penalty 
hennessy discusses errors occur optimizer know additional control flow edges introduced exceptional termination 
presents dataflow equations front compiler compute annotations place call site 
discusses interprocedural analyses compute potential effects global variables 
analyses accommodated splitting scheme require additional annotations stores fetches calls jumps invocations 
intermediate form vortex compiler dean includes explicit control flow edges represent effects exceptions 
edges enable rest vortex optimizer correctly having treat exceptions special case 
hard find real optimizing compilers deal exceptions believe pessimistic assumptions implement ad hoc rules tightly bound particular exception model language compiled 
case standard optimizations reconsidered light particular semantics chosen exceptions 
approach advocate vortex allows developed optimization technology applied program uses exceptions 
appel similar functional setting identifying exception handlers continuations appel compiler simply existing body optimizations known supported continuation passing style 
style expressed manner appendix jump cut 
bruggeman waddell dybvig introduces continuations general scheme continuations invoked 
continuations certainly suffice implement continuations implementation part chez scheme system immediately obvious tradeoffs scheme 
results segmented stacks appear highly relevant concurrent version 
acknowledgments richard black kent dybvig michael ernst lal george thomas johnsson xavier leroy nikhil john reppy olin shivers david watt referees pldi pldi valuable feedback 
supported part nsf ccr asc darpa contract mda generous gift microsoft 
alpern bowen mark wegman kenneth zadeck 
january 
detecting equalities variables programs 
conference record th annual acm symposium principles programming languages pages san diego california 
appel andrew 
compiling continuations cambridge cambridge university press april ssa functional programming 
sigplan notices 
atkinson russell barbara liskov robert 
december aspects implementing clu 
proceedings acm annual conference pages 
acm 
bruggeman carl oscar waddell kent dybvig 
may 
representing control presence shot continuations 
acm sigplan conference programming language design implemen tation sigplan notices 
chase david 
june implementation exception handling part journal language translation 
september implementation exception handling part ii calling conventions asynchrony optimizers debuggers journal language 
conway october proposal 
communications acm 
dean jeffrey defouw david litvinov craig chambers 
october vortex optimizing compiler object oriented languages 
oopsla conference proceedings sigplan notices 
drew steven john cough 
may 
exception handling expecting unexpected computer languages 
drew steven john cough 

implementing zero overhead exception handling 
technical report faculty information technology queensland technology brisbane australia 
see www 
dstc 
qut 
edu 
au gough 
pa hennessy john 
january 
program optimization exception handling 
conference record th annual cm symposium principles programming languages pages williamsburg virginia 
hsieh cheng john gyllenhaal hwu 
december 
java bytecode native code translation caffeine prototype nary results 
proceedings th annual ieee cm international symposium microarchitecture 
lindholm tim frank yellin 
january 
java virtual machine specification 
java series 
reading ma usa addison wesley 
liskov barbara alan snyder 
november 
exception handling clu 
ieee software engineering se 
peyton jones simon april 
implementing lazy functional languages stock hardware spineless tagless machine 
journal functional programming 
peyton jones simon dino oliva nordin 

portable assembly language 
proceedings workshop implementing functional languages vol 
lncs pages 
springer verlag 
peyton jones simon norman ramsey 
august machine independent support garbage collection debugging exception handling concurrency draft 
technical report cs department computer science university virginia 
see www 
eecs harvard 
edu nr pubs rti 
html 
peyton jones simon norman ramsey 
september 
portable assembly language supports garbage collection 
nadathur editor international conference principles practice declarative programming number lecture notes computer science pages berlin 
rosen barry mark wegman kenneth zadeck 
january 
global value numbers redundant computations 
conference record th annual cm symposium principles programming languages pages san diego california 
appendix implementing exceptions believe support rich variety exception semantics 
demonstrations provide supporting evidence unfortunately demonstration necessarily fixes semantics source language cost model implementation 
save space sketch potential exception dispatchers 
dispatchers implement modula exceptions different cost models 
modula exceptions zero normal case overhead shows fragment game playing program written modula 
modula uses try show handlers scopes 
statement sequences right arrows handlers exceptions 
exceptions raised try control transfers appropriate handler 
assignment control skips directly 
execution handler control transfers 
implementation run time stack unwinding code translated procedure shown 
procedure try player mod number players player player tiles example modula procedure 
bits player unwinds kl aborts unwinds kl aborts bits players load size array descriptor mod finish return continuation kl bits bits player load address method goto finish continuation bits bits player load address method tiles goto finish implementation modula run time stack unwinding 
see exception dispatch works suppose terminates normally discovers move goes board 
contain modula statement raise board translated yield awaken front runtime request exception dispatching service 
details particular exception pushed global exception stack push exn info exn board yield exception front runtime invoke exception dispatcher simplified version appears 
dispatcher get exception information call tcb get activation handle topmost activation stack 
map activation handle statically allocated exception descriptor mechanisms implementing mapping discussed peyton jones ramsey 
struct exn descriptor int handler count struct void exn tag int cont num int takes arg handlers void dispatcher activation void exn tag arg pop exn info exn tag arg tcb struct exn descriptor 
map activation exn descriptor 
int handler count handlers exn tag exn tag tcb unwind stack 
tcb handlers cont num choose handler 
handlers takes arg exn expects value 
void result tcb result arg assign result 
return abort unhandled exception dump core simplified exception dispatcher modula written exception raised handled handlers descriptor dispatcher call get frame 
eventually find activation exception descriptor states continuation handles modula ex ception 
purposes number continuations starting zero order appear unwinds annotation call site activation suspended 
dispatcher establish activation re sume cause resumption proper continuation 
tcb find location put argument handler 
continuation parameters numbered starting zero 
recommended modula manual implementation requires zero dynamic overhead entering scope exception handler cost dispatching exception may considerable 
real dispatcher modula complicated pro vide finalization try handlers receive multiple exceptions better recovery unhandled exceptions 
dispatcher included dec src modula includes performance optimizations efficient finalization locks 
register bits exn top top exn stack bits exn tag arg kl exn top sizeof put dynamic exception stack 
bits exn top player cuts cuts bits players load size array descriptor mod exn top sizeof leave try 
finish return continuation exn tag arg exn tag player load address method arg goto finish exn tag player load address method tiles goto finish kl bits exn top exn top sizeof kl cut kl exn tag arg implementation modula stack cutting 
modula exceptions constant time compilers different implementation trade 
small overhead added try exchange exception dispatch efficient typically instructions 
high level language maintains stack handlers pointed register 
exception dispatched handler top stack handler contains code identify exception pass handler necessary 
style implementation procedure compiled code shown 
example assumes machine native data pointer type bits code raise exception raise exn val compiled bits exn top fetch current handler stack exn top sizeof pop stack invoke exn val invoke handler equivalent exception dispatcher propagation exceptions implemented handler 

