static decentralized information flow control andrew myers january massachusetts institute technology research supported part darpa contract monitored office naval research darpa contracts monitored usaf rome laboratory 
author supported intel foundation fellowship 
massachusetts institute technology laboratory computer science cambridge massachusetts usa static decentralized information flow control andrew myers growing mobile code downloaded programs applets servlets increased interest robust mechanisms ensuring privacy secrecy 
common security mechanisms sandboxing access control restrictive weak prevent applications sharing data usefully allow private information leak 
example security mechanisms java prevent useful applications permitting trojan horse applets leak private information 
thesis describes decentralized label model new model information flow control protects private data allowing applications share data 
previous approaches privacy protection information flow label model decentralized allows cooperative computation mutually principals mediation highly trusted agents 
cooperative computation possible individual principals declassify data principals privacy 
decentralized label model permits programs checked statically important precise detection information leaks 
thesis presents new language jflow extension java programming language incorporates decentralized label model permits static checking information flows programs 
variable declarations jflow programs annotated labels allow static checker check programs information leaks efficiently manner similar type checking 
labels inferred automatically annotating programs onerous 
dynamic checks may safely static checks insufficiently powerful 
compiler implemented jflow language 
checking performed statically compile time impact performance usually small 
keywords constraint solving covert channels integrity java labels principals privacy programming languages role hierarchy security static checking trojan horse trusted computing base type systems verification report minor revision dissertation title submitted department electrical engineering computer science january partial fulfillment requirements degree doctor philosophy department 
thesis supervised professor barbara liskov 
acknowledgments people deserve helping degree love research reality 
advisor barbara liskov continuous support inspiration provided am better writer speaker time mit largely due 
hope someday approach clarity thought expression ability focus important 
thesis committee provided excellent suggestions form content 
mart abadi thoughtful extremely useful comments phases greatly appreciate support reading thesis 
john guttag suggested useful clarifications 
butler lampson insightful suggestions developing helped central ideas thesis intuitive 
people provided useful feedback thesis 
chandrasekhar boyapati miguel castro stephen garland deserve special depth readings helpful suggestions couple years 
nick mathewson provided useful code able borrow 
pleasure graduate student programming methodology group group members creating lively thought provoking environment 
atul adya joseph bank phillip chandra miguel mark day sanjay ghemawat jason hunter umesh maheshwari life richer considerable abilities willing movie runs share suggest books play ping pong swap evil puzzles 
friends helped years 
help refine talks papers 
addition useful feedback jim toole stimulating early years mit 
joe paul flew town graduate life 
people better researcher computer scientist 
greg nelson src appreciate value written specification 
learned user interfaces design rob myers silicon graphics brendan bruce sgi better programmer collaborator 
pavlovic mayo clinic introduced research helped realize wanted scientist 
parents rest family incredibly supportive years quest doctoral degree 
parents pushed achieve limits ability done ensure best education possible 
owe gratitude 
greatest asset years wife bala 
emotionally supportive best reviewer person bounce ideas 
worked complete doctoral degree helped conceivable way right start barcelona park helped idea thesis topic 
contents example 
existing security techniques 
decentralized information flow control 
decentralized label model 


applications 
limitations 
outline 
label model 
principals 
labels 
relabeling restriction 

relabeling declassification 
channels 
examples 










annotations 
static correctness condition 
sound complete relabeling rule 



integrity policies 
combining integrity privacy 

summary 
jflow language static vs dynamic checking 
language support information flow checking 



run time labels 
reasoning principals 
declassification 
run time principals 




exceptions 
parameterized classes 
arrays 
run time type discrimination 
authority declarations 
inheritance constructors 
examples 
example 
example protected 
limitations 

label expressions 




new expressions 
statically checking jflow correctness 


environments 
exceptions 


representing principals 
representing labels components 
representing types reasoning principals 
reasoning labels reasoning subtypes 
checking java statements expressions arithmetic variable access 
variable assignment compound statements goto statements exceptions checking new statements expressions declassification 
run time label tests checking classes methods checking classes class authority 
method signature compatibility constraint solving translation determining meet components handling dynamic constraints recursion dynamic components translation principal values actsfor statement related access control 
limitations discretionary access control static enforcement security policies cryptography decentralized label model chapter computer security increasingly important result ongoing trends 
computers inextricably connected internet 
increasingly computation data storage distributed geographically remote untrusted sites programs data highly mobile 
sensitive personal corporate government data placed online routinely accessed networks 
number users interacting entities continues increase rapidly trust relationships entities growing increasingly complex 
short protect difficult protect 
difficult characterize protection needed 
abstractly goal computer security ensure computations obey set policies central goals computer security private secret data leaked parties misuse valuable data damaged destroyed parties 
complementary goals referred privacy integrity 
thesis focuses protection privacy integrity considered briefly 
protecting privacy secrecy data long known difficult problem existing security techniques provide satisfactory solutions problem 
systems support downloading distrusted code particularly need better protection privacy 
example java gjs supports downloading code remote sites creating possibility downloaded code transfer private data sites 
suppose user computes taxes downloaded applet 
user ensure applet transfer tax information back applet provider 
java attempts prevent improper transfers security model called sandbox model fm mf approach largely prevents applications sharing data permitting privacy violations just described 
key problem information shared downloaded code preventing code leaking information 
generally accepted definition means protect privacy 
distinction drawn privacy security goals secrecy confidentiality 
privacy identified weaker goal anonymity protecting identity various parties medical protocol data swe 
terms privacy secrecy considered synonymous refer ability control information leakage kind 
term privacy emphasizes decentralized environment generally accepted notion sensitivity data exists 
users generally consider data private naturally concerned privacy data users 
privacy requirements users treated equally important 
general security enforcement mechanisms may internal external computing system 
internal mechanisms attempt prevent security violations making impossible external mechanisms threat legal action attempt convince users initiate computation violate security 
current security mechanisms internal external viable computing system large decentralized anonymous international 
widespread downloading code dealing untrusted programs greater issue security past 
conventionally focus placed protecting operating system buggy malicious programs protecting users 
computer systems programs violate user privacy programs installed system purchased vendor 
source program known form external available program violate privacy 
programs java applets dynamically downloaded executed ability identify exact supplier privacy violating code reduced 
goal develop better internal mechanisms preventing programs violating security policies convincing users 
sense goal reduce cost ensuring security cost passed users 
user downloads free application user accepts risk program violate security considerable cost ensuring program violate security 
observation applies commercial software providing application ensure violate user security liable cases violates security sense reputation may suffer 
kinds software cost passed users application 
better internal mechanisms applied users software developers reduce cost 
example depicts example security requirements satisfied existing techniques 
scenario contains mutually principals cooperate perform useful 
example user bob preparing tax form spreadsheet program piece software called 
bob able prepare final tax form trust protect privacy 
computation performed programs spreadsheet trusts full authority program trust 
bob transmit tax data spreadsheet receive final tax form result final tax form bob spreadsheet preparer database simple example tax data protected leaking tax information 
example principal named preparer privacy interests 
principal preparer represents firm distributes software 
application computes final tax form proprietary database shown bottom owned preparer 
database example contain algorithms minimizing tax payments 
principal source software trusts program distribute proprietary database malicious action program leak information contains bugs 
principle may difficult prevent information database contents leaking back bob particularly bob able large number requests carefully analyze resulting tax forms 
information leak practical problem preparer charge bob form fee exceeds value information bob obtains form 
scenario preparer principal needs pieces functionality 
needs protection accidental malicious release information database paths final tax form 
second needs ability sign final tax form confirming information leaked final tax form sufficiently small scrambled computation tax form may released bob 
worth noting bob preparer need trust execution platform subverted 
example running computer bob completely controls bob able steal proprietary database 
clearly preparer real expectation privacy secrecy private data manipulated unencrypted form execution platform trust 
thesis assumed execution platform trusted programs running platform may 
issue trust execution platform discussed section 
assumption scenario implemented satisfactorily modeled existing security techniques 
current techniques bob carefully inspect code verify leak data general task difficult 
techniques described thesis allow security goals bob preparer met inspection bob preparer cooperate performing useful computation 
sense shows bob preparer inspect program efficiently simply determine violates security requirements 
existing security techniques briefly consider application existing security techniques problem depth discussion see chapter 
people think computer security think wellestablished security techniques access control 
typical access control mechanisms support discretionary access control protect privacy programs trusted access control prevents unauthorized information release control information propagation information accessed 
example program allowed read user data control distributes information read 
known approach protecting privacy information flow control 
information flow techniques mandatory access control piece data attached sensitivity label 
labels typically small ordered set unclassified classified secret top secret 
labels remain attached data propagates system preventing released improperly released untrusted program 
data may relabeled restrict relabeling secret top secret 
relabeling data top secret secret allowing top secret data affect secret data declassification downgrading lead information leak 
intuitively information flow control protects privacy directly access control practical problems information flow control prevented widespread adoption 
sensitivity labels usually maintained dynamically causing substantial loss performance 
dynamic labels impose greater run time storage overheads access control mechanisms primitive operation label result computed 
limitation sensitivity labels implicitly centralized express privacy concerns single principal typically government 
considers providing privacy decentralized setting community web users clear universal notion secret sensitivity established 
practical information flow control systems provide ability declassify downgrade data strict information flow control restrictive writing real applications 
declassification systems lies outside model performed trusted subject code possessing authority highly trusted principal 
notion highly trusted principal extend decentralized system 
traditional information flow models support workable declassification decentralized environment 
important issue information flow systems precision detection information flow 
information assumed flow program value dependency values 
unidentified dependency create potential information leak 
important avoid false dependencies false dependency results data overly labeled usable situations ought 
provide precise determination data dependencies particularly dependencies arising implicit flows static analysis required dd 
dynamic enforcement information flow control mandatory access control systems dod determine data dependencies conservatively dependencies arising implicit flows results false dependencies overly restrictive labels 
decentralized information flow control central goal information flow control viable technique providing privacy complex decentralized world mutually principals 
involved major components independently useful 
decentralized label model component development new model labeling data supports situations involving mutual distrust 
model allows users control flow information imposing rigid constraints traditional multilevel security system 
provides security guarantees users groups monolithic organization essence provides principal multilevel security 
decentralized information flow model differs previous information flow control introduces notion ownership data allows users explicitly declassify data 
data derived sources sources data agree release 
previous information flow allowed declassification trusted agent trusted subject essentially arbitrary powers declassification notion universally trusted agent clearly inapplicable decentralized environment 
declassification model provides safe escape hatch rigid restrictions strict information flow checking 
deciding declassification appropriate outside scope model inference controls statistical databases developed applicable methods den 
decentralized label model number important properties discussed chapter allows individual principals attach flow policies pieces data 
flow policies principals reflected label data system guarantees policies obeyed simultaneously 
model works principals trust 
model allows principal declassify data modifying flow policies attached label 
arbitrary declassification possible flow policies principals maintained 
declassification permits programmer remove restrictions appropriate example programmer determine amount information leaked acceptable techniques information theory mil 
model compatible static checking information flow 
allows richer set safe relabelings previous label models den fully exploiting information relationships different principals 
formal semantics allows precise characterization relabelings legal 
rule static checking shown sound complete respect formal semantics rule allows safe relabelings allows safe relabelings 
model labels form lattice structure helps static checking programs effective 
model applied dual form yield decentralized integrity policies 
static information flow analysis second component collection new techniques static analysis information flow programs 
techniques incorporated new language jflow extension java language gjs allows information program annotated decentralized labels 
annotations checked statically allowing precise fine grained determination information flows programs previous languages allowing static checking information flow 
approaches po vsi ml sv hr mye jflow treats static checking flow annotations label checking extended form type checking 
programs written jflow checked statically jflow compiler detects information leaks covert storage channels 
jflow intended support writing secure servers applets manipulate sensitive data 
important philosophical difference jflow statically checking information flow focus usable programming model avoiding unnecessary restrictiveness earlier systems static flow analysis 
jflow provides practical programming model earlier 
goal add power static checking framework allow reasonable programs written natural manner 
jflow program jflow compiler java source label annotations jflow compiler java compiler class file bytecode adding power required new contributions 
jflow extends complex programming language supports language features integrated previously static flow checking including mutable objects complex function values subclassing dynamic type tests access control exceptions 
jflow provides powerful new features information flow checking restrictive convenient previous models label polymorphism allows writing code generic respect security class data manipulates 
run time label checking class label values create dynamic escape cases static checking restrictive 
run time checks statically checked ensure information leaked success failure run time check 
automatic label inference unnecessary write annotations required 
statically checked declassification operator allows safe declassification described decentralized label model 
jflow compiler structured source source translator output standard java program compiled java compiler 
operation compiler depicted 
input compiler text jflow program compiled bytecode external program modules program 
model compilation exactly java 
information compiler checks jflow programs translates equivalent java program converted executable form standard java compiler 
addition jflow compiler generates auxiliary file containing information label annotations program 
auxiliary file conjunction compiled bytecode file program external module purpose compiling code depends shown dashed arrow 
labeled inputs program annotations trusted static checker executable program labeled data trusted execution platform labeled outputs part translation involves removal static annotations jflow program checking course 
reason little code space data space run time overhead checking performed statically 
trusted computing base important aspect security mechanism identification trusted computing base tcb set hardware software function correctly order security maintained 
trusted computing base includes usual trusted components hardware subverted trustworthy underlying operating system reliable authentication mechanism 
conventional security mechanisms programs part trusted computing base respect protection privacy internal mechanism ensuring programs respect privacy 
privacy protected necessary programs transfer information ways violate 
model static checker rejects programs containing information flows violate privacy 
static checker may compiler statically checks information flows program digitally signs program verifier checks compiler 
trusted components trusted execution platform 
depicts trusted execution platform code may enter checked statically ensure may trusted obey label model 
data system labeled inputs outputs system 
trusted computational environment constructed trusted nodes connected network communication links nodes trusted accomplished phys ical security encrypting digitally signing communication nodes 
unrelated third parties assumed unable violate privacy integrity snooping subverting channels directly question addressed prevent intended receiver information transfer violating privacy 
applications goal new information flow control system support secure distributed computation including useful applications node share information downloaded program prevent mobile code leaking information additionally program protected leaking private information programs running node 
kind security mobile code useful clients download applet code servers servers upload servlet code data clients remote evaluation 
secure servers heavily applications written programming languages extended information flow annotations adding confidence sensitive information revealed clients service programming errors 
trusted parties provide secure computation servers allow mutually parties carry computations securely privately trusts programs respect security 
architecture solution problem arises party trusts execution platform tax preparation example 
trustworthy platform computation service economic value provider charge 
annotations jflow programming language extend conventional programming languages intermediate code java virtual machine bytecode ly machine code labeling system defined basis easily checkable security proofs proof carrying code nec 
approach producing proof annotations compiler generate product static checking approach shown checkable type safe machine code mwcg ought applicable information flow labels 
limitations static analysis techniques developed chapters intended control covert legitimate storage channels 
techniques deal timing channels harder control 
static analysis applied program executed identify covert channels exist level abstraction programming language 
covert channels timing channels ruled single threaded system 
multi threaded system information may communicated covert channels cache timing 
covert channels sort identified analysis program source code form source code high level abstraction 
outline remainder thesis structured follows 
chapter describes decentralized label model demonstrates formal properties 
chapter presents jflow programming language extends java language support information flow control 
chapter shows information flow jflow language checked statically process similar type checking certain aspects static checking source source translation deferred chapter 
security techniques related privacy protection discussed chapter 
chapter concludes offers thoughts extensions 
chapter label model chapter describes decentralized label model 
earlier ml ml developed thesis 
key new feature decentralized label model supports computation environment mutual distrust 
ability handle mutual distrust achieved attaching notion ownership information flow policies 
policies modified safely owners form safe declassification 
arbitrary declassification possible flow policies principals remain force 
decentralized label model supports richer set safe relabelings earlier models 
example enables user define personal set sensitivity levels data value relabeled upward sensitivity independently user 
allows information flow policies defined conveniently terms groups roles 
rule relabeling data shown sound complete respect simple formal semantics labels rule allows safe relabelings allows safe relabelings 
decentralized label model important property supports static checking information flow including ability infer information flow labels automatically 
discussion static checking model integrated programming language deferred chapters 
chapter demonstrate model necessary properties support integration 
chapter structure section essentials label model 
section provides examples showing label model applied applications 
sections develop model carefully 
section gives formal semantics labels system section uses semantics develop powerful rules manipulating labels 
output channels discussed section 
section discusses ways labels principals generalized allow convenient modeling security requirements 
acts basic model amy students bob principal hierarchy examples carl carl chair carl advisor section presents essentials decentralized label model principals entities privacy protected model labels way principals express privacy concerns 
rules followed computation proceeds order avoid information leaks described including mechanism safe declassification model 
principals decentralized label model information owned updated released principals users authority entities groups roles 
example users groups unix modeled principals 
model principals authorized act principals acts relation reflexive transitive defining hierarchy partial order principals 
relation similar speaks relation principal hierarchy similar role hierarchy san 
acts relation model groups roles conveniently shown 
arrows indicate acts relations 
group students modeled authorizing principals representing members group amy bob act group principal 
role restrictive form user authority modeled authorizing user principal act role principal 
roles carl chair carl advisor roles principal carl fill 
information structure principal hierarchy maintained secure database 
principal hierarchy changes time revocations assumed occur infrequently 
handling revocation discussed section 
simple model principals easily generalized provide complete modeling groups roles entities extensions explored section 
labels value computed program execution associated label 
see label value functions kind type program expressions said label 
label set policies express privacy requirements 
privacy policy parts owner set readers written form owner readers 
owner policy principal data observed order construct value labeled policy 
readers policy set principals permitted owner read data 
implicitly understood owner policy permits read data explicitly reader 
principals permitted read data 
intuitive meaning label policy label obeyed data flows system labeled information released consensus owners 
principal may read data reader owner policy label 
intersection policies enforced adding policies label restricts propagation labeled data 
example expression denotes label denote principals 
semicolons separate policies label 
owners policies reader sets policies respectively 
policy readers means owner policy able read data 
example label containing policy equivalent label 
label contain policy owned principal effect care data propagates 
policy listed possible principals readers 
restrictive label possible label containing policies principal expressed interest restraining data label 
label written empty set 
label contains policies owner policies enforced independently just policies principal may read labeled data policies permit principal reader 
policy part label notation denotes owner policy notation denotes set readers specified policy 
functions completely characterize label types policy principal policy set principal respectively 
compactness single argument functions expressed arguments example ok 
equations chapter letters denote label policies 
relabeling restriction program computes information manipulates leak long labels information obey certain rules 
consider rules arguably simplest computation performed program assignment value variable 
model variable label applies data variable 
value read variable label variable 
value stored variable label value forgotten effectively acquires label variable stored 
assignment value variable causes relabeling copy value assigned 
avoid leaking information label copied value label variable restrictive original label value 
kind relabeling termed restriction 
expression means label restrictive equal label alternatively restrictive values relabeled 
definition assignment value variable legal lx lv lv labels respectively 
relabeling restriction policies old label guaranteed enforced new label 
policy guaranteed enforced policy policies owner reader set subset reader set observation leads subset relabeling rule relabeling restriction subset rule ok oj rk rj relabelings restrictions rule assuming letters denote principals subset relabeling rule sound captures relabelings safe regardless principal hierarchy 
knowledge principal hierarchy available additional relabelings determined safe 
presentation permissive relabeling rule wait formal semantics labels developed section defining means relabeling safe 
model variables statically bound labels value loses label assignment 
approach supporting variables differs dynamic binding approach systems label variable automatically restrictive restricted value written 
dynamic binding requires run time overhead prevents static analysis 
lead label creep variable gradually restrictive unusable 
jflow type protected described chapter provide behavior dynamically labeled variable needed 
computation label join computation values derived values 
derived value may contain information sources label reflect policies sources 
example multiply integers product label restrictive labels operands 
avoid unnecessarily restricting result computation result restrictive label restrictive labels operand upper bound join operand labels respect relation join operands constructed simply union sets policies operand labels ensuring policies operands enforced result 
example join labels 
labels join written defined follows join rule rule ensures policies label value propagate labels values affects protecting privacy data computation 
rule restrictive way relax policies needed 
relabeling declassification labels model contain information owners labeled data owners retain control dissemination data relax overly restrictive policies appropriate 
safe form declassification provides second way relabeling data 
ability process declassify data depends authority possessed process 
moment executing program process authorized act behalf possibly empty set principals 
set principals referred authority process 
process authority act principal actions performed process assumed authorized principal 
code running authority principal declassify data creating copy label policy owned principal relaxed 
label copy readers may added reader set policy may removed entirely effectively allowing readers 
declassification applies owner basis centralized declassification process needed systems lack ownership labeling 
declassification limited affect policies owners process act declassification safe owners reading occurs consensus owners 
declassification mechanism clear labels maintain independent reader sets owning principal 
example label consisted just owner set reader set information individual flow policies lost reducing power declassification 
ability declassify depends run time authority process requires run time check proper authority 
shown chapter overhead run time check reduced proper static framework 
declassification described formally 
process may weaken remove policies owned principals part authority 
label may relabeled long la label containing exactly policies form principal current authority 
rule declassification may expressed inference rule relabeling declassification la current authority la may declassified inference rule builds rule relabeling restriction 
subset rule relabeling states policies policy restrictive 
declassification rule intended effect policies owned principal current authority restrictive policy la policies corresponding policy current authority power weaken 
rule shows label may declassified label relabeled restriction restriction condition implies antecedent la channels model users assumed external system programs run 
information leaked leaves system 
giving private data untrusted program create information leak program runs authority principal long program obeys label rules described 
information leaked leaves system output channel output channels labeled prevent leaks 
information enter system input channel labeled prevent leaks 
safe process manipulate data principal authority right read process data write variable channel label restrictive 
input output channels half variables variables associated label information conduit 
provide half functionality variable provides input output 
variable value read input channel value acquires label input channel 
similarly value may written output channel label output channel restrictive label value information leak presumed occur 
obviously assignment labels channels security critical operation 
important channel label reflect reality 
example output printer read number people important output channel printer identify information leak possible 
computers communicate channels important labels matching output input channels agree labels round trip 
typically output input channel label containing single policy multiple policy channels 
output channel owner policy thought data released principals listed reader set policy 
clear final tax form intermediate results bob bob preparer preparer bob bob bob spreadsheet preparer database tax data bob bob network preparer preparer annotated tax preparation example data principal written output channel trusts owner output channel readers output channel subset readers allows 
conversely owner input channel principal demands data arriving channel may released listed readers 
policy may overridden owner principal act owner 
multiple policy channels policy acts additional requirement release data 
examples consider examples decentralized label model helpful protecting privacy 
examples illustrate intuitions model demonstrate capture security needs interesting useful computations 
tax preparer example tax preparer example illustrated identical example chapter data example annotated labels protect privacy bob preparer 
seen labels obey rules meet security goals set chapter scenario 
ovals indicate programs executing system 
boldface label oval indicates authority program acts 
example principals involved bob preparer seen give authority spreadsheet programs respectively 
arrows diagrams represent information flows principals square boxes represent information flowing databases sort 
bob applies label bob bob tax data 
label allows read data hmo hmo records patient patient acts doctor doctor doctors hospital principal hierarchy bob 
label applied tax data sent untrusted network location represented output channel label case bob bob 
bob give data program reasonable confidence leaked unable remove bob bob policy tax data data derived 
program uses bob tax data private database compute tax form 
intermediate results computed data sources label bob bob preparer preparer 
reader sets label disagree label prevents bob preparer reading intermediate results 
joint label generated rule join bob bob preparer preparer bob bob preparer preparer preparer protected label accidental disclosure private database programming errors application 
released bob final tax form label intermediate results readable bob appropriately 
order tax form readable application label removing preparer preparer policy 
application preparer principal granted application authority 
authority reasonable preparer supplied application presumably trusts power maliciously 
authority act preparer need possessed entire application part performs final release tax form 
limiting authority small portion application risk accidental release database reduced 
important part application exposed generally accessible external interface exposure allow bob parties misuse interface declassify data owned preparer 
hospital example example parties privacy concerns patient obtaining medical services doctor providing services health maintenance organization hmo serves intermediary 
principals system patients patient doctors doctor additionally doctors act principal doctors represents group doctors hmo 
hmo principals exist hmo representing maximum authority hmo hmo records representing authority record keeping functions hmo hmo act hmo records records hmo logs hmo records hmo audit program hmo records doctor report hmo patient patient doctors patient patient doctor hmo records hmo doctor doctor patient record general information patient patient doctors patient confidential patient patient hmo confidential hmo records hmo report patient patient display device hmo records doctor hospital example patient authorization authorized declassification procedure hmo records edited copy patient record general information patient patient doctors patient confidential patient patient doctor hmo confidential hmo records hmo doctor act patients patient trust hmo keep track records 
resulting principal hierarchy shown 
shows hospital example shows information flows patient receives medical services 
hmo maintains patient medical history parts general information controlled patient readable doctor private information medical history patient normally readable doctors confidential information hmo release patients 
step patient doctor interaction doctor obtain copy patient record 
record declassified doctor read happen authorization patient 
patient represented diagram dark oval labeled patient authenticated request existing program running authority hmo records program uses patient authority provide doctor edited version patient private information hmo confidential information 
doctor represented dark oval labeled doctor read information doctor requires output channel display device single reader doctor display device certified hmo records secure device doctor reading 
principle information patient records safe write display device subset relabeling rule permit 
example motivates development better relabeling rule developed sections 
writing information display device safe hmo records act owners data patient records patient hmo records certification 
addition various parts patient record released doctors doctor actual reader doctor act principals 
note patient information written channel readers doctor way doctor declassify patient information 
eventually doctor sends report hmo services rendered 
addition comments doctor report contain information components patient record acquires joint label reflecting sources 
note general patient information explicitly permit doctor reader 
subset relabeling rule policy owned patient resulting joint label prevents doctor reading report 
example unnecessary restrictiveness arises subset relabeling rule fixed flexible relabeling rule developed 
audit program runs authority hmo records principal store information appropriate labels log patient record database 
send report patient tax preparer example designer audit program mechanisms outside scope information flow control determine hmo confidential information leaked leak acceptably small 
extending interpreting labels hospital example previous section shows basic model powerful permissive relabeling rule needed takes principal hierarchy account 
section formalizes notions labels principal hierarchies defines condition judging relabeling rule correct 
limitations subset relabeling rule way think relabeling rule safe considering incremental relabelings label restrictive leave equally restrictive 
relabeling rules discussed thesis understood terms incremental relabelings allow 
example subset relabeling rule allows kinds incremental relabelings label restrictive possibly effect 

removing reader policy restrict propagation labeled data effect 
adding policy 
similarly adding new policy restrict data policies label enforced 
sequence relabelings result label restrictive original 
compare labels see sequence incremental relabelings trivial 
subset relabeling rule defined earlier clearly sound permits value relabeled restrictive label 
prevents valid relabelings 
kinds relabelings existence acts relationship principals adding readers 
possible add reader policy policy allows reader acts 
rule safe acts privileges allowing read data allows principals act read 
replacing owners 
possible replace owner principal acts rule safe new label allows processes act declassify original label allows processes weaker authority declassify 
self authorization 
principal owner policy safe add reader principal acts consider owner policy reader reasonable allow owner added explicitly list readers 
similarly addition readers act owner allowed 
readers may added doctor example able view report 
confidential patient information label patient patient doctors allows doctor view data item possible relabel item explicitly allow particular doctor view patient patient doctor 
doctor doctor view report doctor reader policy joint label 
owners may replaced output channel hospital example intended 
output channel labeled hmo records doctor means hmo records division certified doctor reader channel 
label display device display information patient record principal hmo records acts patient global notion principals read output channel data owned owner written channel trusts hmo records division hmo records act 
self authorization rule add significant power label model policy owner added explicitly reader policy 
expression common labels concise 
subset relabeling rule relabelings add readers replace owners done process sufficient authority declassification mechanism 
relabelings restrictions safe process perform regardless authority 
direct support relabelings consistent principle privilege sal avoids unnecessarily excessive privilege processes 
extending label model support relabelings facilitates modeling desirable security policies 
example suppose user wants define security classes multi level fashion personal unclassified classified classes protecting data 
extensions security classes represented principals system secret principal act classified unclassified 
user assign security classes principals system allowing act principals user correspondingly marks data item readable appropriate security class principal 
trivial extend relabeling rule permit relabelings want preserve ability analyze information flow statically 
pointed denning denning dd information flow checked statically compile time avoid leaks implicit flows discussed section 
new relabelings depend principal hierarchy exists run time 
principal hierarchy exists run time differ principal hierarchy compile time rule relabeling principal hierarchy changes 
trick check relabelings statically rule ensures relabelings safe hierarchies encountered run time point program 
problem addressed steps 
remainder section presents formal model labels allows precise definition legal relabelings 
section defines rules static checking shows sound complete 
interpreting labels relabeling allowed create new ways relabeled information flow 
characterize rule precisely need way interpret label decide information flows described label 
useful think label describing set flows flow owner reader pair 
set denoted flows label interpretation 
represents flow information owner reader interpretation label contains flow means principal labeled data may read principal general interpretation label includes flows explicitly stated label 
subset relabeling rule corresponds literal interpretation label set flows label policy interpretation contains flows ok reader set rk 
principal owner label interpretation contains flows principal words permits flows principal expressed flow policy labeled data care flows 
example system containing principals label interpreted set flows 
flows principal owner flows allows readers 
principal owner multiple policies ki label describes flows readers intersection sets 
interpretation function maps labels sets flows called 
label expression simple literal interpretation set flows 
seen subset relabeling rule restrictive support certain safe relabelings take principal hierarchy account 
flexible relabeling rule requires interpretation function take principal hierarchy account 
despite limitations interpretation shorthand expressing sets flows precisely literal 
writing sets flows inconvenient sets flows usually large contain uninteresting flows flows principals owners 
set flows expressed unambiguously manner independent principal hierarchy writing label interpretation set flows 
set flows interest label constructed easily interpretation set flows chapter labels place longer sets flows meaning 
formalizing principal hierarchy express richer interpretation precisely necessary clarify idea principal hierarchy 
act denoted formally expression binary relation reflexive transitive anti symmetric distinct principals may act case principals said equivalent 
relation sort called pre order 
notation indicates principal act principal principal hierarchy principal hierarchy pre order principals treated set ordered pairs principals specifies relations exist 
interpretation equivalent principal hierarchy contains acts relations say extends written space principals assumed infinite immutable pre existing 
course real implementation finite allow creation new principals 
model creation new principal treated assignment new meaning existing unused principal 
advantage treatment principal hierarchy just set acts relations specify set principals 
label interpretation function idea richer interpretation actual flows denoted label depend principal hierarchy 
label interpretation function form function defined label interpreted principal hierarchy interpreted 
current principal hierarchy implicit argument set flows xl interpretation label informally function defined follows flow denoted label policy owner act permits flow explicitly member reader set owner implicitly principal member reader set owner policy owner act flow permitted care data propagates 
intuitions new interpretation 
policy lists reader reader policy implicitly authorizes readers principals implicit authorization sense possess power 
second suppose policy label owned principal case label contains policies owned principal acts policies reader sets identical policy words policies dictated apply principal acts 
sections basis interpretation function developed carefully formally specifying showing constructed 
complex interpretation develop restrictive relabeling rule 
flow set constraints consider label set flows see constraints set flows ought satisfy particular principal hierarchy constraint readers owners 
set flows sense satisfies constraints 
see constraints underlie label interpretation function just described 
reader constraint corresponds intuition just described set flows contains flow andr principal act set contain flow 
example label patient doctors equivalent label patient doctors doctor principal doctor act principal doctors 
reader constraint stated formally follows symbol implication xl xl reader constraint sufficient want allow relabelings change label owners 
consider relabeling patient doctor hmo records doctor 
relabeling effectively transfers responsibility controlling flow data principal patient principal hmo records 
transfer restricts data flow hmo records act patient key insight allowing kind relabeling owner constraint xl xl interpretation constraint superior owner states flow occur flow removed reader sets inferior owners principals superior owner acts 
restrictions applied superior owners apply inferior owners 
superior owner doctor doctors small principal hierarchy try prevent flow inferior owners may prevent 
inferior owner policy restrictive superior owner policy 
constraint label hmo records doctor equivalent label hmo records doctor patient doctor principal hierarchy 
label allow flows patient readers flow allows patient patient doctor hmo records patient hmo records policy allows flow doctor label functions help construct label interpretation function functions defined establish reader owner constraints 
function expands set readers policy include readers implicitly allowed reader constraint owner policy principals act 
policy function produces expanded policy ri 
notation oi ri denote policy owner oi readers ri function defined follows ri oi oi ri function expressed concisely function yields reader set policy plus owner ri oi ri oi convenience application function entire label defined label produced applying individual policies rl ri 
suppose applied policy label doctors patient doctor patient patient principal hierarchy containing single relation doctor doctors shown 
case rl doctors patient doctors doctor doctor patient patient doctor 
note doctors self authorizes reader policy doctor reader acts doctors 
establish owner constraint function converts label set flows restricting 
generates flow operative policies label policies oi allow flow 
intuitive effect remove flows violate owner constraint 
ol oi ri function generates flow policies label oi case implication vacuously true policies flows capture intuition principal policy allows flows possible readers 
example consider applying rl previous example 
set flows results interpretation label doctors patient doctor doctor patient patient doctor 
notice set flows includes flow doctor doctor doctors doctors policy rl specify flow 
flow doctors doctors eliminated owner second policy doctor allow flow doctors acts owner policy doctors 
expect monotonic respect reader sets applied sense ri ri oi oi 
monotonic reader sets labels differ reader sets respective policies oi oi ri ri ol 
functions differ behavior principal hierarchy changes 
show principal hierarchy appear explicit argument functions 
principal hierarchy extension relations hold rr rr function anti monotonic argument composing functions obtain label interpretation function maps label set flows particular principal hierarchy 
definition interpretation function xl orl ri oi oi oi ri result xl satisfies reader owner constraints preserves reader constraint established policy result formula meaning informal definition earlier section 
seen example application label doctors patient doctor patient patient earlier examples applied sequentially just definition function express correctness condition relabeling presence arbitrary principal hierarchy 
relabeling principal hierarchy valid long new flows added 
making principal hierarchy explicit argument correctness condition correctness condition relabeling safe apply rule show validity relabeling patient doctors hmo records doctor principal hierarchy 
applying gives set containing flow hmo records doctor doctor patient hmo acts patients flows unrelated owners readers applying gives set containing pairs hmo records example 
xl xl relabeling safe 
function composition monotonic respect reader sets monotonic anti monotonic respect interesting properties 
interpret set produced applying label label large write label flow mentioned explicitly flows owners allow readers 
interpretation see function idempotent xl xxl 
checking relabeling statically static checking programs containing label annotations desirable allows precise fine grained analysis information flows capture implicit flows properly dd dynamic label checks create information channels controlled additional static checking ml 
correctness condition xl xl derived section directly static checking depends principal hierarchy time relabeling takes place static checking done earlier part compilation 
principal hierarchy may changed compilation execution full run time principal hierarchy available relabeling checked 
relabeling checked partial information principal hierarchy 
section general rule developed checking relabelings statically partial information principal hierarchy 
section begins giving sketch programs annotated 
section demonstrates defining sound relabeling rule static environment non trivial 
section defines relabeling rule static checking shows sound complete 
section shows label model lattice properties needed support label checking automatic label inference static environment 
annotations int patient doctors int patient doctor actsfor doctor doctors assignment static principal hierarchy programs statically annotated information labels data manipulate 
static label checker uses annotations analyze information flows programs determine program follows information flow rules described 
chapters set language annotations described permits static information flow checking 
summarizes features important understanding static analysis affects model variables arguments procedure return values labeled types 
example labeled integer variable declared int patient doctors 
label may omitted local variable causing inferred automatically 
label omitted procedure argument implicit parameter procedure generic respect 
statement actsfor allows run time test structure principal hierarchy 
statement executed principal act principal 
label checker uses knowledge checking relabelings occur statement optional clause executed specified relationship exist 
expression declassify value label label may add readers label owners oi remove owners oi statement legal statically known process act oi 
procedures assigned principal compiled principal derives user running compilation 
procedure called runs authority 
code calls procedure called procedure authority act principals caller acts explicitly 
example assignment legal body actsfor statement checker knows doctor act doctors 
program statement label checker verifies acts relations determined exist lexical nesting actsfor statements 
relations form subset true principal hierarchy exists run time known statically true principal hierarchy contains explicitly stated acts relations 
fairly general model programming static information flow annotations challenge define sound conservative rule checking relabelings 
static correctness condition program assigns value variable data assigned value label changed label variable 
relabeling sound long create new ways assigned data flow 
example sound relabeling rule original subset relabeling rule section 
rule monotonicity guarantees correctness condition holds regardless run time principal hierarchy 
subset relabeling rule seen excessively restrictive 
rule uses information principal hierarchy available statically 
principal hierarchy contains acts relations statically known containing actsfor statements 
principal hierarchy called static principal hierarchy 
actual principal hierarchy run time extension contain acts relations may contain additional relations 
actual principal hierarchy notation introducing principal hierarchy explicit argument function correctness condition says safe relabel condition holds time static checking static correctness condition relabeling statically safe interesting note restrictive static correctness condition checking subset relabeling rule difference allows self authorization 
subset relabeling rule expresses requirement relabeling safe principal hierarchies want relabeling rule takes advantage information run time principal hierarchy expressed condition static correctness condition 
expect check relabeling valid check weaker condition simply applies correctness condition directly static hierarchy construction rule allows valid relabelings take place relabeling allowed rule creates new flows principal hierarchy rule necessary sufficient 
example show rule sound 
consider bad relabeling label examples section doctors patient doctor patient patient doctors staff patient doctor patient patient consider happens apply labels assuming principal hierarchy contains single relation doctor doctors known hold compile time words principal hierarchy shown 
result applied label set flows written label brevity interpretation xl doctors patient doctor doctor patient patient doctor xl doctors patient doctor doctor patient patient doctor note xl contain flow doctors staff superior owner doctor rules 
relabeling safe label interpretations equal 
suppose run time principal hierarchy shown patient staff member patient staff 
applying label hierarchy leads quite different xl doctors patient doctor doctor patient patient doctor xl doctors patient patient doctor doctor patient patient doctor relabeling invalid principal hierarchy adds flow doctors patient 
example shows correctness condition applied directly static relabeling rule 
sound complete relabeling rule examine relabeling rule 
relabeled principal hierarchy written expression defined formally follows doctor doctors doctor doctors small principal hierarchies patient staff definition complete relabeling rule oj oi rj rr oj oi rj rj rj oi ri ri rj ri oj oi rr oj oi rj ri rj ri rule checking relabeling label label straightforward policy corresponding policy restrictive policy restrictive principal hierarchy expressed defined formally 
condition described informally covers informally relabeling rule says policy may replaced policy covers 
policy covering rule stated different ways 
second fourth statements policy covering rule simply expansions third respectively may obvious third definitions equivalent 
definition contains condition rj rr third replaces condition rr 
definition implies third oj oi implies rr implies rr conjunction rj rr 
third definition implies statement rj transitively implies rj rr 
definitions equivalent 
complete relabeling rule sections convenient definition selected 
difference relabeling rule unsafe relabeling rule section explained simply 
rule says policy asingle policy cover 
earlier unsafe rule effectively allows multiple policies cover policy 
principal hierarchy extended policies interact unexpected ways fail cover binary relation defined labels principal hierarchy relation pre order transitive reflexive anti symmetric labels may equivalent equal 
equivalent write mean example hierarchy labels hmo doctors hmo doctors doctor equivalent 
principal hierarchy generates pre order labels defining legal relabelings 
nature relabeling rule understood considering incremental relabelings permits 
seen section subset relabeling rule characterized incremental relabeling rules 
new relabeling rule allows additional relabelings described section subset relabeling rule permit 
result new rule allows arbitrary sequence kinds relabelings sound individually reader may dropped owner reader set 
new owner may added label arbitrary reader set 
reader may added acts member reader set 
owner may replaced owner acts 
reader may added acts owner 
interestingly incremental relabelings capture sound relabelings 
words rule page sound complete called complete relabeling rule 
rule complete sense exactly captures set valid relabelings respect static correctness condition defined section assumptions static checking environment 
consider proofs statements figures 
relabeling rule checked soundness counter example generator jd 
soundness 
rule sound relabeling rule holds principal hierarchy correctness condition holds possible extensions formal proof statement definition policies page 
comments proof notation order 
proof hypothesis indicated increase level indentation 
notation right hand columns substituted statement 
step happens formula replaced fresh variable step happens formula xp instantiated existing expression producing step 
proof argued informally follows 
soundness proved contradiction 
suppose relabeled andx contain flow 
show relabeling safe 
policy suppresses rr oi 
policy covers rr oj oi 
oj oi oj oi transitively oj assume flow 
show generates contradiction 
oj reader 
rr member rr 
reader means transitively 
contradicts statement rr 
contradiction conclude 
flows flow 
relabeling rule sound 
assumption assumption arbitrary assumption arbitrary assumption defn 
oi rr defn 
oi rr defn 
oi rr defn 
oj oi rr defn 
oj oi oj oj rr rr defn 
rj ri rj ri defn 
ri ri rj ri contradiction completeness 
show converse proof soundness prove statement contradiction relabeling rejected rule find 
words relabeling rejected result leak 
proof formally figures 
part shows construct new principal hierarchy part shows relabeling unsound principal hierarchy 
argument goes follows policy policy oj oi rj 
consider arbitrary policy 
relabeling leaks policy reader rj rj rj rj 
readers rj construct principal hierarchy extends results leak 
assumption defn 
oj oi rj rj rj rr defn 
skolem function maps oj oi corresponding rj described step oj oi fj rr define oj oi define fresh principal relation principal hierarchy owners readers 
rall define define rall rall fj define rall fj proof completeness part consider principal hierarchy exactly additional principal unrelated owners readers 
assumed new principals added principal hierarchy static checking principal potentially exists 
form adding relation rj rj transitive closure rj rj note pre order relation member transitive closure reflexive relation pre order 
definition oi oi relabeling causes leak relabeling rule complete 
completeness result strengthened 
rule complete presence negative information relationships principal hierarchy 
fact negative information available clause actsfor statement 
actsfor tests principal act body clause known statically specified principal relationship exist 
static information establish upper bound dynamic principal hierarchy just static principal hierarchy establishes lower bound 
upper bound useful checking relabelings proof completeness holds presence upper bound choose arbitrary mentioned upper bound 
static checking label model certain lattice properties order support static checking 
checking assignments explained complete relabeling rule 
labels compared may oi assumption oi oi rr defn 
oi oi rr rr reflexivity defn 
fj oj oi fj fj rr fj defn 
fj contradiction oi oi assumption oi oi defn 
oj oi rr oj oi assumption oj oi oj contradiction oj oi fj define rr defn 
contradiction oi proof completeness part results joins account computations meets occur process automatic label inference 
join meet defined 
join defined earlier section revisited context new definition relation labels form pre order lattice partial order labels equivalent equal 
labels preserve important properties lattice static reasoning information flow feasible pair elements possesses upper bounds greatest lower bounds 
labels form pre order bounds equivalence classes labels single labels 
set labels bottom element label 
mathematical completeness set labels considered top element restrictive label 
addition join meet operations distribute 
definitions join meet desirable properties join meet easy evaluate resulting labels easy deal applying complete relabeling rule 
join 
new definition relation revisit definition join upper bound labels 
join useful assigning label result operation combines values adding numbers 
result adding numbers ought general restricted numbers added 
restrict sum unnecessarily assigned restrictive label restrictive input labels 
lattice unique label uniqueness important purposes 
label equivalence class acceptable long relabeled label restrictive input labels 
join label expressions defined quite simply definition section holds complete relabeling rule definition join examples join expressions principals unrelated acts relation doing join compiler simplify label expression removing redundant policies checking steps run efficiently 
simplification performed second example policy redundant third example 
policy redundant relabeling rules behave identically label regardless policy 
policy policy redundant static principal hierarchy covers 
second join example relation true policy redundant join result 
see important owners repeatable labels completes lattice equivalence classes 
repeated owners allowed upper bound pairs labels 
consider third example disallowing repeated owners 
principal principal restrictive labels relabeled include relabeled 
upper bounds different equivalence classes upper bound labels 
join operation just described produces upper bound labels 
seen interpreting join result set flows extended principal hierarchy follows directly definition hierarchies result follows xl takes intersection sets flows generates policies label equation means label restrictive relabeled 
result join operator relabeled label relabeled label property equivalence class result join operator interpretation set flows 
equivalence class defines upper bound labels 
declassification 
section rule declassification follows label may relabeled long la label containing exactly policies form principal process act 
definition continues intended effect complete relabeling rule performed statically static notion process authority called static authority 
capable relabeling la policy covered policy la policies owned principal static authority automatically covered policies la policies owned principal static authority need covered effect policies owned static authority may weakened arbitrarily declassification 
reasoning joins 
policies join independently relabeled declassified 
property important allows checking code generic respect labels appear 
case declassification surprises principal set flows added join subset set flows added individual policies 
interactions parts join create new unexpected flows 
forexample relabeled thenl relabeled regardless may unknown label label determined run time invalidating relabeling 
similarly declassified thenl declassified 
relabelings join guarantees policies respected 
meet 
meet greatest lower bound labels restrictive label relabeled 
meet labels produced computations program execution useful defining algorithms automatic label inference dd ml 
meet useful definition meet ai bj ai bj meet labels inferring labels inputs automatically just join useful producing labels outputs 
example code restrictive label expressed meet int int int example variables labels respectively 
variable assigned label long relabeled upper bound label algorithm inferring variable labels described chapter uses succession meet operations fashion refining unknown variable labels downward variables consistent assignments contradiction reached 
construct meet labels consider meet policies statically known relation owners policies meet label relabeled result obtained uninterpreted known owners relationship known statically exist containing actsfor statement 
suppose rn 
act equal meet policies rn 
ifo equivalent equal meet policies rn rn 
label equivalent simpler labels rn chosen symmetrical respect policies 
consider meet arbitrary labels 
label containing policies join policies meet computed distributing meet joins 
result meet shown join pairwise meets policies policy label 
labels composed policies ai bj respectively 
pairwise meets ai bj may produce label course dropped join 
join validity formula meet seen interpretation function extension principal hierarchy compute meet labels relation holds formula join definition meet produce restrictive label possible extensions produces restrictive label existing static principal hierarchy 
result occurs rule joining policies returns owners known statically relationship run time hierarchy relationship may exist 
practical effect label inference conservative cases 
cases significant problem explicit label declarations cases explicitly declared label restrictive cause static checking fail 
distribution properties 
shown straightforwardly join meet distribute expected way distributive lattices producing equivalent labels means static checker doing label inference described ml rely properties meet join simplify label expressions 
equation follows trivially definition meet ai bj ck ai bj ai ck proving second equation slightly harder ai bj ai ck ai ai bj ai ck bj ck ai ai ai bj ai ck bj ck ai bj ck fourth step bit tricky relying absorption property policies property term ai redundant terms containing meets ai 
absorption property follows directly definition meet policies label containing policies term redundant 
see consider possible cases result expression wherea rn 
case meet may case absorption property holds second case equivalent case rn rn second policy weaker equal 
absorption property holds third case equivalent rn rn rn second third policies redundant 
output channels assumed private information leaked computation computation performed untrusted programs long label discipline observed 
information leaked transmission outside region labels enforced 
note region enforcement may include computers networks control humans may choose violate rules 
reader set component output channel policy characterization part outside world output channel leads 
essential output channel labeled properly information transmitted output channel label relabeled output channel 
output channel decentralized label need universally accepted notion readers output channel 
effect relabeling rules principal effectively accepts reader set policy owner policy acts fact process creating labeled output channels described neatly additional mechanism 
additional mechanism needed ability create raw output channel output channel label 
data written channel privacy restrictions creation channel safe operation channel leak private data 
labeled output channels constructed top raw channels straightforward manner 
labeled output channel simply function accepts data label performs steps 
optional transformation data encryption public key 
declassification transformed data label 
transmission raw output channel 
step performed function runs authority owners label words labeling system ensures owners policies output channel claims enforce granted authority process creates output channel owners explicitly trust output channel 
owners decide authority output channel outside scope thesis granting authority belief channel delivers data listed readers 
possible reasons belief physical connection raw channel models known secure connection listed readers 
data sent channel encrypted way intended recipients able decrypt 
generalizing labels principals interesting ways extend basic label model described far 
section considered 
integrity policies seen decentralized label model supports labels containing privacy policies 
structure developed point applied integrity policies 
integrity policies bib dual privacy policies 
just privacy policies protect data read improperly passes untrusted programs integrity policies protect data improperly written 
integrity label keeps track sources affected value sources affect value indirectly 
prevents untrustworthy data having effect trusted storage 
structure decentralized integrity policy identical decentralized privacy policy 
owner principal policy enforced set writers principals permitted affect data 
label may contain number integrity policies behalf various owners 
intuitive meaning integrity policy guarantee quality 
policy guarantee principal able affect value data 
restrictive integrity label label containing policies 
label provides guarantees contents labeled value data input receiver imposes integrity requirements 
integrity label variable protected improper modification 
example suppose variable single policy 
value labeled may written variable value affected label variable permit affect 
value labeled write general permitted value affected principal mentioned allowed writer label variable 
permitted 
consider value labeled 
case write permitted policy says believes affected value 
second policy exists behalf affect legality write variable superfluous guarantee quality 
just privacy policies earlier assignment value copied variable avoid violations integrity label variable restrictive label value 
preceding sections relabeling rule developed privacy 
see applied integrity labels 
section said legal relabeling privacy policies characterized set incremental relabelings 
characterization attractive easier judge correctness incremental relabeling 
integrity label incremental relabelings writer may added policy 
addition safe additional writer integrity policy additional warning contamination value restricted subsequent 
policy may removed 
integrity policy may thought assurance principals set writers affected data 
removing assurance safe restricts subsequent value 
policy writer may replaced writer acts 
ability act policy permitting writer permits writers policy permitting general permit replacing really adds writers change safe 
policy may added identical existing policy oi oj 
new policy offers weaker integrity guarantee existing value restrictive addition policy 
principal acts owner policy may removed writer 
restrictive integrity policy principal want express principals act write labeled variable 
owner policy principal acts owner implicitly considered writer need expressed explicitly 
rule equivalent self authorization privacy policies 
kinds relabelings turn capture exactly inverse relabelings allowed incremental rules privacy labels described section 
see consider incremental rules turn 
effect rules reversed applying privacy rules adding writer 
privacy rules permit removing reader 
removing policy 
privacy rules permit adding arbitrary policy 
replacing writer privacy rules allow reader added reader reader removed 
adding policy identical existing policy inferior owner oi oj 
privacy rules allow owner replaced oi making policies identical 
removing owner policy writer set 
owner policy may added reader set policy 
similarly effect privacy rules may reversed applying integrity rules 
privacy labels relabeled sequence incremental privacy relabelings converts 
suppose integrity labels form 
sequence incremental integrity relabelings leading thenl ordering relations privacy integrity labels perfect duals 
property means rules integrity derived directly rules privacy 
just seen privacy labels corresponding integrity labels logical equivalence defines complete relabeling rule integrity terms corresponding rule privacy section 
rules meet join integrity labels similarly expressed terms privacy label counterparts 
rules follow directly dual relationship ordering relation kinds labels 
operationally meet integrity labels performed simply concatenating policies join corresponding privacy labels evaluated join integrity labels corresponds meet corresponding privacy labels 
words meet labels restrictive label restrictive contains policies labels performed union policies 
similarly join integrity labels contain policies enforced labels 
declassification 
analogue declassification exists integrity labels 
privacy labels declassification mechanism allows privacy policies removed cases reasoning outside scope strict dependency analysis tax preparer example suggests policy overly strict 
dual action integrity policies add new integrity policies situations data higher integrity strict dependency analysis suggest 
principal adds new integrity policy label removes writers existing policy represents vote confidence integrity data allows data freely subsequently 
just declassification privacy reasons principal choose lie outside scope model 
adding new policies safe new policy may added current process authority act owner policy 
principals affected trust policy owner extension process performing declassification act 
declassification described formally declassification integrity label label permitted li integrity label policy principal authority process 
policy lists principals system writers 
note duality rule rule declassification privacy labels 
code labels 
integrity labels introduce new issue code damage integrity access extra labeled resource 
example routine alleged add numbers perform different computation destroying integrity 
keep track effect integrity label assigned function program joined value computed function 
program expression sub expressions andy associated integrity label 
code labels applied privacy utility case code secret 
privacy integrity natural default code label 
default label quite different effects kinds labels 
label restrictive privacy label effect joined label 
integrity label restrictive label offers guarantee integrity data computed function 
integrity label offers quality guarantee authority needed label code specifically authority act owners integrity policies label 
expect owner integrity label typically author code 
author appear writer integrity label 
combining integrity privacy set privacy labels called sp set integrity labels si form pre order ordering relations respectively 
kinds labels generate system combined labels enforce privacy integrity constraints simultaneously 
combined label written sequence privacy integrity policies 
disambiguate kinds policies privacy policies written form integrity policies written form arrows suggest direction information flow 
combined label considered pair lp li member set sp si 
ordering relation combined labels join meet operations easily defined usual way product spaces ordered sets lp li lp li lp li lp li li lp li lp li li similarly combined label lp li declassified combined label components declassified 
lp refer label called la earlier 
lp lpa li li lp li declassified summary rules combined labels integrity privacy policies independently enforced interact 
generalizing principals acts relation principals principal hierarchy powerful concepts apparent 
principals represent broader range entities users groups roles 
readers writers policies principals may represent input output devices user defined privacy integrity levels compartments 
necessary owners readers writers kinds entities 
notation section external connection user cable represented output channel single policy privacy label root cable root trusted principal 
information marked readable cable principal prevented transmission cable 
having cable principal readers output channel way reflecting danger cable may leak information way 
similarly cable input channel assigned integrity policy root cable indicate data input channel passed cable way system conceivably damaged transit 
principal hierarchy establish categories devices 
principal cable acts principal secure channel effectively secure channel devices interoperate labels expressed terms secure channel terms specific devices 
user express trust secure channels allowing secure channel principal act user principal trust allow data lists user reader sent channel assuming policy owners required degree trust 
see moment trust secure channel principal needed expect 
users establish privacy levels introducing new role principals represent privacy levels 
acts relation principals expresses information flows allowed levels absence declassification 
example user jobs information default kept 
suppose amy manager committee chair 
concerns addressed introducing new principals amy manager amy chair shown 
long amy assume full power amy principal data allowed move compartments 
declassification mechanism available explicit cases deems appropriate 
roles introduced represent user specific integrity levels similar fashion 
unsatisfactory aspect model described far acts relation appears give power 
example approach described modeling group principal members group act group principal 
structure allows group members read read group principal 
gives additional power declassify redistribute publicly owned group 
added power violates principle privilege 
introduce different kinds acts relations group members power read group data declassify 
suppose amy bob group members amy group administrator power declassify data owned group bob group member able merely read data read group 
scenario modeled shown 
diagram shows bob right read group amy full power act group implies ability read declassify group 
new weaker relations transitive reads reads behaves similarly 
understand implications extended acts relations necessary develop new theory labels system containing extended acts relations translated original model 
principal hierarchy pe supporting extended relations translated principal hierarchy contains simple acts relation label names principals pe may translated corresponding label names principals semantics extended system pe determined simply applying existing rules relabeling join meet translated forms labels translation pe performed follows 
principal pe corresponds principals named po pr acts relations shown pr pw amy amy manager amy chair compartments hierarchy bob group amy reads acts modeling group act po 
names suggest principals po pr possible positions occupy label owner reader writer respectively 
privacy label bob group mentions principals translated label bob owner group reader 
pr acts po principal automatically authorized read data owns 
process authority translated pe process running authority runs authority principal po authority principals pr pw process 
shows principal hierarchy translated simpler model 
bob power principal giving right read 
ability amy act principals means declassify data owned group read data readable group 
third relationship amy group self reads relationship means amy read data owned group 
relationship mean amy read data readable group declassify group data 
self reads relationship weaker relationships abilities amy read declassify group imply transitivity amy self reads group 
different kinds acts relations pe hierarchy principals translated follows hierarchy principal reads principal principal principal principal self authorized read self reads pr po po relations correspond incremental relabeling rules defined section reads corresponds rule adding readers corresponds rule replacing owners self reads corresponds rule self authorization 
splitting principals bob bob reads group group reads self reads amy amy modeling group split principals see extended principal hierarchy pe supports new relations indicated writing appropriate subscripts sign 
po reads pr writes pw self reads ro po self writes wo po relations affect privacy reads self reads correspond exactly ways relation second definition relation page 
definition expression oj oi compares owners test relation 
expression rj oi compares reader owner test self reads relation 
rj ri compares readers test reads relation 
complete relabeling rule expressed pe system way enforcing new rule directly effect enforcing original complete relabeling rule translated labels 
new version complete relabeling rule follows oj oi rj rj rj ro oi ri ri rj ri rule model extended acts relations enforced directly pe hierarchy transformation pe original model 
acts relations ro wo viewed access control lists lam 
principal distinct kind acts relation list principals allows act manner 
relations similar access control lists appropriate notion ownership principal typically power change principals lists 
acts relations complete example privilege principal usefully ability modify lists changing principal hierarchy 
privileges management important outside scope 
relations differ usual concept access control lists certain axioms connect relations 
axiom authorization transitive reads reads implies acts reads writes self reads self writes partial order extended acts relations addition relations imply partial order relations shown 
original relation acts gives principal full privileges implies new relations 
summary decentralized label model promising approach specifying information flow policies privacy integrity 
provides considerable flexibility allowing individual principals attach flow policies individual values manipulated program 
flexible labels permit values declassified owner value 
declassification safe affect secrecy guarantees principals interest secrecy data 
support multiple principals label model ideal mutually principals 
important feature decentralized label model complete relabeling rule precisely captures legal relabelings allowed knowledge principal hierarchy available statically 
rule sound complete easy apply 
rule formalized pre order relation distributive lattice properties join meet operators defined labels compiler static checker check information flow 
information flow checked statically runtime overhead avoided 
compile time overhead checking rules small 
new rules relabeling join meet decentralized label model practical usable 
easier model common security paradigms 
example information flow described concisely system group role principals 
individual principals model multilevel security classes decentralized fashion rules dual form protect integrity protect privacy integrity simultaneously 
chapter jflow language preceding chapter discusses decentralized label model little consideration apply programming language 
chapter presents jflow new programming language extends java language gjs permits static checking flow annotations 
shorter description jflow language published mye 
jflow intended support writing secure servers applets manipulate sensitive data 
approaches static information flow checking vsi sv hr jflow treats static checking flow annotations extended form type checking 
programs written jflow checked statically jflow compiler detects information leaks covert storage channels 
program type safe flow safe translated jflow compiler equivalent java program converted executable code standard java compiler 
static checker detect leaks covert timing channels 
jflow practical programming language developed date allows static information flow checking 
important philosophical difference jflow statically checking information flow focus usable programming model 
despite long history static information flow analysis accepted widely security technique 
major reason previous models static flow analysis limited restrictive practice 
goal add power static checking framework allow reasonable programs written natural manner 
involved new contributions 
jflow extends complex object oriented programming language supports language features integrated static flow checking previously including mutable objects subclassing dynamic type tests access control exceptions 
jflow provides powerful new features information flow checking restrictive convenient previous models decentralized label model chapter supported allowing multiple principals protect privacy presence mutual distrust 
jflow supports safe declassification mechanism described chapter permits principal relax privacy policies weaken policies principals 
label polymorphism allows expression code generic respect security class data manipulates 
run time label checking class label values provide dynamic escape static checking restrictive 
run time checks statically checked ensure information leaked success failure run time check 
automatic label inference unnecessary write annotations required 
goal type checking ensure apparent static type expression supertype actual run time type value produce similarly goal label checking ensure apparent label expression restrictive actual label value produce 
addition label checking guarantees declassification apparent label value restrictive actual label value affect 
principle actual label computed precisely run time 
static checking ensures apparent static label conservative approximation actual label 
reason typically unnecessary represent actual label run time 
kinds static checking differ important way 
type checking important achieve language checked entirely statically 
limitations static type checking worked resorting dynamic type checking java simply trusting programmers understand types programs better static checker 
fallback positions available checking information flow dynamic information flow checking creates new information channel 
reason language mechanisms jflow support static checking information flow elaborate usual language mechanisms static type checking 
jflow compiler structured source source translator output standard java program compiled java compiler 
part translation involves removal static annotations jflow program checking little code space data space run time overhead checking performed statically 
jflow completely superset java 
certain features omitted information flow control tractable 
jflow eliminate possible information leaks 
certain covert channels particularly various kinds timing channels difficult eliminate 
limitations jflow enumerated section 
static vs dynamic checking int public boolean secret int implicit flow example information flow checks viewed extension type checking 
kinds static analysis compiler determines certain operations permitted certain data values 
type checks may performed compile time run time compile time checks usually preferred applicable impose run time overhead 
contrast fine grained information flow control practical static analysis 
claim may sound odd check performed compiler performed run time 
difficulty run time checks exactly fact fail 
failing may communicate information data program running 
information flow model properly constructed fact failure absence serve covert channel 
contrast failure compile time check reveals information actual data passing program 
compile time check provides information program compiled 
similarly load time checks provide information program may considered static checks purposes 
example consider code segment 
examining value variable segment executed determine value secret boolean assigned constant values 
flow information called implicit flow information transferred program control structure direct assignment 
problem assignment allowed 
static analysis required order program safely 
run time check easily detect assignment communicates information improperly abort program point 
consider case false assignment occurs context affects flow control 
fact program aborts continues implicitly communicates information value information case false 
multilevel secure systems handle programs safely restricting writes follow statement grounds process observed tainted 
value process computes tainted label depend conditional way 
label associated process restrictive value process observes 
problem approach coarse grained process label easily restrictive value process computes unusable 
imagine inspecting body statement run time see contains disallowed operations general requires evaluation possible execution paths program clearly infeasible run time 
advantage compile time checking effect static analysis efficiently constructs proofs possible execution path contains disallowed operations 
see shortly static analysis check small program properly 
language support information flow checking sections overview jflow language 
section concentrates new features added jflow language rationale addition 
section examines interactions information flow control complex programming language features objects methods inheritance 
sections ordinary java semantics discussed java widely known documented gjs 
labeled types jflow program label denoted label expression set component expressions 
expressions may take form seen section label expression may series policy expressions separated semicolons 
case component expressions policy expressions 
jflow supports privacy policies straightforward add combined privacy integrity policies sort described section 
chapter component expression owner reader reader 
ina program component expression may take additional forms 
added component form variable name denotes set policies label variable named 
example label expression contains single component expression label means value labels restricted contents 
label expression contains component expressions indicating labeled value restricted principal restricts value read kinds label components introduced 
jflow value labeled type consists parts ordinary java type int label describes ways value propagate 
type expression may labeled label expression labeled type expression written example labeled type int represents integer principal owns readers listed read 
labeled type may occur jflow program places type may occur java program 
example variables may declared labeled type int int int label usually may omitted labeled type declaration variable label omitted default label automatically provided manner depends context 
example label local variable omitted label inferred automatically uses variable 
label instance variable known field member variable omitted default label label 
chapter label restrictive possible label contains components restrict data labels 
cases default labels assigned cases discussed 
type label parts labeled type act largely independently 
notation mean type subtype type intuitive behavior subtyping operates independently type label types labels vsi 
rule really true environment mutation functional programming language 
thesis subtyping relation types labeled types 
implicit flows jflow label expression value varies depending evaluation context 
somewhat unusual property needed prevent leaks implicit flows channels created control flow structure 
prevent information leaks implicit flows compiler associates label pc statement expression representing information learned knowledge statement expression evaluated 
idea program counter label due fenton fen 
example consider program assuming information learned fact program executed initially pc 
case value pc consequent statement 
statement true pc information deduced fact statement statement executed 
true general value pc reverts statements true statement terminates normally 
label literal expression pc case 
unsafe assignment example prevented label variable assigned public restrictive label value assigned secret 
label variable declared label joined pc point declaration 
label variable expression join variable label pc point expression occurs 
label expression assignment general permitted condition translates secret public true general 
way thinking program counter label distinct pc basic block program 
general flow control program depends values certain expressions 
final pc pc pc basic blocks statement point execution various values vi observed order decide arrive current basic block labels values affect current pc pc vi 
mutation assignment potentially leak information observed values vi variable mutated restricted labels variables words label restrictive label pc 
label vi determined straightforward static analysis program basic block diagram 
decision exit point follow basic block bi depends observation value vi 
label pc particular basic block join labels vi 
vi included join possible reach bi possible reach final node bi passing paths bi final node pass arriving conveys information vi 
rule propagating labels basic blocks equivalent rule denning denning dd 
jflow apply rule directly 
rules determining pc statement expression expressed static inference rules chapter 
usually static inference rules generate pc label rule basic block analysis cases inference rules generate restrictive label resulting loss precision 
loss precision occurs code throws catches exceptions complex manner appear problem practice 
termination channels information transmitted termination non termination program 
consider execution statement creates loop basic block diagram 
situation illustrated 
basic block rule just static inference rules case statement terminates pc reasoning statement 
labeling strange know value arrive final block 
arriving final block gives information value code started 
false final pc false pc pc basic blocks statement way code sort transmit information improperly long programs terminate way derive information non termination program dd ar 
way decides program terminated time execution explicitly asynchronous communication thread 
discussed jflow attempt control information transfers timing channels termination channels asynchronous communication threads 
run time labels jflow labels purely static entities may values 
class values new primitive type label represent labels 
functionality needed label value determined statically 
example bank stores number customer accounts elements large array account different label expressing privacy requirements individual customer 
implement example jflow account labeled attached dynamic label value 
variable type label may class value label values 
example methods accept arguments run time labels method declaration static float lb compute int lb label lb example component expression lb denotes label contained variable lb label variable lb 
preserve safety variables type label lb may construct labels immutable initialization java terminology final 
important power run time labels add ability examined run time switch label statement example shown 
code attempts transfer integer variable variable transfer necessarily safe label lb known statically 
statement examines run time label expression executes label lb int lb int switch label case int throw new switch label case statements optional statement 
statement executed associated label restrictive expression label statement assignment expression value declared variable case legal 
case lb arm switch executed transfer occur safely clause executed exception thrown 
statement appears superficially typecase statement modula nel permit discrimination actual run time type expression 
types variables declared arms statement supertypes apparent type expression 
example apparent type int declared type int 
lb run time value information may transferred example observe arms switch executed infer value lb accordingly 
information channel covert 
prevent information channel information leak pc arm augmented include lb label assignment permitted 
ordinary label checking rules control information channel 
seen run time test labels lb gives information contents variable lb 
principal final local variable type principal run time test may give information contents 
assignment permitted information lb affects possibility executing arm 
note run time principal condition trivially true 
switch label statement may contain case arms 
arm fact executed gives information labels previous case clauses earlier clauses known executed 
pc arm including final optional clause restrictive labels labels previous case arms tested 
example pc clause restrictive 
run time labels manipulated statically conservatively treated unknown fixed label 
presence opaque labels problem static analysis lattice properties labels 
example labels case third label 
implication possible opaque label appear label preventing static analysis 
unknown labels including run time labels propagated statically 
reasoning principals jflow contains mechanism determining authority running process dynamically statically checked 
authority mechanism similar systems supporting complex access control mechanisms 
jflow method executes authority granted 
authority essentially capability act set principals controls ability declassify data 
simple authority mechanism build complex access control mechanisms focus authority control declassification 
point program static checker understands code running ability act set principals static authority code point 
actual authority may greater principals may able act principals 
static authority exceed actual authority revocation occurs program running 
static principal hierarchy 
static checker maintains notion static principal hierarchy point program 
static principal hierarchy set acts relations known exist 
static principal hierarchy subset acts relations exist true principal hierarchy 
static authority procedure may augmented testing principal hierarchy dynamically 
principal hierarchy tested new actsfor statement 
statement actsfor executes statement principal act principal current principal hierarchy 
statement skipped 
statement checked statically knowledge tested acts relation exists example static authority includes augmented include 
addition actsfor statement may clause just statement 
clause executed tested relationship exist 
clause statically checked additional knowledge 
section showed negative information acts relations augment static checking 
authority process viewed simply part principal hierarchy 
process represents transient principal hierarchy 
authority granted process principal system calling code explicitly authority thought transient acts relation 
revocation 
possible actsfor statement executed principal hierarchy may change way cause test statement fail 
case may desirable revoke code permission run authority assumed underlying system halting process executing code point hierarchy changes 
running program halted revocation information may leaked part program int int declassify declassify statement executed 
leak covert channel probably slow impractical 
strategy dealing asynchronous revocation run program series transactions 
principal hierarchy checked time transaction commits ensure acts statements executed principal hierarchy information invalidated time transaction committed 
invalid acts relations transaction aborted changes rolled back preventing improper information flows 
framework handling revocation properly product isolation asynchronous modification transaction systems normally provide 
current jflow implementation attempt invalidate execution revocation 
form revocation requires extra support revocation occurs method granted authority terminates 
described preceding section method considered transient principal system 
revocation privileges principal safe principal longer exists revocation way name principal corresponding executing method 
declassification program authority declassify value model section 
expression declassify result expression label declassification checked statically static authority point declassification 
declassify expression may relax policies owned principals static authority 
program authority declassify program counter label 
functionality provided new statement declassify executes statement program counter label form declassification checked statically 
example contains example declassify statement 
assuming label restrictive label program implicit flow duration assignment program counter label relaxed restrictive 
legitimacy declassification statically checked label static authority program point 
note labels automatically inferred example automatically inferred labels problem checking declassification statically 
run time principals class account final principal customer string customer name float customer balance bank account run time principals labels principals may class values run time 
type principal represents principal value 
final variable type principal may real principal 
example explicit policy may final variable type principal name owner reader 
variables may actsfor statements allowing static reasoning parts principal hierarchy may vary run time 
labels constructed run time principals declassification may performed labels 
run time principals needed order model systems heterogeneous respect principals system resorting declassification 
example bank store bank accounts structure shown run time principals run time labels 
structure account may owned different principal customer account 
security policy account similar structure owned principal member variable customer 
code manipulate account manner generic respect contained principal determine run time principal 
principal customer may manipulated actsfor statement label customer may switch label statement 
interactions features java novel aspect jflow integration information flow analysis practical object oriented programming language 
java complex features mutable objects inheritance subtyping exceptions features interact label checking 
section describes java language constructs extended modified support information flow control 
jflow object oriented language supports inheritance subtyping 
classes jflow largely extension classes java 
may contain methods static methods instance variables 
instance variables declared labeled types just local variables methods 
class related features java supported jflow inner classes static instance variables supported 
inner classes supported complication unnecessary goals 
static instance variables supported create covert channels discussed section 
non static instance variables usually substitute static instance variables 
method declarations syntax jflow method declaration extensions compared java syntax optional annotations manage information flow authority delegation 
method header syntax shown syntax definitions java language specification gjs 
identifier identifier grammar method header grammar shows return value arguments exceptions may labeled individually 
optional labels method declaration called label label 
label specify restriction pc point invocation method 
allows information pc caller statically checking implementation preventing assignments method creating implicit flows information 
contains example jflow class declaration jflow version standard java class vector 
provides examples jflow method declarations 
method declaration prevented leaking information label 
called pc caller restrictive 
labels arguments written discussed section argument labels automatically include label arguments labeled 
public class vector label extends private int length private object elements public vector 
public object elementat int throws return elements public void object int public int size return length public void clear 
jflow version class vector label method specifies pc point termination method captures restrictions information learned observing method terminates normally 
individual exceptions return value may distinct labels allowing static label checking track information flow fine granularity 
example label elementat method means pc normal termination restrictive label label argument label necessary index bounds exception thrown observation instance variable elements argument knowledge termination path method may give information contents variables 
java method arguments jflow implicitly final 
change class principals labels convenient arguments types label principal nearly desired final 
simple change remove significant power language code assigns argument variable rewritten local variable 
default labels contains examples jflow method declarations demonstrate features method declarations 
types example labeled types arguments method 
types unlabeled types argument return value elementat 
labels omitted jflow program default label assigned providing greater expressiveness greater convenience 
effect defaults methods require label annotations 
section describes default labels assigned 
labels may omitted method declaration signifying implicit label polymorphism 
example argument method elementat unlabeled 
argument label omitted method generic respect label argument 
argument label implicit parameter procedure 
method elementat called integer regardless label 
label polymorphism important building libraries reusable code methods need reimplemented argument label 
consider implementing method cos evaluates cosine argument 
implicit label polymorphism strategies reimplement argument label implement run time labels 
approach clearly infeasible 
implicit labels advantage run time labels provide adequate power easier cheaper 
implicit labels signature cos method float lx cos float lx label lx implicit label polymorphism eliminates run time overhead gratuitous method arguments method signature allowing simpler signature java float cos float labels assigned defaults 
label method includes label label declared explicitly label method omitted equal label 
default label return value method label joined labels arguments 
default sense common case 
method cos default return value label need written explicitly 
methods may return exceptionally exceptions may labeled rule default exception labels rule label 
label omitted implicit parameter method 
method implicit label parameter called regardless pc caller code method guaranteed leak information 
general methods side effects written fashion convenient implement 
static checking rules described section place restrictions implementation method limit ability cause side effects local variables may course modified method sort may mutate objects passed arguments appropriately declared side effects prevented 
assignment requires label variable restrictive pc point assignment label variable external method proved restrictive label assignment rejected statically 
method constraints java method may contain list constraints prefixed keyword constraints constraint authority principals caller principals actsfor principal principal different kinds constraints authority pn clause lists principals method authorized act 
static authority method includes set principals listed clause 
principals listed may names global principals names class parameters type principal 
listed principal listed authority clause method class described section 
authority mechanism obeys principle privilege methods class need possess full authority class 
caller pn calling code may dynamically authority method caller constraint 
authority clause authority object authority case caller 
method caller clause may called calling code possesses requisite static authority 
void principal 
throws caller actsfor manager 
throw new void caller manager 
caller constraint principals named caller clause need constants may names method arguments type principal 
passing principal corresponding argument caller principal authority code 
dynamic principals may class principals example may labels 
actsfor actsfor constraint may prevent method called specified acts relationship acts holds call site 
method body checked static principal hierarchy assumed contain acts relationships declared method header 
constraint allows information principal hierarchy transmitted called method dynamic checking 
caller mechanism provides simple access control mechanism checked statically dynamically 
check authority dynamically method caller constraint accept unknown authority actsfor statement test granted authority sufficiently powerful 
access control mechanism build elaborate access control mechanisms access control lists 
example consider method skeletons 
method dynamically tests caller authority act principal manager 
caller constraint caller pass principal act 
actsfor test tests method authority act principal manager 
exception thrown 
note label method knowing method terminated normally exceptionally gives information principal passed 
authority tests leak information success failure 
method statically enforces test authority tests dynamically 
called code statically known act manager consequent actsfor test method method 
method flexible incurs dynamic overhead 
exceptions exceptions jflow identical exceptions java 
changes syntactic semantic 
syntactic change list exceptions method header delimited parentheses 
parentheses needed case exception labeled declaration 
int object object throws nullpointerexception notfound parentheses determined unambiguously brace nullpointerexception label expression method 
substantive change java treatment unchecked exceptions 
java allows users define exceptions need declared method headers unchecked exceptions practice described atypical gjs 
jflow specific exceptions allowed unchecked unchecked exceptions serve covert channels 
exceptions nullpointerexception declared explicitly method header method throw exception 
unchecked exception allowed new exception may caught catch clause 
exception error conditions stack overflow heap exhaustion 
unchecked serve covert information channel 
caught exception transmit bit information program execution 
jflow java catch clause try catch statement type discrimination mechanism exception handling mechanism 
places jflow type may labeled 
java catch clause takes form catch unlabeled class inherits throwable variable name statement executed clause catches exception 
decision catch clause try catch statement execute depends dynamic type exception 
catch clause pc determined labels attached exceptions thrown statement try clause statement 
break continue statements provide exception mechanism java may specify statement label jump 
statements structured goto statements 
supported jflow introduce simple requirement pc destination statement restrictive pc break continue statement 
parameterized classes parameterized types long known important building reusable data structures 
parameterized class generic respect set type parameters 
genericity particularly useful building collection classes generic sets maps 
important polymorphism public class vector label extends private int length private object elements public vector 
public object elementat int throws return elements public void object int public int size return length public void clear 
parameterization labels information flow domain usual way handle absence statically checked type polymorphism perform dynamic type casts approach works poorly applied information flow dynamic tests create new information channels 
jflow class interface declarations extended allow parameterization may generic respect number labels principals including set explicitly declared parameters 
parameterized types important building reusable data structures jflow 
example reusable data structure java vector class may translated jflow shown 
example appeared earlier 
vector class parameterized label represents label contained elements 
assuming secret public appropriately defined types vector secret vector public represent vectors elements differing sensitivity 
types referred instantiations parameterized type vector 
ability instantiate classes particular labels necessary reimplement vector distinct element label 
class may parameterized principals example 
class may instantiated principals example bob amy label bob amy 
functionality provides power similar run time principals bank account example run time storage overhead run time principals incur 
class principal principal int contents parameterization principals semantics class parameters defined way class parameters need represented run time information conveyed class parameters 
result class parameters may run time tests example label parameters may tested switch label statement may principal parameters appear actsfor test 
parameterized type inherits superclass implements interface supertype may instantiation 
instantiation inherited implemented legal type scope class inheriting implementing 
specific instance general rule jflow parameterized class interface formal parameters class may actual parameters instantiations parameterized types scope 
rule corresponds exactly approach taken languages support parameterization types lcd lmm ow 
jflow provide parameterization respect types unnecessary investigating static information flow control 
straightforward add unconstrained parametric polymorphism implementation polymorphic abstraction unable knowledge type parameter 
kind parametric polymorphism expressive appears similar languages mbl lmm pizza ow 
constrained parametric polymorphism languages creates complications information flow control parameter information channel 
addition label principal parameters jflow parameterized classes simple dependent types car types contain values 
ensure dependent types defined meaning final variables may parameters immutable meaning change 
alternative approach allow variables parameters case different types mention variable different meanings assignment variable occurred 
note public secret case vector public vector secret 
subtype relation denoted 
subtype relation unsound vector mutable observation applies subtyping relations type parameters 
subtype relation sound parameter may declared covariant label label 
covariant label parameters sound placing additional restrictions follows 
covariant label parameter may construct label non final instance variable 
may actual parameter class formal parameter label 
immutable final instance variables method arguments return values may labeled covariant parameter 
non static methods instance variable variable may construct labels denotes label object method invoked object instance variable part 
instance variable labeled safe allow assignment variable object label restrictive class authority root public boolean check string user string password authority root 
authority declaration label assignment 
observe assigned value 
reason variable treated implicit covariant label parameter label 
label restricted way covariant parameters restricted may label non final instance variables 
arrays jflow support user defined type parameters support type type parameter built java array type type instance variable elements 
jflow arrays parameterized respect type contained elements label elements 
example vector type instance variable elements object represents array object element array labeled array type behaves type array parameters element type element label case object 
label parameter may omitted case defaults 
example types int int equal 
wonder label array sufficient protect array elements 
reason arrays mutable data containers 
suppose arrays separate label parameter 
case variable type int assigned variable labeled type int restrictive label value labeled type assigned array element apparent safety value observed original array unrestricted label laundering label away 
argument applies type vector discussed preceding section 
subtyping rule arrays jflow java type subtype type type array subtype array 
label parameter covariant labels imply array subtype array 
jflow arrays offer additional operation pseudo field length returns number elements array 
label length field label array element label 
label safe length jflow array java array immutable array creation 
run time type discrimination java supports expressions run time type discrimination run time casts instanceof operator 
expression attempts cast expression type throwing exception possible expression instanceof returns boolean indicating produced expression assigned variable type operators supported jflow 
result expressions restricted result expression jflow imposes limitation operators may invoked type instantiation 
reason restriction information parameters available run time 
information parameters available run time create additional information channel controlled 
parameterized types operators safe determined statically parameters cast match parameters dynamic type class 
approach taken type parameters language pizza ow pizza represent type parameters run time currently supported jflow 
authority declarations classes jflow support authority declarations 
class may authority granted objects addition authority clause class header 
contains partial example class declares authority principal root method check claims authority root body method 
authority clause class may name principals external program case class parameters type principal 
case class superclass cs authority cs clause principal authority clause 
effect rule possible obtain authority inheriting superclass 
ability give class authority external principals useful potentially dangerous controlled 
authority clause class names external principals principals permit creation class 
permission tested requiring process installs class system compiler granted appropriate authority principals named 
authority clause names parameter class type principal code class acts arbitrary principal specified 
static authority point invocation class constructor include authority actual principal parameters call constructor ensures authority class received process possessed authority 
rule differs rule external principals named authority clause authority derives code invokes constructor process installs class system 
note static methods class possess authority principal parameters construction time test bypassed 
language feature powerful dangerous object created manner capture retain authority granted method caller general free standing capability dv wcc authority 
jflow way tell authority granted subsystem captured subsystem capability sort mechanism misused create attacks subsystem acquires authority knowledge caller 
reason principals permitted define class places principal parameter authority clause classes may defined highly trusted principal root 
inheritance constructors java classes jflow class may declare supertypes superclass inherits interfaces implements 
inheritance subtyping interactions new features jflow 
java methods may overloaded distinguished argument types 
signature class method conform signatures method supertypes method identity determined argument type 
signature conformance jflow includes java requirement return types signatures identical places restrictions labels subclass method signature labels method arguments subclass restrictive labels method arguments superclass label return value subclass may restrictive label return value superclass 
jflow classes support constructors just java classes 
constructor class behaves static method returns new object type constructors declare return label label returned object label method 
consider constructor declaration class bob int int 
constructor declared label label bob object produced call new operator uses constructor label 
constructors java jflow invoke superclass constructor class inherits superclass 
jflow differs java requiring final instance variables subclass initialized call superclass constructor 
requirement arises important prevent final instance variables type label principal observed initialized 
observation lead information leaks 
suppose variable type label construct label variable declaration int variable argument switch label statement variable initialized statement determine case execute properly class complex public final float real imaginary public complex float float real imaginary 
implementation complex numbers may invoke case creates information leak 
section constructor superclass invocation sequence arbitrary statements referred constructor prologue 
instance variable class initialized constructor prologue include assignment form instance variable expression prologue call superclass constructor object instance variables scope may may course left hand side initialization assignments 
purpose rule prevent uninitialized data read possibly causing information leaks 
initialization assignment checked relaxed rule variable assignments 
ordinary assignment safety condition le label expression takes account current pc 
initialization assignment weaker condition le lr enforced lr label constructor label object constructed 
weaker condition safe instance variable accessed object constructed 
access instance variable object causes result acquire label 
label object protect instance variable 
weaker initialization rule helpful writing classes represent immutable abstractions class representing complex numbers 
example consider code implements simple complex number abstraction convenient 
class complex single constructor takes arguments object returned constructor automatically labeled label constructor 
implementation constructor particularly simple 
convenient abstraction possible weaker initialization rule 
initializations instance variables real imaginary permitted label constructor restrictive labels values assigned weaker initialization rule assignment permitted label instance variables known restrictive implicit label parameters associated arguments weaker initialization rule safe access class authority root public boolean check string user string password authority root return password correct boolean match false try int names length names user passwords password match true break catch nullpointerexception catch return declassify match user password private string names private string root passwords jflow password file instance variables real imaginary object labeled data stored examples essentials jflow language covered ready consider interesting examples jflow code 
example contains jflow implementation simple password file passwords protected information flow controls 
method checking passwords shown 
method check accepts password user name returns boolean indicating string right password user 
method label local variables match stated explicitly automatically inferred uses 
statement conditional elements passwords password labels implicit parameters 
body statement pc user password root variable match label order allow assignment match true 
label prevents match returned directly result label return class protected object lb content final label lb public protected ll object ll label ll lb ll occur call super super content checked assuming lb ll public object get label throws switch label content object unwrapped return unwrapped throw new public label get label return lb protected class value default label user password 
method match desired label compiled authority act root 
precise reasoning possibility exceptions writing code convenient 
example exceptions nullpointerexception caught explicitly method explicitly declare 
possible show case exceptions thrown 
little difference code equivalent java code 
annotations added authority clause stating principal root trusts code declassify expression label elements passwords 
labels local variables return values inferred automatically assigned sensible defaults 
task writing programs easier jflow label annotations tend required interesting security issues number novel language features needed possible 
method implementor class decided declassification match results acceptably small leak information 
login procedures method leak information exhaustively trying passwords eventually extract passwords password file 
assuming space passwords large passwords difficult guess expected amount password information gained trial far bit 
reasoning leaks information acceptable lies outside domain classic information flow control 
example protected class protected provides convenient way managing run time labels bank account example mentioned earlier 
implementation shown 
implementation shows object type protected immutable pair containing value content type object label lb protects value 
value extracted get method caller provide label extraction 
label insufficient protect data exception thrown 
value type protected behaves value dynamically checked information flow systems carries runtime label 
protected obvious analogue type domain value dynamically associated type tag example dynamic type 
key making protected convenient lb final labeled simply 
effect label label containing object 
initialization lb allowed permissive initialization rule section 
assignment lb ll initialization rule requires formula ll ll true obviously note necessary instance variable content final code correct 
limitations section summarizes ways jflow superset java covert channels jflow eliminate 
certain covert channels particularly various kinds timing channels difficult eliminate 
prior addressed static control timing channels resulting languages restrictive ar sv 
covert channels arise java language features consequently removed 
threads jflow prevent threads communicating covertly timing asynchronous modifications shared objects 
covert channel prevented requiring single threaded programs 
timing channels jflow prevent threads covertly gaining information timing code system clock removing access clock 
hashcode built implementation hashcode method provided class object communicate information improperly gives information memory address object allocated 
information allows memory allocator covert channel 
result jflow class implement hashcode 
static variables order static variable initialization communicate information improperly 
covert channel blocked ruling static variables 
static methods legal 
run separate thread main program communicate covertly 
part jflow 
resource exhaustion communicate information covertly conditionally allocating objects heap exhausted 
jflow treats error converting exception preventing communicating single bit expected information program execution 
resource exhaustion errors stack overflow treated similarly 
wall clock timing channels jflow program change run time private information observed 
extreme example enter infinite loop 
jflow attempt control channels variety timing channel information leaks able time program 
unchecked exceptions described section jflow unchecked exceptions serve covert channels 
backward compatibility jflow backward compatible java existing java libraries flow checked provide flow annotations 
cases java library wrapped jflow library provides reasonable annotations 
grammar extensions jflow contains extensions standard java grammar order allow information flow annotations added 
productions added modified standard java language specification gjs 
java grammar modifications grammar required grammar input parser generator 
grammar modifications fact code jflow compiler considerable extent derived extension java supports parametric polymorphism mbl lmm 
label expressions components component components component component principal identifier identifier principals principal principals principal principal name labeled types types extended permit labels 
new primitive types label principal added 
name boolean label principal production represents instantiation array index expression 
brackets ambiguity resolved parsing 
name expression name expression new class declarations class identifier interface identifier params parameter parameter parameter label identifier covariant label identifier principal identifier authority authority principals method declarations identifier void identifier identifier identifier constraints constraints constraint constraints constraint constraint authority caller principals actsfor principal principal avoid ambiguity classes throws list placed parentheses 
label confused method body 
throws throws new statements statement existing productions 
switch label statement executes case label new variable introduced restrictive label expression statement invoked 
determination static comparison label components run time representable dynamic comparison label component run time representable 
new variable initialized value expression 
cases executed clause executed 
switch label expression case type identifier case actsfor statement executes statement principal act second principal current principal hierarchy 
knowledge existence acts relationship statically checking statement 
acts relationship exist statement clause executed 
actsfor principal principal statement declassify statement executes statement restrictions removed pc 
declassify statement new expressions new label expression produces new run time value type label 
expression describe label entirely run time representable may mention principal label parameters implicit explicit 
literal existing productions new label declassify expression evaluates expression returns result possibly declassified label 
static authority point invocation sufficiently strong 
declassify expression chapter statically checking jflow chapter shows language chapter checked statically straightforward manner 
describes jflow language completely previous chapter shows precisely static checking performed formal inference rules function definitions 
rules explained informally 
approach taken describe aspects jflow differ java 
example type checking largely ignored identical java 
execution semantics language sufficiently close java described formally 
focusing information flow checking formal rules provide concise description interesting aspects jflow compiler implementation 
chapter describes static checking done jflow compiler description label inference algorithm source source translation chapter 
correctness chapter presents rules statically checking jflow language useful consider criteria rules correct 
notion correctness language essentially statically checking information flow kind type system vsi sv hr 
simple jflow programs parameters run time labels subtyping rules needed static checking essentially static checking rules 
extra static checking machinery jflow support new language features chapter 
rules intended enforce properties apparent label expression restrictive actual label value produce 
actual label value restrictive actual label value affect 
modulo declassification 
value considered affect change cause change 
property expresses usual idea static checking conservative second property enforces usual definition correctness information flow non interference gm 
intuitively non interference says low security outputs program may affected high security inputs 
java jflow objects may exist program runs effectively persistent considered inputs outputs 
non interference condition weakened presence declassification language model 
declassification allows higher security data interfere lower security data explicit action principal security affected 
relaxed version non interference inputs may affect lower security outputs explicit authorization principal able override corresponding policies 
properly define notion actual label expression operational semantics jflow defined 
argument correctness twofold operational semantics enforce modified non interference property static checking rules conservative respect operational semantics 
approach taken type checking java sym nv taken thesis important features jflow objects inheritance dependent types formal proofs correctness difficult point 
operational semantics java defined clearly gjs de notion actual label clear simply static checking rules 
static checking rules particularly standard java constructs seen correct inspection similar static checking rules seen information flow dd vsi hr support exceptions 
addition attempt argue informally correctness rules 
section described java features threads built hashcode method removed jflow information channels ignored stack overflow leak bit information 
reason removing information channels difficult characterize static typing rules making language impractically restrictive 
absent information channels information flows jflow program easily characterized local manner statement expression language chapter shows 
static checking framework sake clarity certain simplifications describing static checking jflow programs 
jflow java class may named fully qualified name base name class package imported 
rules chapter ignore complication orthogonal information flow checking 
reason classes assumed reside package names unqualified 
similarly visibility modifiers public private ignored classes class members assumed public purpose checking information flow 
standard visibility checking class name resolution performed java compiler suffices jflow 
presenting rules checking various language constructs necessary establish certain notational semantic conventions permit concise expression rules 
purpose section describe basic framework static checking rules built 
static checking rules sections 
type checking vs label checking jflow compiler performs kinds static checking compiles program type checking label checking 
aspects checking entirely labels type constructors appear rules subtyping 
checks needed show statement expression sound largely classified type label checks 
chapter focuses rules checking labels type checking jflow exactly type checking java 
interesting interactions kinds checking 
static type checking typically expressed attempt prove type judgement 
inference rules static type checking formula typically meaning environment expression type expression entire program formula expresses idea program typed 
environment captures information context expression occurs context entire program checked typical compiler symbol table 
formula written subscript indicating judgement type domain 
thesis statically checking information flow formula indicate judgement domain information flow 
analogy type checking expect letter formula represents label 
case need describe exceptions fully 
letter represent set path labels capture information flow possible ways expression terminate 
return structure path labels section 
environments programs jflow checked correctness environment binding symbols names various entities associated information 
symbols may names classes principals local variables pieces static checking context 
environment contains static principal hierarchy static authority 
letter static checking rules represent environment 
binding symbol id environment written id 
new environments created expression form id creates new environment identical symbol id re bound environment maps identifier variable name binding ag global environment containing class definitions environmental information external program checked id binding identifier id id new environment id re bound expression generates path labels evaluated environment statement generates path labels environment principal known act principal knowledge principal hierarchy contained label restrictive label knowledge principal hierarchy contained equivalent principal hierarchy contained expression type type subtype type 
predicate 
predicate named predicate true environment environments judgements global environment ag contains definitions classes system constant part principal hierarchy 
code checked complex environments constructed extend ag contain definitions local variables class parameters bindings 
addition judgements just described judgements describe static correctness jflow 
convenience judgements syntax environments just described summarized table explained detail introduced 
convention worth explaining syntax proving auxiliary predicates final line 
convention followed variable variables represent outputs variables xi represent inputs 
formal sense difference inputs outputs predicate inference rule natural implementation rules predicate arguments outputs useful distinguish basis 
exceptions important limitation earlier attempts create languages static flow checking absence usable exceptions 
example original denning denning static flow checking dd exceptions terminated program treatment exceptions leak information 
subsequent avoided exceptions entirely 
unnecessary treat exceptions directly languages function generates exceptions desugared function returns discriminated union oneof 
approach leads coarse grained tracking information flow 
obvious way treat oneof types analogy record types 
arm oneof distinct label associated 
addition added integer field tag indicates arms oneof active 
problem model assignment oneof require tag pc attempt oneof read tag implicitly 
result arm oneof effectively carry label 
modeling exceptions unacceptable loss precision 
reason unnecessary treat exceptions directly exceptions usually ignored treatments static type checking 
feasible ignore exceptions checking information flow exception ignored static checking leads possible security violation 
reason static type checking rules ignore exceptions may legacy programming language ml mth strongly typed statically typed expression terminates exception static type checking rules ignore 
programming languages clu lab theta lcd statically check exceptions languages sto modula nel java treat exceptions statically 
jflow exceptions checked statically 
expression statement static checker determines path labels labels information transmitted various possible termination paths normal termination termination exceptions termination return statement 
fine grained analysis avoids unnecessary restrictiveness produced desugaring exception thrown evaluating statement expression possibly distinct label transferred pc catch clauses intercept 
finer resolution provided normal termination return termination value label expression may differ path label 
differentiation value label path label pc point program restrictive value computed prior point making jflow impractically restrictive 
path labels statement expression represented total map paths labels 
mapping represents termination path statement expression take label mapping conservatively indicates information learned path known actual termination path 
paths domain map may symbol represents normal termination 
symbol represents termination return statement 
symbols nv rv represent labels normal value expression return value statement respectively 
represent paths convenient include part map 
set path labels map symbols labels expression generates path labels evaluated environment class extends throwable special symbols nv goto label statement label label associated termination break continue statement mentioning label label corresponding path restrictive label possible 
label expressed programs containing policies 
restrictive label possible 
label need expressed directly programs 
pseudo label representing path taken 
path way expression statement terminate corresponding path 
set path labels identical label associated path changed set path labels describing expression terminate sx join sets path labels simply join corresponding labels exc function useful creating path labels expressions throw exceptions defined follows represents exception type class extends throwable exc label definitions path labels names classes inherit throwable 
class represents exception mapping class represents path termination exception 
tuple form goto represents termination executing named break continue statement jumps target continue statement name target represented tuple goto members domain paths denoted 
unfortunately letter heavily overloaded 
notation environments path labels expression denotes label maps expression denotes new map exactly path bound label range path labels precisely set labels set labels augmented pseudo label 
mapped indicates statement terminate path joins label behaves lower label labels including label 
summarizes notation defines additional notation relating path labels 
label special value 
label expression produces label environment type type expression labeled type expression expression form function labeled distinguishes cases 
principal principal expression name component policy label see section formal parameter class actual parameter class program expression actual parameter class part type name class name variable statement method field signature complete method declaration including implementation additional notation conventions additional conventions certain conventions chapter worth mentioning point 
rules follow symbols suggest kind type value expression denoted 
conventions summarized easy described detail 
sequences items kind represented notation xi 
letters indices sequences 
items sequence assumed separated appropriate delimiters delimiters included cases clarity expression xi 
equation index variable appears holds range max explicitly indicated 
sequence items xi 
distinct sequence xj 
subscript index items distinguish 
convention chosen compactness inspired convention repeated indices relativistic physics 
optional items indicated large brackets expression rules optional expressions denote implicit variable generated unification syntactic form component environment 
example consider rule extend final var final type part var label var uid name mutable non final variable maps tuple representing variable type label var final uid final variable param principal uid parameter type principal param label uid parameter type label covariant label uid covariant parameter type label class 
class 
entire class declaration stored environment 
constant principal real principal external program goto variable representing pc statement labeled break continue target environment mappings final right corresponding option argument extend 
optional items condition expression case condition understood true optional item 
notation represent empty optional value 
cases brackets written subscript different optional items 
final case subscript distinguish environment bindings jflow static checker environments store variety different kinds information 
certain information stored environment special symbols 
special symbols auth pc auth set principals program known authorized act particular point program static authority pc program counter label ph static principal hierarchy 
set pairs principals meaning known act environment environment contains mappings various named entities local variables 
mappings shown environment 
bindings rules notation uid represents unique identifier generated static analysis distinguishes program identifiers share name 
indicated classes interfaces entered environment 
order support mutual classes class interface bindings global environment ag environments generated extension 
global environment contains information entry ag ph contains part static principal hierarchy assumed constant 
code compiled global environment need invalidated relations described ag ph revoked 
similarly entry ag auth contains principals willing authority code compiled precisely added system 
principals revoke authority code invalidated 
representing principals jflow entities including principals types labels sharp distinction drawn syntactic expression denoting entity representation entity static checking 
example principals named jflow programs identifiers 
identifiers may names principals external program parameters denoting unknown principals names variables type principal 
static checking principals represented kinds tuples pr external principal external program typically username pr param uid static principal parameter 
static parameters run time representation 
pr dynamic uid run time principal variable 
label label variable keeps track information conveyed knowing principal variable denotes 
principals appearing policy expression may take forms 
forms appear range environment map example variable type principal maps tuple form var final principal uid form pr dynamic mapping principal identifiers internal representation performed function interp short interpret principal 
function assumes appropriate environment entry installed identifier question 
done clear 
interp id case id constant principal pr external id param principal uid pr param uid var final principal uid pr dynamic uid representing labels components labels represented differently static checking program expressions 
label expressed jflow program set component expressions pi 
separated semicolons 
letter denotes component stands policy 
component expressions may policy expressions components name variable parameter dynamic components 
static checking label represented join components produced interpreting corresponding component expressions 
label written pn 
pi pi 
principals components component expressions represented different notation 
possible forms component corresponding allowed ways write component expression interp ri 
policy interp interp ri interp case var final uid covariant label uid covariant label uid param label uid label param uid constant principal param principal uid interp case var final label uid dynamic uid interpreting labels policy ri represents policy label component explicit owner readers ri principals 
kind component generated policy expression form ri 
label param uid fixed unknown label corresponding explicit class label parameter 
covariant label uid fixed unknown label corresponding class parameter type label declared covariant implicit argument label parameter dynamic uid dynamic label contained final variable type label 
kind component generated expression form variable 
environment environment exists declaration variable variable uid undeclared label resulting label omitted program 
label sort inferred constraint solver described chapter 
definitions function fresh variable produces new labels containing single variable component fresh identifier uid 
definition fresh variable variable fresh uid function fresh uid generates unique identifier static checking 
label expression program converted join components function interp interprets individual component expressions joins interp pn interp interp pn component expression interpreted straightforwardly producing kinds policies 
interpretation process shown formally 
details label interpretation hold interest 
definition shows policy interpreted recursively interpreting principals named policy 
component expression consisting identifier interpreted differently depending significance identifier 
identifier name variable simply denotes label variable component expression 
identifier label parameter denotes label parameter 
identifiers names external principals associated information flow denote empty label 
contents variable type label may construct dynamic component notation representing types care taken represent jflow types unambiguously static checking 
java kinds type constructors class types interface types arrays 
jflow adds labels ability instantiate class parameters 
internal representation class interface type symbol name class followed possibly empty sequence parameters 
basic types int represented way empty sequence parameters int 
arrays represented symbol array followed parameters type contained elements common label 
type int represented internally array int 
java arrays type allow type parameter 
predicate interp translates type expression internal representation shown 
convenience expressing static checking rules predicate written function 
interpreting instantiations parameterized classes predicate interp param interpret actual parameters 
rules interp show simple object types interpreted 
rule shows interpretation non parameterized class treated exactly parameterized class having parameters 
second rule shows parameterized instantiation interpreted interp param predicate 
third fourth rules define interpretation jflow array type accordance section 
final rules show actual parameters parameterized class interpreted 
subtle issue parameter interpretation non covariant formal label parameter may supplied covariant actual label parameter fifth rule 
predicate invariant defined section 
static checking rules chapter symbol represent labeled type expression expression form convenience functions labeled type part part manipulate labeled type expressions defined 
invariant vs covariant types presence covariant label parameters necessary distinguish invariant covariant types 
invariant types types mention covariant label parameters meaning invariant type vary parameter 
covariant types types vary covariant label parameters 
type invariant long actual label parameters invariant 
class interp class pi 
qi interp param qi pi qi 
interp qi interp invariant array interp interp interp invariant invariant array interp interp invariant interp param label id interp interp param covariant label id interp interp param principal id interpreting type expressions labeled true type part interp label part interp labeled false type part interp label part definitions labeled types case qi 
pj 
uid pj covariant label uid true invariant qi determining type invariance uid uid pr param uid pr param uid pr dynamic uid pr dynamic uid pr external uid pr external uid ph get uid get uid get uid get uid inferring relation predicate invariant defined uses simple rule 
label invariant contain components form covariant label uid condition expressed requiring label label parameter may restrictive label contains label component components form covariant label uid ordinary member set labels large write 
basic rules representations principals labels types just defined basic rules reasoning entities expressed starting principals 
reasoning principals environment static principal hierarchy stored component ph set pairs principals 
notation means static knowledge contained environment principal known act principal 
necessary reflexivity transitivity static principal hierarchy see section achieved inference rules transitively extend set pairs ph 
rules shown 
rule expresses transitivity acts relation 
second rule captures reflexive property acts relation 
third rule describes static principal hierarchy accessed check acts relations 
function get uid extracts uid component principal 
reasoning labels rules shown checking label constraints 
rules simply complete relabeling rule section 
rules show non policy components pi 

pi ia ri policy ri policy true label param uid label param uid true covariant label uid covariant label uid dynamic uid dynamic uid inferring relation treated opaque 
final rule reduces reasoning label equivalence reasoning relabeling 
rules say label variables components form variable uid rules applied fully label variables satisfying assignments replacing kinds components defined section 
fourth rule dynamic component relabeled dynamic component uid words contents variable type label 
correspond contents different variables static relationship inferred 
relationship components depends contained labels 
expect contained labels labels variable 
components acquire different labels constraint solving label variable type label automatically inferred 
case contained label conservative approximation true label variable different dynamic components may contain different conservative approximations 
class scope environments jflow unique languages support static checking information flow fully supports objects 
unique support parameterization including parameterization labels class env qi case ag class pi 
ag param id pi qi 
inner class env case ag class pi 
authority pk 
ag param id pi formal actual pi 
auth interp pk param id case covariant label id id principal id id formal actual case covariant label id covariant label fresh uid label id param label fresh uid principal id param principal fresh uid modifying environment class scope principals 
section describes functions predicates support features 
handling class parameters 
class jflow possibly empty list formal parameters may instantiated actual parameters appropriate sort 
code external internal class necessary create environments formal parameters bound 
functions creating augmented environments defined 
function class env checking code external class code mentions instantiation class 
augments environment definitions parameters class instantiation class parameters creating binding formal parameter class corresponding actual parameter instantiation 
function inner class env augments environments class parameters creating environment checking code class 
adds definitions parameters class treats formal parameters actual parameters appropriate type 
checking code class definitions ensures class safe possible actual parameters supplied 
var final qi pc fresh uid extend qi obj env qi case ag class pi 
implements tj 
class pi 
extends ts extend interp ts class env qi extend qi extend qi ag class final vn final label ln final principal ln nj 

ln fresh variable var final label ln fresh uid 
vn var final principal ln fresh uid 
ln interp ln extend qi extending object environment example class parameter type label bound label containing single component form param label fresh uid uid function generates previously unused identifier 
static checking rules treat component opaque label known equivalent 
condition holds possible label code parameterized label sound regardless actual parameter code instantiated 
building object environments 
jflow final instance variables type label principal may construct dynamic label components policies containing objects scope 
example instance variable type label may label instance variable object 
instance variables may construct labels non static methods class 
performing static checking obj env predicate extends environment add definitions final instance variables type label principal 
definition shown 
primary obj env checking correctness method body 
context variable scope 
instance variables need placed scope ordinary access instance variable treated expression predicate extend ensures appropriate instance variables added environment 
defined 
instance variables added environment starting topmost superclass working 
ordering ensures instance variables shadow superclass definitions bound correctly 
predicate extend shown adds final instance variables type label principal members single class second argument 
rule works extracting indices final variables type label principal variables nj 
respectively 
indices select variables entered successively augmented environments process complicated fact labels instance variables may refer 
instance variable vn new label variable ln handle potential circularity 
label ln label entering variable environment required final antecedent equivalent interpretation declared label variable ln environment necessary instance variables defined 
instance variable method signatures 
important part static checking looking signatures class members including members inherited superclasses 
class members include instance variables methods 
judgement signature meaning member type signature type class type 
rules looking signatures figures 
member may name instance variable method identifier form ti ti types arguments 
name instance variable signature form final id rule provided look method signatures signature match argument types ti argument types signature supertypes corresponding types ti 
condition final antecedent rule method signature lookup 
rule multiple overloaded signatures may satisfy argument types ti 
java situation static error signatures specific 
rules capture aspect static checking sake simplicity 
methods fields inherited superclasses rule 
rule ts represents type expression superclass superclass type expression ts interpreted environment class env qi may mention formal parameters class rule holds methods tj substituted reasoning subtypes consider judgement relevant jflow languages subtyping 
ordinary unlabeled types 
subtype rule java handles class parameters 
instantiation parameterized class subtyping invariant parameters ag class pi 
final 
obj env ag qi tf type part lf labeled label part final tf lf signature qi ag class pi 
static aj 
throws 
kl 
class env qi tj type part static aj 
throws 
kl signature qi tj ag class pi 
extends ts member ts interp ts class env qi signature ts signature qi looking field method signatures label parameter declared covariant 
subtyping rule shown 
rule vector subtype checking subtype relations jflow straightforward 
instantiations class necessary walk type hierarchy rewriting parameters shown second rule 
rules inductively prove appropriate subtype relationships including reflexivity transitivity 
instantiations class subtype relation parameters equivalent parameter covariant label labels appropriate relation 
ag class pi 
qi pi covariant label id qi qi 

ag class pi 
extends ts ts interp ts class env qi ts 
qi 

subtype rules true pc true literal pc nv pc pc simple rules rules checking subtype relationship instantiations parameterized types similar checking performed compiler supports type parameters mbl 
checking subtype relation class interface interfaces done exactly way classes 
checking java statements expressions section presents rules statically checking information flow statements expressions jflow inherits java 
semantics statements java discussion behavior needed 
kind java expression deferred section call method constructor differs somewhat jflow java 
simple rules rules statement forms expressed simply definitions provided far 
contains important static checking rules 
rule interpreted follows empty statement terminates normally pc start 
simply passes pc statement follows 
second rule seen literal expression numeric constant terminates normally labeled current pc described earlier 
third rule applies statement important relaxing restrictive path labels 
intuitive meaning rule statement terminate normally pc pc 
normal termination statement gives new information 
true statement terminate return statement 
rule called single path rule 
safe rule apply exception paths rule requires single path see suppose set path labels formally contains single exception path path include multiple paths consisting exceptions pc pc exc nv exc nv nv arithmetic rules subclasses multiple paths discriminated try 
catch statement 
java exception model identifies exceptions types java supports subtyping single path rule may applied safely exception paths 
exceptions identified types clu lab single path rule applied exceptions 
arithmetic gives rules checking arithmetic operations 
arithmetic operations throw exception addition covered rule 
java evaluates second argument arithmetic operation argument terminates normally 
second argument checked statically pc 
operation terminate ways terminate normally case evaluated 
operation terminate ways terminate 
path labels expression derived applying operator path labels individual expressions normal termination path removed 
arithmetic operations throw exception division modulo second rule applies 
operations throw exception second argument zero 
simplify description static checking function exc 
definition repeated bottom 
function creates set path labels just input path labels include additional path exception path label normal termination normal termination value observed knowledge exception thrown may leak information knowledge thrown 
exc applies label components nv 
example division rule arithmetic exception thrown depending value denominator static rule applies exc nv 
extend final var final type part var label fresh uid extend extend extend extend statements var label labeled label part pc fresh variable local variables adding local variable definitions static checker stores information local variables environment 
function extend defined augment environments definitions local variables 
applied statement function extracts local variable definitions needed java jflow allow variable definitions point method 
angle brackets placed statement argument clarity 
statement forms function extend returns unchanged environment 
local variable definitions adds appropriate binding shown case 
note label variable interpreted environment variable may label 
sequence statements considered single statement second definition recursively applies extend statements sequence accumulate definitions 
function var label creates appropriate label variable declared extended type 
variable declared label true label declared label joined pc point declaration 
access variable tainted pc applying weaker label variable immutable 
argument variable definitions added environment different set rules see section 
variable access simple rules accessing variables components objects 
rule covers expression consisting variable name 
value variable labeled variable label current pc 
joining label current pc necessary label expression includes pc expression occurs 
label variable includes pc point declaration variable 
second rule covers array index expression 
rule mirrors order evaluation expression 
array expression ea evaluated yielding path labels xa 
completes normally index expression eb evaluated yielding xb 
completes normally tests performed 
array checked sure null index checked sure bounds array 
test fails appropriate exception thrown 
meaning final antecedent rule label array index expression depends labels array expression index expression array elements la 
possible var final uid pc nv pc ea la ea xa pc xa eb xb exc xa xb xa nv nullpointerexception exc xa nv xb nv nv la nv ea eb field label xe exc xe xe nv nullpointerexception nv xe nv final signature class env labeled label part field label array xe exc xe xe nv nullpointerexception length accessing variables fields termination paths array index expression include normal termination paths ea eb plus exceptions just mentioned 
rule uses operator coalesce paths 
third rule checking accesses instance variables fields 
similar rule checking array index expressions index evaluated tested 
label instance variable obtained predicate field label defined just 
predicate ensures label label field type predicate obtain field signature interpreting label signature 
field label predicate useful shortly 
final rule checks accesses immutable pseudo field length arrays 
note value length labeled label array elements immutable 
variable assignment var uid nv ea xa ea la pc xa eb xb pc xb ev xv exc xa xb xv xa nv nullpointerexception exc xa nv xb nv exc xa nv xv nv xv nv la ea eb ev field label pc exc nv nullpointerexception nv assignment rules contains various rules assignment 
rule covers simple assignment expression non final local variable termination paths statement exactly expression restriction label variable restrictive label result assigned nv 
rules assignment array elements object fields complicated fact java defers checking validity variable assigned right hand side fully evaluated 
rule array element assignment similar rule array element access 
array expression ea evaluated yielding path labels xa 
completes normally index expression eb evaluated yielding xb 
assigned value evaluated 
java checks possible exceptions performing assignment 
avoiding leaks requires label array elements la restrictive label information stored xv nv 
assignment instance variable similar access instance variable 
earlier rule predicate field label obtains label instance variable 
label compared label assigned information prevent leaks 
compound statements extend pc xe pc xe nv pc xe nv xe fresh variable pc goto xe pc xe nv xs xs xe xs goto compound statement rules presents rules checking compound statements 
rule simplest statement containing statements sequence statements 
second statement executed statement terminates normally pc augmented include information normal termination 
environment second statement includes local variables defined 
possible termination paths sequence include termination paths plus abnormal termination paths 
note statement sequence operator assumed associative rule works sequences statements 
rule shows check statement 
path labels xe expression determined 
execution conditional statements include value label xe nv 
statement terminate paths terminate ors normal termination normal termination cause executed 
statement clause statement considered empty statement second rule applied 
third rule statement subtle presence loop 
rule introduces label variable represent information carried continuation loop xe xe xe rv xe nv return pc goto continue goto break goto fresh variable goto pc goto checking goto statements jflow various paths 
label loop invariant pc value discovered constraint solver described chapter 
may carry information exceptional termination break continue statements occur inside loop 
entry added environment goto capture information flows break continue statements loop 
rules checking break continue section environment entries apply proper restriction information flow 
goto statements gives rules checking statements transfer control non locally 
rule return statement 
return statement terminate abnormal termination expression evaluated path 
rule shown results 
expression return proper path labels simply pc 
path labels generated return constant return value label rv 
break continue statements handled special entry environment keeps track label containing information transferred targets 
rule saw example entry break continue statements lacking specific target 
break continue transfer information current pc target rule statements simply requires restrictions current pc transferred target expressed pc goto 
statements generate path labels containing mapping tuple goto label 
reason adding mappings prevent single path rule erroneously 
label label binding equal 
class 
xe exc xe xe nv throw try try catch ci vi si 
try catch ci vi si 
xs pci exc label xs ci pc pci vi var final ci pci fresh uid si xi xi uncaught xs ci try catch ci vi si 
exc label try uncaught ci sx ci try statements rule ensures appropriate environment entries created named goto targets 
introduces binding name goto label maps goto label variable binding placed environment check 
rule exploits non determinism conciseness statement sequencing associative rule clear sequences statements considered 
necessary contain break statements naming contain continue statements naming 
chosen manner program incorrect 
jflow compiler implementation precisely follow approach described rule method constructs table targets maps targets label variables 
table impose condition pc targets break continue statement encountered just rule 
exceptions exceptions thrown caught safely jflow usual java constructs 
shows rules various exception handling statements 
rule throw statements straightforward 
rule shows arbitrary statement form try 
catch 
try 
catch statement nested try 
statement reduces set statements true try throw new false catch implicit flow throw checked statically 
idea try 
catch rule catch clause executed pc includes paths cause clause executed paths exceptions exception class subclass superclass class named catch clause 
function exc label joins labels paths path labels join finite exceptions paths need joined 
path labels statement merge path labels various catch clauses plus paths xs caught catch clause include normal termination path xs 
try 
rule similar rule sequencing statements 
interesting difference statement checked exactly initial pc executed matter terminates 
see exception rules consider code 
example boolean variables 
code transfers information implicit flow resulting exception 
fact code equivalent assignment rule path labels throw statement path labels statement 
assignment false checked pc code allowed 
restriction correct exactly equivalent assignment statement required 
applying try catch rule single path rule value pc code fragment seen start 
throwing catching exception necessarily taint subsequent computation 
dynamic type discrimination java provides mechanisms dynamic type discrimination checked run time type casts instanceof operator 
rules checking constructs shown 
straightforward 
case result expression depends label value expression instanceof path labels boolean result run time cast path labels thrown wrong dynamic type exception conditional value label thatis xe nv 
instanceof xe exc xe xe nv dynamic type discrimination pc interp pr param uid pc nv nv interp uid pr param uid ph ph actsfor checking actsfor statement checking new statements expressions previous section rules checking information flow existing java statements expressions 
section shows statically check jflow statements expressions java 
testing principal hierarchy actsfor statement dynamically test relationship principals current principal hierarchy 
relationship exists named principals statement executed 
shows statement checked statically 
expressions identifiers condition enforced function interp interpret 
name external principals run time principals principals class parameters type principal available run time tested 
expressions identifiers generate exceptions evaluated 
name run time principals values may carry information affects result test information labels nv nv 
reason pc augmented include labels 
ph component environment augmented include pair making knowledge available statically checking 
note extra knowledge available statically checking discussed section negative xe interp xe nv interp auth label declassify interp pc auth label pc xs xs xs pc declassify auth label auth policy declassification statement expression information principal hierarchy useful static checking 
declassification jflow provides mechanisms information declassify expression declassify statement 
constructs checked statically static authority code point invocation shown 
static authority code stored environment entry auth set principals principals code currently known authority act 
principals principals auth act implicitly static authority 
check label declassified equation auth label satisfied enforcing constraint la section 
label auth label contains policies form policy principal auth 
label equivalent la label policies form policy principal static authority additional policies redundant redundancy rule section 
rule determines path labels expression ensures label value xe nv declassified label second rule ensures current pc declassified desired label new declassified pc check statement declassified pc carry statement declassify fourth line rejoins pc normal termination label 
exceptions return statements performed able take advantage declassified pc paths joined pc 
statement defined modify pc subsequent statements defining xs definition result unintentional declassification 
semantics chosen engineering choice avoid programming accidents 
run time label tests xe li interp li xe nv li lrt ti interp ti ti pc xe pc pc label xe nv li pc pc vi var final ti li fresh uid si xi xe xi switch label case ti li vi si 
checking switch label interesting aspect checking jflow checking switch label statement inspects label value run time 
inference rule checking statement 
intuitively switch label statement tests equation xe nv li arm finds equation holds executes 
test evaluated statically run time 
reason test split stronger conditions tested statically tested dynamically 
rule naturally contains static part test 
lrt join possible run time representable policies policies mention label principal parameters 
static test xe nv lrt li lrt simpler equivalent test xe nv li lrt dynamic test xe nv lrt li lrt tests imply full condition xe nv li 
test may information channel check pc include labels xe nv li point 
rule uses label function defined determine labels join 
applied label function label generates new label includes policies variables mentioned function complicated possibility transferring information dynamic principals information channel captured function pr label 
extracting label dynamic component account possible presence recursive label 
intuitively label component dynamic uid simply label label refer component contains 
recursive label generated static checking rule seen far created constraint solver 
definition function subst rewrites eliminate recursive accordingly deferred chapter constraint solver discussed 
label label label label param uid label covariant label uid label dynamic uid subst uid label policy ri pr label pr label ri pr label case pr external name pr param uid pr dynamic uid method constructor calls label label static checking object oriented languages complex various features jflow add complexity covariant invariant class parameters implicit argument parameters method constraints 
section shows despite complexity method calls constructor calls operator new checked statically 
generic checking rules checking method constructor calls shown figures 
avoid repetition checking static non static method calls constructor calls expressed terms predicate call defined 
predicate turn expressed terms predicates call call 
predicate call checks argument expressions checks constraints calling method satisfied 
produces label li argument environment aa binds method arguments appropriately labeled types default return label def rv invoking method requires evaluation arguments ej producing corresponding path labels xj 
argument labels bound aa labels lj line xj nv lj ensures actual arguments assigned formals 
label explicitly declared tested interpreted required restrictive pc evaluating arguments xmax 
label declared implicit parameter bound max 
passes test max automatically 
predicate satisfies constraints call establish constraints kl calling method satisfied 
caller actsfor constraints need satisfied authority constraints tested class method compiled method 
rule predicate uses function interp call maps identifiers method aa li def rv call qi ej call qi aa li def rv call qi ej static aj 
throws 
kl pc pc xj ej xj lj fresh variable fresh uid ac class env qi aa ac aj var final type part ac lj 
li interp aa xmax lj labeled label part aa li lj xj nv lj xmax li def rv void jxj nv satisfies constraints aj ej kl li def rv call qi ej interp interp call case ki authority true caller pj 
pj auth interp pj actsfor interp interp satisfies constraints ki static aj 
lr li throws 
kl interp lr labeled label part def rv ck type part class env qi xj lr nv ck label part lr 
call qi li def rv generic method call checking constraints corresponding principals 
function defined 
perform mapping function needs environments corresponding calling code called code aa special environment binds actual arguments am 
environment entry auth contains set principals code known statically act 
interp call interp case pr dynamic uid interp interpreting principals method call predicate call produces path labels method call assuming method returns path labels header claims 
label def rv label return value case return type labeled 
joins labels arguments typically return value function depends arguments 
rule shows default label label label included labels exception paths label return value 
argument labels default included exceptions depend arguments function argument labels included default programmer encouraged write method specifications overly restrictive 
specific rules checking calls rules various kinds method calls built top framework shown 
subtlety arises rules constructors checked static methods similar signature 
function signature obtains signature named method class 
ordinary method calls checked call predicate straightforward manner 
pc call predicate set normal termination path expression method receiver es 
static method calls checked simply evaluation method receiver arguments evaluated 
final rule covers calls constructor handled similarly call static method 
fact rule shows constructor call checked static method class 
additional check needed constructor calls 
recall class declaration authority clause mentions principals objects class act 
kinds principals may named clause external principals parameters class type principal 
authority external principal derives user installs class system authority principal parameter derives code creates object calling constructor 
rule shows static authority caller include actual principal parameters passed position formal parameters happen listed authority clause class 
es qi 
ej tj signature qi tj es xs pc xs nv call qi ej es ej 
interp ej tj signature tj call ej ej 
qi 
interp ag class pi 
authority pk 
ej tj signature tj aj 
throws 
kl static dummy aj 
throws 
kl call ej parameters pk auth interp pk class env new ej 
checking classes methods method constructor call checking rules checking virtually statements expressions jflow defined 
rules relied environment properly set entries auth ph entries method argument variables class parameters 
section addresses static checking information flow entire class definitions including method constructor declarations 
checking classes class contains number methods possibly extends superclass interfaces 
may granted authority external principals principals parameters 
rule describes various components class checked terms number lower level predicates discussed sections 
function inner class env create environment contents class checked 
function defined earlier section 
adds definition environment formal parameter class 
example label parameters class bound entries form param label uid stand actual parameters supplied instantiation ag class pi 
mm 
final vn 
extends ts implements tj authority pk 
inner class env authority ok match method interp ts mm match method interp tj mm interp param id pi check method mm final true invariant type part invariant label part check class checking class class 
static checking rules conservative respect parameters ensuring class statically check actual parameter substituted corresponding formal parameter 
type expression ts denotes superclass type expressions tj denote interfaces implements 
type expressions interpreted environment may mention formal parameters class various aspects class declaration checked statically 
successive lines rule correspond static tests discussed detail remainder chapter 
authority declared authority clause class granted class 
authority great authority superclass 
conditions tested predicate authority ok described section 
signature method mm compatible signatures inherited superclass interfaces class implements 
predicate match method section verifies compatibility 
methods class provide implementation safe respect information flow obeys declared signature method 
predicate check method ensures methods class properties described section 
covariant label parameters may construct labeled type instance variable vn declared final 
instance variables mention covariant label parameters mutable create information leaks 
ag class pi 
extends cs implements tj 
authority pk interp pk class authority case pr external uid pr param uid true ag auth ag cs class cs authority pl 
ag interp pl authority ok checking authority class authority clause class declaration validated external principals listed clause granted authority installation class 
authority clause may name principals parameters class discussed section authority principals granted time object creation 
predicate authority ok checks claimed authority global environment shown 
final lines rule enforce condition authority declared authority clause class great authority declared superclass 
authority obtained inheriting methods superclass 
method signature compatibility methods class signatures compatible methods superclass interfaces implements 
jflow follows java requiring exact matches argument types method considered overloaded methods distinguished argument types 
labels argument return types part method identity need class superclass 
usual contravariance covariance type rules ac argument labels may restrictive return labels exception labels may restrictive 
cases subclass able accept values method arguments may return fewer values 
addition constraints superclass method sufficiently strong guarantee satisfaction constraints subclass method 
conditions enforced match method test 
jflow object oriented languages essence test method conformity subclass method valid implementation superclass method case object method invoked subclass type 
rule performs exactly test additional condition types method arguments equal classes java rule 
strengthen ag class pi 

throws 


class env qi li check arguments kl type part type part obj env qi call qi check body li match method qi static throws 
match method qi superclass method conformance match method qi ag class pi 
extends ts implements tj 
class env qi extends ts match method interp ts implements tj 
match method interp tj match method qi recursively checking method compatibility ing condition needed subclass method valid implementation superclass method types method arguments subclass supertypes corresponding method argument types superclass 
java enforces rule supports overloading needed type soundness 
rule subscript indicates superclass components subscript indicates subclass components 
goal rule check signatures methods 
signature signature method body method irrelevant test 
rule works simulating checking call method method signature 
second rule shows checking method signature conformance needed static methods 
unnecessary constructors 
match method test satisfied rule superclass qi 
method matching name argument types condition easily described words inference rule 
method compatibility insured direct superclass indirect super static aj 
throws 
kl li check arguments aj kl static obj env qi check body li li check method qi checking method declarations lj fresh variable fresh uid aj var final type part lj 
interp covariant label fresh uid lj arg label li pc li auth constraint authority kl ph constraint ph kl auth auth li check arguments aj arg label labeled label part covariant label fresh uid checking method header classes interfaces 
match method test rule check class applies function match method supertypes class shown 
method declarations kinds methods object methods static methods different kinds constructors 
object methods static methods treated similarly 
predicate check method defined methods shown 
parts rule method arguments aj constraints kl create environment body method statement checked 
method non static environment effectively extended include definitions identifier non final instance variables 
saw earlier checking calls different kinds methods common general predicates call call defined capture common checking 
similarly common checking declarations different kinds methods 
particular checking method arguments paths method termination involve common 
common checks defined check arguments check body predicates defined figures 
caller call call method check arguments check body structure method checking checking method arguments 
check arguments predicate similar form call predicate defined earlier 
surprising predicates callee side tests method arguments respectively indicated intuitively 
check arguments predicate establishes label li label object non static method 
label defined interpretation label provided label parameter 
case initial pc checking method body defined li 
omitted li defined fresh label parameter mentioned outside method 
results computations performed method stored externally external label provably restrictive li 
reason methods lacking explicit label side effect free 
predicate check arguments establishes environment statically checking body method 
contains definitions arguments method 
arguments automatically final variables declared type 
method arguments scope label expressions method header level indirection required define labels 
allow variables refer arguments aj bound label variables lj third line 
equations constructed require lj equivalent interpretation label part environment contains bindings aj 
indirection allows label parts refer variables 
note label li automatically part argument label 
sixth line establishes environment check body method 
environment extends argument environment add definitions method body pc authority auth static principal hierarchy ph 
functions constraint authority constraint ph defined construct definitions 
seventh line ensures authority claimed method authority clause subset authority possessed class 
environment defined inner class env function contains class authority seventh line requires principal method authority authorized principal class authority may principal parameter 
constraint authority kl case kl authority pl interp pli 
caller pl interp 
constraint ph kl ph case kl actsfor pl interp pl interp pl ph building environment entries constraints lr xs interp li li lr labeled label part lr nv rv type part label part lr check body li checking method body checking method bodies 
environment established check arguments checking method body completed check body predicate shown 
rule determines path labels environment requires result path labels declared method header restrictive path labels need second argument clear point checking constructors 
effectively allows insertion arbitrary statement executed method body ordinary methods 
checking constructor bodies 
constructors checked similarly ordinary methods added complexity need initialize instance variables invoke superclass constructors 
con aj 
throws 
kl final vars check arguments aj pk li obj env qi check body li check method qi simple constructor aj 
throws 
kl em check arguments aj pk li ag class pi 
qi param id pi new qi em obj env qi check body li check method qi constructor superclass constructor invocation class final instance variables superclass checked simply shown 
condition final vars prevents having final instance variables 
constructor may defer initialization constructor class shown 
checked constructor body executed object class created 
final form constructor invokes superclass constructor shown 
final instance variables initialized call superclass constructor 
object instance variables scope prologue constructor call superclass constructor 
scoping rule shown environment contexts 
checking instance variable initialization 
constructor prologue checked keeping track final instance variables initialized 
check inits predicate describes checking 
predicate builds new environment final instance variables type label placed label checking 
contains final rule improves static reasoning dynamic labels constructors keeping track expression final instance variables type label initialized 
rule preferentially general rule initial statement effect instance variable initialized final variable type label variables share uid treated containing label 
rule expect obtain fresh aj 
throws 
kl super em check arguments aj pk li check inits final vars ag class pi 
extends ts pc new ts em var final qi pc fresh uid pc check body li check method qi constructor final instance variables true check inits pc class final xe xe nv label part pc xe check inits xe check inits pc check inits check inits checking instance variable initialization uid treated statically containing different label 
optimization avoids unnecessary dynamic testing labels situations determined identical statically 
class final var final label uid pc label part var final label label part uid check inits check inits improving static reasoning dynamic labels example situation implementation class protected 
assignment context checked statically lb ll bound dynamic label variable rule 
key step rule fifth line creates environment setting label instance variable uid label assigned variable seen second line 
chapter constraint solving translation chapter covers aspects implementing jflow described chapter 
depicts top level structure jflow compiler 
dark ovals indicate parts implementation described 
chapter described phase static checking application inference rules rule checker 
second phase static checking constraint solving described section 
constraint solving assign labels automatically local variables program counter pc 
satisfying assignment constructed constraint solver jflow program translated equivalent java program process described section 
constraint solving rules static checking applied generate constraint system labels method 
example assignment rule generates constraint nv constraint system labels unknowns called label variables 
job constraint solver jflow program inference rules rule checker translator java program constraint system structure jflow compiler constraint solver find assignments label variables satisfy constraints 
inference rules generate label variables function fresh variable described section 
section describes final step statically checking jflow code solving system constraints generated application inference rules producing satisfying assignments label variables 
producing satisfying assignments constraint solver automatically infers labels local variables program counter 
integrating static checking constraint solving inference rules chapter check program antecedents form label constraints encountered 
general constraints contain label variables tested constraints encountered 
static checker records constraints consideration 
constraint takes form environment labels 
constraints may take form constraint equivalent pair constraints 
deferring checking label constraints safe searching necessary apply inference rules previous chapter despite apparent non determinism rules 
selection rule apply step syntactic considerations particular label constraint satisfied 
words removing antecedents inference rules label constraints effect rules need applied show program correct 
solving constraints practical done method method basis entire program 
rules previous chapter explicit constraints generated statically checking method affect constraints method constraint systems various methods solved isolation loss expressive power 
property holds label variable constraint solver find value associated method constraint mentions label variables method 
constraint systems tend small constraint system generated method solved isolation 
constraint equations step solving set constraint equations put canonical form 
constraints generated application inference rules form may join labels 
step creating canonical constraint equations break labels individual components 
letter denote label containing single component labels written join components 



properties join operator constraint equivalent set individual constraints 

left hand side component canonical form constraints left hand side equation single component 
constraint lhs rhs lhs label rhs rhs policy ri label param uid covariant label uid dynamic uid variable uid lhs lrt grammar canonical constraints canonical form constraint expressed grammar 
terminals grammar expressions appear static checking rules previous chapter 
simple component types policy label param covariant label dynamic components may appear constraint solver solution 
job constraint solver replace label variable join simple components result constraints satisfied 
components components summarized policy ri policy label param uid invariant label parameter covariant label uid covariant label parameter dynamic uid dynamic label contained final variable type label variable uid label variable label solved join components invariant label parameters lrt join run time representable components label label label may contain simple components variable components certain terms may appear right hand side equation left special labels lrt checking switch label statement invariant predicate respectively 
labels infinite expanded static checking 
constraint term may take form label label function label defined earlier 
applying label join components defined join label applied individual components 
result applying label label components defined label variables type variable uid 
function label shows canonical constraint equations terms form label variable uid 
dynamic labels unique property contain label canonical form constraint system internal label reduced canonical form join simple components label variables shown grammar 
constraint equation contains just pair labels contains environment records static checking environment label constraint occurred 
part static checking environment relevant label constraints static principal hierarchy stored ph 
static principal hierarchy affects judgements relation policies seen earlier 
solving constraints simple iterative list algorithm solve constraints canonical form just described 
ignoring dynamic components terms involving function label constraint equations form simple system lattice constraints solved generalization linear time algorithm satisfying boolean horn clauses dg rm 
horn clause algorithm works join operator appears constraint equations meet operator allowed sat problem reducible form constraint solving problem np complete rm 
algorithm works keeping track conservative upper bounds label variable iteratively refining upper bound downward label lattice 
initially upper bounds set top label lattice 
algorithm iteratively refines upper bounds constraints satisfied contradiction observed 
upper bound variable join simple components 
step algorithm picks constraint satisfied label variables substituted upper bounds applies constraint forcing satisfied 
possibly unsatisfied constraint applied follows constraint label variable lefthand side upper bound estimate variable lowered meet current upper bound value right hand side 
upper bound variable denoted 
evaluating right hand side variables replaced current upper bound estimates 
words constraint form label variable join components satisfied assignment 
assignment ensures constraint question satisfied current assignments variables appears assignment effect constraint satisfied existing 
meet operator produces restrictive label restrictive operands new restrictive label managing satisfy constraint old upper bound 
inductively new upper bound remains conservative 
step constraint solving upper bound variable join components sorts allowed final solution policy param label covariant label 
constraints satisfied upper bounds variable legal satisfying assignments 
step component left hand side unsatisfied constraint variable constant policies named constraint system solvable contradiction observed 
reason constraints solvable variable assignments conservative upper bounds set refinements variable assignments cause unsatisfied constraint satisfied 
labels simple algorithm restrictive labels satisfy constraints 
actual values inference algorithm finds irrelevant converted class values type label 
important satisfying assignment labels proving code safe 
special labels lrt added constraint system checking switch label state ments invariance labels respectively 
principle labels join potentially infinite set components 
practice integrated algorithm just described straightforward manner 
recall lrt join run time representable label components defined section 
label lrt appears constraints form lrt variable component join arbitrary terms 
constraint selected satisfied updated just simple algorithm 
new lrt equivalent lrt distribution properties term lrt intersection lrt join run time representable components 
words infinitely large label lrt manipulated expansion full form 
label treated similarly 
label defined section arises occurrences invariant predicate 
predicate results constraints form 
constraint selected satisfied upper bound changed words components form covariant label uid dropped upper bound determining meet components section rule meet labels defined 
model chapter labels contained policy components 
rule meet extends labels containing simple kinds components preserving necessary label lattice properties 
rule follows directly rule ordering operator earlier section 
chapter meet components relabeling relationship bottom label 
components label param uid label param uid label param uid covariant label uid covariant label uid covariant label uid dynamic uid dynamic uid dynamic uid policy ri policy policy ri policy ri policy ri policy ri policy meet related components relabeling relationship rules meet defined rules 
note meet components defined respect static principal hierarchy thisis indicated rules writing static principal hierarchy subscript note rules correspond definitions section 
notation indicate acts vice versa 
handling dynamic constraints algorithm described previous section handle terms constraint equations form label variable uid 
terms may generated uses switch label construct seen rule 
term form may occur left right hand side constraint equation 
consider handle terms form occur right hand side 
important property constraint systems considered previous section upper bounds refined downward label lattice values right hand sides constraint equations change monotonically downward lattice 
upper bound variable iteratively takes values vn constraint solving case vn 
addition right hand side constraint label decreases monotonically solving 
property important ensuring conservative upper bound application constraints non variable left hand side delayed constraints variable left hand side satisfied 
structure function label important property preserved terms label 
definition label earlier reproduced 
definition allows function label applied current upper bound variable defined components occur upper bound 
label label label label param uid label covariant label uid label dynamic uid subst uid label policy ri pr label pr label ri pr label case pr external name pr param uid pr dynamic uid label label label applied dynamic component result contained label substitution applied function subst may necessary handle recursive effect described shortly 
constraint solver refines variables downward current upper bound contained label changes downward monotonically result applying label dynamic component 
constraint solver iteratively refines upper bounds variables set dynamic components current upper bound variable decrease size upper bound refined meet operator 
function label applied label result may contain components derive policy components principals policy variables type principal 
function pr label extracts label policies 
just dynamic components set policies upper bound decrease size 
set dynamic components policy components decrease constraints applied result applying label kind component move downward label lattice result applying label label move downward label lattice 
argument shows terms form label behaved constraint solving constraint solving algorithm needs little modification support terms form right hand side constraint equation 
constraint refine upper bound variable terms form evaluated current upper bound variable definition label 
terms form label may appear left hand side constraint 
constraint form label called dynamic constraint 
dynamic constraint applied differently constraints 
satisfied component label covered component 
component come contained label dynamic component policy 
general ways refine upper bounds variables constraint system ensure part label 
general refinement guaranteed preserve upper bound property 
refinement drop component lowering upper bound possible contains includes variable component part source dropping ensure constraint label refinements dropping ensure constraint refinement general safe sense guaranteed upper bounds respective variables 
refinements guaranteed confluent 
ambiguity refinement apply eliminate particular component dynamic constraint deferred unsatisfied constraint applied 
unsatisfied constraints dynamic constraints ambiguity jflow constraint solver selects refinement dropping 
arbitrary choice results contradiction constraint solver reports unable prove method correct reporting method provably incorrect 
case programmer add label annotations code help constraint solver 
adding label annotations usually straightforward 
necessary code contains relatively infrequent switch label construct label expression label tested case labels partly inferred automatically 
case programmer annotate code explicit labels order avoid need infer 
label inference algorithm complete code containing switch label statements sound 
possible provide complete constraint solver adding searching allowing refinements tried 
worst case solving time exponential size program 
recursion dynamic components problem unique dynamic components recursion 
dynamic component evaluated current upper bounds label variables upper bounds may mention dynamic component evaluated creating infinite recursion 
situation arise label variables refer function definition void label label 
function arguments type label dynamically labels 
function result constraints form la unique identifiers various components variable dynamic lb variable variable dynamic la variable assuming constraint applied algorithm described far refine upper bounds infinite sequence variable variable variable dynamic lb variable dynamic la dynamic lb variable dynamic lb dynamic la dynamic lb variable dynamic la dynamic lb dynamic la dynamic lb 
avoid recursion additional kind component needed label contained dynamic component refers containing label 
kind recursive occur initial set constraints reduced canonical form previous example demonstrates arise constraint applications 
component form uid support recursive dynamic components components form dynamic uid label contains enclosing component 
prevent infinite recursion replaced component form uid matching uid 
previous example solved follows variable variable variable dynamic lb variable dynamic la dynamic lb variable dynamic lb dynamic la lb variable dynamic la dynamic lb la 
point constraints satisfied upper bounds label variables 
components new form occur dynamic component refers variable 
definition label dynamic components take consideration possible presence components replacing containing component 
substitution performed function subst defined 
rewrites label third argument substituting occurrences uid second argument 
function subst needs defined simple components plus components 
ordering relaxation steps algorithm described may require nh constraint applications number variables constraint system maximum height label lattice 
height lattice subst uid pi 
subst uid pi 
subst uid label param uid label param uid subst uid covariant label uid covariant label uid subst uid policy ri policy pr subst uid pr subst uid ri subst uid uid uid uid uid pr subst uid case pr dynamic uid pr dynamic uid subst uid substituting away recursive label observed execution algorithm equal number non variable components constraint system 
number size method checked constraints selected application worst possible order 
performance algorithm usually improved intelligently selecting constraints applied 
section discusses select apply constraints satisfying assignment contradiction arrived rapidly possible 
constraint systems solved jflow static checker similar form dataflow analysis framework kil ku techniques accelerate iterative dataflow analysis accelerate solution 
key observation accelerating constraint solver dependencies different constraints constraint system 
concerned constraints left hand side variable constraints left hand side variable determine constraints satisfiable constraints satisfied 
constraint variable left hand side applying constraint result updated satisfied 
appears right hand side constraint said depend 
sense apply constraint enforced affects variable 
dependencies constraints envisioned dependency graph nodes constraints constraint system 
dependency graph directed graph nodes graph connected dependency corresponding constraints 
simplest case dependency graph acyclic constraint system solved application constraint 
case constraints topologically sorted applied sequentially order generated 
time required perform topological sort linear number constraints 
general dependency graph contain cycles 
example loops program generate ordered visited new boolean ordering new int position new int int visit void visit int visited return visited true iterator int dependencies visit ordered ordering ordered position ordered ordering constraint equations cycles label dependency graph 
rule statement section label variable introduced explicitly part constraint cycle 
cycles dependency graph result strongly connected components sets constraints constraint transitively dependent constraint 
strongly connected component handled simply looping constraints component turn constraint satisfied 
jflow constraint solver selects constraints topologically sorting constraints standard algorithm depth traversal constraints clr 
algorithm shown code 
code places indices constraints array ordering assumes dependencies produces iterator yields indices constraints dependent constraint inverse ordering placed array position 
applied directed acyclic graph algorithm produces ordering nodes node occurs node depends 
strongly connected components ordering identified depth traversal transposed dependency graph linear time algorithm clr 
algorithm strongly connected components effectively constructs schedule solving constraint system 
identified constraint solver applies strongly connected components topological order 
strongly connected component looped sequentially order node occurred original topological sort constraint component satisfied 
entire component satisfied constraints need consideration 
subtle benefit applying strongly connected components topological ordering constraints tend propagated effectively strongly connected component 
example strongly connected component comprising single cycle needs repeated order ensure constraints constraint applications required size constraint system terms fixed topo fixed fifo queue topo scc performance various heuristics ordering constraints component satisfied 
algorithm similar topological sorting identification strongly connected components priority scc algorithm optimize iterative dataflow analysis 
apart difference form constraint equations difference algorithms dataflow analysis algorithm orders variables constraints algorithm 
ordering basis individual constraints appears offer better performance empirical measurements 
number iterations required dataflow analysis algorithm shown nd maximum number back edges depth traversal constraint dependency graph 
dataflow analysis observed number back edges bounded reasonable programs property hold label constraints 
number back edges linear size graph proves difficult observe behavior asymptotic bound predicts example results section suggest behavior 
tighter bound run time algorithm shown 
empirical comparisons observed behavior jflow compiler constraint solving negligible part run time compiling methods tens lines length 
empirical analysis performance useful understanding performance constraint solving technique scales size constraint system 
algorithm identification strongly connected components algorithms solving dataflow systems empirically compared label constraint systems 
ordering algorithms empirically compared earlier dataflow analysis kw 
results observed dataflow analysis largely agree results label constraints shown 
axis maximum number iterations required solve complex system constraints containing number back edges linear number constraints various techniques choosing constraints 
size constraint systems tested somewhat larger constraint systems generated typical method definitions 
constraints systems form li variables li non variable constraint 
empirically constraints form require relatively large number iterations arrive fixed point assignment upper bounds 
maximum number iterations constraint system determined introducing components li meet possible subset li resulted different label 
programs behavior extremely resulting constraint system useful gaining understanding behavior algorithms 
constraint systems comparison related simple fashion consecutive constraint system smaller constraint system additional constraints 
performance heuristics ordering compared constraint systems 
comparison ordering heuristics common constraint solving framework 
framework uses information dependencies constraints keep track constraints unsatisfied step 
constraint known satisfied previously known satisfied variable right hand side modified point 
constraint ordering heuristics constraint applied known satisfied reasoning 
ordering heuristics tested fixed constraints placed fixed order potentially unsatisfied constraint applied step 
topo fixed constraints topologically sorted algorithm ordering fixed ordering 
fired ordering kanamori weise kw applied unsatisfied constraint selected step 
fifo queue fifo queue potentially unsatisfied constraints maintained 
standard technique iterative dataflow analysis kw 
topo scc approach implemented jflow constraint solver described section loops strongly connected components 
actsfor principal actsfor case param principal uid error constant principal jflow principal var final principal uid translating principals actsfor particular example results entire constraint system single strongly connected component 
situation worst case topo scc ordering comparison orderings 
topo scc ordering results substantially better performance ordering techniques 
results shown fact typical variety different kinds constraint systems containing strongly connected components 
interestingly best ordering techniques appear fifo queue ordering topological sort strongly connected components 
number iterations required simple fixed ordering grows sequence constraint systems simpler constraint systems contain strongly connected components 
translation jflow compiler static checker source source translator 
output standard java program 
annotations jflow run time representation translation erases leaving java program 
example type labels erased produce corresponding unlabeled java type 
class parameters authority clauses erased including label parameter array types 
method labels constraints erased 
declassify expression statement replaced contained expression statement 
variables built types label principal translated java types jflow lang label jflow lang principal respectively 
variables declared types remain translated program 
statements translate interesting code actsfor switch label statements 
translated code simple efficient shown figures 
figures translation jflow expression java expression translation statement principal values actsfor statement actsfor statement translates statement tests current principal hierarchy executes statement depending relation principals exists 
new label pn tl pn tl pn tl new label pn new label tl join new label tl join new label tl pn tl case var final uid tl constant principal label bottom param principal uid label bottom tl ri new label ri 
tl case var final label uid switch label case ti li si 
se tv tl xe nv lrt tl lrt tl xe nv lrt tl li lrt si se translating labels switch label class jflow lang principal provides static method actsfor test principal may act 
principals jflow represented classes subclasses jflow lang principal instances classes 
having class principal system simplifies management principal hierarchy java run time system 
principal object contains list principal objects act directly immediate superiors principal hierarchy 
object contains hash table maps principal objects booleans hash table actsfor tests performed quickly second times 
subclass principal contains static initializer sets object initial list superiors empty hash table 
subclass class principal located package jflow principal contains static variable type principal 
jflow code external principal translated expressions form jflow principal 
new principals may added freely package jflow principal principal responsible identifying principals may act adding new principal new privileges principal give power principal principal new principal 
right modify class principal order add new superiors controlled adding superiors removing superiors existing principal affect principal hierarchy potentially unsafe ways 
current implementation model aspect system appears straightforward 
label values switch label statement indicated labels simply erased jflow program translated java 
labels represented run time represented values type jflow lang label 
translation function tl translates label expression java expression generates appropriate run time representation 
undefined components representable run time label parameters 
note policies label translated translating principals mentioned policies policy representable run time principals mentions representable run time 
translation rule switch label uses definitions static checking rule switch label 
discussed earlier run time check performed xe nv lrt li lrt test mentions labels representable run time 
method check label relationship exists 
actsfor method accelerated hash table lookup cache memoized results 
chapter related thesis concerned problem protecting secrecy data 
problem recognized years referred confinement lam data confidentiality 
thesis referred protecting privacy goal protect data owned mutually principals secret data single entity government 
great deal gone addressing problem secrecy feasible enumerate 
chapter summarizes previous done various kinds security techniques relate particularly focusing information flow control 
access control systems protect privacy integrity discretionary access control usually called simply access control 
idea access control potentially dangerous action may taken computer program run time test ensure program granted necessary authority action 
access control mechanisms designed capabilities dv wcc access control lists lam various hybrid schemes rsc 
actions conform stated policies permitted reads writes higher level operations 
unix file permissions example simple known access control mechanism 
jflow provides simple mechanism controlling privileges program form static authority interesting compare existing java access control models stack inspection wf 
current versions java run time environment provided netscape microsoft sun implement variants model net mic gs 
java privileges needed perform various unsafe operations accesses local filesystem 
stack inspection approach privileges known targets 
class authorized claim privileges default class code possess privileges 
explicit operations provided enabling disabling privileges 
privilege needed order perform unsafe operation stack leading point invocation inspected run time 
class code stack point needed privilege enabled authorized claim privilege 
model allows class privilege enabled privilege explicitly 
privilege granted code trusted class claimed privilege 
privilege enabled explicitly granted implicitly act calling method privilege enabled 
set design choices differs respects jflow 
jflow principals may represent targets users 
authority clause class gives class power act named principals individual methods possess corresponding privilege explicitly declare 
models similar privileges available explicitly declared 
jflow authority granted called method explicitly passed argument type principal caller clause called method 
java called method need potential authority principal target 
stated reason preventing java models defeats attacks authority granted misused called method 
attacks greater concern java model authority granted implicitly 
jflow clear authority granted called method may run time parameter 
jflow allows authority bound object parametric fashion class require constructors called site possessing authority principal parameters authority bound object 
obvious difference models manner enforced 
jflow authority mechanisms largely statically checked support dynamic checking java model checked entirely dynamically consequent run time overhead 
static checking possible jflow authority transfers completely explicit 
java model access control largely subset jflow enforced load time extended java virtual machine class files extended explicit annotations granted authority 
limitations discretionary access control discretionary access control support privacy prevents information release control information propagation 
example consider tax preparer example section reproduced 
example bob preparing tax form piece software called 
bob able prepare final tax form trusting protect privacy 
bob impose access check determines preparer see tax data 
access allowed bob control preparer distributes information read 
forced trust program respect privacy correctly 
discretionary access protects privacy data vulnerable trojan horse programs 
just said privacy applies integrity 
program allows program modify data controlled may write data control obtains data write 
discretionary access control trust program affected data providing 
discretionary access control point sale mechanism final tax form bob spreadsheet preparer database tax preparer example tax data control propagation information release propagation information leading update 
information flow control case privacy integrity wanted way extend access restrictions transitively arbitrarily far point data released updated 
transitive extension possible conventional discretionary access control system decision transfer information program program authority privileges possessed restrictions data ultimate source destination apply enforced reliably information restrictions general lost 
insight leads information flow control mandatory access control models apply sensitivity labels data 
labels propagate data mediate information transfers programs 
restrictions data propagate data apply data derived 
privacy restrictions prevent data seen untrusted users integrity restrictions prevent untrusted data affecting storage locations 
overview information flow control denning den 
original model information flow secrecy comes early bell lapadula bl 
objects system assigned security classes small ordered set unclassified classified secret 
information flow partitions moving upward security class 
subject process system assigned security class data manipulates assigned security class 
read data subject lower security class 
bell lapadula model supports privacy information flow control controls writes access control 
non destructive writes permitted object higher security class destructive writes permitted objects security class 
rule prevents low level subjects overwriting high level data overwriting cause information leak 
common information flow enforcement mechanism dynamic 
fenton data mark machine dmm early model information flow enforcement fen fen example dynamic approach fine grained information flow 
program computes sensitivity labels security classes associated data values 
sensitivity label computed value restrictive sensitivity labels values computed 
dmm model label pc maintained run time 
weakness dmm model inability deal implicit flows precisely 
statement pc revert value jflow 
data computed conditional excessively labeled 
dmm model workable pc unaffected function call cost exceptions supported 
jflow allows program counter label revert method terminate normally allows fine grained tracking information communicated exceptions 
dod orange book requires dynamic mechanism enforcing mandatory access control mac secure systems class higher dod 
approach fixed label associated currently running process 
bell lapadula model process may read objects label lower level 
may write object equal label 
orange book specifies systems mandatory access control information leak leaving system channels 
kinds channels single level channels single fixed label data dynamically tested transmission multilevel channels allow arbitrarily labeled data transmitted dynamically transmit label data 
jflow language provides static dynamic enforcement information flow emphasis making static enforcement expressive possible 
dynamic enforcement features mandatory access control simulated jflow run time labels run time principals 
channels decentralized label model single level channels multi level channels simulated transmitting values type protected encapsulates value label 
jflow provides fine grained tracking information labels 
mandatory access control process tainted label data observed passes label data touches afterward making data unnecessarily restrictive 
approach necessary purely dynamic enforcement order prevent implicit flows 
fine grained static analysis jflow allows implicit flows prevented avoiding unnecessary restrictions 
considerable developing richer expressive models labeling data 
denning extended clarified bell lapadula label model notion lattice security classes den den 
model defined thesis information may relabeled upward lattice information derived multiple sources acquires label security class join labels sources 
decentralized label model quite fit denning lattice structure retains essential properties 
obvious difference decentralized label model supports limited form declassification 
label system looks different principal principal shares common set safe relabelings access declassification relabelings 
relabeling decentralized label model defines ordering relation denning model partial order labels may equivalent equal 
support lattice operations join meet equivalence classes labels operations distribute 
denning lattice framework instantiated flr multilevel security policies 
multilevel security policy pair hierarchical security class set categories 
hierarchical security classes form totally ordered set bell lapadula model categories arbitrary symbols 
multilevel security policy relabeled long 
categories operate reverse direction expect acceptable increase set categories decrease 
provide notion owners data potential readers data 
multilevel security policies common underlying model mandatory access control systems 
modeled straightforwardly decentralized label model introducing principals represent hierarchical security classes possible categories 
principals representing security classes corresponding acts relations principal representing top secret act principal representing secret 
multilevel policy cn translated decentralized label cn complete relabeling rule enforces exactly relabeling rule multilevel policies 
users security classifications introducing acts relations principals appropriate ci principals output channel user labeled root root highly trusted principal relabeling rule enforce appropriate restriction 
weakness translation allows user declassify data read flaw fixed approach section 
biba showed information flow control enforce integrity secrecy integrity dual secrecy bib insight employed subsequent systems applies decentralized integrity policies described section 
ix example real world information flow control system implements mac supports secrecy integrity policies simultaneously 
label models widely adopted 
popular theme models commercial applications capture conflicts interest allow non transitive flow policies cw bn tw fol 
chinese wall policy brewer nash bn subject study 
idea policy information labels able enforce separation duties 
example bank maintain separation accounts investments departments 
employee supposed handle investments bank access information customer accounts vice versa 
sandhu argued chinese wall policy implemented standard lattice labeling policy properly distinguishing users programs san 
decentralized label model separation duties enforced restrictions principal hierarchy labels 
group principals accounts investments introduced employee principals prohibited belonging groups 
structure arguably intuitive separation duties built principals labels individual pieces data 
modeling separation duties taken similar approach mapping user duties role hierarchy ggf 
decentralized label model similarities model models provide approximation originator controlled release labeling dod intelligence community 
model developed observation conventional mac dac policies adequately support kind security policy 
decentralized label model key concept ownership policies 
models support joining labels computation occurs model lacks important lattice properties attempts merge policies common owners 
model mandatory access control models process labels object labels float upward label lattice arbitrarily phenomenon called label creep leads excessively restrictive labels 
absence lattice properties dynamic binding labels objects processes static analysis model difficult 
interestingly allow owners replaced label components acl checks analogous acts checks support extension reader set 
model support form declassification 
practical information flow control systems provide ability declassify downgrade data strict information flow control restrictive writing real applications 
complex mechanisms inference controls den ss decide declassification appropriate 
declassification systems lies outside label model declassification performed trusted subject code authority highly trusted principal 
variant approach ferrari introduces form dynamically checked declassification special strict flow checking 
need declassification framework avoided fine grained static analysis 
applied dynamically mention specific data objects administrative run time overheads 
key advantage new label structure decentralized trusted subject approach principals system need trust declassification decision principal weaken policies principals act 
previous information flow techniques deal situations mutual distrust 
techniques originally designed protect privacy integrity data owned single principal typically government 
considers privacy integrity decentralized setting community web users clear universal notion secret sensitivity established 
label including hierarchical security class acceptable decentralized environment 
schemes containing generalized lattice labels solve problem mutual distrust 
consider tax preparation example lattice mac system 
bob act preparer vice versa final tax form example labeled bob preparer able read result safe useful 
jflow provides programming model integrates information flow control simple model access control 
stoughton sto developed purely dynamic model integrating access control information flow control defined formally denotational semantics 
model implemented 
model objects current access level potential access level 
potential access level enforce information flow constraints mandatory access control systems 
current access level enforce discretionary access control relaxed appropriately trusted principal point restrictive potential access level 
relax violate information flow control 
model support declassification 
model purely dynamic treat implicit flows securely 
model access control particularly simple mediates accesses level reads writes objects provide ability control higher level operations 
static enforcement security policies jflow unusual integrating information flow control access control providing static dynamic enforcement mechanisms 
prior security focused dynamic enforcement earlier static enforcement access control 
jones liskov defined system statically enforcing discretionary access control scheme restricted types methods marked inaccessible jl 
rules define form subtyping security guaranteed inability cast downward type hierarchy dynamically 
lack capability dynamically enforcing access control checks scheme impractical 
model access control rsc model mixed static dynamic enforcement access control practical 
jones liskov model objects may type certain methods inaccessible 
objects cross protection domains new copies constructed method accessibility recomputed lazily 
jflow methods called caller constraints satisfied 
objects passed different trust domains method accessibility changes automatically static reasoning authority rewriting needed 
static analysis applied information flow control early denning denning dd adopted widely limitations 
static checking allows fine grained tracking sensitivity integrity labels program computations run time overhead dynamic security classes 
approach inspects entire programs significant advantage simple dynamic checking program checked determine possible execution results security policy violation 
dynamic checking needed programming examples previous static checking techniques integrate dynamic checking making impractical 
earlier static checking techniques handle exceptions 
approach checking programs information flows statically automatic semiautomatic theorem proving 
researchers mitre mil mil sri fei developed techniques information flow checking formal specifications 
fei developed tool automatically checking specifications boyer moore theorem prover 
interest provably secure programming languages treating information flow checks domain type checking require theorem prover 
palsberg rb developed simple type system checking integrity po 
volpano smith irvine taken similar approach static analysis secrecy encoding denning rules functional type system showing sound standard programming language techniques vsi vol 
abadi aba examined problem achieving secrecy security protocols typing rules shown encryption treated form safe declassification primitive encryption operator 
heintze riecke hr shown information flow labels applied simple language types slam calculus 
show statically check integrated model provides access control information flow control integrity 
model similar stoughton earlier dynamic model labels include components enforces conventional access control enforces information flow control 
model inherits limitations stoughton model 
models smith volpano irvine heintze riecke limitation entirely static jflow run time access control declassification run time flow checking 
models provide label polymorphism support objects 
addition features important supporting realistic programming model programming language difficult treat conventional tools programming language theory 
heintze riecke prove useful soundness theorems model 
step desirable jflow various language extensions formal proofs correctness difficult point 
modeling principals roles notion principal hierarchy decentralized label model similar models modeling roles 
acts relation similar speaks relation introduced lampson describing authentication distributed system 
model notion compound principals introduced compound principal expression bob manager ordinary principal manager role 
decentralized label model provide structure compound principal modeled third principal bob acts acts manager 
role access control introduced notions role hierarchy various kinds dominance relations principals roles fk 
structure model assignment users groups roles similarly decentralized label model 
roles security classes information flow model san 
model distinguish roles information flow labels information flow upward role hierarchy 
cryptography minds people computer security associated encryption 
reasonable ask cryptographic techniques related 
encryption achieve important security goals subsidiary protecting privacy integrity computer security research focused 
goal authentication reliable identification requesting action performed lam ablp 
computer systems password checking authenticate users 
distributed system form encryption generally needed perform authentication securely 
reliable authentication prerequisite protecting privacy integrity 
example access control mechanism requires underlying authentication mechanism sure process possess granted authority claims 
important feature secure system reliable information channels subverted unrelated third parties 
encryption protects privacy preventing channels having information extracted digital signatures protect integrity preventing new material inserted channel third party fool receiver 
encryption technology reliable authentication secure channels researched heavily widely available systems kerberos sns ssh 
encryption provides elemental protection privacy integrity 
assumption technologies available standard component builds 
covert channels ignored covert channels arising time measurement thread communication 
channels long recognized difficult control lam 
scheme statically analyzing thread communication proposed rei ar essentially second pc added different propagation rules 
local pc handles information flow thread global pc restricts operations communicate threads 
stoughton model sto uses local global approach 
technique control timing channels 
approach applied jflow checked statically similarly static side effect region analysis jg aims infer possible side effects caused piece code 
clear scheme works practice restrict timing communication quite severely particularly applied directly programming model objects shared threads 
programming model object modifications potentially asynchronous communications threads highly restricted limited pc shared threads 
smith volpano developed rules checking information flow multithreaded functional language sv 
expected rules define prevent run time program depending way non public data arguably impractical 
chapter protecting privacy secrecy data long known difficult problem 
increasing untrusted programs decentralized environments mutual distrust solution problem important difficult solve 
existing security techniques provide satisfactory solutions problem 
goal information flow control viable technique providing privacy complex decentralized world mutually principals 
information flow control attractive approach protecting privacy integrity data allows security requirements extended transitively away principals security protected 
widely accepted technique excessive restrictiveness imposes computational overhead 
address limitations conventional information flow techniques focuses areas 
new model decentralized information flow labels provides ability express privacy policies multiple mutually principals enforce security requirements simultaneously 
second new language jflow permits static checking decentralized information flow annotations 
jflow practical programming language allows checking 
decentralized label model decentralized label model described chapter information flow practical removing unnecessary restrictiveness earlier models 
provides considerable flexibility allowing individual principals attach flow policies individual values manipulated program 
incorporates notion principal hierarchy allows policies expressed terms behalf complex authority entities groups roles 
practical information flow systems require ability declassify downgrade data 
policies decentralized labels notion ownership owner allowed declassify policies owns 
declassification safe affect secrecy guarantees principals interest secrecy data 
owner may reasoning processes information theory techniques inference controls determine information leaked declassification acceptably small principals system need trust reasoning processes 
support decentralized declassification label model ideal system containing mutually principals 
important feature decentralized label model formal semantics defined model relabeling rule shown sound complete respect formal semantics 
relabeling rule precisely captures legal relabelings allowed knowledge principal hierarchy available statically necessary lattice properties support static checking automatic label inference 
complete relabeling rule permissive possible unsafe easier model common security paradigms allowing control information flow system group role principals 
examples chapter showed expressive power complete relabeling rule helpful modeling reasonable application scenarios resorting declassification 
extensions basic model discussed chapter show integrity bib constraints natural lattice structure decentralized integrity policies expressed conveniently framework rules precisely dual decentralized privacy policies 
addition labels combine integrity privacy constraints expressed straightforward rules 
extensions principal hierarchy model allow expressive modeling group role principals 
static analysis information flow information flow control usually enforced dynamically causing substantial loss performance difficulty handling implicit information flows 
static program checking appears enforcement technique control information flows reasonable efficiency precision identify certain covert channels 
previous static analysis techniques shown practical 
chapters describe new language jflow extends java language permit simple static checking flow annotations 
goal add power static checking framework allow reasonable programs written natural manner 
jflow addresses limitations previous area 
supports language features previously integrated static flow checking including mutable objects subsume function values subclassing dynamic type tests dynamic access control exceptions 
avoiding unnecessary restrictiveness supporting complex language required addition sophisticated language mechanisms implicit explicit polymorphism code written generic fashion dependent types allow dynamic label checking static label checking restrictive static reasoning access control statically checked declassification 
making programming language convenient involved automatic label inference described chapter 
list mechanisms suggests reason static flow checking accepted widely security technique despite having invented decades ago programming language techniques type theory sophisticated support sound practical programming model 
adapting techniques jflow useful step usable static flow checking 
directions extending 
obviously important direction continue practical system writing applications 
jflow addresses limitations earlier information flow systems prevented development reasonable applications experience needed better understand practical applications approach 
direction exploration development secure run time libraries written jflow support jflow applications 
features jflow polymorphism hybrid static dynamic checking possible write libraries generic reusable fashion 
interesting possibility development secure user interface library provides event distribution rendering capabilities available user interface toolkits 
library include user interface widgets support information flow control directly example type reliably notifies user security policy applied data entered 
possible augment java virtual machine ly annotations similar jflow source code 
bytecode verifier check types labels time code downloaded system 
ly nec mwcg shown type checking performed compile time transformed machine code bytecode annotations 
code transmitted annotations checked receiver ensure machine code obeys constraints established compile time 
approach applicable information flow annotations expressible kind type system 
jflow language contains relatively complex features objects inheritance dependent types features difficult far theoretical programming language techniques show static checking rules chapter sound 
demonstration important widespread acceptance language secure computation 
assumed entirely trusted execution environment 
model described large networked systems different principals may different levels trust various hosts network 
simple technique dealing distrusted nodes transmit opaque receipts tokens data 
approach third party provide trusted host get impasse mutually distrusted hosts 
interesting investigate distributed computational environment secure computation transparent automatic application techniques 
shows control kinds information flow channels better including channels storage implicit flows run time security checks 
covert channels arise timing channels timing asynchronous communication threads treated thesis ruling timing multi threaded code 
supporting multi threaded applications widely applicable 
analyzing channels static analysis sv hr current techniques restrictive 
central difficulty need distinguish locally globally visible operations multi threaded program 
current multithreaded programming environments tended minimize distinction static analysis reasonably precise tool controlling information flow 
altered programming model may possible information available inter thread communication permit precise analysis 
thesis provided new models techniques protecting privacy 
providing better protection privacy challenging important problem computing environments 
environments large distributed contain distrusted users programs hosts 
problem received attention merits hope contributions thesis serve fresh impetus consideration 
bibliography aba mart abadi 
secrecy typing security protocols 
proc 
theoretical aspects computer software third international conference september 
ablp mart abadi michael burrows butler lampson gordon plotkin 
calculus access control distributed systems 
toplas 
ac mart abadi luca cardelli 
theory objects 
monographs computer science 
springer verlag new york 
mart abadi luca cardelli benjamin pierce gordon plotkin 
dynamic typing statically typed language 
acm transactions programming languages systems toplas april 
appeared src research report 
ar gregory andrews richard reitman 
axiomatic approach information flow programs 
acm transactions programming languages systems 
bib biba 
integrity considerations secure computer systems 
technical report esd tr usaf electronic systems division bedford ma april 
bl bell lapadula 
secure computer system unified exposition multics interpretation 
technical report esd tr mitre mtr bedford ma 
available ntis ad 
bn brewer nash 
chinese wall security policy 
proc 
ieee symposium security privacy pages may 
car luca cardelli 
typeful programming 
neuhold paul editors formal description programming concepts 
springer verlag 
earlier version appeared dec systems research center research report february 
clr thomas cormen charles leiserson ronald rivest 
algorithms 
mit press 
cw david clark david wilson 
comparison commercial military computer security policies 
proc 
ieee symposium security privacy pages 
dd dorothy denning peter denning 
certification programs secure information flow 
comm 
acm july 
de sophia drossopoulou susan eisenbach 
java type safe probably 
proceedings object oriented programming th european conference ecoop pages jyv skyl finland june 
lecture notes computer science vol 
springer 
den dorothy denning 
secure information flow computer systems 
phd thesis purdue university lafayette indiana usa may 
den dorothy denning 
lattice model secure information flow 
comm 
acm 
den dorothy denning 
cryptography data security 
addison wesley reading massachusetts 
dg william dowling jean gallier 
linear time algorithms testing satisfiability propositional horn formul 
journal logic programming october 
mark day robert gruber barbara liskov andrew myers 
subtypes vs clauses constraining parametric polymorphism 
proc 
oopsla pages austin tx october 
acm sigplan notices 
dod department defense 
department defense trusted computer system evaluation criteria dod std orange book edition december 
dv dennis 
programming semantics multiprogrammed computations 
comm 
acm march 
fei richard 
technique proving specifications multilevel secure 
technical report csl sri international computer science lab menlo park california january 
fen fenton 
information protection systems 
phd thesis university cambridge cambridge england 
fen fenton 
memoryless subsystems 
computing may 
fk david richard kuhn 
role access controls 
th national computer security conference 
flr levitt robinson 
proving multilevel security system design 
proc 
th acm symp 
operating system principles sosp acm operating systems review november 
fm steven marianne mueller 
java security 
technical report sun microsystems 
fol simon foley 
taxonomy information flow policies models 
proc 
ieee symposium security privacy pages 
elena ferrari samarati elisa bertino sushil jajodia 
providing flexibility information flow control object oriented systems 
proc 
ieee symposium security privacy pages oakland ca usa may 
ggf gligor gavrila david 
formal definition duty policies composition 
proc 
ieee symposium security privacy pages oakland california usa may 
gjs james gosling bill joy guy steele 
java language specification 
addison wesley august 
isbn 
gm goguen meseguer 
unwinding inference control 
proc 
ieee symposium security privacy pages april 
gs li gong roland 
implementing protection domains java development kit 
internet society symposium network distributed system security san diego california usa march 
internet society 
susan horwitz alan demers tim teitelbaum 
efficient general iterative algorithm dataflow analysis 
acta informatica 
hr nevin heintze jon riecke 
slam calculus programming secrecy integrity 
proc 
th acm symp 
principles programming languages popl san diego california january 
jd daniel jackson craig damon 
elements style analyzing software design feature counterexample detector 
ieee transactions software engineering july 
jg pierre jouvelot david gifford 
algebraic reconstruction types effects 
acm symposium principles programming languages pages january 
jl jones lipton 
enforcement security policies computation 
proc 
th acm symp 
operating system principles sosp acm operating systems review pages november 
jl anita jones barbara liskov 
language extension expressing constraints data access 
comm 
acm may 
kil kildall 
unified approach global program optimization 
proc 
acm symp 
principles programming languages popl 
ku john kam jeffrey ullman 
global data flow analysis iterative algorithms 
journal acm 
kw atsushi kanamori daniel weise 
worklist management strategies dataflow analysis 
technical report msr tr microsoft research may 
lab barbara liskov russell atkinson toby bloom eliot moss craig schaffert robert scheifler alan snyder 
clu manual 
springer verlag 
published lecture notes computer science goos hartmanis eds springer verlag 
butler lampson mart abadi michael burrows edward wobber 
authentication distributed systems theory practice 
proc 
th acm symp 
operating system principles sosp pages october 
operating system review 
lam butler lampson 
protection 
proc 
fifth princeton symposium information sciences systems pages princeton university march 
reprinted operating systems review january pp 

lam butler lampson 
note confinement problem 
comm 
acm october 
lcd barbara liskov dorothy curtis mark day sanjay ghemawat robert gruber paul johnson andrew myers 
theta manual 
programming methodology group memo mit laboratory computer science cambridge ma february 
available www pmg lcs mit edu papers 
lmm barbara liskov nicholas mathewson andrew myers 
parameterized types java 
software release 
located www pmg lcs mit edu july 
ly lindholm yellin 
java virtual machine 
addison wesley englewood cliffs nj may 
mbl andrew myers joseph bank barbara liskov 
parameterized types java 
proc 
th acm symp 
principles programming languages popl pages paris france january 
mcl john mclean 
reasoning security models 
proc 
ieee symposium security privacy pages oakland ca 
ieee 
mcl john mclean 
security models information flow 
proc 
ieee symposium security privacy pages 
mf gary mcgraw edward felten 
java security hostile applets holes 
john wiley sons new york 
mic microsoft 
trust security java april 
mil jonathan millen 
security kernel validation practice 
comm 
acm may 
mil jonathan millen 
information flow analysis formal specifications 
proc 
ieee symposium security privacy pages april 
mil jonathan millen 
covert channel capacity 
proc 
ieee symposium security privacy oakland ca 
ml andrew myers barbara liskov 
decentralized model information flow control 
proc 
th acm symp 
operating system principles sosp pages saint malo france 
ml andrew myers barbara liskov 
complete safe information flow decentralized labels 
proc 
ieee symposium security privacy oakland ca usa may 
catherine judith 
pale mac dac defining new forms access control 
proc 
ieee symposium security privacy pages 
mcilroy reeds 
multilevel security unix tradition 
software practice experience august 
mth milner tofte harper 
definition standard ml 
mit press cambridge ma 
mwcg greg morrisett david walker karl crary neal glew 
system typed assembly language 
proc 
th acm symp 
principles programming languages popl san diego california january 
mye andrew myers 
jflow practical static information flow control 
proc 
th acm symp 
principles programming languages popl san antonio tx usa january 
nec george necula 
proof carrying code 
proc 
th acm symp 
principles programming languages popl pages january 
nel greg nelson editor 
systems programming modula 
prentice hall 
net netscape communications 
capabilities classes 
nv tobias nipkow david von oheimb 
type safe definitely 
proceedings th acm symposium principles programming languages pages 
acm new york january 
ow martin odersky philip wadler 
pizza java translating theory practice 
proc 
th acm symp 
principles programming languages popl pages paris france january 
po jens palsberg peter rb trust calculus 
proc 
nd international symposium static analysis number lecture notes computer science pages 
springer september 
rei richard reitman 
mechanism information control parallel programs 
proc 
th acm symp 
operating system principles sosp acm operating systems review pages december 
rm jakob rehof torben 
mogensen 
tractable constraints finite semilattices 
proc 
rd international symposium static analysis number lecture notes computer science pages 
springer verlag september 
rsc joel richardson peter schwarz luis felipe cabrera 
efficient fine grained protection objects 
proceedings acm conference object oriented programming systems languages applications pages vancouver bc canada october 
sal saltzer 
protection control information sharing multics 
comm 
acm july 
san ravi sandhu 
lattice interpretation chinese wall policy 
proc 
th nist ncsc national computer security conference pages baltimore maryland usa october 
san ravi sandhu 
role hierarchies constraints lattice access controls 
proc 
fourth european symposium research computer security rome italy september 
ravi sandhu coyne feinstein 
role access control models 
ieee computer february 
sns steiner neuman schiller 
kerberos authentication service open network systems 
technical report project athena mit cambridge ma march 
ss samarati sweeney 
generalizing data provide anonymity disclosing information 
acm principles database systems seattle washington usa june 
sto allen stoughton 
access flow protection model integrates access control information flow 
ieee symposium security privacy pages 
ieee computer society press 
sto 
programming language 
addison wesley 
sv geoffrey smith dennis volpano 
secure information flow multi threaded imperative language 
proc 
th acm symp 
principles programming languages popl san diego california january 
swe sweeney 
replacing personally identifying information medical records system 
proceedings journal american medical informatics association pages 
sym don syme 
proving java type soundness 
technical report university cambridge computer laboratory june 
tw phil terry simon 
new security model 
proc 
ieee symposium security privacy pages 
vol dennis volpano 
provably secure programming languages remote evaluation 
acm sig plan notices january 
vsi dennis volpano geoffrey smith cynthia irvine 
sound type system secure flow analysis 
journal computer security 
dan wallach dirk balfanz edward felten 
extensible security architectures java 
proc 
th acm symp 
operating system principles sosp pages saint malo france october 
wcc wulf cohen jones levin pierson pollack 
hydra kernel multiprocessor system 
comm 
acm june 
wf dan wallach edward felten 
understanding java stack inspection 
proc 
ieee symposium security privacy oakland california usa may 

ssh secure login connections internet 
sixth usenix security symposium proceedings pages san jose california 
index access control discretionary integrating mandatory acts relation extending actsfor statement annotations arrays access rule assignment rule assignment rules authority bank example basic blocks boolean satisfaction problem break statement capabilities channels chinese wall policy classes code labels compatibility java completeness proof constraints dynamic constructors continue statement correctness condition dynamic static covariant parameters covert channels cryptography dataflow analysis declassification declassify statement expression dependent types devices discretionary access control distribution properties dynamic cast dynamic checking dynamic constraints dynamic labels dynamic principals empty statement encryption environments example bad relabeling bank complex number hospital password file protected tax preparer vector exceptions unchecked fields see instance variables final variables flows greatest lower bound hashcode horn clauses hospital example statement implicit flows incremental relabeling inference rules input channels instance variables access rule assignment rule instanceof integrity combining privacy declassification policies interpretation functions interpreting labels jflow join judgements labeled statement labeled types labels code components creep defaults dynamic checking generalizing inference interpretation function label expressions paths polymorphism program counter restriction run time semantics static checking variables lattices upper bound literal mandatory access control meet meet operator member functions see methods member variables see instance variables methods arguments bodies calls constraints signatures monotonicity multilevel security mutual distrust notation originator controlled release output channels owners parameterized types parameters covariant password file example path labels policies integrity privacy redundant polymorphism labels principals hierarchy owners readers run time writers principle privilege privacy combining integrity process authority program annotations program counter label proof relabeling completeness relabeling soundness protected example readers constraint redundant policies relabeling complete rule examples incremental proof completeness proof soundness relation subset rule relations restriction revocation role access control rules actsfor statement arithmetic break constructors continue declassify statement expression dynamic cast empty statement exceptions instanceof literal local variables method arguments method bodies method declarations sequence signature compatibility single path subtyping switch label variable access variable assignment run time labels run time principals separation duties signatures methods single path rule soundness proof stack inspection static checking static correctness condition static security enforcement strongly connected components subset relabeling rule subtyping switch label statement tax preparer example termination channels theorem proving threads throw statement timing channels topological sort transactions translating jflow code trusted subject try catch statement types dependent discrimination interpretation labeled parameters static checking subtype rules subtyping uids variables access rules assignment rule extend function final static vector visibility statement 
