wattch framework architectural level power analysis optimizations david brooks department electrical engineering princeton university ee princeton edu vivek tiwari intel intel com margaret martonosi department electrical engineering princeton university mrm ec princeton edu power dissipation thermal issues increasingly significant modern processors 
result crucial power performance tradeoffs visible chip architects compiler writers addition circuit designers 
existing power analysis tools achieve high accuracy calculating power estimates designs layout complete addition available late design process tools quite slow compounds difficulty running large space design possibilities 
presents wattch framework analyzing optimizing microprocessor power dissipation architecture level 
wattch faster ex layout level power tools maintains accuracy estimates verified industry tools leading edge designs 
presents validations wattch accuracy 
addition examples demonstrate architects compiler writers wattch evaluate power consumption design process 
see wattch complement existing lower level tools allows architects explore cull design space early faster higher level tools 
opens field power efficient computing wider range researchers providing power evaluation methodology portable familiar simplescalar framework 
power dissipation issue primarily concerned designers embedded portable computer systems increasingly power issues primary design constraints microprocessors 
dock rates die sizes increase power dissipation predicted soon key limiting factor performance single chip microprocessors 
current high microprocessors reach limits conventional air cooling techniques 
addition battery life cooling concerns difficulties delivering large highly varying amounts current chip significant 
voltage scaling specialized circuit techniques main strategies low power design continue important areas 
unfortunately techniques sufficient higher level strategies reducing power consumption increasingly permission digital hard copies part personal classroom fee provided copies distributed profit advantage copies bear notice full citation page 
copy 
republish 
post servers redistribute lists requires prior specific fee 
isca vancouver bc canada copyright acm crucial 
architectural software techniques addition lower level circuit techniques play major role creating power efficient computer systems 
research area high performance power efficient computer architectures infancy 
major ob research lack infrastructure analyzes power ramifications different architectural choices 
creating infrastructure requires need low level detail accuracy need higher level abstractions offering simulator speed portability describes wattch architectural simulator estimates cpu power consumption 
power estimates suite parameterizable power models different hardware structures cycle resource usage counts generated cycle level simulation 
see wattch power modeling infrastructure useful significant enabler research architecture compiler approaches power efficiency 
prior discuss related research categories 
touch relevant architecture level techniques reducing power consumption second discuss related strategies estimating power consumption architectural level 
prior architecture level techniques power re duction mainly focused caches 
focus attributed factors 
embedded microprocessors historically main focus low power design frequently devote large portion power budget caches cases second caches regular structures somewhat easier model units easier quantify power savings caches 
architecture level power reduction addressed areas processor 
example 
showed branch prediction confidence estimators control branch speculation order reduce power consumption presents results terms amount needless speculative saved pipeline stage indicator power savings 
prior discussed power benefits value clock integer alus 
prior papers simple measure proposed strategy power effective ness offered quantifying type saved 
case example number fruitless speculative cycles saved case number result bits need computed 
saved measures accurate asd useful individual techniques apples apples comparisons different power saving techniques require single common power metric 
motivation creating architecture level power simulator 
prior architecture level power estimation tools 
chen developed system level power analysis tool combined single chip bit dsp order bit risc microprocessor 
model capacitance data generated switch level simulation functional unit designs models 
simulator demonstrated short sequences low level assembly code benchmarks model order hardware difficult compare speed accuracy approach related 
contributions major shortcomings area power reduction high level parameterizable simulator framework accurately quantify potential power savings 
lower level power tools operate circuit verilog level 
providing excellent accuracy types tools especially useful making decisions 
architects typically decisions planning phase design begun tools require complete hdl circuit designs 
second simulation runtime cost tools unacceptably high architecture studies tradeoffs hardware configurations considered 
point compete lower level tools expose basics power modeling higherlevel architects compiler writers 
manner analogous development tools cycle level architectural performance simulation tools architectural level power simulation help open power problem wider au 
goal demonstrate fast high level power simulator 
quantify power consumption major units processor parameterize possible show power estimates integrated high level simulator 
results indicate wattch orders magnitude faster commercial low level power modeling tools offering accuracy power estimates lower level approaches 
hope wattch help open salient details industry designs broader academic community interested researching power efficient archi software 
shows possible usage flows wattch 
left usage scenario applies cases user comparing design configurations achievable simply varying parameters hardware structures modeled 
middle usage scenario software compiler development single configuration programs simulated 
third usage highlights wattch modularity 
additional hardware modules added simulator 
cases hardware models follow template hardware structure handle 
cases array structures user simply add new instantiation model simulator 
types new hardware model fit developed relatively easy plug new models wattch framework 
section demonstrate case studies power simulator perform types power analysis 
section provides detailed description power modeling methodology section describes validation models industrial data 
section provides case studies detailing wattch watts watts watts watts scenario scenario microarchitectural tradeoffs compiler optimizations watts watts scenario hardware optimizations scenarios architecture level power analysis 
form microarchitectural tradeoff studies low power designs compiler tradeoffs power hardware optimizations low power 
section discuss possibilities research area power efficient architectures provide 
power modeling methodology foundations power modeling infrastructure parameterized power models common structures modern superscalar microprocessors 
power mod els integrated range architectural simulators provide power estimates 
integrated power models simplescalar architectural simulator 
cycle 
level power models structure power simulator 
illustrates structure wattch interface performance simulator power models 
section describe power models detail 
performed low level high level validations models val results section 
detailed power modeling methodology main processor units model fall categories array structures data instruction caches cache tag arrays register files register alias table branch predictors large portions instruction window load store queue 
associative content addressable memories instruction window reorder buffer wakeup logic load store order checks tlbs example 
combinational logic wires functional units instruction window selection logic dependency check logic result buses 
clocking clock buffers clock wires capacitive loads 
cmos microprocessors dynamic power consumption main source power consumption de fined pd cva 
load capacitance supply voltage clock frequency 
activity factor fraction indicating clock ticks lead switching activity average 
model estimates circuit tran described 
ia depend assumed process technology 
urn process technology parameters 
activity factor related benchmark programs executed 
circuits pre charge discharge cycle double ended array bitlines 
activity factors certain critical single ended array bitlines measured benchmark 
programs architectural simulator 
vast majority nodes large contribution power dissipation fall categories 
unable measure activ ity factors simulator internal nodes decoder assume base activity factor random switching activity 
higher level power modeling selectively clock gates unneeded units clock cycle lowering activity factor 
power consumption units modeled depends particular implementation particularly internal capacitances circuits processor 
model capacitances assumptions similar jouppi palacharla jouppi smith authors performed delay analysis units listed 
works authors reduced units stages formed rc circuits stage 
allowed estimate delay stage summing delay entire unit 
power analysis perform similar steps key differences 
interested capacitance stage second power analysis power consumption paths analyzed summed 
contrast performing delay analysis expected critical path interest 
table summarizes capacitance formulas descriptions elaborate approach 
array structures array structure power model para number rows entries columns width entry asd number read write ports 
parameters affect size number decoders number number bitlines 
addition parameters estimate length pre decode wires lengths array bitlines 
array structures model power consumption stages decoder wordline drive bitline discharge output drive sense amplifier discuss detail wordline drive discharge 
components form bulk power consumption array structures 
shows schematic bitlines array struc ture 
node capacitance equation regfile wordline capacitance cs regfile bitline precharge capacitance cam capacitance cam capacitance cq capacitance table equations capacitance critical nodes 
schematic bitlines array struc ture 
modeling power consumption bitlines requires estimating total capacitance lines 
capacitance include main components 
components diffusion capacitance wordline driver gate capacitance cell access transistor times number bitlines capacitance metal wire 
bitline capacitance computed 
total capacitance equal diffusion capacitance pre charge transistor diffusion capacitance cell access transistor multiplied number word lines metal capacitance bitline 
models created provide option single ended double ended bitlines 
assume register file array structures single ended bitlines cache array structures double ended bitlines 
equations wordline bitline capacitance axe shown table 
multiple ports array structure increase power consumption ways 
capacitance additional port requires additional transistor connection 
second additional port requires additional bitlines bit bit precharge evaluate cycle 
core cell larger leads longer word bitlines incurring additional wire ance 
transistor sizing plays important role capacitance various structures 
transistor sizes noted 
gener ally transistors structures axe kept relatively small reduce area 
model certain critical transistors automatically sized model parameters achieve reasonable delays 
example wordline driver transistor critical driving wordline high short amount time 
width transistor scaled amount capacitance 
length word bitlines internal wiring capacitance structures significant 
analysis similar jouppi study cache array structures 
analyzes access cycle times chip caches 
modify analysis take account multi ported array structures register alias table register file addition hose developed power models cache arrays study power optimizations caches studied low power circuit techniques register file structures 
physical implementation array structures mv different logical structure 
caches may order provide reasonable delays 
estimate physical implementations cache structures help tool 
tool developed determine delay optimal cache hardware configurations cache size block size associativity perform similar branch prediction structures square possible physical implementation 
cam structures analysis cam structures similar array structures 
cam structure model bitlines 
equations cam capacitance shown table 
parameterized model extended various cam structures processor 
take account number rows number tags columns number bits tag match ports cam 
analysis similar array structures follows methodology taken 
example depicts core cell instruction wakeup logic model cpu form cam structure 
described key sizing parameters cam issue commit width machine number match tag lines core cell depicted parameter ii dta ram dam core cell wakeup logic modeled cam 
tion window size impacts cam height iii physical register tag size equals logarithm base instruction window size impacts cam width 
vertically core cell replicated times 
horizontally number cells equal number bits physical register tag share common wide final match signals instruction ready issue 
model write new tag values cam structure simplicity lines omitted 
complex logic blocks larger 
complex logic blocks consider axe instruction selection logic instruction window dependency check logic register renaming unit 
model circuit structures selection logic described dependency check logic model power consumption result buses estimating length result buses sumptions functional unit height 
lengths multiplied metal capacitance unit length 
equation shown table 
modeling power consumption functional units alus high level difficult 
previous investigated power consumption various functional units 
scale power numbers combinational structures process frequency order estimate power consumption functional units 
clocking clocking network high performance microprocessors significant source power consumption 
consider sources clock power consumption global clock metal lines long metal lines route clock processor 
model mo tree network global clock signal routed portions chip equivalent length metal wires buffers order reduce clock skew 
similar alpha 
clock buffers large transistors drive clock processor timely manner 
estimate size number transistors 
clock loading consider explicit implicit clock loading 
explicit clock loads values gate capacitances pre charge transistors nodes directly connected clock units model 
implicit clock loads include load clock network due pipeline registers 
liere number pipeline stages machine estimate number registers required 
models described implemented program tool starting point 
models simplescalar hardware configuration parame ters inputs compute power consumption values various units processor 
summary major hardware structures type model table 
hardware structure model instruction cache cache array bitlines wakeup logic cam issue selection logic complex combinational instruction window array cam branch predictor cache array bitlines register file array ix bitlines translation lookaside buffer array cam load store queue array cam data cache cache array bitlines integer functional units complex combinational fp functional units complex combinational global clock clock table common cpu hardware structures model type wattch 
simplescalar interface power models interfaced simplescalar keeps track units accessed cycle records total energy consumed application 
modified version simplescalar sim collect results 
simplescalar provides simulation environment modern order processors stage pipelines fetch decode issue writeback commit 
speculative execution supported 
simulated processor contains unified active instruction issue queue rename register file unit called reservation update unit uu 
separate banks integer floating point regis ters register file written commit 
extended simplescalar provide variable number additional fetch issue bringing number line current microprocessors 
study assume additional fetch issue cycles mispredict penalty 
power oriented modifications track units accessed cycle 
example particular cycle involves reading instruction cache selecting ready instructions reading register file performing integer additions power models units bc invoked 
power models vary estimated power number ports described section 
simulation frameworks hope broader distribution framework lead users create richer variety power modeling modules time 
section describes details baseline hardware parameters selected benchmarks 
conditional clocking styles key issue arises estimating power concerns scale power consumption multi ported hardware units 
current cpu designs increasingly conditional clocking disable part hardware unit reduce power consumption needed 
consider different options clock gating disable unused resources multi ported hardware 
options clearly give initial examples 
simplest clock gating style assumes full modeled power consumed accesses occur cycle zero power consumption 
example multi ported register file modeled draw ing full power port 
assumption realistic current cpus choose aggressive conditional clocking 
second possibility ass ames portion unit ports accessed power scaled linearly 
example ports port register file cycle power estimate returned half power ports 
wattch tracks ports hardware structure cycle scales power numbers accordingly 
practice may impossible totally shut power unit port needed small fraction total power may active 
mind third option power scaled linearly port unit usage unused units dissipate maximum power drawing zero power 
number chosen represents typical turnoff industrial clock gated circuits 
clk gating linear clk gating linear clk gating power consumption benchmarks clocking multi ported hardware 
bar assumes simple clock gating unit fully ports accessed cycle fully 
second bar assumes clock gating power scales linearly port usage disabled ports consume maximum power 
third bar assumes ideal clock gating power scales linearly port usage second bar disabled units axe entirely shut 
shows power dissipation specint specfp benchmarks styles conditional clocking 
maximum power configuration similar 
processors move aggressive style reduce average power dissipation 
expect variability power tion benchmarks clock gating 
assumption supported simple clock gating style maximum variations benchmarks average 
variations advanced clock gating techniques axe 
amount clock current processors falls styles consider 
simulation speed wattch intended run overheads moderately larger simplescalar simulators 
computes base power dissipation unit program startup time cost 
base power costs scaled unit access counts 
arithmetic units charge power units cycle cycle performs integer additions charged multiply unit 
addition access counts simulator scales power estimates hardware style clock gating chosen options section 
simulation speed measurements axe modi fied version simplescalar axp sire running pentium ii mhz pc redhat linux version 
simulation speed sim power modeling approximately instructions second 
current methodology updates power statistics cycle access counts see roughly overhead average compared performance simulation 
simulation speed drops roughly instructions second 
ability gauge power fairly high level feel overhead quite tolerable 
reduced updating power statistics cycles 
require loosening accuracy port count statistics statistics usage different functional units 
comparison lower level tools running bit adder test vectors takes approximately hour 
amount time wattch simulate full cpu running roughly simplescalar instructions generate power estimates 
model validation validating power models crucial fast power simulation useful reasonably accurate 
provide methods validation 
low level check compare capacitance values generated model real circuits 
second vali dation level aims quantifying relative accuracy model 
compare relative power weights model generates experimentally measured results published works industry chips 
final validation technique seeks quantify absolute magnitude accuracy models 
method maximum processor power reported published works power results similar processor organizations generated models 
validation model capacitance vs physical schematics parameterized power models section obtain power dissipation estimates calculating ca values critical common circuits 
low level method validating models compare capacitance value computed model circuit design tool calculations capacitance values industry schematics 
section describe type validation entry bit wide register file structure read ports write ports 
physical register file schematic selected actual design intel ia products 
type array structure common modern microprocessors provides sample study 
change capacitance gate diffusion 
total wordline wordline bitline bitline table percentage difference lower level tool capacitance values values estimated model 
table presents results validating register file 
studied read write nodes bit lines register file 
table breaks 
gate capacitance diffusion capacitance interconnect capacitance 
entry percentage difference capacitance value estimated circuit level capacitance extraction tool calculated model 
capacitance error rates 
largest sources error interconnect capacitance 
reasons 
polysilicon wires difficult model lengths wires vary physical layout 
second difficult match exact lengths interconnects physical schematic modeled nodes 
example wire bitline node physical schematic may extend length edge array structure model assumes wire ends directly array boundary total capacitance values nodes studied 
array structures comprise roughly total mod chip power dissipation 
axe currently performing similar low level validation hardware structures cam arrays 
expect results similar methodology modeling units identical 
validation relative power consumption struc ture low level capacitance values precise means validating power simulator 
unfortunately access set industrial hardware designs capacitance values 
validate models chips second high level set validation data 
data compares relative power different hardware structures predicted model published power breakdown numbers available microprocessors 
downside comparison way knowing design style model unit matches design style 
spite downside reassuring see power breakdowns track quite 
shown tables relative power breakdown numbers models average reported data 
tables compare breakdowns wattch power consumption different hardware structures published data intel pentium pro alpha hardware structure intel data model instruction fetch register alias table reservation stations reorder buffer integer exec 
unit data cache unit memory order buffer floating point exec 
unit global clock branch buffer table comparison modeled reported power breakdowns pentium pro 
hardware structure alpha model caches order issue logic memory management unit floating point exec 
unit integer exec 
unit total clock power table comparison modeled reported power breakdowns alpha 
cpus 
power consumption shown maximum power operation units fully active 
mode operation represents static power estimates assume ports units fully active maximum switching activity 
modify simplescalar internal structure resemble processors 
static power estimates models hardware configurations processors 
parameter configurations models set published intel alpha parameters 
power breakdowns track fairly 
example intel data table exact near match units 
include data caches instruction fetch order control logic 
average difference power consumption modeled structures reported data intel processor 
relative power proportions alpha similar reported data average difference 
unit shows inaccuracy current model global clock power intel processor model predicts total chip power published data suggests 
difference clock power model aggressive tree style alpha intel processor 
alpha significantly higher percentage total clock power intel alpha compared intel processor 
main reason large difference simply method accounting clock power companies 
clock power category includes clock capacitance including clock nodes individual units 
hand intel method clock power accounting counts clock power global clock network 
clock nodes various hardware structures counted power dissipation units 
model different chips adjust clock power accounting method match respective data reporting note power proportions discuss normalized hardware structures consider 
example model intel complex micro op decoding report instruction decode unit power consumption consumes chip power 
validation max power consumption cpus pro processor core instr 
window int int fp mem fp physical registers int int fp fp memory order queue fetch width cycle 
decode width cycle issue width cycle commit width cycle functional units int int int fp fp fp branch prediction local history table local predict global history register global predict choice predict btb entry entry entry way way return address stack entry memory hierarchy dcache size dcache assoc 
way way way icache size icache assoc 
way way way dtlb size full asset itlb size full asset process specifications vdd mhz table configuration processors section perform third form validation compare published maximum power numbers commercial microprocessors values produced models similar configurations 
allows evaluate relative absolute accuracy power models 
comparison difficult exact process parameter information general power trends cm seen hardware organizations 
table describes details proces sors consider 
shows results maximum power dissipation processors considered 
cases modeled power consumption reported power consumptions average lower 
reasons systematic underestimation 
concentrated units oo pro mips alpha maximum power numbers processors model aad reported 
immediately important architects consider neglecting circuitry fuse test circuits miscellaneous logic 
second circuit implementation techniques transistor process parameters vary 
hand models axe general tuned processor implementation details 
results improved reassuring see trends track published data high commercial processors 
validation summary details power models ad simulator infrastructure required perform architectural level power analysis 
verified power models industrial circuits results generally low level capacitance estimates 
shown relative accuracy models especially important architectural compiler research tradeoffs different structures average 
limitation models nec model miscellaneous logic real microprocessors 
furthermore different circuit design styles lead different results 
power models predict maximum power dissipation cus tom microprocessors 
methodology modeling extra logic circuit design styles done far inherent limitation models prevents additional considered 
limitation models date industrial fabrication data available public domain lead variations results 
models accurate cpus similar fabrication technology 
reasonable considering tradeoffs particular design problem lab technology fixed factor 
case studies section provide case studies demonstrate wattch perform architectural compiler research 
performing power studies variety metrics axe important depending goals 
simulator provides results metrics power average maximum cycle power consumption processor important power translates directly heat 
chip thermal sensors techniques instruction cache throttling reduce number cycles power consumption significantly average 
large cycle cycle swings power dissipation power glitches axe cause reliability problems 
cycle level power simulator capable analyzing types problems 
performance performance ramifications architectural proposal positive negative important study 
wattch performance measured terms number cycles program execution 
energy energy consumption program equal power dissipation multiplied execution time 
energy consumption important portable embedded processors battery life key concern 
energy delay product energy delay product 
proposed gonzalez horowitz energy consumption delay single metric 
produces metric unwarranted preference solutions low slow fast high power 
subsections case stud ies demonstrate simulator infrastructure architecture compiler research studies 
case studies illustrate possibilities shown 
main point case studies demonstrate methodology rapid exploration ideas give details examples 
getting case studies explain simulation methodology baseline hardware configuration bench 
simulation model parameters stated results section model processor configuration shown table 
baseline configuration parameters roughly match alpha processor 
main difference separate active list issue queue rename register file simplescalar sim uses unified instruction window called ruu 
technology parameters process parameters urn process mhz 
section sec tion aggressive clock gating style scaling number active ports results benchmark applications chose evaluate ideas programs specint specfp benchmark suites 
spec programs representative wide mix current integer floating point codes 
compiled benchmarks alpha instruction set compaq alpha cc com piler optimization options specified spec makefile migrate ifo non shared 
program simulate instructions 
select instruction window program warmup periods discussed 
parameter value processor core size instructions lsq size instructions fetch queue size instructions fetch width instructions cycle decode width instructions cycle issue width instructions cycle order commit width instructions cycle order functional units integer alus integer multiply divide fp add fp multiply fp divide sqrt branch prediction branch predictor combined bimodal table level table bit history chooser btb entry way address stack entry mispredict penalty cycles memory hierarchy data cache way liu blocks cycle latency instruction cache way lru blocks cycle latency unified way lru blocks cycle latency memory cycles tlbs entry fully associative cycle latency table baseline configuration simulated processor microarchitectural exploration important application wattch microarchitectural tradeoff studies account performance power 
example users may interested evaluating sizing tradeoffs different hardware structures 
clearly architectural decisions power considered may differ solely performance 
possible study consider section evaluate size tradeoffs ruu data cache 
example demonstrates scenario 
baseline processor configuration table simulations vary sizes cache 
simulations load store queue set half size ruu 
collected results specint specfp benchmarks 
dis results typically fall main categories behavior results representative benchmark category gcc turb 
figures show results gcc benchmark 
graphs show performance instructions cycle average power dissipation energy delay product benchmark 
similarly figures show results turb benchmark 
ipc graphs show cc gets significant performance benefit increasing data cache size 
begins level roughly kb 
contrast turb gets relatively little performance benefit increasing data cache size highly sensitive increases size 
performance contours fairly different power contours shown fig ures quite similar 
show steady increases average power size unit increased 
despite similarity average power graph benchmarks strikingly different energy characteristics shown figures 
energy delay product combines performance power consumption single metric lower values considered better power performance standpoint 
energy delay product curve gcc reaches optimal point moderate kb caches small 
indicates large caches continue offer cc small performance improvements increased power begins outweigh performance increase 
size offers little benefit gcc front performance energy delay standpoint 
fo turb energy delay increases monotonically cache size reflecting fact larger caches draw power offer benchmark little performance improvement return 
moderate sized offer optimal energy delay turb valley graph pronounced cc 
point case study demonstrate power simulator resulting graphs shown help explore tradeoff points account power mid performance related metrics 
power analysis loop unrolling section gives example high level power simulation compiler writers 
consider simple case study examines effects loop unrolling processor power dissipation 
loop unrolling known compiler technique extends size loop bodies replicating body times unrolling factor 
loop exit condition adjusted accord ingly 
section consider simple matrix multiply benchmark entry matrices 
compaq alpha cc compiler unroll main loops benchmark consider unrolling factors 
figures shows results execution time power energy results loop unrolling 
hope execution time number total instructions com decreases 
loop unrolling reduces loop overhead address calculation instructions 
power results complicated tradeoffs interesting power compiler 
shows breakdown power dissipation individual processor units normalized case unrolling 
axe important side effects loop unrolling 
loop unrolling leads decreased branch predictor accuracy branch predictor fewer branch accesses predictors final fall branch represents fraction total predictions 
side effect loop unrolling removing branches leads efficient front 
fetch unit able fetch basic blocks interrupted taken branches 
turn provides renaming unit fills faster 
fact example full average execution cycles move unrolling factor 
fetch queue connects fetch unit renaming hardware affected full average cycles unrolling factor 
average fetch unit power dissipation decreases reasons 
branch prediction accuracy decreased misprediction stall cycles instructions axe fetched 
second reason larger unrolling factors fetch unit stalled dnr ipc cc 
power energy delay product ipc turbo power 
energy delay product turb 
ing cycles instruction queue full 
reduced number branch instructions significantly reduces power dissipation branch prediction hardware 
note stall cycles increase total energy required run full program graph shows average power 
renaming hardware hand shows small increase power dissipation unrolling factor 
front operating full tilt sending instructions renamer cycle 
fetch unit starts experience stalls unrolling factors renamer unit begins remain idle frequently leading lower power dissipation 
varied power trends unit somewhat complicated picture best seen 
total instruction count program continues decrease steadily larger unrolling factors execution time tends level unrolling 
combined effect energy delay product continues decrease slightly larger unrolling factors execution time 
power aware compiler unroll aggressively compilers 
simple example intended highlight fact design choices slightly different power metrics taken account wattch intended help explore tradeoffs 
memoing save power important application wattch infrastructure evaluating potential hardware benefits hardware optimizations 
section consider result technique previously explored perfor mance benefits :10.1.1.160.9384
idea storing inputs outputs long latency operations re output inputs encountered 
memo table looked parallel cycle computation computation halts hit tered 
reduce multi cycle operations cycle hit memo table 
consider power performance benefits technique 
power consumption floating point units reduced memo table hits 
hand memo tables dissipate additional power 
base analysis showed small entry way set associative table capable achieving reasonable hit rates 
eta 
investigated similar technique saving power integer multipliers 
model additional power dissipation reads writes cache structure tag comparison logic concentrated integer multimedia benchmarks 
point section demonstrate methodology wattch perform study 
inserted memo tables parallel floating point integer 
multipliers cycles floating point adder cycles floating point divider cycles 
study examined specfp perfect selection multimedia dsp applications finding multimedia applications lowest local entropy result values high est hit rates 
multimedia benchmarks readily available examined selection benchmarks specfp suite 
unroll factor exec 
time total instructions energy delay effects loop unrolling performance power 
note branch prediction direction accuracy decreases unrolling unrolling times 
total icache unroll factor detailed breakdown power dissipation 
enter trivial operations multiply divide table assume simpler hardware recognize capitalize opportunities 
modifications power simulator infrastructure new hardware complex 
behavior memo tables implemented memo table lookup memo table routines inserted simula tor pipeline 
routines serve access counters memo tables 
memo tables mod simple cache array structures power models array structures 
shows performance power results technique benchmarks showed aver age speedup average power improvement 
larger power benefits memoing techniques due dynamically scheduled execution core simulated processor 
outof order processor delay long latency operations hidden finding instructions execute performance benefits removing long latency operations axe large 
stopping operations cycle execution significant impact lo applu fpppp hydro turb performance effects memoing tech nique 
power dissipation 
apparent shows performance benefit just power benefit 
discussion goal provide simulator framework evaluate wide range architectural compiler techniques 
wattch benefit low level validation industry circuits opening power modeling researchers abstraction levels circuits schematics 
wattch room improvement hope exposure distribution architectural community lead development additional modules 
additional accuracy validations important plan compare models lower level tools de signs 
speed accuracy tradeoffs signal activity factors area consider 
extensions simulator infrastructure creation additional modules topics re search 
simulator infrastructure extended consider different hardware organization styles 
additional power modules developed different circuit implementation styles targeting different targets 
modeling chip communication taut module developed 
additional focus automatic transistor sizing effects process technologies including leakage power dissipation 
see wide range power studies performed wattch 
old techniques may take new light power considered metric 
case study described section example 
interesting techniques study power metric value prediction instruction preprocessing effects compiler techniques operating system control power dissipation including power dissipation feedback profiling compiler possible research area 
wattch power studies explore techniques focus micro architectural solutions lower level power problems 
example dynamic thermal management techniques reduce power dissipation thermal emergencies occur due high power sections applications 
example evaluation development solutions large short term current spikes due clock gating cause problems chip reliability 
exploring classes ideas power domain open new research possibilities architects 
wattch simulator infrastructure described point research efforts 
acknowledgments supported research funding national science foundation intel addition brooks currently support national science foundation graduate fellowship princeton university gordon wu fellowship 
liu conte 
low power data processing elimination redundant computations proc 
int symposium low power electronics design 

power perfor mance tradeoffs various caching strategies 
proc 
lnt low power electronics design 
bishop irwin 
design register renaming unit 
proc 
great lakes symposium vlsi 
owens irwin 
transistor sizing low power cmos circuits 
ieee transactions computeraided design integrated circuits systems 
circuit implementation ofa mhz bit second generation cmos alpha cpu 
digital technical journal 
brooks martonosi 
dynamically exploiting nar row width operands improve processor power performance 
proc 
th int syrup 
high performance computer architecture jan 
burger austin 
simplescalar tool set version 
computer architecture news pages june 
chen irwin 
architectural level power estimator 
power driven microarchitecture shop isca 
rudolph 
accelerating multimedia processing implementing memoing multiplication division units 
proceedings th conf 
architectural support programming languages operating systems asplos viii pages oct 
fair bailey 
clocking design analysis mhz alpha microprocessor 
digest technical papers pages february 
gabbay mendelson 
value prediction increase power speculative execution hardware 
acm transactions computer systems aug 
gonzalez horowitz 
energy dissipation gen eral purpose microprocessors 
ieee journal solid state circuits 
cowan jackson 
power considerations design alpha microprocessor 
th design automation conference 

intel uses decoupled superscalar design 
microprocessor report pages feb 
smith 
instruction pro processing trace processors 
proc 
th int syrup 
hi computer architecture jan 
johnson kin mangione smith 
filter cache energy efficient memory structure 

th int syrup 
microarchitecture nov 

analytical energy dissipation models low power caches 
proc 
int symposium low power electronics design 
manne grunwald 
pipeline gating speculation control energy reduction 
proc 
th intel syrup 
computer architecture pages june 
mentor graphics 
el 
mhz cmos risc microprocessor 
digital technical 
palacharla jouppi smith 
complexity effective superscalar processors 
proc 
lth int syrup 
computer architecture 
jouppi smith 
quantifying complexity superscalar processors 
univ wisconsin computer science tech 
report 
sanchez thermal management system high performance powerpc microprocessors 
compcon feb 
ahuja martonosi clark 
branch prediction instruction window size cache size tradeoffs ad simulation techniques 
ieee transactions computers nov 
sohi 
dynamic instruction reuse 
proc 
dth int syrup 
computer architecture may 
sohi 
instruction issue logic high interruptible pipelined processors 
proc 
int syrup 
computer architecture pages june 
su despain 
cache designs energy efficiency 
proceedings th hawaii int conference sys tem science 
synopsys 
data sheet 
tiwari reducing power high performance microprocessors 
th design automation conference 
jouppi 
enhanced access cycle time model chip caches 
wrl research report dec western research laboratory 
zimmermann 
low power logic styles cmos versus pass transistor logic 
ieee journal circuits 

energy complexity register files 
pvc 
int symposium low power electronics design pages 

