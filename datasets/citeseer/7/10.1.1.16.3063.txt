unified versioning feature logic andreas zeller gregor snelting informatik bericht 
februar copyright institut programmiersprachen und informationssysteme abteilung technische universit braunschweig braunschweig germany distribution notice submitted publication 
published technical report early dissemination contents 
courtesy intended publisher widely distributed date outside publication 
appear acm transactions software engineering methodology july unified versioning feature logic andreas zeller gregor snelting technische universit braunschweig germany software configuration management scm suffers tight coupling scm versioning models imposed scm processes 
order adapt scm tools scm processes vice versa propose unified versioning model version set model 
version sets denote versions components configurations feature terms boolean terms feature value attributions 
feature logic deduce consistency configurations features derived components describe features propagate scm process feature implications integrate change oriented version oriented scm models 
implemented version set model scm system called ice incremental configuration environment 
ice featured file system ffs version sets accessed virtual files directories 
known preprocessor representation users view edit multiple versions simultaneously differences versions stored 
turns major scm models realized integrated efficiently top ffs demonstrating flexible unifying nature version set model 
categories subject descriptors software engineering programming environments software engineering distribution maintenance version control software engineering management software configuration management programming teams operating systems file systems management artificial intelligence deduction theorem proving artificial intelligence knowledge representation formalisms methods general terms management theory standardization additional key words phrases feature logic version sets software configuration management scm short discipline controlling evolution software systems 
scm encompasses general configuration management procedures identification components structures control changes releases status accounting audit review software specific tasks manufacture process management team 
scm basic prerequisites process improvement stipulated iso standard sei capability maturity model attracts attention professional software development 
article revised extended version fifth european software engineering conference september 
early descriptions revision workspace concepts sections 
featured file system sections discussed 
supported deutsche forschungsgemeinschaft sn sn 
authors address technische universit braunschweig abteilung braunschweig germany email zeller snelting ips cs tu bs de www cs tu bs de 
scm policy quality assurance scm process scm protocol transactions workspaces scm primitives tool primitives operating system operations scm foundation ice process tools realize specific scm process ice task tools realize specific scm procedures featured file system transparent version set access version set model unified scm model feature logic federated scm architecture proposed left realized ice right configuration items accessible line scm typically supported enforced automated scm tools systems 
early days scm characterized dedicated scm tools sccs rcs revision change control cpp preprocessor variant control manufacture 
days new generation emerged represented scm systems adele epos clearcase 
systems provide integrate support scm aspects federated scm system architectures illustrated primitive layer provides basic versioning access capabilities protocol layer realizes scm tasks procedures policy layer implements organization specific standards 
today scm vendors compete means growing number product features 
benefit users choose large number scm systems individual set features 
despite advances scm systems suffer deficiencies lack ambiguity tolerance 
scm systems generally provide poor support treating items 
includes lack support manipulating identifying permanent variants change propagation versions consistency checking ambiguous configurations 
lack process flexibility 
scm systems frequently enforce specific software process 
unfortunately nearly scm system relies predefined inflexible product life cycle diverging scm models identified imposing different scm process 
pretty far away ideal scm system adapt organization process 
lack system integration 
scm primitive layer considerable disagreement versioning models 
consequently scm layers interchangeable resulting scm systems interoperate integrate 
furthermore basic layers constrain higher layers flexibility decreases higher layer considered 
propose resolve deficiencies unified scm versioning model common scm foundation 
version set model integrates common scm models increases flexibility protocol policy layers tolerates ambiguity levels 
version sets sets objects typically software components characterized feature term boolean expression feature value attributions denoting common individual version properties exploring configuration space ice file configuration browser scm convention characterize objects attributes 
version sets generalize known scm concepts components repositories workspaces variant sets revision histories 
feature logic intersection union complement operations version sets realized order express generalize semantics scm models 
feature unification constraint solving technique determine version sets exist ensuring consistency configurations inferring necessary steps construction 
implemented version set model scm system called ice incremental configuration environment 
ice integrates software development environments featured file system ffs version sets represented files directories 
arbitrary programs access version sets realize version operations file manipulations 
specialized configuration browsers shown users incrementally explore configuration space ice deduce consistency incomplete configurations 
known cpp representation users view edit multiple versions simultaneously differences version sets stored 
major scm models realized integrated top ffs demonstrating unifying nature version set model 
organized federated scm architecture shown 
lowest scm layer motivating presenting feature logic formal scm foundation 
section introduces version set model shows primitive scm concepts modeled version sets 
section discuss modeling advanced scm concepts change implications workspaces required scm protocol layer 
section turn practical aspects demonstrate ffs realizes scm primitive layer transparent version set access 
section treat scm protocol layer demonstrate realization scm protocols top ffs 
section discusses performance complexity issues treating integration scm protocols 
close summary suggestions section 
feature logic existing scm literature product oriented describing evaluating set scm concepts realized specific implementation 
think view hinders deeper understanding scm concepts concept question separated implementation 
order support large variety scm versioning concepts specific scm products turn fundamental treatment keeping higher scm layers mind 
scm foundation formal foundation chosen capturing scm versioning concepts called feature logic 
feature logic denotes sets objects properties provides elemental set operations manipulate sets 
scm domain feature logic denote sets components features describe semantics scm operations 
feature logic formal foundation 
relying scm deficiencies stated identified key elements foundation 
foundation sets 
ambiguity tolerance imposes necessity treat sets versions configurations class objects 
scm procedures set oriented item oriented manipulating sets generalizes manipulating items 
instance editing set versions checking set configurations consistency subsumes editing single version examining single configuration 
second foundation attributes 
attribution techniques common scm area known scm models rely versions changes tagged attributes 
identification selection schemes attribute attribution support includes description attributes propagate scm process composed derived objects identified 
third foundation unification 
usual selection process scm systems consists determining objects attributes consistent specific environment 
typically objects described conjunction attribute values environment attribute expression inverse scheme cpp 
order encompass schemes selection identification rely attribute expressions unifying attribute expressions matching attribute expressions conjunction attribute values 
formalisms denote sets objects attributes subsumed term description logics terminological logics 
important domains areas knowledge representation concept descriptions called frames represent sets objects attribute value combinations semantic analysis natural language 
programming languages attribute value combinations record structures 
kaci study structures mathematically calling terms 
resulting term calculus formal foundation programming languages login life similar prolog feature unification syntactic unification 
contrast description logics attributes terms functional value 
convenient objects identified unique attribute value 
terms successfully applied context scm notably system 
uses variant login called congress denote attributes components tools describe attributes propagate source components derived components 
advanced founded scm systems terms building attributing derived components descriptions terms ideal candidates unified scm versioning model successfully scm systems 
unfortunately terms conjunctions attribute value combinations allowed negations disjunctions supported 
restriction severely constrain scm identification selection schemes 
alternative candidate scm foundation suffer restrictions 
boolean operators order logic scm selection schemes order terms may identification purposes deduction techniques boolean unification match identification selection terms 
problem order logic far general lacks central property 
implies scm functionality selection attributes attribute propagation inheritance configurations requires explicit formalization order axioms rules 
formal scm foundation need best worlds boolean operators quantifications order logic order express identification selection schemes attribute oriented formalisms description logics denoting attributes propagate scm process functional attributes terms uniquely identify objects attributes 
logic exist feature logic defined smolka founded description logic includes quantification disjunction negation functional attribution terms forming full boolean algebra 
feature logic nutshell informal overview feature logic 
feature term denotes set objects characterized certain features 
feature functional property attribute objects 
simplest form feature terms consist conjunction feature value pairs called slots feature represents attribute object 
feature values include literals variables nested feature terms 
example consider feature term expresses linguistic properties natural language fragment tense predicate verb sing agent subject num singular person third object term says language fragment tense third person singular agent predicate equal subject denotes sentence template 
syntax feature terms summarized table denote variables features constants feature terms denoted feature terms constructed known boolean set operations intersection union complement 
smolka writes ands implications equivalences occur simple syntactical extensions equivalence simpler operators shown proposition 
notation name interpretation top universe bottom empty set inconsistency atom singleton set containing variable selection value existence defined divergence undefined agreement value disagreement different values complement hold intersection hold union holds implication holds holds equivalence holds holds quantification holds table syntax feature terms set operations may interpreted logical constraint object features representing set objects satisfying constraint 
instance set objects feature value andt set objects feature value intersection set objects feature feature similarly union set objects feature feature feature terms form boolean algebra boolean transformations distribution de morgan law hold feature terms 
necessary specify feature exists defined giving value feature exist feature term 
written resp 
abbreviated 
possibility specify complements greatly increases expressive power logic 
example term compiler gcc denotes objects feature compiler undefined value gcc 
term compiler gcc denotes objects feature compiler defined value gcc 
feature term interpreted representation infinite set ground terms subsumed original term 
subsumed terms obtained substituting variables adding features 
feature terms allow specialization classes object oriented models 
instance fruit fruit apple fruit apple color green fruit apple color green 
atoms apple green denote singleton sets containing unique object features equivalences hold atoms feature leads simple consistency notion feature logic assumes feature value term os dos os unix equivalent empty set formally os dos os unix os dos unix os holds 
terms equivalent called inconsistent 
feature unification constraint solving technique determine arbitrary feature terms 
terms unions complements feature unification works similar classical unification order terms difference subterms identified position prolog feature name 
adding unions forces unification compute finite union unifiers complements usually handled constraint solving similar negation failure 
properties feature terms give properties feature terms 
feature terms called equivalent written unambiguous denote set objects interpretation 
equivalence introduced feature term forms redundant may reduced primitive forms 
proposition feature term rewritten linear time equivalent feature term containing forms equivalences feature term called closed free variables 
feature term ground variables agreements disagreements 
feature term quantifier free contains quantifications 
feature term basic quantifier free contains implications contains complements feature term simple basic contains unions 
feature term disjunctive normal form dnf sn sn simple feature terms 
feature terms called orthogonal common features variables 
proposition quantifier free feature term rewritten linear time equivalent basic feature term equivalences feature term said included subsumed feature term written set denoted subset set denoted possible interpretation 
proposition set feature terms defined 
boolean algebra 
subsumption constitute subsumption lattice supremum proof 
follows definitions properties required boolean algebras commutativity associativity idempotency absorption distribution apply equivalence 
subsumption lattice follows boolean algebra 
interpretation feature terms formally defined 
consistency discuss notion consistency stating feature terms denote empty sets devise algorithms decide consistency 
feature term called coherent consistent interpretation denoted set non empty 
feature term called incoherent inconsistent consistent 
proposition consistency subsumption equivalence feature terms linear time reducible inconsistent inconsistent proposition deciding inconsistency subsumption equivalence quantifier free feature terms np complete problems 
proof 
follows satisfiability problem propositional logic shown 
quantifier free feature terms smolka devised algorithm decides inconsistency arbitrary quantifier free feature terms 
basic idea called feature unification feature term transformed dnf sn consistency conjunct si determined quadratic time algorithm 
proposition deciding inconsistency simple feature terms quadratic time complexity 
transformation non simple feature terms dnf np complete time complexity smolka algorithm exponential worst case complying proposition 
unsuitable practical problems soon feature terms exceed certain size 
imposing certain conditions feature terms time complexity feature unification dramatically reduced 
proposition seen deciding consistency simple feature term decided quadratic time 
unification problem broken terms form orthogonal consistent iff consistent 
proposition orthogonal 
holds 
proof 
algebraic induction intersection primitives lead inconsistency 
efficient algorithm obtained principles partial evaluation 
observe unification problem simplified simple feature term form tn primitive ti check ti linear time syntactically comparing ti primitives deduce inconsistency 
proposition holds variable free 
proposition consistent variable free feature terms simple basic form 
inconsistent iff rewritten equivalences proof 
equivalences handle union intersection selection operators remaining equivalences identify combinations primitives lead inconsistency 
correctness follows algebraic induction 
proposition consistent variable free feature terms simple 
inconsistency decided time complexity log wheres number primitives number primitives proof 
proposition term rewritten basic form linear time proposition applies 
complexity follows fact worst case primitive syntactically searched done logarithmic time 
simplification interested deciding consistency simplifying respect thatis syntactically smaller holds 
basic idea replace literal occurrences simplify 
done adding equivalences rewrite system proposition 
proposition term may reduced size expanding subsequent simplification equivalence essence simplification literal occurrence primitive replaced 
remaining equivalences eliminate superfluous negations 
equivalences propagate new values complexity unaffected 
illustrate inconsistency decision simplification example 
consider term wheres decompose primitive si check consistency si simplify si respect common features consistent simplified 
regarding rewritten inconsistent 
considering term replaced original term 
term consistent 
side effect find simplified holds 
presentation feature logic complete 
remainder article interpret feature terms sets objects specified 
traditional set notation required single exception write express cardinality number elements set denoted feature term interpretation 
required notation provided feature logic introduced 
version set model having introduced feature logic return scm domain 
scm primitive layer basic versioning access capabilities 
show capture scm states means version sets sets software components identified attributes 
basic scm operations selecting version composing consistent configurations modeled means set operations provided feature logic 
versions components scm standards consider object interest scm family software products 
software products breaks components may exist component versions 
component version unambiguous configuration item 
scm domain common method identifying component versions attribution adele context model epos jason shape 
attribution component version identified conjunction attribute value pairs describing features version selection done boolean attribute expression satisfied selected versions similar classical selection databases 
conditional inclusion exemplified preprocessor cpp setting reversed versions identified boolean attribute expressions selected conjunction attribute value pairs describing features environment 
model uses feature terms version identification version selection 
component version assigned feature term describing features uniquely identifying version component versions selected feature terms 
encompassing integrating database cpp scheme setting number advantages scm users alternative properties 
feature terms restricted pure enumeration features identify versions 
instance unions state proposed state tested identify alternatives 
database setting alternatives selecting versions identify 
ability express alternative component properties essential treating version sets unique items 
configuration constraints 
feature terms may express component properties apply 
instance may term operating system unix identify version unix operating system 
feature expresses constraint environment notably components configuration 
cpp constraints realized error directive 
contrast cpp arbitrary selection terms selection term operating system unix exclude unix versions include non windows version 
primitive layer impose specific requirements existence meaning features associate versions component common feature component versions 
assume component identified uniquely object feature assigning component simple unambiguous component identifier 
configuration universe set denoted object set component versions 
define notions versions components 
version set set object 
version singleton version set set object 
component set object simple feature term uniquely identifying component 
component version component version set object 
features component modeled alternatives features component version 
component component versions vn component determined vn vi 
features component object component versions factored 
simple example consider printer component occurring component versions printer component denoted printer object printer print language postscript printer object printer print language ascii printer printer printer object printer print language postscript ascii retrieve specific version specify selection term giving features desired version 
selection term version set identify versions satisfying calculating version set subset subset selection fails denote existing version 
example selecting print language postscript printer returns printer printer printer printer printer printer printer 
printer holds print language feature may value 
just version set may give second selection term select give third selection term narrowing choice set incrementally singleton set selected containing desired version 
composing consistent configurations configuration setting set components 
model scm versioning models features components propagated configurations screen device screen type operating system screen type screen data bitmap os dos screen type tty concurrent false screen type tty screen data ascii screen device dumb data screen data os unix screen type news tty screen type screen data bitmap screen device ghostscript data postscript screen data bitmap concurrent true consistent configurations text graphic editor screen type news screen data postscript bitmap says configurations inherit features components 
crucial point composing configurations components ensure configuration formed consistent 
determine internal consistency configuration scm tools rely separate tools language specific knowledge 
consistency respect external specification usually combined configuration selection consistency constraint part selection term 
version set model configuration constraints specified selection term occur features component 
purpose inheritance consistency realized modeling features configuration intersection component features excluding inconsistent combinations 
instance build configuration components having features operating system windows nt operating system unix operating system feature value formally operating system windows nt operating system unix 
configuration composed components features kn configuration features kn ki 
example configuration consistency consider 
see source components text editor component comes variants 
choose operating systems dos unix screen types tty news screen device drivers dumb ghostscript 
dumb driver assumes screen type handle data directly expressed variable ghostscript driver separate process convert postscript data bitmap 
component features imply version component included bound configuration 
compose consistent configuration source components 
selecting operating system choose dos version 
implies choose news screen types example dos support formally os dos screen type tty screen type news due differing screen type features news screen types 
choose tty screen types indicated plain lines 
final component choose screen device driver 
ghostscript chosen requires concurrent true case dos 
driver remains instantiated bitmap ascii depending screen type making choice complete editor built tty variants inheriting features source components 
alternative consider choice os unix indicated dashed lines 
path stands consistent configuration 
ability treating component features configuration constraints allows arbitrary localization configuration constraints components tagged constraints regarding usage global constraints regarding sub systems permitted 
short constraint usually expressed version selection permissible component feature applies configuration soon component included 
benefit localization single language specify constraints specify component features select component versions 
benefit drawback chosen language expressive encompass existing scm selection schemes simple keep mutual consistency configuration constraints decidable 
checking constraint consistency hard task existing scm selection identification schemes handled efficiently 
feature logic hope having chosen established foundation addresses issues 
features configurations pure intersection appropriate features 
features author status perfect sense differ components object features differ definition 
independent features depend specific component 
possible approach prefix independent features component name resulting orthogonal features tty author screen status 
far better alternative express dependency explicitly feature logic implications object enforce version component required 
construct implications define special aggregation operator 
operator similar special handling independent features unifying dependent specific component object features stripped altogether 
fm feature term denoting independent features fi object holds kn denote components 
component ki ki andk chosen ki object ki holds ki unique component identifier denotes independent features ki denotes ordinary non independent features ki 
ki written kn defined kn ki object ki aggregation properly select intersecting object object respectively proposition object object denote components denote independent features described 
object holds 
proof 
object defined 
object object object object object object object object object object object object object object object object aggregation operator extend object features independent features formally define features propagate components configurations 
configuration composed components kn ki object ki term denoting independent features configuration identified object kn kn object kn ki object features united independent features dependent respective component features unified 
example consider components screen object screen author lisa resolution high medium driver object driver author tom resolution high author set independent features 
configuration containing screen driver object screen driver resolution high object screen author lisa object driver author tom unifying non independent features screen driver resolution high term properly selects lisa screen object tom driver object object screen author tom andc object driver author lisa 
close defining properties configurations 
formally configuration set object feature term identifying set configuration components 
configuration called consistent respect features number possible configurations non zero 
configuration called unambiguous bound aggregation component versions formally bound set object 
bound holds configuration called ambiguous dynamic 
gave alternate definition aggregation operator hold 
features derived components scm context describe features propagate components configurations 
important scm topic identification derived components constructed automatically configuration source components known program successors 
determine features derived components variation 
derived components consistent implies source configuration consistent 
ensure consistency multiple derivation stages derived component inherit features source components just configuration inherits features components 
formally component object derived source components kn denoting independent features identified object kn object ki explicit setting object feature removes implications generated aggregation operator non independent features remain unified 
example derivation consider editor example 
denote components operating system screen type screen device object os author tom object st author lisa object sd author john respectively independent features author 
derive editor component dos configuration identified object editor object os author tom screen type tty concurrent false object st author lisa screen type screen data bitmap object sd author john screen device dumb data screen data object editor screen type concurrent false screen data bitmap screen device dumb data bitmap object features independent features source components stripped features unified 
discuss extension mechanism create re derived components consistent source configurations 
versioning dimensions turn scm protocol layer introducing specific versioning dimensions 
scm literature distinguishes versioning dimensions historic revisions logic variance cooperative workspaces composition configurations 
known goal scm integrate dimensions concepts orthogonal versioning dimensional versioning instance integrate dimensions 
problem models different sets queries services due differing motivations results lack orthogonality 
revision history section show versioning dimensions realized version set model 
underlying foundation feature logic uniform versions identified features regardless versioning dimension scm primitive layer distinction 
protocol level introduce diversity giving special meanings features distinguishing versioning dimensions 
seen handle variance composition dimensions section turn specific historic cooperative dimensions 
revisions changes initial concepts show realize changes revisions 
revision version intended supersede version contrast variant 
typically revision product change applied existing revision 
traditional scm changes controlled version oriented versioning 
version oriented versioning controls impact changes serializing change applied forming revision history 
example consider revision history individual revisions version set denoted 
revision ri created applying change denoted originating revisions rk 
example consider revision created applying change 
version oriented versioning change implies previous changes 
example having change applied requires previous application change likewise implies changes 
configurations excluded simply way include change having applied quite easy analyse impact single change 
version oriented versioning problem changes largely independent wants configuration certain changes applied excluded 
weaknesses addressed change oriented versioning versions merely product applying change delta baseline existing version set 
version set model adopted change oriented versioning 
revision identified conjunction delta features standing change application 
revision subset change applied subset ifthe change applied 
revision instance identified changes applied 
revisions identified selected just versions features 
selection scheme enumerating applied changes convenient changes applied independently pain say revision selected enumerating changes applied 
unified versioning model find way accommodate convenience version oriented versioning freedom change oriented versioning 
idea exclude certain change combinations revision constraints 
mutual exclusions 
example consider version set selecting arbitrary change combination result consistent product inconsistent changes integrate 
achieved making subset easy see inconsistent holds 
generally exclude combination changes version set suffices subset revision constraint change implications 
problem changes rely 
assume contains version change applied say change implies change 
implication explicit making subset case holds effectively excluding change application 
generally ensure change implies change version set suffices subset revision constraint simple example revision constraints linear revision history change implies previous changes 
example revision set subset 
easily select revision just selecting changes automatically implied revision constraints 
see revision constraints effectively control application changes inhibit inconsistent change combinations simply assigning appropriate features version sets 
constraints histories specifying appropriate revision constraints possible capture arbitrary revision histories realizing full version oriented versioning 
example consider version set containing created changes shown 
represented ri conjunction included excluded changes 
far elegant representation obtained revision constraints 
instance subset relies andr subset changes mutually exclusive 
fact entirely represented revision constraints denoting complete revision history 
constraints obtained 
formally revisions ri letr lowest common ancestor revision history ri highest common descendant 
denote changes leading ri respectively version sets usual 
ri exist holds 
ci formal revision constraint defined ci change implies change revision constraint ci ci mutually exclusive ci holds 
turns intersection ci equivalent proposition revision set represented union revisions ri identified intersection included excluded changes intersection revision constraints ci defined 
representations equivalent 
ci ri 
proof 
see 
example representation obtained removing superfluous constraints general scheme 
see proposition realizes version oriented versioning top change oriented versioning appropriate constraints 
maintenance implications duty scm protocol layer hiding user section discuss simple check check protocol realized revision constraints 
scm primitive layer notion revisions knows components identified features distinguish specific feature types 
revision constraints may express implications delta features features 
clearcase example users assign names edges revision history select revisions disjunction name patterns naming changes easily expressed implication name appropriate delta features 
example currency simply devise revision current currency may differ variants 
currency constitutes part scm protocol expressed means scm primitive layer 
simple scheme denote currency set current contains current variants implying certain revisions 
implication current os unix ensures current unix variant requested change excluded possibly excluding subsequent changes revision constraints 
maintenance currency illustrated section 
dropping distinction delta features variant process specific features unifying concepts attribution revision histories scm primitive layer allows create select revise arbitrary revision variant component combinations orthogonal version management allowing refinement inheritance object oriented scm 
cooperation locks workspaces components variants revisions scm literature distinguishes fourth versioning dimension 
team functionality enables team developers develop maintain software product 
basic team functionality cooperation strategy ensures changes individual developer superseded developer 
conservative cooperation strategy developers lock component version configuration wish change 
locks exclusive version configuration locked developers excluded creating new revisions 
version sets locks managed currency set locked contains locked versions locked locked unlocked versions 
scm system locking component version changing features locked selection locked fail 
locking orthogonal features arbitrary version sets locked 
second generation scm systems introduced optimistic cooperation strategies :10.1.1.55.24
preventing concurrent changes attempt integrate changes 
central concept notion workspace individual area developer isolating changes developers isolating changes 
model user workspace just variant identified feature term user user lisa denotes lisa workspace user tom tom workspace 
user feature may value workspaces disjoint developer lisa workspace user lisa see changes user tom workspace 
tom may create new revisions workspace change currency changes subsumed user tom lisa workspace remain unaffected 
apply tom changes workspace lisa integrate tom changes changes 
lisa changes identified comparing contents workspace user lisa contents originating version set user lisa tom tom changes identified likewise 
setting locks workspaces part scm protocol currency revisions 
realized dedicated features freely integrated features selections constraints 
tom may declare workspace user tom os unix confining changes workspace unix version 
lisa may wish current revision including variants choosing workspace user lisa current 
dedicated features may modeling teams geographically distributed sites ensuring orthogonality uniformity interface scm primitive scm protocol layers 
practical extensions versioning model subsumes common identification selection schemes scm systems may prove useful support additional selection schemes practice 
scm systems select component versions set configuration rules prolog syntax shape pattern matching rules clearcase 
basic idea matching rule applied 
alternate scheme realized preference clauses configuration rule refines results previous unambiguous version selected 
schemes expressed feature logic directly version unambiguous means holds checking cardinality depends specific interpretation 
semantics selection schemes described top feature logic preference operators bound equivalences 
express preferences selection terms 
instance current fixed true selects current version fixed version os unix selects revision choice ambiguous unix variant 
practical extension additional constraints expressing properties mutual consistency decided feature logic 
useful examples include arithmetic constraints date function interfaces gcd int int int 
constraints handled additional constraints smolka feature unification algorithm deciding inconsistency simple feature terms evaluated soon variables features instantiated 
extended constraints users aware inconsistency conjunction extended constraints determined 
practice wellknown constraint solving systems simplex method language specific consistency checkers determine inconsistencies 
featured file system find version set model works practice realized version set model experimental scm system called ice incremental configuration environment 
ice provides access uses version sets virtual file system called ffs 
represents version sets known 
endif format identifies differences versions 
ffs example explore feasibility repository version sets defining effects basic file operations provide means describe operations scm protocol layer 
representing version sets designing ice problem arose representation efficient storage version sets scm primitive layer 
aim ambiguity transparent developers wanted represent version sets format suitable human readers 
far common representation multiple versions single source preprocessor cpp representation 
code pieces relevant certain versions enclosed 
endif expresses condition code piece included 
compilation cpp selects single version set feeding compiler 
cpp additional functionality macro expansion file inclusion interest 
conditional compilation programmer may perform changes simultaneously set versions 
unfortunately cpp technology scale number versions grows representation cpp directives hard understand harder change 
small amount variance cpp usage deprecated scm community 
rejection applies tool technique represent version sets cpp format giving user familiar understood representation 
ice uses cpp format represent version sets uses cpp terms boolean expressions represent feature terms 
cpp representation feature names expressed feature term cpp expr feature term cpp expr defined defined table translating feature terms cpp expressions feature term cpp expr get load os unix void extern void nlist defined defined nlist 
nlist kernel file endif defined type type endif value error exit get load os unix void extern void nlist nlist kernel file type value error 
exit version sets represented cpp files get load os unix void extern void nlist defined nlist 
nlist kernel file endif type value error exit cpp symbols 
table summarized mapping feature terms cpp expressions better readability tokens 
represented respectively 
nearly feature term equivalent cpp expression 
exceptions denoted include atoms occurring feature values variables composed feature values 
cpp expressions enclosing square brackets 
vice versa cpp expression equivalent feature term representation exception arithmetic cpp expressions treated atoms feature terms 
cpp program ice syntax semantics cpp files expressions 
show realize selection union version sets represented cpp files 
cpp file representing source code versions version set cpp representation 
select subset selection term set proceed follows 
code piece enclosed 
endif governing feature term intersected selection term ifc code piece removed ifc directive removed simplified respect proposition 
new smaller cpp file characterized written obviously 
shows constrained cpp file get load taken tool displaying system load architectures 
shows subsets get load os unix version get load os unix get load os unix non version get load os unix get load os unix note simplified cpp expressions 
selection refinement possible singleton version set obtained source file directives 
union cpp files andf computed 
compact cpp representation constructed exist 
idea compare files textually diff algorithm initially ignoring cpp directives 
resulting file text parts occurring orf governed respectively common parts governed read right left demonstrates get load os unix get load os unix get load os unix os unix get load os unix diff algorithm determines compact representation generated version set get load os unix governing expressions simplified respect os unix 
see feature terms introduced syntactic device denotation version sets precise semantics terms cpp files 
transparent version set access integration software development environments scm primitive layer configuration items accessible way 
common denominator today environments file system know scm tool provide file system interface 
today scm tools realize item access explicit copying source components repositories databases individual file systems vice versa 
approach advantage database technology transaction safety advanced query services available repository workspaces may realized possibly ambiguous sub databases repository 
drawback configuration items scm control copied individual file system 
approaches allow configurations workspaces selected manipulated virtual file systems representing individual views repository 
typical examples include nse dfs clearcase 
systems user workspaces part classical repository actual repository hard wired nse clearcase generic dfs 
entire repository accessible virtual file system 
convenient users technique gives scm system direct control user workspaces 
allows space savings copy write techniques known sharing common files developers 
chosen cpp representation introduced base virtual file system ice called ffs featured file system realizing example scm primitive layer 
ffs files occurring multiple versions accessed appending version specification file name just notation 
basic operations supported ffs read 
read access accomplished selection shown opening virtual file tty user tom gives access version set user tom file tty write 
write access changing implemented generating 
practice means version subset multi version document edited changed invoking ordinary text editor 
cpp directives indicate common differing parts versions 
write ffs re determines differences cpp directives original file similar multi version editor maintenance multiple versions done file system level 
current ffs implementation uses cpp representation version specifications 
user tom screen user lisa test tty user tom screen tty versioned directories user tom screen user lisa test tty express file existent configuration cpp error directive 
error directive stands non existent file error directive governed feature term indicates non existent 
add ffs operations create 
creating file non existent creates containing error directive governed considered non existent 
remove 
removing file augments error directive governed accessible 
example consider creation file printer data postscript 
creation printer contain lines data postscript 
error 
endif attempt read printer data postscript fail 
alternate interpretation file exists specific configuration features 
creation removal set manipulate features file set features file remove 
operation called renaming rename 
renaming file equivalent removing 
tagging technique illustrated discussing composition protocol section 
versioned file system versioned files ffs provides versioned directories covering state changes entire file system configuration universe 
basically versioned directory format ordinary directory directory entry associated governing feature term 
directory entry governed feature term visible subset selection term orc tom creates new file workspace user tom entry current directory governed term user tom illustrated lisa workspace user lisa directory version non existent 
versioned directory part current path directory version affects contents directory including subdirectories files contained file version implicitly read 
opening directory os unix selects unix variants files subdirectories changes applied user tom directory affects tom workspace 
changing current directory users switch workspaces versions 
entering cd current 
os dos shorter cd current os dos sure subsequent changes apply current revision non dos variants 
illustrated user tom os dos user tom os dos narrowing configuration space ffs os unix user tom os unix directory changes may performed incrementally subsequently narrowing configuration space features specified 
workspace variant revision individual view configuration space 
features directory set features individual files removing complement 
removing directory version tested current directory contained items available tested version 
convenient setting features files directory file system subset 
accepting version specifications parts file path features file systems apply 
directory refers second component current path user tom 
equivalent 
file modes times access restrictions versioned file may occur times versioned directory time different attributes different governing feature term 
technically ffs realized modified nfs server making ffs available network 
version sets stored ordinary cpp files allowing simple recovery cpp special format available binary files 
ffs server keeps version sets cache read changed version sets kept cache superset requested 
second version set accesses served constant time 
practice means directory version entered ffs server performance ordinary nfs server 
considered slow alternate ffs realizations dynamic system libraries dfs virtual device drivers clearcase bypass nfs bottleneck local file systems show virtually difference direct file access 
files common version sets cached showing space saving effects copy write techniques 
current implementation file uniquely identified name 
versioning contents modes file exploits maximum commonality cpp representation renaming file inhibits common cpp representation ffs implementations add extra indirection level 
contrast virtual file systems realizes nse clearcase enforce specific scm policy 
provides basic mechanisms arbitrary version set access 
specific scm policy realized top ffs scm tools manipulate version sets 
contrast dfs scm tools located lowest level realizing repository access basic scm policies 
practice expect developers interact directly ffs unusual circumstances 
developer private workspace user lisa current scm tools realize specific scm policies changing contents current 
issue explored discussing scm protocols section 
unified versioning section ffs describe semantics major scm protocols taken feiler survey configuration management models commercial environments 
show implement protocols top ffs give ideas protocols integrated 
number scm protocols scm system supports indicator flexibility protocol layer turns protocols realized top ffs demonstrating unifying nature version set model 
checkin checkout protocol checkin checkout protocol realized known rcs sccs tools 
sketched section scm tools provide operations copy revisions file system repository check retrieve back check illustrated 
individual developers lock branches revision history changes 
show realize checkin checkout protocol top ffs 
repository realized file conjunction revision constraints discussed section 
order select individual revision ri introduce special feature ri ri includes changes leading ri excludes changes 
term contains additional constraints form ri rk revisions immediately derived ri obviously ri ri holds 
current revision maintained currency constraint current ri inr 
operations checkin checkout protocol described 
check 
add new current revision file repository unique identifier holds words unused revision number 

check locks 
current locked exist current revision locked abort operation 

store new revision 
overwrite new revision selected old revision set accessed 

maintain revision constraints 
require constraint ancestor revisions 
way including change automatically include earlier changes 
done renaming feature 
maintain revision selector 
rename ri accessing ri returns 
check check check repositories workspace checkin checkout protocol 
maintain currency 
old currency invalidated renaming current 
new currency established renaming current add revision multiple ancestors add non current revision branch constraints maintained 
check 
check current revision copy current check earlier revision ri ri lock 
lock revision ri user check revision locked ri locked exists abort operation 
rename ri ri locked ri exists locked version 
unlock 
unlock revision ri locked user rename ri locked tof ri 
check operation quite complex illustrate example 
repository revisions shown current revision 
file exists current defined 
check new revision 
step new version accessed old repository accessible differences enclosed 
endif 
endif 
selecting older revision ri returns non singleton version set ri implies 
handled step changing selecting excludes change holds 
remaining steps ensure andf current return 
composition protocol composition protocol extends checkin checkout protocol notions configurations consistency 
set components composed component version selected resulting bound consistent configuration shown 
composition selection taken place selected components maintained checkin checkout protocol component individual repository 
composition usually simple enumeration components obtained refining dependency relationships selection identification schemes subsumed see discussion represent version relationships 
compose select repository composition configuration composition protocol feature logic 
realize composition protocol configurations maintained current directory 
current directory records versions components part configuration 
operations composition protocol tag 
assign attribute file rename remove 
remove attribute sure exist rename tof 
compose 
compose set components feature term identifying composition 
composition exists just enter directory version 
select originating version subset set configuration adding removing files required 
select 
configuration bound refine component occurs version chosen configuration bound 
refinement process best done interactive tool ensures configuration consistency 
composition selection realized efficient simple feature term stated proposition disjunction configuration rules existing scm systems handled efficiently 
single difficult point check consistency ambiguous configurations discussed section 
theory easily construct examples possible configuration separately checked consistency resulting explosion exponential complexity 
practice expect problem due principles low coupling high cohesion 
low coupling confines changes function module leaving interface intact 
means ambiguity effect components factorized consistency checking 
hand high cohesion functions modules means change implies changes choosing component version determines versions components narrowing configuration space configurations remain 
properties apply today software systems affect configurability open issue 
long transaction protocol long transaction protocol centered notion workspace discussed section realized sun network software environment nse 
update commit project workspace user workspace long transaction protocol realize long transaction protocol top ffs setting 
user assigned individual variant project top level directory identified user 
common project state identified user project disjoint user workspace call project workspace 
shown users synchronize propagating changes project workspace 
workspace revision history 
realized checkin checkout protocol current revision accessed directly ffs 
user usually works workspace current revision entering user current 
entire workspaces versioned 
realizations long transaction protocol conservative strategy rely component workspace locking 
setting assumes optimistic cooperation strategy existence change integration tools 
change integration algorithms known text syntax semantic purposes algorithms extended handle version sets 
operations long transaction protocol follows originate 
create new workspace user rename user project 
user project virtually copying project workspace user workspace making accessible update 
propagate changes project workspace user project user workspace user determine ri user ri user project ri isthe common origin workspaces 
integrate changes workspaces base store result workspace user commit 
commit changes user workspace project workspace update user workspace described 
create new current revision project workspace containing virtual copy user workspace 
example long transaction protocol 
tom lisa individual workspaces user tom 
user lisa 
changes current revision file tty lisa commit changes 
changes tty update new revision project workspace created containing lisa changes tty tom updates workspace commit integrate lisa changes changes revision base 
integration committed creating new revision project workspace incorporating lisa tom changes 
apply baselines changes configuration change set protocol change set protocol section discussed difference version oriented versioning 
change set protocol logical changes primary objects interest versions merely product applying change sets baseline shown 
change oriented versioning provides natural link change requests originate scm process configuration identified incorporated changes 
revision concept discussed section assumes revisions created applying changes ancestor revision appropriate revision constraints users denote revisions specifying change sets giving revision numbers discussed section 
operations change set protocol change 
create change file create new version change desired 
file may file system subset changes files part implies changes rename tof 
apply 
apply change set arbitrary baseline access 
version exist changes mutually exclusive create integrating changes discussed section 
contrast version oriented protocols change oriented protocol extensive change integration 
version repositories structured mutual exclusion implication conflicting changes indicated constraint 
just version oriented protocols arbitrary sets changes variants components specified examined 
performance complexity having shown individual protocols realized top ffs discuss complexity issues 
may sound surprising obviously individual protocol realized efficiently existing scm system bother 
show efficiency endangered formal base fact efficiency due number constraints organization features identify 
second having understood constraints scm protocols efficient turn problem integrating scm protocols 
today scm protocols efficient 
proposition stated deciding inconsistency feature term deciding holds np complete problem 
scm principles rely deciding inconsistency result exponential complexity 
isn existing scm systems 
basically causes reducing complexity imposing constraints general problem 
simplification 
existing scm systems components identified selected simple feature terms general case having non simple feature terms identification selection occurs 
preconditions proposition apply version member selection simply decided evaluating selection term values furnished identification term vice versa 
selection operations section efficient 
implication chains 
second issue specific revision handling 
applying revision constraint scheme section revisions identified long chains implications 
simple method decide consistency implication chain selection term works follows replace repeat process likewise replace repeat process scheme allows efficient selection classical revision histories realized today scm systems 
orthogonality 
stated proposition feature terms consistent common features variables intersection consistent checked linear time 
property creation new versions efficient identified new features orthogonal existing ones 
furthermore orthogonality simplifies separation concerns 
instance maintenance revisions variants dramatically simplified soon revision features variant features interact example placing cpp file rcs control 
conclude long versions identified simple feature terms long stick revision histories long keep revisions workspaces variants separated realize efficient scm protocols 
status quo 
common foundation realize efficiently 
case study see ice handles major scm protocols implemented methods stated deductive shortcuts full fledged feature unification 
case study chosen gnu program publicly available revisions named 
gnu distribution considered single file named commands happened modified revision 
wanted know ice performs creating repository revisions commands compared known tools rcs sccs see effects deductive shortcuts ice run deductive shortcuts rely feature unification 
gnu distribution differences earlier revisions available gnu ftp server ftp prep ai mit edu pub gnu 
commands enter file suffixes deps unsigned int slen strlen dep name unsigned int len strlen file name endif len slen dep name name len slen slen elif len slen dep name name len slen slen len slen dep name file name len slen endif file stem name len slen file stem file name len slen endif break file stem multi revision file see excerpt version set commands incorporating revisions 
see change replaced file name dep name change introduced parenthesized subexpression 
excerpt maximum number features govern code pieces making excerpt quite readable 
commands contains code pieces governed features little harder understand alternative set mutual diff runs 
version set commands ice extract individual revisions linear time due efficiency simplification selecting specific revision take time running appropriate rcs sccs command 
results apply just chosen features identifying workspaces variants changes 
reading individual versions easily competes existing scm systems creation repository showed unexpected problems 
listed execution times checkin process ice checkin times rcs sccs 
initially deductive shortcuts ice relying np complete feature unification execution time grew limits shown 
deductive shortcuts enabled ice checkin time grows number revisions rcs sccs checkin times remain fairly constant 
difference ice ice compares entire version sets determining new compact representation discussed section example new revision compared entire repository ice inference engine determine governing feature terms number revisions grows 
contrast rcs sccs ice deductive shortcuts ice feature unification rcs sccs revision checkin times seconds ice rcs compare new revision previous revision 
checkin problem easily solved realizing rcs sccs approach comparing latest revisions 
data shows ice quite efficient comparing small revision sets feature logic common scm foundation feasibility common scm primitive layer 
multiple variants multiple revisions sharing common code latest revisions ice compare 
extent variants compared 
central problem integration variance scm concepts 
workspaces imply certain variants variants imply certain revisions changes apply certain variants introduce disjunctions revision constraints deduction process overly complex 
interferences indicators poor structure configuration space showing low coherence strong coupling configuration threads 
interferences uncovered mathematical concept analysis configuration structures restructuring software order eliminate 
research experience show far non orthogonal variance allowed interfere scm concepts resulting complexity tolerable practice 
see realization existing scm protocol imposes special problems integration scm concepts remains open issue 
automated scm lies clear separation primitives protocol policy clear semantic foundation 
proposed feature logic version sets scm foundation 
version sets integrate unify current scm versioning models provide welldefined semantics defining higher scm layers 
feature logic powerful endanger flexibility higher scm layers sufficiently specialized describe features propagate scm process 
implementation version set model ice shown foundation numerous user visible benefits 
feature deduction mechanisms ambiguity tolerated scm layers sets objects primary items interest 
scm process constrained process specific decisions lower scm layers 
major scm protocols realized efficiently top scm primitive layer ffs 
features ice environment adapting users process vice versa 
refining extending evaluating ice implementation especially protocol policy levels focus subjects 
efficient integration scm concepts 
seen major scm models realized efficiently top version set model 
identified complexity problems non orthogonal scm concepts especially variance 
experience ffs underlying deduction engine want investigate far integration scm concepts go efficiency 
furthermore want see integrated scm protocols feasible realized top ffs far scm process determined protocols 
versioned component relations 
model supports versioned components notions relationships components 
required means model versioned component relations relations component versions 
generally plan extend version set model features represent relationships version sets 
relationships modeled non functional features called roles 
extension introduce unify versioning concepts graph structured applications computer aided design cad graph software development environments results 
support scm process 
conceptual level find scm processes formalized version set model scm tool behaviour may verified scm process 
imagine organizing scm process entirely manipulating component features changing state proposed tested released scm procedures modeled pre post conditions specified feature terms 
unfortunately true methodology components versions attributed feature terms experiences attribute oriented scm systems faceted classification help 
eventually hope model entire scm process operations version sets denoted feature logic providing uniform semantic foundation scm layers 
ice ffs developed part nora project aims utilizing inference technology software tools 
ice ffs related technical reports accessed nora henrik play 
nora real acronym 
ice www page www cs tu bs de ice anonymous ftp ftp ips cs tu bs de pub local ice 
acknowledgments ice possible contributing ice implementation making program sources tools available 
lars ning implemented cpp representation gnu diff 
olaf built ffs server top public domain nfs server 
marc implemented smolka feature unification algorithm 
dirk babel michael brandes andreas realized higher layers ice 
anonymous reviewers useful constructive comments 
adams solomon overview software development environment 
software configuration management selected papers icse scm scm workshops seattle washington oct estublier ed vol 
lecture notes computer science springer verlag pp 

kaci algebraic semantics approach effective resolution type equations 
theoretical computer science 
kaci nasr login logic programming language built inheritance 
journal logic programming 
kaci podelski meaning life 
proc 
rd international symposium programming language implementation logic programming passau germany aug ski wirsing eds vol 
lecture notes computer science springer verlag pp 

berliner cvs ii parallelizing software development 
proc 
winter usenix conference washington 
binkley horwitz reps program integration languages procedure calls 
acm transactions software engineering methodology jan 
brachman levesque tractability subsumption frame description languages 
proc 
th national conference american association artificial intelligence austin texas aug pp 

brown dart feiler state automated configuration management 
tech 
rep cmu sei atr software engineering institute carnegie mellon university pittsburgh pa sept 
conradi versioning models 
software configuration management selected papers icse scm scm workshops seattle washington oct estublier ed vol 
lecture notes computer science springer verlag 
conradi westfechtel version models software configuration management 
tech 
rep aib rwth aachen germany oct 
network software environment 
tech 
rep fe sun microsystems feb 
dart concepts configuration management systems 
proc 
rd international workshop software configuration management trondheim norway june feiler ed acm press pp 

engels lewerentz nagl sch fer sch rr building integrated software development environments part tool specification 
acm transactions software engineering methodology 
estublier process session 
software configuration management selected papers icse scm scm workshops seattle washington oct estublier ed vol 
lecture notes computer science springer verlag pp 

estublier adele configuration manager 
configuration management tichy ed vol 
trends software 
john wiley sons chichester uk ch 
pp 

feiler configuration management models commercial environments 
tech 
rep cmu sei tr software engineering institute carnegie mellon university pittsburgh pa mar 
feldman program maintaining computer programs 
software practice experience apr 
fowler korn rao dfs multiple dimensional file system 
configuration management tichy ed vol 
trends software 
john wiley sons chichester uk ch 
pp 

gulla karlsson yeh change oriented version descriptions epos 
software engineering journal nov 
harter version management change control systematic approaches keeping track source code support files 
unix world june 
institute electrical electronics engineers ieee guide software configuration management 
new york 
ansi ieee standard 
institute electrical electronics engineers ieee guide software configuration management plans 
new york 
ansi ieee standard 
international organization standardization international electrotechnical commission 
programming languages dec 
iso iec international standard 
jones gomard sestoft partial evaluation automatic program generation 
prentice hall 
kaplan bresnan lexical functional grammar formal system grammatical representation 
mental representation grammatical relations bresnan ed 
mit press cambridge mass pp 

katz unified framework version modeling engineering databases 
acm computing surveys dec 
kay functional unification grammar formalism machine translation 
proc 
th international joint conference artificial intelligence stanford pp 

krone snelting inference configuration structures source code 
proc 
th international conference software engineering sorrento italy may ieee computer society press pp 

lacroix preferences putting knowledge queries 
proc 
th international conference large data bases brighton kent eds pp 

mahler object base attributed software objects 
proc 
fall conference oct pp 

cm challenge configuration management works 
configuration management tichy ed vol 
trends software 
john wiley sons chichester uk ch 
pp 

lie conradi karlsson change oriented versioning software engineering database 
proc 
nd international workshop software configuration management princeton new jersey oct tichy ed acm press pp 

mahler variants keeping things telling apart 
configuration management tichy ed vol 
trends software 
john wiley sons chichester uk ch 
pp 

martin nipkow boolean unification story far 
unification kirchner ed 
academic press london pp 

miller myers file comparison program 
software practice experience 
larsen gulla conradi karlsson uniform versioning model 
proc 
th international workshop software configuration management preprint baltimore maryland may feldman ed pp 

nebel reasoning revision hybrid representation systems vol 
lecture notes artificial intelligence 
springer verlag 
nebel smolka representation reasoning attributive descriptions 
sorts types artificial intelligence apr bl sius ck 
eds vol 
lecture notes artificial intelligence springer verlag pp 

managing multi variant software configurations 
proc 
rd international workshop software configuration management trondheim norway june feiler ed acm press pp 

data model configuration management assistant 
proc 
nd international workshop software configuration management princeton new jersey oct tichy ed acm press pp 

prieto az classifying software reusability 
ieee software jan 
orthogonal version management 
proc 
nd international workshop software configuration management princeton new jersey oct tichy ed acm press pp 

source code control system 
ieee transactions software engineering se dec 
sch fer version management tightly integrated software engineering environments 
proc 
th international conference software engineering environments noordwijkerhout netherlands apr ieee computer society press 
sandberg goldberg kleiman walsh lyon design implementation sun network filesystem 
proc 
summer usenix conference portland oregon june pp 

bernstein kruskal creation maintenance multiple versions 
proc 
international workshop software version configuration control jan winkler ed teubner verlag stuttgart pp 

marlin designing configuration management facilities dynamically bound systems 
software configuration management selected papers icse scm scm workshops seattle washington oct estublier ed vol 
lecture notes computer science springer verlag pp 

sch rr winter graph grammar engineering progres 
proc 
th european software engineering conference spain sept sch fer botella eds vol 
lecture notes computer science springer verlag pp 

shieber pereira robinson tyson formalism implementation patr ii 
research interactive acquisition knowledge bresnan ed 
sri international 
smolka feature constrained logics unification grammars 
journal logic programming 
smolka kaci inheritance hierarchies semantics unification 
unification kirchner ed 
academic press london pp 

snelting calculus context relations 
acta informatica may 
snelting reengineering configurations mathematical concept analysis 
acm transactions software engineering methodology apr 
snelting schroeder inference support programming large 
proc 
rd european software engineering conference milano italy oct van lamsweerde eds vol 
lecture notes computer science springer verlag pp 

tichy rcs system version control 
software practice experience july 
van der hoek heimbigner wolf generic peer peer repository distributed configuration management 
proc 
th international conference software engineering berlin germany mar ieee computer society press pp 

westfechtel structure oriented merging revisions software documents 
proc 
rd 
scm trondheim norway june feiler ed acm press pp 

wiebe object oriented software configuration management 
proc 
th international workshop software configuration management preprint baltimore maryland may feldman ed pp 

winkler version control families large programs 
proc 
th international conference software engineering monterey california mar riddle ed ieee computer society press pp 

zeller unified version model configuration management 
proc 
rd acm sigsoft symposium foundations software engineering washington dc oct kaiser ed vol 
acm software engineering notes acm press pp 

zeller smooth operations square operators version set model ice 
proc 
th international workshop software configuration management berlin germany mar sommerville ed vol 
lecture notes computer science springer verlag pp 

zeller configuration management version sets 
phd thesis technical university braunschweig germany apr 
zeller versioning software systems concept descriptions 
computer science report technical university braunschweig germany jan 
submitted publication 
zeller snelting handling version sets feature logic 
proc 
th european software engineering conference spain sept sch fer botella eds vol 
lecture notes computer science springer verlag pp 

technische universitat braunschweig informatik berichte ab nr 
lindig style practical type checker scheme 
ehrich zu und troll light zeller con guration management feature logics beschreibung des auf der hartmann saake hartel revised version modelling language troll version 
zeller snelting incremental con guration management feature uni cation conrad basic calculus verifying properties synchronously interacting objects gogolla denker conrad 
ehrich approach development reliable information systems lindig software fischer vcr vdm software component retrieval tool des von godel snelting reengineering con gurations mathematical concept analysis zeller uni ed con guration management model bickel hoare logic data types 
type stamps structure stamps referentially transparent higher order module language uber und den wissenschaften zeller ddd free graphical front unix debuggers zeller smooth operations square operators version set model ice funk snelting algorithms concept lattice decomposition application zeller snelting uni ed versioning feature logic snelting systeme durch program slicing und constraint solving lindig snelting modularization legacy code mathematical concept analysis workshop domains ii proceedings 
syntactic approach structure generativity zur funktionen aus zeller versioning software systems concept descriptions 
