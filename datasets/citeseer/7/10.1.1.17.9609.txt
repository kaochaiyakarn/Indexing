www lsv ens cachan fr appear journal logic algebraic programming model checker time 
complexity model checking timed modal logics luca aceto brics department computer science aalborg university fredrik vej dk aalborg denmark :10.1.1.43.2086
fax laboratoire cation cation cnrs umr ens de cachan av 
du pr 
wilson cachan france :10.1.1.43.2086
fax studies structural complexity model checking timed modal logics literature :10.1.1.43.2086
precisely consider variations speci cation formalisms tools cmc uppaal fragments timed calculus 
logics characterize computational complexity model checking speci cation program complexity parallel compositions timed automata system model 
particular show complexity model checking timed calculus interpreted networks timed automata exptime complete matter complexity measured respect size speci cation model 
model checking timed versions hennessy milner logic restricted fragments timed calculus studied literature cmc uppaal shown pspace complete exptime complete 
complexity results ered theorem ect model checking problem sublanguage timed calculus proposed larsen pettersson yi pspace complete 
result accompanied array statements showing extension model checking problem 
argue model checking problem timed propositional calculus exptime complete improving results henzinger nicollin sifakis yovine 
key words model checking timed automata timed modal logics complexity veri cation 
email addresses luca cs auc dk luca aceto fl lsv ens cachan fr 
basic research computer science centre danish national research foundation 
preprint submitted journal logic algebraic programming december model checking approach computer aided veri cation programs rst proposed gained considerable acceptance years light impressive applications design veri cation circuits distributed protocols see :10.1.1.43.2086
model checking establish correctness system respect speci cation showing mathematical model satis es correctness criteria expressed formal language 
language takes form temporal logic ctl modal logic xed points modal calculus :10.1.1.43.2086
choice appropriate speci cation language application hand result trade contrasting issues expressiveness complexity 
hand highly expressive logic allows describe interesting behaviours concurrent systems 
model checking realistic systems relies fully automatic computer support crucial speci cation language admits cient model checking algorithms 
extension model checking speci cation veri cation realtime systems thoroughly studied years 
led development speci cation logics extend standard untimed formalisms quantitative analysis timing constraints see important theoretical results investigating limits decidability model checking :10.1.1.43.2086
theory embodied veri cation tools hytech kronos uppaal successfully veri cation non trivial systems see 
applications indicate automatic veri cation real time embedded software may feasible practice 
despite important theoretical results op 
cit literature lacking comprehensive analysis structural complexity model checking real time modal logics variations thereof speci cation formalisms veri cation tools cmc uppaal 
complexity theoretic analysis model checking problem yields useful guidelines selecting speci cation logic ers compromise expressiveness complexity see comprehensive complexity theoretic perspective model checking linear branching time logics reactive systems main sources inspiration :10.1.1.43.2086
remainder section introduce di erent ways measuring complexity model checking problems outline main results compare untimed case :10.1.1.43.2086
discussion related 
complexity model checking real time logics 
untimed case model checking algorithms polynomial time complexity small space requirements developed branching time temporal logics :10.1.1.43.2086
timed case model checking problems considered literature pspace hard :10.1.1.43.2086
clearly quantitative analysis timing constraints increases complexity model checking interesting analyze precisely cases complexity blow occurs 
untimed case papers see study detail ect temporal operators number atomic propositions depth operators nesting complexity model checking giving better understanding complexity issue :10.1.1.43.2086
things address kind problem timed case happens time inserted model formula 
happens expressive logics restricted operators 
consider timed modal property languages introduced speci cation language tool cmc fragment proposed order improve ciency model checking practice sbll safety bounded liveness logic introduced properties respect testing timed automaton method currently veri cation tools uppaal check properties plain reachability ones :10.1.1.43.2086
property languages study computational complexity model checking networks timed automata system model 
argued lichtenstein pnueli complexity model checking problem measured di erent ways 
speci cation measure complexity function size program veri ed program complexity measure 
secondly program measure complexity function size speci cation speci cation complexity measure 
combined complexity model checking problem measured function size program speci cation 
lichtenstein pnueli thesis models systems usually large speci cations usually small program complexity model checking signi cant measure feasibility 
er complexity results di erent views model checking problem property languages consider 
doing give posteriori justi cation couched complexity theoretic arguments folk beliefs area model checking real time systems choices developers real time veri cation tools 
outline main results 
study analyzing complexity model checking timed calculus denoted alternation free fragment afmc sect 
:10.1.1.43.2086
untimed setting fragment modal calculus plays important role speci cation formalism fairly expressive restricted syntax symbolic evaluation expressions linear size model speci cation 
real time setting show complexity model checking timed afmc exptime complete program complexity speci cation complexity thm 

show furthermore surprisingly model checking problem fortiori timed afmc exptime hard model inactive process clocks nil 
see lemma 
feel result theoretical curiosity 
successful approaches model checking variations modal calculus partial model checking veri cation engine tool cmc :10.1.1.43.2086
approach model checking problems networks timed automata reduced checking properties expressed logic process nil 
results show worst case problem just hard original 
similar results apply full timed calculus study 
prove model checking problem fragment greatest xed points essentially timed version hennessy milner logic pspace complete thm 

proceed develop thorough analysis complexity model checking timed modal property languages literature tools cmc uppaal 
case er results pinpointing program speci cation combined complexity model checking property languages greatest xed points 
just wish point model checking problem property language pspace complete matter complexity measured respect size program speci cation 
see thm 

light aforementioned results assuming pspace di erent exptime model checking problem lower computational complexity results er complexity theoretic justi cation claims ect model checking easier source lower complexity derives observation model checking problem reduced polynomial time reachability checking timed automata problem pspace completeness shown 
syntax property language contains seemingly ad table overview results stands complete model checking prog 
compl 
spec 
compl 
exptime exptime exptime sbll pspace pspace pspace pspace pspace conp conp sbll pspace pspace conp hoc restrictions informative study structural complexity model checking extensions language obtained removing constraints syntax imposed 
prove array statements ect resulting extensions model checking problem sect 

results er justi cation choices op 
cit 
overview main results obtained table denotes xed point free fragment property language argued appendix results robust respect changes type guards allowed timed automata 
model checking concurrent programs 
aforementioned results complexity model checking timed automata model real time systems 
practice real time systems contain communicating components may modelled parallel compositions timed automata 
denote model checking concurrent programs problem deciding modal logic formula holds concurrent timed system viz 
parallel composition timed automata 
untimed setting model checking su ers called state explosion problem presence concurrency 
characterization complexity model checking problem property languages study presence concurrency yield realistic assessment hardness task model checking real time systems 
prove property languages consider untimed setting concurrency feature increase structural complexity model checking problems sect 

explanation phenomenon may gleaned comparing results untimed formalisms 
table timed vs untimed formalisms stands complete ja untimed timed un timed reachability nlogspace pspace pspace ctl pspace pspace afmc exptime exptime full calculus exptime exptime comparison results untimed formalisms :10.1.1.43.2086
instructive compare results similar ones untimed alternation free calculus 
previously mentioned program logic algorithms model checking run time linear size program speci cation 
program speci cation complexities complete 
model checking problem full calculus 
note program complexity alternation free calculus concurrent programs exptime complete matches exactly complexity results er model checking 
interesting note program complexity ctl model checking reachability concurrent programs pspace complete matching complexity model checking tctl reachability timed automata respectively 
results provide mathematical grounding folk belief clocks act concurrent programs increasing number clocks corresponds adding parallel components 
overview comparison complexity model checking untimed formalisms timed counterparts table :10.1.1.43.2086
related 
extensive literature complexity model checking linear branching time logics concurrent reactive systems see :10.1.1.43.2086
particular ers automata theoretic approach model checking problem branching time logics ctl ctl calculus gives improved space complexity bounds problem 
clear readers study greatly inspired developments op 
cit especially technical developments related establishing lower bounds complexity model checking problems consider study model checking problems concurrent programs 
program complexity ltl model checking concurrent programs shown pspace complete classic study means techniques 
literature complexity veri cation untimed reactive systems rich results complexity implementation veri cation 
implementation veri cation models implementations speci cations means transition systems 
veri cation task consists checking behaviour model implementation correlates behaviour model speci cation 
complexity implementation veri cation concurrent programs studied trace tree approaches investigated fairness constraints 
related literature dealing complexity model checking realtime logics expressiveness languages extensively mentioned introductory section 
surveys results area research may 
interesting rabinovich develop real time logics grounded mathematical logic tradition framework monadic logic order particular 
focuses expressiveness decidability issues 
example introduces quantitative temporal logic qtl shows satis ability problem logic pspace complete techniques mathematical logic argues qtl expressive rivals literature 
behavioural relations timed automata relationship timed logics characteristic formulae studied 
expanded version 
apart providing proofs results announced current ers new developments 
particular point things deal full timed calculus study structural complexity model checking networks timed automata real time logics consider analyze complexity model checking extensions property language mapping territory property language study robustness results respect changes model timed automata consideration 
preliminaries brie reviewing variation timed automaton model proposed alur dill sect :10.1.1.43.2086
property languages study sects :10.1.1.43.2086
:10.1.1.43.2086
algorithms shall employ order establish upper bounds complexity model checking problems consider rely region graph construction 
sake clarity construction main properties outlined sect 
:10.1.1.43.2086
recall basic problems complexity theory nd application lower bound arguments sect 
:10.1.1.43.2086
timed automata act nite set actions ranged denote sets natural non negative real numbers respectively :10.1.1.43.2086
write set delay actions set clocks :10.1.1.43.2086
denote set boolean expressions atomic formulae form write restriction expressions integer constants belong kg :10.1.1.43.2086
expressions interpreted collection time assignments 
time assignment valuation function write typical elements collection valuations time assignment boolean value describes satis ed :10.1.1.43.2086
time assignment denote time assignment maps clock value set clocks included write assignment maps clock value agrees cnc de nition timed automaton ta quintuple ei nite set nodes initial node nite set clocks act nite set edges :10.1.1.43.2086
quintuple hn stands edge node node action denotes set clocks reset enabling condition guard :10.1.1.43.2086
lieu hn shall suggestive resp 
possibly omitted tt resp 

denote largest integer constant occurring guards remainder study shall write nil node timed automaton fn state con guration timed automaton pair node time assignment initial state initial node time assignment mapping clocks 
operational semantics timed automaton timed labelled transition system ta hs act sa set states initial state transition relation de ned follows 
hn tt :10.1.1.43.2086
reader readily realize determined timed automaton nil consists state form uncountably delay transitions form de nition ei timed automaton :10.1.1.43.2086
say node reachable sequence transitions ta leading initial state state form :10.1.1.43.2086
note consider extended tas assign invariant downward closed clock constraint node avoid excessive time delays 
results hold extended tas 
complexity class having hardness result simple tas implies extended tas having membership result extended tas implies tas 
membership result easily adapted extended tas 
results size region graph cf 
sect 
bigger extended tas tas introduced defn :10.1.1.43.2086
adding invariants remove states delay transitions 
timed modal calculus de ne timed modal calculus inspired logic :10.1.1.43.2086
de nition nite nonempty set clocks disjoint id countably nite set identi ers ranged 
set formulae id generated grammar hai max min act subset id occurrence identi er formula bound min max operator :10.1.1.43.2086
denote largest integer constant occurring clock constraints 
new operators tt ff read implies easily de ned 
example tt ff shorthands respectively timed automaton interpret formulae respect extended con gurations con guration time assignment classic modal operators hai deal action transitions operator resp :10.1.1.43.2086
denotes existential resp 
universal quanti cation delay transitions 
clocks socalled formula clocks increase synchronously automata clocks measuring time states system 
formula initializes formula clocks 
constraints compare values formula clocks current extended con guration integer values 
extended con guration satis es max resp 
min belongs largest resp 
solution equation complete lattice sets extended con gurations 
existence solutions guaranteed standard xed point theory 
de ne formal semantics convenient consider open formulae formulae may contain occurrences identi ers bound greatest xed point operators 
timed automaton environment mapping identi ers id sets extended con gurations environment identi er subset extended states write 
environment mapping acting identi ers 
formal semantics table associates formula environment set extended states satisfy assumption identi er satis ed extended states :10.1.1.43.2086
interested reader nd details de nition 
closed formula collection extended states satisfying independent environment written 
sequel extended state closed formula shall write table semantics def ttg def def hai def :10.1.1.43.2086
def :10.1.1.43.2086
def def def def min def fs :10.1.1.43.2086
sg max def fs 
read satis es lieu :10.1.1.43.2086
timed automaton closed formula suggestive shorthand lieu 
example property expressed xed points clock constraints consider formula max fxg hci tt formula expresses fact state reachable performing actions delays occurrence action followed action time units 
interested reader referred examples property speci cations fragment fragments fragments logic interest remainder study :10.1.1.43.2086
alternation free fragment denoted consists formulae occurrence identi er bound min resp 
max operator occur subformula form max resp 
min 
logic fragment greatest xed points allowed 
property language fragment existential modalities hai restricted disjunction form allowed :10.1.1.43.2086
property languages sbll extend interpreted slightly di erent kind timed automata subset act edge labeled guard tt act contains label denote internal action automata :10.1.1.43.2086
semantics property languages di erent notion satisfaction relation denoted follows compared formula holds extended con guration holds reachable zero transitions 
example 

implies 
reached delay transitions total duration 
sbll extends allowing hai tt subformulae extends sbll new operators formula holds holds :10.1.1.43.2086
reachable delay transitions total duration delay transitions positive duration occur states actions enabled 
languages translated sense exists formula :10.1.1.43.2086
example max see appendix complete translation 
important property sbll model checking problem reduced reachability problem follows formula languages build testing automaton reject node reachable synchronized parallel composition :10.1.1.43.2086
shown expressive encode reachability property kind timed automata tool uppaal 
interested reader referred op 
cit 
information sbll property language shall denote xed point free fragment 
timed calculus proposed model checking problem shown pspace hard :10.1.1.43.2086
logic uses powerful binary operator 
modalities hai 
subse quent exptime completeness result model checking problem logic see theorem easily adapted yielding improved lower bound complexity model checking see :10.1.1.43.2086
region graph construction sake clarity brie review basic techniques results algorithmics timed automata needed remainder study :10.1.1.43.2086
presentation necessarily sketchy refer reader full details 
regions time assignments 
automatic veri cation timed systems modelled networks timed automata possible despite uncountably nite number con gurations associated timed automaton 
decision procedure problem known region technique 
denote set clocks possible partition uncountably nite set time assignments nite number regions way extended con gurations region satisfy subformulae :10.1.1.43.2086
formally regions de ned equivalence classes induced equivalence relation valuations de ned valuations region satisfy clock constraints bm max 
write region contains time assignment cl ranged denote nite set regions set cl clocks integer constant region cl cl de ne reset operator 
region unique successor region cl denoted succ region tt cl exists :10.1.1.43.2086

write succ succ nonnegative integer region graph :10.1.1.43.2086
timed automaton ei set formula clocks disjoint integer constant de ne symbolic semantics nite transition system called region graph de ned set symbolic states act succ symbolic state :10.1.1.43.2086
hn tt succ :10.1.1.43.2086
succ formulae readily interpreted states region graph evaluating delay modalities respect succ transitions guards respect regions single time valuations 
cf details 
note developments op 
cit 
deal explicitly apply equally resulting symbolic semantics closely related standard formula clock constraints constants greater region valuation :10.1.1.43.2086
decide holds su cient apply standard model checking algorithm nite region graph built 
sake clarity approach described yields possibly di erent instance untimed model checking problem timed automaton formula 
complexity analyses follow shall need estimate size region graph 
note size jc 
jc 
estimate sizes set states transition relation region graph jsj jn 
jc 
jc act succ jej jn :10.1.1.43.2086
jc 
jc region jf succ gj :10.1.1.43.2086
jc 
interested reader invited consult details 
algorithms regions 
order de ne algorithms operating region graphs shall need basic operations regions 
represent region set clocks means di erence bounded matrix jcj jcj integer matrix smallest integer convention 
simplicity just mention non strict comparisons 
strict comparisons handled similar way 
usually dbms encode convex sets regions 
data structures employed veri cation tools timed systems algorithms dbms de ned 
interested problems building dbm representation set clock constraints see deciding dbm corresponds region deciding clock constraint satis ed region deciding dbm representations region reachable succ transitions computing dbm operations performed polynomial time standard algorithms 
way example limit presenting algorithm deciding succ holds regions rst compute :10.1.1.43.2086
denotes convex set regions reachable succ transitions 
su cient remove upper bounds values clocks constraints done large integer value 

remains check constraint implies corresponding deciding succ done polynomial time verifying region succ :10.1.1.43.2086
deciding 
holds done polynomial time need verify edge guard holds region basic problems complexity analysis determine lower bounds complexity model checking problems shall reduce classic problems complexity known instances model checking problems :10.1.1.43.2086
remainder study shall consider reachability linear bounded turing machines validity quanti ed boolean formulae pspace hardness results reachability linear bounded alternating turing machines exptime hardness results validity propositional formulae conp hardness arguments 
proceed sketch brie sake completeness 
interested reader referred treatment 
linear bounded alternating turing machines 
nondeterministic turing machine quintuple hq nite set states nite alphabet initial state nal state fl rg set transitions :10.1.1.43.2086
con guration triple denotes current control state represents contents tape understanding cell contains symbol viz :10.1.1.43.2086
jth symbol jwj blank symbol denotes current position tape head 
transition say transition enabled con guration case performing leads successor con guration resp 
resp 

input word accepted execution starting initial con guration input leads con guration control state linear bounded turing machine nondeterministic turing machine jwj cells tape decide input accepted 
deciding word accepted pspace complete 
alternating turing machine atm nondeterministic turing machine set states partitioned sets assume loss generality con guration con guration said accepting accepting state exists successor con guration accepting con guration :10.1.1.43.2086
con guration said accepting successor con guration successor con gurations accepting con guration :10.1.1.43.2086
word said accepted accepting con guration 
linear bounded alternating turing machine atm tape head go input markers 
deciding word accepted exptime complete :10.1.1.43.2086
problems logic 
shall validity problem quanti ed boolean formulae qbf known pspace complete 
instance qbf formula form boolean formula set atomic propositions fp negations quanti er belongs ng :10.1.1.43.2086
shall lemma lemma instance qbf :10.1.1.43.2086
valid exists non empty set ffg boolean valuations correctness closure valuation shall validity problem propositional formulae viz :10.1.1.43.2086
propositional formula hold interpretation atomic variables known conp complete problem 
complexity results model checking order formulate prove complexity results follow need de ne size timed automaton ei formula size formula length symbols :10.1.1.43.2086
note formula de nes size guard :10.1.1.43.2086
de ne size jaj timed automaton jn jcj jg considering constants represented unary binary change results explicitly mentioned :10.1.1.43.2086
reachability timed automata embarking analysis complexity model checking sublanguages recall known important result complexity reachability timed automata 
proof statement encoding workings linear bounded turing machine input string means timed automaton repeatedly technical developments follow 
lemma reachability timed automata pspace complete 
proof 
establish membership pspace hardness pspace separately 
pspace membership follow pspace membership reachability problem networks timed automata see theorem 
pspace hardness show acceptance problem reduced polynomial time reachability problem timed automata 
hq nondeterministic linear bounded turing machine 
assume loss generality fa bg 
input word going build polynomial time timed automaton am accepted distinguished node reachable am jw timed automaton am constructed follows 
set nodes am ng :10.1.1.43.2086
intuitively node denotes current state current position tape head 
encode con gurations necessary represent tape contents 
done means appropriate clock valuations 
tape cell clocks values encode content follows contains resp 
resp 

writing resp 
cell consist resetting time resp 
delaying positive amount time ensure value positive resetting 
note encoding tape contents preserved delay transitions 
action set am fs 
transition machine add possible position tape head ng transitions :10.1.1.43.2086
resp 
resp 
fx resp :10.1.1.43.2086
fx resp 
resp 
resp 

need add constraint ensure time sure resetting encode writing cell value clock greater 
extra clock reset transition add constraint guard previously described transitions 
initialization tape input word encoded adding transition init 
fx bg ftg 
detect accepting run add transitions accept clearly node reachable am accepts am obviously built polynomial time proven acceptance problem reduced polynomial time reachability problem timed automata shown 
encoding proof employs comparisons values clocks represent content cell encoding input means timed automaton possible comparisons clocks integer values guards :10.1.1.43.2086
case step simulated transitions timed automaton encoding 
complexity results follow hold 
refer interested reader appendix details alternative encoding 
consider complexity model checking property languages introduced previously 
logics studying complexity model checking logics theorem model checking problem :10.1.1.43.2086
speci cation program complexities model checking exptime complete 
proof 
exptime membership consequence exptime membership model checking networks timed automata see theorem follow :10.1.1.43.2086
exptime hardness er polynomial time reduction acceptance input model checking problem am am timed automaton proof lemma formula encode behaviour input assume loss generality strict alternation states remind reader assume initial nal states states 
approach proposed untimed concurrent systems alternating behaviour handled formula form max accept ff hsi intuitively satis ed am initialization step current state accepting state required subformula accept ff step leading state exists transition leading non accepting state 
am accept negation formula uses xed points express accepting state reachable sequence transitions hs min tt hsi negation uses greatest xed point expressed quanti ers modalities formula allows express alternating form acceptance conditions 
yields model checking problem program complexity claim follows proof model checking formula constructed xed depend speci cation complexity claim consequence lemma follow states model checking problem nil process exptime complete 
proof theorem adapted propositional timed calculus proposed yielding improved lower bound complexity model checking :10.1.1.43.2086
proof show exptime membership model checking networks timed automata see theorem follow mutatis mutandis model checking networks timed automata :10.1.1.43.2086
best knowledge rst precise characterization structural complexity model checking logic 
proceed study computational complexity model checking logic xed point free fragment 
theorem model checking problem pspace complete 
speci cation complexity model checking pspace complete :10.1.1.43.2086
program complexity model checking integer constants timed automata represented unary 
proof 
prove statement turn 
separately establish membership hardness pspace 
pspace membership follow general argument theorem 
pspace hardness instance qbf problem 
er polynomial time reduction validity model checking problem consider timed automaton formula formula ha tt ha tt ha tt tt example considering formula accept tt :10.1.1.43.2086
tt 
resp 
marks resp 
odd states 
sat xn rn fig :10.1.1.43.2086

automaton ha resp 
resp 

consider path 


:10.1.1.43.2086

ta valuation setting clocks 
path action performed time clock reset time reset clock reset :10.1.1.43.2086
path describes valuation atomic propositions convention reset time tt ff 
entails time value sat labelled transition enabled con guration 
claim valid prove hold de ne def ha tt tt 
note establish implications statement separately 
assume valid 
implies exists set boolean valuations satisfying requirements lemma 
establish holds su cient auxiliary lemma proof easy induction lemma valid boolean valuation set boolean valuations satis es requirements lemma :10.1.1.43.2086
timed valuation set clocks fx tg 


resp 
ff resp 
tt 
assume :10.1.1.43.2086
shall show valid 
su cient exhibit collection boolean valuations satisfying conditions lemma 
path ta form :10.1.1.43.2086
say consistent ng :10.1.1.43.2086
particular consistent 
note furthermore consistent path de ned 






consistent clock time valuation 
clock reset st action transition 
clock reset st action transition 

consistent easy see 
follows collection boolean valuations associated set consistent paths ta nonempty requires existence path form satis es correctness closure requirements lemma :10.1.1.43.2086
may conclude valid 
completes proof 
speci cation complexity qbf instance encoded model checking problem form nil formula clocks see lemma follow :10.1.1.43.2086
entails pspace hardness speci cation complexity model checking 
program complexity formula 
de ne algorithm worst case complexity polynomial jaj building pertinent part region graph manner 
key points decide holds timed automaton need consider sequences action transitions action transitions number possible delay transitions region graph bounded jc jkj max polynomial jaj unary :10.1.1.43.2086
algorithm decide holds symbolic state proceeds structural induction formula decide holds form need worst case decide holds :10.1.1.43.2086
decide holds form hai need worst case decide holds 

number bounded jaj 
decide holds form need worst case decide succ holds larger jcj jk max :10.1.1.43.2086
assume represented unary follows number subproblems form succ considered jaj :10.1.1.43.2086
decide holds form need decide decide need verify constraint holds region done constant time size contains clocks disjoint set clocks automaton depth recursive calls algorithm recursive call generates jaj :10.1.1.43.2086
computation recursive call takes time polynomial constant jaj 
follows time complexity aforementioned algorithm jaj xed program complexity note aforementioned proofs lower bounds speci cation complexity model checking xed point free fragment realization model checking problems form nil formula logics considered far nil untimed automaton transition just hard model checking problems arbitrary timed automata :10.1.1.43.2086
shall refer restricted model checking problem nil model checking 
lemma nil model checking problem exptime complete 
nil model checking problem pspace complete 
proof 
nil model checking problem fortiori exptime pspace respectively follows theorems 
proofs relevant lower bounds may appendix light results worst case complexity model checking real time logics considered section may seen deriving solely clocks formulae :10.1.1.43.2086
pattern remain true property languages study follows sbll property languages study apart hai hai sbll enjoy property timed automaton formula possible build formula nil behaviour timed automaton encoded sense formula generally logics allow compositional model checking :10.1.1.43.2086
expressiveness result property languages deduce computational hardness nil model checking problem complexity general model checking problem size exponential 
example proof previous lemma pspace hardness nil model checking problem established formula model checking instance proof theorem :10.1.1.43.2086
note constructs form set formula clocks employed lower bound proofs speci cation complexity model checking logics considered section 
property language property language see section introduced sub language allows cient model checking algorithms :10.1.1.43.2086
best knowledge intention supported precise complexity theoretic considerations 
proceed 
theorem complexity model checking pspace complete 
speci cation program complexities model checking pspace complete 
proof 
pspace membership model checking problem form reduced polynomial time reachability problem parallel composition :10.1.1.43.2086
see general theorem follow 
pspace hardness er linear time reduction reachability problem timed automata pspace complete lemma model checking :10.1.1.43.2086
timed automaton nodes 
build automaton relabelling edges adding new edge hn tt ni 
reachable max ff 
speci cation complexity possible reduce polynomial time instance hm acceptance problem linear bounded nondeterministic turing machines model checking problem form nil means kind encoding see lemma follow :10.1.1.43.2086
program complexity pspace complete formula expressing reachability problem pspace hardness argument depend input automaton 
light result assuming pspace di erent exptime model checking problem lower computational complexity source lower complexity observation model checking problem reduced polynomial time reachability checking timed automata :10.1.1.43.2086
theorem model checking problem conp complete speci cation complexity model checking 
program complexity constants input automata represented unary 
proof 
conp membership see general theorem follow 
conp hardness validity problem propositional formulae reduced polynomial time model checking 
propositional formula set atomic propositions fp consider timed automaton built negation 
claim valid sat ff see hold consider arbitrary path ta form page :10.1.1.43.2086
argue valid con guration satis es formula sat ff 
note con guration reached time possible valuations form fn ng ng depending clocks reset path :10.1.1.43.2086
valid false interpretation deduce valid viz 
constraint values clocks guarding edge node node hold reachable 
sat shown 
similar fashion easy argue valid path ta form con guration perform sat labelled transition :10.1.1.43.2086
sat ff valid :10.1.1.43.2086
speci cation complexity instance validity problem propositional formulae reduced polynomial time model checking problem form nil :10.1.1.43.2086
see lemma follow 
program complexity follows immediately fact program complexity thm 

lemma nil model checking problem pspace complete :10.1.1.43.2086
nil model checking problem conp complete 
proof 
nil model checking problems pspace conp respectively follows theorems 
proofs relevant lower bounds may appendix mapping territory sections shown things model checking problems property languages pspace complete respectively :10.1.1.43.2086
restricted fragment proposed order improve ciency model checking practice natural wonder seemingly ad hoc syntactic restrictions imposed formulae necessary order obtain sublanguage model checking problem pspace 
answer natural question shall consider possible extensions extensions obtained adding constructs language diamond modalities viz 
allowing formulae hai unrestricted disjunction viz 
allowing formulae existential quanti cation delay transitions viz 
allowing formulae 
consider possible extensions turn show leads exptime hard model checking problem 
implies restrictions imposed syntax dropped increasing structural complexity model checking problem :10.1.1.43.2086
adding diamond modalities hai denote property language obtained adding construct hai de ning clauses shall argue proposition complexity model checking problem hai exptime complete program complexity speci cation complexity 
proof 
consider combined program speci cation complexities model checking turn 
complexity model checking hai sublanguage su cient argue complexity model checking problem hai exptime hard 
er polynomial time reduction acceptance input model checking problem am am timed automaton proof lemma hai formula encode behaviour input proof thm 
assume loss generality strict alternation states remind reader assume initial nal states states 
formula cf 
eqn 
page handle alternating behaviour proof theorem replaced contains existential quanti cations delay transitions general disjunction max accept ff hsi note existential quanti cation delay transitions cf 
page may replaced subformula know exactly time unit separates consecutive labelled transitions simulation workings input timed automaton ered proof lemma 
accepts am yields exptime hardness hai model checking 
program complexity formula constructed xed depend exptime hardness program complexity model checking problem follows :10.1.1.43.2086
speci cation complexity see appendix general model checking problem nil model checking problem hai pspace complete :10.1.1.43.2086
follows satisfaction formulae involving action modalities trivially checked nil process 
model checking problem form nil hai reduced time linear size model checking problem form nil formula obtained replacing subformula form hai ff :10.1.1.43.2086
extension restricted diamond formulae form hai tt increase complexity model checking problem remains pspace complete model checking problem formula additionally subformulae form act possible build polynomial time timed automaton formula :10.1.1.43.2086
timed automaton built adding transitions form node fresh action symbol easy see hai tt ff node clock valuation formula built replacing occurrence hai tt act ff :10.1.1.43.2086
fragment hai greatest xed points complexity results proposition model checking problem hai pspace complete :10.1.1.43.2086
speci cation complexity hai model checking pspacecomplete :10.1.1.43.2086
nil model checking problem hai conp complete 
program complexity hai model checking constants input automata represented unary 
proof 
prove statements turn 
hai sublanguage model checking problem hai pspace thm 

establish hardness pspace argue instance qbf reduced polynomial time model checking problem hai instance qbf problem :10.1.1.43.2086
consider timed automaton 
proof thm 
argued valid timed automaton satis es formula ha tt ha tt ha tt tt ha resp :10.1.1.43.2086
resp 

formula hai uses existential delay operator 
note consecutive action transitions separated exactly time unit 
lieu formula consider fresh clock def tt ha resp :10.1.1.43.2086
resp 

valid 
see appendix proof pspace hardness speci cation complexity :10.1.1.43.2086
follows lemma :10.1.1.43.2086
statement immediate corollary theorem adding disjunction denote property language obtained adding construct de ning clauses shall argue proposition complexity nil model checking problem exptime complete speci cation complexity program complexity :10.1.1.43.2086
proof 
see appendix fragment greatest xed points complexity results proposition model checking problem conp complete speci cation complexity nil model checking problem :10.1.1.43.2086
program complexity constants input automata represented unary 
proof :10.1.1.43.2086
algorithm proof conp membership model checking concurrent programs thm 
follow easily adapted nondeterministic polynomial algorithm decide negation formula holds symbolic state 
extend cover su cient add clause case procedure simply checks hold :10.1.1.43.2086
resulting nondeterministic algorithm remains polynomial 
conp hardness nil model checking immediate consequence conp hardness nil model checking lemma 
model checking nil process conp complete speci cation complexity model checking 
characterization program complexity comes theorem adding existential quanti cation delay transitions denote property language obtained adding construct de ning clauses shall argue proposition complexity nil model checking problem exptime complete speci cation complexity program complexity :10.1.1.43.2086
proof appendix fragment greatest xed points complexity results proposition model checking problem pspace complete nil model checking problem speci cation complexity :10.1.1.43.2086
program complexity constants input automata represented unary 
proof 
formula appendix show nil model checking problem pspace hard belongs 
program complexity comes theorem main results mapping territory summarized ease tables :10.1.1.43.2086
interesting note adding hai increases complexity model checking adding 
addition general disjunction increases complexity model checking presence xed points 
table complexity results languages fixed points hai mc spec 
com 
prog 
com 
pspace exptime exptime exptime exptime thm 
propn 
propn 
propn :10.1.1.43.2086
thm :10.1.1.43.2086
nil mc pspace pspace exptime exptime exptime lem 
propn :10.1.1.43.2086
propn :10.1.1.43.2086
lem :10.1.1.43.2086
table complexity results languages fixed points hai mc conp pspace pspace conp pspace spec 
compl 
conp pspace pspace conp pspace prog 
compl 
thm 
propn 
propn :10.1.1.43.2086
propn :10.1.1.43.2086
thm :10.1.1.43.2086
nil mc conp conp pspace conp pspace lem 
lem 
propn 
propn :10.1.1.43.2086
lem :10.1.1.43.2086
property languages sbll model checking problems property languages sbll complexity stated theorem proof similar theorem omitted theorem complexity sbll model checking pspacecomplete :10.1.1.43.2086
speci cation program complexities sbll model checking pspace complete 
property languages sbll obtain result theorem model checking problem sbll pspacecomplete :10.1.1.43.2086
speci cation complexity model checking sbll conp complete 
program complexity model checking property languages sbll pspace complete 
proof 
pspace membership follows general statement theorem 
pspace hardness reachability problem reduced linear time model checking problem sbll 
timed automaton node want reach initial con guration 
build timed automaton replacing transition label adding action transition control node reachable ff 
speci cation complexity fix timed automaton de ne nondeterministic algorithm formula decides time polynomial 
note compute constant time derivatives derivatives symbolic state computation depend clocks formula 
algorithm uses ideas employed proof theorem follow 
hardness result consequence lemma follow showing model checking sbll conp hard timed automaton nil process :10.1.1.43.2086
program complexity previously argued checking timed automaton satis es xed formula ff pspace hard 
attentive reader noticed complexity model checking xed point free versions languages sbll coincides full languages :10.1.1.43.2086
implicit recursion delay transitions hidden semantics sbll operator 
recursion su cient model checking problems sbll pspace hard exploited aforementioned proof hardness result 
nil model checking problems sbll resp 
sbll equivalent nil model checking problem resp 
transition occurs nil process 
free timed automata weak interpretation equivalent strong interpretation 
subformulae form hai tt replaced ff action transition occurs nil process equivalent 
follows lemma lemma nil model checking problem sbll pspace complete :10.1.1.43.2086
nil model checking problem sbll conp complete 
complexity model checking concurrent timed programs practice real time systems contain components modelled parallel compositions timed automata :10.1.1.43.2086
denote model checking concurrent programs problem deciding property holds concurrent timed system viz 
parallel composition timed automata 
untimed setting model checking su ers called state explosion problem presence concurrency characterization complexity model checking problem concurrent programs yield realistic assessment hardness task model checking real time systems 
aim section analysis 
real time concurrent programs 
timed automata assume sets clocks pairwise disjoint 
model real time concurrent program means parallel composition parallel composition operator parameterized synchronization function 
operator generalizes large range existing notions parallel composition 
synchronization function partial function signature act 
act denotes distinguished action symbol 
fact ary synchronization function renaming 
denote 
ja parallel composition 
respect synchronization function network con guration pair vector nodes 
valuation set clocks network 
network con guration write ith node vector restriction set clocks semantics 
ja de ned terms timed labelled transition system states con gurations network transitions rules act :10.1.1.43.2086
ng :10.1.1.43.2086
ng act :10.1.1.43.2086

note second rule stipulates clocks increase synchronously 
synchronization function understood context sim ply write lieu 
ja size sum sizes timed automata size function viz 
number synchronization vectors 
symbolically jaj ja 
ja jf clearly stored space jaj 
possibility forming parallel compositions automata add expressive power model timed automata 

ja possible build product timed automaton strongly bisimilar sense 
ja 
automaton ei 

contains edge act guards reset sets :10.1.1.43.2086

ng tt edge known see size automaton constructed aj untimed case hard prove lemma satisfy exactly formulae decide :10.1.1.43.2086
ja holds formula su cient consider region graph corresponding product timed automaton associated parallel composition :10.1.1.43.2086
ja analysis sect 
:10.1.1.43.2086
max 
recall denotes set formula clocks 
size transition relation region graph viz 
jf 
je jn 
jc 
jc note furthermore size region graph associated product automaton formula viz 
jsj exponential aj sake clarity regions algorithms model checking networks timed automata deal set clocks recall basic operations regions mentioned sect :10.1.1.43.2086
performed polynomial time :10.1.1.43.2086
position study complexity model checking property languages considered previous section concurrent timed systems 
shall see cases concurrency feature increase structural complexity model checking problems 
reachability concurrent timed systems studying complexity reachability problem networks timed automata 
known reachability communicating nite state machines pspace complete 
parallel compositions timed automata obtain result 
theorem node reachability problem concurrent timed systems pspace complete 
proof 
pspace membership 
ja parallel composition timed automata 
node ng :10.1.1.43.2086
deciding reachable initial state region graph associated product automaton determined equivalent reachability timed labelled transition system associated done nondeterministic algorithm builds step step path region graph leading con guration control nodes con guration path exist current state contains answer algorithm guesses con guration path leading :10.1.1.43.2086
region 
veri es polynomial time succ action step need store con gurations 
savitch theorem nondeterminism algorithm inessential 
pspace hardness reachability problem single timed automaton pspace hard see lemma 
model checking sublanguages concurrent timed systems program complexity model checking alternation free calculus untimed concurrent programs exptime complete :10.1.1.43.2086
parallel compositions timed automata fragments obtain results 
theorem model checking problem concurrent timed systems exptime complete :10.1.1.43.2086
proof 
exptime membership approach similar prove exptime membership untimed calculus model checking problem concurrent programs 
previously seen lemma formula :10.1.1.43.2086
ja timed automaton corresponding product 
ja respect speci ed synchronization function 
know untimed automaton region graph associated size exponential ja jf interpreted untimed formula :10.1.1.43.2086
modify slightly adding transitive closure transition relation succ size resulting automaton exponential ja jf step modalities :10.1.1.43.2086
may viewed untimed calculus formula time complexity model checking aj alt alt alternation depth 
clearly alt obtain algorithm exponential ja gives exptime membership exptime hardness model checking problem timed automaton thm :10.1.1.43.2086

theorem model checking problem concurrent timed systems pspace complete :10.1.1.43.2086
proof 
pspace membership nondeterministic model checking algorithm pspace easily de ned considering parts region graph associated 
ja required 
simply adapt algorithm proof thm 

savitch theorem nondeterminism algorithm inessential 
pspace hardness immediate theorem 
theorem model checking problem sbll concurrent timed systems pspace complete :10.1.1.43.2086
proof 
pspace membership property languages instance model checking problem 
ja reduced polynomial time reachability problem :10.1.1.43.2086
ja jt timed automaton jt :10.1.1.43.2086
theorem gives pspace upper bound 
pspace hardness consequence theorem 
theorem model checking problem concurrent timed systems conp complete :10.1.1.43.2086
proof 
conp membership 
ja concurrent timed system formula 
de ne nondeterministic polynomial algorithm region graph associated viz 
product automaton induced decide negation containing existential modalities holds initial symbolic con guration give main cases case procedure rst guesses non deterministically hold proceeds checking case :10.1.1.43.2086
procedure rst veri es holds region proceeds checking 
case 
procedure guesses region reachable sequence delay transitions 
veri es polynomial time succ holds nally checks 
case hai 
procedure guesses con guration holds veri ed polynomial time proceeds checking 
case 
simply proceed checking holds 
note absence xed points entails deciding satis es formula needs consider executions action transitions 
formula algorithm sketched takes steps step complexity polynomial jaj 
conp hardness immediate consequence theorem 
result straightforward corollary pspace membership reachability networks timed automata thm :10.1.1.43.2086
pspace hardness model checking problem sbll thm 
:10.1.1.43.2086
theorem model checking problem sbll concurrent timed systems pspace complete 
results show untimed setting concurrency feature increase structural complexity model checking timed systems 
natural question ask holds true speci cation program complexities 
results speci cation complexity change program considered xed structure matter parallel composition timed automata possible build corresponding product timed automaton time constant size speci cation program complexity model checking respect networks timed automata change sbll sbll program complexity property languages hard timed automaton general model checking problem concurrent timed systems 
program complexity model checking concurrent timed systems np hard conp hard belongs pspace case untimed hennessy milner logic hard see satis ability resp 
validity problem boolean expressions encoded model checking problem formula hai ff resp 
ff parallel composition automata 
program complexity model checking concurrent timed systems conp complete 
conp hardness comes conp membership shown similar arguments proof thm 
formula hold system exists short path number action transitions satisfying verifying done polynomial time 
relationships relative expressive power property languages considered complexity model checking problems summarized :10.1.1.43.2086
means model checking problem reduced linear time equivalent model checking problem :10.1.1.43.2086
discussion follow shall abbreviations sbll sbll pspace exptime conp ls stands expressive fig 
:10.1.1.43.2086
expressiveness vs complexity model checking denote respectively model checking problems clocks allowed automata speci cations clocks allowed speci cations clocks allowed automata 
note speci cation languages studied proof hardness corresponding model checking problem uses formulae clocks cf 
proofs hardness results thms 
:10.1.1.43.2086
implies problems complexity 
results complexity model checking problems form nil show problems complexity exception hai hai complexity model checking depend time added model speci cation 
time highly expressive feature witnessed encodings ered appendix results structural complexity model checking real time concurrent programs match untimed concurrent programs ered 
think kind results taken grain salt claim model checking real time programs just cient ine cient model checking untimed ones practice 
worst case time complexity model checking algorithms untimed speci cation logic calculus interpreted concurrent programs size input :10.1.1.43.2086
hand theoretical algorithms ered model checking logic networks timed automata run time :10.1.1.43.2086
practice big di erence bounds 
secondly importantly complexity model checking real time programs due concomitant factors 
apart known state explosion problem brought concurrency feature deal complexity deriving timing information form clocks comparisons clocks 
research community veri cation technology developed data structures reduced ordered binary decision diagrams variety tech niques see alleviate explosion number control states deriving cooperative concurrency :10.1.1.43.2086
similarly cient data structures developed handle timing information dbms 
development cient data structures techniques handle time timing information state explosion problem far proved elusive 
expect exciting developments line research see 
carsten weise suggested title gave useful suggestions draft extended 
special anders ravn insightful comments thorough proofreading 
philippe schnoebelen discussions complexity model checking 
anonymous referees gave insightful comments spotted inaccuracies original version 
responsibility remaining rests authors 
aceto larsen power reachability testing timed automata proc 
lncs december pp 
:10.1.1.43.2086
aceto larsen model checking reachability testing timed automata proc :10.1.1.43.2086
tacas lncs april pp 
:10.1.1.43.2086
aceto pedersen characteristic formulae timed automata rairo theoretical informatics applications pp :10.1.1.43.2086

aceto model checker time proc 
th int :10.1.1.43.2086
symp 
math 

comp 
sci 
mfcs poland sep vol 
lecture notes computer science springer pp :10.1.1.43.2086
:10.1.1.43.2086
alur techniques automatic veri cation real time systems phd thesis stanford university 
alur courcoubetis dill model checking dense real time information computation pp 
:10.1.1.43.2086
alur dill theory timed automata theoretical computer science pp :10.1.1.43.2086
:10.1.1.43.2086
alur feder henzinger bene ts relaxing journal acm pp 

alur henzinger logics models real time survey proc 
rex workshop real time theory practice de bakker huizing 
de roever rozenberg eds vol 
lecture notes computer science berlin new york springer verlag pp :10.1.1.43.2086

real time logics complexity expressiveness information computation pp 

preliminary version appears proc 
th lics 
really temporal logic journal acm pp 
:10.1.1.43.2086
preliminary version appears proc 
th focs 
andersen model checking boolean graphs theoretical computer science pp :10.1.1.43.2086

partial model checking extended proc 
th annual ieee symposium logic computer science lics la jolla san diego june ieee computer society press pp :10.1.1.43.2086

arnold linear algorithm solve xed point equations transition systems information processing letters pp :10.1.1.43.2086

beer ben david geist methodology system practical formal veri cation reactive hardware dill pp 
:10.1.1.43.2086
behrmann larsen pearson weise yi cient timed reachability analysis clock di erence diagrams proc 
th int 
conf 
computer aided veri cation cav trento italy july vol 
lecture notes computer science springer 
bellman dynamic programming princeton university press 
bengtsson griffioen larsen larsson pettersson yi veri cation audio protocol bus collision uppaal proc 
th 
international conference computer aided veri cation cav alur henzinger eds vol 
lecture notes computer science new brunswick new jersey usa july august springer verlag :10.1.1.43.2086
bidoit finkel petit ph 
schnoebelen systems software veri cation 
model checking techniques tools springer :10.1.1.43.2086
biere cimatti clarke zhu symbolic model checking bdds tools algorithms construction analysis systems tacas cleaveland ed vol :10.1.1.43.2086
lecture notes computer science amsterdam netherlands march springer verlag pp 
:10.1.1.43.2086
bryant graph algorithms boolean function manipulation ieee transactions computers pp :10.1.1.43.2086

chandra kozen stockmeyer alternation journal acm pp :10.1.1.43.2086

hoare ravn calculus durations information processing letters pp :10.1.1.43.2086
:10.1.1.43.2086
clarke emerson design synthesis synchronization skeletons branching time temporal logic proceedings workshop logic programs yorktown heights kozen ed vol :10.1.1.43.2086
lecture notes computer science springer verlag pp 
:10.1.1.43.2086
clarke emerson sistla automatic veri cation nite state concurrent system temporal logic :10.1.1.43.2086
programming languages systems pp 
:10.1.1.43.2086
clarke jha exploiting symmetry temporal logic model checking courcoubetis pp :10.1.1.43.2086
:10.1.1.43.2086
clarke grumberg peled model checking mit press :10.1.1.43.2086
clarke wing formal methods state art directions acm computing surveys pp :10.1.1.43.2086
:10.1.1.43.2086
report working group formal methods acm workshop strategic directions computing research 
cleaveland linear time model checking algorithm modal calculus formal methods systems design pp :10.1.1.43.2086
:10.1.1.43.2086
courcoubetis ed proc 
th 
international workshop computer aided veri cation cav vol 
lecture notes computer science greece june july springer verlag 
courcoubetis yannakakis minimum maximum delay problems real time systems formal methods system design pp :10.1.1.43.2086

schnoebelen complexity propositional linear temporal logics simple cases extended proc :10.1.1.43.2086
th ann 
symp 
theoretical aspects computer science stacs lncs paris france feb springer verlag pp 
:10.1.1.43.2086
dill timing assumptions veri cation nite state concurrent systems proc 
workshop automatic veri cation methods finite state systems grenoble lncs 
dill ed proc 
th 
international conference computer aided veri cation cav vol 
lecture notes computer science california usa june stanford springer verlag 
harel power bounded concurrency finite automata journal acm pp :10.1.1.43.2086

expression complexity modal calculus model checking 
unpublished manuscript november 
emerson jutla sistla model checking fragments calculus courcoubetis pp 

emerson 
lei cient model checking fragments propositional mu calculus proc 
st 
annual symposium logic computer science lics ieee computer society press pp 
:10.1.1.43.2086
harel kupferman vardi complexity verifying concurrent transition systems proc 
th int 
conf 
concurrency theory concur warsaw poland jul vol 
lecture notes computer science springer pp :10.1.1.43.2086
:10.1.1.43.2086
harel lichtenstein pnueli explicit clock temporal logic proceedings fifth annual ieee symposium logic computer science philadelphia pennsylvania june ieee computer society press pp 
:10.1.1.43.2086
hennessy milner algebraic laws nondeterminism concurrency journal acm pp :10.1.1.43.2086

henzinger nicollin sifakis yovine symbolic model checking real time systems information computation pp :10.1.1.43.2086
:10.1.1.43.2086
rabinovich framework decidable metrical logics proc 
th int :10.1.1.43.2086
coll 
automata languages programming icalp prague czech republic july vol 
lecture notes computer science berlin springer verlag pp 
:10.1.1.43.2086
quantitative temporal logic proc 
th int 
workshop computer science logic csl madrid spain sep vol 
lecture notes computer science springer verlag pp 
:10.1.1.43.2086

ho wong toi automated analysis audio control protocol proc 
th 
international conference computer aided veri cation cav wolper ed vol 
lecture notes computer science belgium july springer verlag pp 

larsen static constructs modal process logic lecture notes computer science springer verlag 
deciding winner parity games information processing letters pp 
:10.1.1.43.2086
karp reducibility combinatorial problems complexity computer computations plenum press new york pp :10.1.1.43.2086

kozen lower bounds natural proof systems proceedings th annual symposium foundations computer science ieee pp 
:10.1.1.43.2086
kozen results propositional calculus theoretical computer science pp :10.1.1.43.2086

kupferman vardi wolper automata theoretic approach branching time model checking acm pp :10.1.1.43.2086
:10.1.1.43.2086
larsen compositional model checking real time systems proc :10.1.1.43.2086
th 
international conference concurrency theory concur lee smolka eds vol 
lecture notes computer science philadelphia pa usa august springer verlag :10.1.1.43.2086
cmc tool compositional model checking real time systems proc 
ifip joint int 
conf 
formal description techniques protocol speci cation testing veri cation forte kluwer academic publishers pp 

larsen weise timed automata logic back proc 
th :10.1.1.43.2086
international symposium mathematical foundations computer science mfcs eds vol 
lecture notes computer science prague czech republic august september springer verlag pp :10.1.1.43.2086
:10.1.1.43.2086
ph 
schnoebelen model checking ctl hard proc 
th int 
conf 
foundations software science computation structures fossacs genova italy apr vol :10.1.1.43.2086
lecture notes computer science springer pp :10.1.1.43.2086

ph 
schnoebelen state explosion problem trace bisimulation equivalence proc 
rd int 
conf 
foundations software science computation structures fossacs berlin germany mar apr vol :10.1.1.43.2086
lecture notes computer science springer pp :10.1.1.43.2086
:10.1.1.43.2086
larsen pettersson yi model checking real time systems proceedings th international conference fundamentals computation theory 
ed ed dresden germany august lncs pp 
:10.1.1.43.2086
uppaal nutshell journal software tools technology transfer pp 
:10.1.1.43.2086
lichtenstein pnueli checking nite state concurrent programs satisfy linear speci cation conference record twelfth annual acm symposium principles programming languages new orleans louisiana jan pp 

maler yovine hardware timing veri cation kronos proc 
th israeli conference computer systems software engineering israel june 
papadimitriou computational complexity addison wesley publishing reading ma 
sifakis speci cation veri cation concurrent systems cesar proceedings th international symposium programming vol :10.1.1.43.2086
lecture notes computer science springer verlag pp 

rabinovich complexity equivalence problems concurrent systems nite agents information computation pp 
:10.1.1.43.2086
rabinovich symbolic model checking calculus requires exponential time theoretical computer science pp :10.1.1.43.2086

ramakrishna melliar smith moser dillon kutty interval logics decision procedures 
part ii real time interval logic theoretical computer science pp 

fundamental study 
savitch relationships nondeterministic deterministic tape complexities comput 
system sci pp 
:10.1.1.43.2086
sistla clarke complexity propositional linear temporal logics journal acm pp :10.1.1.43.2086

stockmeyer complexity decision problems automata theory logic tech 
rep mac tr project mac mit cambridge mass 
stockmeyer meyer word problems requiring exponential time preliminary report conference record fifth annual acm symposium theory computing austin texas apr may pp :10.1.1.43.2086

henzinger 
ho wong toi hytech model checker hybrid systems journal software tools technology transfer pp 
:10.1.1.43.2086
tarski lattice theoretical xpoint theorem applications paci journal mathematics 
vardi linear vs branching time complexity theoretic perspective proceedings th annual symposium logic computer science lics pratt ed ieee computer society press :10.1.1.43.2086
vardi wolper reasoning nite computations information computation pp 

th 
wilke specifying timed state sequences powerful decidable logics timed automata formal techniques real time fault tolerant systems langmaack 
de roever eds vol 
lecture notes computer science springer verlag pp 

table building sbll formula ff def ff def alw def alw def alw def alw hai tt def alw hai tt def alw max def alw max yannakakis lee cient algorithm minimizing real time transition systems courcoubetis pp :10.1.1.43.2086
:10.1.1.43.2086
yovine kronos veri cation tool real time systems journal software tools technology transfer pp 
:10.1.1.43.2086
property languages sbll alw formula max new identi er 
intuitively alw holds extended state timed automaton holds reachable transitions 
alw formula max new identi er 
intuitively alw holds extended state holds reachable transitions delay transitions total duration rules table give way building equivalent formula sbll formula example top algorithm lemma timed automaton 
suppose sbll formula formula de ned 
size linear size 
note possible translate sbll formula extension property language formulae form hai tt 
sbll possible translate formula formula timed automaton 
di erence sbll concerns operator def max hai tt complexity nil model checking appendix devoted proofs lower bounds complexity nil model checking problems logics studied section main body :10.1.1.43.2086
proof lemma exptime hardness nil mc show encode behaviour input means 
