low overhead software dynamic translation technical report cs kevin scott jack davidson kevin department computer science university virginia charlottesville virginia cs virginia edu software dynamic translation sdt technology allows programs modified running 
overhead monitoring modifying running program instructions substantial sdt 
result sdt impractically slow especially sdt systems employ dynamic optimization offset overhead 
unfortunate sdt obvious advantages modern computing environments interesting applications sdt continue emerge 
introduce novel overhead reduction techniques improve sdt performance factor dynamic optimization performed 
demonstrate effectiveness overhead reduction techniques show type useful tasks low overhead non optimizing sdt systems put implemented dynamic safety checkers sdt 
dynamic safety checkers perform useful tasks preventing buffer overrun exploits restricting system call usage untrusted binaries 
performance similar cases better state art tools perform functions sdt 
software dynamic translation sdt technology allows programs modified running 
sdt systems virtualize aspects host execution environment interposing layer software program cpu 
software layer mediates program execution dynamically examining translating program instructions run host cpu 
trends research commercial product deployment strongly indicate sdt viable technique delivering adaptable high performance software today rapidly changing heterogeneous networked computing environment 
sdt achieve distinct goals variety research commercial systems 
goals binary translation 
cross platform sdt allows binaries execute non native platforms 
allows existing applications run different hardware originally intended 
binary translation new architectures practical economically viable 
popular sdt systems fall category fx translates ia alpha daisy translates vliw powerpc uqdbt translates ia sparc transmeta code morphing technology translates ia vliw 
goal certain sdt systems improved performance 
dynamic optimization running program offers advantages compile time optimization 
dynamic optimizers light weight execution profile feedback optimize frequent executed hot paths run ning program 
collect profile information program running dynamic optimizers avoid training effect problems suffered static optimizers profiles collected potentially non representative training runs 
furthermore dynamic optimizers continu ally monitor execution program phase transition creates new hot paths 
dynamic optimizers perform profitable optimizations partial ing functions conditional branch elimination expensive perform cally 
sdt systems perform dynamic optimization dynamo optimizes pa risc binaries optimizes ia binaries mojo optimizes ia binaries dbt optimizes pa risc binaries voss eigenmann remote dynamic program optimization system optimizes sparc binaries separate thread optimizer :10.1.1.12.7138
binary translators previously described perform dynamic optimization daisy fx transmeta code morphing technology 
sdt useful technique providing virtualized execution environments 
envi ronments provide framework architecture operating systems experimentation migration applications different operating environments 
advantage sdt application area simulation virtual machine fast sequences virtual machine instructions dynamically translated sequences host machine instructions 
examples application sdt embra virtualizes mips instruction set running irix shade runs sparc virtualizes sparc mips instruction sets vmware virtualizes windows linux plex virtual windows execution linux 
preceding applications sdt benefit reductions dynamic transla tion overhead 
reducing overhead improves application performance allows sdt sys tems implement additional functionality additional optimizations detailed profiling enables uses sdt new application areas 
describe novel tech niques reducing overhead sdt 
strata framework designed building sdt systems performed experiments identify measure sources sdt overhead 
observed sdt overhead stems just sources specifically handling indirect control transfers 
measurements guide implemented novel techniques reducing sdt overhead associated indirect control transfers 
resulting improvement overhead non optimizing sdt averages factor broad range benchmark programs cases completely eliminates overhead non optimizing sdt 
demonstrate low overhead sdt applied new interesting application areas implemented dynamic safety checking applications 
safety checker prevents buffer overflow attacks 
safety checker prevents unauthorized system calls 
safety checkers implemented strata framework designed building effi cient sdt applications 
overhead reduction techniques performance safety checkers similar cases better state art tools perform functions sdt 
important contributions 
show sdt overhead sub reduced careful handling indirect control transfers 
overhead reduction techniques applicable improve performance wide variety sdt sys tems including dynamic optimizers 
second show useful efficient applications built non optimizing sdt overhead reduction techniques 
remainder organized follows 
section briefly describes strata framework 
section discusses sdt overhead 
section discusses sdt safety checkers implemented 
section discusses related section presents summary con 
strata strata infrastructure building software dynamic translators 
realize specific dynamic translator strata basic services extended provide desired functionality 
strata basic services implement simple dynamic translator mediates execution native application binaries visible changes application semantics aggressive attempts optimize application performance 
shows high level architecture strata 
strata provides functionality prior description set retargetable extensible sdt services 
services include memory management fragment cache management application context management dynamic linker fetch decode translate engine 
strata mechanisms gaining control application 
application binary rewritten replace call main call strata entry point 
alternately pro grammer manually initiate strata mediation placing call strata start application 
case entry strata saves application state invokes strata com ponent known fragment builder 
fragment builder takes pc instruction program needs execute instruction pc cached fragment builder begins form sequence code called fragment 
strata attempts frag ments long possible 
strata inlines unconditional pc relative control transfers fragment constructed 
mode operation fragment terminated conditional indirect control transfer instruction strata needs maintain con trol program execution control transfer instruction replaced trampoline arranges return control strata fragment builder 
fragment fully formed placed fragment cache 
transfers control strata application application back strata called context switches see 
context switch strata trampoline cur rent pc looked hash table determine cached fragment corresponding pc 
cached fragment context switch back application occurs 
discussed section context switches large component sdt overhead 

architectures including sparc includes unconditional branches direct procedure calls 

dynamic translator implementor may choose override default behavior terminate fragments instructions conditional indirect control transfers 
software dynamic translation overhead overhead sdt systems degrade system performance substantially 
particu true dynamic translators perform code optimizations offset dynamic translation overhead 
overhead software dynamic translators come time spent ing instructions original program time lost due dynamic translator undoing static optimizations time spent mediating program execution 
cross platform dynamic translators overhead may arise inefficient translations source target instruction sequences 
source overhead concerned focusing native sdt systems source target architectures 
program text 
architecture strata 
context switch context switch cache 
context switch fragment cache characterize overhead sdt conducted series experiments measure sdt systems spend time 
experiments conducted unloaded sun fragment 
strata fragment builder client fetch fetch client translate translate pc mhz ultrasparc ii gb main memory 
basic strata dynamic translator described section experiments 
basic translator optimization 
experiments performed mb fragment cache sufficiently large hold executed fragments benchmarks 
benchmark programs specint compiled sun compiler version aggressive optimizations xo enabled 
resulting binaries executed control strata dynamic translator 
specint training inputs measurement runs 
strata basic mode operation context switch occurs fragment executes 
large portion context switches eliminated linking fragments materialize fragment cache 
instance destinations pc relative conditional branch materialize fragment cache conditional branch trampoline rewritten transfer control directly appropriate fragment cache locations performing context switch control transfer fragment builder 
shows slowdown benchmark programs executed strata fragment linking 
slowdowns relative time execute application directly host cpu 
fragment linking observed large slowdowns average benchmarks 
fragment linking majority context switches due executed conditional branches eliminated 
resulting slowdowns lower impractically high average benchmarks 

benchmarks eon crafty experiments 
chose eliminate programs eon application crafty requires bit supported compiler optimization settings rest benchmarks 
slowdown 
slowdown simple overhead reduction 
bzip cc gap fragment linking gzip majority remaining overhead due presence indirect control transfer instructions 
target indirect control transfer known branch exe strata link fragments indirect control transfers targets 
conse quence fragment indirect control transfer save application context call fragment builder computed branch target address 
likelihood high requested branch target fragment cache builder immediately restore application context executing target fragment 
time reach ing indirect control transfer execution branch target averages cycles sparc platform experiments 
large penalty pay programs execute large numbers indirect control transfer instructions 
sparc indirect control transfers fall categories function call returns indirect branches 
shows number context switches strata due returns indirect branches 
clear mix indirect control trans highly application dependent 
benchmarks gzip parser vpr bzip indirect control transfers executed returns non return indirect branches 
contrast mcf parser perlbmk twolf vortex vpr cc perlbmk gap execute sizeable fraction indirect control transfers returns 
applications contain switch statements sun compiler implements indirect branches jump tables 
remaining applications mcf vortex twolf control transfers returns small portion indirect branches 
percent total switches improve strata overhead gains achieved fragment linking find way reduce latency individual context switches strata reduce number switches due indirect control transfers 
code manages context switch highly tuned hand written assembler language 
signifi cantly reduce execution time code current cycles 
devel oped novel highly effective techniques reducing number context switches forced indirect control transfers 
indirect branch translation caching gzip vpr sw return sw 
causes context switching fragment linking overhead reduction 
cc technique propose reducing number context switches due indirect control transfer indirect branch translation cache ibtc 
ibtc small direct mcf parser perlbmk gap vortex bzip twolf mapped cache maps branch target addresses fragment cache locations 
choose associate ibtc indirect control transfer instruction just non return control transfer instructions 
ibtc respects larger lookup table fragment builder uses locate fragments fragment cache 
ibtc simpler structure consequently faster consult 
ibtc lookup requires instructions inserted directly fragment avoiding full context switch 
inserted code saves portion application context looks computed indirect branch target appropriate ibtc 
branch target matches tag ibtc ibtc hit ibtc entry contains fragment cache address branch target mapped 
partial application context restored control transferred branch target fragment cache 
ibtc hit requires cycles execute order magnitude faster full context switch 
ibtc full context switch formed strata fragment builder invoked 
addition normal action taken context switch address produced replaces old ibtc entry 
subsequent branches location hit ibtc 
shows rates various ibtc sizes 
left chart shows rates non return indirect control transfers handled 
right chart shows rates indirect control transfers handled 
returns included higher volume indirect control transfers result capacity conflict misses push ibtc rate higher 
surprisingly rates higher smaller ibtc sizes 
generally ibtc size exceeds entries improvements rate level programs 
bzip cc 
ibtc rate benchmark 
chart left shows ibtc rate ibtc handles indirect branches 
chart right shows ibtc rate handle indirect branches including returns 
performance benefits ibtc substantial 
white bar shows application slowdowns fragment linking entry handle indirect control transfers including returns results contained dis cussed section 
average slowdown benchmarks signifi cantly better average slowdown observed fragment linking 
expect largest slowdowns observed programs large numbers frequently exe switches perlbmk cc gap 
fast returns gap gzip mcf parser perlbmk ibtc mechanism yields low rates due large percentage executed returns see overhead inserted instructions ibtc lookup han returns significant source application slowdown 
reducing ibtc related head handling returns lower cost method desirable 
twolf vortex vpr eliminate overhead ibtc lookups returns just execute return instruction directly rewriting calls fragment cache return addresses bzip cc gap gzip mcf parser perlbmk twolf vortex vpr slowdown normal text segment return addresses 
return executes jumps proper location fragment cache 
technique safe application modify caller return address executing callee return 
possible write programs modify return address executing return violation sparc abi compilers assembly language programmers avoid 
bar labeled fast returns shows application slowdown fragment linking ibtc fast returns 
average slowdown benchmarks slightly higher slowdowns obtaining ibtc 
reason greater slowdown eliminating return induced context switches context switches indirect branches remain 
applications substantial portion indirect control transfers non returns non return indirect control transfers increase strata overhead significantly 
bzip cc fast returns ibtc fast returns ibtc gap 
strata overhead combinations aggressive overhead reduction techniques 
gzip possible combine fast returns ibtc reduce overhead remedy sit uation 
bar labeled fast returns ibtc shows slowdowns fragment linking fast returns entry non return indirect branches 
slowdowns aver mcf parser perlbmk twolf vortex vpr aging lower fast returns ibtc represent best effort far reducing strata overhead 
shall show section overhead reduction techniques allow implement novel dynamic safety checkers performance significantly bet ter proposed approach safety checking par published approach 
level performance achieved safety checkers simple extensions strata 
software dynamic translation memory overhead addition execution time overhead program run sdt may suffer increased memory utilization 
increased memory utilization due fragment cache dynamic transla tor data memory translator code 
shows increase maximum dent set size application run strata best overhead reduction techniques megabyte fragment cache 
chose maximum resident set size measure memory overhead reflects actual memory patterns executed program 
benchmark applications maximum resident set size increased slightly 
especially cc twolf maximum resident set size increased percent 
applications higher overhead due ibtc lookup instructions frequently executed non return indirect branch trampolines 
modern desktop server systems large memo ries increase memory utilization large relative program strata small relative available memory 
platforms mobile devices smaller available memories increased memory utilization may issue addressed 
increase resident set size applications software dynamic translation demonstrate effectiveness overhead reduction techniques real application domain strata implement different dynamic safety checkers 
preventing buffer overflow attacks bzip cc gap 
increase maximum resident set size benchmark programs run strata fragment cache 
major problem securing computer systems undetected presence buffer overflow software 
buffer overflow vulnerabilities allow malicious entities insert nearly arbitrary code program 
inserted code subsequently executed program ill effect 
popular exploit buffer overflow vulnerabilities called stack smashing attacks buffer overflowed allocated program stack 
attacks typically write sequence instructions stack arrange address inserted code overwrite return address stack 
accomplished passing carefully crafted source buffer function strcpy check see stack resident destination buffer sufficiently large hold source buffer 
gzip mcf parser perlbmk twolf vortex vpr attacked function returns transferring control caller mali code executed 
consequences buffer overflow vulnerabilities usually ous affected program privileged circumstance allows attacker gain privileged access machine resources 
implementing strata dynamic translator eliminates buffer overrun exploits requiring access source trivial 
simply extend fetch routine fetch decode trans late engine see compare pc fetched instructions current stack heap boundaries pc inside stack heap regions buffer overflowed program verge executing malicious code 
point simple matter strata terminate application perform appropriate action 
strata dynamic translator prevent buffer overflow exploits progress doubt useful 
run time overhead tool excessively high appli technique real systems may limited 
particular translator trivial extension strata performs code improving transformations head technique nearly overhead base strata system 
shows slowdown safety checker applications 
column labeled base shows slowdown base strata best overhead reduction settings entry non return control transfers fast returns fragment linking 
column labeled buffer shows slowdown strata buffer overflow detection tool 
slowdown safety checker averages benchmarks 
slowdown significantly lower cowan pu technique equivalent power tool 
locating keeping track stack heap boundaries program execution simple matter systems 
averages slowdowns synthetic microbenchmarks 
safety checker compares favorably singh 
report slow downs 
technique substantially complex simple exten sions strata 
preventing unauthorized system calls second strata safety checker implemented prevents unauthorized system calls untrusted binaries 
safety checkers increasingly important era ubiquitous net working binary downloaded untrusted sources executed 
binary programs may potentially contain code malicious sys tem resources execution system calls 
fact programs containing buffer overflow fall category buffer overflow exploits execute unauthorized system calls 
slowdown bzip cc gap base buffer syscall gzip 
slowdown strata dynamic translators 
bar labeled base slowdown base strata system best overhead reduction 
bar labeled buffer slowdown buffer overflow monitor best overhead reduction 
bar labeled syscall slowdown system call monitor best overhead reduction 
mcf parser perlbmk twolf vortex vpr strata implement dynamic translator enforces predefined system call utilization policy 
example policy may specify untrusted program may open network sockets may write particular file descriptors may perform exec 
buffer overflow safety checker policy enforcement easily accomplished strata simple modification translation facility fetch decode translation engine 
translator inserts code system call checks system call parameters ence policy 
policy violated offending system call executed pro gram may terminated appropriate action taken 
case buffer overflow safety checker overhead system call policy safety checker excessively high applicability technique real systems may limited 
column labeled syscall shows slowdown system call policy safety checker 
policy enforced safety checker application may perform system call 
policy sufficiently powerful prevent known stack smashing attacks privileged solaris programs 
aggressive overhead reduction techniques place slowdowns safety checker averages 
software dynamic safety checking compares favorably complexity overhead existing techniques equivalent power 
related overhead major issue sdt systems number overhead reduction techniques previously discussed literature 
example shade simulator embra emulator technique called chaining link cache resident code frag ments bypass translation lookups 
technique identical strata fragment linking simple effective overhead reduction technique 
different approach dynamic optimizer proposed voss eigenmann 
dynamic optimizer achieves low overhead multiprocessors running dynamic optimizer concurrently application different cpu 
disadvantage approach requirement second cpu run optimizer thread 
overhead approach evaluated single microbenchmark 
overheads realistic benchmarks published 
strata indirect branches cause difficulties dynamic optimizers 
consequently dynamo dbt oracle convert indirect branches chains conditional branches improve program performance 
chains conditional branches sense simple cache indirect branch targets 
eliminate context switches ibtc conditional branch chains remove indirect branch penalties increase available ilp permit ting speculative execution 
conditional branch chains kept relatively short maintain increases performance indirect branch typically terminates conditional branch chain handle case conditional branch comparisons match branch target address 
case programs containing switch statements large num bers frequently executed cases cc perlbmk conditional branch comparisons frequently match branch target address resulting context switch 
strata ibtc addresses problem accommodating large number indirect branch targets indi rect branch 
approach fewer context switches performed approach yields superior pipeline performance branch target conditional branch chain 
researchers studied problem buffer overrun vulnerabilities general problem restricting application resource utilization 
evans pro posed technique statically detecting buffer overrun vulnerabilities analysis source code 
approach obvious advantage run time overhead 
approach require program source 
static analyzers detect possible buffer overrun vulnerabilities problem undecidable 
strata buffer overflow safety checker hand require program source code prevents buffer overflow exploits 
cowan proposed techniques dynamically eliminating stack smashing attacks detecting malicious alterations function return addresses preventing malicious alterations 
stackguard technique eliminate stack smashing attacks specially modified compiler uses alternate procedure calling convention 
contrast strata buffer overflow safety checker require source code elimi stack smashing attacks 
overhead stackguard appears lower strata buffer overflow safety checker 
overhead tools low practi cal powerful technique completely eliminates stack smashing ties os facilities write protect procedure return addresses procedure tions 
approach incurs substantial overheads yielding orders magnitude slowdowns program execution 
contrast safety checker significantly lower overhead preventive power 
library prevents stack smashing attacks dynamically maintaining stack called canary words parallel normal procedure activation stack 
procedure returns canary word parallel stack compared canary word activation stack 
different system concludes buffer overflow occurred 
library employs dynamic translation insert code implement parallel stack canary word comparisons program load time 
overhead reported 
overhead strata buffer overflow safety checker slightly higher prevents class buffer overflow exploits 
implementation buffer overflow safety checker complex requiring lines code implement strata opposed hun lines 
janus project proposed sand boxing technique enforces predefined system call utilization policy 
system calls dynamically intercepted os system call trace facility 
system transparent performs sand boxing low overhead 
report lower overheads strata safety checkers 
achieve low overhead system refrains monitoring frequently executed system calls write 
furthermore rely nonstandard low overhead system call tracing facility 
contrast strata system call policy safety checker rely special os system call tracing facilities incurs additional performance penalty monitoring frequently executed system calls 
summary software dynamic translation continues play significant role modern systems techniques improve performance sdt useful 
dem techniques improve performance sdt systems 
tech niques particularly effective systems perform dynamic optimization 
overhead reduction techniques reduce penalties associated indirect control transfer handling sdt systems 
technique indirect branch translation cache ibtc allows reduce cost determining indirect control transfer fragment cache location orders magnitude 
resulting improvement overhead averages factor 
technique fast returns completely eliminates overhead associated indirect control transfers return function calls 
techniques combined overhead reduced average factor benchmarks studied cases sdt overhead com pletely eliminated 
low overhead non optimizing sdt systems may enable practical sdt technology new areas 
demonstrate strata sdt framework implement safety checkers perform useful functions 
safety checker prevents buffer overflow attacks second prevents untrusted binaries making system calls 
safety checkers implemented strata dozen lines code 
overhead reduction techniques safety checkers achieved performance compa superior state art safety checkers sdt 
plex 
www plex org 
solaris eject buffer overrun exploit 
www insecure org solaris eject html 
solaris buffer overrun exploit 
www insecure org solaris html 
bala evelyn duesterwald sanjeev banerjia 
dynamo transparent dynamic optimization system 
sigplan conference programming language design implementation pages 
singh timothy tsai 
transparent run time defense stack smashing attacks 
proceedings usenix annual technical conference june 
wen ke chen lerner david 
mojo dynamic optimization system 
proceedings acm workshop feedback directed dynamic optimization 
anton chernoff mark ray chris reeve norman rubin tony bharadwaj john yates 
fx profile directed binary translator 
ieee micro april 
hot chips ix stanford university stanford california august 
bob cmelik david keppel 
shade fast instruction set simulator execution profiling 
proceedings acm sigmetrics conference measurement modeling computer systems pages may 
crispin cowan calton pu dave maier heather hinton peat steve beattie aaron perry wagle qian zhang 
stackguard automatic adaptive detection prevention buffer overflow attacks 
proceedings usenix security symposium 
david 
transmeta crusoe cool chips mobile computing 
ieee editor hot chips stanford university stanford california august spring street suite silver spring md usa 
ieee computer society press 
evelyn duesterwald bala 
software profiling hot path prediction 
proceedings th conference architectural support programming languages operating systems pages november 
ebcioglu altman 
optimizations oracle parallelism dynamic translation 
pages 
kemal ebcioglu erik altman 
daisy dynamic compilation architectural compatibility 
th annual international symposium computer architecture pages 
ian goldberg david wagner randi thomas eric brewer 
secure environment untrusted helper applications confining hacker 
proceedings usenix security symposium 
david david evans 
statically detecting buffer overflow vulnerabilities 
proceedings usenix security symposium 
mendel rosenblum 
vmware virtual platform virtual machine monitor commodity pcs 
ieee editor hot chips stanford university stanford california august spring street suite silver spring md usa 
ieee computer society press 
amitabh srivastava andrew edwards vo 
binary translation distributed environment 
technical report msr tr microsoft research april 
standard performance evaluation 
spec cpu benchmarks 
www org osg cpu 
david ung cristina cifuentes 
machine adaptable dynamic binary translation 
proceedings acm workshop dynamic optimization dynamo 
michael voss rudolf eigenmann 
framework remote dynamic program optimization 
proceedings acm workshop dynamic optimization dynamo 
david weaver tom 
sparc architecture manual version 
prentice hall ptr upper saddle river nj usa 
witchel mendel rosenblum 
embra fast flexible machine simulation 
proceedings acm sigmetrics international conference measurement modeling computer systems pages may 

