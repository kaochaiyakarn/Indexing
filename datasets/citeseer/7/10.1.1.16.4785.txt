kademlia peer peer information system xor metric describe peer peer system provable consistency performance fault prone environment 
system routes queries locates nodes novel xor metric topology simplifies algorithm facilitates proof 
topology property message exchanged conveys reinforces useful contact information 
system exploits information send parallel asynchronous query messages tolerate node failures imposing timeout delays users 
describes kademlia peer peer key value storage lookup system 
kademlia number desirable features simultaneously offered previous peer peer system 
minimizes number configuration messages nodes send learn 
configuration information spreads automatically side effect key lookups 
nodes knowledge flexibility route queries low latency paths 
kademlia uses parallel asynchronous queries avoid timeout delays failed nodes 
algorithm nodes record existence resists certain basic denial service attacks 
important properties kademlia formally proven weak assumptions uptime distributions assumptions research partially supported national science foundation ccr ccr 
maymounkov david mazi res dm cs nyu edu kademlia scs cs nyu edu validate measurements existing peer topeer systems 
kademlia takes basic approach peerto peer systems 
keys opaque bit quantities sha hash larger data 
participating computers node id bit key space 
key value pairs stored nodes ids close key notion closeness 
node id routing algorithm lets locate servers near destination key 
kademlia benefits result novel xor metric distance points key space 
xor symmetric allowing kademlia participants receive lookup queries precisely distribution nodes contained routing tables 
property systems chord learn useful routing information queries receive 
worse asymmetry chord metric chord routing tables rigid 
entry chord node finger table store precise node proceeding interval id space node interval greater keys interval far key 
kademlia contrast send query node interval allowing select routes latency send parallel asynchronous queries 
locate nodes near particular id kademlia uses single routing algorithm start finish 
contrast systems algorithm get near target id hops 
existing systems kademlia resembles pastry phase described way authors successively finds nodes roughly half far target id kademlia xor metric :10.1.1.28.5987
second phase pastry switches distance metrics numeric difference ids 
uses second numeric difference metric replication 
unfortunately nodes close second metric quite far creating discontinuities particular node id values reducing performance frustrating attempts formal analysis worst case behavior 
system description kademlia node bit node id node ids constructed chord simplify assume machines just choose random bit identifier joining system 
message node transmits includes node id permitting recipient record sender existence necessary 
keys bit identifiers 
publish find key value pairs kademlia relies notion distance identifiers 
bit identifiers kademlia defines distance bitwise exclusive xor interpreted integer note xor valid albeit non euclidean metric 
obvious 
xor offers triangle property 
triangle property follows fact chord clockwise circle metric xor unidirectional 
point distance exactly point 
ensures lookups key converge path regardless originating node 
caching key value pairs lookup path alleviates hot spots 
pastry chord xor topology symmetric 
node state kademlia nodes store contact information route query messages 
node keeps list ip address udp port node id triples nodes distance 
call probability remaining online hour function uptime 
axis represents minutes 
axis shows fraction nodes stayed online minutes stayed online minutes 
lists buckets 
bucket kept sorted time seen seen node head seen tail 
small values buckets generally empty appropriate nodes exist 
large values lists grow size system wide replication parameter 
chosen nodes fail hour example 
kademlia node receives message request reply node updates appropriate bucket sender node id sending node exists recipient recipient moves tail list 
node appropriate bucket bucket fewer entries recipient just inserts new sender tail list 
appropriate bucket full recipient pings bucket seen node decide 
seen node fails respond evicted bucket new sender inserted tail 
seen node responds moved tail list new sender contact discarded 
buckets effectively implement seen eviction policy live nodes removed list 
preference old contacts driven analysis gnutella trace data collected saroiu 
shows percentage gnutella nodes stay online hour function current uptime 
longer node remain hour 
keeping oldest live contacts buckets maximize probability nodes contain remain online 
second benefit buckets provide resistance certain dos attacks 
flush nodes routing state flooding system new nodes 
kademlia nodes insert new nodes buckets old nodes leave system 
kademlia protocol kademlia protocol consists rpcs ping store find node find value 
ping rpc probes node see online 
store instructs node store key value pair retrieval 
find node takes bit id argument 
recipient rpc returns ip address udp port node id triples nodes knows closest target id triples come single bucket may come multiple buckets closest bucket full 
case rpc recipient return items fewer nodes buckets combined case returns node knows 
find value behaves find node returning ip address udp port node id triples exception 
rpc recipient received store rpc key just returns stored value 
rpcs recipient echo bit random rpc id provides resistance address forgery 
pings piggy backed rpc replies rpc recipient obtain additional assurance sender network address 
important procedure kademlia participant perform locate closest nodes node id call procedure node lookup 
kademlia employs recursive algorithm node lookups 
lookup initiator starts picking nodes closest non empty bucket bucket fewer entries just takes closest nodes knows 
initiator sends parallel asynchronous find node rpcs nodes chosen 
system wide concurrency parameter 
recursive step initiator resends find node nodes learned previous rpcs 
recursion previous rpcs returned 
nodes initiator heard closest target picks queried resends find node rpc 
nodes fail respond quickly removed consideration respond 
round find nodes fails return node closer closest seen initiator resends find node closest nodes queried 
lookup terminates initiator queried gotten responses closest nodes seen 
lookup algorithm resembles chord terms message cost latency detecting failed nodes 
kademlia route lower latency flexibility choosing nodes forward request 
operations implemented terms lookup procedure 
store key value pair participant locates closest nodes key sends store rpcs 
additionally node re publishes key value pairs hour 
ensures persistence show proof sketch key value pair high probability 
generally require original publishers key value pair republish hours 
key value pairs expire hours original publishing order limit stale information system 
order sustain consistency publishing searching life cycle key value pair require node observes new node closer key value pairs replicates pairs removing database 
find key value pair node starts performing lookup find nodes ids closest key 
value lookups find value find node rpcs 
proce bucket entries find replies augmented round trip time estimates selecting nodes 
optimized require far fewer messages description scope 
dure halts immediately node returns value 
caching purposes lookup succeeds requesting node stores key value pair closest node observed key return value 
topology searches key hit cached entries querying closest node 
times high popularity certain key system caching nodes 
avoid caching expiration time key value pair node database exponentially inversely proportional number nodes current node node id closest key id simple lru eviction result similar lifetime distribution natural way choosing cache size nodes priori knowledge values system store 
buckets generally kept constantly fresh due traffic requests traveling nodes 
avoid pathological cases traffic exists node refreshes bucket range performed node lookup hour 
refreshing means picking random id bucket range performing node search id join network node contact participating node inserts appropriate bucket 
performs node lookup node id refreshes away closest neighbor 
refreshes populates buckets inserts nodes buckets necessary 
sketch proof demonstrate proper function system need prove operations take log time small constant key value lookup returns key stored system overwhelming probability 
start definitions 
bucket covering distance range define index bucket define depth number inferred bucket structure current node 
node smallest index non empty bucket 
define node bucket height node index bucket insert minus index significant empty bucket 
node ids randomly chosen follows highly non uniform distributions 
overwhelming probability height node constant log system nodes 
bucket height closest node id kth closest node constant log step assume invariant bucket node contains contact node exists appropriate range 
assumption show node lookup procedure correct takes logarithmic time 
suppose closest node target id depth node significant buckets empty lookup procedure find node half close distance bit shorter step turn node log steps 
node buckets empty case target node resides range empty bucket 
case final steps decrease distance half 
search proceed exactly bit key corresponding empty bucket flipped 
lookup algorithm return closest node log steps 
closest node concurrency switches number steps find remaining closest nodes bucket height closest node kth closest node constant plus log prove correctness invariant consider effects bucket refreshing invariant holds 
refreshed bucket contain valid nodes contain node range fewer exist 
follows correctness node lookup procedure 
new nodes join inserted buckets full 
way violate invariant exist nodes range particular bucket contained bucket fail intervening lookups refreshes 
precisely chosen probability simultaneous failure hour maximum refresh time small 
practice probability failure smaller probability nodes leaving hour incoming outgoing request updates nodes buckets 
results symmetry xor metric ids nodes node communicates incoming outgoing request distributed exactly compatibly node bucket ranges 
invariant fail single bucket single node affect running time adding hop lookups correctness node lookups 
lookup fail nodes lookup path lose nodes bucket intervening lookups refreshes 
different nodes buckets overlap happens probability 
nodes appearing multiple nodes buckets longer lower probability failure 
look key value pair recovery 
key value pair published populated nodes closest key 
re published hour 
new nodes reliable probability lasting hour hour key value pair nodes closest key probability property violated insertion new nodes close key soon nodes inserted contact closest nodes order fill buckets receive nearby key value pairs store 
course closest nodes key fail key value pair cached kademlia lose pair 
discussion xor topology routing resembles step routing algorithms pastry tapestry plaxton distributed search algorithm 
run problems choose approach target node bits time acceleration purposes 
xor topology need additional algorithmic structure discovering target nodes share prefix differ bit digit 
algorithms resolve problem different ways drawbacks require secondary routing tables size addition main tables size log 
increases cost bootstrapping maintenance complicates protocols pastry tapestry prevents formal analysis correctness consistency 
plaxton proof system geared highly faulty environments peer topeer networks 
kademlia contrast easily optimized base 
configure bucket table approach target bits hop 
requires having bucket range nodes distance amounts expected log buckets actual entries 
implementation currently uses 
summary novel xor metric topology kademlia peer peer system combine provable consistency performance routing symmetric unidirectional topology 
kademlia furthermore introduces concurrency parameter lets people trade constant factor bandwidth asynchronous hop selection delay free fault recovery 
kademlia peer peer system exploit fact node failures inversely related uptime 
rowstron druschel 
pastry scalable distributed object location routing large scale peer peer systems 
accepted middleware 
research microsoft com pastry 
ben zhao john kubiatowicz anthony joseph 
tapestry infrastructure fault tolerant wide area location routing 
technical report ucb csd berkeley april 
andr richa greg plaxton rajaraman 
accessing nearby copies replicated objects distributed environment 
proceedings acm spaa pages june 
stefan saroiu krishna gummadi steven gribble 
measurement study peer peer file sharing systems 
technical report uw cse university washington department computer science engineering july 
ion stoica robert morris david karger frans kaashoek hari balakrishnan 
chord scalable peer peer lookup service internet applications 
proceedings acm sigcomm conference san diego california august 

