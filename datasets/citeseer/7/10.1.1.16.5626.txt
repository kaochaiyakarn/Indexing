generic components state machines johannes tuwien ac tuv december technical university vienna information systems institute distributed systems department various architectural design styles state transition mechanisms state transition diagrams state transition tables statecharts development process software systems 
example finite state machines fsms graphical counterpart state transition diagrams heavily specification various kinds protocols network protocols tcp ip protocols infrared data transmission irda 
introducing generic components state machines supposed raise level abstraction hard coded control flow decisions switch case statements flexible implementation model control flow 
design pattern developed thesis expected allow statecharts specification design reactive system behavior provide advanced statechart features implementation level 
statecharts developed david harel extend state transition diagrams notion hierarchy concurrency bringing major simplification system complexity increases 
equally important aspect homogenous application statechart features specification design implementation process issue providing state machine engine 
idea provide state transition information higher level basic conditional language statements simplify system understanding enhancement maintenance 
case state machine engine processes high level data implements correct system behavior 
design pattern introduced thesis consists independent approaches approach extends existing object oriented design pattern called state enable statechart features 
state pattern alexander ran ran model states classes 
second approach table transition information defined table generic state machine engine processes table 
thesis shows possible statecharts advanced mechanisms specification implementation reactive systems simultaneously raising level abstraction source code object oriented table means 
furthermore table approach shows certain degree genericity flexibility reached major losses efficiency design implementation generic components 
keywords state machine state machine engine statechart design pattern fl distributed systems department technical university vienna 
vienna austria phone fax url www tuwien ac master thesis generic components state machines carried information systems institute technical university vienna guidance univ prof dipl ing 
dr techn 
mehdi jazayeri univ ass 
dipl ing 
georg contributing advisor responsible johannes nr 
ii parents johannes iii author georg mehdi jazayeri stimulating discussions topics covered thesis 
georg rene reading drafts thesis commenting 
master thesis mainly consists results originating european union research project esprit iv ares architectural reasoning embedded systems 
ares colleagues various contributions 
information systems institute distributed systems department technical university vienna provided fruitful environment studies 
iv table contents 
iii table contents 
iv abbreviations 
vi table figures 
vi list tables vii 
viii problem description motivation problem definition proposed solution organization thesis review state art implementation state machines grail state machine implementation smalltalk moods models object oriented design state architectural design styles state transition techniques state architectures object oriented architectures feedback control architectures real time architectures approaches statecharts mate sdl basic techniques available software components generic programming fsms state transition diagrams david harel visual formalism statecharts design patterns state design pattern related techniques state machine engine extended state design pattern history generic state machine engine tv set example requirements state design pattern processing statecharts extended state harel state approach hs applying hs tv set control example depth orthogonality broadcast communication generic harel state machine engine approach hsme applying hsme tv set control example depth orthogonality broadcast communication code framework evaluation evaluation comparison state machine versions evaluation hs pattern benefits shortcomings evaluation hsme pattern benefits shortcomings selection criteria hs hsme evaluation current hs hsme implementations summary appendix state machine versions appendix version appendix version appendix version appendix version appendix version appendix version appendix version vi abbreviations case computer aided software engineering dfa deterministic finite automaton es extended state fsm finite state machine hs harel state hsme harel state machine engine loc lines code omt object modeling technique oo object oriented ooa object oriented analysis sdl specification description language sm state machine stl standard template library table figures state transition diagram 
simple tv set example state transition diagram 
statechart examples 
simple tv set example statechart 
state member relation ran 
relation state machine engine state machine specification 
tv remote control 
tv set control application statechart 
tv set class diagram 
vii list tables table external internal tv set system events 
table augmented tv set state transition table part 
table augmented tv set state transition table part ii 
table requirements state design pattern processing statecharts 
table quantitative comparison state machine versions 
table qualitative comparison sm versions hs hsme 
table requirements checklist current pattern implementations 
viii various architectural design styles state transition mechanisms state transition diagrams state transition tables statecharts development process software systems 
example finite state machines fsms graphical counterpart state transition diagrams heavily specification various kinds protocols network protocols tcp ip protocols infrared data transmission irda 
introducing generic components state machines supposed raise level abstraction hard coded control flow decisions switch case statements flexible implementation model control flow 
design pattern developed thesis expected allow statecharts specification design reactive system behavior provide advanced statechart features implementation level 
statecharts developed david harel harel extend state transition diagrams notion hierarchy concurrency bringing major simplification system complexity increases 
equally important aspect homogenous application statechart features specification design implementation process issue providing state machine engine 
idea provide state transition information higher level basic conditional language statements simplify system understanding enhancement maintenance 
case state machine engine processes highlevel data implements correct system behavior 
design pattern introduced thesis consists independent approaches approach extends existing object oriented design pattern called state enable statechart features 
state pattern alexander ran ran model states classes 
second approach table transition information defined table generic state machine engine processes table 
thesis shows possible statecharts advanced mechanisms specification implementation reactive systems simultaneously raising level abstraction source code object oriented table means 
furthermore table approach shows certain degree genericity flexibility reached major losses efficiency design implementation generic components 
problem description problem description chapter introduces basic ideas concepts related problem gives motivation approach carried master thesis 
description specific problem outlook solution overview chapter structure provided 
component programming software engineering approach standard software components software engineering process advance line development component development jazayeri 
engineering disciplines standard components design build artifacts 
example house prefabricated parts assembled significantly faster building house bricks 
prefabricated parts build physical units logical ones interfaces parts clear comprehensible simple rules followed assemble order get building 
software industry aims approach solve basic productivity quality problems development process software systems parnas meyer ngt 
objective scientific founded technique decompose software design set components provide components component catalog 
component catalogs components selected implement design 
component programming expected reduce software development time decreasing number code lines written increasing productivity 
fewer code lines component oriented programming style quality expected improved leading better maintainability understandable code 
software component component catalog intended reuse issues important component programming paradigm cb cl krueger meyer 
components built strict rules guarantee flexible generic behavior 
generally applicable usable contexts software environments components generic possible 
genericity concept tries build components assumptions possible environment extensively reused changing software environments ms ms 
standard template library stl shall serve example generic component catalog ls :10.1.1.108.7776
created alexander stepanov meng lee stl consists set components divided categories containers algorithms iterators 
containers store data items arbitrary types problem description algorithms provided designed order arbitrary containers concept iterators 
essential implementation stl template mechanism stroustrup serve major vehicle thesis 
second concept approach thesis finite state machines graphical representation state transition diagrams 
swiss mathematician euler graphs visual formalism harel 
graphs defined set points nodes connected edges arcs 
state transition diagrams graphs nodes represent states directed arcs represent states changes caused events 
nodes called states arcs transitions 
state transition diagram graphical representation finite state machine abbr 
fsm mathematical definition fsm see section hu 
fsm consists set states state transition function relates events event set current state get new state 
process visually corresponding state transition diagram 
example state transition diagram see page 
specification order events state machines known wide spread technique specification phase software systems 
various software architecture styles state transition diagrams specify dynamic course events statically specified scenario example sg 
diagrams possible execute model system simulating events environment watching behavior system basis diagrams 
actions associated states transitions description algorithm obtained 
state machine describes behavior system steps taken generate corresponding programming language code automatically 
process parsing high level specification language generate code certain programming language called automatic program synthesis 
code generation process trivial code generated meet efficiency constraints subject extensive optimization harel 
harel visual formalism statecharts described specify dynamic course events statically specified scenario 
statecharts extension state diagrams graphical representation finite state machines 
states grouped substates superstate notion depth modularization achieved 
important linear growing system number states grows exponentially handling states gets tedious error prone 
superstate substate concurrently active 
extension called orthogonality 
directed arcs states labeled events meaning occurrence event causes state transition source destination state corresponding arc state transitions blocked conditions transition takes place condition evaluates true 
state transition takes place possible generate internal events 
external events cause problem description state transitions components relevant broadcast mechanism internal events reported components inside statechart possibly causing state transitions 
statecharts basically state diagrams including depth orthogonality broadcast communication 
ran techniques model states classes introduced 
commonly object oriented languages offer sufficient support modeling states behavior 
especially state polymorphism implicit method selection object state supported 
ran suggests model different states certain cases behavior state classes define state dependent methods 
state classes grouped clusters represented clients single class cluster deputy 
mechanism state dependent dispatch allows instances cluster deputy exhibit state dependent behavior transparently calling method state class represents current state 
introducing basic paradigms concepts thesis focused section discusses relevance approach thesis 
section gives detailed comprehensive problem description 
motivation various architectural design styles state transition mechanisms state transition diagrams state transition tables statecharts known development process software systems shaw 
finite state machines state transition diagrams intensively specify various kinds protocols example network protocols tcp ip protocols infrared data transmission irda 
sdl specification description language st state machines specified higher level abstraction specification language compiled source code 
example nokia telecommunications uses sdl derivative sdl dx telephone switching system 
philips uses low level coded state machines implementing user interfaces embedded systems audio video devices 
thesis aims raise level abstraction software view generic components state machines 
wide spread state transition techniques practice serves motivation 
problem description problem definition described statecharts state diagrams mechanisms depth orthogonality broadcast communication 
number states system grows exponentially system grows linearly statecharts powerful tool specifying dynamic behavior reactive systems 
statecharts tool visualization clear mathematical formalism harel graphical concept statecharts called visual formalism 
stated state diagram visual counterpart finite state machine 
implement dynamic behavior system programmers hard code finite state machines large multipart conditional statements statements switch case 
implementation done way advanced mechanisms statecharts depth orthogonality broadcast communication directly transferred code level lack built language features 
chapter ll introduce design pattern overcome problems 
design pattern solve recurring problems software development process ghjv 
ll define pattern called extended state integrates software development approaches including david harel visual formalism statecharts specify dynamic system behavior hg harel harel alexander ran techniques model states classes ran ran generic state machine engines 
resulting software components expected raise level abstraction software view hard coded control flow decisions higher level program behavior specification 
pattern expected generic approach software components developed thesis generally applicable assumptions possible environment extensively reused changing software environments 
obviously genericity implies efficiency 
useful practice important generic approaches efficient conventional solutions 
consequently efficiency important aspect proposed approach 
suggested design pattern allow statecharts graphical representation provide advanced statechart features implementation level 
important homogenous application statechart features specification design implementation process issue providing state machine engine 
idea provide state transition information higher level basic conditional language statements simplify system understanding reactive systems characterized event driven continuously having react external internal stimuli hp 
efficient means efficiencies differ magnitudes 
problem description enhancement maintenance 
state machine engine processes high level data implements correct system behavior 
proposed solution extended state design pattern chapter suggests approaches allow statecharts graphical representation provide advanced statechart features implementation level 
approach state machine engine implicitly contained state cluster transition information explicitly single state class methods 
second approach table transition information table explicit state machine engine processes table 
organization thesis chapter reviews state art implementing state machines diagrams statecharts software development process code generation 
chapter gives detailed description concepts paradigms methods influenced approach thesis component generic programming state machines statecharts fundamentals design patterns concrete state transition related pattern 
chapter describes history generic state machine engine implementation presents example reactive system introduces extended state pattern describes pattern parts harel state hs generic harel state machine engine hsme applying example 
chapter results evaluated selection criteria pattern parts provided possibilities area research discussed 
chapter summarizes results draws final 
review state art review state art introducing basic techniques available section state art discussed including implementation approaches state machines state transition techniques analysis design approaches statecharts sdl 
implementation state machines grail grail library automata expressions rw 
implements finite state machines templates 
grail fsm class fm parametrized type characters input alphabet 
declaration fm fsm yields finite state machine fsm provided input symbols character type 
build transition function inside fm class user call special method add called instructions consist source state label sink state 
finite automaton accepts words regular grammar fm class provides method takes word input alphabet characters labels tests word part language defined finite automaton 
grail tool experimenting regular expressions class fm provided actions carried fsm processing 
explicit state machine engine able take different fsm descriptions execute execution mechanism inherent state machine class 
state machine implementation smalltalk hopkins various implementation techniques model state machines object oriented programming language smalltalk gr 
author explains different mappings states program constructs mapping states case statements mapping states methods mapping states classes 
discusses advantages disadvantages various approaches suggests approach considering different requirements 
review state art moods models object oriented design state ran ran alexander ran presents techniques model states classes 
moods family design patterns intended simplify design implementation objects complex state dependent representation behavior 
ran calls objects moody objects 
design pattern called state techniques ghjv 
proposed approach state design pattern enhances see sections chapter 
comprehensive list related ran 
architectural design styles state transition techniques mary shaw shaw architectural design styles state transition diagrams state transition tables extension diagrams invented david harel called statecharts harel 
mary shaw compares architectural design styles papers booch cruise control problem addressed 
divides different architectural design styles groups discussed sections 
state architectures state architectures focus major states system events cause transitions states shaw 
statemate sg case system state transition methods advanced capability simulation 
state transition formalism graphical notations activity charts form functional decomposition statecharts representation finite state machines 
state model checking technique ag defines state formulation problem mode transition tables 
modes collection states 
remaining architectural design styles state transition formalisms secondary views meaning supporting tools design process shaw 
review state art object oriented architectures nrl scr naval research laboratory software cost reduction approach kirby serves example object oriented architectural design style 
approach information hiding precision completeness 
state transition tables intensively architectural diagrams 
feedback control architectures process control paradigm shaw state transition problems modeled state machines 
difference object oriented functional designs characterized kinds system components control loop designs characterized kinds components special relations hold components shaw 
real time architectures approaches extensions structured analysis support real time system models ward mellor approach wk logic control transformations described state transition diagrams boeing approach wk uses state transition diagrams part control flow description 
approaches statecharts mate mate object oriented extension statemate case system 
modeling technique uses charts specify structure system 
charts omt notation identify classes objects relationships 
statecharts specify behavior single objects 
precise formal defined modeling technique allows model execution enables designer generate events analyze dynamic behavior system 
david harel mate inventors researchers states harel model execution manually creation external events simulation environment analyze behavior object modeling technique review state art specified reactive system interpretation process complex systems compiled 
compilation process translation representation example executable code programming language 
usually referred code generation 
term merely denote generation template code empty procedures harel coined term codification code generation conceptual model including behavioral aspects control flow 
fact code synthesis capabilities legal model translated executable code 
current target language mate 
visual formalism statecharts essential technique discussed thesis automatic code generation objective 
similar approach mate chb static structure system described configuration diagrams system behavior 
notation specifying behavior object classes statecharts 
sdl nokia telecommunications uses derivative sdl st fjm called sdl 
developed nokia large scale telephone switching system dx 
computational model underlying sdl processes finite automata known finite state machines 
finite automata provide intuitive basis understanding behavior sdl processes 
finite state automata graphically represented state transition diagrams 
main extension sdl processes compared finite automata possibility output symbols state transitions 
sdl process signal queue 
signals messages sent process sent signal queue process takes queue 
queue operates fifo discipline 
formal description process starts start statement transition executed process created 
start transition typically initializes variables process defines initial state 
review state art example start 
state process waits input 
state statement starts state definition input statement defines signals expected state nextstate statement defines state enter arrival certain signal 
example state state input digit 
actions carried signal digit received nextstate state input digit 
actions carried signal digit received nextstate state state state name asterisk associated signals nextstate definitions added state process 
useful representing behavior common states 
nextstate means state current state 
output statement send signals processes 
example output high level sdl specification compiled programming language state machine hard coded switch case goto statements 
switch case construct represents state machine states incoming events 
actions coded inside switch case construct entered goto statements 
consequently change action code state machine structure affected 
sdl state machines described source code level high level language higher degree abstraction 
sdl state automaton approach designed process harel statechart extensions depth orthogonality 
review state art thesis higher level abstraction achieved designing representation higher abstraction level special implementation techniques source code level 
furthermore integration harel statechart extensions depth orthogonality broadcast communication essential task thesis 
basic techniques available basic techniques available basic techniques available introduced detail chapter 
topics software components generic programming state machines state transition diagrams harel visual formalism statecharts design patterns related techniques state design pattern state machine engines discussed 
software components generic programming engineering disciplines rely standard components design build artifacts 
essential technical challenge software engineering enable adoption model software development process jazayeri 
realizing component model far reaching effects software analysis design redesign implementation maintenance enhancement 
scientifically founded component programming paradigm help standardize analysis design concepts reduce number code lines written increase maintainability simplify enhancement redesign provide basis standard certifying quality assurance techniques areas system architecture design implementation 
components bundled standard component catalogs selected application created 
jazayeri catalog fulfil certain requirements components form systematic taxonomy means closely related set understood concept 
catalogs comprehensive provide user components needed free far possible burden low level line line development 
components generic possible cover wide range applicability minimal number different components 
basic techniques available components efficient possible applications subject certain efficiency constraints 
alexander stepanov meng lee contributed research area component especially generic programming writing standard template library stl ls :10.1.1.108.7776
stl component catalog written provides generic components divided main groups components set basic concept 
stl described versions state machine implementation chapter serves model development generic components 
main components stl containers iterators algorithms 
containers store data arbitrary type 
type independence achieved template mechanism stroustrup 
iterators access method algorithms data 
algorithms directly containers require write different versions different containers 
iterators encapsulate certain data access methods instance random access needed sort operation step step access needed linear find operation 
clean formally sound concept different components stl leads socalled orthogonal decomposition component space concept allows programmer generic algorithms existing generic components vice versa 
efficiency concern generic components built thesis 
genericity efficiency contradictory objectives stl approach shown 
algorithms stl written way efficiency lost applying algorithms different containers different iterators 
authors stl convinced generic algorithms succeed practice efficient conventional ones 
fsms state transition diagrams finite state machine finite automaton 
finite automaton deterministic non deterministic 
thesis fsm considered deterministic finite automaton dfa event cause state transition time making system behavior non deterministic 
automata theory hu deterministic finite automaton defined tuple basic techniques available dfa set states input alphabet transition function yields state state input symbol initial state set final states 
state transition diagram visual counterpart finite state machine harel 
shows state transition diagram state transition diagram identifier initial state final state legend initial final state normal state usually named event associated transitions dotted arc transition state state state state event event event basic techniques available state transition diagram depicts control flow simple tv set control application 
initial state tv screen shows standard picture 
pressing certain button remote control main menu shown screen volume menu selected volume increased decreased 
state initial state state transition initial state possible 
simple tv set example state transition diagram state tv display initial final state means state machine execution begins ends state infinite sequence remote control commands issued 
menu button pressed remote control event press menu generated causes transition state tv display state show menu menu control certain tv functions displayed 
volume menu button remote control generates event press volume menu state show volume menu 
volume level lowered raised pushing corresponding buttons remote control exit button deletes menu screen 
event causes transition state state transition labeled said fire 
event point time having duration zero time state certain duration delimited events 
event said trigger transition called trigger event 
formal description tv remote control dfa tv display initial final state tv show menu tv show volume menu tv raise volume tv lower volume hide menus show menu show volume menu raise volume lower volume basic techniques available tv control vt tv display tv show menu tv show volume menu tv lower volume tv raise volume vt show menu show volume menu lower volume raise volume hide menus tv display tv display defined tv display show menu tv show menu tv show menu show volume menu tv show volume menu tv show menu hide menus tv display tv show volume menu lower volume tv lower volume tv show volume menu raise volume tv raise volume tv show volume menu hide menus tv display tv lower volume lower volume tv lower volume tv lower volume raise volume tv raise volume tv lower volume hide menus tv display tv raise volume lower volume tv lower volume tv raise volume raise volume tv raise volume tv raise volume hide menus tv display formal description fsm extended output associated transitions states 
literature fsms associate output states called moore machines fsms associate output state transitions called mealy machines hu 
output symbols taken specified output alphabet 
formal description moore machine mealy machine moore mealy ti basic techniques available ti input alphabet output alphabet mapping moore machine mapping mealy machine symbols fsm description 
approach thesis output symbols interpreted execution actions corresponding output symbols 
states duration actions executed time state duration especially entry point exit point state 
actions events considered zero time means execution action require global system time 
furthermore activity started state entry point stopped state exit point 
dfa defined state transition table additionally specifying initial state set final states 
david harel visual formalism statecharts david harel extended state transition diagrams visual formalism higraphs harel 
higraphs graphs certain number different nodes higraph idiom called blobs grouped superior node 
adds notion hierarchy depth higraphs 
harel applied principle state transition diagrams leading remarkable simplifications 
instance required state transition system states error state 
state transition diagram system state arc drawn error state 
statechart system states grouped superior state transition arc drawn single called superstate error state 
depth feature important improvement linear growing system number states grows exponentially handling states gets tedious error prone 
statechart formalism applied complex systems confusing 
superstate substates xor relationship 
state machine superstate exactly substates 
introduce notion concurrency called orthogonality statecharts harel allows substates superstate separated dashed line 
leads decomposition states superstate area marked dashed line exactly state active point time 
extension refers transitions 
state transition diagrams transition labeled events 
event labels called conditional guarded transition meaning event triggers transition condition basic techniques available true 
express timing constraints timeouts 
general transition labeled expression trigger event condition action 
arrives condition true transition fires specified action executed 
action cause internal events broadcast system external events lead state transitions 
extensions harel defines statecharts follows harel statechart state transition diagram depth orthogonality broadcast communication 
architectural design styles described section adopt notation statecharts making state art design complex reactive systems 
statecharts include notations showing concurrency mechanisms showing state changes notations timing constraints shaw 
harel uses statecharts specifying behavior case tool approaches statemate mate described section 
shows statechart examples concepts depth left statechart superstate contains substates orthogonality right statechart superstate orthogonal substates 
left statechart state transition triggered arrival event condition true 
concept broadcast communication seen right statechart 
arrival event event generated broadcast statechart 
superstate substate active broadcast leads state transition statechart examples basic techniques available shows corresponding statechart state transition diagram 
states tv show menu tv show volume menu tv lower volume tv raise volume substates grouped single superstate 
possible draw single transition arc superstate initial state tv display 
state transition diagram trivial tv set example simple statechart simplification striking 
consider simplification issues gain importance system complexity increases 
simple tv set example statechart design patterns structured object oriented architectures usually contain patterns ghjv pree 
focusing patterns system development lead simpler smaller understandable designs 
pattern describe problem occurring certain environment define core problem solution 
solve certain problem corresponding design pattern applied preventing repeated development alternative inadequate inefficient solutions 
pattern description concrete design implementation problem template applied different show menu hide menus show volume menu lower volume raise volume tv show menu tv display tv show volume menu tv lower volume tv raise volume basic techniques available situations 
pattern describes problem way suggests general solution 
ghjv pattern consists essential elements pattern name name short meaningful pattern names increase architects vocabulary design higher level abstraction 
problem description description describes apply pattern explains problem context 
solution solution describes elements design relationships properties collaborations 
consequences consequences results tradeoffs applying pattern critical evaluating design alternatives understanding advantages disadvantages applying certain pattern 
thesis follow concept design patterns introduced ghjv 
problem solutions design patterns intended simplify classification application 
section design pattern state taken ghjv described detail extend design pattern harel statechart mechanisms 
state design pattern related techniques behavior objects depends significantly states may qualitatively different different times 
ran ran problem modeling states dynamic behavior object oriented languages especially discussed 
commonly object oriented languages offer sufficient support modeling states state dependent behavior 
main problems dedicated language construct exists represent states conditions classes behavior states get hidden implementation share name space class relations states represented explicitly state relation dedicated construct exists model relation object state member relation basic techniques available oo languages support state polymorphism implicit method selection object state 
ran overcomes problems introducing approaches modeling state classes oo languages 
oo languages term state mean combination bindings object attributes 
ran uses term instance concrete state meaning 
term state specify certain case behavior called state 
state establishes classification instances class state 
classification class states modeled collection classes state classes 
class models state called state class called ordinary standard class 
concept state seen specialization concept class state relation specialization subclass relation 
state subclass provides implementation state specific methods 
clients view class state subclasses separate 
class state subclasses forms cluster classes 
cluster represented clients single class cluster deputy 
clusters state classes models classes states 
cluster deputy class represents cluster clients hides implementation details cluster 
member relation second relation exists instance socalled root class cluster state class cluster deputy state class different techniques shortly described 
relation describes actual state class modeled state cluster just 
ran possibilities model member relation introduced membership extension means states objects naturally specified unambiguous consequences received events cause state transitions 
membership intension state class may interpreted intensionally predicative definition represented state predicative definition means predicate evaluated case true false states entered 
explains state member relation tiny example 
state class busy derived root class implement behavior case line busy case call rejected 
line busy basic techniques available instance instance root class 
maintains member relation busy state class provide right service incoming call 
state member relation ran mechanism allows instances cluster deputy exhibit state dependent behavior called state dependent dispatch 
state dependent dispatch achieved techniques stateless states methods state classes defined operate deputy instance 
deputy delegates messages instances state classes member relation 
representation member relation may pointer state class instance 
distributed representation deputy representation pointer instance generic class cluster cluster root 
messages received deputy delegated pointer object perform method behalf deputy 
dynamic type change need deputy object 
instance state cluster may directly clients 
appropriate method selected dynamically changing types state subclasses 
programmer controlled dispatch changing object instances order call right method may change way methods defined state classes selected 
deputy class multiply inherits state class cluster 
line busy idle busy state instance member basic techniques available response method call deputy compute select appropriate implementation method state membership 
object oriented design pattern state ghjv technique stateless states alexander ran ran design classes states change behavior dependence states 
state represented state class 
inside state class methods implement behavior needed state 
single system states physically separated comprehensible prevents method code overloaded large conditional statements 
inheritance hierarchy single state classes called state cluster 
interface client state cluster deputy class 
deputy class pointer state class corresponding actual state 
client calls method deputy class delegates method call appropriate state class internal pointer 
case state transition method updates pointer inside deputy class pointer instance state class corresponding state 
state machine engine state machine coded switch case statements specification system states events transition information algorithm evaluate events relate states mixed source code level 
technique build state machine engine discussed intended various state machine specifications implements system behavior 
different degrees separation state machine specification states events state transition information state machine engine considered shown approach approach approach state machine engine state machine specification state machine specification inserted operations outside state machine engine state machine specification state machine engine basic techniques available relation state machine engine state machine specification approach state machine engine state machine specification encapsulated conglomerate 
case call state machine engine implicit closely related state machine specification 
meaningful operational combination specification physically logically separated switch case approach 
approach state machine engine logically separated state machine specification physically combined software component 
specification brought state machine component operations provided component 
third approach state machine engine physically logically separated state machine specification 
state machine engine component provided handle state machine specification able process 
major advantage approach fact concepts state machine engine state machine specification fully separated mutual influences dependencies minimized 
essential genericity issues 
approaches section referred state machine engine approach 
extended state design pattern extended state design pattern extended state design pattern introduced chapter 
detailed description pattern parts harel state hs generic harel state machine engine hsme provided patterns applied example tv set control application 
section describes state machine engine versions implemented originating development process generic state machine engine 
code version appendix 
versions referred state machine version 
code examples chapter written 
cases may incomplete essential parts 
complete examples compiled borland borland respectively 
history generic state machine engine state machine versions section process simple state machine shown 
version state machine implementations done plain style switch case statements 
infinite loop system waits incoming event 
event occurs valid transition current state state system decides state action executed depending current state 
benefit state machine implementation efficiency small code size cost code see sight piece code implements state machine 
state machine enhanced enhancement state space event space transition functionality system designer go code level add corresponding code statements 
state machine description code deciding state transitions state machine engine combined piece source code state machine engine approach considerations section 
state machine engine implicitly contained code 
state event space huge maintenance gets tedious error prone 
second third version structural change code 
transition information explicitly provided user stored stl container data structure second version stl vector third version stl set 
state machine class execute member function defined works data 
inside extended state design pattern execute member function loop ends state machine reaches final state 
long current state final state system waits event applying function provided user 
polling process done loop left incoming event valid event 
data structure transition information searched data item source state current state incoming event event received 
data item new current state data item destination state function stored data item executed 
data item incoming event valid current state system starts event polling process 
finding transition information vector corresponds array statistically needs container accesses data item set maximal ld steps container size 
set vector increases speed time increases code size complicated implementation set 
approach processing loop logically separated state machine specification state transition information inserted state machine class user versions represent state machine engine approach 
fourth version uses state machine engine approach implements class transition storing source state event destination state action executed template type state event action data items arbitrarily changed instantiating template different data types 
class state machine template type transition data item fixed instantiation time 
versions stl containers version vector version set hold state event sets 
time state transition table implemented vector vector corresponds dimensional array 
advantage direct access data structure speeding access constant time search carried 
disadvantage waste memory especially state transition table big sparsely filled 
approach possible instantiate state machine engine template stl vector states events stl set states events mix containers 
vector leads smaller code size set leads run time improvement user decide properties concrete state machine instantiation 
versions build transition information run time need computer resources seventh version defines state transition table simple dimensional array compile time 
dynamic part execution state machine engine loop 
state event data structures state machine engine template structs 
comparison shows version extended state design pattern close version terms lines code object code size execution time 
tv set example provide imaginary tv set control application example reactive system designed implemented 
imagine tv remote control layout controlling tv set buttons channel selection button 
allows entry digit channel number 
increase decrease volume respectively 
button menu shows selection menu tv screen parameter brightness contrast 
changed selected buttons 
press menu allows alter specific parameter 
press menu stores uses new parameter 
mute button toggles tv speaker vice versa 
key suspends tv set suspend mode 
tv remote control left middle part table show events generated pressing appropriate buttons remote control right part table shows internal events issued tv set menu mute extended state design pattern table external internal tv set system events dynamic behavior tv set specified statechart shown tv set control application statechart button event button event 
menu mute internal events power power tv set control tv tv tv digit get get second normal control select menu modify menu speaker speaker normal locked norm speaker speaker speaker spe locked speak extended state design pattern assumed tv set functionality implemented class tv set 
tv set instance created power event arrives means switched 
destroyed terminated power event arrives tv set switched 
notation circles containing hg 
initializing instance superstate control active 
inside superstate control orthogonal concurrent substates normal speaker tv active time concurrently receive events trigger state transitions 
orthogonality graphically expressed separation dashed lines 
normal initial state norm speaker speak tv tv expressed little arcs source state 
events broadcast inside entire statechart event occurs sent active states processed 
state norm superstate containing substates orthogonality 
introducing superstate norm allows important simplification transition arc drawn state norm state locked express substates norm subject transition 
regardless state inside norm active arrival event state transition state locked take place 
usual state diagrams state transitions represented directed arcs labeled event causing transition 
event external internal condition follow brackets state transition takes place said triggered condition evaluates true 
example condition speaker evaluates true causes transition state speaker active time condition evaluated 
component state transition label action 
action generation external internal event broadcast transition triggered 
event cause state transitions 
action consist statements meaningful certain programming language meaning statements carried transition takes place 
general state transition label syntax components event condition action mandatory event condition action power turned tv set button remote control suspend tv set 
internal event sent tv set suspended lock tv set remote control input sent tv set reactivated 
statechart state transition table derived straightforward manner 
column titles single system events external internal line titles system states 
table cells consist state follows state line event column arrives 
table table additionally state extended state design pattern natural language description action carried transition takes place 
call table augmented state transition table 
notice table names substates statechart modularization feature stands state current state remains unchanged action respectively table augmented tv set state transition table part state event normal control normal control select channel get sel digit ch select menu go select menu normal control raise volume normal control lower volume select menu modify menu enter menu select menu menu select menu previous menu modify menu normal control parameter modify menu raise parameter modify menu lower param get get second get number normal control cancel digit get second normal control get second num normal control cancel digit speaker speaker tv tv locked spe locked extended state design pattern table augmented tv set state transition table part ii statecharts visual formalism derivation process statechart state transition table done automatically 
actions specified state transition conceivable compile high level statechart model directly source code level abstraction 
harel named process automatic code generation including control flow codification harel 
requirements state design pattern processing statecharts table shows important requirements state design pattern state machine engine capable processing harel statechart extensions 
requirements derived statechart examples harel hg tv set control example 
presentation es state event normal control locked select menu locked modify menu locked get locked get second locked speaker speaker turn speaker spe locked speaker speaker turn speaker spe locked tv tv turn tv set tv tv turn tv set locked normal control spe locked speaker extended state design pattern hs hsme current implementations approaches evaluated checklist section 
table requirements state design pattern processing statecharts addition state machine engine processing state transition information efficiently meaning efficiency differ hard coded approach magnitudes 
state machine engine generic possible widely applicable changing software environments 
example insensitive certain changes representation state event transition table representations improve flexibility 
extended state extended state design pattern expected simplify specification design implementation reactive systems 
problem domain decomposed set classes standard ooa techniques booch 
dynamic course events dynamic behavior system specified statecharts 
hs approach classes transformed clusters state classes state related finite number state machines specified processed finite number orthogonal substates superstate specified state modularization superstate substate relation principle provided specification state depending result action possible event related events broadcast active components system internal events generated state transitions different event queues specified different states action related specification actions state transition table differ return types parameter lists possible parameters bound actions specified state transition table condition related specification global conditions block state transitions possible specification meta conditions state state block state transitions possible extended state design pattern state class represents state 
arrival events appropriate member function called transparently implements correct state dependent system behavior 
hsme approach statechart information transformed state transition table explicitly expresses possible states events state transitions assigned actions 
generic state machine engine works state transition table incoming events implement correct system behavior 
imperative hsme approach system object oriented decomposed classes 
current implementation actions state transition table simple functions wrapper class methods common functions 
harel state approach hs applying hs tv set control example tv set physical logical unit decide design tv set functionality class tv set class 
dynamic behavior tv set specified system requirements statechart 
requirements tv set control application stated explicitly thesis derived statechart 
resulting statechart called state diagram derived 
state diagram shows hierarchy states global superstate relating substates state relation 
state diagram interpreted subclass inheritance hierarchy 
subclass hierarchy shown starting tv setstate class root class cluster 
additionally cluster deputy depicted member relation shown implemented pointer array stateless states technique 
extended state design pattern tv set class diagram events modeled methods state classes 
external event arrives client call method corresponds event 
source code methods named exactly external internal events 
harel state extends state cope statechart mechanisms depth orthogonality broadcast communication system modeled statecharts directly transferred code 
step deputy class tv set provides interface client implemented const int max orthogonal states class tv set public tv set tv setstate control tv set tv setstate state method state method state normal tv speaker speak norm locked spe locked tv tv speaker speaker normal control digit get get second menu modify menu deputy class state cluster client extended state design pattern external events void void void void void void void void void private internal events void void friend class tv setstate void tv setstate tv setstate state max orthogonal states attribute state array pointers instances tv setstate class 
tv setstate base class tv set state cluster 
single tv setstate pointers model member relation array state pointers implements orthogonality feature 
approach implementation orthogonality usage list 
state pointer array size maximum number states concurrently active 
number taken statechart example stored global constant variable max orthogonal states 
step tv setstate class implemented class tv setstate public virtual void tv set virtual void tv set virtual void tv set virtual void tv set virtual void tv set virtual void tv set virtual void tv set virtual void tv set virtual void tv set virtual void tv set virtual void tv set protected extended state design pattern void tv set tv setstate tv setstate member functions take tv set instance parameter access data elements tv set able change current state 
tv set tv set add active states control instance constructor deputy class tv set defines control initial state 
control instance control member function returns pointer instance control class models state control 
superstate control gets active information provided substates get active order add state pointers state data structure 
done recursively substates state superstate left 
add active states tv set member function provides functionality 
void tv set tv setstate add active states member tv set takes state pointer adds state pointer case superstate pointers active substates state array 
void tv setstate tv set member functions tv setstate defined empty 
typedef void tv setstate tv set void broadcast tv setstate state tv set int state void tv set broadcast state tv setstate extended state design pattern member functions deputy class tv set broadcast incoming events broadcast communication orthogonality feature active states system 
states react event possibly causing state transitions 
hs states represented classes 
superstate control represented class control inherited tv setstate 
classes representing states normal speaker tv inherited control class diagram shown 
state classes implemented way 
class control public tv setstate public static tv setstate instance tv setstate control instance static control instance return instance class normal public control public static tv setstate instance class speaker public control public static tv setstate instance class tv public control public static tv setstate instance depth modularization hierarchy feature inherently state class approach due subclass inheritance relation 
example class norm inherited normal redefines empty member function 
state classes inherited norm inherit member function 
substates norm react event state transition state locked having define member function substate 
inheritance mechanism implements modularization feature statecharts 
class norm public normal public static tv setstate instance virtual void tv set extended state design pattern void norm tv set locked instance tv set control application internal events broadcast arrival event 
internal events broadcast system directly calling corresponding deputy member function 
effect event external 
corresponding deputy member function implemented private member possible outside issue internal event 
void tv tv set action code suspend tv set produce internal event broadcast tv instance final state reached orthogonal component corresponding state pointer deleted data structure tv set control application final states defined 
data structure gets empty ultimate final state reached 
fact reported environment signal state machine processing ended reaction events deputy function calls take place 
void tv set state event final state tv set action code 
transition final state deleting current state tv setstate client state cluster act way tv set tv tv finished switch wait remote control event case tv break case tv break 
default unknown remote control event extended state design pattern depth orthogonality broadcast communication depth modularization hierarchy feature inherently state class approach subclass inheritance relation 
orthogonality feature implemented extending state pointer array pointers list pointers 
list approach allocates memory needed storing state pointers currently active states array approach allocates memory maximum number state pointers 
implement broadcast communication feature arrival external internal event loop state pointers report event currently active components 
internal events broadcast system directly calling corresponding deputy member function 
generic harel state machine engine approach hsme harel state machine engine approach table approach transition information actions executed state transitions kept table 
hsme uses explicit state machine engine process data state transition table implement specified system behavior specific name 
hsme implements state machine engine approach see section 
states represented classes template structs 
approach templates implementation independent concrete types 
data possible kept static maximum state machine code instantiated compile time run time part remains minimal 
transition function template struct fully instantiated compile time 
dynamic part state machine engine loop 
minimality approach essential comes implementation embedded systems usually strong restrictions referring hardware resources 
applying hsme tv set control example hs tv set control application requirements statechart drawn see 
states events defined code level define error state error define state machine tv set extended state design pattern global superstate control define control state super orthogonal superstate normal define normal state super define locked state concrete superstate norm define norm state super define normal control state init define select menu state concrete define modify menu state concrete superstate digit define digit state super define get state concrete define get second state concrete second orthogonal superstate speaker define speaker state super define spe locked state concrete superstate speak define speak state super define speaker state init define speaker state concrete third orthogonal superstate tv define tv state super define tv state init define tv state concrete state machine tv set struct state states locked concrete states normal control select menu modify menu get get second spe locked speaker speaker tv extended state design pattern tv control normal norm digit speaker speak tv const int super start index starting index struct states struct event events analogously const int max ortho states data item inside braces state define directives state identifier second data item specifies type state 
state superstate type super having finite number substates concrete state type concrete meaning state substates 
concrete state initial state type init final state type final 
concrete state combined initial final state type init final 
combination types done bitwise operator 
type error represents error state 
example state current state event received error state means transition exists current state state caused event received 
implementation essential concrete states get identifiers zero maximum number concrete states access state transition table identifier type required integral type 
specified concrete states states struct marked underscore name superstate 
orthogonality feature properly necessary give additional information substates contained superstate mechanism able find extended state design pattern active components superstate gets active 
information expressed follows const int num super states number const int max sub states maximum number substates superstate struct state super num super states max sub states normal speaker tv error locked norm error error normal control select menu modify menu digit get get second error error spe locked speak error speaker speaker error error tv tv error error step actions going state transition table defined 
action void function returning result structure 
typedef result event res res standard action return value res prg hdtv set prg return res vol states speaker hdtv set vol return return res res trans res ton hdtv tv queue internal event event events event return res state res event extended state design pattern return value type result queue finite number internal events enable action define state regardless corresponding state transition table entry 
additionally block transitions certain conditions evaluate false 
example global function returns true state provided parameter currently active false 
hdtv global pointer instance tv set software interface class controls tv set hardware 
pointer global passed action parameter current implementation state transition table take void functions see section 
step definition state transition table typedef struct tf node fp tf node delta locked error error 
normal control normal control prg normal control prg 
select menu error error 
modify menu error error 
get get second get second 
get second normal control normal control 
spe locked error error 
speaker error error 
speaker error error 
tv error error 
tv error error fp type action function pointer defined user concrete state event types array dimensions computed automatically 
type define action function pointer typedef result event fp void state machine engine template struct instantiated types state event type transition table types table dimensions type function returning external events 
parameters constructor pointer transition table dimensions table function pointer external event providing function 
function usually coded user required return value event type example reads integers input stream ev returns events type event 
event void extended state design pattern int ret ev ret exit return event ret typedef event void sm event int int delta start processing harel state machine execute member function state machine engine struct called data structure containing initial state state state max ortho states int state state add active states states state control superstate execute state add active states function takes state pointer state pointer array functionality case concrete initial state state pointer added state array case superstate add active states recursively searches concrete initial states superstate adds pointers state data structure 
mechanism necessary state concrete state orthogonal superstate successor state added state pointer array 
depth orthogonality broadcast communication problem approach implementation depth modularization feature 
hs transition functionality defined norm class inherited subclasses 
static table approach allow simplification state appropriate action specified table substates norm 
conceptual problem implementational problem dimensional table flat model inherently provide means modularization depth hierarchy 
implement orthogonality feature current implementation hsme uses state pointer array store active components 
broadcast communication achieved loop execute member function going state pointer array broadcast internal extended state design pattern external events 
internal events added queue inside state machine struct action return struct result processed ahead external events 
code framework code parts shown section logically grouped header files 
hsme state machine user program state machine engine implementation header file sm included 
state event transition table state machine data structures defined 
state machine definition file containing definition states events created user included 
step action implementation file actions created user included 
state transition table specified defined states events actions 
state machine struct instantiated initial state defined execute member function state machine struct called start processing 
section presents essential code parts state machine engine implementation sm template struct state enum stype init final error super concrete id integral identifier required table access stype type type state int operator const state const state operator const state state struct parametrized type identifier data item 
second data item state type 
type serves bit mask state combined type 
event struct similar state struct 
equality operators needed internal events stored stl event queue stl containers certain requirements data item types ls :10.1.1.108.7776
tt node transition table node struct merely consists state action executed template struct event event id event const id extended state design pattern id integral identifier required table access int operator const return id int operator const event const return id id event operator const event template struct tt node state ac action perform result struct returned transition table action function enables features queuing internal events defining certain state regardless state specified transition table blocking forbidding state transitions 
template struct result enum normal state event trans result info normal ev num result info ev num result state event int state event result delete internal result operator const result info state event internal int ev num examples show return internal events combined action defined state single internal event action defined state extended state design pattern block transition event events events event return res states event events event return res state res event return res states event res state return res res trans operations state machine engine struct constructor execute member function process state machine member function reports specified state currently active 
queue internal events qu type queue list stl container queue stl container adaptor adapt interface list container look queue interface 
template class class fp struct sm sm node de const dx const dy fp delta de dx dy void execute state current int state st dimension delta dimension delta node delta transition table fp pointer global event queue queue qu queue internal events state curr pointer state pointer array execute member function commented extended state design pattern template class class fp void sm execute state current curr current curr attribute sm struct points state pointer array provided parameter execute member 
done operation needs access state pointer array 
result res ac state super event ev int finished qu empty qu pop clear internal event queue finished processing ends finished evaluates true 
finished set true state pointer array empty see 
qu empty ev qu front qu pop poll internal event queue internal events internal event queue taken queue broadcast 
ev poll global event queue internal event queue empty event function pointer dereferenced receive external event 
ev id polling process done valid event received 
loop currently active states broadcasts event received 
loop currently active states int current state extended state design pattern node node delta current id ev id transition table accessed actual state event identifiers 
type error bit mask evaluated check transition valid 
transition valid destination state error state 
transition actual state event received leads error state event ignored 
execute action ac res ac res ac action specified table executed 
res info trans statement checks actual transition blocked preceding action execution 
set state res info state current res action specified state state pointer array updated correspondingly state specified state transition table 
current queue internal events res info event action specified internal events added stl queue push operation 
int res internal event qu push res internal current type super extended state design pattern state super state add active states template function adds pointers active substates state pointer array 
super current current state add active states super current current type final current type init case true final state combined initial final state state pointer removed state pointer array 
current state cout transition cout event current id current state finished int finished current state state machine engine ends processing active component left react events 
cout finished 
evaluation evaluation chapter presents evaluation comparison state machine engine versions discussed section evaluation hs hsme design patterns selection criteria choosing hs hsme evaluation current hs hsme implementations considerations research area 
evaluation comparison state machine versions stated section benefits state machine version low level switch case approach efficiency terms run time small code size comprising small number code lines small object code size 
cost low abstraction level source code 
version action code defined functions outside state machine implementation invoked incoming events 
action code implemented inside switch case construct state machine code size increases 
furthermore action code state machine processing code mixed 
effort analyzing code increases 
low level abstraction essential shortcoming implemented dynamic behavior understood coding state machine purposes program system understanding modification reuse 
categories state machine modification conceivable enhancing reducing state space modification state space altering state information 
enhancing reducing event space modification event space altering event information 
enhancing reducing transition information transition information changing destination states state transitions name actions executed 
enhancing reducing altering processing functionality state machine engine 
evaluation modifications categories system engineer low abstraction level single language statements 
state machine version represents state machine engine approach see section mutual dependencies code level transition information description transition information description processing functionality 
modification categories mentioned list lead unintentional modification category 
consequently certain probability correctness implementation affected certain modifications 
developing generic component raising level abstraction source code probabilities expected decrease 
considerations state machine version implemented 
table consisting parts compares different state machine implementations terms number lines code object code size bytes od compiler optimization full size optimization full speed optimization run time seconds versions process event file containing events disk caching disabled 
executable size bytes od compiler optimization full size optimization full speed optimization code compiled ms dos borland respectively 
ox expressions borland specific compiler switches optimization purposes 
evaluation table quantitative comparison state machine versions table parts compares different state machine implementations hs hsme approaches qualitative terms storing method provider building time access effort storing efficiency way modification state transition information templates stl encapsulation 
loc numbers originate original implementation files code appendix 
counting process done manually empty lines lines merely consisting comments skipped 
state machine version lines code object code size bytes od switch case oo sm engine vector oo sm engine set sm engine template stl approach vector stl approach set minimal sm template version run time events executable size bytes od switch case oo sm engine vector oo sm engine set sm engine template stl approach vector stl approach set minimal sm template evaluation member function table additional member functions implemented versions version transition info stored provided built switch case source code programmer compile time oo sm engine vector container user run time oo sm engine set container user run time sm engine template container user run time stl approach vector table user run time stl approach set table user run time minimal sm template hs hsme table state class methods table user programmer user compile time compile time compile time version access effort space waste sparse transition information modification state event space transition info code level modification container ld modification container modification container modification table modification table hs hsme modification table defining new classes methods modification table evaluation table qualitative comparison sm versions hs hsme state machine version result trying develop state machine engine generic component 
advantages version compared version separation transition information execution loop enabling physical state machine engine implementation execute valid state machine descriptions provided user enabling modification state transition information going low level code engine implementation preventing modification execution loop modifying state transition information vice versa independence state event data structures concrete identifier type long integral type transition table access constant time independence transition table entries concrete type state action independence state machine engine template concrete types state event transition table data structures 
advantages hsme state machine engine developed version state machine implementation 
advantages version compared version cheap terms increase number code lines object code size run time see table 
stl container storing transition information template state machine engine implementation templates 
stl storing state transition information 
stl queue queuing internal events 
version templates stl encapsulation classes classes classes classes classes hs hsme structs classes structs evaluation evaluation hs pattern section discusses properties benefits shortcomings hs approach indicates areas 
benefits harel state approach true object oriented approach 
state design pattern ghjv new states events added easily defining new state classes methods 
consequently modifications done object oriented level class method definitions level single language statement implementation 
introducing separate classes different states state transitions explicit state transition associated change state class instance 
state transition hidden implementation changing values various variables flags 
client works cluster deputy state class hierarchy hidden client 
hs approach depth modularization feature statecharts inherently provided effectively simplify shorten code 
hs meets requirements solution problem stated chapter summary requirements chapter specifications reactive system behavior statecharts directly transferred code hs pattern methodologies implementing advanced statechart features 
level abstraction raised correspondence states classes events methods 
state transitions explicit instances state classes representation states 
virtual function calls introduce level indirection run time efficiency hs approach differ low level approach state machine version magnitudes see section 
shortcomings state class state approach compact single class approach 
states state classes created handled maintained 
interesting find break point virtual functions called searching right function pointer virtual function table vft dereferencing 
evaluation clear logical concept state classes longer compensate increase complexity introduced large number state classes 
having large number state classes maintenance gets difficult appropriate state dependent code located class hierarchy implementation 
understanding dynamic behavior difficult table approach instance hsme 
table considerably large easily understood class hierarchy large number member function implementations 
additionally modification state transitions happens code level returning pointer state class instance table approach modification happens higher level abstraction altering table entries 
hs approach explicit state machine engine component physically logically separated state machine specification 
part engine coded user polling evaluating events calling corresponding deputy member function part engine encapsulated global template function broadcast broadcasts events active components functionality hidden state cluster defining state 
local scattering state machine engine functionality leads essential shortcoming engine enhanced changed modified version number existing state clusters 
list discusses requirements stated chapter hs state cluster encapsulated software component dedicated concept component generic 
certain flexibility due object oriented approach reuse concept classes single lines code 
missing physical separation state machine engine state machine specification prevents 
different specifications physical engine implementation vice versa 
stated completely separated engine encapsulated single component exists 
consequently engine reused level single component level integrating number code parts 
hs defines class state hs implementation contains lines code compared table low level approach especially state space large 
list discusses possible concerning hs approach done fully implement orthogonality feature case state superstate 
initial states inside superstate recursively added data structure currently active states 
state classes enhanced member function returning type superstate concrete evaluation state 
case algorithm implemented hsme solve problem 
implementational task 
quantitative evaluation show run time efficiency properties hs approach comparison hsme low level approaches 
system consists different states source code class hierarchy rapidly gets confusing 
obviously conceptual problem done develop kind structuring technique overcome problem 
evaluation hsme pattern section discusses properties benefits shortcomings hsme approach points areas 
benefits generic harel state machine engine approach designed intent state transition information explicit possible modification done code level form basic language statements higher level abstraction 
modifying program code approach data modified 
new states events defined easily instantiating static template structs adding arrays 
state transition information information action executed state transition modified modifying appropriate table entry 
compared hs modifications approach restricted relatively small part code 
state event action transition table descriptions compact easily overlooked 
actions implemented provided tv set software interface class tv set class section possible person skilled low level programming design different reactive systems defining states events transition table 
hsme approach fully separates transition information execution loop discussed section physical state machine engine implementation execute valid state machine descriptions provided user state transition information modified going low level code execution loop modified modifying state transition information vice versa 
evaluation state machine engine separated state transition information changing engine functionality done new functionality effective recompiling modified engine state machine specifications concerned 
important consideration approach implement engine design pattern generic component generally applicable context software environment 
argument hsme state machine engine implementation generic fact arbitrary statechart descriptions 
designing system states events actions transition table defined 
processing defined state machine happens instantiating state machine software component data issuing execution command 
second argument genericity partial independence state machine engine software component concrete types represent states events transition information implementation data structures passed state machine struct template parameters 
partial means data structures template parameters state machine engine course strict requirements 
example state data structure attributes id type defined attributes referenced name inside execution loop state transition table accessible twice repeated application dereference operator operator 
requirements exist type independence achieved templates threefold independence state event data structures concrete identifier type long integral type transition table access constant time independence transition table entries concrete type state action independence state machine engine template concrete types state event transition table data structures 
alternative approach generic flexible conventional approach lacks efficiency significantly slower practice 
efficiency concerns essential comes assess utility generic approaches 
section state machine version compared state machine version terms run time code size 
result increase run time code size assessed minor advantages generic approach consideration 
quantitative efficiency evaluation repeated having implemented advanced statechart features 
expect enhanced engine run time efficiency reasons orthogonality feature adds array state pointers implementation 
reporting events active state state diagram broadcast mechanism iterates array evaluation report events currently active states 
enhancement seen constant 
objective keeping code size hsme minimal taken consideration development process major enhancements compared state machine version definition super struct loc depend system size result struct loc action functions loc depend features internal events add active states function loc statechart extensions execute member function loc loc 
consequently hsme meets requirements solution problem stated chapter certain extent statecharts specification dynamic behavior reactive systems directly transferred code state machine engine processes transition information 
level abstraction source code raised static state transition table specify transition information independent state machine engine component process 
approach generic having separate software components additionally templates independent concrete types data structures associated 
efficiency terms run time code size preserved compared low level approaches 
state machine engine state machine specification independent software components 
handle state event state transition information accessed state machine engine approach 
research needs pursued improve approach requirements 
list show suitability hsme pattern possible approach general problem specified 
shortcomings ghjv disadvantages table approaches discussed 
general table look considered efficient virtual function call 
current implementation identifiers states events required integral type int long char enable transition table access constant time addition dereference operations carried access table entry 
shortcoming stated transition information state action executed explicitly table approach transition criteria evaluation explicit state hs 
hs transition information stated action code state class method reader see conditions transition actions executed transition 
table approach action functions pseudo names shortly describe functionality dynamic system behavior understood directly table 
shortcoming takes effect action able block transition defines state dependence condition 
processes seen table prevent correct understanding state machine functionality 
major restrictions genericity current hsme implementation facts action functions state transition table type void functions return result structure 
required improve genericity 
example function objects function pointers state transition table allow pass parameters actions actions arbitrary type 
essential problem approach far loss ability statically define state transition table built compile time 
feasible study check suitability function object approach hsme 
list indicates possible concerning hsme approach quantitative efficiency evaluation hsme implementation done prove results predicted give quantitative argument hsme design implementation process reactive systems 
additional features triggering state transition certain timeout periods implemented increase utility hsme 
improvements genericity function object approach evaluated increase flexibility utility 
approaches conceptual problem missing modularization feature conceived 
selection criteria hs hsme integration hs hsme approaches feasible extent reasonable resulting coexistence implicit hs function objects objects function call operator operator defined 
evaluation explicit state machine engine hsme 
problem loss information particular action called state transition hsme explicitly shown state transition table 
hs mapping event method hidden state cluster deputy member functions named exactly events mapping transparently 
programmer go code find actual action caused event 
increase code size due class hierarchy approach hs reason integration 
help system designer choose approach certain environment give selection criteria reasonable hs pattern harel modularization feature brings major simplification system resulting code incorporated system object oriented efficiency code size requirements great concern enhancement maintenance cases expected system states significantly changing behavior 
reasonable hsme pattern missing modularization feature great concern code efficient compact corresponding low level coded approach design embedded real time systems frequent enhancement maintenance expected non programmers expected design systems implementation level quick system understanding extern persons experts required separation state event transition information state machine engine important modified dynamically changing engines 
evaluation current hs hsme implementations harel state design pattern requirements discussed section table compares current implementation approaches respect requirements 
means corresponding feature implemented table cell remains empty indicates incomplete feature implementation 
evaluation table requirements checklist current pattern implementations list discusses details numbered features table hs approach ad different state machines grouped global superstate events broadcast active components global state machine 
ad mechanism automatically finding active sub components currently fully implemented hs 
ad modularization feature inherently inheritance 
ad polling different event queues implemented user hs user responsible calling corresponding member functions dependence incoming external events 
ad deputy methods void functions data passed state cluster parameters 
ad meta conditions easily implemented state cluster member functions examining state pointer data structure active states state question 
state machine engine feature harel state harel state machine engine process finite number state machines specify finite number orthogonal substates state modularization principle dependence state result action event broadcast mechanism generating internal events specification different event queues different states user scope specification arbitrary typed actions state transition table table binding parameters actions global conditions block state transitions meta conditions state evaluation list discusses details numbered features table hsme approach ad see ad preceding list ad state modularization essential problem table approaches see section 
ad required state struct extended hold function pointer allow different event queues different states 
ad actions specified state transition table type 
ad void action functions specified state transition table parameter passing possible 
ad approach function objects remedy things essential problem loss ability statically define state transition table 
summary summary objective thesis implementation generic components state machines focusing component programming paradigm genericity efficiency harel visual formalism statecharts ran techniques model states classes 
major goal simplification specification design implementation reactive systems 
problem statement proposed strategy possible problem solution 
specification design powerful tool statecharts model dynamic system behavior 
step design pattern simplify direct transfer design code improve enhancement maintenance 

level abstraction software view raised low level coded control flow higher level program behavior specification 

software components developed generic generally applicable extensively reused changing software environments 

generic efficiency terms run time code size differ conventional low level approaches magnitudes applicable practice embedded systems subject sparse resources 

state machine engine developed physically separate processing loop state machine description 
engine processes high level transition information implements correct system behavior 
approach problem solution thesis introduces extended state design pattern consisting independent patterns harel state hs generic harel state machine engine hsme 
hs existing object oriented design pattern called state ghjv 
state extended way state machine descriptions derived statecharts easily directly implemented 
hierarchy states implemented class hierarchy inheritance events modeled methods deputy class representing state cluster 
depth feature inherently inheritance orthogonality broadcast communication implemented state pointer array loop array report events currently active components 
hs meets requirements problem solution summary dynamic system specifications statecharts directly transferred code hs pattern methodologies implementing advanced statechart features 
level abstraction raised correspondence states classes events methods 
run time efficiency hs approach differ low level approach 
requirements met hs approach state cluster encapsulated software component dedicated concept component generic 
completely separated engine encapsulated single component exist 
hs defines state class state hs implementation contains lines code compared table low level approach 
shortcomings compensated clear object oriented approach explicitly modeling states state transitions providing powerful mechanism modularization 
hsme pattern generic state machine engine separate software component working table transition information 
table approach transition information equivalent dynamic system behavior modified maintained conveniently 
approach developed especially considering genericity efficiency issues 
hsme meets requirements statecharts specification dynamic behavior reactive systems directly transferred code state machine engine processes transition information 
level abstraction source code raised static state transition table specify transition information independent state machine engine component process 
approach generic having separate software components additionally templates independent concrete types data structures associated 
efficiency terms run time code size preserved compared low level approaches 
state machine engine state machine specification independent software components 
summary meeting mentioned requirements hsme generic component approach expected significantly flexible low level coded state machine time working efficient low level approach consuming space 
striving flexible modeling approach reactive systems generic components hsme pattern help improve productivity quality reuse reactive system design preserving efficiency code size low level approaches 
ag gannon state model checking event driven system requirements ieee trans 
software eng ieee pp jan booch booch object oriented analysis design applications nd edition benjamin cummings publishing redwood city california coleman arnold object oriented development fusion method prentice hall englewood cliffs nj cb basili identifying qualifying reusable software components ieee computer pp february chb coleman hayes bear introducing statecharts object oriented design ieee trans 
software eng ieee pp cl chen lee study software reuse reusable components journal systems software pp january fjm notations software design springer verlag london ghjv gamma helm johnson vlissides design patterns addison wesley gr goldberg robson smalltalk language addison wesley harel harel statecharts visual formalism complex systems science computer programming north holland pp harel harel visual formalisms comm 
acm pp harel harel biting silver bullet brighter system development computer pp jan hg harel executable object modeling statecharts proceedings icse ieee hopkins hopkins implementing state machines smalltalk university manchester computer science technical report umcs hp harel pnueli development reactive systems logics models concurrent systems nato asi series vol 
apt ed 
springer verlag new york pp hu hopcroft ullman automata theory languages computation addison wesley jazayeri jazayeri component programming fresh look software components fifth european software engineering conference barcelona september kirby kirby example nrl scr software requirements automobile cruise control monitoring system tech 
report tr wang inst 
graduate studies boston univ mass krueger krueger software reuse acm computing surveys pp june book nd edition nokia telecom ls stepanov lee standard template library hp page mill road palo alto ca february meyer meyer object oriented software construction prentice hall englewood cliffs nj meyer meyer reusable software base object oriented component libraries prentice hall englewood cliffs nj ms musser stepanov generic programming issac symbolic algebraic computation proceedings published editor lecture notes computer science springer verlag ms musser stepanov algorithm oriented generic libraries software practice experience pp july ngt nierstrasz gibbs tsichritzis component oriented software development communications acm association computer machinery pp sep parnas parnas criteria decomposing systems modules communications acm pp dec pree pree design patterns object oriented software development addisonwesley ran ran modelling states classes nokia research center software technology laboratory box helsinki finland ran ran moods models object oriented design state early version chapter pattern languages program design addisonwesley rumbaugh blaha premerlani eddy lorensen object oriented modeling design prentice hall cliffs new jersey rw raymond wood grail library automata expressions symbolic computation academic press limited sg smith gerhart statemate cruise control case study proc :10.1.1.108.7776
computer software applications conference ieee cs press pp shaw shaw objects software design paradigm process control tech 
report cmu cs carnegie mellon university pittsburgh shaw shaw comparing architectural design styles ieee software ieee pp nov st ccitt sdl overview language applications computer networks isdn systems special issue ccitt sdl elsevier science publishers pp stroustrup stroustrup programming language nd edition addison wesley jun wk ward comparison ward mellor boeing real time methods proc smc xii twelfth structural methods conf structured tech 
assoc pp appendix appendix state machine versions appendices state machine engine implementations versions described section 
appendix presents state machine action definition file defines actions 
actions called state transitions 
state machine implementation files defined extern actions linked corresponding file 
state machine action definition file include void cout void cout void cout void cout void cout appendix appendix version input stream ev operates file events contains integer numbers separated white spaces stroustrup 
style state machine include include ev events ios extern action declarations extern void extern void extern void extern void extern void event show menu event show volume menu event lower volume event raise volume event hide menus state tv display state show menu state show volume menu state lower volume state raise volume static const char err sink state int event incoming event int current current state void main void ev event break appendix switch event case switch current case current break default cout break case switch current case current break default cout break case switch current case case current break case break default cout break case switch current case case current break case break default cout break case switch current case case case case current break default cout break default cout appendix appendix version modified bc include files order hp stl implementation bc 
information stl stl bc internet url www tuwien ac research component tutorial htm oo sm engine stl vector define minmax defined exclude min max functions define stl stl bc include include include include ev events ios define init state define final state extern void send tv show menu extern void send tv show volume menu extern void send tv lower volume extern void send tv raise volume extern void send tv hide menus class event public event name event const int name const int getname const return name int operator return name private int name appendix friend int operator const event const event inline int operator const event const event return name name class state public state name init final state const int int int name init final state const state name name init init final final state operator const state name name init init final final return int operator return name int const return init int const return final const int getname const return name private int name int init final friend int operator const state const state inline int operator const state const state return name name init init final final class data public data source input dest data state event source input data state event state void void source input dest function const state const return source const event const return input const state const return dest appendix void function void private state source event input state dest class state public state state event st int operator const data return st private state st event class state machine public state machine state init void trans event state state void void delta push back data void execute event void state init vector iterator event find delta delta state delta function private vector delta state init appendix event get event int ret ev ret exit return event ret void main void specify states name init state final state state tv display init state final state state show menu state show volume menu state lower volume state raise volume specify state machine initial state state machine tv volume control tv display specify transitions event source state destination state action tv volume control trans event tv display show menu tv volume control trans event show menu show volume menu tv volume control trans event show menu tv display tv volume control trans event show volume menu lower volume tv volume control trans event show volume menu raise volume tv volume control trans event show volume menu tv display tv volume control trans event lower volume lower volume tv volume control trans event lower volume raise volume tv volume control trans event lower volume tv display tv volume control trans event raise volume lower volume tv volume control trans event raise volume raise volume tv volume control trans event raise volume tv display appendix execute state machine tv volume control execute get event appendix appendix version version equivalent version stl vector storing state transition information version uses stl list 
essential differences include class state machine public state machine state init void trans event state state void void delta insert data void execute event void state init set iterator event delta find data delta function private set delta state init appendix appendix version oo sm engine stl vector pragma option jg define minmax defined stl min max functions define stl exclude borland operators include include include cope variable argument lists include stl vector definition include stl algorithms static const init state initial state static const final state final state ev events ios extern void send tv show menu extern void send tv show volume menu extern void send tv lower volume extern void send tv raise volume extern void send tv hide menus class action public action function action void void function void function void friend int operator const action const action inline int operator const action const action return function function appendix class event public event name event const int name const int getname const return name private int name friend int operator const event const event inline int operator const event const event return name name class state public state name init final state const int int int name init final int const return init int const return final const int getname const return name private int name int init int final friend int operator const state const state inline int operator const state const state return name name init init final final template class transition public typedef state appendix typedef event typedef action transition source input dest act transition source input dest act transition source input dest act const const return source const const return input const const return dest const const return act private source input dest act friend int operator const transition const transition inline int operator const transition const transition return source source input input dest dest template class state public typedef state typedef event state st int operator const return st private st appendix template class state machine public typedef state typedef event state machine int beg void execute void private vector delta template state machine state machine int beg 
int va list ap va start ap beg va arg ap break delta push back beg va ap template void state machine execute void vector iterator find delta delta state delta appendix void void function event get event int ret ev ret exit return event ret void main void state machine tv control state sm source state trans transition state init final event state action transition state event state action transition state event state init final action transition state event state action transition state event state action transition state event state init final action transition state event state action transition state event state action transition state event state init final action transition state event state action transition state event state action appendix transition state event state init final action specify argument list empty transition transition tv control execute get event appendix appendix version version equivalent version stl set store states events version uses stl vector 
version appendix 
appendix appendix version sm included version contains data structures definitions state machine engine sm ifndef sm define sm wrapper pointer function template class action public action function action function void operator function private function template class event public event id event const id const get id const return id event operator const event id id return int operator return id int operator const event const appendix return id id private id template class state public enum error normal init final state const int normal id type void error type error void normal type normal void init type init void final type final void type int const return type error int const return type init type int const return type final type int const return type const get id const return id state operator const state id id type type return int operator return id int operator const state const return id id private id int type template class state machine appendix public typedef value type typedef value type typedef value type tmp typedef tmp value type state machine states events delta void execute void current iterator iterator ite current current states find current valid state 
states exit transition ite events find valid event 
ite events delta get id ite get id current second private delta states events endif stl approach set pragma option jg define minmax defined stl min max functions appendix define stl exclude borland operators include include include include include sm typedef void fp void action performed template class state template class event typedef state typedef event ev events ios extern void send tv show menu extern void send tv show volume menu extern void send tv lower volume extern void send tv raise volume extern void send tv hide menus get event int ret ev ret exit return ret void main void set states set states tv display state tv display initial state tv show menu second state tv show volume menu third state tv raise volume appendix tv lower volume tv error tv error error error state states insert states tv display set states states insert states tv show menu states insert states tv show volume menu states insert states tv raise volume states insert states tv lower volume states insert states tv error set events input alphabet show menu event show volume menu second event raise volume lower volume hide menus events insert events show menu events insert events show volume menu events insert events raise volume events insert events lower volume events insert events hide menus typedef pair transition function vector delta vector tmp single line delta build transition function error pair tv error action tmp indices event numbers tmp pair tv show menu action tmp tmp tmp tmp error delta tmp tmp error tmp pair tv show volume menu action tmp pair tv display action delta tmp tmp error tmp pair tv lower volume action tmp pair tv raise volume action tmp pair tv display action appendix delta delta delta tmp state machine set states set input alphabet vector transition tv control states events delta tv control execute get event tv display appendix appendix version sm included version contains data structures definitions state machine engine sm pragma option jg include include template struct state enum stype init normal final error id stype type template struct event event id event id id template struct tf node ac template class struct sm typedef event fp void sm ms tf de fp max state ms max event delta de void execute state state current event ev appendix current type current type current id max state cout ev ev id max event node delta current id ev id type error current ac cout endl max state max event tf delta fp minimal sm template include include include sm event typedef void fp void ev events ios extern void send tv show menu extern void send tv show volume menu extern void send tv lower volume extern void send tv raise volume extern void send tv hide menus define error state error define tv display state init state final appendix define show menu state normal define show volume menu state normal define lower volume state normal define raise volume state normal struct state states tv display show menu show volume menu lower volume raise volume struct event events show menu show volume menu lower volume raise volume hide menus const int sizeof states sizeof states const int sizeof events sizeof events struct tf node fp delta show menu error error error error error show volume menu error error tv display error error lower volume raise volume tv display error error lower volume raise volume tv display error error lower volume raise volume tv display sm event tf node fp tf node fp int test delta event int ret ev ret exit return event ret void main void test execute states 
