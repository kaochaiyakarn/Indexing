critique standard ml andrew appel princeton university revised version cs tr november standard ml excellent language kinds programming 
safe efficient suitably concise 
aspects language 
perfect standard ml shortcomings 
cases obvious solutions cases research required 
meta language edinburgh lcf theorem proving system evolved programming environment standard ml :10.1.1.104.171:10.1.1.43.208
evolution language fairly stable 
critique language perspectives user implementor 
part describes ml pleasant language second shows language features interesting compile 
third fourth parts point ml programmers implementors deal 
supported part nsf ccr 
ml section list reasons programming ml decreasing order importance 
features language ml especially known fall surprisingly far list 
safety certain programming errors detected compiler cheaply detectable run time case allowed give rise machine implementation dependent effects terms language 
criterion give name security 
hoare 
pleasant things ml safe programs corrupt runtime system execution program faithful language semantics 
nelson divides programming languages categories bcpl family including safe algol family including pascal ada safe modula manual phrasing mathematically derived family including lisp ml smalltalk clu safe lisp programmers disable runtime type checking expensive 
course languages fortran cobol fall categories 
safe language errors program cause behavior explainable terms source language detected compile time run time 
easier reason program behavior expression uses element list assured really list misunderstood integer 
furthermore large class storage allocation mistakes common unsafe languages simply possible ml 
fallible humans attempt write large programs complicated things safety important 
course safety thing freedom bugs 
bugs understood framework language semantics formal informal 
behavior principle predicted program text 
unsafe language program bugs corrupt runtime system usually difficult diagnose disastrous effects 
safe language buggy programs stay semantic model language program development easier 
garbage collection garbage collection frees programmer calculating lifetime object order deallocate 
automatic storage management possible write programs concisely elegantly abstractly manipulate values objects addresses remembered freed 
garbage collector programmer avoid keeping unnecessary pointers useless objects lest program space occasionally may necessary analyze rewrite parts program avoid keeping data structures live chapter 
performance tuning preferable correctness tuning necessary language explicit dispose 
garbage collection difficult safe language interesting things 
ml detected run time considered exception error exceptions include events arithmetic overflow array bounds errors head empty list 
modern languages families mentioned dynamic storage allocation 
general languages mathematical category automatic garbage collection 
bcpl algol families dynamic storage longer active explicitly freed program re 
practically impossible knows safe language explicit storage deallocation 
main reason languages algol family completely safe 
pascal programs obvious put free dispose statements 
data structures get just bit complicated harder predict dispose things 
programmers resort explicit counts special purpose mark garbage collectors implemented anew class record 
problem worse module boundaries 
server module implements abstraction dynamic storage client module won know format records dispose 
server won know client finished objects 
typical solution add new operators interface freeing objects 
quickly tedious 
storage allocation bugs corrupt runtime system go undetected millions program statements executed error 
particularly nasty diagnose 
safe languages mathematical family including standard ml automatic garbage collection avoid kind bug entirely 
compile time type checking programmers mistakes 
proved algorithms correct formal informal sense difficult avoid errors translating concrete formal notation programming language 
am particularly programming mistakes average programmer 
find mistakes fix 
help programming environment give finding mistakes welcome 
practical matter vast majority mistakes compile time ml type checker 
mistakes particularly easy fix ffl compiling takes time compiling running 
ffl compilation find compile time errors harder find bugs run compile runs program 
ffl compile time errors caught regardless input data run time type errors may caught program exercised inputs 
ffl compile time errors come helpful explanations run time errors harder diagnose 
compile type types especially elegant type system ml help understand program consistent way fewer mistakes place 
interesting note languages mathematical family run time type systems lisp scheme smalltalk apl algol languages compile time type checking 
mathematical languages garbage collectors garbage collectors require run time type information trace reachable objects long type information run time data temptation knew mathematical compile time type checking ml type system invented 
course runtime type checking slow mathematical languages raw speed primary design concern 
ml absence run time checking efficient implementation discussed 
module system ml module system supporting data types hiding representations type checked interfaces 
modules important structuring large software systems 
written advantages modules data types 
classes object oriented programming kind module support abstraction nicely modules modula ada 
controversial say modules enforced interfaces representation hiding essential feature modern programming language 
ml module system particularly nice allows module parameterized interface 
ada modula support generic modules parameterized way 
ml unusual parameterized modules functors compiled code generation actual parameter 
arguments favor compile time type checking favor checking functors parsed independently arguments applied 
language parameterized modules data types necessary check type refers concrete representation time giving away representation 
ada modula checking possible compilation type checking parameterized module body done application actual parameters 
ml uses sharing spec require functor parameters representation shared data type 
example suppose signature interface hash specifies module map strings unique tokens 
certainly different ways implement signature implementation exist multiple instances maintaining different hash tables 
parser module parse signature parse produces parse trees containing tokens type checking module typecheck signature typecheck deals tokens combined module compiler functor compiler structure parse structure typecheck sharing hash hash 
advantage parameterizing compile applied different parsers different typechecking algorithms 
program meaningless particular parse module relies hash table typecheck module 
worse internal representation unique tokens sufficiently different program safe pointers integers ml module system may unique safely combining compiled parameterized modules data types 
immutable values functional language describes relationships values objects 
illustrate silly example 
consider statements programming language henceforth spec mean syntactic construct ml signatures specification general informal sense 
reason relationship ask questions ffl 
ffl modify change 
ffl need copy implement ffl re done dispose 
questions silly consider analogous case program fragment cons cons list cell 
modify car change 
copy cons cell 
dispose 
disposal question adequately handled languages garbage collection course 
update identity questions 
distracting writing understanding program worry sharing substructures side effects aliasing 
optimizing compiler distracted problems 
questions silly integers treat integers values objects 
considered integers objects command update bits integer object complexities listed considered programming integers 
values advantages objects 
sharing substructures values leads problems substructures modified 
doesn need reason equal versus identical values ensure true ml permit testing address equality immutable types 
perform induction structure prove useful things values objects induction histories complicates reasoning 
mutable objects values nice properties notion mutable objects discarded 
say updateable cells hard understand 
proved right certainly true algorithm objects simulated values algorithms readable understandable 
millions programmers sufficiently comprehended notion assignment updateable data structures write successful programs 
course argument bringing back goto kilobyte address space 
true programming updates proven technology programming entirely research 
languages combined functional style capability updates scheme example 
question styles combined losing benefits immutable values 
updates permitted silly questions posed previous section complicated answers 
ml solves problem carefully segregating mutable immutable types 
integer values type int mutable cell containing integer type int ref types 
fetch immutable value int ref bind variable type int store different immutable value int ref 
values ones questions sharing identity important 
cells components data structures 
example tree shown type immutable trees integer leaves elements tree trees leaves may modified structure immutable 
contrary leaves tree immutable structure re arranged entirely new leaves inserted datatype tree leaf int node tree tree datatype tree leaf int ref node tree tree datatype tree leaf int node tree ref tree ref mutable cells carefully identified advance compiler human reader program turned compromise 
allow value reasoning non updates necessary 
polymorphic types implicit parametric polymorphism ml great convenience 
writing pascal program deals linked lists different types objects example copy verbatim definitions functions create lists map functions lists reverse lists calculate lengths lists 
ml lisp map function operate list similarly length reverse cons 
length function polymorphic type int list int type string list int 
object oriented languages inheritance polymorphism achieved difficulty depending language 
polymorphism accomplished cast avoid type checker pascal clumsy variant records 
type inference ml necessary declare types variables functions formal parameters 
compiler infer types identifiers checks variables consistently 
ml achieves advantages compile time type checking conciseness undeclared types 
convenience course doesn shorten programs enormous factor languages explicitly declared types type declarations don overwhelm program 
big advantage type inference compiler infers general polymorphic type function 
programmer doesn tend prematurely specify types functions 
example consider writing length function compute number integers list fun length head rest length rest length nil programmer needn specify type list element head temptation hardly see section overloading 
list ml empty nil cons cell containing head element tail rest list 
list dis joint union type datatype form datatype list nil list constructors datatype nil pronounced cons 
elements list type type ff list called ff list 
keyboards don greek letters write ff 
convenient infix default nil list positive integers 
int 
length function just written type ff list int ff applied lists strings lists reals lists lists 
complete formal definition programming language pascal advance language design popular reasons 
supported clean useful control structures data structures 
small language specified precisely informal prose people understand pascal programs 
pascal ambiguities 
language definition ambiguous meaning certain constructs different compilers give different results program language insecure safe sense described hoare 
ml secure unambiguously defined 
definition standard ml complete operational semantics entire language 
definition calculate exactly programs accepted compiler result 
furthermore definition accompanying commentary readable formal semantic definitions go 
mean definition suitable manual programmer formal notation worked examples 
student language design serious compiler writer definition understand meaning construct doubt 
leads portability implementations provability programs principle confidence safety security ml programs 
definition time proved tractable serve basis useful technical discussion readers 
turned holes definition discussed repaired confidence agreement changes mean 
formal definition merely complicated charm prove important properties language 
definition mathematically tractable prove example programs type check execute safely dangling invalid pointers type inference algorithm finds general type expression theorems inspire confidence semantics language 
proponents formal specifications programming languages long claimed semantics tool language design just writing semantics existing languages 
conciseness completeness ml definition stem part reluctance standard ml design committee admit features language didn understand write provably sound semantics 
higher order functions ml scheme languages derived calculus functions class values may passed arguments returned results put data structures 
course programming language class functions important difference functional values ml ml nested function definitions lexical scope inner functions refer local variables formal parameters outer functions 
time outer function invoked different actual parameters new version inner function built 
simple example fun add int fun val add val add val twelve fun keyword introduces function declaration 
dec exp syntax introduces local declaration dec visible expression exp add applied function created returned result 
add computed function result 
imagine moment programming language character string values stored variables passed arguments returned results suppose character string literals possible extract individual characters string values 
suppose theorems mentioned proved subsets standard ml 
add function written concisely fun add int type constraint int necessary loading see section 
operators concatenate create new character string values run time 
character string type limited utility printing interactive prompts defined compile time 
data type pass compile time literals hardly class 
exactly situation function pointers 
function values created compile time new functions shown example 
allow nested functions lexical scope 
similarly modula nested functions lexical scope functions outermost level nesting passed arguments 
hand pascal allows nested functions lexical scope passed arguments returned results stored data structures 
restriction limits utility function values 
restriction pascal restriction motivated desire avoid need garbage collection class functions nested scope implemented conventional stack activation records 
system garbage collector firstclass nested functional values don add great complexity implementation language 
write programs higher order functions really appreciate expressiveness 
examples reduction functions lists take binary operator apply entire sequence values append term order appropriately handle case 
notion easily generalized operator opr identity operator reduce opr function applies operator entire list values 
function sum totals elements list just reduce product reduce 
ml write fun reduce opr fun nil rest opr rest val sum reduce op val product reduce op fun min int val infinity val reduce min infinity val fifteen sum nil op keyword allows infix operator ordinary identifier 
window manager organize window interface application running window represented keyboard mouse 
hand application characters typed window calls keyboard function give mouse clicks calls mouse function 
type keyboard string unit mouse int int unit says record type containing fields keyboard mouse 
keyboard function takes string parameter returns unit placeholder void mouse takes coordinate pair argument 
window manager pass application calling functions 
object oriented flavor private data application self oop terminology hidden free variables functions 
necessary include explicit self field record pass extra argument keyboard mouse 
interesting uses class functions combine nested lexical scope inner functions free variables bound outer functions functions returned results stored data structures 
combination left pascal difficult implement requires garbage collector activation records useful 
efficiency elegant language applications programs written run slowly 
interesting useful windowing library implemented ml gansner reppy elegant interface server 
example describe system 
important ml compiled run efficiently 
reasons believe 
ml compile time type checking means type tags need carried run time operators need check types arguments run time 
ml dynamic method lookup required objectoriented languages 
ml array bounds checking slows things safely removed optimizing compiler 
ml check pointers nil dereferencing way incorporated pattern matching feature language tests part ordinary control flow written programmer 
unfortunately programmer knows list nil check done anyway intelligent compiler 
ml checks overflow arithmetic expressions computers handled hardware need issue extra instructions 
ml efficient 
extent research question interests 
difficult question answer requires program written standard ml 
mean say program written idiomatic written idiomatic ml 
attempt quantitative measurement rewriting programs idiomatic ml vice versa running results compilers hardware 
sufficiently job people done realistic programs 
hand scheme compilers 
scheme run efficiently problems scheme common lisp sufficiently efficient real applications written 
possible get ml run efficiently scheme languages similar ways ml doesn require run time type checking scheme 
case reasonably efficient implementation ml :10.1.1.55.9444
implementations users standard ml implementations available ffl standard ml new jersey princeton university bell laboratories contact appel princeton edu ffl poly ml hardware 
contact bob ahl uk ffl ml university sussex isl uucp pop cs umass edu adequately efficient case slow order magnitude 
ml programs run compilers space comparable programs 
serious problem research chapter hinted solutions 
appears ml efficient wide variety applications 
programs faster probably factor 
purposes ml advantages safety elegance ease storage management may outweigh difference performance 
programs require complicated expensive storage management may run faster ml implementation garbage collector 
people don ml anonymous early reviewer complained ml lack dynamic types mutation lack thereof lack access machine restrictive type system small changes usually require complete recompilation bizarre syntax lack macros criticisms merit discussion 
lack dynamic types things easier dynamically typed language 
example subtyping easy lisp list real automatically subtype list real string ml doesn subtyping mechanism 
examples compelling ml program injection projection functions lisp program 
interesting dynamic types programs wish type safe structured input output problematic standard ml 
ml community type dynamic proposed solution problem values type dynamic carry full ml style types part runtime representation coerced ordinary statically typed values runtime check 
ffl edinburgh ml university edinburgh lfcs ed ac uk ffl anu ml australian national university mcn anu oz au ffl university sweden cs se restrictive type system ml type system restrictive languages allow evasion type system 
return obeying type rules programmer rewarded compile time error messages run time bugs 
mutation lack thereof ml extremely modify fields data structures fields declared advance 
just encourage functional style programming escape hatch necessary 
lack access machine ml succeeds abstracting away machine 
difficult implement programs machine level things memory words pages protections signals possible interfaces things ml admitted typical ml system large runtime system written handle things couldn implemented ml 
recompilation separate compilation essential programming environment 
languages modula system recompile just files may need dynamically typed languages lisp files modified need recompilation absence macro definitions course 
implementations standard ml usually separate compilation systems 
partly problem language elaborated section problem individual implementations 
case appears problem solved modifying language definition 
bizarre syntax lisp syntax wonderful consistency acquired taste 
standard ml syntax mediocre example algol school keywords parentheses infix operators sense 
obvious bugs grammar reported general don better things argue syntax 
lack macros clearly advantage disadvantage 
programmer calculate string string rewrite program semantic analysis invites problems worst kind 
macros attain effect line expansion functions doing done optimizing compiler 
macros attain call name effect obtained passing suspension argument ml written syntax fn 
admittedly ugly fairly concise better tolerating semantic havoc macros 
ml fun compile ml characteristics enable compilers interesting techniques applicable languages 
hand aspects language best attacked quite conventional techniques 
features ml considered annoyance challenge compiler writers described section 
safety compilers safe languages program defined result perform certain transformations compilers unsafe languages may 
example programmer access data structures official operators compiler free choose arbitrary representations different representations data structure different parts program 
unsafe language programmer access underlying bit pattern data type tends practice convention force compiler predictable choices 
example safety heading accurate control dependence 
essentially input program representation computable program compiler may extensional equality substitute representation function 
hand unsafe language aspects program represented operational semantics specifying sequence operations order rearranged 
compile time type checking compilers languages run time type checking lisp smalltalk hard minimize execution cost type checking 
advantage ml languages algol bcpl families type checking done compile time slow execution program 
representation analysis types variables ml known sufficiently compile time guarantee algol primitive operators applied values wrong type 
ml parametric polymorphism contexts inside cons function types polymorphic variables completely known 
cases program manipulates values inspecting internal representation 
order manipulate pass arguments store data structures necessary know size 
solution represent polymorphic variables bit patterns size word 
polymorphism run time polymorphic variables passed place machine code oblivious actual type 
exactly strategy implementing lisp cons function needs know size object need know internal representation objects consing 
interpreted mean variable function closure argument function represented exactly word 
natural representation value fit word list floating point number pointer heap allocated object 
source great inefficiency 
parametric polymorphism useful kind abstraction abstraction leads inefficiency 
ml programmers face tradeoff language resolved favor abstraction 
possible pay abstraction abstraction 
xavier leroy pointed necessary represent variable word just polymorphic variables 
type checker identify places values passed polymorphic variables vice versa 
compiler choose specialized representations just languages algol family variables 
extent ml program uses variables pascal program efficient pascal program 
significant savings leroy measurements show 
kind optimization impossible lisp types safely analyzed compile time 
separation static dynamic semantics ml compiler static semantics type checking dynamic semantics evaluation evaluated independently order 
compiler dynamic semantics determines machine code generated 
may interesting consequences implementation separate compilation facility 
possible generate machine code module knowing types module free identifiers 
link time module type checked types free identifiers known 
code generation expensive type checking gain significant benefit approach 
algorithms separate compilation worked implemented 
mundane advantage separation static dynamic semantics simple untyped intermediate representation translation ml intermediate representation need pay attention types 
somewhat simplifies compiler 
course representation analysis described implementation dynamic semantics dependent static semantics 
compiler uses link time type checking simpler translation intermediate representation take representation analysis 
immutable records common problem plagues optimizing compilers aliasing 
difficult determine pointers point thing inhibits certain kinds optimizing transformations 
example pascal similarly replace statement involves fetch register register move 
possibility points record aliased modify transformation invalid 
easier solve aliasing problems ml language 
don need solved 
fetches immutable objects possibly affected store instructions 
vast majority objects created immutable variety real applications fetches moved past stores procedure calls common subexpressions involving fetches immutable objects eliminated 
pleasant exploit freedom writing optimizing compiler 
mutable cells ml updateable parts data structures ref cells identified compile time 
useful garbage collector 
generational garbage collectors segregate heap allocated records age 
records initialized point existing records created newer records usually point older records 
way older record point newer record update older record newer created 
generational collectors need efficiently identify cells older generation updated point newer generation 
ways keep track updated cells 
software approach compiler generate code assignment statement keep list cells updated 
necessary put newly allocated cells list course 
compiler needs distinguish initializing store instructions updating stores 
easy ml lisp language records initialized allocated 
difficult algol languages records created uninitialized stored initialize 
alternate approach updates virtual memory hardware computer 
making older generations read updating store cause page fault 
fault handled making page writeable marking objects page possibly updated 
updates object nearby objects incur cost fault 
page technique best locality updates 
best example put mutable objects close small set pages fewer updating page faults occur 
possible runtime system guess objects updated 
fortunately ml ref cells distinguished immutable records data constructors closures created 
compiler mark ref cells allocated allocate different area memory runtime system rely marking 
technique possible lisp object principle updated objects updated practice 
interesting compare ml allows programmers execute updating side effects lazy functional languages haskell garbage collector point view 
generational garbage collectors hate updates existing objects glance purely functional language assignment statement easier garbage collect 
lazy languages constantly updating lazy closures thunks results evaluating 
paradoxically collector viewpoint ml fewer assignments haskell garbage collection ml efficient 
accurate control dependence statement guarded conditional said control dependent conditional 
definition refined safe languages ml 
consider ml fragments fragment case 
nil 
case 

nil 
link case fetch guarded conditionals 
compiler wish hoist fetch inner conditional improve instruction scheduling register allocation 
case nil fetch nil illegal target machine 
pattern ensures cons cell 
case clearly permissible hoist fetch validity pointer affected value example tell relationship programmer know length linked list fetch hoisted value unrelated nil fetch hoisted 
ml provides precise information compiler true control dependences fetches 
summary safety language gives tool reasoning accurately control dependencies 
pointer equality pointers ml tested identity 
ref cells program determine similar objects located address 
non objects updated program perform experiment modifying object seeing changes 
unusual feature leads interesting consequences 
compilers perform common subexpression elimination record expressions 
program val val val line implemented val compiler 
transformation lisp pascal language program able test pointed address 
compilers garbage collectors 
record created similar record exists special hash table pointer existing record making new 
systems allow address comparisons hash consing entail observable semantic change program ml 
hash consing may slow 
consider variation generational garbage collector hash merging objects survive second generation 
necessary hash small percentage objects get allocated objects survive garbage collection 
idea implemented marcelo goncalves princeton university 
garbage collectors move object place need update pointers object 
concurrent garbage collector trouble finding pointers quickly 
case usable copies object old new pointers forwarded 
distributed systems copy objects worrying identity 
suppose want distributed nature system transparent programmer 
processors want look data structure time obtain adequate performance necessary copy pieces data structure different processors 
conventional programming language worry address identity making updates visible processors 
problems usually solved hardware snoopy caches 
ml worries updates disappear values rare conventional synchronization message passing adequately efficient 
module system run time aspects module system turn simple 
structure exports types values implemented ordinary tuple types needed compile time 
functors implemented functions take structures tuples arguments return structures results 
inter module linkage expressed way conventional link loader necessary particularly convenient interactive system load execute programs modules fly 
class continuations interesting powerful feature scheme call current continuation mechanism dynamic calling context function abstracted function 
standard ml class continuations turns easily introduced fit nicely ml type system 
class continuations easy implement coroutines generalization lightweight processes 
low level details ordinarily confronted implementations allocation new activation stacks interface mechanisms saving registers invoke new thread neatly encapsulated continuation mechanism 
thread scheduling efficient done client process requiring hardware operating system context switches synchronizing interleaving thread executions 
operating system research shown operating system schedule processors client programs manage processes take advantage efficiency user mode schedulers 
ml extended class continuations scheduler source language program manipulates continuations directly 
approach elegant robust proved successful concurrent ml ml threads quite different concurrent programming environments ml 
ml traps pitfalls syntactic semantic pitfalls ml programmer encounters severe numerous described languages example 
misspelled constructors known dangerous pitfall awaiting ml programmer misspelling constant data constructor pattern 
syntactic distinction constructors variables identifier declared constructor understood compiler constructor identifier interpreted variable matches 
misspelled constructor looks variable accepted compiler 
example misspelling nil implementation length causes function return zero fun length nill length head rest length rest cases pattern match redundant rules result programmer mistake 
compiler warns redundant rules error detected way 
cases 
warning messages easily ignored programmer 
approach prolog takes solve problem constructors syntactically different variables prolog constructors lower case variables upper case 
solution quite ml reasons ml allows symbolic identifiers don letter upper lower case rule wouldn apply ml allows data constructors thinned identically named value bindings module interfaces seen constructor module seen function variable module 
small things cute minimally useful programmers easily absence 
variation prolog approach solve problem significantly altering nature standard ml 
haskell language uses approach 
overloading languages support kind overloading operators known ad hoc polymorphism 
simplest form means operator applied integer arguments yielding integer result real arguments yielding real result 
parametric polymorphism ml lisp functions cons map algorithm implement different integers reals implementation cons types 
languages algol bcpl families overloaded operators built overloading resolution determination argument types implementation function compile time 
languages mathematical family typically overloading resolution run time 
languages families allowed programmers define new overloaded identifiers specify implementation function argument type 
object oriented languages especially sophisticated support user defined overloading 
compile time overloading resolution polymorphic type inference 
processing function definition fun double impossible know compile time implemented integer floating point addition 
dangerous trap programmer ambiguous function double caught compile time type checking error programmer fix problem presumably inserting type constraint fun double real frequent annoyance writing program integers am just thinking real numbers am constantly surprised see overloading resolution failures 
teaching language qualify statements ml type inference algorithm derive general type expression technicalities half dozen built operators 
way solve problem allow run time resolution overloading language haskell extensions typed lambda calculus :10.1.1.47.1059
languages class operators passed runtime implicit extra arguments functions take polymorphic overloaded types arguments 
mechanism dynamic semantics dependent static semantics precludes certain kinds separate compilation schemes 
haskell uses heavyweight mechanism apparently small gain 
making non overloaded identifiers wouldn programs bigger just different names different operations 
am asked seriously mean floating point addition represented symbol 
exactly mean standard ml provides half dozen overloaded operators anyway admittedly ugly symbol reasonable price pay deletion overloading language 
designers standard ml considered problem carefully came opposite matter taste 
weak type variables ml type system type inference algorithm works effectively programs side effects 
particularly important types intuitive inferred types natural obvious programmers cases 
long known algorithm polymorphic 
illustrate oft example consider val fn true function type ff ff ff correctly applied int bool 
polymorphic function type inference algorithm naively applied 
natural give polymorphic types ref operators ref ff ff ff ref ff ff ref ff unit ff ff ref ff try type check expression val ref fn fn true type ff ff ff ref program inappropriately type check go wrong run time incrementing boolean 
naive polymorphic type checker proved inadequate handle cells 
appropriate type ff ff ff ref quantifier nested inside ref constructor ml type inference system cope inner quantifiers 
cardelli ml compiler initial proposal standard ml required cells completely monomorphic compiler able infer type type variables argument ref constructor :10.1.1.43.208:10.1.1.43.208
certainly safe insufficiently flexible 
tofte generalized idea introducing weakly polymorphic imperative types 
allow function creates applied type long type monomorphic 
tofte imperative types substantial improvement usable language adopted part standard ml definition 
tofte scheme flexible 
particular naturally higher order functions currying function imperative type lead function rejected tofte algorithm 
macqueen solved problem assigning numerical weakness indices type variables 
macqueen scheme strictly powerful tofte implemented standard ml new jersey 
macqueen weak types aren easy programmers understand 
difficult infer types functions ref cells typically write expression get compiler print type writing module signatures approach interface design opposite usually recommended 
annoying thing tofte macqueen imperative types visibility locally interface descriptions 
consider function sort int list 
int list list pairs element pair integer key second element arbitrary type course type element list 
sort function returns list sorted key 
easy write purely functional quicksort merge sort solve problem efficiently 
suppose expects integers range list contain thousands elements 
bucket sort faster array elements 
array returned sort retained way sort returns type bucket sort program sort int list 
int list indicating non key elements list polymorphic values 
bad purely internal data structure mentioned interface 
researchers engaged devising better type inference systems polymorphic programs indicates problem type checking regarded solved systems address problem internal temporary described 
ml grammar designers standard ml worked hard get semantics right define semantics completely formally possible 
unfortunately attention paid syntax 
years algol fifteen years yacc definition standard ml contain unambiguous context free grammar syntax language 
grammar ambiguous reasons parser guess identifier pattern variable constructor guess identifier defined infix precedence associativity 
problems difficult solve semantically 
example think expression parsed differ infix operator solution parse expression sequence atoms implement simple precedence parser lines code sml nj semantic action infix operators 
problem ml context free grammar grammar clearly specified definition 
immediately runs problems wants implement parser ml 
language definition include complete lr grammar reduce reduce conflicts shift reduce conflicts possible 
implementor intends parse different strategy ll recursive descent lr grammar useful starting point 
standard ml new jersey implementation uses grammar terminals nonterminals productions lalr states :10.1.1.55.9444
languages shift reduce conflict 
expression clear supposed match second 
customarily resolved saying innermost case second matched lr parser resolve conflict shifting 
ml cleverly avoids problem requiring clause 
similar problem occurs case expressions case 
case 

pattern part case case 
definition says corresponds resolving shift reduce conflict favor shift 
shift reduce conflict standard ml new jersey grammar 
programmers grown accustomed behavior 
ml programmer fall case trap write pattern matches 
solution enclose inner case expression parentheses problem didn occur place 
extra parentheses ugly 
fact having shift reduce conflict grammar ugly 
better solution require case fn expressions example written case 
case 

ambiguity 
matter taste extra parentheses 
syntactic glitches 
clearly intent designers semicolons optional declarations 
declaration val val meaning semicolons 
thing semicolons cluttering programs prose matter 
turns structure declaration functor declaration semicolon required structure declarations functors 
apparent reason discrepancy syntax module declarations carefully thought 
heard different people find ml syntax confusing ugly difficult learn 
ml programmer am quite comfortable ml syntax frequency complaints serve hint opportunity syntax designer rare taste genius 
infix operators programmers may define new infix operators standard ml may give precedence higher number indicates tighter binding left right associativity 
programmer wants define exponentiation operator right associative tighter binding multiplication declaration infixr works quite 
definition states infix infixr dictate left right associativity respectively association left different operators precedence 
rule 
consider list datatype datatype list nil list list infixr flavors cons cells 
expression nil intended list integers marked just nil ordinary list integers 
ml top level read eval print loop adds twists discussed 
cases cons operators meant associate right 
ml definition requires list expression associate left different operators precedence 
definition meant say operators precedence opposite associativity associate left 
better rule left right associative operators precedence don mix parentheses rule haskell 
infix vs modules infix declarations exported modules specified signatures 
significantly useful 
example implements module vector implement random access integer keyed tables want signature signature vector sig type vector val vector list 
vector val sub vector int 
structure vector vector 
want sub infix operator expressions sub getting ith element vector 
vectors module refer vector creation function vector vector subscript function vector sub 
convenient write open vector inside vector sub prefix write infix sub signature vector sub operator won infix separate infix sub declaration idea module system arbitrary piece static environment encapsulated open environment scope 
prohibiting encapsulation fixity portion static environment definition infix declarations second class 
argument allowing open fixity declarations programs hard understand interpretation fixity operator understood looking lexically upwards text program declaration identifier notice open module identifier vector 
argument applies declarations implicitly introduced open just fixity declarations 
semantics type value operator determined lexically open programmer parse operators doesn know badly isn sure operator precedence 
definition page states liberal scheme consideration allow infix specs signatures open declaration re install operators 
scheme implemented standard ml new jersey quite convenient :10.1.1.55.9444:10.1.1.55.9444
separate compilation ml language definition purposely quite vague pragmatics putting programs 
definition chooses pretend programs typed interactive top level read eval print loop vaguely fact programs compiled files 
reasonable wrong defining programming language tying concrete details operating systems file systems 
far better aspect language get wrong 
modern languages module facilities including modula ada usually specify quite clearly parts program compiled separately rest program file generally requires files compilation files modula definition specific organization compilation units 
ml elaborate module system module separately unit 
necessarily case structures free structure identifiers sufficiently specify importing 
commentary suggests severe restrictions module system allow separate compilation 
relationship structures modules separate compilation 
fact implementations function called allows files compiled disagree semantics nested uses 
structures structure definition ml constrained signature representations types hidden show 
declaration module implementing complex numbers signature complex sig type complex val complex complex 
complex structure complex complex struct type complex real real val op fn theta complex theta complex 
theta theta hide fact polar representation structure declarations constrained signatures allow type sharing information show constraint 
modules complex structure able access components complex number import complex parameter functor 
people learning ml surprised signature declaration mention representation 
cases transparency signatures necessary useful cases useful module system implement data types 
macqueen original module proposal provided abstraction special kind structure declaration type representation sharing information specified signature constraint hidden 
giving programmers choice structure abstraction better support programming data types 
datatypes hidden representations apple pie modern software engineering rightly 
course exist mechanisms data types standard ml abstype functor 
particularly convenient data types module level abstraction straightforward abstype 
functors clumsy mechanism structuring programs 
commentary definition shows abstraction semantically problematical page gives useful generalization macqueen proposal 
feature omitted definition 
open signatures customary writing modular software specify interfaces modules implement modules meet interfaces 
programmer develops implementation practice pretend writing interface signature cleaning implementation necessary meet signature 
reader program understand interfaces generally concise implementations proceed learn implementation module time 
signatures standard ml module system support writing clear interface specifications 
imagine interface definition says effect signature defined interface happens met implementation module understand read entire implementation inferring types values keeping track identifiers visible outermost scope 
right thinking software engineer certainly method defining interfaces 
exactly provided open specs signatures 
signature signature sig open specifies interface just largest interface obtained elaborating structure open spec may symmetrical theoretician may technically useful defining semantics rest module system 
place real programming language 
related problem overlapping open include specs 
open include effect including identifiers easy programmer purposefully include different signatures containing type value structure identifier 
ambiguity semantics spec takes precedence multiple definitions scope specs complicated follow implementation semantic analysis signatures sharing difficult 
scope rules ml expressions simple completely trivial appropriate programs complicated things 
sharing constraint relate signature interface free structure 
problematical reader program effect visibility names 
worthwhile strive extreme simplicity interface signature definitions scope rules signatures trivial 
clear understanding interfaces program prerequisite understanding program 
removing open local include specs standard ml result cleaner interfaces causing great inconvenience 
arguments include helps writing concisely signature modules satisfy different specifications 
consider signature hash values signature group mathematical group structures signature hash sig type value val hash value 
int signature group sig type elem val id elem val elem elem 
elem val inverse elem 
elem combined signature groups 
include write signature sig include hash include group sharing type value elem substructures serve concisely include signature sig structure hash structure group sharing type value elem fact approach robust unfortunate naming coincidences signatures distinguished qualified identifiers imagine hash signature identity function id value value 
disadvantage client open qualified identifiers id id problems compiling ml ml designed compiled things evaluated compile time 
ml static types am proposing remove open declarations expressions just open specs signatures 
static lexical scope statically checked modules 
aspects language design hard compile efficiently 
polymorphic equality ml operator test equality values type 
values types integer real string may tested equality values function type may 
types programmer purposely hidden representation admit equality equality types 
values record type datatype built equality types may compared equality 
equality records lists structural record equal way tell records address 
complication 
consider program fun andalso val val fn illegal 
fn fn function type resembling ff ff ff ff bool pass integers strings lists real numbers 
pass values type int int admit equality declaration illegal 
tell functions equal compiler able tell give results inputs difficult 
standard ml problem resolved introducing equality type variables instantiated types admit equality 
type ff ff ff ff bool substitute int ff int int 
ascii ml program equality type variables written starting just 
clever solution introduces kinds problems ml language 
static semantics language complicated 
code generation runtime system require unpleasant special cases 
programming equality types isn idea 
static semantics language designers worry type constructors admit equality specs signatures types admit equality propagation equality property sharing constraints functors 
definition standard ml fewer pages mention syntactic semantic aspect equality types approxi mately pages definition 
ramifications equality similarly standard ml compiler 
equality types add significant complexity language implementation 
dynamic semantics respect type checking ml program distinct evaluation program 
type checking done compile time type tags need carried runtime objects 
saves considerable space time important features language 
function able test variables equality type variables polymorphic known run time 
ways accomplished 
runtime representation object sufficient tag information determine object pointer fields pointed record record ref cell 
equality interpreter recursively traverse data structures test bitwise equality structural equality pointers 
believe solution chosen existing ml compilers 

representation formal parameter type polymorphic equality type variable pair field value second field function testing equality values type 
function implicit parameters perform equality testing 
solution adopted haskell generalizes notion equality types include kinds overloading 
disadvantages solution 
requires runtime tags necessary ordinary execution 
argument tags allow garbage collector traverse pointers records 
possible devise garbage collector relies static type information computed compile time runtime tags data 
furthermore conventional garbage collector big bag pages scheme groups objects similar type page tag suffices 
runtime equality interpreter faces complex task understanding structure objects 
provision implicit arguments functions workable inelegant 
commentary standard ml states static dynamic semantics studied independently 
preface structuring compiler convenient translation expressions machine language independent types expressions 
requiring expressions treated specially depending types corrupts interface components compiler 
programming equality types example utility equality types implementation sets union intersection lists 
fun set nil fun member nil false member orelse member fun union member union union union nil functions sets elements type ff long ff admits equality doesn contain components functional type 
programmer doesn provide explicit equality function compiler figures 
significant problems program problems sufficiently general may affect program equality type variables 
set union function takes quadratic time 
realistic program deals sets want set union take linear time done sort ordering comparison operator available elements way hash elements integer values 
production quality set abstraction parameterised just equality function 
second consider happens sets sets 
example val union set set val union set set val set val member set single element set line tests set membership 
course program tell fag violates set abstraction 
problem structural equality wrong equality sets programmer really provide function tests sets elements 
implicit structural equality bad programming practice 
programmer provide explicit equality function explicit function efficient explicit function right semantics application 
reasonable compromise allow kind statically overloaded equality function kind earlier versions standard ml 
equality operator worked nonfunctional monomorphic type 
operator quite convenient programmer unduly complicate language semantics compiler runtime system 
half pages definition mention equality equality attributes cease interact type checker module system equality interpreter needed runtime system 
admitted solution ml overloading left principal types cases 
datatype representations recursive data types declared ml datatype defines constructors associated types disjoint union type 
linked lists just special case general notion 
runtime representation typical datatype element consists constructor associated value 
straightforward implementation representation element record field containing small integer tag standing constructor containing value ml polymorphic types pages definition mention equality pages longer need 
value size word typical implementation 
scheme applied datatype list require representation pointer element record containing constructor value value pointer pair containing element list requires cons cell 
cardelli ml compiler avoided advantage fact runtime representation values pointers distinguished small integers :10.1.1.43.208:10.1.1.43.208
compiled code tell constructor nil applied seeing value small integer nil pointer 
pointer point directly record containing representation lists cardelli compiler subsequent ml compiler just representation lisp 
fact compilers generalize idea slightly datatype just non constant constructor number constant constructors non constant constructor carries value represented pointer extra indirection carry constructor necessary 
consider perfectly legal standard ml program functor type datatype list nil struct 
structure datatype list nil list type list compiling functor compiler know representation pointer explicit indirection record constructor representation list 
compiling structure actual parameter datatype list value carried record pointer 
representation chosen compiler cardelli optimization 
lists created outside passed functions inside program go wrong different compilation units disagree representation lists 
standard ml permit cardelli optimization implementations alternative expensive 
problem bit general 
possible generalizations cardelli technique aim making representations datatypes compact efficient 
techniques functor boundaries 
cardelli technique variant idea pay abstraction things 
leroy representation analysis applies functions cardelli data structures 
appears idea apply recursive datatypes standard ml extremely unfortunate 
believe problem lies partial abstraction datatypes 
example programmer abstracted ff ff list ff abstracted datatype list 
unusual program 
point concrete datatype programmer wanted type interface parameter wouldn mentioned datatype 
solution problem change slightly notion datatype 
saying datatype disjoint sum types say disjoint sum product types 
value carried constructor just type record type 
note exactly way variant record works pascal 
problematic program legal 
functor definition allowed datatype actual parameter match datatype formal parameter 
slight restriction allow compilers efficient representations concrete datatypes ml 
experimenting implementation representation consequent language restriction explore tradeoff 
think compiler represent element int int list triple int int tail pointer 
product type int int part datatype part type parameter list constructor 
lead problems polymorphic functions list types applied specially represented lists 
optimization problems functor boundaries function boundaries 
cardelli course compiling language functors 
initial basis definition specifies initial basis set predefined types values exceptions built functions ml system 
include arithmetic operators integers reals string concatenation operators lists 
initial basis large write real programs nontrivial input output interact operating system 
perfectly acceptable language definition library module 
type module systems standard ml adequate describe appropriate libraries important 
initial basis rough edges ffl functions reading writing strings characters converting integers single character strings back concatenating strings exploding strings lists single character strings concatenating list strings way access ith character string constant time substring operator 
way extract internal character string explode string traverse resulting list takes time linear length string 
ffl way updateable arrays constant time access arbitrary elements 
arrays simulated lists trees ref cells access update operations take linear logarithmic time 
updateable arrays certainly place language updateable refs 
ffl arithmetic operators may overflow case definition prescribes raise sum exception raise prod exception 
extremely inconvenient implementor distinct exceptions different operators computers don raise separate hardware exceptions different kinds overflow 
programmer served just single exception called overflow 
ffl bit string type bitwise logical operators integer type 
applications bitwise operators graphics number theory cryptography areas 
hand worth noting ml div mod rounding behavior negative infinity zero allow shifts masks defined powers compilers optimize case principle 
ffl input output error io exception raised string argument 
format argument specified definition format provide formation serious applications 
preferable leave contents string unspecified prematurely settling inadequate standard 
ffl finish trivial note list concatenation operator declared infix associating left 
programs compute result right associativity run faster copy left argument right 
worth noting implementation ml cardelli constant time array subscript efficient substring function definition provided helpful standardization 
popularity ml increasing language writing real programs starting point theoretical investigations type theory language design 
programmers note points ml discussed general important criticisms tend narrow technical important 
theorists note criticisms minor theoretical interest affect usability language 
theorists anticipate designing language someday want remember critique classics genre 
acknowledgment doug mcilroy anonymous referee valuable comments 
military standard ada programming language 
technical report mil std department defense naval publications forms center philadelphia pa 
thomas anderson brian bershad edward lazowska henry levy 
scheduler activations effective kernel support userlevel management parallelism 
acm trans 
computer systems february 
andrew appel 
runtime tags aren necessary 
lisp symbolic computation 
andrew appel 
compiling continuations 
cambridge university press 
andrew appel david macqueen 
standard ml compiler 
gilles kahn editor functional programming languages computer architecture lncs pages new york 
springer verlag 
andrew appel david macqueen :10.1.1.55.9444
standard ml new jersey 
martin wirsing editor third int symp 
prog 
lang 
implementation logic programming pages new york august 
springer verlag 
luca cardelli :10.1.1.43.208
compiling functional language 
symp 
lisp functional programming pages new york 
acm press 
clinger lars thomas hansen 
explicit deallocation really faster garbage collection 
unpublished manuscript 
eric cooper gregory morrisett 
adding threads standard ml 
technical report school computer science carnegie mellon university pittsburgh pa december 
luis damas 
type assignment programming languages 
phd thesis department computer science university edinburgh 
bruce duba robert harper david macqueen 
typing class continuations ml 
eighteenth annual acm symp 
principles prog 
languages pages new york jan 
acm press 
gordon milner wadsworth 
edinburgh lcf 
springer verlag new york 
hoare 
hints programming language design pages 
prentice hall 
keynote address acm sigplan conference 
report programming language haskell version 
technical report technical report yale university glasgow university august 
report programming language haskell non strict purely functional language version 
sigplan notices may 
kathleen jensen niklaus wirth 
pascal user manual report 
springer verlag new york 
pierre jouvelot david gifford 
algebraic reconstruction types effects 
eighteenth annual acm symp 
principles prog 
languages pages new york jan 
acm press 
stefan kaes 
type inference presence overloading subtyping recursive types 
proc 
acm conf 
lisp functional programming pages 
acm press 
brian kernighan dennis ritchie 
programming language 
prentice hall englewood cliffs nj 
andrew koenig 
traps pitfalls 
addisonwesley reading mass 
xavier leroy 
unboxed objects polymorphic typing 
nineteenth annual acm symp 
principles prog 
languages pages new york january 
acm press 
xavier leroy michel mauny 
dynamics ml 
hughes editor functional programming languages computer architecture th acm conference lncs pages 
springerverlag 
xavier leroy pierre weis 
polymorphic type inference assignment 
eighteenth annual acm symp 
principles prog 
languages pages new york jan 
acm press 
henry lieberman carl hewitt 
real time garbage collector lifetimes objects 
communications acm 
john lucassen david gifford 
polymorphic effect systems 
fifteenth annual acm symp 
principles prog 
languages pages new york jan 
acm press 
david macqueen 
modules standard ml 
proc 
acm conf 
lisp functional programming pages new york 
acm press 
david macqueen 
weak types 
distributed standard ml new jersey 
robin milner 
theory type polymorphism programming 
journal computer system sciences 
robin milner 
proposal standard ml 
acm symposium lisp functional programming pages new york 
acm press 
robin milner mads tofte 
commentary standard ml 
mit press cambridge massachusetts 
robin milner mads tofte robert harper 
definition standard ml 
mit press cambridge ma 
greg nelson editor 
systems programming modula 
prentice hall englewood cliffs nj 
scott nettles james toole 
carnegie mellon univ pittsburgh pa personal communication scott nettles 
rees clinger 
revised report algorithmic language scheme 
sigplan notices 
john reppy 
concurrent programming events 
technical report cornell university dept computer science ithaca ny 
john reppy emden gansner 
exene library manual 
cornell univ dept computer science march 
colin runciman david wakeling 
heap ing lazy functional programs 
technical report university york dept computer science york dd united kingdom april 
zhong shao andrew appel 
recompilation 
proc 
twentieth annual acm sigplan sigact symp 
principles programming languages page appear 
acm press 
robert shaw 
improving garbage collector performance virtual memory 
technical report csl tr stanford university palo alto ca 
jean pierre talpin pierre jouvelot 
polymorphic type region effect inference 
technical report emp cri ecole des mines de paris february 
mads tofte 
type inference polymorphic 
information computation november 
david ungar 
design evaluation high performance smalltalk system 
mit press cambridge ma 
philip wadler 
essence functional programming invited talk 
nineteenth annual acm symp 
principles prog 
languages pages new york jan 
acm press 
philip wadler stephen blott 
ad hoc polymorphism ad hoc 
sixteenth annual acm symp 
principles prog 
languages pages new york january 
acm press 
mitchell wand 
continuation multiprocessing 
conf 
record lisp conf pages new york august 
acm press 
welsh hoare 
ambiguities pascal 
software practice experience 
niklaus wirth 
programming modula 
springer verlag new york ny 

