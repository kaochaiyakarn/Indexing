pro le guided compiler optimizations rajiv gupta university arizona tucson arizona eduard institute software science university vienna vienna austria zhang university arizona tucson arizona traditionally compile time optimization algorithms applied conservatively situations known optimization de nitely applicable bene cial 
conservative approach fails exploit valuable optimization opportunities 
pro le guided optimizer uses program execution pro le ways aggressively optimize program 
pro les identify new optimization opportunities frequently observed program execution detected static analysis 
second pro les carry sophisticated cost bene analysis apply transformations improve performance part program expense performance loss part program 
di erent types optimizations require di erent types pro le data 
chapter illustrate control ow value address pro les selected classical code optimizations memory optimizations 

past decades numerous compile time optimizations developed speed execution programs 
application typical optimization viewed consisting primary tasks uncovering optimization opportunities static analysis program transforming program exploit uncovered opportunities 
early classical code optimizations simple performance model 
optimizations de ned application considered positive impact performance 
focus research developing aggressive analysis techniques uncovering opportunities optimization greater numbers designing powerful program transformations exploit uncovered opportunities 
simplicity approach attractive years recognized approach optimizing programs serious drawbacks 
hand approach fails exploit opportunities optimization hand may apply optimizations may adverse impact performance 
rst drawback remedied employing combination static analysis execution pro les detect optimization opportunities 
second drawback addressed sophisticated performance model application optimizations 
particular cost bene analysis program transformation carried applying appear compiler design handbook optimizations machine code generation 
mation 
adequate pro le data broad categories optimization opportunities exploited optimization opportunities uncovered static analysis exploitation involves performance trade situations analysis phase optimization algorithm may successful uncovering optimization opportunity transformation phase may require cost bene analysis determine optimization opportunity exploited 
example transformation may represent trade improved performance part program degraded performance part program 
optimization opportunities uncovered static analysis frequently observed exist program execution 
program optimizations designed exploit characteristics values representing data addresses encountered various instructions program execution 
static analysis relate values variables amenable identifying speci values involved 
example examining statement statically determine statement increments value 
general able determine exact value value may depend number runtime factors program input number times statement executed illustrate scenarios consider example shown fig 

consider rst scenario 
original code contains optimization opportunity 
conditionals evaluate true expression computed twice 
determination statically analyzing program 
optimize program may wish transform code shown fig 

transformation removes redundant evaluation true evaluations conditionals 
consider execution corresponding false evaluations conditionals nd evaluation introduced transformed code prior transformation 
conclude transformation useful line executed frequently line 
simple cost bene analysis expected execution frequencies various statements program decide transformation applied 
consider instance second scenario 
assume static analysis identify speci values associated variable program execution 
pro ling execution program may determine frequently value line 
pro ling identi ed optimization opportunity detected static analysis multiply operation line frequently optimized away 
transform program shown fig 

multiply operation line executed conditionally transformed code 
extra instructions required check value accordingly update important ensure bene eliminating multiply operation greater cost executing extra instructions 
simple cost bene analysis expected frequencies variable 
endif endif original code endif endif redundancy removal 
endif endif strength reduction fig 

examples pro le guided transformations 
value value line determine transformation applied 
example fig 
illustrated execution pro les detect optimization opportunities identify bene cial transformations context classical optimizations similar situations arise context memory optimizations discussed chapter 
reason increased relevance pro le guided optimizations opportunities optimizations exploited processors past exploited due advanced hardware features modern processors 
support safe speculative execution predicated execution helpful carrying pro le guided optimizations 
example multiple operation fig 
replaced divide operation placement line result divide zero exception may occurred original program execution 
redundancy removal transformation rendered illegal 
ia processor provides hardware support suppressing spurious exceptions allows optimization divide operation carried 
support predicated execution provided ia enable ecient implementation strength reduction transformation shown example enables conditional execution multiply operation introducing additional branch instructions 
discussion clear cost bene analysis integral part optimization algorithm 
cost bene analysis program execution carried provided estimates execution frequencies various runtime events relevant program performance impacted program transformation 
example cost bene measured terms number instructions cycles may case 
situations bene may measured terms anticipated reduction number instructions cost may measured terms code growth resulting transformation 
optimizations essentially perform code specialization results code growth 
pro le guided compilation process summarized fig 

pro optimizations carried instrumented version program run representative inputs collect pro le data 

pro le data optimizing compiler recompile program generating optimized code 
selection representative inputs important optimizations expected bene cial pro le data collected relatively insensitive wide range inputs program expected executed 
chapter devoted static pro optimization programs concept pro le guided optimization dynamic optimizers 
contrast techniques described chapter pro ling optimization techniques employed dynamic optimization extremely light weight 
program execution profile guided optimizing compiler compiler instrumented representative program input program profile data optimized code fig 

pro le guided optimizing compiler 
remainder chapter organized follows 
section provide brief overview types pro le data guide wide range optimizations 
section discuss role pro les carrying classical optimizations 
illustrates principles pro le guided optimization depth look partial redundancy elimination algorithm 
section discuss role pro les carrying optimizations improve memory performance program 
concluding remarks section 
types profile information pro les provide summary information past program executions guide program optimization 
di erent types optimizations require di erent types pro les 
particular types pro le information practice control ow pro les value pro les address pro les 
section brie discuss pro le types including types optimizations 
control flow pro les form pro le captures trace execution path taken program 
trace represents order nodes corresponding basic blocks program control ow graph cfg visited 
refer pro le program control ow trace cft 
examining cft compute execution frequency program subpath 
expected extremely large size representations maintain compressed form considered 
compressed forms referred program paths 
larus sequitur algorithm compression zhang gupta proposed alternative redundancy removal techniques compression 
compression extremely large 
practice number approximations cft directly measure execution frequencies selected program subpaths 
pro les di er degree approximation involved cost collecting 
proposed approximations control ow pro les include node pro les provide execution frequencies basic blocks control ow graph 
optimizations pro les adequate 
example making code placement decisions illustrated redundancy removal transformation fig 
node pro les sucient 
edge pro les provide execution frequencies edge control ow graph 
overhead collecting edge pro les comparable overhead collecting node pro les 
edge pro les superior node pro les edge pro les computed node pro les node pro les computed edge pro les 
edge pro les widely 
edge pro les provide execution frequencies pair consecutive edges control ow graph 
clearly superior edge pro les 
edge pro les computed edge pro les 
reverse true 
edge pro les derive increased power ability capture correlation executions consecutive conditional branches 
path pro les provide execution frequencies acyclic subpaths control ow graph acyclic intraprocedural 
path acyclic include loop back edge intraprocedural terminates exit node procedure reached 
path pro les precise edge pro les acyclic components control ow graph capture correlation multiple conditional branches acyclic graph 
edge pro les capture correlation pair conditional branches cyclic path path pro les 
relative precision control ow pro les 
pro les derive estimate execution frequency arbitrary subpath program 
precision estimate vary type pro le data 
examine subpaths execution frequencies directly measured pro ling algorithms distinguished important characteristics 
lengths subpaths execution frequencies collected vary 
second degree overlap subpaths may executed varies 
table fig 
gives length overlap terms number nodes pro le types 
table conclude relationships precisions pair pro le types 
example edge path pro les comparable greater degree overlap allows longer paths 
precision relationships summarized hierarchy shown fig 

illustrate estimation execution frequency program path various types pro les 
estimate exact obtain lower upper bounds execution frequency 
lower upper bounds path means path de nitely 
node edge edge path length nodes overlap nodes edge path program path edge node fig 

relative precision control flow pro les 
executed times potentially executed times 
fig 
shows sample control ow graph complete control ow trace program execution 
node edge edge path pro les corresponding program execution 
estimate frequency path various pro les 
pro le node edge edge path freq 
estimate path fig 

example control flow pro les 
estimate node pro les 
examine execution frequencies nodes path minimum frequency encountered node upper bound execution frequency path 
nd lower bound execution frequency path rst consider lower bound execution frequency subpath 
node executed times lower bound execution frequency 
considering execution frequency node lower bound execution frequency path 
conclude path executed times potentially times 
estimate edge pro les 
examining edge pro les conclude subpaths fgk executed exactly times respectively 
conclude path executed times potentially times 
algorithm deriving estimates 
estimate edge pro les 
case edge pro les deduce subpath frequency 
frequency subpaths efg efh measured directly respectively 
conclude path executed times possibly times 
estimate path pro les 
path pro ling execution frequency path directly measured acyclic path 
know execution frequency exactly 
cost collecting pro les 
collect pro les execute instrumented versions program 
instrumentation code introduced depends type pro les collected 
general overhead instrumented code linear length program execution techniques employed reduce overhead 
collection node pro les instrumenting basic block collect execution frequency introduce counter control dependence region program 
execution frequency basic block equal sum execution frequencies control dependence regions belongs 
far fewer control dependence regions basic blocks approach reduces overhead pro ling 
fig 
basic blocks belong control dependence region identical execution frequencies 
single shared counter measure execution frequencies 
similarly edge control ow graph need instrumented execution frequencies edges computed execution frequencies edges 
fig 
edges fg gk frequency instrumented 
frequencies edges df ef fh known exceptions deduce frequency edge fg 
collection edge path pro les expensive 
computation optimized reducing instrumentation points 
algorithm reduce overhead instrumentation code 
collection path pro les 
path acyclic graph assigned unique number 
form instrumentation computes path number traversed 
reaching path path number available update frequency counter associated path 
carefully placing instrumentation code number instructions needed compute path number minimized 
value pro les value pro les identify speci values encountered operand instruction frequencies values encountered 
example fig 
illustrates form pro les 
information compiler recognize operands constant utilize information carry value specialization optimizations constant folding strength reduction motion nearly invariant code loops 
fig 

sample value pro les 
number instructions program large operand instruction may potentially hold large number values collection complete value pro les practical 
reduce size pro le data execution time overhead pro ling steps taken 
frequently appearing values collected operand 
calder proposed maintaining top value table tnv register written instruction 
tnv table entry contains pair values value frequency value encountered 
frequently lfu replacement policy choose entry replacement table full 
exclusively lfu policy updating tnv values encountered program may able reside table encountered frequently 
may repeatedly replaced 
avoid situation regular intervals bottom half table cleared 
clearing part table free entries created values encountered program 
number entries table clearing interval carefully tuned get results 
collecting top values reduces pro ling overhead convergence steady state easier faster reach 
second complimentary approach reducing pro ling overhead collect value pro les interesting instructions 
debray model cost testing cost register special value bene direct indirect instruction savings 
achieved optimizing program information 
control ow pro les collected rst carry cost bene analysis identify candidates value pro ling 
address pro les address pro les collected form stream memory addresses referenced program 
pro les usually apply data layout placement transformations improving performance memory hierarchy 
depending optimization address traces collected di erent levels granularity 
nest level granularity memory address traced 
coarser level traces record individual objects individual addresses 
program address space divided parts stack heap globals 
stack data typically exhibits cache locality 
research focused improving data access behavior globals heap data 
programmers usually organize data structures logically 
tend put logically related data objects data elds 
logical relationships may di erent order data structures accessed runtime 
information provided address pro les compilers reorganize placement data objects respect placement elds data object closely accessed items placed 
way cache behavior improved 
complete address trace program run extremely large 
order compress size address trace chilimbi proposed sequitur algorithm generate compressed program stream wps representation address trace way sequitur compress program control ow trace 
guide application data layout placement transformations wps representation analyzed identify hot address streams 
streams represent subsequences addresses encountered frequently program run 
approach rst collects complete address pro les processes identify information useful guiding data layout placement transformations approach directly identify useful information 
calder proposed algorithm approach 
information collect represented graph named temporal relationship graph trg 
nodes graph data items interest 
weighted links established pairs nodes 
pair data items separated fewer threshold number say data weight associated link items incremented 
maintain weights links entry queue maintained records latest data items referenced program 
weights links program run compiler identify data items placed close achieving cache behavior 
fig 
shows example information collected approach 

fig 

address pro les 

profile guided classical optimizations simple optimization algorithms typically optimize statements determined optimizable conditions static analysis program 
hand aggressive algorithms optimize statements conditionally optimizable optimization opportunities discovered static analysis pro ling 
consequence algorithms involve replicating statements creating unoptimized optimized copies 
depending conditions hold appropriate copy statement executed 
process commonly referred code specialization 
optimizations specialization leads elimination copy redundancy dead code elimination optimizations specialization leads simpler ecient code strength reduction constant folding 
section providing brief overview various code specialization transformations followed identi cation speci optimizations rely 
describe critical role pro ling plays carrying optimizations 
pro le guided partial redundancy algorithm illustrate pro le data exploited systematic way developing pro le guided optimization algorithm 
transformations di erent code specialization algorithms carry code replication di erent levels granularity 
example function inlining replicates entire functions partial inlining replicates code selected paths function code motion algorithms replicate individual statements 
primarily classes transformations carry code replication enable specialization conditionally optimizable code code motion di erent types control ow restructuring varying scope 
code motion statements 
basic form code motion safe code motion addition honoring program data dependences guarantees execution statement execution optimized code exists 
corresponding execution statement execution unoptimized code 
consequence case exception occurs execution optimized code occurred execution unoptimized code 
hardware support modern processors ia allows relaxation constraint preserves program semantics 
particular speculative code motion allows compiler introduce executions statement optimized code unoptimized code 
bene cial added cost extra executions set savings resulting speculative code motion 
pro le cost bene analysis typically required take advantage speculative code motion 
predicated code motion creates opportunities performing code motion freely 
statements moved control structures executed di erent program point original conditions execution appropriately constructed predicate expression 
pro ling assist estimating bene achieved code motion outweighs cost evaluating predicate expression 
control ow restructuring 
conditions statement optimized hold execution paths control ow restructuring employed enable optimization statement follows 
restructuring create program reach statement incoming edge arrive statement determine statement optimized 
create unoptimized optimized copies statement place incoming edges 
scope control ow restructuring determines degree code optimized 
example changes due intraprocedural control ow restructuring localized procedure body interprocedural restructuring changes ow control procedure boundaries 
primary cost transformation resulting growth code size 
increasing scope restructuring increases amount resulting growth code size 
function inlining way achieve interprocedural control ow restructuring 
accompanied signi cant code growth 
limit code growth performing interprocedural optimizations couple alternative techniques proposed partial inlining frequently executed paths procedure creating procedures multiple entries multiple exits 
optimizations partial redundancy elimination pre 
pre expressions traditionally performed safe code motion 
opportunities redundancy removal exploited restricted form code motion 
example fig 
evaluation expression node partially redundant node visited prior reaching node expression evaluated node need evaluated 
partial redundancy reduced eliminated safe code motion 
speculative code motion hoist node shown fig 
net reduction partial redundancy results frequency node frequency node 
control ow restructuring employed 
manner shown fig 
redundancy entirely eliminated 
code growth results 
cost bene functions pro le data designed selectively carry transformations 
speculation rst proposed control ow restructuring rst proposed 
combination transformations achieve greater bene ts lower costs discussed 
considered redundancy evaluation context arithmetic expressions partial redundancy elimination applied contexts load removal array bounds checks elimination 
partial dead code elimination pde 
pde assignment achieved delaying execution statement point execution de nitely required 
conservative code motion opportunities pde exploited 
example assignment node fig 
partially dead control reaches nodes value computed assignment 
simply delay execution assignment node cases placement assignment node block correct value reaching node 
straightforward code motion block sinking assignment node preventing optimization occur 
statement enable sinking past node achieve pde see fig 

approach clearly bene cial frequency node node 
control ow restructuring applied carry pde shown fig 

case pre pro le cost bene analysis required selectively apply forms pde predication pde rst proposed 
control ow restructuring algorithm minimizes code growth associated pde 
just partially dead assignments eliminated motion restructuring transformations partially dead stores eliminated 
conditional branch elimination 
conditional branch considered partially redundant paths outcome determined compiletime 
elimination partially redundant conditional branch requires ow graph restructuring performed 
ow graph restructuring path outcome conditional branch known compile time separated path outcome unknown code duplication 
basic idea intraprocedural restructuring rst proposed general algorithm interprocedural demand driven analysis pro le guided interprocedural control ow restructuring 
example fig 
illustrates optimization 
ow graph fig 
contains paths intraprocedural interprocedural conditional branch elimination applicable 
rst path established false known false 
second path arises true value preserved call function condition evaluate false 
rst opportunity exploited intraprocedural control ow restructuring second requires interprocedural restructuring achieved splitting exit function shown fig 



code partial redundancy 



pre speculative code motion 




pre control flow restructuring 










partially dead code 
pde predicated code motion 
pde control flow restructuring 



call 


call 
partially redundant conditional branch 
redundancy removal control flow restructuring 
fig 

code motion control flow restructuring pro le guided classical optimizations 
partial redundancy elimination speculative code motion computation called partially redundant exists path computed twice 
redundancies eliminated doing computation appropriate program point assigning value auxiliary variable replacing original computations auxiliary variable 
problem nding appropriate program point guided transformational idea 
unnecessary recomputations avoided moving computations opposite direction control ow placing general context maximizing way potential redundant code eliminated 
restriction new computations inserted path computationally optimal results obtained statically 
assumed paths equally important true practice 
section pre algorithm takes pro le information account reduce number recomputations 
executing expressions speculatively enables removal redundancies frequently executed paths expense introducing additional expression evaluations frequently executed paths 
speci cally speculation process hoisting expressions expression execution controlled conditional prior speculation executed irrespective outcome conditional speculation 
way new computations may introduced paths alter semantics program case computations cause exceptions 
modern architectures intel ia support speculative execution instructions suppressing exceptions making kind transformation safe 
remainder section organized follows 
rst cost model identify pro table opportunities speculation 
practical algorithm carrying cost bene analysis probabilistic data ow analysis 
show analysis application cost model approximated 
details code motion framework carry pre combination safe code motion selectively enabled speculative code motion cost bene analysis 
cost model 
expression exp conditional node formulate condition potentially pro table enable speculative hoisting exp essentially identify paths bene speculation exp paths incur additional execution time cost due speculation exp probability paths bene greater paths incur cost speculation exp enabled computation probabilities execution pro le 
develop cost model hoisting expression exp conditional node useful categorize program subpaths originate terminate follows available subpaths subpaths start node evaluation exp encountered killed rede nition operands prior reaching 
available unavailable exp exp exp exp exp exp exp fig 

path classi cation 
unavailable subpaths subpaths start node exp available subpaths include evaluation exp encountered exp encountered killed rede nition operands prior reaching 
subpaths subpaths node exp evaluated prior rede nition operands exp 
subpaths subpaths node exp subpaths include exp evaluated exp evaluated done rede nition operands 
paths potentially bene hoisting exp conditional node paths obtained concatenating available subpaths subpaths rst paths redundancy 
evaluation exp prior reaching causes evaluation exp performed visiting redundant 
secondly redundancy removed exp hoisted node state path passes conditional node hoisting expression exp bene path exp available entry denote set paths bene hoisting exp exp 
expected bene speculating exp computed summing execution frequencies paths set shown 
exp req paths incur cost due hoisting exp conditional node paths obtained concatenating unavailable subpaths 
execution added redundancy removed exp exp exp fig 

paths bene vs paths incur cost 
subpaths paths additional evaluation exp prior reaching introduced 
path passes conditional node hoisting expression exp costs path exp unavailable entry denote set paths incur cost due hoisting exp exp 
expected cost speculating exp computed summing execution frequencies paths set shown 
cost exp req speculation enabled pro le data conclude expected bene exceeds expected cost 
boolean variable exp associated expression conditional node pair exp set true speculation exp enabled set false 
convenience restate speculation enabling condition terms probabilities detailed analysis algorithm probabilistic data ow analysis 
shown speculation enabled probability path bene ts greater probability path incurs additional cost 
req execution frequency node note sum probabilities need may paths una ected speculation 
exp exp exp exp cost exp req exp exp req 
noted expression exp available exp speculation enabled hand exp available exp exp non zero speculation enabled apply cost model example fig 

assume entire control ow trace shown gure loop iterates times 
encircled numbers right side nodes denote number times node visited execution 
evaluated times evaluated times evaluations evaluations redundant 
entire control ow trace cost model described compute precise probabilities gure 
probabilities conclude enable speculative hoisting conditional node 
speculation expressions enabled conditional nodes 


control low race precise probabilities fig 

enabling speculation idealized cost model 
cost bene analysis probabilistic data ow analysis 
analysis described preceding section idealized respects 
availability anticipability data ow information required interesting path passes conditional 
second assumed entire control ow trace available execution frequencies interesting paths determined 
possible compute path data ow information maintain complete control ow traces techniques described respectively practical reasons may desirable explore expensive alternatives 
section detailed cost bene algorithm uses probabilistic data ow analysis guided edge pro les 
algorithm requires entire control ow trace compute data ow information path basis 
traditional data ow analysis calculates data ow fact holds hold program point calculate probability data ow fact hold program point 
applied data ow problems availability anticipability provides probabilities rob exp probability expression exp available node rob exp probability exp node reformulate speculation enabling condition expression exp conditional node terms probabilities follows exp exp exp exp rob exp rob exp exp rob exp rob exp important note formulation approximation prior cost model assumption availability anticipability conditional node independent events 
computed probability path bene ts incurs cost product probabilities availability availability anticipability anticipability 
know practice outcomes conditionals program may correlated 
model approximate uses precise probabilities availability anticipability 
reconsider example fig 
light cost model 
model compute availability anticipability probabilities 
compute precise probabilities control ow trace 
see results fig 
estimates cost bene probabilities changed relationship changed 
conclude speculation enabled conditional node expressions 
example approximation cost model precise availability anticipability probabilities derived control ow trace 
discuss probabilities approximated edge pro les 
precise probabilities rob rob approximate probabilities fig 

enabling speculation precise availability anticipability probabilities 
rst probabilistic data ow system edge probabilities developed ramalingam :10.1.1.56.7436
demand driven frequency analyzer cost controlled permitting bounded degree imprecision proposed bodik 
edge frequencies capture branch correlation approximations introduced computed probabilities considerable 
scholz proposed data ow system probabilities 
relating data ow facts node data ow facts immediate predecessor nodes ow graph edge probabilities data ow facts node related predecessor nodes ow graph edge probabilities 
way signi cantly better results achieved 
course approach precise extending edges undermine goal computing probabilities eciently 
availability anticipability calculated traditional formulations data ow problems shown fig 

availability analysis guided local boolean predicates 
exp equals true occurrence exp blocked subsequent statement statement modi es variables exp exp equals true exp blocked statement statement modifying variable exp boolean conjunction denoted boolean disjunction boolean negation denoted bar 
pre abbreviations entry exit respectively 
con uence operator indicates availability problem forward problem 
availability analysis expression exp available exit downwards exposed 
expression exp blocked statement false start node pred anticipability analysis hoisting candidate exp upwards exposed 
hoisting exp blocked statement false node succ original data flow equations 
dual availability analysis true start node pred dual anticipability analysis true node succ data flow equations transformation 
fig 

availability anticipability analysis 
similarly anticipability analysis guided local predicates 
exp equals true occurrence exp blocked preceding statement statement modi es variables exp exp equals true exp blocked statement statement modifying variable exp con uence operator indicates anticipability problem backward problem 
probabilistic data ow systems problems meet operator union analyses problems transformed described reps 
problem intersection problem may problem union problem 
solution problem complement solution may problem 
fig 
presents data ow equations complementing original ones 
note initializations start node changed appropriately 
con uence operator problems union framework applied straightforward way 
solutions equation systems denote probabilities complementary problems 
probabilities availability anticipability avail avail anti anti discuss detail specify equation system edge approach 
applicable large class data ow problems called nite bi distributive subset problems 
class data ow problems requires nite set data ow facts ii data ow functions distribute set union set intersection 
class data ow problems general bit vector problems general class nite distributive subset problems introduced reps 
equations built utilizing called exploded control ow graph created original cfg data ow problem 
fig 
depicts availability problem subgraph example consisting nodes 

subgraph exploded subgraph fig 

cfg subgraph example 
nodes denoting node set corresponding cfg denoting data ow information set extended special symbol calculate node frequencies 
data ow facts designate expressions respectively 
edges derived representation relation data ow function follows jy jy fxg note nodes connected successor nodes 
nodes ect availability described identity function nodes connected corresponding exploded successor nodes 
data ow fact generated node edge 
hand data ow fact killed node outgoing edge node 
way represents dfa functions explicitly 
edge approach require edge probabilities specify probability execution follow edge vw edge uv reached 
occurs uvw occurs uv occurs uv 
function occurs denotes number occurrences path control ow trace 
need notion predecessor edge similar predecessor node 
vw 

vw denotes set predecessor edges edge vw data fact 
fig 
gives equation system edge approach 
unknowns equation system related edges 
unknown vw denotes expected frequency data ow fact hold true node condition edge vw taken vw denotes expected number times edge vw executed 
core equation system equation 
unknown related edge vw fact linked unknowns related edges weighting edge probability 
initialization reasons introduce arti cial root edge pseudo node start node equation equation show initialization equation system denoting initial values corresponding data ow problem 
equation describes relation nodes edges 
equation system frequency unknowns solved rob denotes probability data ow fact hold true node edge equation system fig 
terms forward data ow problems 
backward problems edge probability equation system adapted accordingly 
vw vw vw uv pred vw fig 

edge equation system 
probabilities availability edge approach coincide precise results example 
note solving availability precisely conditional node important gure path taken 
fortunately edge approach succeeds enabling hoisting expressions node 
general probabilities may deviate precise results bene cial opportunities improvements missed 
exists trade preciseness results having possibly direct uence optimizations performed ort required obtain results 
speculative code motion framework 
speculative code motion framework carry optimization 
framework expressions appropriate points program safe code motion conditionals speculation disabled speculative code motion conditionals speculation enabled 
number pre algorithms literature 
adapt safe code motion pre algorithm proposed ste en 
original analysis consists backward data ow analysis phase followed forward data ow analysis phase 
backward data ow identify safe points points expression evaluations safely hoisted 
forward data ow analysis identi es earliest points expression evaluations placed 
expression evaluations placed points earliest safe 
modify safety analysis take advantage speculation past conditional nodes speculation enabled 
analysis remains unchanged 
placement points identi ed algorithm entry exit points nodes control ow graph 
situations ow graph may contain node appropriate placement point 
ensure happens certain called critical edges split synthetic node introduced 
edges nodes successor nodes predecessor 
ow graph fig 
edge critical edge 
node introduced edge performing analysis carrying pre 
data ow equations computing safety expression exp follows 
expression exp safe entry node computed exp true safe exit preserved res exp true 
expression exp safe exit conditional node conditions true exp safe entry points successor nodes speculation exp enabled exp true exp safe successor nodes 
rst conditions ste en original code motion framework carries safe code motion 
second condition added allow useful speculative motion exp occur 
node examined conditional node rst conditions checked 
alse exit node succ conditional succ succ outcome applying algorithm example fig 
shown fig 

results safety analysis observe 
expressions safe entry node speculation enabled expressions 
formally describe analysis easy informally observe earliest points safe entry point node safe exit node exit point node safe entry node 
evaluations placed points assigned temporary tx replaces original occurrences program 
similarly observe earliest points safe entry point node entry point node exit point node entry point node 
evaluations placed points assigned temporary ta replaces original occurrences optimized placement results evaluations reducing evaluations respectively 
enabling speculation expressions node pro table resulted ecient code 
example illustrates need breaking critical edges evaluation placed newly created node 
cost analysis applied entire program compile time cost pro le guided optimization algorithm expected higher non pro le guided coun 
exp tx tx ta 
tx tx ta ta tx ta ta ta fig 

speculative pre modi ed safety analysis 

example speculative pre algorithm preceding section expensive traditional safe code motion algorithm 
additional cost results cost bene analysis associated enabling speculation 
approaches applied limit cost pro le guided algorithms application optimization algorithms limited code belonging frequently executed hot program regions aggressively optimized 
carrying exhaustive data ow analysis employ demand driven analysis techniques 
techniques limit cost data ow analysis computing data ow facts relevant code optimization 
approach particularly bene cial expensive analyses interprocedural analysis 
conservatively imprecise frequency analysis techniques limit cost frequency analysis 
frequency analyzer cost controlled permitting bounded degree imprecision proposed bodik 
addition analyzer demand driven 

profile guided memory optimizations past decade processor speeds risen year memory speeds improved year 
result cache penalties increased cycles cycles 
memory 
accesses especially due loads critical path cache misses greatly reduce ability modern processor ectively exploit instruction level parallelism 
broadly speaking classes optimization techniques aimed improving cache performance reduce number cache misses minimize memory stalls better tolerate cache penalty 
focus section optimizations rst type 
program address space divided parts heap stack global space 
stack data typically exhibits cache behavior 
research aimed improving cache locality statically allocated global data dynamically allocated heap data 
optimizations statically allocated data typically carried compile time optimizations applicable dynamically allocated data combination compile time decisions runtime actions 
techniques improve data locality divided categories object placement techniques determine placement data objects relation provides improved cache behavior 
object layout techniques determine layout elds large data object improve cache locality 
object layout placement techniques alter layout elds object placement data objects relation 
object compression techniques improve cache behavior reducing data memory footprint program object placement address pro les provide compiler information useful organizing placement objects memory relation 
example categorize objects frequently referenced hot objects infrequently accessed cold objects 
hot objects placed separate cold objects 
seeing hot objects frequently placement hot objects relation determined 
statically allocated global data object placement carried time compilation 
placement heap objects carried incrementally runtime dynamically allocated 
standard system provided memory allocators malloc provide control data placement 
proposed approaches placement heap objects object migration memory clustering 
object migration 
approach standard memory allocators heap objects initially allocated placement optimized 
runtime objects migrated original locations ones order improve cache locality 
main challenges carrying ective object migration 
substantial overhead object migration 
sources overhead object migration requires extra execution time access migrated objects may require additional operations situations 

gain improved cache locality outweighs migration overhead object migration optimization pro table 
role address pro les identify objects colocated migration 
second challenge maintaining program correctness presence object migration 
programmer location data developing code clearly object migration lead correctness problems 
example consider objects corresponding variable structure pointed shown 
user may assume objects colocated address arithmetic accessing elds 
particular user may access data eld sizeof int 
clearly object migration cause code fail 
int struct int int approach addressing correctness issue provide programming guidelines restrict manner data accessed 
address arithmetic allowed object prohibit user deriving address object address object 
restriction eliminate problem illustrated example 
approach provide hardware support may enable safe application object migration situations 
luk mowry proposed hardware support memory forwarding uses limited hardware support enable aggressive object migration 
problem addressed support follows 
object migrated pointers object may exist program 
pointers date accesses illegal 
correctly handle accesses migrated objects pointers support provided 
extra bit attached machine word semantics 
bit attached set indicates object resided location migrated location contains forwarding address migrated object 
load store instructions implemented carry extra level dereferencing contents bit attached memory location addressed 
approach enables migration objects forwarding addresses left locations objects originally resided 
noted extra overhead associated memory forwarding terms extra storage needed hold forwarding addresses extra execution time required carry extra level dereferencing 
example fig 
illustrates approach 
shows link list initially items link list reside originally assigned locations 
link list elements migrated adjacent memory locations shown 
list elements migrated fewer cache misses occur list traversed 
note original locations migrated list elements contain forwarding addresses 
dangling pointers point old addresses forwarded new addresses hardware 
fig 

memory forwarding 
memory clustering 
approach supports memory management routines provide limited user level control object placement 
object migration dynamically changes object placement approach places objects desirable locations 
result migration overhead avoided 
approach burdens programmer task providing hints memory allocator making object placement decisions 
example user level memory allocator ccmalloc allocator proposed chilimbi 
addition providing size object memory allocation user provides pointer existing object accessed contemporaneously newly allocated object 
possible ccmalloc allocates new object cache block existing object 
address pro les user identify objects accessed contemporaneously 
fig 
show grouping nodes binary tree clustering 
group nodes belonging cache block shown shading gure 
grouping prior clustering re ects order nodes created 
grouping ccmalloc allocates group neighboring nodes cache block 
assuming decision address pro les breadth rst traversal tree optimized placement tree nodes lead better cache performance 
fig 

ccmalloc example 
approach requires programmer involvement possible automate process address pro les 
identify appear close address pro les generate signature 
group 
creating nodes runtime attempt nodes signature 
object layout data structure de ned programmer support code readability 
logically related data elds put 
compiler simply uses memory layout elds mirrors order elds declared 
order may consistent ordering incurs fewer cache misses 
order improve cache performance layout elds object reordered elds accessed frequently contemporaneously placed close 
course transformation useful object large extends multiple cache blocks 
truong evaluated approach showed node spans cache blocks object layout optimization implicitly takes advantage cache line prefetching reduces cache pollution improving cache performance 
fig 

field reorganization 
fig 
shows default memory layout compiler left 
right layout generated pro le guided eld reorganization shown assumption cache block large hold elds elds 
pair accesses elds generate cache misses reorganization cache reorganization 
object layout placement highly aggressive locality improving transformations result simultaneous changing object layouts placement respect 
consider data structure contains multiple objects nodes type 
object contains elds hot frequently cold rarely 
transformations instance interleaving object splitting proposed improve cache behavior data structures 
instance interleaving 
allocating object contiguous set memory locations approach proposed truong interleaves storing multiple instances object instances type 
hot elds di erent object instances stored cold instances 
application transformation example fig 
illustrated fig 

hot elds di erent object instances stored place cold elds di erent object instances stored 
clearly example observe internal layout relative placement objects changed transformation 
fig 

interleaving instances type 
object splitting 
chilimbi proposed transformation separates hot elds object cold elds 
fact split object parts hot primary part cold secondary part 
hot elds accessed directly pointer cold part stored hot part extra level indirection involved accessing cold elds 
transformation explicitly interleave hot cold parts di erent object instances 
locality objects improved memory clustering ccmalloc group hot cold elds di erent object instances 
example fig 
illustrates transformation 
compared instance interleaving approach cleaner easy manage modi cation original source code easier perform 
important note changing object layout useful object small ts cache block 
layout placement simultaneously changed bene cial split small objects splitting allow clustering greater number hot parts objects single cache block 
object compression complimentary technique improving data cache behavior object compression 
technique improves cache performance reducing memory requirement packing greater amounts data cache block 
higher data 
fig 

object splitting 
density cache block reduces number cache misses take place accessing amount data memory 
compile time techniques developed exploit presence narrow width data achieve compression 
stephenson proposed bitwidth analysis discover narrow width data performing value range analysis 
example ag declared integer may take values 
compiler proven certain data items require complete word memory compressed smaller size 
approach particularly useful programs narrow width multimedia data packed user 
davidson carries memory coalescing compiletime analysis 
techniques share common characteristic applicable compiler determine data compressed fully compressible apply narrow width non pointer data 
zhang gupta proposed pro le guided compression transformations apply partially compressible data addition handling narrow width non pointer data apply pointer data 
transformations quite ective compressing heap objects 
generality approach quite important experience shown heap allocated data structures highly compressible fully compressible 
approach simpler respect 
require complex compile time analysis prove data compressible 
simple pro le guided heuristics compiler determine data structure compressed contains compressible data 
compression partially compressible data structures observation zhang majority data values encountered data memory allocated program divided categories small constant values large address values 
node belonging heap allocated data structure data elds may contain small constants pointer elds contain large address values 
higher order bits small constants truncate value lower order bits remaining bits simply obtained replicating highest order bit truncated entity 
pointer eld stored node shares common bit pre address node stored 
fig 

compression partially compressible data structure 
truncate pointer eld bits 
full contents pointer reconstructed address node resides 
truncated bit entities representing integer data pointer compressed single word 
remaining bits bit word unused indicate word contains compressed values 
word contain compressed values case values compressible runtime 
case contains pointer location elds stored uncompressed form 
bene ts optimization increase extent large critical data structures program compressed 
cost optimization additional instructions carrying data compression expanding compressed data prior computations checking compressibility data accessing data extra level indirection 
pro ling indicates values data structure compressible bene ts costs 
fig 
node structure contains integer eld pointer eld 
lets assume pro ling indicates elds compressible 
situation compiler replaces single combined eld 
runtime node created reduced amount storage allocated accommodate eld 
data stored compressible stored single word shown gure 
signi cant bit set data held compressed eld 
hand data stored compressible additional storage allocated store data pointer location placed 
signi cant bit set 
pro le guided code layout techniques discussed far applicable program data 
techniques proposed improve instruction cache behavior 
goal techniques layout code manner increases fraction 
instructions fetched instruction cache block executed 
note instructions belonging cache block may executed due presence branches code 
fig 

code placement 
consider example fig 

sizes cache line basic blocks shown gure 
illustration purposes assume entry fully associative cache 
layout optimizations performed compiler generate layout marked original layout gure 
layout introduces large number instruction cache misses primarily blocks frequently executed path kept cache 
block fetched repeatedly rarely executed 
path pro le data easily determine bene cial optimized layout shown gure blocks packed cache line 
number cache misses greatly reduced case 
illustrated application code layout optimization basic block level 
techniques layout optimization procedural level developed 

concluding remarks chapter identi ed optimization opportunities may exist program execution exploited availability pro le data 
di erent types pro le data useful code optimization identi ed 
pro le data carrying pro le guided classical memory optimizations discussed 
identi ed key issues involved developing pro le guided optimization algorithms demonstrated issues developing speculative pre algorithm 

aggarwal yeung 
tseng evaluating impact memory system performance software prefetching locality optimizations th annual acm international conference supercomputing ics pages sorrento italy june 
ball larus ecient path pro ling th ieee acm international symposium microarchitecture micro pages december 
ball sagiv edge pro ling versus path pro ling showdown th acm sigplan sigact symposium principle programming languages popl pages san diego ca january 
bodik gupta interprocedural conditional branch elimination acm sigplan conference programming language design implementation pages las vegas nevada june 
bodik gupta partial dead code elimination slicing transformations acm sigplan conference programming language design implementation pages las vegas nevada june 
bodik gupta complete removal redundant expressions acm sigplan conference programming language design implementation pages montreal canada june 
bodik gupta load reuse analysis design evaluation acm sigplan conference programming language design implementation pages atlanta georgia may 
bodik gupta sarkar abcd eliminating array bounds checks demand acm sigplan conference programming language design implementation pages vancouver canada june 
calder feller eustace value pro ling th ieee acm international symposium microarchitecture micro pages december 
calder john austin cache conscious data placement th acm international conference architectural support programming languages operating systems asplos pages san jose california october 
chilimbi hill larus cache conscious structure layout acm sigplan conference programming language design implementation pldi pages atlanta georgia may 
chilimbi davidson larus cache conscious structure de nition acm sigplan conference programming language design implementation pldi pages atlanta georgia may 
chilimbi ecient representations abstractions quantifying exploiting data locality acm sigplan conference programming language design implementation pages snowbird utah june 
davidson memory access coalescing technique eliminating redundant memory accesses acm sigplan conference programming language design implementation pldi pages orlando fl june 
dhamdhere practical adaptation global optimization algorithm morel renvoise acm transactions programming languages vol 
pages 
duesterwald gupta practical framework demand driven interprocedural data flow analysis acm transactions programming languages systems vol 
pages november 
duesterwald gupta demand driven computation interprocedural data flow acm sigplan sigact nd symposium principles programming languages popl pages san francisco california january 
ia architecture ieee computer vol 
pages july 
gupta fresh look optimizing array bound checks acm sigplan conference programming language design implementation pldi pages white plains ny june 
gupta berson fang path pro le guided partial redundancy elimination speculation ieee international conference computer languages iccl pages chicago illinois may 
gupta berson fang resource sensitive pro le directed data flow analysis code optimization ieee acm th international symposium microarchitecture micro pages research triangle park north carolina december 
gupta berson fang path pro le guided partial dead code elimination predication international conference parallel architectures compilation techniques pact pages san francisco california november 
hank 
hwu rau region compilation motivation th ieee acm international symposium microarchitecture micro pages ann arbor michigan heintze demand driven pointer analysis acm sigplan conference programming language design implementation pldi pages snowbird utah june 
knoop ste en lazy code motion acm sigplan conference programming language design implementation pldi pages san francisco ca june 
knoop ste en partial dead code elimination acm sigplan conference programming language design implementation pldi pages orlando florida june 
larus program paths acm sigplan conference programming language design implementation pldi pages atlanta ga may 

luk mowry memory forwarding enabling aggressive layout optimizations guaranteeing safety data relocation th ieee acm international symposium computer architecture isca pages may 
mcfarling program optimization instruction caches th acm international conference architectural support programming languages operating systems asplos pages april 
scholz novel probabilistic data flow framework tenth international conference compiler construction cc lncs springer verlag pages genova italy april 
manning witten linear time incremental hierarchy inference compression data compression conference snowbird utah ieee computer society pages 
sarkar determining average program execution times variance acm sigplan conference programming language design implementation pldi pages portland oregon june 
stephenson babb amarasinghe bitwidth analysis application silicon compilation acm sigplan conference programming language design implementation pldi pages vancouver canada june 
truong improving cache behavior dynamically allocated data structures international conference parallel architectures compilation techniques pact pages paris france 
debray goal directed value pro ling tenth international conference compiler construction cc lncs springer verlag genova italy april 
morel renvoise global optimization suppression partial redundancies communications acm vol 
pages 
mueller whalley avoiding conditional branches code replication acm sigplan conference programming language design implementation pldi pages la jolla ca june 
ramalingam data flow frequency analysis acm sigplan conference programming language design implementation pldi pages philadelphia pa :10.1.1.56.7436
reps horwitz sagiv precise interprocedural data ow analysis graph reachability acm sigact sigplan symposium principles programming languages popl pages san francisco ca january 
ste en property oriented expansion international static analysis symposium sas lncs springer verlag pages germany september 
ste en data flow analysis model checking tacs sendai japan springer verlag lncs pages 
young johnson karger smith near optimal intraprocedural branch alignment acm sigplan conference programming language design implementation pldi pages las vegas nevada june 
zhang gupta timestamped program path representation acm sigplan conference programming language design implementation pldi pages snowbird utah june 
zhang yang gupta frequent value locality value centric data cache design ninth international conference architectural support programming languages operating systems asplos pages cambridge ma november 
zhang gupta data compression transformations dynamically allocated data structures international conference compiler construction grenoble france april 
