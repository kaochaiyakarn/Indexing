achieving extensibility product lines domain specific languages case study don batory clay johnson bob macdonald dale von department computer sciences university texas austin austin texas batory cs utexas edu applied research labs university texas austin austin texas clay bob drv utexas edu 
case study product line architectures plas domain specific languages dsls design extensible command control simulator army fire support 
reusable components pla layers aspects addition removal simultaneously impacts source code multiple objects multiple distributed programs 
complexity component specifications substantially reduced dsl defining refining state machines abstractions fundamental simulators 
preliminary results show pla dsl synergistically produce flexible way implementing state machine simulators possible pure java implementation 
preliminary version international conference software reuse vienna austria july 
updated acm september 
software evolution costly unavoidable consequence successful application 
evolution occurs new features added existing capabilities enhanced 
unfortunately applications suffer design fatigue evolution difficult costly issues addressed initial design 
software easily evolvable central problem today software engineering 
proposed complementary technologies address software evolution object oriented design patterns domain specific languages product line architectures 
design patterns techniques restructuring generalizing object oriented software 
evolution occurs applying design patterns existing design effects changes borne programmers manually transform existing code base match updated design 
advances indicate tool support 
supported part university texas applied research labs department defense advanced research projects agency cooperation wright laboratory avionics directorate contract 
automating applications patterns possible 
domain specific languages dsls raise level programming allow customized applications specified compactly terms domain concepts compilers translate dsl specifications source code 
evolution achieved modifying dsl specifications 
product line architectures plas designs families related applications application construction accomplished composing reusable components 
evolution occurs plugging components encapsulate new enhanced features 
pla models genvoca model distinguished integration ideas aspect oriented programming parameterized programming program construction refinement 
presents case study genvoca plas dsls create extensible command control simulator army fire support 
design patterns played minor role 
discovered components distributed simulations conventional dcom corba components layers aspects addition removal simultaneously impacts source code multiple distributed programs 
writing components general purpose programming language java resulted complex code obscured relatively simple state machine design 
extending java domain specific abstractions case state machines component specifications readily understood domain experts knowledge engineers application programmers 
case study interesting novelties introduced plas dsls integration technology inadequate 
explaining ideas terminology fire support 
review existing simulator called fsats motivate redesign 
genvoca pla creating extensible fire support simulators introduce extension java language defining refining state machines 
simple measures program complexity show plas dsls individually simplify simulators combination provides practical extensibility 
background domain fire support fire support command control application includes detection targets assignment weapons attack target coordination actual attack 
entities engaged process called operational facilities soldier operated machine automated command posts exchange tactical war messages 
forward observers fo intervals battlefield 
kinds sensors responsible detecting potential targets 
hierarchy fire support elements fse responsible directing requests fos appropriate weapon system handle attack 
fos report fire support team fist fist reports fse fse reports brigade fse 
fse typically supporting command posts cps different weapon systems 
example fse supported field artillery command post fist supported mortar command post 
general higher echelon supported higher echelon cps powerful longer range weapon systems 
opfac command hierarchy fire support team fist hills forward observer fo fos responsible evaluating target 
evaluation may result assigning target attacked supporting weapon elevating target higher echelon fse evaluation denial choosing attack target 
cps responsible assigning targets best weapon combination weapons command 
weapon assigned messages exchanged mission originator usually fo coordinate completion mission 
particular message sequence depends target weapon 
generally case messages relayed chain cps involved initiating mission newer systems permit messages exchanged directly weapon observer 
message sequence particular mission referred mission thread 
general opfac participate number mission threads time 
mission thread instance mission type 
mission types including ready fire effect mortar cp assigned shoot target soon possible ready fire effect artillery artillery artillery cps assigned shoot target soon possible fire support element fse hills enemy tank front line opfac command hierarchy artillery time target artillery tot artillery field artillery requested fire target rounds land specified location specified time ready adjust forward observer knows approximately location enemy requests single rounds fired observer sending corrections rounds target hit point mortar mission 
opfac fo fist fse performs different actions mission type 
example actions taken fo tot mortar mission different artillery mission 
clearly description fire support highly simplified actions taken specific mission thread translation messages formats tactical transmission omitted 
details unnecessary understand contributions 
fsats simulation plays key role army testing training 
avoids costs live forces provides repeatability testing allows force force combat training liability 
simulation model virtual environments weapons effects outcome computational resources increase fidelity refined entity level simulators 
fire support number domains digital command control communications computer intelligence systems automate battlefield mission processing 
advanced field artillery tactical data system arguably sophisticated system existence provides software backbone message transmission processing fire support army 
fsats fire support automated test system system testing fire support systems 
fsats collects digital message traffic command control communication networks interprets messages stores database analysis 
fsats simulate 
subject test system performance individual opfac performance system operator performance 
fsats training army personnel fire support debugging testing 
current fsats implementation fsats development years 
typical systems mentioned introductory paragraph began clean design capabilities extended limitations design increasingly troublesome 
implementation combination decision rules encoded database tables set common actions written ada procedures decision rule interpreter ada 
set rules associated pair opfac type message type 
tactical message received opfac appropriate rule set selected interpreter rule set sequentially evaluated succeeds point action rule executed processing message terminates 
rules associated opfac type divided various input message types 
rule consists predicate conjunction guards action index sequence state message common actions 
predicates typically contain guards terms 
processing rule sets optimized predicates assume failure previous predicates 
common actions range simple copy target number field input output message complex determining exists supporting opfac type mortar capable shooting target indicated current message 
obvious drawbacks design implementation 
rule sets express opfac behavior opfac behavior routinely understood analyzed terms mission threads 
illustrates mission thread horizontal execution path associates various rules spanning multiple opfac programs 
complicates knowledge acquisition engineering process derive analysis multiple mission threads rules apply opfac 
conversely analyzing debugging system behavior rules multiple mission threads merged monolithic sets opfac program 
opfac opfac opfac rule rule rule rule rule rule 
rule sets vs mission threads contrast vertical nature rule sets versus horizontal cross cutting nature mission threads illustrates encapsulation dichotomy unique fsats 
general conventional oo approaches explore cases threads specification analysis system behavior 
concept case transient design process identifies behavior rules actors actions missions 
trade seemingly unavoidable need produce objects combine behaviors react variety situations 
fsats transformation mission threads rule sets yields autonomous increased cost analysis maintenance 
fsats evolved rule sets quickly large unwieldy 
different missions message type opfac slightly different purposes 
simpler rules sufficed factored disambiguate applicability newer specialized missions 
worse cases large subsets rules rule rule rule 
duplicated resulting dramatic increase rules interactions 
relationship rules different missions applied lost 
modifying opfac rules laborious analysis rediscover dependencies 
combinatorial effect rule set interactions analysis increasingly difficult time consuming 
fsats management realized current implementation sustainable long term new approach sought 
fsats continue evolve addition new mission types varying behavior opfac mission accommodate differences time different branches military 
need extensible simulators clearly envisioned 
primary goals redesign disentangle logic implementing different mission types implementation testing mission independent existing missions reduce conceptual distance logic specification implementation implementations easily traced back requirements verified allow convenient switching mission implementations accommodate requirements different users experiment new approaches 
genvoca technology chosen address problems identified generation fsats simulator genvoca pla implemented jakarta tool suite jts 
section motivate explain basic ideas genvoca implementation techniques 
scope review design methodologies apply genvoca concepts explain domains simpler fsats elaborate approach taken 
interested readers consult 
motivation today models software low level exposing classes methods objects focal point discourse software design implementation 
difficult impossible reason software architectures componentbased designs simple elegant easy understand specifications applications able create critique software designs automatically set high level requirements 
simple specifications amenable automated reasoning code generation analysis possible provided focus discourse shifted components encapsulate implementation individual largely orthogonal features shared multiple applications intuitive rationale shift evident discussions software products architects don speak products terms code modules explain products terms fea tures offered clients 
focus discourse features source code 
genvoca aims raise level abstraction understanding software code modules code encapsulation technologies features feature encapsulation technologies 
features refinements core genvoca design methodology creating product lines building architecturally extensible software software extensible component additions removals 
genvoca scalable outgrowth old methodology called step wise refinement advocates efficient programs created revealing implementation details progressive manner 
traditional step wise refinement focussed microscopic program refinements apply hundreds thousands refinements yield admittedly small programs 
approach fundamental industrial infrastructures horizon genvoca extends step wise refinement scaling refinements component layer multi class modularization granularity refinement adds feature program composing refinements yields entire application 
critical shift understand software manner recognize programs values refinements functions add features programs 
consider constants parameterless functions represent programs different features program feature program feature refinement function takes program input produces refined feature augmented program output adds feature program adds feature program follows multi featured application specified equation named composition functions different equations define family applications app app features app app features app app features casually inspecting equation readily determine features application 

griss defines feature product characteristic users customers view important describing distinguishing members product line 
note subtle important confluence ideas model function represents feature implementation 
different functions offer different implementations feature adds feature implementation adds feature implementation application requires feature problem equation optimization determine implementation best provide best performance possible automatically design software produce equation optimizes qualitative criteria set declarative constraints target application 
example kind automated reasoning 
practical matter refinements typically transform arbitrary programs 
input refinements functions satisfy type set constraints syntactic semantic nature 
typical syntactic constraint program implement set defined java interfaces typical semantic constraint implementation interfaces satisfy certain behavioral properties 
common combinations features implementations correct 
model expressing program types algorithms automatically efficiently validate equations developed part jakarta tool suite 
mixin layer implementation ways implement refinements ranging dynamically composing objects statically composed meta programs programs generate programs rule sets program transformation systems 
simplest templates called mixin layers 
term component denote mixin layer implementation refinement 
genvoca component typically encapsulates multiple classes 
depicts component classes 
number relationships exist classes shows inheritance relationships 
subclasses inheritance relationship 
concept refinement integral part object orientation 
particular subclass refinement superclass adds new data members methods overrides existing methods 
genvoca refinement scales inheritance simultaneously 
technically different equations represent different programs 
equation optimization space semantically equivalent programs 
identical relational query optimization query initially represented relational algebra expression expression optimized 
expression represents different semantically equivalent query evaluation program original expression 
component component genvoca components composition refine multiple classes 
depicts component encapsulates refining classes additional class 
note refining classes superclasses specified enables plugged underneath determined superclasses 
model refinements functions write composition 
dealing template implementations convention slightly different syntax 
trivial correspondence model equations implementing mixin layer template expressions 
correspondence shows result 
classes outlined darker ovals distinguish classes 
note obvious thing happens classes component refined classes expected 
linear inheritance refinement chain created original definition top chain refinement bottom 
components composed inheritance hierarchies produced get progressively broader new classes added deeper existing classes refined 
rule bottom class refinement chain instantiated subclassed form distinct chains 
indicated shaded classes 
reason classes contain features aspects added higher classes chain 
higher classes simply represent intermediate derivations bottom class :10.1.1.127.1416
consequence instantiating bottom class chain refinement relationships take precedence typical subclassing relationships 
class 
kinds refinements discussed 
example optimizing refinement maps inefficient program efficient program 

accurately refinement class subclass name normally subclasses distinct names superclass 
idea graft refinements class necessary forming linear refinement chain synthesize actual version 
subclasses names distinct superclass define entirely new classes subsequently refined 
composition component refined refined version superclass precedence relationship seen 
representation 
genvoca component refinement encoded jts class nested classes 
representation component shown denotes refined version class 
classes superclass 
java technique defining properties empty interfaces interface indicate type component interface empty class implements class 
class extends 
class extends 
class 
components encapsulate refinements expressed mixins classes superclass specified parameter 
representation mixin layer parameter instantiated component type class extends implements class extends :10.1.1.127.1416
class extends 
class extends 
class 
parlance model section value type function parameter type returns refined program type composition depicted expressed class extends replaced instantiated bodies readers familiar earlier descriptions genvoca model recognize corresponds realm interface components realm type equation 
extensibility achieved adding removing mixin layers applications product line applications defined different compositions mixin layers 

technically realm interface empty specify class interfaces methods 
realm interface include nested interfaces classes component realm implement 
nested class extend implement ia particular nested interface java current jts extensions java enforce class interfaces implemented interface declarations nested 
going research aims correct situation 
perspective stepwise refinement originated late writings wirth dijkstra 
key lies scaling effects individual refinements contributors 
neighbors described architectural organization mapping languages concrete languages mappings higher language representation program lower implementation oriented representation seen large scale refinements 
parameterized programming provides conceptual infrastructure early models parametric components advanced goguen 
earliest plug compatible layers large scale refinements creating product families extensible applications originated mid late batory malley 
feature descriptions applications product lines originated early kang feature oriented domain analysis evolutionary domain life cycle models 
collaborations object oriented representations refinements discussed 
kiczales notion aspects cross cutting effects clarified general need feature encapsulations 
multi dimensional separation concerns examines flexible way identifying composing features existing software 
worth noting trade large scale refinements genvoca generic small scale microscopic refinements commonly literature 
traditional argument small scale relatively small number generic small scale refinements generate larger number large scale refinements 
additionally large scale refinements tend applicable tend assumptions application context 
refinement applicable sub refinement specializes requires presence 
case traditional small scale refinements breaks precisely doing domain specific development generation argument fails hardly generic transforms interest restricted domain contextual assumptions argument breaks domain provides required context 
domain specific small scale refinements address cited deficiencies 
mentioned earlier enormous numbers domain specific small scale refinements applied produce admittedly small programs 
scaling refinements doing provides practical way develop complex domain specific software artifacts 
tools simpler concepts closer main stream programming methodologies oo collaborations see section 
implementation genvoca fsats design implemented jakarta tool suite jts set java tools creating product line architectures compilers extensible java languages 
sections outline essential concepts jts implementation 
design extensible fire support simulator design 
key idea genvoca fsats design encapsulation individual mission types components 
central variabilities fsats history projected lie addition enhancement removal mission types 
encapsulating mission types components evolution fsats greatly simplified 
noted earlier mission type cross cutting effect addition removal mission type impacts multiple opfac programs 
mission type example common kind refinement called collaboration set objects collectively achieve certain goal 
collaborations desirable property defined largely isolation collaborations simplifying application design 
case fsats mission collaboration objects cooperatively particular mission 
actions taken opfac defined protocol state machine follows part processing mission thread 
different follow different protocols different mission types 
extensible component design fsats follows directly observations 
component vanilla defines initial opfac class hierarchy routines sending receiving messages routing messages appropriate missions reading simulation scripts depicts vanilla component encapsulating multiple classes opfac type 
defined vanilla know react external stimuli 
reactions encapsulated mission components 
mission component encapsulates protocols expressed state machines added opfac participate thread mission type 
composing mission component vanilla extends opfac knowledge react particular external stimuli coordinate response 
example artillery component added forward observer protocol tells react sees enemy tank creates artillery message relays fist 
fist commander turn follows artillery protocol forward message fse 
depicts artillery component encapsulating multiple classes opfac type 
enclosed class encapsulates protocol added appropriate opfac class 
component composition accomplished inheritance shown dark vertical lines component encapsulating multiple classes class implementing state machine inheritance relationship legend 
superclass subclass vanilla opfac inheritance refinement hierarchy class ovals 
holds mission components 
note classes instantiated bottom classes linear inheritance chains embody protocols features grafted opfac 
readers recognize example genvoca paradigm section components mixin layers 
genvoca fsats design distinct advantages mission type extensible comparatively easy add new mission types existing genvoca fsats simulator mission type defined largely independently reducing difficulties specification coding debugging understandability improved opfac behavior routinely understood analyzed mission threads 
mission type components directly capture simplicity avoiding complications knowledge acquisition engineering rule sets 
implementation 
different mixin layer components gen fsats composed form fully loaded simulator 
individual components mission type just 
monolithic vanilla component 
discovered vanilla decomposed largely independent layers totalling classes deal different aspects fsats infrastructure 
example distinct components reading simulation scripts opfac communication local remote processes fo 
product line different fsats simulators possible presently emphasis fsats mission type extensibility 
worth noting exponentially large product lines fsats simulators synthesized mission components distinct compositions simulators 

artillery 
brigade fse 
artillery 
tot artillery 
opfac proxies objects evaluate opfac commanders supported desired weapons platforms different weapon distinct components mortar artillery gui displays graphical depiction ongoing simulations 
packaging capabilities distinct components simplifies specifications extraneous details need included debugging components largely debugged isolation 
important feature design coded threads executing single java process 
rmi adaptor component transforms design distributed program opfac thread executes process different site 
advantage substantially easier debug layers mission threads single process debugging remote executions 
furthermore distributed simulations needed adaptor included fsats design 
perspective 
worth comparing notion components common today software industry 
event distributed architectures dcom corba components communicate message exchanges dominant architectural paradigm 
original design fsats classic example opfac programs distributed dcom corba components exchange messages 
components common distributed architectures orthogonal components genvoca fsats design 
depicted vertical inheritance chain corresponds opfac corba dcom class fsats mission type depicted horizontal slice 
components layers encapsulate fragments encapsulating individual opfac 
typical approaches collaboration aspect designs 
corba dcom component legend layer refinement event architectures clearly extensible ability add remove component instances adding removing simulation 
opfac object population extensibility fsats definitely requires 
fsats needs feature extensibility opfac programs mission type extensible 
distinctions obvious hind sight prior 
fsats clearly differentiates 
fo 
brigade fse 
artillery 
corba dcom vs layers refinements domain specific language state machines discovered opfac rule sets largely representations state machines 
expressing opfac actions state machines substantial improvement rules easier explain understand require little background comprehend 
major goal redesign minimize conceptual distance architectural abstractions implementation 
problem faced encodings state machines obscure situation specifications refined previously created machines expressing state machines pure java code unattractive 
eliminate problems jts extend java domain specific language declaring refining state machines informal state machines nodes edges direct expression formal compilable document 
extended version java called took bit week code jts 
initial declarations 
central idea state machine specification translates definition single class 
generated variable current state value indicates current state protocol statemachine class instance 
message received opfac designated method invoked message argument depending state protocol different transitions occur 
shows simple state machine states transitions 
message arrives start state method true state advances state 
model fsats required boolean conditions triggered transition arbitrary java expressions side effects actions performed transition arbitrary java statements 
shows specification 
defines name formal parameters void method delivers message state machine 
case actions corrupted current state defines code executed error discovery 
message received transition activated defines code executed case ignore message 
states declared 
edges declared edge name start state state transition condition transition action 
java data member declarations methods introduced edge declarations 
specification translated class generated 
additional capabilities discussed 
refinement declarations 
state machines progressively refined layered manner 
refinement addition states edges data members methods existing machine 
common situation fsats illustrated 
protocols missions general type share protocol fragment initialization 
particular mission type artillery states edges specific 
additional missions contribute states edges allowing complex state machines built step wise manner 
start original state machine refinement expressed separate specifications encapsulated distinct layers 
layers composed specifications translated java class hierarchy 
shows hierarchy root class generated specification immediate subclass generated refinement specification terminal subclass generated refinement specification 
sketches specification refinement chain 
true state machine event delivery receive message error error default ignore message states start edge start conditions action edge start conditions action edge conditions true action methods data members 
boolean 
current state start 
state machine specification original second inheritance machine refinement refinement hierarchy refining state machines state machine original states edge edge state machine refines original states edge edge edge edge state machine second refines states edge edge 
refinement hierarchy inheritance class refinement plays central role implementation 
states edges inherited machine refinements states edges inherited machine refinements 
machine executed created instantiating bottom class refinement chain 
readers recognize example genvoca paradigm section 
perspective 
domain specific languages state machines common :10.1.1.17.5606:10.1.1.20.461
way expressing state machines states enter exit methods edges conditions actions elementary subset harel statecharts sdl extended finite state machines 
notion refinement statecharts ability explode individual nodes complex state machines 
different notion refinement explored 
closer refinement extended finite state machines sdl original second process class encodes state machine refined subclassing new states edges added extend parent machine capabilities 
idea state machine refinements new new context dsl addition general purpose programming language java fundamental context component development fsats simulators 
preliminary results preliminary findings encouraging objectives redesign met genvoca fsats design possible specify add verify test mission type independent mission types version fsats created single mission possible remove replace mission types accommodate varying user requirements allows direct implementation specification reducing conceptual distance specification implementation 
common re engineering projects detailed statistics effort involved original implementation available 
rough comparisons 
experience original fsats simulator estimate time add mission month 
similar addition genvoca fsats accomplished days including iteration identify correct initial misunderstanding protocols mission 
evaluate redesign anecdotal fashion collected statistics program complexity 
simple measures class complexity number methods number lines code number tokens symbols class 
originally metrics provided insights 
jts access component specification code layered code written fsats engineers generated non layered pure java code approximates code written hand 
metrics compare pure java code vs code layered vs non layered code quantitatively evaluate impact layering reducing program complexity key goal redesign 
complexity non layered java code 
consider non layered design fsats 
suppose class refinement chains squashed single classes classes written hand non layered design 
consider fsats class hierarchy rooted class class encapsulates methods encoding state machine shared 
prototype implemented different variants missions 
class subclass encapsulates additional methods java equivalent state machine edges states define actions specific forward observer 
subclasses encapsulate additions specific 
pure java columns table complexity statistics classes 
note statistics subclasses definition superclasses complexity superclasses inherited 
pure java class name table 
statistics non layered implementation class observation immediately apparent number methods mission impl huge 
different encoding techniques state machines reduce number complexity shifted methods complicated 
prototype deals missions expect number methods increase mission types added 
consider methods class missions 
add mission specialized particular weapon system mortar methods added 
representative mission complexity mission types added weapon specializations methods 
clearly class incomprehensible 
consider effects 
columns table show corresponding statistics state exit enter declarations edge declarations treated equivalent complexity method declarations 
call declarations method equivalents 
comparing corresponding columns table see coding reduces software complexity factor 
number method equivalents reduced factor number lines code reduced factor number symbols reduced factor 
problem noted pure java implementation remains 
generic mission contributes method equivalents specialized particular weapon system mortar method equivalents added 
substantially better non layered pure java equivalent 
expected programmers introduce modularity decomposing class hundreds methods multiple classes smaller numbers methods 
complicate white board implementation mapping want avoid guarantee resulting design mission type extensible 
method equivalents 
dsl simplifies specifications delays onset design fatigue 
non layered designs fsats may difficult scale ultimately hard maintain dsl 
complexity layered java code 
consider layered design implemented pure java 
inherited complexity columns table show inheritance cumulative statistics class refinement chains 
rows data listed bold represent classes terminals respective refinement chains 
rows correspond rows table 
isolated complexity columns table show complexity statistics individual classes table measuring class complexity including complexity superclasses 
note classes simple 
class example complex methods 
class encapsulates infrastructure methods missions 
table indicates layering logic different features classes units small comprehensible manageable programmers 
example having understand class methods largest layered subclass methods lines code lines inherited complexity isolated complexity class name 





table 
statistics layered java implementation class gauge impact layered design consider inherited complexity columns table show statistics refinement chains written 
isolated complexity columns table show corresponding statistics individual classes 
show layered specifi cations compact class methods lines code lines combination domain specific languages layered designs greatly reduces program complexity 
inherited complexity isolated complexity class name 







table 
statistics layered implementation class isolated complexity metric indicator class complexity requires discussion 
case true complexity class related total complexity superclasses plus additional complexity class 
argued inherited complexity metric better measure actual difficulty understanding layer 
case fsats 
typically fsats layers simply invoke methods superclass com corba components invoke methods server interfaces 
implementation details hidden interfaces making easy programmers invoke server methods having know servers implemented 
holds layers fsats 
difference methods fsats class override extend previously defined methods requiring programmers know guts superclass implementation 
fsats generators built additional implementation knowledge minimal 
may layers superclass implementations provide infrastructure programmers mission layers need aware simply methods private layer 
reasons believe isolated complexity closer true complexity class inherited complexity 
reduction program complexity key goal project tables support observations fsats engineers mapping white board design fsats protocols implementation direct invertible layered specifications 
writing components matches informal designs domain experts requires fewer mental transformations design implementation simplifies maintenance extensibility error prone product 
contrast mapping original fsats implementation back design possible due lack association particular rule set rules specific mission 
extensibility property simple changes design software artifact requires proportionally simple effort modify source code 
extensibility result engineering anticipated variabilities domain simple design 
complementary technologies emerging extensibility possible product line architectures plas domain specific languages dsls 
product lines rely components encapsulate implementation basic features aspects common applications domain applications extensible addition removal components 
domain specific languages enable applications programmed domain abstractions allowing compact clear machine processable specifications replace detailed code 
extensibility achieved evolution specifications 
fsats simulator army fire support representative complex domain distributed command control applications 
original implementation fsats reached state design fatigue anticipated changes enhancements capabilities expensive realize 
undertook task redesigning fsats inherent projected variabilities adding new mission types easy introduce 
important goal minimize conceptual distance white board designs domain experts actual program specifications complexity fire support specifications closely match designs generation fsats source understandable maintainable 
achieved goals extensibility understandability integration pla dsl technologies 
genvoca pla express building blocks fire support simulators layers refinements addition removal simultaneously impacts source code multiple distributed programs 
layered design insufficient components written easily pure java 
reason code expressing state machine abstractions lowlevel difficult read maintain 
addressed problem extending java language domain specific language express state machines refinements wrote components extended language 
preliminary findings confirm component specifications substantially sim white board designs domain experts direct invertible expressions specifications 
believe combination plas dsls essential creating extensible fire support simulators 
fire support admittedly domain specific unusual requirements domain specific need plas dsls benefits 
regard fsats unusual classical example domains technologies naturally complement produce result better technology deliver isolation 
research pla dsl technologies focus infrastructures ip jts support integration research pla dsl methodologies cognizant synergy possible desirable 
acknowledgments 
perry utexas insightful comments earlier draft bringing sdl attention frank weil motorola clarifying discussions sdl state machines 
referees helpful suggestions improved final draft 

system segment specification sss fire support automated test system fsats applied research laboratories university texas 
see url www utexas edu fsats shtml 

batory malley design implementation hierarchical software systems reusable components acm october 

batory shafer creating architectures example avionics symposium software reusability seattle washington april 

batory smaragdakis jts tools implementing domain specific languages th international conference software reuse victoria canada june 
url www cs utexas edu users schwartz jts beta htm 

batory composition validation subjectivity genvoca generators ieee transactions software engineering february 

batory product line architectures smalltalk java conference erfurt germany october 

batory smaragdakis architectural styles adaptors software architecture kluwer academic publishers patrick ed 

batory chen robertson wang design wizards visual programming environments genvoca generators ieee transactions software engineering may 

baxter design maintenance systems cacm april 

berry gonthier esterel synchronous programming language design semantics implementation science computer programming 

bosch product line architectures industry case study icse los angeles 

lin comparing frameworks layered refinement icse toronto 

chidamber kemerer metrics suite object oriented design oopsla 

czarnecki eisenecker components generative programming acm sigsoft 

van deursen klint little languages little maintenance sigplan workshop domain specific languages 

sarma formal object oriented language communicating systems prentice hall 

findler flatt modular object oriented programming units mixins icfp 

gamma design patterns elements reusable object oriented software 
addison wesley reading massachusetts 

goguen reusing interconnecting software components ieee computer february 

kerschberg knowledge approach generating target system specifications domain model ifip congress vol 

graves code decay project url www bell labs com org projects decay 

griss implementing product line features composing component aspects international software product line conference denver aug 

harel statecharts visual formalism complex systems science computer programming 

harel executable object modeling statecharts icse 

kang feature oriented domain analysis feasibility study sei 

technical report cmu sei tr november 

kiczales lamping mendhekar maeda lopes loingtier irwin aspect oriented programming ecoop 

lopez batory standard problem evaluating product line methodologies third international conference generative component software engineering september erfurt erfurt germany 

system segment specification sss advanced field artillery tactical data system 

neighbors method engineering reusable software components biggerstaff perlis eds software reusability addison wesley acm press 

neighbors protocol technologies url com 

seamless support creation maintenance object oriented systems journal object oriented programming october 

rich waters programmer apprentice acm press 

software engineering institute product line practice plp initiative url www sei cmu edu plp plp init html 

death computer languages birth intentional programming nato science committee conference 

smaragdakis batory implementing layered designs mixin layers ecoop 

smaragdakis batory appear acm transactions software engineering 

tarr ossher harrison sutton jr degrees separation multi dimensional separation concerns icse 

taylor panel software reuse motorola software engineering symposium ft lauderdale 

tokuda batory evolving object oriented architectures refactorings conf 
automated software engineering orlando florida 

van notkin role components implement collaboration designs oopsla 

weiss lai software product line engineering addison wesley 

