call value games samson abramsky guy mccusker university edinburgh department computer science james clerk maxwell building edinburgh eh jz scotland 
mail samson dcs ed ac uk st john college oxford ox jp england 
mail mccusker comlab ox ac uk 
general construction models call value models call name computation described 
construction essential properties sum types common denotational models call name 
applied categories games yields fully models call value functional language pcfv extended incorporate recursive types language local standard ml 
years game semantics emerged novel intuitively appealing approach modelling programming languages 
success providing syntax free description fully model pcf full abstraction results obtained untyped recursively typed functional languages languages imperative features :10.1.1.28.2978
addressed problem modelling call value languages major shortcoming real life languages including standard ml call value 
honda yoshida provided fully games model call value pcf pcf new category games 
show fact framework provided full abstraction results call name interpret call value full abstraction retained 
main tool general construction takes call name model returns model call value computation 
essentially matter programming suitable type theory choose level categorical models 
apply construction known models call name usual category cpos categories games 
case familiar model pcf predomains partial functions recovered 
cases new games models discovered 
contains fully model pcf extended provide fully model recursively typed language fpc second fully rml language ml style 
model pcf alternative presentation honda yoshida 
results rml provide syntax free description fully model language combining dynamically allocated store higher order procedures 
underlying categories games new new proof techniques required establish results 
fact proofs full abstraction axiomatic level introduced 
reason concentrate describing general construction outlining model definitions omitting proofs 
fam construction call name languages viewed certain extensions typed calculus 
natural choice model call name cartesian closed category equipped extra structure account additional features language question usually including fixed point operator interpret recursion 
category thought category domains category cppo complete partial orders element continuous functions provides example 
addition products function spaces cccs interpret programming languages sum types 
known ccc fixed points coproducts interpretation sums category kind weak coproduct 
prototypical model call name cartesian closed category weak coproducts sense precise 
hand moggi shows call value interpreted ccc coproducts bicartesian closed category provided extra structure shape strong monad 
leading example model category cpo complete partial orders possibly element total continuous functions familiar operation lifting provides strong monad kleisli category call value languages interpreted pcpo category predomains partial functions studied plotkin 
model call name computation cartesian closed category weak coproducts additionally ask small products just finite ones 
construct bicartesian closed category fam define strong monad 
objects category fam families fa ig objects indexed set map oe fa ig fb jg consists reindexing function map oe 
construction familiar category theory free completion respect coproducts 
cppo fam thought category disjoint unions pointed cpos total continuous functions full subcategory usual category cpo predomains 
lemma 
fam cartesian closed coproducts bicartesian closed category 
products fa ig theta fb jg fa theta theta jg reindexing function projection projection theta map theta fibre projection similarly pairing maps consists pairing reindexing functions pairings fibrewise maps terminal object singleton family 
exponential defined follows 
fa ig fb jg pi ask products just finite ones 
map oe fa ig theta fb jg fc kg reindexing function fibrewise maps oe corresponding curried map oe formed currying map ith fibre type gamma 
pi fold pairing oe ji 
coproducts formed disjoint union families fa ig fb jg coproduct fc jg initial object empty family fg 
ccc domains construct predomains total maps 
order define suitable monad fam require weak coproducts sense 
call subcollection objects pointed call subcategory full subcategory pointed objects category strict maps family fa ig objects posit pointed object sigma maps sigma family oe maps pointed unique strict map oe sigma satisfying oe oe define monad fam follows 
object fa ig define tfa ig sigma singleton family 
unit fa ig tfa ig unique reindexing function map sigma lifting operation takes map oe fa ig jg consist unique reindexing function fibrewise maps oe sigma map oe tfa ig jg morphism fibre defined oe 
lemma 
gamma kleisli triple monad fam 
see definitions concepts 
satisfies mild conditions define natural transformation theta tb theta making strong monad 
double strength morphism defined ta theta tb ta theta theta ta theta theta theta id partner ta theta tb tb theta ta theta theta maps coincide general necessarily commutative monad 
certain consequences 
maps oe tb tc fam thought partial maps respectively ways forming partial pairing morphism theta hf gi hf gi think reflecting distinction evaluating pair left right evaluating right left 
pure functional languages distinction redundant come consider language side effects crucial 
equipped strong monad furthermore kleisli category seen enriched original model call name computation fixed points endomorphisms enriched operations kleisli category fixed points 
allows interpret recursion standard way 
final construction necessary intrinsic preorder category 
define order homset follows ff ff ff 
obtained currying map induces equivalence relation homset usual way 
equivalence classes maps gives category refer extensional quotient fam 
straightforward show structure strong monad lift category 
see works case cppo 
objects pointed strict maps take expected 
weak coproduct separated sum 
suggested think fam cppo full subcategory usual category predomains family fa ig thought disjoint union domains monad takes family singleton family sigma separated sum coincides lifting case kleisli category full subcategory pcpo 
intrinsic preorder reduces ordinary pointwise ordering continuous functions case extensional quotient fam cppo 
known cppo contains fully model language pcf additional parallel conditional constant pcpo contains fully model call value pcf parallel conditional 
construction takes category giving fully model callby name variant call value variant 
construction applied category games contains fully model pcf parallel conditional obtains fully model pcf applied liberal category games contains fully model idealized algol fully model language ml style obtained 
games section give intuition games models explain equip categories introduced weak coproduct construction described applied 
omit full definitions categories involved 
game consists set rules participants player opponent moves 
moves players alternate 
idea represents environment user program plays behalf program 
simple game model natural numbers call name pcf typical play depicted follows 
begins asking question corresponds user running program type respond number played number 
possible fail respond corresponds nontermination program 
tensor product games formed playing side side interleaved parallel omega linear function space moves left hand game moves vice versa play look play particular run square program begins demanding output order calculate output requires input demands move left hand side supplies input give output 
function strategy predetermined set responses moves 
types modelled games programs modelled strategies games 
category games objects strategies game morphisms strategies composed parallel composition plus hiding 
game moves tensor unit 
program strategy composing squaring strategy gives parallel composition hiding action middle game just strategy program expected 
shown ideas extended turn model linear logic 
subcategory inn morphisms strategies just innocent ones 
strategy innocent bases decision move entire history play far certain subsequence called view model linear logic 
categories inn give rise cccs inn called intensional categories maps strategies simply game version moves repeated single play consists interleaved plays applying construction previous section cccs obtain categories fam fam inn model call value computation 
words warning sketch incomplete 
formal definition game introduces notion justification move played pointer attached indicating earlier move justifies 
facilitates definition view sequence innocent strategies categories inn inn details definitions build pioneering hyland ong 
weak coproducts final piece structure need apply construction games models weak coproduct inn fact shall obtain weak coproduct inn define 
say game pointed opened technical condition see unique initial move map oe pointed games strict responds initial move initial move family games fa ig pointed game sigma defined follows 
set moves disjoint union moves fresh moves fi ig 
move unique initial move respond answer 
play continues initial moves justified strategy sigma responds initial question plays copycat available copies family maps oe pointed strict strategy oe sigma plays follows 
responds initial move sigma plays move continues playing oe play 
clear composing yields oe furthermore unique strict strategy property 
construction lifts inn follows 
pointed games strict maps form der oe oe strict map inn sum family fa ig sigma injections strategies sigma 
family maps oe pointed strategies oe strategy der oe sigma corresponds precisely girard translation intuitionistic disjunction linear logic 
worth noting interpretation sum types take form linear sum sigma led unsatisfactory situation models sum types existed extensional quotient 
moving girard translation furthermore gives interpretation sums extensional quotient 
applying construction see happens apply construction obtain games model call value 
fam families games objects map fa ig fb jg consists function strategy oe recalling definition monad map fa ig jg family strategies oe sigma universal property weak coproduct family alternatively seen single strict strategy oe sigma sigma kleisli category seen subcategory consisting games form sigma strict strategies 
modelling programming languages type natural numbers interpreted family ng 
representation game sigma precisely game described previously 
type pairs naturals theta ng 
game begins unique initial question responds giving pair natural numbers 
contrasted call name interpretation asking question component pair second responds single natural number case 
distinction seen intensional description difference product smash product cpos domain models 
relationship honda yoshida representation initial questions games somewhat redundant play strategy oe sigma sigma model begins unique initial question right hand side strategy responds asking unique initial question left hand side 
possible reformulate model moves elided play begins supplying index left 
economical representation closely resembles model call value proposed honda yoshida 
believe model pcf way 
pcf simplest typed call value functional programming language pcf simply typed calculus constants arithmetic recursion 
types grammar exp canonical forms language succ pred ya ranges natural numbers countable collection variables general terms defined mm am constants type exp succ pred type exp exp types ya type 

terms type exp type term am type omit standard definition terms context gamma gamma xn list distinct variables tagged types containing variables free operational semantics defined 
relation observation equivalence terms context gamma gamma defined follows 
write gamma just iff contexts gamma closed terms 
see detailed definition contexts substitution terms holes 
functions mn arithmetic succ mn pred mn pred mn conditionals recursion mn fig 

operational semantics pcfv interpretation pcf categories fam fam inn games standard type exp interpreted object ng coproduct countably copies terminal object type interpreted 
term context xn interpreted morphism xn theta delta delta delta theta follows 
numeral interpreted tn nth coproduct insertion 
constant succ interpreted coproduct structure map tn pred handled similarly 
model enrichment categories fam fam inn inn respectively obtain fixed point combinator 
fact consider categories cppo enriched usual order theoretic construction fixed point operator 
standard definitions complete semantics 
gamma ja gamma theta gamma gamma gamma gamma mn ev gamma notice semantics application mn reflect fact intended interpreter evaluates proposition 
closed terms 
proposition 
closed terms 
proved straightforward induction 
second requires computability predicate argument logical relation methods completely standard 
easy consequence results proposition soundness 
gamma gamma emphasized results hold innocent knowing games models 
definability result holds innocent strategies 
proof mild generalization pcf 
proposition innocent definability 
types pcf oe theta delta delta delta theta compact morphism fam inn 
exists term xn pcf oe 
easy show model pcf provided inn extensional quotient fam inn fully 
theorem full abstraction pcf 
model pcf inn fully 
proof 
soundness follows easily soundness model fam inn 
completeness suppose wlog closed terms type definition inn exists compact morphism ff ta wlog ff ff 
fact find compact morphism fi tn tn fi fi 
innocent definability fi term 
recursive types categories products coproducts straightforward matter extend results version pcf augmented product sum types 
natural useful extension add recursive types done type natural numbers associated constants combinator definable led simple syntax plotkin language fpc 
types theta ranges countable collection type variables 
standard way interpret type system category model type free type variable functor op theta mixed variance functor account types positive negative occurrences treated separately 
closed type interpreted object satisfying conditions specifying canonical solution freyd notion minimal invariant 
operations corresponding sums partial function spaces functorial kleisli category monad lack commutativity means product operation necessarily lift bifunctor kleisli category gives rise premonoidal structure monoidal 
fact manifested existence different pairing operators find forms obstacle interpreting recursive types 
lost 
kleisli categories fam fam inn subcategory containing objects type constructors functorial 
map kleisli categories consists family strategies oe sigma family included corresponding subcategory iff oe empty strategy factors 
subcategory equivalent kleisli category fam fam inn monad gamma 
simple matter check operations product sum function space functorial subcategory 
results adapted show functors minimal invariants closed types fpc interpretation objects subcategories kleisli categories 
furthermore loc 
cit pitts theory invariant relations show model fpc obtained sound 
analogue innocent definability result holds model establish 
theorem full abstraction fpc 
fam fam inn extensional quotients inn contain sound models fpc 
compact morphism finite fpc type fam inn definable model inn fully 
notice results version fpc call value operational semantics call name variant fully games model provided 
note improved interpretation sums inn model soundness definability results intensional categories previously models existed extensional level 
language store radical extension pcf addition mechanism generation program variables 
expressive power extended language great example objects classes simple form considered syntactic sugar 
price extra power behaviour programs quite subtle difficult reason 
distinct ways variables allocated 
exemplified algol languages employs block structure variables local blocks allocated entry block deallocated exit 
second method languages standard ml referred dynamic allocation 
possible access variable allocated block passed outside block variable allocated seen persisting forever 
detailed analysis behaviour languages feature undertaken pitts stark operational denotational techniques fully model known 
fully games model idealized algol category 
show category fam fully language dynamically allocated 
may surprising modifying game semantics idealized algol stack storage applying general construction gives rise model language dynamically allocated storage scope extrusion effects 
fact illustrates considerable flexibility afforded underlying linear types 
model idealized algol uses standard kleisli construction morphisms linear arrows form composition promotion means strategy may history sensitive start scratch call persistent storage effects modelled 
contrast underlying linear arrows fam model simplifying slightly form composition simply composition linear category 
means history sensitive strategies carry information invocation effects characteristic heap allocated storage scope extrusion captured 
describe language study 
bears close resemblance reduced ml studied stark important distinction discussed 
call language rml 
add pcf type com commands akin unit type standard ml command viewed function side effects returns trivial value 
command side effect canonical form skip 
add type var variables store natural numbers constants deref var com assign var exp com new var dereferencing assignment allocation fresh variables 
constants large variety imperative constructs defined abbreviations 
instance new var new com assign notice call value essential 
reynolds analysis variables algol languages identify type var product access methods dereferencing produces computation natural number assignment takes expression produces command var exp theta exp com identification complete add language constant creating new variable objects com exp 
exp com var semantically essentially pairing constructor var type 
constant means called bad variables terms type var denote actual memory locations play important role language 
particular means rml conservative extension stark reduced ml 
implies equality test var type meaningless general sense ask terms type var denote memory location 
worth mentioning conversely languages variables equality definable 
idea simply write different values variables test contain value 
key differences language standard ml rml allows storage values ground type standard ml store type second bad variables exist 
absence equality language equivalently presence bad variables may regarded greater lesser defect depending view number related issues 
example language ml may store values type var type constructor var 
peter hearn pointed absence bad variables type constructor functorial fact preserve isomorphisms 
raises serious questions denotation variables hl hl flg sil assignment hl sim hl il hl hl hl hl 
skip assign skip dereferencing hl sim hl il hl hl skip deref fig 

operational semantics rml recursive types languages 
rate finding fully model language equality left challenge 
operational semantics terms stores follows 
range countable collection locations finite sets locations 
store partial function natural numbers 
write 
store obtained updating mapped operation may extend domain operational semantics takes form judgements hl sim hl store store adopting convention rule delta delta delta mn vn abbreviation hl im hl iv hl im hl iv hln hln hl im hln iv additions operational semantics shown 
notice locations appear operational semantics syntax part official syntax language appear user programs 
access locations allocated new 
outline interpretation rml fam extension pcf type com interpreted terminal object interpretation var 
define deref tn theta tn assign tn theta skip interpretation suitable currying pairing constructor 
note maps exist fam inn fam interpret rml new constant innocent strategies 
call sublanguage rml gamma 
interpret new give morphism cell var strategy game sigma sigma theta sigma 
sigma means sum singleton set unique element call game sigma plays form delta sigma consists countably disjoint copies game 
write move nth copy write move copy ok similarly play delta sigma written read delta plays var look delta delta write delta ok delta read delta delta delta delta strategy cell obvious responds initial indicate convergence 
responds write ok read value written 
strategy innocent model rml fam inn extra freedom arbitrary strategies necessary 
proposition soundness 
model rml fam sound proved similar way soundness result idealized algol 
rml gamma modelled innocent strategies definability result available proved just pcf proposition innocent definability rml 
compact morphism rml type fam inn definable term rml gamma 
result proposition innocent factorization 
type rml oe morphism fam 
exists var fam inn cell oe 
furthermore oe compact fam chosen compact fam inn 
idea proof result innocent strategy simulates knowing strategy oe storage cell record history play 
factorization gives rise proposition definability rml 
compact morphism rml type fam definable term rml 
proof 
just consider case morphism oe 
proposition factorizes cell compact innocent map var 
innocent definability var oe new 
just pcf definability result allows prove full abstraction 
theorem full abstraction rml 
model rml fully 

abramsky jagadeesan malacaria 
full abstraction pcf 
accepted publication information computation 

abramsky 
axioms full abstraction full completeness 
plotkin sterling editors milner festschrift 
mit press appear 

abramsky mccusker 
linearity sharing state fully game semantics idealized algol active expressions 
hearn tennent editors algol languages pages volume 
birkhauser 

fiore 
axiomatic domain theory categories partial maps 
distinguished dissertations computer science 
cambridge university press 

fiore plotkin 
axiomatization computationally adequate domain theoretic models fpc 
proceedings ninth annual ieee symposium logic computer science pages 
ieee computer society press 

freyd 
recursive types reduced inductive types 
proceedings fifth annual ieee symposium logic computer science 
ieee computer society press 

freyd 
algebraically complete categories 
carboni editors proc 
como category theory conference pages berlin 
springerverlag 
lecture notes mathematics vol 



girard 
linear logic 
theoretical computer science 

honda yoshida 
game theoretic analysis call value computation 
degano gorrieri spaccamela editors proceedings th international colloquium automata languages programming icalp volume lecture notes computer science pages 
springerverlag 

hyland 
ong 
full abstraction pcf ii iii 
accepted publication information computation 

jacobs 
semantics weakening contraction 
annals pure applied logic 

mccusker 
games full abstraction functional metalanguage recursive types 
phd thesis department computing imperial college university london 

mccusker 
games full abstraction fpc 
proceedings eleventh annual ieee symposium logic computer science pages 
ieee computer society press 

moggi 
notions computation monads 
information computation 


hereditarily sequential functionals 
proceedings symposium logical foundations computer science logic st petersburg lecture notes computer science 
springer 

pitts 
relational properties domains 
information computation 

pitts stark 
observable properties higher order functions dynamically create local names new 
mathematical foundations computer science proc 
th int 
symp gda volume lecture notes computer science pages 
springer verlag berlin 

pitts stark 
observable properties higher order functions dynamically create local names preliminary report 
workshop state programming languages copenhagen pages 
acm sigplan 
yale univ dept computer science technical report yaleu dcs rr 

pitts 
notes inductive inductive techniques semantics functional programs 
notes series brics ns brics department computer science university aarhus december 
vi pp draft version 

plotkin 
lcf considered programming language 
theoretical computer science 

plotkin 
lectures predomains partial functions 
notes course center study language information stanford 

power robinson 
premonoidal categories notions computation 
mathematical structures computer science 

reynolds 
syntactic control interference 
conf 
record th acm symposium principles programming languages pages 

reynolds 
essence algol 
proceedings international symposium algorithmic languages pages 
north holland 


relating full abstraction results different programming languages 
proceedings th conference foundations software technology theoretical computer science bangalore 
springer lncs 

stark 
names higher order functions 
phd thesis university cambridge dec 
