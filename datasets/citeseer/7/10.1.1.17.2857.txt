safe untrusted agents proof carrying code george necula peter lee carnegie mellon university school computer science pittsburgh pa usa 
proof carrying code pcc enables computer system determine automatically certainty program code provided system safe install execute requiring interpretation run time checking 
pcc applications computing system safe efficient dynamic installation code needed 
key idea proof carrying attach code easily checkable proof execution violate safety policy receiving system 
describes design typical implementation proof carrying code language specifying safety properties order predicate logic 
examples safety properties covered memory safety compliance data access policies resource usage bounds data abstraction boundaries 
proof carrying code pcc enables computer system determine automatically certainty program code referred agent provided system safe install execute 
key idea pcc external system shall henceforth refer code producer provides encoding proof code adheres safety policy defined recipient code shall call code consumer 
proof encoded form transmitted digitally consumer quickly validated simple automatic reliable proof checking process 
pcc useful applications 
enhances ability collection software systems interact flexibly efficiently providing capability share executable code safely 
typical examples code consumers include research sponsored part advanced research projects agency title fox project advanced languages systems software arpa order 
issued esc ens contract 

views contained document authors interpreted representing official policies expressed implied advanced research projects agency government 
submitted lecture notes computer science special issue mobile agents 
operating system kernels world wide web browsers allow untrusted applications internet hosts install execute code 
pcc useful situation safety presence newly installed code paramount 
pcc key characteristics combination give advantage previous approaches safe execution foreign code 
pcc general 
code consumer defines safety policy policy limited particular notion safety 
experimented simple safety properties memory type safety properties normally difficult verify time limits execution resource usage bounds 

pcc low risk automatic 
proof checking process code consumer determine code safety completely automatic implemented program relatively simple easy trust 
safety critical infrastructure code consumer rely reduced minimum 

pcc efficient 
practice proof checking process runs quickly 
furthermore contrast previous approaches code consumer modify code order insert costly run time safety checks consumer perform checking interpretation proof validated code installed 

pcc require trust relationships 
consumer need trust producer 
words consumer know identity producer know process code produced 
information needed determining safety code included code proof 

pcc flexible 
proof checker require particular programming language 
pcc wide range languages machine languages 
describes proof carrying code enforce safety presence untrusted agents 
general overview basic elements pcc 
major components pcc described subsequent sections 
concrete presentation implementation details pcc introduce sect 
stripped example safety policy associated agent agentbased shopping 
complete discussion pcc review agent example context complex safety policy sect 

conclude comparison related presentation result showing agents pcc faster agents safety enforced run time checking 
basic elements proof carrying code proof carrying code applications application may entail variations precise details approach 
say variations section 
section describe high level canonical implementation pcc general variations seen optimizations special cases 
general form pcc involves addition code consumer code producer proof producer 
practice turns code producer proof producer system general may separate entities 
central component pcc implementation safety policy specified code consumer 
term safety policy distinct ways 
denote set safety rules code consumer desires enforce untrusted code 
term safety policy denote concrete realization safety rules components code consumer program called vcgen proof checker configuration file defines logic valid axioms inference rules may proofs 
details implementation safety policy sect 

safety policy defined pcc involves stage interaction process 
stage code consumer receives untrusted code extracts safety predicate proved execution code violate safety policy 
predicate sent proof producer proves returns proof back consumer 
second stage code consumer checks validity proof simple fast proof checker 
proof valid proof safety predicate untrusted code installed executed 
stage verification process key design element contributing advantages listed previous section 
particular reason pcc certify code properties difficult impossible infer code directly 
staging verification difficult phase proof generation simple phase proof checking able minimize complexity safety critical infrastructure implementation proof checking process greatly reducing risk bug system leads failure detect unsafe programs 
fact design goal pcc task result easily checked generated performed untrusted entity code proof producer checked code consumer 
give step step description typical pcc session glossing implementation details 
details deferred parts 
fig 
shows session canonical pcc implementation sequence steps determined arrows 
step 
pcc session starts code producer preparing untrusted code sent code consumer 
part preparation producer adds annotations code 
annotations exact nature discussed contain information helps code consumer understand safety relevant properties code 
code producer sends annotated code code consumer requesting execution 
annotated executable ae safety predicate sp safety proof prf verify prf proves sp scan ae generate safety predicate prove sp code consumer code producer proof producer install run untrusted trusted vcgen fig 

overview proof carrying code 
step 
receiving annotated code code consumer performs fast detailed inspection annotated code 
accomplished program called vcgen component consumer defined safety policy 
vcgen performs tasks 
checks simple safety properties code 
example verifies immediate jumps code segment boundaries 
second vcgen watches instructions execution violate safety policy 
instruction encountered vcgen emits predicate expresses conditions execution instruction safe 
standard terminology field automatic program verification refer predicates verification conditions vcgen seen classical verification condition generator 
collection verification conditions control flow information safety predicate copy sent proof producer 
step 
receiving safety predicate proof producer attempts prove event success sends encoding formal proof back code consumer 
code consumer trust proof producer system act proof producer 
particular code producer act proof producer 
step 
step pcc session proof validation step performed code consumer 
phase performed program refer proof checker 
proof checker verifies inference step proof valid instance axioms inference rules specified part safety policy 
addition proof checker verifies proof proves safety predicate generated step predicate 
step 
executable code passed vcgen checks proof check trusted violate safety policy installed execution need run time checking 
variants proof carrying code fig 
step process described canonical view proof carrying code 
approach pcc 
redistributing tasks entities involved adapt pcc special practical circumstances maintaining safety guarantees 
section briefly discuss variations 
subsequent sections details implementation component pcc 
variant pcc code producer runs vcgen submits resulting predicate proof producer 
code proof sent code consumer runs vcgen verifies incoming proof proves resulting safety predicate 
arrangement possible secret vcgen untrusted code producers 
retain safety guarantees original pcc necessary code consumer repeats vcgen step order produce trustworthy safety predicate 
version saves communication step generating safety predicate preferred interactive version latency verification minimized 
variant pcc code consumer proof generation 
possible case safety predicate relatively easy prove automatically extra knowledge program 
variant pcc useful situations generated proof large send communication channel proof producer code consumer 
code consumer variant pcc safety critical infrastructure consisting vcgen proof checker remains 
tempted save cost generating storing verifying proof altogether trusting theorem prover consumer side 
saving expense greatly increasing size complexity safety critical infrastructure experience suggests relying correctness complex theorem prover dangerous game 
scheme employing pcc variants establish safety code code consumer system forward code execution system trust trust established convenient means digital signatures 
scheme useful trusted machines computational power perform vcgen proof checking phases machines power want execute untrusted code 
example firewall certify external code pcc forward code machines inside firewall 
matter variants chosen share characteristic depending small defined safety critical infrastructure simple proof checker vcgen 
design details vcgen starting section reconsider detail main building blocks pcc system 
start vcgen continue section description proof checker proof generator 
purpose vcgen twofold perform simple checks untrusted code emit verification conditions checks mandated safety policy difficult perform time 
order simplify adaptation vcgen different safety policies useful restrict checks performed vcgen code properties encountered safety policies branch targets code boundaries function invocations follow stack discipline 
checks emitted general verification conditions interpretation left logic proofs safety predicates 
configuration data safety predicate sp parser symbolic evaluator annotations code vcgen fig 

structure vcgen example useful assume form memory safety going part safety policy 
want hard wire vcgen particular form memory safety 
designed vcgen emit generic verification condition saferd mem addr attempted read access address addr memory state mem 
left proof logic determine meaning saferd predicate 
logic say saferd true effectively disallowing memory reads 
techniques implementing vcgen described literature 
shown fig 
approach implementing vcgen involves main components 
language dependent parser purpose translate instructions untrusted annotated code stream instructions generic intermediate language il understood second component symbolic evaluator 
vcgen customized particular safety policy configuration file provided part safety policy code consumer 
example agent travel agency 
concrete presentation implementation details follow introduce simple example safety policy associated agent agent shopping 
assume travel agency host records database pricing information airline tickets various destinations 
distinguishing feature particular travel agency mobile untrusted agents allowed scan database communicate back parent host 
control access information database travel agency implements multi level access protection scheme database 
purpose assigns access levels agent record database requires agent access records access level equal access level 
things interesting travel agency decides mediate interaction agent database proof carrying code select agents obey safety policy behavior uncertain 
purpose simple agent computes best available price trip 
actual agent expressed dec alpha assembly language clarity show source code fig 

simplifying assumption database array pricing entries entry containing bit fields encoding entry access level source destination airport associated price order 
focus operation reading price fields 
agent sections exemplify operation building blocks pcc 
purpose providing simple example initially ignore communication agent parent host 
sect 
expand safety policy allow communication restrict agent cpu cycles network bandwidth 
int main entry tab int len access acc len tab access acc fint tab price fig 

fragment agent computes best available price trip 
code annotations code properties interest general difficult infer code directly 
cases vcgen relies code annotations provided producer extra source information code behavior 
doing careful allow incorrect annotations hide unsafe program behavior 
kinds annotations currently mandatory optimization purposes 
important mandatory annotations loop invariants 
main purpose associate loop set properties preserved execution loop body sufficient proving safety code 
presence loop invariant loop code possible vcgen extract safety predicate just pass thorough code 
requirement loop associated invariant easily satisfied associating invariant backward branch target 
loop invariant verification conditions emitted part safety predicate verifies invariant holds loop entry verifies preserved loop iteration 
proved induction loop invariant assumed valid purpose inspecting loop body code loop 
example code annotations call target annotations required disambiguate target indirect call instruction 
kind annotations needed example untrusted code written dec alpha assembly language indirect function calls exist 
vcgen reads call target annotation continues code inspection assuming annotation correct 
prevent safety breaches vcgen generates safety condition call site requiring value expression indirect call equal address destination declared annotation 
important annotations describe 
share property untrusted model loop invariants call target annotations checked verification conditions 
vcgen configuration file order reduce need dynamic checking parameters code consumer usually declares precondition essentially description calling convention consumer invoking untrusted code 
example untrusted code needs access ethernet network packets code consumer declare argument passed code array length bytes 
assumption array accesses packet header fields proved safe need run time checking 
safety policy declare postconditions untrusted code 
constraints final execution state untrusted code 
precondition postcondition parameters vcgen part safety policy 
preconditions postconditions functions declared untrusted code functions exported code consumer expressed order logic predicates vcgen configuration file 
code consumer guarantees code precondition holds untrusted code invoked 
turn untrusted code ensure postcondition holds return 
functions exported consumer situation reversed precondition predicate untrusted code establish calling function postcondition predicate untrusted code may assume hold return function 
example safety policy agent travel agency 
return example introduced purpose defining precondition postcondition 
purpose define predicate entry denote memory state agent access level address points entry pricing database 
described formally follows entry saferd saferd saferd sel oe saferd informally definition says bit words situated offsets start entry readable word situated offset price readable value word access level equal agent access level 
safety policy requires agent contains function main tab len acc expects arguments starting address table number entries table access level assigned agent 
postcondition assigned agent time meaning imposes requirements agent result 
calling convention expressed pair precondition postcondition shown pre main len oe entry mem tab theta acc post main true variables vars variable sets vars labels label expressions expr gamma sel upd predicates pred true false oe px saferd safewr instructions instr set assert call ret branch inv table 
syntax intermediate language il 
safety policy enforced runtime access table mediated host 
example untrusted agent performs access checks invoking host greatly reducing run time penalty enforcing safety 
code parser purpose code parser provide machine language independent interface symbolic evaluator 
fact parser component pcc system 
translating instructions incoming language intermediate language abstracts language code details relevant safety policy 
intermediate language il syntax shown tab 

simplify parsing machine code generic assembly language il 
examples require distinguished variable mem denoting state memory symbolic evaluation 
safety policy explicit state components memory modeled similar fashion 
requirement sets variables labels left time depend particular source language parsed 
expository purposes intermediate language restricted constructors shall examples 
practice expressions arithmetic logical operation need included 
depending needs safety policy extension firstorder logic temporal linear higher order logic 
special expression constructors merit discussion 
expression sel denotes contents memory address memory state denoted expression upd denotes new memory state obtained old state updating location value denoted level predicates introduce special predicates dealing memory safety 
predicate saferd valid memory state denoted safe read address denoted predicate safewr similarly memory writes extra argument denoting value written 
invariant instruction inv requires predicate valid corresponding program point declares maximal set variables modified loop paths contain instruction 
instructions parser signal symbolic evaluator memory access instruction decoded 
safely ignored safety policy concerned memory safety state changing semantics redundantly expressed set instructions see tab 
examples 
example fig 
shows possible il representation agent fig 

loop invariant main loop changed variable loop set loop inv fjg branch len len done branch sel mem tab theta acc acc tab theta set sel mem tab theta set branch true loop fig 

intermediate language representation agent shown fig 

example parsing dec alpha machine code 
example describe parser subset dec alpha machine code intermediate language il 
set variables case machine registers dec alpha plus special memory variable mem 
order simplify resulting safety predicate want parser interpret spill area stack frame extension register file 
purpose extend set il variables ff gamma limit impose number spill slots 
order keep parser simple require set modified variables optimization allowing symbolic evaluator construct smaller safety predicates 
missing conservatively approximated set variables scope 
avoid danger aliasing spill area safety policy ensure area declared safe access arbitrary memory operations 
il observations start function set sp sp set ra ra start function save values stack pointer return address 
addl rd set rd arithmetic logical instructions done similarly 
ann call jsr ra pv assert sp sp gamma assert pv call set ra pc require call annotation 
emit checks stack pointer correctness annotation 
return address register changed call 
jsr zero ra assert sp sp assert ra ra ret return verify stack pointer return address 
ann inv inv invariant annotations propagated unchanged 
ldl rd sp assert sp sp gamma set rd check mod 

emit check stack pointer 
ldl rd set rd sel mem load instructions signal read effect state 
stl rs sp assert sp sp gamma set rs check mod 

emit check stack pointer 
stl rs rs set mem upd mem rs store instructions signal write effect memory state 
beq rs branch rs pc rs pc mapping dec alpha machine code addresses indices stream il instructions 
table 
parser dec alpha machine code 
current function parsed declared frame size 
line pc machine code index dec alpha instructions 
untrusted code declare frame size 
spirit simplicity memory accesses register sp interpreted accesses stack 
accesses treated ordinary memory accesses 
purpose checking procedure calls returns define special variables sp ra keep initial values stack pointer return address registers 
dec alpha indirect procedure calls difficult translate il call syntax requires immediate label 
information gap bridged requiring position immediately preceding call instruction call target annotation ann call declares actual call target 
table shows definition parser dec alpha machine code mapping sequences dec alpha machine instructions annotations sequences il instructions 
line table assumed occur index pc machine code 
convenience assume annotations lined machine code 
practice actual implementation stores annotations line data segment 
symbolic evaluator symbolic evaluator executes intermediate code produced parser 
opposed concrete evaluator perform basic operations il computes result symbolic expression 
symbolic evaluator implemented linear pass code loops required invariant 
output symbolic evaluator safety predicate consists mainly verification conditions 
verification condition emitted example symbolic evaluator encounters memory operations 
verification conditions symbolic evaluator emits predicates corresponding taken branches invariants reflecting control structure code 
respects safety predicate expression part operational semantics untrusted code relevant safety policy 
order define symbolic evaluator introduce notation 
mapping pi associates function labels triplets containing precondition postcondition set modified global variables 
write pi pre post function declared precondition pre postcondition post set modified global variables state symbolic evaluator consists current index il instruction stream partial mapping variables symbolic expressions ae vars expr write ae denote state obtained ae setting variable write ae denote expression resulting substitution variables values ae 
extend substitution notation predicates 
evaluation invariant instructions symbolic evaluator keeps track invariants seen far path start current instruction 
invariant symbolic evaluator remembers execution state time invariant encountered 
accomplished mapping instruction indices labels states loops label moment symbolic execution dom set invariants current path start 
symbolic evaluator parameterized current function evaluated mapping pi shall omit subscripts se pi label theta theta loops pred simplify presentation evaluator assume prior evaluation prepend il representation function instruction inv pre pre precondition set modified registers se ae ae il set ae se ae il assert ae oe se ae ae oe se ae il branch oe il inv oe il inv saferd ae ae se ae il safewr ae ae ae se ae il ae yk ae oe se ae ae il inv fx dom fy new variables ae ae xk yk ae ae il inv dom ae pre yk ae post oe se ae il call pi pre post fx fy new variables ae ae xk yk ae post ae il ret pi pre post table 
definition se pi ae symbolic evaluator generic memory safety 
table presents definition symbolic evaluator function se pi ae cases depending instruction evaluated il 
kind instruction case invariant instructions treated differently time encountered 
evaluation set instruction consists updating state continuing instruction 
case assertion symbolic evaluator emits asserted predicate variables substituted current state 
conditional branch symbolic evaluator considers branches recursively builds safety predicate conjunction implications 
left side implication guard predicate branch 
way control flow information available purpose proving verification conditions arising evaluation branches 
instructions evaluator emits appropriate verification conditions safety memory access 
evaluation loop invariant instruction encountered time index dom consists asserting invariant altering values variables changed loop processing loop body new state 
invariant predicate assumed hold considering loop body new state recorded invariant instruction encountered evaluator asserts invariant predicate checks variables declared modified changed 
verification conditions corresponding equality checks generated auxiliary function ae ae dom ae dom ae gammas ae ae surprisingly function call return instructions processed manner similar loop invariants just minor differences 
processing ret instruction state equality check recovered possible instruction function index invariant instruction inv pre optimization evaluator verify simple verification conditions 
effect reducing safety predicate size implicitly proof size 
cost optimization increased code complexity symbolic evaluator employed verification conditions trivial check 
case checks emitted syntactic identities 
safety predicate function obtained evaluating symbolically starting state maps global variables function formal parameters new variables resulting predicate quantified sp se pi fg example show fig 
safety predicate obtained symbolic evaluation agent il code shown fig 

lines safety predicate represent order final quantification precondition initial invariant 
rest predicate originates evaluation loop body 
mem tab len acc len oe entry mem tab theta acc oe oe len oe sel mem tab theta acc oe saferd mem tab theta sel mem tab theta acc oe len oe true fig 

safety predicate function main fig 

special memory variable mem global variable 
encoding checking proofs building block pcc describe proof checker 
purpose verify proof supplied untrusted proof producer uses allowed axioms inference rules proof required safety predicate 
order isolate dependencies safety policy built generic proof checker parameterized configuration file 
proof checker contain details safety policy logic 
details segregated configuration file 
safety proof prf safety predicate sp lf typechecker signature sp pf prf proof checker fig 

structure proof checker achieve independence safety policy logic currently encoding safety predicates proofs edinburgh logical framework lf specifically designed metalanguage highlevel specification logics :10.1.1.21.5854
rest section give brief overview lf pcc 
reader interested comprehensive discussion subject including numerous implementation details consult 
logical framework simple typed language dependent typed calculus expression constructors variables constants functions function application similar set type constructors types pi objects encode syntax particular logic predicates semantics axioms inference rules safety policy declares set lf expression constants types 
refer set constant declarations lf signature sigma defines logic 
fig 
shows small fragment signature defines order predicate logic integers 
lines declare constant expression representation numeral plus binary constructor 
lf representations respectively lf object plus lf representation middle section shows predicate constructors 
particular feature lf excellent choice proof checking richness type system particular power encode predicates lf types 
predicate pf type proofs logic 
bottom third fig 
show declaration proof constructors 
true nullary proof constructor proof constant represents axiom predicate true valid 
proof constructor mp represent modus ponens proof predicate 
example lf representations proofs oe respectively lf object mp lf representation proof predicate exp plus exp exp exp true pred impl pred pred pred exp exp pred true pf true mp pip pred pir pred pf impl pf pf fig 

fragment lf signature describing syntax semantics order logic 
actual proof checking operation done verifying proof object prf type pf sp sp safety predicate interest 
lf typechecking operation written sigma prf pf sp verifies fact proof contains proof constants declared sigma proves right predicate 
important feature lf type checking simple completely described fifteen inference rules implemented pages code 
furthermore lf type checker completely independent particular logic safety policy reuse checking proofs logics 
standing proof reusability past experiments pcc unmodified implementation lf type checking safety policies ranging memory safety type safety termination resource usage bounds 
furthermore lf type checking simple possible prove formally adequacy proof checking 
pcc implementation lf signatures expressed proof checker configuration files format virtually identical fig 

increase confidence proof checking infrastructure configuration file pass lf type checker type checking proofs 
generating proofs pcc safety predicates expressed order logic language machine details abstracted modeled logic proof generator theorem prover fragment order logic 
order logic theorem proving systems implemented 
knowledge able prove typical safety predicates help additional tactics provided code consumer 
safety properties automatic decision procedures exist effective 
cases practical theorem prover guided person deep understanding reasons underlying safety untrusted code 
usable pcc proof producer theorem prover able prove safety predicates capable generating detailed proof 
furthermore proofs expressed particular logic axioms inference rules specified part safety policy code consumer 
major difficulty theorem prover output proof proof details generally easy transform format expected consumer 
implementations pcc different theorem provers far 
primitive theorem prover developed elf implementation lf 
elf system able read lf signature describing logic answer queries form lf object having type pf 
representation predicate want prove answer query representation proof construction valid proof 
basically theorem prover consists elf system lf signature part safety policy 
major problem elf approach theorem proving elf uses simple search algorithm inappropriate logics 
cases having integer arithmetic add redundant inference rules safety policy elf search proof 
lately switched implementation theorem prover nelson oppen architecture cooperating decision procedures implemented stanford pascal verifier extended static checking systems 
distinguishing feature implementation outputs lf representation proof successfully proved predicates 
theorem prover uses decision procedures notable ones simplex deciding linear inequalities congruence closure deciding equalities 
addition incorporates decision procedure modular arithmetic simple matcher 
theorem prover complicated system implementing complex algorithms rely soundness 
just check proof outputs 
fact doing able discover subtle bugs theorem prover 
theorem prover currently able prove completely automatically safety predicates arising pcc experiments 
controlling resource usage pcc previous sections describe proof carrying code example certifying memory safety conformance simple access protection scheme simple shopping agent 
section expand safety policy allow communication agent parent host restrict agent cpu cycles network bandwidth 
consider agent exploits extended policy gather sends parent host entries satisfying arbitrary predicate 
extending safety policy resource usage bounds order control total execution time agent extend vcgen perform simple timing analysis agent code 
keep things simple instruction counts estimates execution time define icount incremented instruction parsed 
change parser prepend set icount icount instruction translation instruction agent code 
example translation addition instruction dec alpha machine language il described follows addl gamma 
set icount icount set instruction count variable referred preconditions postconditions order specify timing constraints 
example limit execution agent maximum instructions add predicate icount icount agent postcondition 
superscript variable refers value function entry 
symbolic evaluator sect 
enforces partial correctness postcondition enforced event function terminates 
total correctness important termination large class program properties usually referred liveness properties require occurrence certain events execution opposed safety properties prevent occurrence certain events 
fortunately minor change symbolic evaluator enforce total correctness 
symbolic evaluator automatically adds precise estimate execution time obtained increasing increment amounts instructions take time complete 
predicate icount icount loop invariant function postcondition valid safety predicate ensures termination loop function postconditions express total correctness properties 
extend safety policy allow communication agent parent host 
purpose host supplies function agent invoke memory address number words sent 
precondition states entire memory range referred actual arguments agent readable 
address resource usage issues arising communication safety policy limits memory network bandwidth usage 
achieved conservative manner limiting size single message timing successive invocations 
concretely safety policy requires length argument passed theta len instructions passed previous communication message length len sent 
conservatively limits memory buffer usage network bandwidth freq theta cpi freq processor clock frequency cpi average number cycles instruction agent execution 
implementation function customized individual agent example address parent host 
simple way code consumer prepare closure data structure containing customization information give pointer main function untrusted code 
agent required closure time invokes 
safety issue arises safety policy ensure untrusted agent invoke tampered closure argument 
answer inspired types 
define type constructors require argument function type 
untrusted code prove type actual argument function closure type way passing closure supplied host 
extend safety policy host provided function sleep agent delay execution equivalent number instructions passed argument 
having described safety policy informally proceed formalization order logic 
start simpler task formalizing closure type continue formalization bandwidth limitation 
logic counterpart type constructors uninterpreted unary predicate symbol axioms 
introduce programs intended terminate certain liveness properties structured function invoked repeatedly host 
liveness properties verified function 
predicate denote expression valid closure function 
formalize bandwidth limitation consider general problem restricting timing various events execution 
particular example event constructors start denote start agent execution send denote communication event 
define pseudo variable log keep log events occurrence times 
global variable just memory instruction count pseudo variables implicitly passed potentially modified function 
valid values log variable expressions form new denoting new event occurred instruction count state log denoted order manipulate event occurrence times define expression denote log state value instruction count occurrence event event occurred function undefined 
meaning expressed axioms new new send start conclude safety policy description show tab 
preconditions postconditions functions involved 
recall main untrusted precondition main postconditions sleep assumptions safety predicate postcondition main preconditions sleep actual verification conditions safety predicate verification conditions arising loop invariants memory operations 
function precondition postcondition main cl tb ln sl cl ln oe entry mem tb theta sl log start icount log send icount icount icount cl dt ln cl ln oe saferd mem dt theta ln icount gamma log send ln theta icount icount icount icount log new log send icount sleep icount icount table 
extended travel agency safety policy 
precondition postcondition shown list conjuncts 
pseudo variables mem log icount considered implicit inputs outputs functions 
void main cl tab len acc timeout true timeout return len return timeout tab access acc continue filter tab continue sleep timeout cl tab timeout gg fig 

skeleton shopping agent attempts send back parent host pricing table entries match certain predicate 
extending shopping agent swap travel agency administrator hat code producer design shopping agent uses arbitrary predicate select database records sent parent host 
discuss key points proving safety predicate new agent describe experimental results gathered actual implementation agents 
purpose stick agent design leads simpler proof safety 
agent main function shown fig 
keeps track explicitly instruction counts variables timeout conservatively estimates number instructions available execution conservatively estimates number instructions pass new communication initiated 
constants minimum maximum number instructions required execution functions filter respectively 
decrement operations line account instructions lines line account program lines 
note variable timeout decremented maximum possible execution time decremented minimum 
purpose constant initialization timeout account loop preamble exit lines 
loop terminates entries scanned line instruction left perform iteration loop line 
constant conservative estimate number instructions executed loop iteration theta assuming maximum length wait performed line 
conclude presentation new agent loop invariant main loop inv timeout gamma gamma timeout icount gamma log start theta gamma theta gamma icount gamma log send conjunct invariant inherited simple agent 
third conjunct specifies gamma gamma timeout conservative estimate total number instruction executed instructions subtracted allow time return line 
conjuncts invariant claim theta gamma positive conservative estimate number instructions executed communication operation 
modified symbolic evaluator adding invariant predicate icount gamma icount 
additional conjunct weaker loop invariant ignore 
proving safety extended agent safety predicate safety proof corresponding agent large show 
discuss key point proof report data obtained actual implementation 
symbolic evaluator encounters call line emits verification condition obtained substituting symbolic values variables precondition 
verification condition focus conjunct specifies timing 
conjunct shown horizontal line fig 

line number subscripts variables denote value variable right execution corresponding line 
proof conjunct cases depending sleep function called 
case sleep called proof follows adding assumptions shown horizontal line fig 

assumption loop invariant second postcondition filter third postcondition sleep 
icount gamma log send theta gamma icount icount icount icount gamma gamma icount gamma log send theta fig 

fragment proof precondition holds line case test line succeeds 
line assumptions added yield desired shown line 
case proof precondition verification conditions arising symbolic evaluation main proved similar manner 
experimental results implemented extended safety policy section proof carrying code system 
constructed configuration file vcgen describing functions involved experiment preconditions postconditions 
file literally transcription tab 

created lf signature describing order logic axioms define predicates entry 
literal transcription lf syntax axioms 
wrote agents compiled dec alpha assembly language 
program extended agent manually edited adjust discrepancy number instructions counted source level number assembly language instructions 
manually add loop invariant annotations 
resulting programs submitted vcgen produced safety predicate agent 
proved safety predicates theorem prover developed applications pcc 
proof safety predicate simple agent done completely automatically 
proving timing verification conditions extended agent customize theorem prover providing list axioms 
purpose experiments fold 
want show costs specific pcc safety predicate generation time proof generation time proof size cost proof checking 
second want quantify run time penalty imposed agent execution techniques typically enforce level safety 
integrate data obtained experiments compute simple agent minimum number table entries cost safety predicate generation proof checking amortized 
set experiments done ascertain costs proof generation proof checking 
important note costs incurred agent independently times agent executed consumer 
experiment measured proof size times required vcgen proof generation proof checking 
put proof size context report machine code size agents 
experiments pcc obtain proofs times larger code larger factors observed complex safety policies 
experiments confirm usual intuition proof generation expensive proof checking 
second set experiments compared agents pcc agents implemented java agents isolated hardware memory protection software fault isolation sfi 
comparison entirely fair java sfi enforce database access policy offer weaker safety guarantees pcc hardware memory protection 
measurements done implementation simple agent mhz dec alpha running dec osf 
experiment code size proof size vcgen proof generation proof checking bytes bytes ms ms ms simple agent extended agent table 
cost pcc example agents 
java experiment embedded code fig 
simple java applet containing timing code 
unfortunately able find jit compiler dec alpha java measurements done bytecode interpreter netscape 
trying remedy situation final version 
software fault isolation technique code consumer inspects untrusted agent code inserts instructions memory bounds checking memory operation 
code inspection process similar vcgen 
simulate effects sfi instructed compiler insert operations memory accesses 
simulate agent runs hardware protected memory space modified agent invoke consumer supplied function checks access level copies entry agent memory space 
simulate accurately cost function call different protection domains inserted idling loop lasting instructions checking function 
experiment running time slowdown cross table entries proof carrying code software fault isolation indirect access data java interpretation java jit gamma gamma gamma table 
comparison table entry running time simple agent fig 
safety policy enforced pcc sfi java consumer access data 
column computes number table entry amortize cost vcgen proof checking ms 
see text caveats regarding experiments 
table shows running time divided number table entries simple agent fig 
safety policy enforced pcc sfi java hardware memory protection 
times average runs 
results line measured similar experiments 
addition running time agents pcc differs techniques considered time cost incurred vcgen proof checking 
cases especially short running agents agents executed efficient techniques 
case example happen small database 
column tab 
shows minimum size table checking time ms simple agent added running time pcc agent smaller running time agent competing technique 
case sfi considered cost scanning code instrumenting cost vcgen 
note pcc indirect access method enforce desired safety policy 
discussion important consideration design extended agent sect 
ultimate requirement prove satisfies safety policy 
imposes delicate balance code optimizations difficulty proof safety predicate optimized agent usually difficult prove unoptimized version 
safety policy unduly restrict optimizations applied agent decide spend effort proof generation develop optimized agents 
forced write extended agent maintain explicit instruction counts safety policy specifies strict timing requirements 
safety policy relaxed impose instruction count limit varies size database timing constraints proved loop body making unnecessary maintain explicit instruction counts run time 
unpleasant aspect writing extended agent programmer keep track assembly language instruction counts 
think feasible write automatic tool insert appropriate decrement instructions loop termination tests 
possible need find simpler way specify timing constraints code typing annotations 
direction automation pcc obtained promising results prototype implementation optimizing compiler type safe subset language dec alpha assembly language 
performance resulting code comparable cc gcc optimizations enabled produces required annotations proof type safety memory safety 
automation possible case compiler need preserve properties source language 
similar technology certify complex safety policies start restricted domain specific source language 
unpleasant aspect experimental results proof sizes order magnitude larger code certain cases grow exponentially size code 
worst case occurs program long sequences conditionals intervening loop invariants 
safety properties size proof linear size program 
moment scratched surface proof representation optimizations applied reduce size proofs 
example common proofs repeated sub proofs hoisted proved lemmas 
common subproofs identified proofs different experiments safety policy 
common parts proved assumed theorems safety policy 
apply compression algorithms binary representation proofs 
superficial experiments compression observed reduction factor proof size 
believe serious proof optimization size proofs memory type safety approach size code 
direction identifying examples code properties verified pcc 
challenging properties verify liveness properties involving dynamic safety requirements 
direction obtained promising results dealing locks memory allocation extending model log events 
greatest challenge area serious difficulty proving resulting safety predicates 
proof carrying code compares favorably techniques prevent untrusted code step outside safety policy 
compared runtime techniques hardware software memory protection interpretation advantage run time performance simplicity safety critical infrastructure 
advantage run time checking pcc avoids possibility untrusted code terminated abruptly run time error chance cleaning modified state 
furthermore certain safety properties compliance data abstraction boundaries checked run time significant penalties 
compared approaches type safety advantage pcc increased expressiveness order logic traditional type systems example express resource usage bounds arithmetic properties enable elimination array bounds checking 
proof carrying code qualitatively better digital signatures purpose certifying safety agents rely assumption owner particular encryption key writes behaved code 
presents details proof carrying code certify safety untrusted code 
safety properties explored memory safety compliance simple data access policies resource usage bounds data abstraction 
pcc safety liveness properties expressed order logic 
proof carrying code potential free host system designer relying run time checking sole means ensuring safety 
traditionally system designers viewed safety simply terms memory protection achieved expensive run time mechanisms hardware enforced memory protection extensive run time checking data 
limited memory protection run time checking designer impose substantial restrictions structure implementation entire system example requiring restricted agent host interaction model intermediate access critical data resources example 
proof carrying code hand provides greater flexibility designers host system agents allows safety policies fine grained memory protection 
believe potential lead great improvements robustness performance systems 

bershad savage pardyak sirer becker fiuczynski chambers eggers extensibility safety performance spin operating system 
symposium operating system principles dec pp 


boyer moore computational logic 
academic press 

burstall landin programs proofs algebraic approach 
machine intelligence 

constable allen bromley cleaveland cremer harper howe knoblock mendler panangaden sasaki smith implementing mathematics nuprl proof development system 
prentice hall 

coquand huet constructions higher order proof system mechanizing mathematics 
proc 
european conf 
computer algebra lncs springer verlag pp 


luckham stanford pascal verifier user manual 
tech 
rep stan cs dept computer science stanford univ mar 

detlefs overview extended static checking system 
proceedings formal methods software practice workshop 

dijkstra guarded commands formal derivation programs 
communications acm 

gordon hol machine oriented formulation higher order logic 
tech 
rep university cambridge computer laboratory july 

harper honsell plotkin framework defining logics 
journal association computing machinery jan 

mccanne berkeley packet filter man page 
bpf distribution available ftp ftp ee lbl gov may 

necula lee efficient representation validation logical proofs 
technical report cmu cs computer science department carnegie mellon university oct 

nelson oppen simplification cooperating decision procedures 
acm transactions programming languages systems oct 

owre rushby shankar pvs prototype verification system 
th international conference automated deduction cade saratoga ny june kapur ed vol 
lecture notes artificial intelligence springer verlag pp 


pfenning elf meta language deductive systems system description 
th international conference automated deduction nancy france june july bundy ed lnai springer verlag pp 


sun microsystems 
java language specification 
available ftp ftp javasoft com docs ps zip 

sun microsystems 
java virtual machine specification 
available ftp ftp javasoft com docs ps zip 

wahbe lucco anderson graham efficient software fault isolation 
th acm symposium operating systems principles dec acm pp 

article processed macro package llncs style 
