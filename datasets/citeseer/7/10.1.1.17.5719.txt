increasing cross domain call batching promises batched control structures june massachusetts institute technology 
rights reserved 
supported advanced research projects agency department defense monitored ce naval research contract 
massachusetts institute technology laboratory computer science technology square cambridge massachusetts increasing cross domain call batching promises batched control structures client server system may possible client corrupt server data unsafe access methods programming errors 
common method protecting server data separate client server distinct protection domains unix processes 
communication client server restricted de ned set calls results passed opaque pointers server data 
unfortunately cross domain calls expensive seriously ect performance system 
batched futures presents mechanism batching cross domain calls amortizing overhead domain crossing batch 
showed improvement performance directly proportional average size batch batching factor 
thesis describes mechanisms improve batching factor basic value promises batched control structures 
basic value promises allow batching calls return basic values integer boolean character real 
batched control structures allow batching simple control ow statements statements loops loops 
mechanisms implemented thor object oriented database system 
thesis presents performance results showing ectiveness mechanisms increasing performance cross domain calls 
keywords futures promises control structures batching protection domains calls object oriented databases 
gratitude appreciation people prof barbara liskov supervising thesis particular aiding graduate career general 
howard trickey advisor 
past members programming methodology group technical support friendship 
special philip atul adya mark day andrew meyers umesh maheshwari sanjay ghemawat dorothy curtis miguel castro 
charles isbell great friend invaluable resource 
kelsey reliable friend 
wife wonderful companion 
love support harder task 
parents far away source support inspiration 
contents roadmap thor client interface thor concepts thor architecture frontend veneer stubs exception handling iterators discussion batched futures batched futures implementation futures remapping discussion promises improving batching factor promises implementation veneer method stubs batching call promises remapping claim implementation frontend experimental results performance model oo benchmark revisited batched control structures increasing batching factor bcs promises bcs syntax semantics bcs grammar batched loop batched statement batched loop assignment cells bcs exception handling bcs implementation annotated batch bcs language implementation bcs implementation frontend syntax checking type checking set computation parse tree construction evaluation parse tree nodes arg nodes method nodes nodes nodes foreach nodes performance results ways batch loop client loop client loop perfect batching batched loop batched loop theta loop bene ts optimizations summary batched break statement batched continue statement batched procedures sandboxing list figures thor architecture promises oo traversal var arg node method node node node iterator closure foreach node bcs performance bcs performance enlargement method node optimization chapter client server system data integrity ofthe server guaranteed separating client server distinct protection domains 
communication occurs de ned interface ensures client corrupt data stored server interfere server operation 
crossing domain boundary expensive 
client server distinct processes running machine call requires context switch slower direct function call 
client server running separate machines need communicate network cost context switch worse 
previous mechanism called batched futures sending calls server batches 
normally call sent server evaluated 
results handles object stored server basic values integers booleans 
batched futures mechanism allows calls return handles batched 
sending call individually waiting result client places call batch generates place holder result called 
argument calls 
batching set calls improves performance cross domain calls amortizing cost domain crossing number calls batch 
performance improvement directly related number calls batch 
batch size mechanism limited reasons 
rst allows calls return handles batched 
calls return basic values executed immediately point calls run followed call returning basic value 
calls returning basic values occur frequently client code batch sizes necessarily small 
second reason straight line code batched 
mechanism allows sequence client calls batched provided return handles 
presence control structure condition depends result call necessarily interrupts batch 
call immediately client result determine control ow program 
example loop controlled test examines state server object run single batch 
batch terminated iteration loop 
thesis suggested ways limitations 
extends batching mechanism lines suggested 
provides mechanism allows calls return basic values batched generating special kind result called promise 
claim operation de ned promises allows client extract actual value promise time 
promises allow client batch calls return basic values results immediate interest increasing size batch improving performance 
second thesis provides way batching control structures means new mechanism called batched control structures 
batching control structure interrupt current batch allowing calls preceding control structure placed current batch aswell 
batched control structure loop processed server parsed executed multiple times 
parsing loop server generates highly cient representation loop evaluated 
evaluating representation cient processing individual calls sent client 
batched control structures improve performance ways increasing batch size preprocessing batch running reducing cost running calls batch 
batched control structure mechanism supports kinds looping structures loops foreach loops 
kind loop server iterator 
iterator special kind routine produces multiple results yields results time loop iteration yielded value 
prior thesis way client server iterators system foreach mechanism overcomes limitation 
roadmap chapter describes thor object oriented database system context 
chapter describes batched futures background 
chapter describes design implementation basic value promises thor 
chapter describes main contribution thesis batched control structures 
chapter describes implementation batched control structures 
chapter presents performance results batched control structures chapter describes possible extensions thesis gives 
chapter thor client interface context thor new object oriented database system provides persistent highly available storage objects 
rst half chapter describes relevant features thor basic system architecture 
rest chapter describes mechanism client programs interact thor 
thor concepts client thor provides universe objects 
objects fully encapsulated internal representation accessible client 
clients obtain thor objects pass objects arguments method calls calls routines 
addition basic value arguments sent 
thor basic values integers booleans characters real numbers 
methods routines method procedure de ned part type 
method implicit rst argument object type de ned 
method invoked object type 
routine stand procedure associated type 
iterators addition procedures thor supports iterators introduced clu programming language 
returning single value iterator yields new value time called 
iterators called special construct 
routines methods iterators 
object thor object called handle 
handles returned client method calls performed thor behalf client 
handles arguments subsequent method calls 
handles valid duration particular session client thor 
exceptions thor routines methods return normal values signal exception termination 
exception indicates normal return values computed 
types operations performed object determined type 
thor types speci ed implemented theta new object oriented programming language developed speci cally thor 
type consists set method signatures 
example de nition database type theta examples database type fetch user string returns signals find user database return corresponding record 
signal user database 
new user user string returns signals possible create new record user return new record 
signal possible record created 
users yields yield records users database 
database keyword signals indicates exceptions signaled method 
keyword yields returns case iterator 
type hierarchy theta allows subtyping 
theta methods supertype compatible signatures plus additional methods 
subtype object type supplied argument object type expected 
thor architecture thor system divided components set distributed storage servers persistently store thor objects 
called object repositories process called frontend caches objects executes calls routines methods behalf client 
client interface thor de ned interactions frontend client program 
client language unsafe client frontend executed separate protection domains 
practice means client frontend language considered unsafe allows arbitrary pointer dereferencing client veneer frontend thor server server thor architecture 
client ada veneer frontend run separate processes machine possible client frontend run separate machines 
illustrates thor architecture client frontend running machine 
client communicates frontend language speci veneer 
described section 
frontend frontend dedicated single client application 
objects accessed client fetched cached frontend 
interface client frontend includes commands lookup wellknown command takes string arguments 
frontend searches string table known objects returns handle object corresponding string argument 
invoke command invoke method routine arguments method name arguments call including receiver 
client calls frontend communicating shared memory bu er tcp ip network connection 
generally client session looking root object database 
frontend continually waits commands client 
probably frequently command invoke command 
client sends name method current implementation thor support routines discuss remainder thesis arguments form handles basic values frontend 
handles nd corresponding objects handle table maintained frontend 
name nd method signature verify right number arguments passed type check arguments 
call type correct type argument subtype type listed argument position signature call type checks call result object mapped new handle sent back client 
basic value results mapped handles sent back client directly 
method resulted exception signaled exception send client 
handles implemented positive integers index handle table logical interface frontend implemented di erent interfaces textual interface ascii binary interface 
ascii interface suitable direct user access telnet protocol clients written simple text processing languages 
binary interface provides higher performance direct encoding values clients 
goals thor allow application programs written di erent programming languages share objects 
accomplished providing veneer programming language 
veneer extends language necessary procedures interact thor 
implemented thor including emacs lisp perl tcl modula 
remainder thesis limit discussion veneer concepts explained limited veneer 
veneer provides client interface thor 
interface implemented library procedures 
procedures generally stub procedures call corresponding remote procedures frontend interface described previous section 
addition veneer maintains mapping handles stub objects objects mimic corresponding thor objects 
remainder section describe stub object mechanism detail 
general discussion see 
veneer stubs veneer manages set handles currently referred client 
veneer handles encapsulated stub objects mimic thor objects represent 
veneer provides stub procedure thor routine method 
veneer stub procedures implemented member functions stub objects 
theta type de ned thor corresponding class generated automatically included part veneer 
example class de nition database type mentioned earlier optimization basic value arguments type checked 
speeds execution really violate type safety thor treats basic value opaque bit number regardless type 
method de ned integers execute passed real exception may signaled cases 
class th database public th public th database th fg th database int handle th handle fg th fetch th string user signals th new user th string user signals possible th users stub object contains handle thor object 
method thor object client invokes method stub stub object 
thor method invocation looks regular invocation client programmer 
stub procedure marshals arguments sends actual call frontend 
frontend executes call sends back result 
results handles basic values 
stub procedure result returns client 
result handles encapsulated new stub objects returned 
code fragment illustrates call fetch method object database type th database db look wellknown root th string usr new th string th el db fetch usr rst statement calls stub procedure calls corresponding look procedure frontend 
case root object type database 
resulting handle wrapped stub object pointer stub object assigned variable db 
second statement creates new thor string value 
handle string object returned frontend wrapped new stub object 
variable usr assigned pointer stub object 
statement calls stub function fetch method stub object db argument usr assigns resulting stub object el 
exception handling thor call signals exception exception back client 
veneer client provide handler function called veneer exception occurs 
handler provided veneer terminates client program error message 
iterators theta iterators called inside loop 
body loop iterator run coroutines 
iteration iterator executed yields value 
control returned caller executes loop body 
cycle repeats iterator terminates loop terminated prematurely break return statement 
example example call theta iterator int example iterator de ned objects integer type yields integer values value receiver value rst argument 
currently provide way clients call iterator 
chapter new mechanism calling iterators 
discussion invocation mechanism described chapter ine cient 
call client requires round trip communication frontend expensive 
chapter describes mechanism batched futures reduces overhead amortizing cost domain crossing calls sent frontend batch 
remainder thesis describes mechanisms increasing average batch size improving performance 
chapter batched futures batched futures mechanism allows cross domain calls server batched 
batching calls improves performance cost domain crossing client server amortized number calls batch 
greater number calls batch larger performance bene 
batched futures result call thor operation handle basic value 
handle argument subsequent calls delaying computation sense 
sending call waiting result handles computed call batched placeholder generated result 
time batch calls sent frontend evaluated 
allow calls refer result batched call stub call generates place holder result called 
addition handles arguments name method called result call included batched call 
allow frontend associate result call call executed 
new calls added batch corresponding stubs invoked client program 
client invokes method returns basic value entire batch sent frontend executed 
frontend executes call assigns result corresponding 
sequential nature process futures assigned value 
example consider code int nth th intlist int return function returns nth element list integers 
nds nth node list calling method times returns rst element list 
ordinarily function require pairs domain crossings pair invocation function plus invocation 
batched futures computation require single pair domain crossings 
invocation returns result argument call 
calls placed batch loop essentially unrolled 
returns basic value result case integer execution causes batch sent frontend 
batch generated code previous example look return fn statement batch records information necessary frontend execute call 
example rst statement indicates method invoked object handle 
arguments call result assigned 
similarly subsequent calls 
note point batch receiver call computed 
nal call indicates result calling method returned client 
implementation section contains brief description batched futures implementation 
complete description implementation 
batched futures implementation consists parts modi ed veneer method stubs batch message describing call return result 
batch data structure accumulates sequence calls sent frontend call returns basic value 
table frontend maintains mapping futures objects 
veneer table vf maintains mapping futures stub objects 
counter called index generate new futures 
futures futures handles implemented integer indices table objects 
distinguish handles futures negative 
result batched call new generated incrementing index 
counter periodically reset veneer explained section 
call placed batch contains assigned result 
frontend call executed result mapped speci ed table subsequent call presents argument corresponding object fetched passed argument actual call 
remapping remapping mechanism batched futures implementation limit size table veneer generates fresh result call grow bound 
prevent futures periodically remapped handles 
remapping new handle created object frontend 
futures assigned handle frontend sends handle pairs back veneer 
veneer table vf veneer nds stub object corresponding stores new handle 
index reset zero space vf reclaimed 
futures remapped index reaches threshold value little cient remap large number futures 
discussion result showed real benchmark oo average batch size batching factor low 
consequently speedup achieved batched futures 
remainder thesis describes new mechanisms promise batched controls structures enable larger batching factor achieved 
chapter promises section describes contributions thesis promises 
promise basic value thor 
regular result call 
addition promise initialized refer particular value 
get actual value promise refers promise claimed 
promises rst described mercury call streams 
mercury promise claimed argument subsequent call 
thor promise claimed argument 
needs claimed actual value promise needed 
promises increase batching factor 
basic value result immediate interest client client request call return promise actual value 
allows call batched batching mechanism described section 
promises improve batching factor certain cases practice expect bene relatively small 
necessary batched control structures chapter expect larger impact batching factor 
improving batching factor promises basic value results ways handles passed arguments calls value directly 
cases sense delay computation actual value 
example client program exchanges integer elds object need examine actual value elds 
promises code look swap th point int get val field int get val field set set field old set set field old example stub object pointer type th point corresponds point type thor 
point type methods get corresponding values set set assign new value 
method calls batched return integers 
section code incurs expense pairs domain crossings calls batch containing calls set set promises code requires single pair domain crossings 
calling return integers special stub functions called return integer promises 
example functions rst letter name capitalized swap th point th int assign field promise th int assign field promise set set field old set set field old note return integers stub objects type th int 
similarly set set take th int arguments integers 
th int corresponds thor integer type supports additional claim method 
example promises claimed 
example promise keep running sum case claimed sum computed 
implementation veneer veneer promise implemented tagged union value 
value set explicitly promise created set veneer actual value promise available 
promises encapsulated stub objects thor 
stub object types promises special claim method obtain actual value promise 
stub objects promise contain handle 
call returns promises batched means stub object returned call contains 
replaced value handle remapping 
method stubs strongly typed language 
promise corresponding basic value di erent types veneer single stub function accepts basic value promise particular argument 
similarly stub function return basic value promise result 
veneer provides di thor routine method basic value arguments return values takes returns promises takes returns basic values 
double number stub functions provided 
methods take return basic values actual expansion factor usually 
current implementation roughly 
example new de nition th point class previous example support promises class th point public th public int return value eld int return value eld void set int set value eld void set int set value eld th int return promise value eld th int return promise value eld void set th int set value eld promise void set th int set value eld promise new de nition contains additional methods support promises return integer promises set set take integer promises arguments 
cases client programmer may want call thor method mixture promises basic value arguments return values 
alternatives providing functionality 
provide di erent stub permutation promises basic value arguments return values 

provide mechanism converting basic values promises promises version 

require promise arguments claimed rst basic value version 
rst option providing di erent stub function permutation promises basic value arguments return values lead exponential increase amount code provided 
chose combination second third options 
third option exists default provide full functionality desired allow client call stub returns promise mixture promise value arguments 
may defeat purpose providing promises rst place forcing promise claimed unnecessarily 
convert basic value promise veneer provides constructor create new promise value 
veneer constructor de ned part stub object class 
create integer promise value code th int foo new th int constructor simply sets value eld promise sets tag accordingly 
complete speci cation th int follows 
de nitions th bool th real th char correspond theta boolean real number character values similar class th int public th stored th handle eld 
public stubs regular theta integer methods int add int int sub int int mul int int div int signals zero int mod int signals zero bool equal int bool lt int bool gt int greater bool le int equal bool ge int greater equal int int iterator 
method stubs support promises th int int val sets value eld tag 
th int add th int th int sub th int th int mul th int th int div th int signals zero th int mod th int signals zero th bool equal th int th bool lt th int th bool gt th int th bool le th int th bool ge th int th int th int int claim extract actual value 
private int val value eld promise batching call promises regular futures stub function returns promise generates result creates new stub object containing 
included call frontend assign result call 
stub returns pointer newly created stub object 
promise argument sent tothe frontend value tag distinguish 
remapping claim limit size tables veneer periodically futures handles section 
originally remapping done index value exceeded threshold 
allowed processed larger chunks opposed remapping futures particular batch tended small 
policy changed promises implemented remapping done execution batch 
done reasons 
expect average batch size larger promises batched control structures 

claim operation implemented ciently 
remapping basic value remapped actual value handle 
value stored value eld promise tag changed accordingly 
promise claimed tag indicates contains current batch sent frontend 
futures remapped batch nished executing 
promise stub objects contain actual value promise batch nished executing 
implementation frontend frontend receives promise value 
promise value frontend treats treat normal basic value argument 
corresponding value looked table argument actual call 
experimental results uses performance model describe expected impact promises performance traversal oo benchmark 
implementing promises con rmed predicted result 
performance model model states average cost call average cost running call cost pair domain crossings batching factor total number calls divided number pairs domain crossings 
oo benchmark revisited predicted promises traversal increase batching factor 
prediction replacing integers promises part traversal code similar examples discussed earlier integer elds swapped value examined 
rewriting code suggested yielded exactly predicted batching factor 
measurements thor invocation mechanism optimized yielding factor improvement performance 
domain crossing overhead substantially decreased reducing total bene achieved increased batching 
seconds futures batching factor promises batching factor promises oo traversal 
comparison running time oo traversal batched futures versus running time traversal modi ed promises 
running time batched futures version seconds 
running time promises version seconds 
speedup achieved 
chapter batched control structures chapter describes main contribution thesis batched control structures bcs 
bcs mechanism allows client program send small programs server executed 
bcs allows client programmer express simple control ow statements loops batch 
advantages bcs increase number calls placed batch 
bcs amortizes type checking call overhead frontend multiple iterations code 
bcs provides mechanism call iterators 
increasing batching factor bcs promises applications batching factor low due structure client program 
example client loop condition depends thor call cause new batch sent evaluated iteration loop call evaluated iteration control ow loop determined 
bcs solve problem allowing client batch entire loop reducing number domain crossings iteration entire loop 
speci cally consider loop traverses thor list condition single call frontend returns boolean value th list notempty single call returns boolean 
calls loop body contains calls loop executes iterations client batched futures send batches size frontend requiring roundtrip communication 
extra call batch accounts call computes loop condition notempty 
call causes batch sent frontend iteration call returns basic value case boolean 
entire loop sent frontend executed ective batch size piece code number iterations loop executes frontend times number calls loop 
entire loop iterations incurs expense single round trip communication 
assuming batching entire control structure signi cantly increase overhead evaluating batch increase batch size result increase performance 
chapter show iterations cost processing batched control structure successfully amortized number times evaluated 
sending entire loop frontend requires calls return basic values batched 
client express control ow statements batch sent frontend 
frontend reconstruct control structure information batch execute 
satisfy rst requirement promises 
second third requirements addressed bcs mechanism described detail remainder chapter 
theory client able send arbitrarily complex code frontend evaluation 
complex code di cult parse evaluate ciently 
addition want client programmer learn complex new language 
goal bcs provide programmer small number useful constructs improve performance application 
speci cally concerned control structures statements loops loops don expect batched statements isolation provide improvement performance statements inside control structure executed 
cost parsing batched control structure amortized multiple iterations 
control structure nested inside batched control structure parsing control structure get amortized number iterations enclosing loop 
intended batched control structures 
bcs syntax semantics bcs mechanism direct extension batched futures mechanism described chapter 
batched futures allows batching sequence calls thor methods routines 
bcs mechanism extends veneer set control ow statements explicitly client program batch control structure 
execution statements annotates batch markers delimit control structure 
body control structure entirely calls thor routines methods batched batched futures promises 
batch parsed frontend markers reconstruct control structure evaluated 
evaluation process described detail chapter 
remainder section describes syntax semantics bcs 
section description language implementation bcs 
bcs general mechanism rely speci language features 
syntax semantics bcs similar languages 
issue discussed detail chapter 
bcs grammar grammar bcs language follows bcs expr body endwhile expr body body endif foreach stub pointer batched method call body expr batched method call stub pointer batched method call expr method name expr expr body method call bcs grammar stub pointer client identi er refers stub object batched method call method call batched return basic value results 
batched loop argument call boolean expression evaluated frontend iteration loop 
body loop executes long expression evaluates true 
example list traversing loop earlier rewritten follows th list notempty single call returns boolean promise 
calls batched statement semantics straightforward 
condition result boolean promise 
frontend condition evaluated 
resulting value corresponds true body evaluated body evaluated 
optional course 
batched loop batched loop provides cient mechanism calling iterator 
foreach statement batched method call single call iterator 
scope body stub pointer refers value yielded iterator 
general iterators yield multiple values iteration 
foreach construct deals common case iterator yielding single value 
support yielding multiple values foreach construct easily extended sequence stub pointers single stub pointer rst argument 
example loop iterates integers th int new th int th int new th int th int foreach foo endfor scope body foreach statement variable refers value returned iterator 
values converted promises arguments call returns promise explained section 
evaluated server body iterator execute routines 
iterator executes result assigned body executed 
continues iterator signals values yielded 
current implementation provide means terminating iterator values yielded 
important iterators may non terminating iterator yields prime numbers 
chapter describes mechanism terminating batched loop analog break statement assignment syntax semantics bcs designed mimic corresponding language constructs theta 
theta bcs language compiled language right implemented bunch procedures called client annotate batch chapter 
places certain limitations bcs mechanism 
statements procedure calls place markers current batch interrupt sequential ow control client program 
statements preceding executed absence bcs commands 
statements cause things placed batch contribute body batched control structure seen frontend 
include calls thor method stubs nested bcs statements 
calls client procedures assignments client variables expressed batch sent frontend 
note means calls assignments executed exactly client frontend containing control structure may zero times 
second batched futures mechanism designed batch linear sequence calls 
call batched generated result 
call executed frontend result mapped actual result table call uses argument object looked passed actual call 
client uses stub objects refer futures 
typically stub object returned method stub assigned client identi er refers result batched call 
identi er argument corresponding batched call 
relationship identi er 
assignment identi er body batched control structure relationship may violated 
example consider code fragment th list find list notempty rst statement assigned result call client procedure returns pointer list stub object 
refers condition statement call batched call receiver call 
statement body receiver call 
result call corresponds di erent assigned way propagate information back top loop 
calls involving batched 
loop evaluated frontend iteration loop terminates value changes 
problem longer correspondence result particular call 
refers rst assignment second assignment 
expect refer result rst assignment rst iteration loop second assignment second iteration happens 
assignment identi er inside batched control structure expected provided assignment statement inside body textually follows identi er body condition control structure 
previous example assignment subsequent expected behavior control structure prior assignment true condition assigned body 
clear example common situations necessary identi er assigned inside body batched loop 
mechanism provides functionality described 
question raised assignment identi er inside batched control structure previous example thor object identi er refer control structure evaluated 
reasonable semantics identi er refers result time call evaluated 
possible call evaluated body batched loop branch batched statement conditionally evaluated 
identi er assigned inside batched control structure necessarily awell de ned meaning control structure evaluated 
fact current implementation identi er refers valid thor object control structure evaluated 
solution settled issues extend thor slightly inventing new type called cell 
object type cell stores single value type 
assignment identi er stub object inside control structure rewritten performing storage operations object type cell 
section gives detailed explanation cells 
note bcs mechanism detect inappropriate assignment inside body batched control structure inappropriate identi er batched control structure 
programmer cells appropriate situations 
course safe replace assignment cell 
necessary may slightly increase overhead batched control structure 
cells idea cells replace assignment client variable method call thor object 
advantage approach semantics method calls inside batched control structure understood making easier reason resulting program 
potential solutions cells increase complexity veneer bcs mechanism 
theta speci cation cell follows cell type put store new value cell 
get returns signals possible return value stored previous put call 
signal value stored cell 
cell type information type value stored cell preserved 
greatly simpli es cell 
prior control structure client creates new cell calling special veneer function called th cell new 
function de ned constructor th cell class 
call th cell new batches special command frontend creates new cell returns cell 
assignment replaced call put method cell mutates cell storing new value 
retrieve value assigned cell get called 
example list traversal code previous example rewritten follows th list th cell th list cl new th cell th list create new cell cl put cl get notempty cl get cl put cl get example new cell created call new th cell 
cell initialized call put list argument 
inside loop body access replaced call get 
statement stores new value list cell 
note example cl obtain result call batched control structure evaluated 
bcs chapter show possible get substantial improvement performance replacing client loop batched control structure small number iterations 
replacement may place somewhat burden client programmer 
order batch condition loop statement condition rewritten entirely terms calls thor methods routines 
body loop contains calls client procedures may sense bcs mechanism require eliminating calls rewriting terms thor calls 
generally bcs relatively simple convert client code bcs 
example client batched loop speci cally condition 
rewriting condition may slightly increase complexity client language operators basic values replaced equivalent thor calls basic values replaced basic value promises 
rst necessary condition computed frontend second necessary calls condition batched 
example consider loop th list length single thor call length 
rewriting condition requires converting operation lt method de ned integer promises replacing integer value integer promise initialized 
speci cally code look th list th int limit new th int initialize integer promise length lt limit condition thor calls 
lt returns boolean promise lt return boolean 
exception handling giving client program access exception occurs evaluation batched control structure di cult simple way associate exception actual call generated 
current implementation exception generated evaluation control structure causes client program terminate error message 
intended bcs improve performance tested code signal exceptions 
exceptions signaled bcs mechanism explained chapter analogous syntax errors generated compiler 
chapter bcs implementation chapter describes implementation batched control structures 
implementation consists parts language veneer frontend communicate control ow information batch second implementation bcs syntax described previous chapter third mechanisms frontend interpret evaluate batched control structures 
annotated batch batched control structures communicated frontend annotating batch control ow information 
example loop th int limit new th int cl get length lt limit cl put cl get produce annotated batch cond condition expression get length lt limit promise value body expression body get put body body 
cond marker indicates expression condition loop 
calls expression batched 
body marker indicates condition body 
sent marker 
refers boolean value checked condition 
calls body batched nested control structures batched way 
body marker indicates batched loop 
similar markers provided foreach control structures 
bcs language implementation veneer bcs commands endwhile foreach foreach endif implemented macros 
macro expands sequence procedure calls place appropriate markers batch 
macros take condition expression single argument place markers batch 
foreach macro takes arguments stub object holds value yielded iterator expression iterator 
example cond macro expands pseudocode put place cond marker batch th bool cond batch condition expression put body place body marker batch assignment condition boolean promise causes calls condition placed batch code executed 
promise argument put body function 
function places referred batch body marker 
note condition assigned boolean promise compiler type check call ensure expression evaluate boolean promise 
macro exactly macro calls put case foreach var iter command variable assigned result calling iterator 
statement foreach expands put foreach place foreach marker batch batch call iterator assignment iterator variable type checked compiler 
assignment generates value yielded iterator stored stub object referred variable inside body argument receiver call batch 
loop evaluated frontend refers current value yielded iterator iteration 
marker needed indicate body foreach control structure iter argument expand single call 
body begins second call foreach marker 
endif endwhile expand single call places appropriate marker batch 
note expression condition case surrounded markers 
advantage macros opposed regular procedure calls syntax hides level detail programmer 
macro expanded cond expression evaluated 
macro sandwich expression calls place markers code executed calls expression batched expr marker body marker 
language support macro processing client programmer marker placement explicitly essentially hand coding macros 
shortcoming current implementation syntax errors checked compile time 
compiler check markers match 
example statement ended endif 
bcs parser frontend check error runtime 
second compiler verify foreach statement terminated actual macro introduces new scope terminated statement 
ensure appropriate marker placed batch scope accidentally terminated means macro 
macros modi ed entire control structure case compiler able check errors 
example cond macro changed condition body 
endwhile macro longer necessary functionality macro 
disadvantage approach syntax slightly natural 
fact control structure terminated detected frontend explained section problem remain languages macros implement bcs 
veneer uses batched futures mechanism batch thor operations inside batched control structure extensions needed veneer support bcs 
evaluating control structure done frontend 
bcs implementation frontend frontend parses batch stand method calls parsed executed 
bcs marker reached calls processed di erently 
call type checked added parse tree node representing batched control structure 
control structures nested 
marker outer control structure reached frontend evaluates entire parse tree 
process continues long statements batch 
syntax checking parsing batch frontend detect marker mismatch nds marker current control structure loop signals exception 
frontend detect batch contain marker current control structure 
batch implemented continuous stream xed 
approach allows client frontend place things take things batch asynchronously scheduled execute operating system 
client fails provide marker control structure frontend continue processing subsequent batched calls control structures nested inside current control structure 
client call batched terminating batched control structure frontend signal exception 
client certainly call order get basic value results error eventually detected 
type checking goal type checking call ensure run time object passed argument call subtype type listed method signature particular argument 
current system guarantee checked method call submitted client 
improve performance bcs method calls batched control structures type checked control structure evaluated 
amortizes overhead type checking number times control structure evaluated 
discussion notation apparent type type object inferred type checking system 
argument denotes apparent type actual type real type object information contained object 
argument denotes actual type expected type type listed signature method arguments 
argument denotes expected type sis subtype constant evaluation batched control structure constant refers object iteration refers result call prior control structure 
variable evaluation batched control structure variable refer di erent object iteration refers result call inside control structure 
type checking algorithm batched method call inside control structure consists items value receiver call name method values arguments result 
ensure call type correct type checking algorithm verify argument including receiver 
determined looking method signature 
check done di erently depending referred constant handle constant variable 
recall basic value arguments need type checked 
referred handle constant determined directly object object handle table 
algorithm verify 
body get get returns list 
list list 
body referred variable example determined object available parse time 
refers result earlier call method de ned return type listed signature theta methods type safe guarantees type object returned method subtype type listed method signature return value 

subtype relation transitive algorithm need check ensure subtype 
determine apparent type object referred avariable mapping created return type method result refers 
previous example call get parsed mapping created type list 
mappings kept table called type table 
argument call apparent type corresponding object determined looking previous example call type checked apparent type looking set computation run time argument object passed method call representation changed appear method object type expected method 
done computing integer set depends relationship type hierarchy object actual type type expected method 
complete description sets 
call sent client set computed arguments method called 
common case actual type expected type identical computing set trivial 
identical computing set requires traversing type hierarchy starting actual type examining supertypes recursively expected type reached 
type checking stage bcs evaluation part cost computing set amortized number times method called inside control structure 
actual type object known object computed 
complete set actual type expected type computed type checking variable 
constant handle computed information stored parse tree 
computed variable type checking set apparent type expected type 
information stored parse tree 
prior executing method call set actual type apparent type computed added previously computed set 
sum constitutes total set actual type expected type 
parse tree construction evaluation frontend parses batch processes normal calls executes described chapter 
marker batched control structure reached frontend changes mode 
parse tree created represent control structure 
subsequent calls batched control structures added parse tree 
marker outermost control structure reached parse tree evaluated 
processing batch continues 
section describes structure parse tree 
parse tree nodes bcs parse tree constructed nodes types fore ach method arg 
foreach nodes may contain nested bcs parse trees 
method node represents particular method call includes method receiver arguments place results 
foreach nodes represent corresponding control constructs 
arg node represent argument method call 
parse tree constructed evaluated 
evaluation starts calling eval method top level parse tree node 
function recursively calls eval methods parse trees node contains 
parse tree list nodes eval method called member list 
evaluation halts nodes evaluated 
current implementation exception signaled bcs parsing evaluation connection frontend client terminated 
arg nodes arg node store information particular argument call 
arg nodes divided di erent types 
argument call referred handle constant corresponding arg node contains pointer object pointer obtained handle table parse time 
type arg node referred const arg node 

argument basic value value stored directly arg node 
called basic arg node 

case variable special kind arg node called var arg node 
arg node types described detail remainder section 
const basic arg nodes const arg nodes contains pointer object 
pointer set properly 
basic arg node contains basic value 
cases evaluated arg node simply returns value 
arg nodes simple 
explained section eliminated method node construction optimization 
var arg nodes refers result particular call 
call contains argument list frontend looks table nd corresponding object passed actual call 
approach calls inside batched control structure 
batched control structure sequence calls executed times means futures looked times 
sense mechanism little parse time incurs overhead evaluation time 
table pass results earlier calls ones bcs evaluation mechanism uses shared pointers pass results 
variable pointer object time contains pointer object referred refers result method call 
call evaluated mutated points result 
call uses argument dereferences get corresponding object 
arg nodes correspond contain pointer arg node contains partial set section apparent type object full set computed evaluation 
partial set depends expected type argument may di erent di erent method calls take object referred argument 
arg node evaluated veri es contains valid object pointer may contain invalid pointer refers result call executed call branch statement taken 
set computed apparent type actual type determined object 
set added partial set sum added pointer returned 
mechanism sharing pointers objects follows call parsed result mapped type result addition new pointer object initialized point actual result 
mapping stored call parsed uses argument looking new arg node containing created method node representing call 
arg node contains type object complete set computed 
mapping variable futures objects stored variable futures arguments calls inside control structure 
variable refer valid object outside batched control structure discussed section 
results arguments calls control structure stored cell object 
diagram var arg node 
method nodes method node represents single method call 
method node contains arg node receiver call array arg nodes arguments arg node result pointer actual function called 
presents schematic diagram typical method node 
evaluation method node evaluated executes method function updates result pointer 
evaluate steps performed arg nodes arguments evaluated generating array objects arguments 
arg node receiver evaluated actual function method call determined dispatching 
function executed result pointer updated point result 
method signals exception evaluation process halted 
method node specializations improve performance method node evaluation certain common cases identi ed special method nodes cases 
receiver constant handle basic value constant method dispatch done parse time 
method node evaluated need recompute function calling 
second specialization method return value 
case evaluation need check exception function called 
special method nodes method call argument arguments 
single argument constant need arg node abstraction 
method node just contains pointer object set properly 
specializations described corresponding method node contain particular optimization shall call complement 
di erent method node implemented permutations specializations complements described 
special method node method call constant receiver variable argument return values nodes node represents batched loop 
node contains list method nodes condition expression pointer eventual result condition expression arg type offset method receiver arguments result function var arg node obj pointer arg ref arg ref obj method node arg ref arg ref list method nodes body 
result method call expression boolean condition loop 
presents schematic diagram node 
evaluation node evaluated follows rst expression evaluated 
condition true body evaluated 
process repeated condition false 
nodes node represents batched control structure 
node contains list method nodes condition expression pointer eventual result condition expression lists method nodes body body 
presents schematic diagram node 
note expression condition related exact way node 
evaluation expression evaluated 
condition true body evaluated 
foreach nodes node represents batched loop 
node contains pointer iterator result single method node iterator list method nodes body loop 
implementation iterators thor order understand rst understand way iterators implemented thor 
section presents brief explanation iterator implemented thor 
thor iterator implemented procedure takes extra argument listed signature iterator 
argument closure body loop calling iterator 
closure contains function environment contains values function free variables 
remaining free variable iterator pass value yields iteration 
generating value iterator calls function closure value generated 
values yielded iterator returns 
example consider loop theta int sum sum sum expression condition body method var method expression condition method method method bool node method method bool method node method result method result shows iterator closure corresponding example loop 
note sum passed change value propagated call code generated theta compiler 
foreach evaluation mechanism described node closure constructed body foreach node passed iterator function 
done soon foreach node constructed 
closure created evaluate body foreach 
function takes arguments rst argument pointer value yielded iterator 
second argument list method nodes comprising body loop 
argument actual value yielded iterator 
called sets point contain basic value 
enables method calls body arg nodes access presents schematic diagram foreach node 
evaluating method node iterator function iterator called closure body foreach loop rst argument 
function repeatedly generates value calls closure function iterator done yielding values returns 
fact optimization foreach node replaced method node iterator parse tree eliminating unnecessary level indirection evaluation 
foreach iterator closure int start int int start env closure function env sum closure function env var body iterator void env int env sum env sum iterator closure method args method method args func arg ref env val env var val eval env body obj foreach node closure cl 
cl cl env val chapter performance results chapter presents results measurements demonstrate ciency bcs mechanism 
rst set experiments compares bcs regular batched futures 
second set experiments demonstrates bene ts method node optimizations described chapter 
ways batch loop rst experiment shows relative performance bcs compared batched futures running entire application inside thor 
di erent version loop evaluated 
client side loop 
client side loop perfect batching 
batched loop 
batched loop 
theta version loop loop measured total time spent loop 
measured entirely client side includes overhead batching calls client side 
expect small compared total time taken 
measurements taken lightly loaded dec alpha axp workstation 
optimizations described chapter turned measurements garbage collection frontend done start time figures show total running time loop compared number iterations executed loop 
actual measurements taken iterations 
error bars show con dence interval measurement 
shows long term behavior loops 
shows behavior loops iterations 
note loop curves parallel inside thor curve 
means iteration overhead larger optimum cases table 
note loop outperform client loops small number iterations 
milliseconds milliseconds iterations bcs performance iterations bcs performance enlargement loop start cost iter client perfect iter inside table cost iteration client perfect iter inside client perfect iter inside table summarizes start times cost iteration di erent cases 
start times substantial bcs loops loops batched interpreted frontend executing 
data cost iteration computed di erence total time di erent iterations dividing di erence iterations 
note cost iteration bcs loops client loops 
cost iteration bcs loops higher cost iteration theta loop 
remainder section explains loops detail 
minor details code omitted clarity 
rst code fragment preamble cases th database data th res th int zero new th int th int new th int int loop iters loop iters preamble declares variables creates promises represent values 
number iterations varied loop iters variable 
case loop performs roughly amount ofwork 
iteration calls fetch method object data 
fetch method performs simple linear search database users looking string match argument usr 
fetch method return basic value calls batched 
addition loop performs addition integer reasons explained 
loop extra keep track number iterations 
client loop simple client loop sends new batch frontend iteration 
loop client side 
int loop iters add force batch data fetch usr data fetch usr data fetch usr rst statement body loop gratuitous call integer add operation causes batch sent frontend iteration happen loop condition depended thor call 
batched version call added versions loop 
main di erence cost loop perfect batching cost domain crossing iteration addition veneer remapping batch 
clear previous gures doing domain crossing iteration expensive 
case total cost loop nt number iterations number statements loop cost domain crossing average cost call 
average cost call absolute measure depends particular mix calls di erent calls necessarily cost 
give idea performance ected ran similar loop larger number similar calls body 
solving equation microseconds measured nt microseconds table get microseconds 
includes cost doing remapping iteration cost batching type checking 
see shortly cost overhead 
client loop perfect batching loop previous call add batched 
loop client side 
int loop iters add zero batch call add 
data fetch usr data fetch usr data fetch usr version client side loop calls return basic value results 
calls batched causing loop unrolled batch 
size batch equal number iterations loop executes times number statements body 
refer case perfect batching 
case performs better previous cost domain crossing amortized iterations loop iteration 
total cost case subsequent cases negligible impact total performance amortized iterations loop 
computed 
table cost iteration nt microseconds 
microseconds 
note case futures remapped loop nished executing 
cost remapping amortized ectively cient large remapping smaller ones 
accounts di erence case previous case 
batched loop version loop uses batched control structure 
batched loop th cell th int sum new th cell th int th int iters new th int loop iters sum put zero sum get lt iters add zero data fetch usr data fetch usr data fetch usr sum put sum get add case entire batch consists loop 
note cell sum keep track number iterations 
due cell total number calls iteration case greater client side loops 
experiment control structure outperforms client loops small number iterations 
due fact bcs mechanism amortizes overhead evaluating calls multiple iterations 
batched futures versions call parsed type checked evaluated individually 
control structure case frontend constructs parse tree representation loop evaluates iteration 
parse tree highly optimized overhead evaluating iteration evaluating individual calls batched futures mechanism 
total cost evaluating batched loop roughly modeled follows nt cost parsing type checking call loop cost evaluating call 
case 
idea cost parsing call bcs 
start cost loop table nt microseconds 
microseconds 
includes overhead building parse tree loop value gives idea cost evaluating call bcs microseconds nt table microseconds 
note quite bit smaller previous cases 
due fact parsing type checking costs included addition average calls put get lt cheap compared cost fetch 
batched loop version loop uses foreach batched control structure 
batched loop th int foreach iters iters loop add zero batch call add 
data fetch usr data fetch usr data fetch usr foreach batched loop ideal way structure particular loop 
control structure required cell introducing additional overhead control structure allows concise description computation performed 
performance loop modeled formula loop 
case extra call iterator 
case similar previous case 
di erence due fact mix calls di erent cost parsing slightly di erent 
cost iteration microseconds smaller loop number calls 
case microseconds 
slightly higher case loop case average included calls put get lt cheaper calls fetch 
theta loop nal version loop executed entirely frontend side making single call client 
call theta version loop 
data loop fetch usr loop iters fastest possible implementation benchmark 
theta code 
loop fetch method de ned database type earlier 
loop fetch string iters int iters self fetch self fetch self fetch loop fetch case cost evaluating loop represents cost executing call 
cost iteration microseconds 
microseconds 
note remapping case futures generated call loop fetch 
case number calls batched loop 
di erence previous case attributed entirely evaluation mechanism batched loop 
note cost small case microseconds 
bene ts optimizations experiment described section shows performance gain due optimizations described previous chapter 
experiment loop similar batched loop described previous section run iterations 
di erence loop previous section number calls fetch varied calls add 
cell count number iterations remains 
shows cost evaluating parsing loop versus number calls fetch method 
curve labeled optimized measures expense evaluation method node section optimizations ect 
graph labeled optimized shows experiment method node optimizations turned 
case fetch method call translates method node constant receiver single constant argument 
calls cell methods get put optimized 
di erence curves calls fetch due fact calls put get lt executed iteration 
table shows average cost call fetch method optimized schemes 
milliseconds calls fetch method node optimization scheme time batched optimized table cost call fetch optimized optimized chapter rst part chapter presents summary done thesis drawn 
remainder chapter presents suggestions 
summary thesis new mechanisms increase performance cross domain calls 
rst basic value promises allows calls return basic values batched allowing larger batching factor implies better performance 
cases promises increase batching factor directly expect mayor 
promises integral part second mechanism thesis batched control structures bcs 
bcs mechanism allows client programmer augment batch simple control ow information interpreted server 
batched control structure client language control structure improve batching factor eliminating need communicate immediately server obtain values critical control ow program 
performance studies shown basic value promises bcs signi cantly improve performance client program thor 
promises increase batching factor traversal oo benchmark increasing performance 
bcs illustrate possible increase batching factor reduced overhead associated call thor bcs 
similar remote evaluation rev allows client program send small sub programs evaluated server 
stamos client server written programming language clu 
goals thor allow clients written di erent programming languages share objects 
rev operations invoked client exported server provided shipped code 
thor operations called client exported thor 
bcs extends calling mechanism allowing control ow expressed batch calls 
bcs means general purpose programming language way clu remote evaluation di erent intended distributing computation number servers improve performance application 
contrast bcs thor reduce communication evaluation overhead remote calls remote calls way thor 
promises bcs points spectrum client interaction thor 
spectrum client uses thor repository data objects 
client interacts thor placing individual calls waiting results 
clearly ine cient way doing things 
extreme spectrum application written entirely theta stored thor part database 
client case small program invokes single top level thor procedure 
presumably cient working thor 
approach drawbacks allow client programmer heterogeneity thor 
client programmer learn theta order write application 
envision application programmers want language familiar 
second writing part application theta requires stored persistently named inside thor multiple times 
providing programmer tools batched futures bcs application written succinctly ciently client language set prede ned types stored inside thor 
sections describe possible extensions bcs mechanism 
batched break statement useful extension current bcs mechanism addition break statement terminates execution nearest enclosing loop 
ect break achieved loop encoding condition break loop condition 
case loop possible 
break way toachieve early termination case loop 
important example iterator search case want terminate search soon match 
veneer break statement implemented procedure places break marker batch 
frontend parse tree contain break node represent break statement 
evaluated break node sets ag 
ag checked evaluation function evaluating corresponding node 
evaluation functions method nodes return immediately ag set evaluating respective nodes 
evaluation function node checks ag iteration 
ag set clears ag returns immediately 
evaluation continues node node parse tree 
case foreach iterator checks ag iteration 
ag set clears ag returns 
batched continue statement semantics continue execution continues iteration loop 
continue implemented similar way break 
provides continue statement called batched foreach loop 
frontend continue ag 
continue node evaluated sets ag 
subsequent calls method node evaluation functions check ag return immediately set 
evaluation functions foreach nodes clear ag iteration 
batched procedures inconvenience bcs batched procedures 
sequence code performed multiple times code duplicated inside bcs rewritten theta procedure called directly client 
possible simulate recursion bcs quite cumbersome 
hard extend current bcs mechanism include procedures 
basic idea create parse tree batched procedure associate name provided client 
client program cause parse tree evaluated di erent times invoking explicitly name 
illustrate mechanism discuss case procedure argument results 
real mechanism provide support multiple arguments result 
new procedure construct takes arguments name procedure single argument procedure name type argument 
argument type 
name argument type frontend look corresponding type 
type stored parse tree node procedure type checking algorithm verify argument passed client right type 
example batched procedure created swap procedure mentioned chapter th cell int temp new th cell th int procedure swap point temp put set set temp get procedure call batched procedure client calls invoke procedure function provided veneer th point invoke procedure swap sandboxing alternative providing safety running separate protection domains 
mechanism software fault isolation popularly called sandboxing inserts software bounds unsafe client guarantee client doesnot access memory outside designated area 
reduces call overhead eliminating need domain crossing call 
sandboxing thor batching obviate need type checking eliminate overhead constructing parsing batch calls 
hand bcs mechanism allows server construct highly cient representation computation repeatedly evaluated 
clear sandboxing produce larger performance bene ts bcs batched futures 
thorough comparison schemes allow answer question help decide drawbacks sandboxing worth gains 
bibliography bershad anderson lazowska levy 
lightweight remote procedure call 
acm transactions computer systems february 
andrew black norman hutchinson 
typechecking polymorphism emerald 
technical report digital equipment cambridge research laboratory december 

reducing cross domain call overhead batched futures 
master thesis massachusetts institute technology 
luca cardelli 
semantics multiple inheritance 
information computation 
readings object oriented database systems zdonik maier eds morgan kaufmann 
michael carey david dewitt je rey naughton 
oo benchmark 
proceedings acm sigmod international conference management data pages washington dc may 
castro 
object invocation performance thor 
programming methodology group memo appear laboratory computer science mit cambridge ma 
mark day 
client cache management distributed object database 
phd thesis massachusetts institute technology 
forthcoming 
mark day etal theta manual 
programming methodology group laboratory computer science mit cambridge ma 
appear 
goodenough 
exception handling issues proposed notation 
communications acm december 
hel 
modula veneer thor 
liskov etal clu manual 
goos hartmanis editors lecture notes computer science volume 
springer verlag berlin 
liskov gruber johnson shrira 
highly available object repository heterogeneous distributed system 
proceedings fourth international workshop persistent object systems design implementation pages martha vineyard ma september 
liskov shrira 
promises linguistic support cient asynchronous procedure calls distributed systems 
proceedings acm sigplan conference programming languages design implementation 
acm june 
andrew myers 
fast object operations programming system 
master thesis massachusetts institute technology january 
anderson wahbe lucco graham 
cient software fault isolation 
proc 
fourteenth acm symposium operating system principles pages december 
scha ert trellis owl 
proceedings acm conference object oriented systems languages applications portland september 
stamos gi ord 
remote evaluation 
acm transactions programming languages systems october 

