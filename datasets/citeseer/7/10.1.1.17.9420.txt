structural luca aceto operational semantics wan fokkink chris verhoef contents preliminaries labelled transition systems 
behavioural equivalences preorders 
hennessy milner logic 
term algebras 
transition system specifications 
examples tsss 
basic process algebra empty process 
priorities 
discrete time 
meaning tsss model theoretic answers 
proof theoretic answers 
answers stratification 
evaluation answers 
applications 
brics basic research computer science centre danish national research foundation department computer science aalborg university fredrik vej dk aalborg denmark 
email auc dk 
partially supported italian cnr nazionale informatica matematica 
department software engineering kruislaan sj amsterdam netherlands 
email wa hi 
partially supported dation 
university amsterdam department computer science programming research group kruislaan sj amsterdam netherlands 
email uva 
conservative extension operational conservative extension 
implications valued stable models 
applications axiomatizations 
axiomatic conservative extension 
completeness axiomatizations 
completeness axiomatizations 
applications rewriting 
rewrite conservative extension 
ground confluence 
congruence formats panth format 
ntree format 
de simone format 
de simone languages 
expressiveness de simone languages 
de simone languages process algebras 
gsos format 
gsos languages 
junk rules 
coding universal counter machine 
infinitary gsos languages inducing regular ltss turning gsos rules equations 
recursive gsos ltss divergence 
results gsos languages 
rbb safe format 
precongruence formats behavioural preorders 
simulation 
ready simulation 
decorated traces 
accepting traces 
traces 
trace congruences 
sorted higher order languages actual world 
formal world 
actual formal transition rules 
operational conservative extension 
denotational semantics preliminaries 
domains 

finite synchronization trees 
domain synchronization trees 
recursive gsos denotational semantics 
index structural operational semantics sos provides framework give operational semantics programming specification languages intuitive appeal flexibility considerable application theory concurrent processes 
sos widely programming language semantics large interesting theoretical developments taken place concurrency theory 
particular sos successfully applied formal tool establish results hold classes process description languages 
concept rule format played major role development general theory process description languages formats proposed research literature 
chapter presents exposition existing rule formats rich body results guaranteed hold process description language sos formats 
far possible theory developed sos features predicates negative premises 
phrases structural operational semantics labelled transition systems bisimulation hennessy milner logic transition system specifications basic process algebra priorities discrete time stratification conservative extensions valued stable models equational logic complete axiomatizations completeness conditional term rewriting systems ground confluence panth format ntree format format format de simone format gsos format regular processes recursion rooted branching bisimulation simulation ready simulation ready traces failures accepting traces traces trace congruences sorted higher order languages denotational semantics algebraic semantics synchronization trees full abstraction 
importance giving precise semantics programming specification languages recognized sixties development high level programming languages cf early accounts operational semantics semantics describes programs compute stepwise fashion possible state transformations perform advocated mccarthy elaborated 
examples full blown languages endowed operational semantics algol pl csp 
structural operational semantics sos provides framework give operational semantics programming specification languages 
particular intuitive appeal flexibility sos considerable application study semantics concurrent processes despite successful de bakker zucker hennessy abramsky see methods denotational semantics appear difficult apply general 
sos generates labelled transition system states closed terms algebraic signature transitions states obtained inductively collection called transition rules form premises typical example transition rule conn stipulating holds certain closed terms closed term general validity premises transition rule certain substitution implies validity rule substitution 
sos successfully applied formal tool establish results hold classes process description languages 
allowed generalization known results field process algebra development meta theory process calculi realization extant results field depend general semantic properties language constructs 
concept rule format played major role development meta theory process description languages formats proposed research literature 
principal aim chapter give exposition existing rule formats 
formats surveyed comes equipped rich body results guaranteed hold process calculus sos format 
predicates sos semantics coded binary relations 
negative premises expressed positively pred 
literature see sos definitions decorated predicates negative premises 
example predicates express matters un successful termination convergence divergence maximal delay side conditions 
negative premises describe deadlock detection sequencing priorities probabilistic behaviour urgency various real discrete time settings 
predicates negative premises pervasive lead cleaner semantic descriptions features constructs interest theory sos setting deals explicitly notions possible 
hope chapter useful guide literature sos process algebra 
organization chapter follows 
sect 
presents preliminaries sos theory contains standard sos definitions serve running examples 
sect 
gives overview different ways give meaning sos definitions 
sect 
presents syntactic constraints extension sos definition influence properties original sos definition 
sect 
studies wide range syntactic formats sos definitions guarantee semantics term determined semantics arguments focuses connection sos semantics complete proof systems 
sect 
describes formalism deal variable binders explicitly 
sect 
pays attention automatic generation fully denotational models process calculi sos semantics 
terminology structural vs structured operational semantics mentioned chapter shall acronym sos stand structural operational semantics 
adjective structural plotkin title seminal set lecture notes approach giving formal semantics programming specification languages places great emphasis defining effect running program terms structure 
term structural operational semantics commonly literature semantics programming languages various textbooks topic see 
form semantics describe chapter called plotkin style operational semantics aforementioned daimi report plotkin papers kind specification 
authors see prefer term transition semantics emphasize transitions program states main objects study form semantics 
terminology albeit descriptive context structural plotkin style drawback applicable range operational semantics automata petri nets different nature deal chapter 
ll ll groote vaandrager acronym sos stand structured operational semantics 
aim emphasize transition system specification leads transition system bisimulation equivalence congruence called structured possibly compositional level concrete transition systems 
adopting terminology process algebra literature may construed suggesting forms operational semantics unstructured 
disclaimer chapter focus results theory sos feel interest point view process algebra 
sign maturity field sos applications settings 
original motivation development sos give semantics programming languages success endeavour witnessed growing number real life programming languages usable semantic descriptions means sos see 
applications sos limit mentioning operational approach type soundness pioneered preferred choice methods denotational semantics correctness hardware implementations real life programming languages compilation techniques established sos fit reasonable operational extensions language pcf scott original lattice model studied framework sos observed sos appropriate style static pro gram analysis derivation proof rules functional languages oper specifications investigated building cf 
sect 

interesting examples applications sos covered chapter 
hope reader tempted explore possibly contribute fascinating research area 
acknowledgments thoughts theory sos shaped inspiring collaborations researchers 
explicitly 
evident readers chapter theory survey presentation give possible colleagues 
particular ideas bard bloom rob van glabbeek sect 
heavily jan groote robert de simone vaandrager influential 
hope list prove useful guiding interested readers original sources subject matter 
davide simone anonymous referee thorough reading draft chapter 
preliminaries section basic notions process theory needed remainder chapter 
presentation necessarily brief interested reader encouraged consult information motivation background material subject matter 
hope basic definitions results mentioned section help reader go material chapter ease 
labelled transition systems reviewing model labelled transition systems express operational semantics process calculi 
consist binary relations states carrying action label predicates states 
intuitively expresses state evolve state execution action sp expresses predicate holds state convenience terminology refer binary relations predicates states transitions 
definition labelled transition system labelled transition sys tem lts quadruple proc act act pred proc set states ranged act set actions ranged proc proc act 
usual suggestive notation lieu write state proc satisfies resp 
satisfy predicate binary relations unary predicates sp lts called tran sitions 
follows shall identify lts set transitions 
trust meaning clear context 
definition finiteness constraints ltss lts finitely branching state finitely going transitions regular finitely branching state reach finitely states finite finitely branching infinite sequence transitions 
conditions regularity finiteness defined usually level process graphs transition systems distinguished initial state states reachable zero transitions 
particular definition ensures lts finite regular process graphs obtained choosing arbitrary state initial removing states unreachable restricting transition relations set reachable states 
note notion regularity defined purely 
instance lts defined regular definition unfolding regular lts 
define semantic notions regularity modulo notion behavioural equivalence 
see section chapter issue information behavioural equivalences states ltss 
behavioural equivalences preorders ltss describe operational behaviour processes great detail 
order away irrelevant information way processes compute wealth notions behavioural equivalence relation reflexive transitive symmetric preorder relation reflexive transitive states lts studied literature process theory 
systematic investigation notions see chapter chapter issue van glabbeek presents linear time branching time spectrum 
lattice contains known behavioural equivalences preorders ltss ordered inclusion 
investigate fragment spectrum proceed sake completeness 
definition simulation ready simulation bisimulation assume lts 
binary relation states simulation sl sl transition slp 
binary relation states ready simulation simulation property sl sl slp sp 
bisimulation symmetric simulation 
write sl es resp 
sl simulation resp 
ready simulation sl states sl bisimilar written sl bisimulation relation relates 
henceforth relation referred bisimulation equivalence 
bisimulation equivalence relates states lts precisely branching structure 
simulation see bisimulation relax ready simulation known requirement different degrees 
preorders induced ways abstracting away full branching structure ltss 
decorated versions traces 
definition ace semantics lts sequence act trace state exist states sl 
sn sl sn abbreviated sn 
act pred trace state exists state sp 
write set traces included state define follows symbol stand equals definition initials act proc 
pred sp definition decorated trace semantics assume lts predicates 
ready traces 
sequence anxn xi act pred ai act ready trace state sl 
ssn write set ready traces included failure traces 
sequence anxn xi act pred ai act pred failure trace state sl sn sl snp respectively initials xi write eft set failure traces included 
pair act act pred ready state sl state sl initials write set included failures 
pair act act pred failure state sl state sl initials 
write sets failures traces included completed traces 
act completed trace state sl state sl initials act pred completed trace state sip state sl 
write ct set completed traces included accepting traces 
act accepting trace state state sl 
write eat set accepting traces included decorated trace semantics defined take predicates account 
uses semantics literature process theory occur settings predicates 
definition completed trace preorder agrees definition notion differs required completed traces traces included notion accepting trace standard formal language theory see received widespread treatment literature process theory 
rs ct rt ft relation preorder states arbitrary ltss 
kernel denoted iff result standard process theory cf 
proposition lts predicates eat directed edge relation means source edge included target 
es included eat included inclusions hold kernels preorders 
inclusions previous proposition proper lts consideration includes modulo bisimulation equivalence fi nite synchronization trees see sect 
examples 
hennessy milner logic modal temporal logics reactive programs considerable theory practice concurrency see 
earliest influential connections logics reactive programs behavioural relations hennessy milner introduced multi modal logic showed characterized bisimulation equivalence 
limit briefly recalling basic definitions results hennessy milner logic 
interested reader referred details motivation 
definition standard apart atomic propositions cater presence predicates ltss 
definition hennessy milner logic set hml formulae bnf grammar range act pred respectively 
lts states satisfy hml formula written defined inductively true 
sp fi negation conjunction hml define standard boolean connectives 
states considered equivalent respect hml written hml iff hml formulae seminal result due hennessy milner 
theorem equivalence relations nitely branching ltss 
ohm coincide fi restriction finitely branching ltss thm 
dropped infinitary conjunctions allowed syntax hml 
term algebras section reviews basic notions term algebras needed chapter 
start countably infinite set ar variables ranged definition signature signature set function symbols disjoint vat arity mapping assigns natural number function symbol function symbol arity zero called constant function symbols arity called unary binary respectively 
arity function symbol represents number arguments 
definition term set open terms signature ranged set term tl tar term function symbol tl tar terms 
denotes set closed terms terms contain variables 
constant term abbreviated convention write term phrase intend term binary 
substitution mapping 
substitution closed maps variable closed term 
substitution extends mapping terms terms usual term obtained replacing occurrences variables 
context xl xn denotes open term distinct variables xl xn appear 
term tl tn obtained replacing occurrences variables xi xl ti definition congruence assume signature equivalence relation resp 
preorder congruence resp 
precongruence implies tl 
tar ul 
uar transition system specifications remainder chapter set proc states general consist closed terms signature 
proceed introduce main object study field sos viz 
transition system specification collection inductive proof rules derive transitions set closed terms 
definition transition system specification signature range 
transition rule form hick set positive premises tp negative premises tp 
form tp 
left hand side source form right hand side target transition rule closed contain variables 
transition system specification tss set transition rules 
tss positive transition rules contain negative premises 
sake clarity transition rules displayed form premises transition rule proper set notation 
systematic study tsss may study tsss negative premises appeared 
proceed define transition provable tss 
fol lowing notion proof generalizes standard definition see allowing derivation closed transition rules 
deriva tion transition corresponds derivation closed transition rule case corresponds derivation assumptions definition literal positive literals transitions tp negative literals expressions tp range collection closed terms 
literal positive negative literal 
definition proof tss 
proof closed transition rule upwardly branching tree infinite branches nodes labelled literals root labelled set labels nodes directly node label 

closed substitution instance transition rule proof exists provable notation hick 
examples tsss section tsss literature serve running examples sections come 
abundant examples systematic sos handbook 
hartel ll developed tool environment animation tsss functional programming languages 
basic process algebra empty process signature basic process algebra empty process denoted bpae consists operators set act constants representing indivisible behaviour special constant called empty process representing successful termination binary operator called alternative composition term tl represents process executes tl binary operator called sequential composition term tl represents process executes tl 
bnf grammar bpae act tl tl intuition operators bpae formalized transition rules table constitute tss bpae 
tss defines transitions express term evolve term execution action act transitions tv express term terminate successfully 
variables transition rules range collection closed terms ranges act 
priorities language bpae obtained adding priority operator bpae 
function symbol assumes partial order process obtained eliminating transitions process transition semantics priority operator captured transition rules table 
tss bpae consists transition rules tables 
yx yx table transition rules bpae 
xv table transition rules priority operator 
discrete time final example tss extension bpae relative discrete time denoted bpae dt 
time progresses distinct time steps transition denotes passing time slice 
syntax bpae dt consists operators bpae unary operator ad represent delay time unit 
term ad execute transitions delayed time step 
term evolve time slice evolve time slice 
transition rules dealing time steps table 
tss bpae dt consists transition rules tables 
meaning tsss positive tss specifies lts straightforward way set provable transitions cf 
def 

groote pointed trivial associate lts tss containing negative premises 
solutions investigated originating logic programming 
section presents overview xv xx table transition rules discrete time 
associate ltss tss 
presentation heavily excellent systematic analysis meaning tsss van glabbeek refer reader op 
cit 
details 
see unclear meaning tss negative premises consider tss consisting constant transition rules ap ap tx apx ap regarded example tss specify welldefined lts 
example suggests tsss may meaningless 
questions answer tsss meaningful ltss associated 
papers possible answers questions consisting class tsss mapping class ltss 
answers consistent agree lts associate tss intersection domains 
answer extends answer class meaningful tsss extends consistent 
collection answers proposed van glabbeek op 
cit 
grouped model theoretic proof theoretic flavour 
proceed 
model theoretic answers answer answer questions take class positive tsss meaningful ones associate positive tss lts consisting provable transitions 
negative premises possible give clean description important constructs programming specification languages answer really satisfactory 
general answers questions proposed literature 
reviewing recall criteria imposed reasonable answers 
definition lts set literals write positive literals negative literals closed terms tp negative literals tp definition supported model tss lts 
model closed substitution instance transition rule supported closed substitution instance transition rule requirement model says contains transitions offers justification 
second requirement supported says contains transitions offers justification 
note lts containing possible transitions model tss lts containing transitions supported tss 
result standard roots classic theory inductive definitions 
proposition positive tss set transitions provable supported model model starting prop 
ways generalize answer tsss negative premises 
answer tss meaningful iff model 
answer tss meaningful iff supported model 
note general unique supported model may exist 
counter example tss models ap ap supported 
answers incomparable 
example tss ap model supported models 
hand tss models ap ap supported supported model 
answers extend answer inconsistent 
example tss model ap supported model ap ap 
ap ap ap ap answer proposed 
answer tss meaningful iff unique supported model 
positive tss supported models viz 
ap answer extend answer 
gsos languages considered op 
cit 
cf 
sect 
answer coin acceptable answers mentioned section 
note supported model unique supported model 
entail answer satisfactory tsss general 
fages proposed strengthening notion support setting logic programming 
supported means transition may non empty proof presence starting transitions 
premises proof may include transition derivation allowing loops case 
notion supported model idea absence transition may assumed priori provided assumption consistent presence transition needs proven sense del building set assumptions contains negative literals 
definition supported model lts supported model tss model transition proves closed transition rule contains negative literals stable model developed gelfond lifschitz area logic programming adapted tsss allows transitions supported 
definition stable model lts stable model tss transition iff proves closed transition rule contains negative literals lts stable model tss tiff supported model 
answer tss meaningful iff unique stable model 
answer extends answer improves answers rejecting tss meaningless 
improves answer rejecting tss model supported 
furthermore answer gives meaning perfectly acceptable tsss handled answers 
example consider tss 
ap ap ap ap compelling way obtain ap expect ap hold consequently ap holds 
ap unique stable model tss 
models supported ap ap 
valued stable model introduced przymusinski logic programming partitions set transitions disjoint subsets set transitions certainly true set transitions unknown true set remaining transitions alse 
definition valued stable model disjoint pair sets transitions constitutes valued stable model tss transition iff proves closed transition rule contains negative literals transition iff proves closed transition rule contains negative literals tss valued stable models 
example tss ap iz ap ap ap valued stable models 
tss affords valued stable model sense set maximal 
przymusinski showed valued stable model coincides called founded model introduced van gelder ross schlipf logic programming 
answer tss meaningful iff valued stable model contain unknown transitions 
associated lts consists true transitions valued stable model 
answer extends answer extended answer inconsistent answers 
particular tsss outside domain associates ap ts ap 
sect 
answer stand stead formulation congruence results presence negative premises cf 
thm 
thm 
thm 
answers unsatisfactory 
proof theoretic answers note reader 
section extend notion negative literals expressions form intuitively expression denotes term evolve term execution action section reviews possible answers questions generalization concept proof 
van glabbeek proposed generalizations concept proof def 
enable derivation negative literals 
generalizations notions supported model def 
supported model def 
respectively 
definition denying literal pairs literals deny tp tp 
definition supported proof supported proof literal ct tss proof see extra clause 
negative closed substitution instance tran sition rule ff denies literal denies write ct supported proof ct exists 
definition supported proof supported proof literal ct tss proof def 
extra clause 
negative set negative literals ff literal denying literal denies write ws ct supported proof ct exists 
clause def 
allows infer tp manifestly impossible infer tp respectively 
clause def 
allows inferences impossibility derive tp detected examining possible proofs consist step 
consequence tss included ws 
results stem 
proposition tss induced relation ws contain denying literals 
proposition tss literal ct 
ct implies ct supported model 
ws ct implies ct supported model introduce concept complete tss transition provable refutable 
definition completeness tss complete ws transition resp 
tp resp 
tp resp 
tp 
answer tss meaningful iff complete 
associated lts consists provable transitions 
answer tss meaningful iff ws complete 
associated lts consists ws provable transitions 
complete shall mean ws complete 
tss complete iff valued stable model contain unknown transitions see answer agrees answer 
answer extends answer 
example area process theory viz 
modelling priority operator basic process algebra silent step handled answer answer showing full generality answer useful applications 
proceed show associate lts tss concept supported proof 
illustrated tsss lts supported model 
model basic requirement van glabbeek proposed universal answer gives requirement 
examine 
associated lts model contain ap ap 
symmetry associated lts include transitions 
reason include transitions lts associated ap ap 
considerations lead proposal 
answer tss meaningful 
associated lts consists transitions denying negative literals ws provable 
answer inspired observation tss set transitions denying negative literals ws provable constitutes model 
answer extends answer inconsistent answers 
answer associates lts ap ap lts ap 
answers stratification review methods assign meaning tsss technique local stratification proposed setting logic programming przymusinski 
technique adapted tsss 
definition stratification mapping transitions ordinal numbers stratification tss transition rule closed substitution positive premises cr negative premises tp rr closed terms rr respectively 
stratification strict holds positive premises tss strict stratification strictly 
tss transition depends negatively 
lts associated tss may built stratum transitions value time 
transition value zero provable sense def 
soon validity transitions value greater known ordinal number validity closed instantiations negative premises occur proof transition value known determines validity transitions 
tss stratification stratum ln transitions ordinal number defined ordinal induction ln iff proves closed transition rule ul similarly tss strict stratification stratum mn tran sitions ordinal number defined ordinal induction mn iff closed substitution instance transition rule unm groote proved sets independent chosen strict stratification 
justifies answers questions 
answer tss meaningful iff 
associated lts 
answer tss meaningful iff strictly 
associated lts answer extends answer extended answer 
answer extended answers 
evaluation answers possible answers questions tsss meaningful ltss associated 
answer positive classical interpretation tsss negative premises answers model supported model straightforward generalizations 
answer unique supported model stems ascertain tsss gsos format cf 
sect 
meaningful 
tss shows answer yields counter intuitive results general 
fortunately tsss gsos format strictly restrictive criteria meaningful tsss considered 
gsos languages recursion longer straightforward find associated lts see 
solution involving special divergence predicate discussed sect 

answer unique stable generally considered general acceptable answer available 
answer complete general answer undesirable properties 
answer concept provability incorporating notion negation clark 
answer unknown transitions agrees answer tss complete iff valued stable model contain unknown transitions 
answer complete support yields unique supported models 
notion provability somewhat simpler apply incorporates notion negation finite 
answer irrefutable gives meaning tss dis advantage yields unstable models unsupported models 
example process algebra tss supported models bpa priority operator unguarded recursion ing defined 
answer gives meaning tss appears arbitrary useful 
particular recursively defined processes satisfy defining equations highly undesirable feature accounts 
answer stratification best known answer logic programming 
variant allows tsss unique supported model answer strict stratification 
answers practical importance extended answer 
giving strict stratification useful tool showing tss complete technique applied examples remainder chapter 
applications show tsss sect 
complete cation 
fact answer extends answers 
bpa empty process tss bpae positive 
priorities tss bpae complete seen giving suitable stratification counting number occurrences priority operator left hand side transition 
closed term contains occurrences tx consider instance second transition rule table clearly closed terms contains occurrence priority operator similar fashion verified transition rules bpae stratification 
tss bpae complete 
discrete time tss bpae complete seen giving suitable stratification counting occurrences alternative composition left hand side timed transition 
closed term contains occurrences act 
consider instance transition rule table clearly closed terms contains occurrences alternative composition similar fashion verified transition rules bpae stratification 
tss bpae dt complete 
conservative extension process calculi ccs csp acp extended new features original tsss provide semantics process algebras extended transition rules describe features see systematic approach 
question arises naturally ltss associated original extended tss contain transitions tp closed terms original domain 
usually desirable extension operationally conservative meaning provable transitions original term original extended tss 
groote vaandrager ll thm 
proposed syntactic restrictions tss automatically yield extension tss transition rules contain fresh function symbols sources op conservative cf 
notion disjoint extension def 

bol groote ll supplied conservative extension format negative premises 
verhoef showed certain conditions transition rule extension allowed original term source 
verhoef formulated generalization context inequational specifications 
fokkink verhoef relaxed syntactic restrictions original tss lifted operational conservative extension result higher order languages see sect 

operational conservative extension natural notion literature property hidden assumption formulation proof omitted justification 
example happens design process algebras applications strategy prove completeness mentioned sect 

paying attention operational conservative extension leads accurate concurrency theory beneficial respects 
operational conservative extension applied obtain results process algebra harder obtain classical term rewriting approaches customized techniques 
organization section follows 
sect 
presents syntactic constraints ensure extension tss operationally tive 
sect 
studies relation valued stable models tss operational conservative extension 
sects 
show operational conservative extension applied derive useful properties concerning axiomatizations term rewriting systems 
related mention mosses introduced concept modular sos transition labels arrows category adjacent labels computations required composable 
intuitively transition labels represent information processing steps 
mosses argues modular sos ensures high degree modularity extends changes described language modular sos extended changed accordingly reformulation 
degano priami introduced concept enhanced operational seman tics transitions labelled encodings proofs 
enhanced operational semantics supports parametricity enables express different views system consistent retrieve views single concrete specification 
operational conservative extension wants add new operators rules tss 
natural operation tsss take componentwise union 
definition stems 
definition sum tsss tsss signatures eo agree arity function symbols intersection 
write union 
sum notation tot tss signature containing rules 
operational conservative extension requires original tss extension prove exactly closed transition rules negative premises original closed term source 
notion operational conservative extension related equivalence tion tsss see thm 
tsss equivalent prove exactly closed transition rules negative premises 
definition inspired notion supported proof def 

definition operational conservative extension tss operational conservative extension tss closed transi tion rule contains negative literals left hand side proceed define notion source dependent variable important ingredient rule format ensure extension tss operationally conservative see thm 

order conclude extended tss operationally conservative original tss need know variables original transition rules source dependent 
literature criterion neglected 
example extended tss considered transition rule extension contains fresh operator source fact concluded extension operationally conservative 
general characteristic shown example 
example constants 
consider tss signature ta consists transition rule xp ap 
extend tss tss signature tb consists transition rule bp contains fresh constant source 
transition ap proven extended tss original extension operationally conservative 
definition source dependency source dependent variables transition rule defined inductively follows variables source source dependent premise variables source dependent variables source dependent 
transition rule source dependent variables 
note transition rule xp ap example source dependent variable 
thm 
stems formulates sufficient criteria tss operational conservative extension tss 
say term fresh contains function symbol similarly action predicate symbol fresh occur 
theorem tsss signatures respectively 
conditions operational conservative extension 

source dependent 

source fresh premise form tp variables occur source fresh 
apply thm 
running examples sect 

bpa empty process transition rules bpae 
example consider third transition rule sequential composition table variables source dependent occur source 
source dependent premise ensures source dependent 
variables transition rule source dependent transition rule source dependent 
bpa empty process silent step process algebra bpae obtained extending syntax bpae fresh constant called silent step see sect 
details intuition constant 
tss bpae tss bpae table proviso ranges act 
observations concerning extra transition rules tss bpae source transition rule silent step contains fresh constant transition rule alternative sequential composition transitions contains premise fresh relation symbol left hand side variable source 
transition rules bpae source dependent thm 
implies bpae operational conservative extension bpae 
priorities transition rules priority operator table contain fresh function symbol sources 
transition rules bpae source dependent thm 
implies bpae operational conservative extension bpae 
discrete time tss bpae table follow ing observations 
transition rule delay operator contains fresh operator source 
second transition rules sequential composition transition rules alternative composition fresh operator sources contain premise relation symbol fresh variable left hand side occurs source 
transition rules bpae source dependent thm 
implies bpae operational conservative extension bpae 
implications valued stable models noted operational conservative extension notion formulated del implies conservativity property valued stable models cf 
def 

extended tss operationally conservative original tss sense def 
valued stable model extended tss restricted transitions original term left hand side result valued stable model original tss 
proposition operational conservative extension 
valued stable model ct left hand side 
zo ct left hand side ct zo valued stable model 
converse prop 
holds sense 
extended tss operationally conservative original tss stable model original tss obtained restricting valued stable model extended tss transitions original term left hand side 
proposition tot operational conservative extension 
valued stable model exists valued stable model 
left hand side 

left hand side 
corollary operational conservative extension 
valued stable model 
left hand side 

left hand side 
valued stable model 
easy see prop 
holds stable models cf 
def 

example shows prop 
hold stable models 
example empty tss 
obviously empty lts stable model 
constant consist single transition rule ap ap 
thm 
tx operational conservative extension 
tx stable model valued stable model ap 
applications axiomatizations section discusses operational conservative extension derive extension axiomatization called axiomatically conservative axiomatization complete complete respect behavioural equivalence 
axiomatic conservative extension definition axiomatization conditional axiomatization signature consists set conditional equations called axioms form uo tl ul 
tn un ti ui 
axiomatization gives rise binary equality relation uo tl ul tn un axiom substitution ti ui relation closed symmetry transitivity function symbol tl ti ti tar tl ti ti tar 
definition soundness completeness assume axiomatization equivalence relation 

sound modulo iff implies 

complete modulo iff implies 
note definitions soundness completeness albeit standard literature process algebras weaker classic ones logic universal algebra required apply arbitrary open expressions 
definition axiomatic conservative extension axiomatizations signatures respectively 
union axiomatic conservative extension equality derived derived theorem derive extension axiomatization axiomatically conservative 
theorem equivalence relation assume axiomatizations respectively 
sound modulo 
complete modulo 
axiomatic conservative extension idea thm 
follows 
suppose derived 
soundness requirement yields completeness requirement yields derived 
particularly helpful case operational conservative extension tss 
assume tsss signatures respectively operational conservative extension 
equivalence relation states ltss 
states ltss associated closed terms equivalence relation carries respectively 
owing operational conservativity equivalence relation induced agrees equivalence relation induced 
applications thm 
process algebra presence operational conservative extension tss abundant literature give typical example 
example thin 
easily seen process algebra acp operational conservative extension acp 
baeten bergstra klop op 
cit 
axiomatization complete acp modulo bisimulation equivalence axiomatization sound acp modulo bisimulation equivalence 
thin 
says axiomatic conservative extension fifteen pages needed prove fact general case open terms means term rewriting analysis 
completeness axiomatizations theorem derive axiomatization complete 
theorem equivalence relation assume axiomatizations respectively 
sound modulo 
complete modulo 
derived 
complete modulo idea thin 
follows 
exist terms proves requirement 
soundness requirement yields implies owing completeness requirement may derive similar thm 
thm 
particularly helpful case operational conservative extension tss 
order clarify link thm 
operational conservative extensions reiterate observation sect 

assume tsss signatures respectively operational conservative extension 
equivalence relation states ltss 
states ltss associated closed terms equivalence relation carries respectively 
owing operational conservativity equivalence relation induced agrees equivalence relation induced 
applications thm 
process algebra presence operational conservative extension tss abundant literature give typical example 
example thin 
easily seen process algebra acp operational conservative extension 
bergstra klop op 
cit 
axiomatization complete bpa modulo bisimulation equivalence axiomatization sound acp modulo bisimulation equivalence satisfies requirement 
thm 
says complete acp modulo bisimulation equivalence 
precise proofs thm 
thm 
detailed information generalizations results axiomatizations inequalities reader referred 
completeness axiomatizations definition completeness axiomatization signature complete equation derived derived closed substitutions milner introduced technique derive completeness axiomatization sos 
idea give semantics open opposed closed terms particular variables need incorporated transition rules 
see applications technique realm process algebra 
theorem derive axiomatization complete 
theorem equivalence relation 
suppose closed substitutions axiomatization 
sound modulo 
complete modulo complete 
idea thm 
follows 
suppose derived closed substitutions soundness modulo requirement yields closed substitutions completeness modulo requirement yields derived thm 
particularly helpful case operational conservative extension tss 
assume tss signature extended tss provides semantics variables gives semantics open terms 
suppose operational conservative extension 
equivalence relation states ltss 
states ltss associated closed open terms respectively equivalence relation carries 
owing operational conservativity equivalence relation induced agrees equivalence relation induced 
applications thin 
process algebra abundant literature give typical example 
example extend tss bpae table letting symbol range set act actions set vat variables 
sense means variables considered constants 
extension operationally conservative follows thm 
facts transition rules bpae source dependent sources transition rules variables fresh transition rule alternative sequential composition contains premise fresh relation symbol left hand side variable source 
furthermore properties derived axiomatization bpae 
sound bpae modulo bisimulation equivalence 
open terms bpae bisimilar bisimilar closed substitutions 
complete open terms bpae modulo bisimulation equiv 
thm 
implies complete bpae modulo bisimulation equivalence 
applications rewriting section discusses operational conservative extension derive extension conditional term rewriting system called rewrite conservative conditional term rewriting system ground confluent 
rewrite conservative extension definition conditional term rewriting system assume signature conditional term rewriting system ctrs consists set rewrite rules uo tl tn tin ti ui intuitively rewrite rule directed axiom applied left right 
ctrs induces binary rewrite relation terms similar way axiomatization induces equality relation terms difference rewrite relation closed symmetry tl tn un rewrite rule substitution ti ui relation closed transitivity function symbol tl ti ti tar tl ti ti tar 
definition rewrite conservative extension ro signatures respectively 
union ro rewrite conservative extension ro rewrite relation derived conservative extension theorem tsss thm 
applies just see details applications result realm software renovation see 
note definition source dependent variables transition rules def 
applies rewrite rules rewrite rule expression uo ti ui premises 
theorem ro signatures respectively 
conditions ro rx rewrite conservative extension ro 

ro source dependent 

source fresh premise form variables occur source fresh 
ground confluence ctrs ground confluent tl tl tl ground confluence important property instance prove axiomatization complete modulo behavioural equivalence relation 
theorem derive ctrs ground confluent 
say ctrs sound modulo equivalence relation implies 
theorem equivalence relation assume ro respectively 
sound ex modulo 
derived ro 
derived ro rx 
ro ground confluent idea thin 
follows 
tl derived 
exist tl derived requirement 
soundness requirement yields tl exists requirement 
tl similar thm 
thm 
thm 
particularly helpful case operational conservative extension tss 
order clarify link thm 
operational conservative extensions reiterate observation sect 

assume tsss signatures respectively operational conservative extension 
equivalence relation states ltss 
states ltss associated closed terms equivalence relation carries respectively 
owing operational conservativity equivalence relation induced agrees equivalence relation induced tot 
applications thin 
presence operational conservative extension tss abundant literature give typical example 
example thm 
easily seen process algebra acp operational conservative extension 
bergstra klop op 
cit 
unconditional ctrs ror process algebra acp reduces closed term acp closed term 
sound acp modulo bisimulation equivalence easily shown reduce bisimilar closed terms bpa closed term 
thm 
says ground confluent 
term rewriting analysis cases needed prove fact general case open terms 
congruence formats development process theory led process description languages large body results 
field process theory matured apparent similar results proven different languages different papers research literature fact instances general theorems independent chosen process description language 
realization paved way development meta theory process description languages prove theorems classes languages time 
case science mathematics asked produce results usual generalize problem consider results specific instances general problems 
approach development theories obligations 
specific generalize choose wider class problems carefully define explicitly arguments apply class 
choose generalization helpful purpose 
process description languages equipped sos 
way giving operational semantics terms natural handle establish results hold process calculi transition rules fit certain rule format imposing syntactic constraints form allowed rules 
rule formats proven suitable tools generalization specific results process theory 
central issue area sos define rule formats ensuring behavioural equivalence relation congruence meaning function symbol respects equivalence 
section presents overview congruence formats tsss studied literature hints results proven 
basic rule format guarantee bisimulation equivalence congruence de simone format 
gsos format allows negative premises look ahead format allows look ahead negative premises 
positive gsos format speak greatest common divisor gsos format 
format extends format negative premises 
path format generalizes format predicates pant format extends format predicates 
presents lattice congruence formats bisimulation equivalence 
arrow rule format indicates transition rules format second format 
arrows connecting rule formats syntactically incomparable 
tss panth ws complete sense def 
bisimulation equivalence congruence respect function symbols signature 
panth format general known panth path gsos positive gsos de simone lattice congruence formats syntactic format guarantee bisimulation equivalence congruence 
restrictive rule formats de simone gsos guarantee nice properties 
rule formats treated separately section 
tss panth format exists equivalent tss ntree format 
result facilitates reasoning panth format cause easier prove theorem tsss ntree format tsss panth format 
example case congruence theorem bisimulation equivalence 
furthermore reduction panth ntree possible remove criterion premises earlier version congruence theorem owing fact tsss ntree format satisfy criterion default see 
sake presentation lattice focuses rule formats practical importance left ntree format derived unnamed formats disallow predicates negative premises 
rule formats mentioned deal silent actions explicitly 
particular interest rule formats 
organization section follows 
sect 
presents panth format sect 
deals equally expressive ntree format 
sects 
study de simone languages gsos languages respectively 
sect 
introduces congruence format presence silent actions sect 
presents congruence formats wide range behavioural preorders 
sect 
studies completed trace congruence induced number congruence formats 
panth format section presents panth format states congruence theorem cf 
def 
ll respect bisimulation equivalence cf 
def 

definition panth format transition rule panth format satisfies restrictions 
positive premise right hand side single variable 
source contains function symbol 
variables occur right hand sides positive premises source distinct 
tss panth format consists panth rules 
path panth format allow negative premises predicates 
definition path format tss path format panth format positive 
tss format panth format transition rules contain predicates 
tss format path 
tss format source rule contains exactly function symbol 
theorem tss complete panth bisimulation equivalence congruence respect lts associated 
interested reader referred proof thm 

groote vaandrager ll string examples tsss show syntactic requirements panth format essential congruence result thin 

give example show restriction thin 
complete tsss essential 
particular relaxed tsss exactly necessarily valued stable model contain unknown transitions 
example derived ex 

example signature consist constants unary function symbol predicates 
consider tss panth format xp xp valued stable model contains unknown transi tions tss complete 
tss valued stable model set unknown transitions empty ap bp true transitions 

respect valued stable model 
van de generalized format absence predicates negative premises stalk format somewhat relaxing constraint sources transition rules contain function symbol 
proved congruence result thm 
holds stalk format 
apply congruence theorem panth format running examples sect 

basic process algebra example transition rule tss bpae table panth 
sequential composition panth right hand side premise single variable source contains function symbol sequential composition variables right hand side premise source distinct 
left reader verify remaining transition rules table panth 
tss bpae positive complete 
tss panth complete thm 
says bisimulation equivalence congruence respect bpae 
priorities hard check tss bpae table panth 
furthermore noted sect 
tss bpae complete 
thm 
bisimulation equivalence congruence respect bpae 
discrete time hard check tss bpae dt table panth 
furthermore noted sect 
tss bpae dt complete 
thm 
bisimulation equivalence congruence respect bpae dr ntree format section result effect tss panth format exists equivalent tss restrictive ntree format 
terminology originates 
definition variable dependency graph variable dependency graph set premises directed graph set variables vertices edges set occurs founded backward chain edges variable dependency graph finite 
transition rule pure set premises founded variable rule occurs source right hand side positive premise 
typical examples sets premises founded yl yl yi yi 
definition ntree format transition rule ntree format satisfies criteria 
panth 
pure 
left hand sides positive premises single variables 
tss ntree format consists ntree rules 
example tsss bpae bpae bpae dt sect 
ntree format 
theorem originates 
theorem tss panth format exists tss ntree format closed transition rule contains negative literals de simone format de simone language consists signature tss transition rules de simone format extended transition rules recursion 
process description languages encountered literature including ccs sccs csp acp meije de simone languages 
de simone languages consistency subsequent developments various definitions de simone languages literature adopt vaandrager 
definition de simone format signature 
transition rule de simone format form xl ar variables xi yi distinct variables occur target contain variables xi multiple occurrences variables 
say type action conjunction signature assume countably infinite set recursion variables ranged recursive terms bnf grammar tl tar fix recursion variable function symbol fix binding construct 
construct gives rise usual notions free bound recursion variables recursive terms 
denote recursive term occurrence recursion variable replaced possibly renaming bound recursion variables 
recursive term fix action introduce transition rule reader referred sect 
formal treatment transition rules incorporate binding constructs 
de simone language set de simone rules extended transition rules recursion 
de simone original definition rule format cf 
del transition rules carried side conditions pr pr predicate actions confused predicates states allowed ltss 
particular syntax predicates considered de simone natural computability restrictions imposed allowed sets tuples 
subsequent literature rule formats transition rules abstracted predicates 
expressiveness de simone languages main original motivation development de simone format gain insight expressive power process calculi sccs meije semantic realm ltss 
particular de simone aiming seminal papers expressive completeness result aforementioned process calculi fully justify choice basic operators developers 
motivation study foundational calculi concurrency stems milner idea proper understanding basic issues behaviour concurrent systems helpful look simple language operators combinators possible embodies distinct intuitive idea give completely general expressive power 
embarking investigation choose appropriate measure expressiveness calculus 
argued vaandrager different ways language completely general expressive power 
turing machine simulated lock step 
recursively enumerable lts specified notion behavioural equivalence 
operation natural class operations realizable means primitive operations language notion behavioural equivalence 
languages proposed literature completely expressive sense criterion offer useful means classify expressiveness languages 
meyer calls turing 
remaining criteria investi gated de simone op 
cit authors 
kind expressiveness results best knowledge developed de simone languages similar investigations lacking general rule formats 
reason rest section devoted brief review results 
results developed format instances theorems general formats survey 
question exists process description language completely expressive respect collection operations definable means de simone rules addressed authors de original 
op 
cit de simone showed result 
theorem act finite set actions 
specified de simone language containing finitely rules 
expressed bisimulation equivalence calculi sccs meije 
corollary expressiveness result pertaining class operators specifiable sccs meije de simone able prove calculi sccs meije reasonably expressive de simone languages denote recursively enumerable lts graph isomorphism 
definition properties ltss lts countably branching state countably outgoing transitions recursively enumerable exists algorithm enumerating transitions decidable exists algorithm determines transition lts computable exists algorithm computes state complete finite list outgoing transitions primitive recursive algorithm primitive recursive 
note computable stronger requirement decidable finitely branching cf 
def 

result thin 

theorem recursively enumerable lts realized recursive term sccs meije graph isomorphism 
variations thm 
literature 
stating results need introduce preliminary definitions 
definition testing arguments assume de simone language 
function symbol tests ith argument de simone rules source xx premise xi yi 
definition assume de simone language 
recursive terms sets unguarded recursion variables defined tl tar til ju tik fix 
tests arguments il ik recursive term guarded subterm fix 
particular function symbol tests arguments owing second clause def 
recursion variable unguarded recursive term form tx tar 
guarded recursive specifications de simone language unique solutions bisimulation equivalence 
guarded recursive term free recursion variables recursive terms free recursion variables 
cf 
sect 

interesting proof thm 
essential unguarded recursive terms sccs meije cf 
detailed comments issue 
infinite summations vis unguarded recursive definitions addressed 
definition trigger rule consider de simone rule term xi source premises ixi yi 
trigger tuple lar li ai li 
say signature decidable algorithm answers input encoding function symbol inputs see 
classification de simone languages subsequent result stem 
definition properties de simone languages de simone language signature recursively enumerable decidable set de simone rules recursively enumerable bounded guarded recursion allowed type trigger set corresponding de simone rules finite effective decidable guarded recursion allowed exists total recursive function associating type trigger finite set corresponding de simone rules decidable guarded recursion allowed exists total recursive function associating type action target finite set corresponding de simone rules primitive effective primitive decidable guarded recursion allowed exists primitive recursive function associating type trigger finite set corresponding de simone rules primitive primitive decidable guarded recursion allowed primitive recursive function giving type action target finite set corresponding de simone rules 
proposition de simone language property left recursive term gives rise lts corresponding property right 
countable recursively enumerable bounded effective coeff ective primitive effective primitive countably branching recursively enumerable finitely branching computable decidable primitive primitive decidable de simone languages process algebras process algebra variant acp containing prefix multiplication lieu general sequential composition argument restricted actions relational renaming operator pr binary relation act act 
sublanguage contains functional renamings considered ccs acp standard process calculi 
exceptions csp inverse image operator standard calculus pc 
suppose act contains actions bn inert constant transition rules 
denote process consists alternative composition terms bn execute action followed action bn 
adding process special constant language yields language 
van glabbeek obtained results concerning express arbitrary de simone languages 
order state expressiveness results properties de simone languages need defined 
definition operator dependency tss 
operator de smallest transitive binary relation function symbols depends transition rule type occurring target 
definition properties de simone languages ii de simo ne language width finitary type finitely correspond ing targets de simone rule type target primitive width effective exists primitive func tion giving type finite set corresponding targets finitary function symbol depends finitely function symbols type finitely corresponding targets image finite type trigger matching set transition rules finite functional exists finite upper bound number transition rules type trigger 
language finitary behaviour recursion free term deduced considering finitely transition rules 
finitary de simone language obtained combination number de simone languages finitely transition rules trivially primitive width effective 
proposition originates 
proposition de simone language satisfying certain properties left side expressible cpr corresponding features right 
finitary image finite functional primitive width effective guarded recursion image finite renaming functional renaming recursively enumerable primitive effective follows superscripts 
superscript denotes recursively enumerable version language version cludes partial recursive communication function see sect 
details 
superscript denotes primitive effective version language see def 
details 
prop 
establishes ex results 
virtually de simone languages encountered practice finitary significant results 

finitary de simone language expressible guarded recursion 

finitary image finite de simone language expressible guarded recursion image finite renamings 

finitary functional de simone language expressible guarded recursion 

finitary recursively enumerable de simone language expressible guarded recursion 

finitary recursively enumerable image finite de simone language expressible guarded recursion image finite renamings 

finitary recursively enumerable functional de simone language expressible guarded recursion 

finitary primitive effective de simone language expressible guarded recursion 

finitary primitive effective functional de simone language ex guarded recursion 
result list generalizes original theorem de simone saying finitary recursively enumerable de simone language recursion expressible recursively enumerable version meije recursion 
generalization assumption source languages guarded recursion target language required guarded recursion 
constant yields stronger result recursively enumerable de simone languages viz 
requiring 
result effective counterpart 
theorem assume recursively enumerable de simone language closed recursive term lts associated bisimilar closed guarded recursive term lts associated cpu 
csp sccs meije specify infinitely branching processes 
csp uses inverse image operation similar relational renaming operator 
result effect process algebra csp completely expressive respect operations definable de simone rules stems 
theorem assume de simone language closed recursive term lts associated bisimilar closed csp term lts associated csp 
interested reader find expressiveness results variations de simone languages notions expressiveness 
gsos format section introduces thoroughly studied rule formats viz 
gsos format bloom meyer 
results developed rule format focusing sanity properties connections axiomatizations modulo bisimulation equivalence 
gsos languages definition gsos format transition rule gsos format form xi yij xl mi ni variables xi yij distinct variables occur finitary gsos language finite set gsos rules finite signature finite set act actions 
de simone rule gsos rule 
de simone rules gsos rules allow negative premises multiple occurrences variables left hand sides premises target 
example gsos rule negative premises second transition rule priority operator see table sect 

actions supremum respect ordering act second transition rule contains negative premises 
priority operator expressed bisimulation equivalence de simone rules 
preserve trace equivalence cf 
def 
operator expressible de simone rules cf 
thm 

example bq trace equivalent notable example gsos rule uses variable left hand side premise target transition rule binary star 
operator studied realm process algebra see chapter issue 
gsos language allows stratification cf 
def 
complete cf 
def 

ltss associated gsos languages computable cf 
def 
finitely branching cf 
def 

contrast exist tsss format cf 
def 
consisting finitely transition rules finitely premises sociated ltss computable see finitely branching see 
straightforward associate ltss gsos languages recursion see 
solution problem involving special divergence predicate discussed sect 

junk rules definition gsos language exclude junk rules transition rules support transitions associated lts 
example transition rule contradictory premises closed substitution premises hold 
furthermore seemingly innocuous transition rule support transition associated lts contain 
unpublished result aceto bloom effect decidable transition rule gsos language junk 
decision procedure rule allows language designer check transition rules describing language features 
result appeared literature proof 
theorem decidable transition rule gsos language junk 
proof denote signature 
hard determine gsos rules junk computed set initials initials recall sect 
initials denotes 
premises gsos rule del satisfiable iff exist closed terms tl tar aij mi initials ti bik ni initials ti 
left give effective way computing set initials gsos language 
note function symbol determines computable function 
act iff exists gsos rule del wih action ha 
ana ow le act ca effectively computed implies se initials computed dividing ino ses ui ha contain han symbols computing nondecreasing sequence initials initials 
obviously sequence finite number seps act se initials suppose wan compute initials ui ha initials ui 
claim ha initials ui initials ui 
fac erm ui gi ui 
know initials gi ha exactly wha needed determine rule premises hold 
compute initials initials ui computed rom initials ui monotonic effective operation ear junk rules removed gsos language altering associated lts 
note legitimate eliminate junk rules 
pl junk rules si junk gsos language obtained removing wo gsos languages associated wih lts 
ll lk coding universal counter machine despite finiteness restrictions imposed gsos languages turing powerful model computation 
exhibit gsos language term cmn behaves universal counter machine input cm iff counter machine diverges input prototypical undecidable problem 
suppose counter machine code form goto dec goto halt assume toy process algebra containing inactive constant unary prefix multiplication operators zero 
succ 
act succ zero 
exhibit behaviour transition rules 
transition rules prefix multiplication cc cc intuitively succ zero represent successor function zero counters natural number encoded term zero 
succ denotes nestings prefix multiplication function succ 
closed term codes codes 
codes iff 
action pulse emitted process performs computation step 
syntax contains binary function symbols ll 
lk code states counter machine li zero zero codes machine label li counters transition rules function symbols follows 
ith instruction form goto lj cc li lj zero li li cc ith instruction goto lj tj ith instruction nc li li cc ith instruction dec zero xl li li cc xt li li commands deal counter similar 
transition rules labels halt commands cause automaton halt 
define cmn ll zero 
zero 

reader find hard see cmn iff universal machine diverges input infinitary gsos languages inducing regular ltss regular ltss cf 
def 
may describe interesting concur rent systems communication protocols mutual exclusion algorithms form basis semantic automated verification tools 
subsets programming languages semantics means regular ltss principle amenable automated verification techniques interesting develop techniques check languages give rise regular ltss 
property general undecidable useful single sufficient syntactic restrictions transition rules tss ensure regularity associated lts 
saw sect 
gsos languages specify universal counter machine turing powerful 
section study infinitary version gsos languages re signature set actions transition rules temporarily relaxed countability restrictions 
restricted version infinitary gsos languages guaranteed give rise regular ltss 
definition infinitary gsos infinitary gsos language countable set gsos rules countable signature countable set actions 
order ensure associated ltss regular necessary impose restrictions class infinitary gsos languages ensuring lts finitely branching set closed terms reachable closed term finite 
recall lts associated finitary gsos language finitely branching 
infinitary gsos language ai gives rise lts infinitely branching 
definition positive trigger positive trigger gsos rule def 
tuple subsets act ei aij mi definition assume function symbol sig nature infinitary gsos language 
say bounded positive trigger corresponding set gsos rules type finite uniformly bounded exists finite upper bound number gsos rules type having positive trigger 
far know standard operations process algebras occur literature uniformly bounded 
notion bounded function symbol originally developed vaandrager de simone languages see def 
extended infinitary gsos languages 
notion uniformly bounded function symbol stems definition regular gsos language see def 

result 
proposition function symbol signature infinitary gsos language bounded associated lts finitely branching 
introduce restriction infinitary gsos languages ensure associated ltss state reach finitely states 
definition simple gsos gsos rule simple target contains function symbol 
gsos language simple transition rules rule formats similar simple gsos rules emerged researchers def 

standard operations process algebras operational semantics means simple gsos rules 
exception binary kleene star discussed sect 

exceptions ing operation early versions milner sccs studied parallel composition operation calculus 
operation gsos rules act delay operation sccs 
gsos rules parallel composition operation calculus dealing called scope extrusion see part ii take form ly denotes restriction operation calculus silent step cf 
sect 

result shown structural induction closed terms lines thm 

theorem assume simple infinitary gsos language 
function symbol signature bounded depends finitely function symbols cf 
associated lts regular 
result hold allowed gsos rules function symbol targets example shows 
example consider gsos language action constants unary function symbol transition rules note second transition rule type simple target carries function symbols 
hard see reach infinitely states fn fn fn fn fn fn 
states non bisimilar 
studied syntactic conditions de simone rules ensure associated lts regular 
identify classes behaved function symbols call non growing operations 
intuitively non growing operations function sym fed terms denoting regular ltss build regular ltss 
special class unary non growing operations transition rules form example standard process algebra operations ccs restriction renaming csp hiding 
note transition rules simple 
view thm 
function symbols infinitary gsos language means simple transition rules non growing sense 
syntactic condition establish operations non growing term rewriting techniques find called simplification ordering terms see def 

similar spirit showing linear gsos languages see def 
syntactically founded see def 
interested reader referred sect 
sect 
information 
unfortunately existence simplification ordering compatible set rewrite rules decidable finitary gsos languages 
specialized techniques show certain closed terms reach finitely closed terms proposed ccs related languages 
interested reader invited consult 
surprisingly specialized meth ods tend powerful general syntactic ones rely language dependent semantic information 
instance method check regularity large set ccs terms interpretation techniques see proposed 
turning rules equations methods specifying verifying processes behaviour modal formulae variants hoare logic 
fairly successful verification technique approximate specification necessarily implementable term process algebra 
set ting set axioms applied try show term behaviourally equivalent sense suitable approximation required specification 
major schools theoretical concurrency applications acp takes notion behavioural equivalence primary defines operational semantics fit axioms 
logic programs complete relative programming language true formulas language provable logic 
properties interest generally non recursive obliged infinitary non recursive rules logics achieve completeness 
section presents results offer algorithmic lution problem computing sound complete axiomatization possibly including infinitary conditional axiom gsos language modulo bisimulation equivalence 
closed terms equated axiom system iff bisimilar associated lts cf 
def 

procedure introduces fresh function symbols needed 
completeness results axiomatizations standard cases 
generalization extant completeness results shows principle burden completely removed gives gsos rules process algebra 
course mean specific process algebras 
instance may possible eliminate auxiliary function symbols see example section infinitary conditional axiom 
interested reader find results complete axiomatizations behavioural equivalences process algebras handbook 
define gsos language fragment ccs suitable expressing finite ltss cf 
def 

signature frq re consists constant denoting inactive process binary alternative composition chooses non deterministically unary prefix multiplication act executes action behaves constant exhibit behaviour consequently transition rules 
transition rules alternative composition prefix multiplication formulated earlier chapter see table sect 
sect 
respectively 
process algebras contain function symbols directly derived operations 
completeness result cf 
def 
known 
proposition denote axiomatization sound complete modulo bisimulation equivalence induced show find gsos language extending axiomatization extending sound complete modulo bisimulation equivalence 
closed terms states lts associated tiff equated moller shown bisimulation equivalence subset ccs interleaving operation ii defined gsos completely characterized finite unconditional axiomatization language 
algorithm produce may require addition auxiliary function symbols signature gsos rules auxiliary function symbols start typical example way completeness result prop 

example consider gsos language tol obtained extending signature unary function symbols finite set actions adding transition rules ok words process behaves actions move 
note different ccs restriction operation ccs restriction persistent disappears transition 
result proof may corollary thm 
completeness axiomatizations extended signatures blueprint developments follow 
idea axioms completeness problem super language reduced completeness problem solved prop 

proposition axiomatization extends axioms ob ob ob ob ob ok sound complete modulo bisimulation equivalence induced 
prop 
follows thm 
owing observations tol operational conservative extension cf 
def 
ree follows thin 
sound extended signature re complete mq prop 
closed term extended signature equated closed term mq means axiomatization 
approach yielded sound complete axiomatization modulo bisimulation equivalence generalized arbitrary gsos sss 
want find axioms top mq sss allow eliminate extra function symbols closed terms 
requires variety methods prop 
plays important role operator encode negative premises 
notion needed presenting main result automatic generation axiomatizations modulo bisimulation equivalence gsos languages 
definition disjoint extension gsos language disjoint extension gsos language signature transition rules include types transition rules signature 
note disjoint extension partial order 
extends operational conservative extension see def 

follows immediately thm 
owing fact gsos rules default source dependent cf 
def 
def 
sources transition rules fresh 
presenting main results need discuss subtlety 
want know axioms re sound modulo bisimulation equivalence induced disjoint extension mq 
general case validity axioms preserved disjoint extensions 
instance consider trivial gsos language tl consisting constant transition rules 
axiom sound modulo bisimulation equivalence induced tl clearly law sound modulo bisimulation equivalence induced disjoint extension 
fortunately soundness axioms axioms needed developments preserved disjoint extensions tee 
semantically founded gsos languages start generation sound complete axiomatizations modulo bisimulation equivalence limited class semantically founded gsos languages generating finite ltss cf 
def 

languages infinitary conditional axioms 
definition semantic foundedness gsos language se founded associated lts finite 
class semantically founded gsos languages contains finite alphabet sublanguages standard process algebras 
algorithm disjoint extension constructs disjoint extension tol finite unconditional axiomatization sound modulo bisimulation equivalence induced closed term signature equated closed term form tl tn empty sum represents 
semantically founded gsos languages pos sible iterate reduction finite number times eliminating function symbols completeness proof tol reduces completeness respect completeness re respect solved prop 

obtain result 
theorem algorithm gsos language semantically founded disjoint extension sse con structs disjoint extension tol finite unconditional axiomatization sound complete modulo bisimulation equivalence induced requirement disjoint extension necessary thm 
quoted algorithm preserve semantic foundedness 
combination semantically wellfounded gsos language general semantically founded see 
example operation process algebras parallel composition ii communication defined transition rules ii ii ii ii act 
intuitively reasonable definition parallel composition transition rules easy explain 
somewhat harder see describe equationally 
axioms clear operation ii commutative associative stopped process identity finite equational description appear 
equational characterization required additional function symbol left merge ll 
intuitively behaves move taken act left merge transition rule xll axioms ll lly axioms ll axioms form sound complete axiomatization closed terms signature modulo bisimulation equivalence 
parallel composition semantically founded gsos language disjoint extension auxiliary operator ll axioms parallel composition left merge produced algorithm mentioned thm 

fact due symmetric character parallel composition operator algorithm produces auxiliary operators ll ii ilu behaves move taken parallel composition axiomatized xll lly right merge ii expressed means left merge ii 
syntactic gsos languages turing powerful undecidable gsos language semantically founded 
interesting subclass gsos languages exist effective syntactic constraints gsos rules ensure semantic 
definition linear gsos gsos rule linear variable occurs target argument tested positively cf 
xi occur target yij 
gsos language linear transition rules 
far know transition rules standard process algebras linear 
definition syntactic foundedness gsos language syn founded exists weight mapping function symbols natural numbers gsos rule type target positive premise adds weights function symbols tl tar tl tar proposition gsos language linear syntactically wellfounded semantically founded 
decidable gsos language syntactically founded 
general gsos languages follows recursion theoretic con discussed programming exercise sect 
extension completeness result theorem general gsos languages requires proof rules purely equational logic 
possible extend completeness result class gsos languages standard way 
bisimulation equivalence finitely branching ltss supports powerful induction principle known approximation induction principle aip 
lts associated gsos language finitely branching aip applies 
introduce family unary function symbols rn transition rules act 
function symbols known projection operators literature acp 
intuitively allows perform moves freely stops 
aip infinitary conditional axiom aip rn rn intuitively proof rule states continuity property bisimulation equivalence finitely branching ltss states bisimilar finite depth bisimilar 
projection operators somewhat heavy handed infinitely gsos languages defined finite 
possible mimic projection operators means binary function symbol intuitively closed term executes silently takes step process runs halts execution 
actions act transition rule arbitrarily chosen action 
formulation may rephrase aip follows aip ready formulate analogue thm 
gsos languages need semantically founded 
theorem algorithm gsos language con structs disjoint extension tol operation defined finite unconditional axiomatization aip gether sound complete modulo bisimulation equivalence induced term rewriting properties axiomatizations generated variations methods just surveyed studied 
proposed modification approach produces complete axiomatizations subclass de simone languages modulo refusal simulation preorder takes account silent step cf 
sect 

regular gsos languages shown subclass infinitary recursive gsos languages generating regular ltss possible obtain sound complete axiomatizations modulo bisimulation equivalence rely infinitary proof rules aip 
definition introduces class regular gsos languages considered op 
cit subclass simple infinitary gsos languages cf 
def 

definition regular gsos infinitary gsos language lar simple function symbol signature 
uniformly bounded cf 

depends finitely function symbols cf 

finite upper bound number positive premises transition rules type tsss standard process algebras literature regular 
follows immediately theory outlined sect 
regular gsos language induces regular lts 
shown reduce completeness problem regular gsos languages regular ltss solved earlier 
recall sect 
de simone languages recursive terms signature bnf grammar tl tar fix ranges countably infinite set recursion variables ranges signature fix binding construct 
construct gives rise usual notions free bound recursion variables re cursive terms 
recursive term fix transition rule fix fix consider subset guarded recursive terms cf 
def 
free recursion variables 
bisimulation equivalence guarded recursive terms com pletely axiomatized milner bergstra klop 
proof rules called recursire definition principle rdp recursire specification principle rsp play key role completeness proofs 
denote guarded recursive term free recursion variables denote guarded recursive term free recursion variables rdp fix fix rsp fix theorem algorithm regular gsos language constructs disjoint extension guarded recursive terms unconditional axiomatization rdp rsp sound complete modulo bisimulation equivalence induced algorithm proof thm 
gsos languages regular see details 
apart just reviewed automatic generation complete axiomatizations tsss received deal attention literature 
results line research may 
recursive gsos ltss divergence section considers gsos languages recursive terms cf 
sect 
previous section signature ec denote set recursive terms contain free recursion variables 
recall absence recursion gsos languages strictly stratified cf 
def 
yielding restrictive criteria mean tsss considered sect 

recursive gsos languages longer straightforward find associated lts 
section shown problem overcome special divergence predicate definition ltss 
interested reader referred motivation information variations semantic model reactive systems 
definition lts divergence lts divergence lts sense predicates divergence predicate convergence predicate 
shown recursive gsos language specifies lts divergence 
recursive gsos languages considered op 
cit 
contain special constant akin constant ccs transition rules type fl difference denotes convergent process transitions stands divergent stopped process 
transition rules recursive gsos language define diver gence specification predicate 
fact common practice literature process algebras define notion convergence define divergence predicate 
definition convergence assume recursive gsos language signature convergence predicate defined predicate set closed recursive terms crc satisfies clauses 
tl tar argument tests cf 
ti 
fix fix 
write case 
motivation definition term divergent initial transitions fully specified 
occurs initial behaviour term depends specified arguments presence unguarded recursive definitions cf 
def 

example terms fix fix convergent initial behaviours terms depend 
applied sccs version ccs considered definition delivers exactly convergence predicates hennessy walker respectively 
hint lts divergence associated re cursive gsos language interested reader referred full technical details 
want lts divergence supported model sense del 
reminiscent positive tsss want associate lts recursive gsos language question 
described possible ab divergence 
extra structure convergence predicate put giving simple way constructing desired lts divergence steps 
transitions emanating convergent terms derived induction convergence predicate 
done standard approach gsos languages outlined sect 
transition rule recursion derive transitions recursive terms 
information transitions possible convergent terms de termine outgoing transitions terms 
key point construction associated lts negative premises satisfied convergent terms 
intuitively know closed term initially perform action need find precisely initial actions perform 
closed term divergent set initial actions fully specified sure term satisfies negative premise 
reader familiar literature hennessy milner logics cf 
def 
relations cf 
def 
follow may noticed notion satisfaction negative premises discussed akin formulae form 
new interpretation necessary obtain mono satisfaction relation respect appropriate notion 
intuitionistic interpretation negative premises crucial obtain operations monotonic respect notion def 

basically ensures closed term transition formula holds iff holds closed term result details construction desired lts divergence may 
proposition recursive gsos language inert constant exists sound supported lts divergence 
example consider term fix odd unary function symbol odd defined transition rule odd operation standard example literature show negative premises unguarded recursive definitions lead tent specifications see 
reason phenomenon follow standard gsos approach recursive equation odd solution modulo bisimulation equivalence 
fact standard operational interpretation gsos languages general tsss negative premises term solving recursive equation mod bisimulation equivalence odd exhibit initial transition iff 
approach ll recursive equation unique solution modulo pre bisimulation equivalence see def 

fix odd di term 
negative premises interpreted convergent terms transition rule applied derive transition fix odd term inert constant fl unique solution odd modulo equivalence 
results gsos languages theory gsos languages rich results sample body documented literature rule format 
overview gsos languages pointers interesting results 
bloom meyer observed behaviour open term xl 
xn completely determined finite set derived transition rules form bik xi yij xi xl xn derived transition rules referred distinguish gsos rules defining operational semantics language consideration 
facilitate development theory sos 
instance simplifies proof congruence result tsss thm 
restricted case gsos languages 
result may thm 

theorem gsos language 
open term xl xn exists finite set xl xn source lts associated model cf 
def 
tl tn exists supporting transition sense def 

example consider process algebra bpa priority operator sect 

set determining operational semantics term consists second actions smaller specification languages case studies literature process algebras mechanisms define new operations terms 
formulated fresh atom principle standard practice process algebra proofs fresh con 
verhoef introduced definition principle similar rdp discussed sect 
facilitate specification new unary function symbols process algebra 
bloom cheng advocated languages enhance expressiveness ease specification languages 
intuitively writing specifications means process algebra faced choice basic operations clear semantics ad hoc operations simplify writing specifications enhance readability complicate reasoning resulting high level description behaviour 
aforementioned argues sos combined theory overview enables systematic extension process algebras way guaranteed preserve semantic properties original language 
compositional proof systems hml proof systems modal log ics enable give formal proofs states ltss satisfy certain requirements 
desirable feature proof systems allow compositional style proof development 
informally proof system compositional builds proof property lts proofs properties certain sub ltss 
realization context pure order logic issue compositionality addressed gentzen sequent calculus 
compositionality obtained cut elimination 
simpson developed sequent cal showing closed terms process algebra operational semantics specified gsos format satisfy assertions modal logic hml see sect 

process algebras provide interesting examples known difficulties giving proof rules flavours parallel composition 
usual benefit working arbitrary gsos language obtains generic proof system applicable wide class process algebras 
binary decision diagrams gsos languages binary decision diagrams widely represent ltss symbolically second generation verification tools concurrent processes see lans textbook model checker smv 
binary decision diagram application generated lts closed terms process calculus turn generated transition rules defining operational semantics calculus 
step approach avoided direct construction binary decision diagram transition rules 
approach followed gsos languages 
results op 
cit 
suggest general procedure yields binary decision diagrams comparable quality generated specific process calculi ad hoc methods cf 
rbb safe format order away internal actions milner introduced special action called silent step 
relation symbol represents internal computation 
number equivalence notions developed identify states ltss incorporate silent steps weak bisimulation branching bisimulation 
rule formats introduced ensure weak branching bisimulation equivalence congruence cf 
def 

general equivalences congruence respect process algebras pre emptive power silent steps see sect 
intuitive discussion phenomenon 
reason standard practice impose condition equivalences silent step 
bloom rule format ensure rooted branching bisimulation congruence imposing additional requirements gsos format 
rule format recognizes called patience rules closed term inherit transitions arguments 
rbb safe format relaxes syntactic restrictions bloom rule format im posing additional requirements panth format 
notably certain arguments function symbols labelled labelling restrict occurrences variables targets left hand sides premises 
tss complete cf 
def 
satisfies syntactic restrictions rbb safe format rooted branching bisimulation respect associated lts congruence 
rooted branching bisimulation assume act extended special action representing silent step 
reflexive transitive closure relation denoted 
define notion branching bisimulation 
definition branching bisimulation assume lts 
binary relation states branching bisimulation symmetric sl sl 
ands 
transitions sip transitions sp states branching bisimilar written exists branching bisimulation relation relates 
branching bisimulation equivalence relation see 
branch ing bisimulation equivalence congruence respect stan dard operations process algebras 
example bpae see sect 
constants branching bisimilar 
introduce condition 
definition rooted branching bisimulation assume lts 
binary relation states rooted branching bisimulation symmetric transition sip 
states sl rooted branching bisimilar written sl ro exists rooted branching bisimulation relation relates 
branching bisimulation equivalence relation easy see rooted branching bisimulation equivalence relation 
rbb safe proceed congruence format rooted branch ing bisimulation equivalence 
denote context viz 
term occurrence context symbol cf 
sect 

assume argument function symbol labelled frozen liquid 
context liquid context symbol occurs inside nested string liquid arguments 
definition liquid context set liquid contexts sig nature defined inductively 
liquid 
liquid argument function symbol liquid tl 
ti ti 
tar liquid 
patience rule argument function symbol implies closed term tl tar inherits transitions argument ti 
definition patience rule patience rule ith argument function symbol gsos rule form xi xl xl xi xi position rbb safe format imposes additional restrictions panth format cf 
def 

definition rbb safe tss panth format rbb safe exists frozen liquid labelling arguments function symbols transition rules 
patience rule liquid argument function symbol 
rule source xl require ments fulfilled right hand sides positive premises occur left hand sides premises argument liquid patience rule xi occur left hand sides premises argument liquid patience rule xi occurs left hand side premise premise positive contain relation symbol left hand side xi right hand sides positive premises variables xi liquid argument occur liquid positions target theorem complete tss rbb safe rooted branching bisimulation equivalence induces congruence 
see string examples complete tsss show syntactic requirements rbb safe format essential congruence result thm 

computation frozen liquid labels crux determining tss rbb safe find suitable frozen liquid labelling arguments function symbols 
assuming signature exists efficient procedure computes frozen liquid labelling witnessing rbb safe labelling exists 
procedure compute liquid labels red green directed graph consists vertices ar 
edge iff transition rule form xl tl tj xi tj tar vertex red iff transition rule target form tl 
tj ld tj 
tar right hand side positive premise rule 
vertices coloured green 
procedure turns green vertices red follows 
vertex red exists edge green vertex coloured red 
procedure terminates green vertices coloured red anymore point outputs red green directed graph 
labels argument function symbol liquid iff vertex output graph procedure red 
proceed apply thm 
tsss sect 
extended silent step 
bpa empty process silent step process algebra bpae obtained bpae extending act silent step 
tss bpae tss bpae table proviso ranges act 
noted sect 
tss table panth 
procedure calculate frozen liquid labelling tss produces result argument sequential composition liquid target third transition rule sequential composition arguments alternative composition second argument sequential composition frozen 
tss table ranging act rbb safe respect frozen liquid labelling 
example sequential composition third transition rule constitutes patience rule argument sequential composition transition rules third transition rule variable liquid argument source occurs left hand side positive premise contain relation symbol third transition rule variable right hand side premise occurs liquid position target 
left reader verify remaining transition rules table rbb safe 
proven sect 
tss table complete 
thm 
rooted branching bisimulation equivalence congruence respect bpae 
priorities silent step general rooted branching bisimulation equivalence congruence respect priority operator 
example suppose rooted branching rooted branching bisimilar 
consequently view thm 
tss bpae table ranging act rbb safe format 
second transition rule table target procedure sect 
labels argument liquid 
assuming actions greater action respect ordering act liquid argument source transition rule occurs left hand side negative premises 
violates rbb safe format 
precongruence formats behavioural preorders literature sos particularly rich results pre congruence formats behavioural equivalences preorders absence predicates 
section presents precongruence formats simulation ready simulation decorated trace preorders accepting trace preorder trace preorder 
vaandrager showed de simone format constitutes precongruence format external trace external failure preorders 
note preorder precongruence kernel congruence 
simulation path cf 
def 
precongruence format simulation preorder cf 
del 
van glabbeek path congruence format nested simulation equivalences 
theorem tss path format simulation preorder induces precongruence 
example tss bpae sect 
path format thm 
implies simulation preorder precongruence respect bpae 
ready simulation precongruence format ready simulation preorder cf 
def 
ob tained disallowing ook panth rules 
definition look ahead transition rule look ahead variables occurring right hand sides positive premises occur left hand sides premises 
definition ready simulation format panth rule ready simulation look ahead 
tss ready simulation format transition rules 
theorem complete tss ready simulation format ready simulation preorder induces precongruence 
example tss bpae sect 
positive complete 
furthermore path format transition rules contains look ahead 
thm 
implies ready simulation preorder precongruence respect bpae 
counter example shows omission look ahead ready simulation format essential 
example act unary function symbol 
extend tss bpae note premises second transition rule contain look ahead 
clearly ready simulation equivalent 
ready simulation equivalent 
transition simulated initial transitions 
decorated traces section presents precongruence formats ready trace failure trace failures preorder cf 
def 

formats re notion liquid context cf 
def 
obtained careful study modal characterizations preorders question 
ready trace failures formats generalize earlier formats van glabbeek bloom de simone respectively 
van glabbeek sketched congruence format failures equivalence format flawed 
definition rule transition rule right hand sides positive premises variables distinct occur source 
definition propagation polling occurrence variable rule propagated occurrence target left hand side positive premise right hand side occurs target 
occurrence variable rule polled occurrence left hand side premise right hand side occurring target 
intuitively precongruence formats decorated trace preorders operate keeping track variables represent running processes 
example semantically reasonable copy process starts 
copying running process give information branching structure process incompatible form decorated trace semantics 
floating variable may represent running process 
notion assumes predicate arguments function symbols say argument liquid frozen cf 
sect 

definition floating variable variable rule float ing occurs right hand side positive premise occurs exactly source liquid position cf 
def 

definition decorated trace safe predicate arguments function symbols 
rule ready trace safe look ahead cf 
def 
floating variable propagated liquid posi tion 
rule safe ready trace safe floating variable propagated polled 
rule failure trace safe safe floating variable polled liquid position positive premise 
second restriction ready trace safe guarantees running process copied continued marked running executed 
safe restriction ensures execution running process tested multiple times 
failure trace safe restriction limits positive test single action predicate 
definition decorated trace formats tss ready trace format format rules ready trace safe respect tss format format rules safe respect tss failure trace format format rules failure trace safe respect theorem tss ready trace format ready trace preorder induces precongruence 
theorem tss format preorder induces precongruence 
theorem tss failure trace format failure trace failure preorders induces 
accepting traces similar rbb safe format precongruence format accepting trace preorder cf 
def 
frozen liquid labelling arguments function symbols 
definition cool tss path format cool exists frozen liquid labelling arguments function symbols transition rules satisfies syntactic restrictions variable occurs liquid argument source right hand side premise occurs exactly left hand side premise liquid position see def 

target variable dependency graph see def 

set premises contain infinite forward chain edges 
theorem tss cool format accepting trace preorder induces precongruence 
counter example shows cool format allow infinite forward chain edges variable dependency graph premises transition rule 
example act ta unary function symbol constants 
consider tss xi xo note edges xi xi variable dependency graph premises second transition rule form infinite forward chain 
terms accepting trace equivalent accepting traces 
accepting trace equivalent accepting empty trace accepting traces 
see examples tsss showing syntactic require ments cool format essential precongruence result thm 

similar procedure rbb safe format sect 
exists ecient procedure compute frozen liquid labelling witnessing cool labelling exists see 
example tss bpae sect 
path format transition rule variable dependency graph premises contain infinite forward chain edges 
take argument sequential composition liquid arguments alternative composition second argument sequential composition frozen 
hard see tss bpae variable occurs liquid argument source right hand side premise transition rule occurs exactly left hand side premise liquid position target transition rule 
thm 
implies accepting trace preorder precongruence respect bpae 
traces bloom formulated congruence format trace equivalence cf 
del generalizing earlier precongruence format trace preorder 
definition trace format finite tss format cf 
def 
trace format transition rule satisfies tions contains finitely premises variable occurs right hand side premise source variable occurs left hand sides premises target 
theorem tss trace format trace equivalence induces congruence 
definition completed trace equivalence cf 
def 
closely related accepting trace equivalence cool trace formats constitute congruence formats completed trace equivalence 
counter example featuring encapsulation operator shows really hope formulate general congruence format completed trace equivalence see 
example act add unary encapsulation operator bpae 
lts term obtained lts excluding transitions 
expressed transition rules added tss bpae clearly completed trace equivalent 
oc oc completed trace equivalent completed trace 
trace congruences original aims development theory gsos languages characterize observational congruence induced reasonable notion ccs operations assumption directly observe behaviour process set completed traces see def 
definition completed trace equivalence 
intuitively closed terms completed trace congruent respect tss context completed traces associated lts coincide 
proceed formulate notion completed trace congruence induced rule format 
definition completed trace congruence rule mat tss format signature closed terms completed trace congruent respect notation ct tss format signature added operationally conservative fashion cf 
def 
context lts associated yields ct bloom meyer characterized completed trace ence induced gsos format terms equivalence corresponding sublanguage modal logic hml cf 
def 

definition denial formula set denial formulae act bnf grammar act true true particular state satisfies formula true iff initial actions 
equivalence relation defined states ltss similar fashion equivalence relation hml see sect 
iff denial formulae theorem gsos language 
equivalence relation induced lts associated coincides completed trace congruence gsos respect gsos format 
ct interested reader referred 
cit 
proofs result discussion 
limit remarking surprisingly negative premises add discriminating power gsos format 
fact gsos operators aforementioned testing denial formulae negative premises 
copying premises transition rules minimal 
reader recall negative premises coding universal counter machine sect 

larsen skou gave characterization denial equiv provides additional insight behavioural nature completed trace congruences induced gsos languages 
theorem finitely branching lts cf 
def 
states ready simulation equivalent cf 
def 
iff satisfy exactly denial formulae 
gsos completed trace congruence equivalence induced ready simulation preorder prompted authors coin slogan bisimulation traced 
result due groote shows bisimulation equivalence traced provided power negative premises offered pure format cf 
def 
def 
available 
theorem assume tss cf 
def 
pure format containing constant signature 
pair closed terms pure ct tt hml tt 
view thm 
means completed trace congruence induced pure format coincides bisimulation equivalence lts associated tss question finitely branching 
negative premises appears necessary order test bisimulation equivalence 
groote vaandrager characterized completed trace congruence induced format 
theorem assume tss pure format associated lts finitely branching 
pair closed terms pure ct nested simulation equivalent refer interested reader op 
cit 
chapter issue definition nested simulation equivalence details completed trace congruences 
sorted higher order languages section presents formal framework describe tsss style plotkin allowing express general binding mechanisms substitutions 
variable binding mechanisms widely sos semantics concurrent functional programming languages calculus value passing process algebras process algebras recursion timed process algebra 
see collection articles re cent developments operational semantics higher order programming languages 
concepts setting operational semantics variable binding intuitively clear sight turn ambiguous studied carefully 
order obtain formal framework transition rules variable binding mechanism expressed rigorously distinguish actual formal variables conventions programming languages formalize bind ing construct transition rules 
programming languages actual parameters formal parameters 
formal parameters define procedures functions actual parameters real variables main program 
main program formal parameters bound actual parameters 
discussing procedures conceptual level useful introduce notational distinction formal actual parameters see instance 
transition rule thought procedure establish transition relation means substituting actual terms formal variables 
example illustrates useful notational dis actual formal variables 
example consider transition rule dp variables standard notation binds replaces application substitution transition rule yields example highlights matters 

expression substitution equal syntactic construct suggestive form called harness 
application substitution result evaluated term 

substitutions apply part variables occur transition rule 
order distinguish variables transition rule marked asterisk 
transition rule takes form formal variables sos variable binding proposed 
organization section follows 
sect 
introduces actual terms sect 
introduces formal terms 
sect 
describes framework sorted higher order sos definitions 
sect 
explains operational conservative extension format thm 
carries higher order setting 
binding mechanisms exist diverse forms 
mech described notational approach nuprl proof development system 
alternative formalism course calculus 
actual world assume set sorts countably infinite set vat sorted actual variables 
actual world contains actual terms actual tions forth 
denote sequence ok sequence oil definition sorted higher order signature sorted higher order signature set function symbols oq ar qij si sorts 
intuitive idea embodied definition function symbol denotes operation takes functions type si arguments delivers result sort 
definition actual term sorted higher order signature 
collection actual terms set satisfying actual variable vat function symbol ql ar ex pression tx ar tar actual term sort ti actual terms sort sequence consists distinct actual variables vat sorts gi 
free occurrences actual variables actual terms defined inductively expected occurs free occurs free ti occur sequence occurs free ar tar actual term closed contain free occurrences actual variables 
actual substitution sort preserving mapping sort preserving means sort 
actual substitution extends mapping actual terms actual terms actual term obtained replacing free occurrences actual variables 
usual postfix notation actual substitution maps inert 
postfix denoted actual substitutions called explicit opposed implicit actual substitutions definition actual substitutions actual terms known complication 
consider actual term occur free replaced actual variables occur bound actual subterms solution problem originates calculus allow unrestricted substitution applying conversion renaming bound actual variables 
actual terms considered modulo conversion actual substitution applied bound actual variables re named 
stoughton clean treatment technique 
formal world argued idea distinguish formal actual variables discussing transition rules variable bindings sub level 
formal term actual term possible occurrences formal variables substitution harnesses 
assume sorted higher order signature set var variables defined var sort 
definition formal term collection formal terms sorted higher order signature set satisfying actual variable vat formal variable vat function symbol ar sar ex pression ar formal term sort 
formal terms sort si consists distinct actual variables vat sorts formal terms sorts respectively vat sort formal term sort 
formal substitution sort preserving mapping rr vat 
extends mapping actual term obtained formal term follows 
replace formal variable 
substitution harnesses explicit actual substitutions result evaluates actual term 
example example formal term evaluates actual constant application formal substitution implicit formal substitution turns substitution harness actual term explicit actual substitution evaluates summarize various notions substitutions briefly discuss differences 
notions worlds implicit explicit actual substitutions semantically formal substitutions substitution harnesses 
implicit actual substitutions rr explicit actual substitutions denote mappings actual variables actual terms 
formal substitutions rr mappings formal variables actual terms 
substitution harness substitution piece syntax suggestive form 
formal substitution applied result expression containing explicit actual substitution evaluated actual term 
substitution harnesses formulate precise way formal substitution act transition rule 
formal actual tions move transition rules proof tree cf 
def 

actual formal transition rules presenting basic definitions sos higher order languages consider example recursive construct combines formal variables binding mechanism substitution harness 
operator similar construct fix incorporated de simone languages cf 
sect 

example intuitively closed actual term tx executes encounters expression case starts executing tx 
intuition expressed transition rule call rule transition prefix multiplication operator ccs derived rule standard tran sition rule prefix multiplication ola cf 
sect 

application formal substitution rule premise takes form evaluates instance tran sition rule prefix multiplication conclude instantiation rule valid proof depicted 
instance prefixing rule tx tx tx tx instance rule definition actual transition rule actual transition rule expression form set literals cf 
positive literal 
actual transition rules deduced means transition rules 
formal transition rules ones literature recipes enable deduce lts 
instance example actual transition rule tx tx tx tx deduced rule formal transition rule 
definition formal transition rule formal transition rule expression set premises form form act denotes predicate 
higher order tss set formal transition rules 
operational conservative extension rule formats higher order languages appeared liter 
sands introduced format sos specifications functional languages established proof principles sound languages expressible format 
howe ence format higher order tsss respect bisimulation equivalence shows strong resemblance format groote vaandrager cf 
def 

rensink obtained congruence results extensions equivalence open terms presence recursion 
interestingly bernstein showed cases semantics higher order language captured order tss terms transition labels 
appears existing rule formats extended terms transition labels straightforward manner see 
case current order rule formats sufficient deal higher order languages 
interest bloom bloom proposed general definition higher order process calculi investigated basic properties 
gave sufficient conditions calculus finitely branching effective showed suitable notion higher order bisimulation congruence subclass higher order calculi 
proceed generalization operational conservative extension format see sect 
higher order setting 
generalization adaptation notion source dependency cf 
def 
requiring distinction occurrences formal variables outside substitution harnesses formal term 
fv denotes set formal variables occur formal term 
definition set fv sets fv defined inductively fv 
vv fv example fv ix 
contrast ev denotes restricted set formal variables formal term take account formal variables occur inside substitution harness 
definition set ev sets ev defined inductively 
ar tr ue 
example ev 
sets fv ev definition source dependent variables formal transition rule 
definition source dependency formal transition rule formal variables source dependent defined inductively 
source formal variables ev 
premise formal variables fv source dependent formal variables ev source dependent 
formal transition rule source dependent variables fv 
thm 
formulates sucient criteria higher order tss tot operational conservative extension see del extends thin 
higher order languages 
say formal term fresh contains function symbol outside substitution harnesses 
similarly action predicate symbol fresh occur 
theorem higher order tsss sorted higherorder signatures respectively 
conditions operational conservative extension 

source dependent 

source fresh premise form tip fv denotes source fresh 
theorem applied extensions higher order tsss process algebra time data binding constructs enable parameterize processes time data domain process algebra recursive operator construct calculus lazy calculus 
denotational semantics bias operational methods process theory dates back original development theory ccs field meta theory process description languages reported chapter concerned operational axiomatic semantics terms relationships 
particular clear possible automatically translate operational theory processes axiomatic 
certain stances possible derive sos semantics axiomatic witnessed developments 
axiomatic semantics proof systems programming specification languages closely related denotational semantics particularly scott strachey approach followed 
paradigmatic example development semantic theory processes operational axiomatic denotational semantics coexist may highlight different aspects process behaviours ory testing equivalence developed de nicola hennessy 
theory process characterized operationally means reaction experiments denotationally acceptance tree 
ac trees allow fully describe behaviour process abstracting away operational details interactions possible testers 
domain theoretic properties model allow establish properties behavioural semantics derive purely operational methods see results sect 

mind coincidence operational axiomatic semantics enjoyed theory processes reinforce chosen notion program semantics allows complementary benefits afforded semantic descriptions establishing properties processes 
developing views processes process description language scratch proving coincidence hard subtle addition quote giving denotational semantics programming languages scott strachey approach involves mathematical weapons unfamiliar computer science 
beneficial develop systematic ways giving denotational semantics process description languages scott strachey approach starting sos descriptions 
course worthwhile denotational semantics produced pro posed techniques automatically guaranteed agreement behavioural axiomatic views processes 
particular generate denotational semantics matches exactly operational intuition process behaviour sense milner plotkin respect reasonable notion behavioural semantics 
section reviews results shown gen erate fully denotational semantics class recursive gsos languages cf 
sect 

usually denotational semantics deals recur sion implicitly setting framework reasoning recursion reduced reasoning recursion free approximations 
line approach denotational semantics terms gsos languages 
recursion free approximations extend result recursive terms recursive gsos languages 
preliminaries domains assume familiarity basic notions ordered continuous see follows give quick overview way denotational semantics recursive language standard lines algebraic semantics 
interested reader invited consult explanation theory 
denote signature sense sect 
includes distinguished constant fl algebra consists carrier set function symbol operator fa 
mapping algebras homomorphism elements dx dar dl dar fb dl dar recall sect 
denotes set closed terms denote set closed terms may contain occurrences countably infinite set recursion variables ranged domain algebra carrier algebraic complete partial order cpo see operations interpreted continuous functions sense 
require viz 
element algebraic cpo notion poset resp 
preorder may defined similar way requiring partially ordered resp 
preordered set operators monotonic 
notion homomorphism extends ordered structures obvious way requiring maps preserve underlying order theoretic structure structure 
interpretation algebra associates term mapping substitutions going recursion variables 
interpretation defined induction follows mapping recursion variables 
recall recursive terms bnf grammar tl tar fix recursion variable function symbol fix binding construct 
construct gives rise usual notions free bound recursion variables recursive terms 
denotes set recursive terms contain free recursion variables 
denotes recursive term occurrence recursion variable replaced domain interpretation extends set recursive terms fix denotes fixed point operator metavariable ranging note depend follows general results semantic mappings defined may 
result states recursive term possibly containing free recursion variables sequence finite approximations tn domain interpretation term upper bound interpretations finite approximations 
second result states precongruence cf 
def 
satisfying fix fix fix fix tn binary relation algebraic part denoted defined follows ta vn tn um say algebraic equal intuitively relation algebraic completely determined behaves recursion free terms 
denotational interpretation induces preorder result characterizes class denotational interpretations induce relations terms algebraic 
lemma domain 
compact element see algebraic 
view general lemma relations recursive terms induced denotational semantics algebraic provided denotations recursion free terms compact elements algebraic cpo 
consider ltss divergence def 
include special divergence predicate convergence predicate holds state iff divergence predicate hold state cf 
def 

behavioural relation ltss divergence study section known partial bisimulation 
recall def 
proc act denote sets states actions respectively lts divergence question 
rel proc denote set binary relations proc 
definition assume lts divergence 
functional rel proc rel proc defined follows 
relation rel proc sl transition transition relation iff 
write sl exists relation preorder proc kernel denoted 
similar spirit notion bisimulation cf 
def 

intuitively behaviour specified simulate restricted part behaviour fully specified 
divergent state outgoing transition intuitively corresponds process behaviour totally unspecified essentially operational version bottom element theory domains 
precongruence result respect recursive gsos languages including inert constant originates 
proposition precongruence respect lts divergence associated recursive gsos language including inert constant cf 
prop 


finite synchronization trees useful source examples ltss divergence set finite synchronization trees 
definition finite synchronization tree set finite synchronization trees set actions act denoted st act defined 
st act 
st act st act loo 
act ql qn st act ql 
qn st act symbol represent finite synchronization tree di 
set finite synchronization trees st act turned lts divergence stipulating st act iff relating behavioural semantics bisimulation relations denotational semantics usually algebraic domains faced mismatch 
hand algebraic domain iff compact element smaller equal dominated 
hand closed terms finite approximations bisimilar 
implies bisimulation algebraic captured standard domain theoretic framework 
way address problem study finitary part 
generally agreed literature finite synchronization trees natural operational counterpart compact elements 
follows interested relating notion preorder finite synchronization trees induced denotational semantics means algebraic domain 
preorders completely determined act finite processes interested comparing finitely observable finitary part bisimulation sense ll 
definition inspired property algebraic domains 
definition finitary preorder finitary preorder lts st act general technically difficult practice try obtain alternative characterization finitary preorder see 
alternative method functional rel proc rel proc def 
obtain preorder apply inductively follows proc proc restricting relation observations finite depth 
preorders inclusions general strict 
interested reader referred wealth examples distinguishing preorders thorough analysis general relationships properties 
comparison preorders respect recursive gsos languages including inert constant originates 
proposition preorders divergence associated recursive gsos language including inert constant cf 
prop 

domain synchronization trees canonical domain give denotational semantics class recursive gsos languages domain synchronization trees countably infinite set act actions considered abramsky 
defined initial solution category sfp cf 
domain equation denotes lifting point domain model coalesced sum separated sum plotkin powerdomain construction see details domain theoretic operations 
intuitively constructs fixed point domain equation starting point domain nth iterative step building finite synchronization trees height streamline presentation away domain theoretic description domain equation 
description domain synchronization trees follows rely results showing construct starting suitable preorder set finite synchronization trees st act 
reconstruction steps 

define preorder set finite synchronization trees st act 
preorder reformulation egli milner preorder st act see prop 

relate poser compact elements poser equivalence classes induced st act 

fact ideal completion poser compact elements relate st act 
approach allows factor definition continuous algebra structure ll similar steps 
definition st preorder binary relation st act conditions satisfied 
sl th 


relation defined easily seen preorder st act 
coincides st act 
proceed relate preorder st act poset compact elements way allows define canonical way continuous operations monotonic ones st act recall isomorphism algebraic cpo poset compact elements follows 
defined inductively con con denotes convex closure operation see 
defined denotes egli milner preorder see def 

definitions follows subset st act 
sense compare relations 
result lends credence previous claims 
proposition iff consequence result ease presentation technical results follow notion preorder gsos denotational semantics characterize class gsos languages incorporating inert constant transition rules map finite ltss finite ltss cf 
def 

semantic counterparts function symbols property compact sense mapping compact elements plotkin powerdomain synchronization trees compact elements 
view lem 
denotational interpretations resulting languages induce preorders terms algebraic 
definition compact gsos gsos language including inert constant compact linear cf 
syntactically wellfounded cf 
del 
function symbol introduce mapping far mapping ar finite synchronization trees finite synchronization tree 
definition operation far assume compact gsos language consider function symbol operation far st act st act defined inductively stipulating sar st act fa iff argument tests ith argument see si fs sl sat gsos rule bik xi yij xi xl xl ma finite synchronization trees mi 
aij mi 
ni si bik si st act ni 
cst 
sat sl 
sar ma csr denotes derived semantic operation associated target gsos rule 
definition discussed length endows preorder finite synchronization trees st act preorder structure signature consideration sense 
poser compact elements domain substructure preorder st act give denotational interpretation recursion free terms compact gsos language terms compact elements 
theorem assume compact gsos language 
iff 
full abstraction result extended lan guage compact recursive gsos language 
order define interpretation programs elements need define continuous algebra structure 
theory powerdomains know main synchronization trees isomorphism ideal completion poser compact elements 
construction ideal com poser discussion basic properties 
standard set inclusion 
ideal completion monotonic function fsr ar function symbol extended continuous func tion fv fz el ear fs dl dar el dar ear el ear ideals identify element principal ideal generates see 
interested reader invited consult sect 
discussion properties afforded canonical extension 
general theory algebraic semantics closed terms view thm 
desired full abstraction result follows prove preorder algebraic 
owing constructions closed term interpreted compact element 
implies relation algebraic 
algebraic relations coincide collection closed terms fact coincide 
key proof algebraicity general theorem providing partial completeness result hennessy arbitrary compact gsos languages 
axiomatizability result uses fact lts divergence associated recursive gsos language including inert constant see prop 

proposition compact recursive gsos language 
exists compact gsos language signature disjoint extension cf 
def 
cf 
sect 

set inequalities terms induces apart intrinsic interest main consequence prop 
key result essentially stating compact gsos language finite synchronization trees compact elements respect preorder proposition assume compact gsos language 
st act result conjunction prop 
yields algebraic 
proposition algebraic lts divergence associated compact gsos language 
light thm 
prop 
compact recursive gsos language induced denotational semantics fully respect theorem assume compact recursive gsos language 
iff applied version sccs considered abramsky tech niques deliver denotational semantics exactly op 
cit 
related reported section means attempt systematically derive denotational models sos language specifications 
main precursors field metatheory process description languages may bloom rutten 
unpublished bloom gives operational logical relational denotational semantics gsos languages negative premises unguarded recursion shows coincide 
bloom behavioural tion simulation denotational semantics means scott domains finite synchronization trees 
hand rutten gives methods deriv ing denotational semantics complete metric spaces non founded sets languages specified means format cf 
def 

particular gives detailed clear technique called processes terms definition operations semantic models transition rules 
rutten general processes terms approach applied yield equivalent formulation semantic operations finite synchronization trees 
aforementioned papers generalized rutten turi 
shown tsss format induce denotational semantics es properties semantic domains definitions possible investigated categorical perspective 
abramsky vickers consider various notions process observa tions uniform algebraic framework provided theory quantales see 
methods developed yield uniform fashion observational logics denotational models notion process observation consider 
semantic nature ignores algebraic structure process expressions 
area semantics functional programs developments somewhat similar spirit 
papers study natural notions preorder programs written simple functional programming language show ordering programs certain basic properties extended term model fully respect 
issue defining mathematical models operational semantics received attention 
refer inter reader details line investigation 
abramsky domain equation bisimulation information computation pp 

abramsky hankin interpretation declarative languages ellis horwood 
abramsky vickers quantales observational logic process semantics mathematical structures computer science pp 

aceto deriving complete inference systems class gsos languages generating regular behaviours jonsson parrow pp 

gsos finite labelled transition systems theoretical cornput 
sci pp 

aceto bloom vaandrager checking equations gsos systems 
unpublished working 
turning sos rules equations lics pp 

preliminary version 
turning sos rules equations information computation pp 

aceto fokkink glabbeek ing axiomatizing prefix iteration silent steps information computation pp 

aceto hennessy termination deadlock divergence assoc 
cornput 
mach pp 

aceto ing cpo models class gsos languages mosses pp 

preliminary version 
cpo models compact gsos languages information computation pp 

characterization finitary bisimulation inf 
process 
lett pp 

aczel non founded sets vol 
csli lecture notes stan ford university 
allen constable howe aitken semantics reflected proof proceedings th symposium logic computer science philadelphia pa ieee computer society press pp 

nd de processus synchronisations theoretical cornput 
sci pp 

baader nipkow term rewriting cam bridge university press 
backus syntax semantics proposed international algebraic language zurich cm conference proceedings icip unesco pp 

badouel conditional rewrite rules algebraic semantics processes research report inria rennes 
badouel darondeau structural operational specifications trace automata cleaveland pp 

baeten ed applications process algebra cambridge tracts theoretical computer science cambridge university press 
baeten bergstra survey axiom systems process algebras report university amsterdam amsterdam 
discrete time process algebra cleaveland pp 

baeten bergstra klop syntax defining equations interrupt mechanism process algebra fundamenta informaticae ix pp 

consistency fair abstraction rule theoretical cornput 
sci pp 

baeten klop eds proceedings st conference concurrency theory amsterdam netherlands vol 
lecture notes computer science springer verlag 
baeten verhoef congruence theorem structured operational semantics predicates best pp 

concrete process algebra handbook logic computer science abramsky gabbay maibaum eds vol 
iv oxford university press pp 

baeten weijland process algebra cambridge tracts theoretical computer science cambridge university press 
bakker semantics programming languages advances information systems science pp 

bakker roever rozenberg eds proceedings rex workshop semantics foundations applications netherlands june vol 
lecture notes computer science springer verlag 
eds proceedings rex school symposium decade con currency reflections perspectives noordwijkerhout netherlands vol 
lecture notes computer science springer verlag 
bakker zucker processes denotational se mantics concurrency information control pp 

barendregt lambda calculus syntax semantics vol 
studies logic foundation mathematics northholland amsterdam 
basten branching bisimilarity equivalence 
information processing letters pp 

bergstra ponse process algebra iteration nesting computer journal pp 

bergstra klop fixed point semantics process algebras report iw mathematisch centrum amsterdam 
algebra recursively defined processes algebra regular processes proceedings th colloquium automata languages programming antwerp belgium paredaens ed vol 
lecture notes computer science springer verlag pp 

process algebra synchronous communication information control pp 

conditional rewrite rules confluence termination corn put 
system sci pp 

verification alternating bit protocol means process algebra spring school mathematical methods specification synthesis software systems germany bibel jantke eds lecture notes computer science springer verlag pp 

complete inference system regular processes silent moves proceedings logic colloquium drake truss eds hull north holland pp 

ponse nd mez process algebra backtracking bakker pp 

bernstein congruence theorem structured operational se mantics higher order languages proceedings th symposium logic computer science indianapolis indiana ieee computer society press pp 

berry hardware implementation pure esterel rapport de recherche ecole des mines cma sophia antipolis france 
best ed proceedings jth conference concurrency theory hildesheim germany vol 
lecture notes computer science springer verlag 
bloom ready simulation bisimulation semantics ccs languages phd thesis department electrical engineering computer science massachusetts institute technology 
lcf 
flat lattice models typed calculus information computation pp 

meanings denotational operational logical characterizations notion simulation concurrent processes 
unpublished manuscript 
ready set go structural operational semantics linear time process algebras report tr cornell university ithaca new york 
chocolate calculi higher order communication lambda terms conference record st acm symposium principles programming languages portland oregon pp 

partial trace equivalence adequate formal aspects computing pp 

structural operational semantics weak bisimulations theoretical cornput 
sci pp 

structured operational semantics specification language conference record nd acm symposium principles programming languages san francisco california pp 

bloom cheng language enhance expressiveness specification ieee transactions soft ware engineering pp 

bloom fokkink glabbeek precongruence formats decorated trace preorders proceedings th symposium logic computer science santa barbara california ieee computer society press 
appear 
bloom meyer bisimulation traced preliminary report conference record th acm symposium principles programming languages san diego california pp 

preliminary version 
bisimulation traced assoc 
cornput 
mach pp 

bol groote meaning negative premises transition system specifications extended proceedings th colloquium automata languages programming madrid spain leach albert monien rodriguez eds vol 
lecture notes computer science springer verlag pp 

preliminary version 
meaning negative premises transition system specifi cations assoc 
cornput 
mach pp 

timed process algebras urgent interactions unique powerful binary operator proceedings rex workshop real time theory practice netherlands june bakker huizing roever rozenberg eds vol 
lecture notes computer science springer verlag pp 

term rewriting properties sos axiomatisations hagiya mitchell pp 

brand klint verhoef reverse engineering system renovation annotated bibliography software engineering notes pp 

brookes hoare roscoe theory communicating sequential processes assoc 
cornput 
mach pp 

brookes main melton mislove schmidt eds proceedings th conference mathematical foundations programming semantics pittsburgh pa vol 
lecture notes computer science springer verlag 
bryant graph algorithms boolean function tion ieee trans 
cornput pp 

clark negation failure logic databases gallaire minker eds plenum press new york pp 

cleaveland ed proceedings rd conference concurrency theory stony brook ny vol 
lecture notes computer science springer verlag 
cleaveland hennessy priorities process algebras information computation pp 

cleaveland parrow steffen concurrency workbench semantics verification tool finite state systems acm trans 
prog 
lang 
syst pp 

constable allen bromley cleaveland cremer harper howe knoblock panangaden sasaki smith mathematics nuprl proof development system prentice hall 
courcelle nivat algebraic families interpretations proceedings th symposium foundations computer science houston texas ieee pp 

general conservative extension theorem process algebras inequalities proceedings nd workshop algebra communicating processes eindhoven netherlands ponse verhoef eds report cs eindhoven university technology pp 

verhoef general conservative extension theorem process algebras inequalities theoretical cornput 
sci pp 

darondeau concurrency computability semantics systems concurrent processes proceedings spring school theoretical computer science la roche france ed vol 
lecture notes computer science springer verlag pp 

de francesco inverardi proving ccs processes non standard semantics acta informatica pp 

de nicola hennessy testing equivalences processes theoretical cornput 
sci pp 

degano priami enhanced operational semantics acm computing surveys pp 

bloom generating bdd models process algebra terms proceedings th conference computer aided verification liege belgium wolper ed vol 
lecture notes computer science springer verlag pp 

expressive power ccs proceedings th conference foundations software technology theoretical computer science bangalore india thiagarajan ed vol 
lecture notes computer science springer verlag pp 

emerson automated temporal reasoning reactive systems moller birtwistle pp 

generating bdds symbolic model checking ccs distributed computing pp 

fages new fixpoint semantics general logic programs compared founded stable model semantics new gen eration computing pp 


fernandez tool verification communicating processes technical report imag grenoble 
fokkink format reduces tree rules hagiya mitchell pp 

preliminary version 
language preorder precongruence report csr university wales swansea 
appear theoretical computer science 
rooted branching bisimulation congruence cornput 
sys tem sci pp 

fokkink glabbeek rules reduce ntree rules information computation pp 

fokkink effective axiomatization real time cp information computation pp 

fokkink verhoef conservative look operational semantics variable binding information computation pp 

conservative extension conditional term rewriting applications software renovation factories proceedings nd conference fundamental approaches software engineering amsterdam netherlands 
finance ed vol 
loo lecture notes computer science springer verlag pp 

fokkink zantema basic process algebra iteration completeness equational axioms computer journal pp 

ross schlipf unfounded sets wellfounded semantics general logic programs proceedings th acm symposium principles database systems austin texas acm pp 

preliminary version 
founded semantics general logic programs assoc 
cornput 
mach pp 

gelfond lifschitz stable model semantics logic programming proceedings th conference logic programming seattle washington kowalski bowen eds mit press pp 

ge investigations logical deduction collected papers gerhard gentzen szabo ed north holland pp 

glabbeek bounded nondeterminism approximation induction principle process algebra proceedings th symposium theoretical aspects computer science passau germany brandenburg vidal wirsing eds vol 
lecture notes computer science springer verlag pp 

comparative concurrency semantics refinement actions phd thesis free university amsterdam 
linear time branching time spectrum baeten klop pp 

complete axiomatization branching bisimulation congruence finite state behaviours proceedings th symposium mathematical foundations computer science poland eds vol 
lecture notes computer science springer verlag pp 

full abstraction structural operational semantics extended proceedings rd conference algebraic methodology software technology enschede netherlands nivat rattray rus scollo eds workshops computing springer verlag pp 

linear time branching time spectrum ii semantics sequential processes silent moves best pp 

meaning negative premises transition system spec ii report stan cs tn department computer science stanford university 
expressiveness acp ponse pp 

meaning negative premises transition system specifications ii extended automata languages program ming rd colloquium meyer auf der heide monien eds vol 
lecture notes computer science paderborn germany springer verlag pp 

personal communication march 
branching time abstraction bisimulation semantics extended information process ing ritter ed north holland pp 

preliminary version 
branching time abstraction bisimulation semantics assoc 
cornput 
mach pp 

thatcher initial algebra semantics continuous algebras assoc 
cornput 
mach pp 

gordon eds higher order operational tech niques semantics cambridge university press 
transition system specifications negative premises extended baeten klop pp 

preliminary version 
transition system specifications negative premises theoretical cornput 
sci pp 

groote ponse syntax semantics ponse pp 

groote vaandrager structured operational seman tics bisimulation congruence extended proceedings th colloquium automata languages programming italy ausiello dezani ciancaglini ronchi della rocca eds vol 
lecture notes computer science springer verlag pp 

preliminary version 
structured operational semantics bisimulation ence information computation pp 

algebraic semantics vol 
lecture notes computer science springer verlag 
gunter semantics programming languages structures techniques foundations computing mit press 
hagiya mitchell eds proceedings nd symposium theoretical aspects computer software sendai japan vol 
lecture notes computer science springer verlag 
hartel lightweight animation tool operational semantics report tr university southampton 
hennessy term model synchronous processes information control pp 

acceptance trees assoc 
cornput 
mach pp 

algebraic theory processes mit press cambridge massachusetts 
semantics programming languages elementary structural operational semantics john wiley sons chichester england 
fully denotational model higher order processes information computation pp 

hennessy communicating processes value passing assignment formal aspects computing pp 

theory communicating processes value passing information computation pp 

hennessy milner observing nondeterminism concurrency proceedings th colloquium automata languages programming netherlands bakker leeuwen eds vol 
lecture notes computer science springer verlag pp 

preliminary version 
algebraic laws nondeterminism concurrency assoc 
cornput 
mach pp 

hennessy nd plotkin full abstraction simple pro gramming language proceedings th symposium mathematical foundations computer science czechoslovakia ed vol 
lecture notes computer science springerverlag pp 

term model ccs proceedings th symposium mathematical foundations computer science poland ed vol 
lecture notes computer science springer verlag pp 

hennessy nd reg process algebra timed systems information computation pp 

hoare communicating sequential processes prentice hall inter national englewood cliffs 
howe proving congruence bisimulation functional program ming languages information computation pp 

ing semantic models communicating process value passing phd thesis school cognitive computing sciences university sussex 
jeffrey csp completely expressive computer science technical report school cognitive computing sciences university sussex 
jifeng hoare algebra operational semantics inf 
process 
lett pp 

jonsson parrow eds proceedings th conference concurrency theory uppsala sweden vol 
lecture notes computer science springer verlag 
keller formal verification parallel programs comm 
acm pp 

kleene representation events nerve nets finite automata automata studies shannon mccarthy eds princeton university press pp 

completeness real time process algebra proceedings nd conference concurrency theory amsterdam netherlands baeten groote eds vol 
lecture notes computer science springer verlag pp 

rs modal specifications tech 
rep institute electronic systems university aalborg 
larsen skou bisimulation probabilistic testing information computation pp 

compositional verification probabilistic processes land pp 

formal definition algol technical report tr ibm lab 
vienna 
le mi tayer schmidt structural operational semantics basis static program analysis acm computing surveys pp 

logic computer science proceedings th symposium santa cruz california ieee computer society press 
luc formal definition programming languages systems proceedings ifip congress north holland pp 

program correctness stepwise development implementations proceedings di informatica university pisa march pp 

finiteness conditions structural construction automata process algebras dimacs series discrete mathematics theoretical computer science pp 

main trace failure testing equivalences communicating systems international journal parallel programming pp 

mason smith talcott operational semantics domain theory information computation pp 

proceedings rd conference theory practice software development vol 
barcelona spain diaz orejas eds vol 
lecture notes computer science springer verlag pp 

mccarthy mathematical science computation information processing ed pp 

mcmillan symbolic model checking kluwer academic publish ers 
meyer semantical paradigms notes invited lecture proceedings rd symposium logic computer science edinburgh ieee computer society press pp 

milne milner concurrent processes syntax assoc 
cornput 
mach pp 

milner processes mathematical model computing agents proceedings logic colloquium bristol uk rose shepherdson eds north holland pp 

fully models typed calculi theoretical cornput 
sci pp 

calculus communicating systems vol 
lecture notes computer science springer verlag 
modal characterisation observable machine behaviour th colloquium trees algebra programming genoa italy astesiano eds vol 
lecture notes computer science springer verlag pp 

relating synchrony asynchrony tech 
rep csr department computer science university edinburgh 
calculi synchrony asynchrony theoretical cornput 
sci pp 

complete inference system class regular cornput 
system sci pp 

communication concurrency prentice hall international englewood cliffs 
complete axiomatisation observational congruence finite state behaviors information computation pp 

elements interaction turing award lecture comm 
acm pp 

milner parrow walker calculus mobile processes part ii information computation pp 

milner tofte harper macqueen definition standard ml revised mit press 
moller importance left merge operator process algebras proceedings th colloquium automata languages programming warwick uk paterson ed vol 
lecture notes computer science springer verlag pp 

moller eds logics concurrency structure versus automata vol 
lecture notes computer science springer verlag 
moller temporal calculus communicating systems baeten klop pp 

mosses foundations modular sos extended pro ceedings th symposium mathematical foundations computer science poland eds vol 
lecture notes computer science springer verlag pp 

mosses nielsen schwartzbach eds proceedings th conference theory practice software development denmark vol 
lecture notes computer science springer verlag 
nicollin sifakis algebra timed processes atp theory application information computation pp 

nielson nielson semantics applications formal wiley professional computing john wiley sons chichester england 
transition system specifications stalk format bisimulation congruence proceedings th symposium theoretical aspects computer science france mayr wagner eds vol 
lecture notes computer science springer verlag pp 

gries axiomatic proof technique parallel programs acta inf pp 

park concurrency automata infinite sequences th gi conference karlsruhe germany deussen ed vol 
lecture notes computer science springer verlag pp 

parrow expressive power parallelism generation computer systems pp 

pl definition group formal definition pl version re port tr american nat 
standards institute 
plotkin powerdomain construction siam comput pp 

cf considered programming language theoretical corn put 
sci pp 

lecture notes domain theory 
university edinburgh 
structural approach operational semantics report daimi fn computer science department aarhus university 
operational semantics csp proceedings ifip tc working conference formal description programming concepts ii germany bj rner ed northholland pp 

pnueli temporal logic programs proceedings th symposium foundations computer science providence rhode island ieee pp 

ponse computable processes bisimulation equivalence formal aspects computing pp 

ponse verhoef eds proceedings st workshop algebra communicating processes utrecht netherlands workshops computing springer verlag 
priami enhanced operational semantics concurrency phd thesis department computer science university pisa 
przymusinski declarative semantics deductive databases logic programs foundations deductive databases logic programming minker ed morgan kaufmann publishers los altos california pp 

founded semantics coincides valued sta ble semantics fundamenta informaticae pp 

reisig petri nets eatcs monographs theoretical computer science volume springer verlag 
rensink bisimilarity open terms proceedings th workshop expressiveness concurrency santa margherita ligure italy palamidessi parrow eds vol 
electronic notes theoretical computer science elsevier 
reppy cml higher order concurrent language programming language design implementation sigplan pp 

rogers theory recursive functions effective computability mcgraw hill book 
roscoe theory practice concurrency prentice hall international 
rosen quantales applications research notes mathematics pitman london 
rutten deriving denotational models bisimulation struc tured operational semantics years concurrency semantics selected papers amsterdam concurrency group bakker rutten eds world scientific pp 

sets programming language semantics brookes pp 

processes terms non founded models bisimulation mathematical structures computer science pp 

rutten turi initial algebra final coalgebra semantics concurrency bakker pp 

salomaa theory automata vol 
international series monographs pure applied mathematics pergamon press oxford 
sands sos rules proof principles operational metatheory functional languages conference record th acm symposium principles programming languages paris france pp 

sangiorgi lazy lambda calculus concurrency scenario information computation pp 

ri symmetric calculus internal mobility mosses pp 

schneider operational semantics timed csp information computation pp 

scott strachey mathematical semantics computer languages proceedings symposium computers automata vol 
microwave research institute symposia series 
simone dans de processus meije de cycle univ paris 
meije sccs infinite sum operators vs non guarded definitions theoretical cornput 
sci pp 

higher level synchronising devices meije sccs theoretical cornput 
sci pp 

simone aboard auto tech 
rep inria centre sophia antipolis cedex 
simpson compositionality cut elimination hennessy milner logic arbitrary gsos proceedings th symposium logic computer science san diego california ieee computer society press pp 

smith operational denotational semantics brookes pp 

smyth powerdomains cornput 
system sci pp 

steel ed formal language description languages computer programming 
proceedings ifip working conference formal language description languages north holland 
stirling modal logics communicating systems theoretical cornput 
sci pp 

generalization owicki gries hoare logic concurrent language theoretical cornput 
sci pp 

modal temporal logics handbook logic computer science abramsky gabbay maibaum eds vol 
oxford university press pp 

modal temporal logics processes moller birtwistle pp 

hansen sm math theory domains cambridge tracts theoretical computer science cambridge university press 
stoughton fully models programming languages research notes theoretical computer science pitman london 
substitution revisited theoretical cornput 
sci pp 

structural operational semantics synchronous languages phd thesis department computer science university pisa 
turi plotkin mathematical operational semantics proceedings th symposium logic computer science warsaw poland ieee computer society press pp 

equivalences observable processes lics pp 

axiomatisations weak equivalences de simone languages proceedings th conference concurrency theory philadelphia pa lee smolka eds vol 
lecture notes computer science springer verlag pp 

finite axiom systems testing preorder de simone process languages wirsing nivat pp 

phillips formats ordered sos rules silent actions proceedings th conference theory practice software development lille france bidoit dauchet eds vol 
lecture notes computer science springer verlag pp 

vaandrager process algebra semantics pool baeten pp 

relationship process algebra input output automata extended proceedings th symposium logic computer science amsterdam netherlands ieee computer society press pp 

expressiveness results process algebras bakker pp 

discrete time process algebra phd thesis eindhoven university technology 
verhoef operator definition principle process algebras report programming research group university amsterdam 
linear unary operators process algebra phd thesis university amsterdam 
congruence theorem structured operational semantics predicates negative premises jonsson parrow pp 

preliminary version 
general conservative extension theorem process algebra proceedings rd ifip working conference programming concepts methods calculi san italy 
olderog ed ifip transactions elsevier pp 

congruence theorem structured operational semantics predicates negative premises nordic journal computing pp 

algebra communicating processes empty process theoretical cornput 
sci pp 

walker automated analysis mutual exclusion algorithms ccs formal aspects computing pp 

bisimulation divergence information computation pp 

watt programming concepts paradigms prentice hall 
weber bloom brown compiling joy silicon exercise applied structural operational semantics bakker pp 

winskel complete proof system sccs modal assertions fundamenta informaticae ix pp 

wirsing nivat eds proceedings th conference algebraic methodology software technology munich germany vol 
lecture notes computer science springer verlag 
wright felleisen syntactic approach type soundness information computation pp 

index wol ii ii ct fw fa st act fs fv accepting trace act action fresh aip algebraic relation alternative composition approximation induction principle see aip argument frozen liquid test arity axiom axiomatization complete ce complete sound basic process algebra behavioural equivalence behavioural preorder binary decision diagram binary kleene star bisimulation bpae bpae dr bpa branching bisimulation rooted complete partial order completed trace conditional term rewriting system see crts congruence completed trace conservative extension axiomatic operational rewrite constant context liquid ctrs de simone format de simone language bounded primitive effective primitive finitary functional image finite recursively enumerable width effective primitive width finitary denial formula disjoint extension egli milner preorder empty process encapsulation equality relation failure ll failure trace ll failure trace format finitary preorder fix function symbol binary bounded uniformly unary ground confluence gsos format gsos language compact infinitary linear regular semantically founded simple syntactically founded hennessy milner logic hml formula initials cool format labelled transition system see lts left merge literal denying negative positive look ahead lts computable countably branching decidable finite finitely branching primitive recursive recursively enumerable regular divergence model stable valued supported supported ntree format format rule failure trace safe safe ready trace safe operator dependency panth format parallel composition path format polling precongruence pred predicate convergence divergence fresh prefix multiplication premise negative positive priority proc projection proof supported supported propagation language quantales rbb safe format rdp format ready ready simulation format ready trace ready trace format recursive definition principle see rdp recursive specification principle see rsp relational renaming rewrite relation rewrite rule rsp rule format sequential composition algebra domain homomorphism poser preorder signature sorted higher order silent step simplification ordering simulation source stalk format state stratification strict substitution actual closed formal synchronization tree finite target term actual closed formal fresh open recursive guarded trace trace format transition transition rule actual junk patience pure source dependent transition system specification see tss trigger positive tss complete positive complete strictly ws complete format format type variable actual floating formal recursion unguarded source dependent variable dependency graph founded 
