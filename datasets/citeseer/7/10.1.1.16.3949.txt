homeomorphic embedding online termination michael leuschel mal ecs soton ac uk declarative systems software engineering group technical report tr october www ecs soton ac uk techreports department electronics computer science university southampton southampton bj united kingdom homeomorphic embedding online termination michael leuschel department electronics computer science university southampton uk mail mal ecs soton ac uk 
quasi orders general homeomorphic embedding particular gained popularity ensure termination program analysis specialisation transformation techniques 
investigate clarify time intuitively formally advantages approach wellfounded orders 
notably show homeomorphic embedding relation strictly powerful large class involved founded approaches 
illustrate homeomorphic embedding relation suffers inadequacies unsatisfactory contexts logic functional logic programming logical variables arise 
new extended homeomorphic embedding relations remedy problem 
keywords termination quasi orders program analysis specialisation transformation logic programming functional logic programming 
problem ensuring termination arises areas computer science lot devoted proving termination term rewriting systems logic programs 
important issue areas program analysis specialisation transformation usually strives methods guaranteed terminate 
issue model checking infinite state systems involved 
basically distinguish kinds techniques ensuring termination static techniques prove ensure termination program process line kind execution online dynamic techniques ensure termination process execution 
process course performing static analysis 
static approaches information disposal require runtime intervention impossible 
approaches part done author post doctoral fellow fund scientific research flanders belgium fwo leuven belgium diku university copenhagen denmark 
taken depends entirely application area 
instance static termination analysis logic programs falls context termination program specialisation transformation analysis ensured online manner 
primarily aimed studying improving online termination techniques 
examine case partial deduction automatic technique specialising logic programs 
henceforth suppose familiarity basic notions logic programming 
partial deduction lloyd shepherdson framework generates possibly incomplete sldnf trees set atoms 
specialised program extracted trees producing clause called resultant non failing branch 
resolution steps sldnf trees referred unfolding steps performed justifying hope specialised program efficient 
ensure termination partial deduction issues arise cf 

called local termination problem corresponding fact generated sldnf tree finite 
called global termination problem meaning set contain finite number atoms 
similar classification done program specialisation techniques cf 

gamma gamma psi gamma gamma psi gamma gamma psi local termination tree finite global termination fig 

global local termination mainly local termination illustrate concepts 
shown atoms structured global tree methods similar local termination ensure global termination 
discussions contributions immediately applicable context analysis specialisation transformation techniques general especially applied computational paradigms logic programming constrained logic programming conditional term rewriting functional programming functional logic programming :10.1.1.25.8566
instance interpretation techniques usually analyse set calls new call patterns continuously added 
faces problem similar global termination partial deduction 
believe discussions relevant areas infinite model checking theorem proving termination insured non trivial ways 
depth bounds albeit ad hoc way solve local termination problem simply impose arbitrary depth bound 
depth bound course motivated property structural program goal consideration 
context local termination depth bound typically lead little unfolding 
determinacy approach partial evaluation functional programs expand tree determinate non failing branch 
approach restrictive guarantee termination infinitely failing determinate computations specialisation time 
strict functional programs condition seen error original program corresponding run time computation terminate 
logic programming situation somewhat different goal infinitely fail deterministic way partial deduction time run time instances finitely fail 
applications theorem proving infinite determinate failures run time necessarily indicate programmer error simply due unprovable statements 
contrary functional programming measures addition determinacy adopted ensure local termination 
founded orders luckily refined approaches ensure local termination exist 
non ad hoc methods logic functional programming founded orders inspired usefulness context static termination analysis 
techniques ensure termination time allowing unfolding related structural aspect program goal specialised permitting consumption static input atoms formally founded orders defined follows definition 
wfo strict partial order set anti reflexive anti symmetric transitive binary relation theta sequence elements called admissible wrt iff 
call founded order wfo iff infinite admissible sequence wrt ensure local termination find sensible founded order atoms allow sldnf trees sequence selected atoms admissible wrt founded order 
atom want select strictly smaller ancestors select atom unfolding altogether 
example 
reverse program accumulator rev acc acc rev hjt acc res rev res simple founded order atoms form rev comparing number function constant symbols argument 
define wfo atoms rev rev iff term size term size 
wfo goal rev bjt unfolded goal rev bjt rev argument strictly decreases step decrease 
rev unfolded rev strict decrease 
elaborate techniques split expressions classes lexicographical ordering subsequences arguments continuously refine orders unfolding process exist precise details 
works refinements apply wfo especially context partial deduction 
instance requiring decrease wrt ancestor request decrease wrt covering ancestors compares ancestor atoms current atom descends resolution 
refinements consist allowing wfo depend selected atom context ignore calls non recursive predicates 
discusses way relax condition strict decrease refining wfo 
refinements applied approaches notably section 
felt researchers founded orders rigid conceptually complex online setting 
quasi orders gained popularity ensure online termination program manipulation techniques 
unfortunately move quasi orders formally justified relation founded approaches investigated 
strive part prove simple quasi approach homeomorphic embedding relation strictly powerful large class involved founded approaches 
despite power show homeomorphic embedding unsatisfactory comes variables 
aims improving situation developing adequate refinements homeomorphic embedding relation 
structured follows 
sections provide gentle quasi orders formally compare power quasi orders power founded orders online termination 
section provide additional investigation discussing concept near foundedness 
section show despite power homeomorphic embedding unsatisfactory comes variables 
provide solution improve section notably able cope infinite alphabets 
section provide discussion applying homeomorphic embedding context metaprogramming 
extended revised version :10.1.1.16.3949
quasi orders homeomorphic embedding formally quasi orders defined follows 
definition 
quasi order quasi order set reflexive transitive binary relation theta henceforth symbols 
possibly annotated subscript refer strict partial orders refer quasi orders 
directionality convenient context 
define expression term built variables function symbols arity atom predicate symbol applied possibly empty sequence terms treat predicate symbols functors suppose confusion function predicate symbols arise predicate function symbols distinct 
definition 
wbr wqo binary relation theta sequence elements called admissible wrt iff say binary relation wbr iff infinite admissible sequences wrt quasi order say quasi order wqo observe contrast wfo non comparable elements allowed admissible sequences 
admissible sequence called bad non admissible called 
binary relation infinite sequences 
equivalent definitions binary relations quasi orders 
higman alternate definition quasi orders terms finite basis property finite generating set :10.1.1.16.3949
definitions equivalent theorem 
different equivalent definition wqo quasi order wqo iff quasi orders contain corresponding strict partial order oe wfo 
property exploited context static termination analysis dynamically construct founded orders quasi ones led initial wqo offline setting :10.1.1.15.3043
quasi orders online setting emerged mentioned compared founded approaches 
comparison wfo wqo offline setting argued simply terminating rewrite systems approaches quasi orders interesting ones partial orders :10.1.1.25.9200
show situation somewhat reversed online setting 
furthermore online setting transitivity wqo really interesting drop requirement leading wbr 
sections develop wbr wqo 
interesting wqo homeomorphic embedding relation theta derives results higman kruskal :10.1.1.16.3949
context term rewriting systems adapted supercompilation :10.1.1.15.3043
usefulness criterion partial evaluation discussed advocated :10.1.1.16.3949
complexity results summarised :10.1.1.16.3949
definition adapts pure homeomorphic embedding adding rudimentary treatment variables :10.1.1.15.3043
definition 
theta pure homeomorphic embedding relation theta expressions defined inductively follows theta relation satisfying rules 
theta variables 
theta theta 
theta ng theta second rule called diving rule third rule called coupling rule 
theta say embedded embedding delta denote theta thetas 
theta denote theta theta example 
intuition definition theta iff obtained striking certain parts said way structure reappears instance theta obtained striking observe striking corresponds application diving rule cf 
lemma delta 
theta delta theta theta 
proposition 
relation theta wqo set expressions finite alphabet 
complete proof reusing higman kruskal results straightforward manner see 
constructive proofs higman lemma see 
see 
non constructive 
ensure local termination partial deduction ensure constructed sldnf trees selected atoms embed ancestors founded order example require strict decrease step 
atom want select embeds ancestors select atom unfolding altogether 
example theta goal rev bjt example unfolded rev bjt rev rev bjt bjt rev bjt rev bjt 
rev unfolded rev rev theta rev 
observe contrast example choose measure arguments 
elaborate inherent flexibility theta section 
homeomorphic embedding relation useful handling structures expressions 
successfully applied detect potentially non terminating sequences characteristic trees 
theta desired property real loops detected detected earliest possible moment see :10.1.1.16.3949
comparing wbr wfo general comparison follows definitions wqo defined iff wfo vice versa 
shows obtain wbr wfo 
lemma 
wbr wfo founded order defined iff 
wbr furthermore set admissible sequences 
means online setting approach wbr theory powerful wfo 
show wbr strictly powerful 
observe necessarily wqo transitivity ensured 

imply 
denote strictly general wfo 


observe proof lemma requires transitivity lemma hold simply founded relation 
examine power particular wqo earlier defined theta 
homeomorphic embedding monotonic wfo homeomorphic embedding theta relation flexible 
example applied sequence covering ancestors permit full unfolding terminating datalog programs quicksort mergesort program list sorted known poses problems static termination analysis methods experiments see appendix 
produce consume example see requires involved techniques considering context solved wfo 
example poses problem theta cf 
appendix 
homeomorphic embedding theta powerful context metaprogramming 
notably ability penetrate layers nonground meta encodings see appendix computer experiments see section 
instance theta admit sequences example progressively wrapped vanilla counting resolution steps keeping track selected predicates respectively sequence rev bjt rev bjt solve rev bjt solve rev bjt solve solve rev bjt solve solve rev bjt rev path path solve solve path solve solve path rev observe need dynamically focus reconfigure weights 
difficult wfo requires refined involved techniques knowledge implementation online setting exists 
example admit third sequence measure argument argument argument 
fifth sequence gets difficult 
intuitively demonstrated usefulness theta flexible wfo 
prove hard results 
turns establish online setting theta strictly generous large class refined wfo 
definition 
founded order oe expressions said monotonic iff rules hold 
variables 
function symbol 
ng note similarity structure definition theta contrary theta relation satisfying rules 
similarity structure enable prove sequence admissible wrt oe admissible wrt theta showing theta see 
observe point need hold predicate symbols point implies constant proposition symbols subtle difference monotonic wfo definition wfo possess replacement property orders called rewrite orders monotonic 

similarly say norm mapping expressions said monotonic iff associated wfo oe monotonic oe iff kt kt 
instance norm see trivially monotonic 
generally semi linear norm form monotonic proposition 
norm expr defined ktk kt ktk variable psi ffl theta theta fig 

pair admitted monotonic prohibited theta monotonic coefficients function symbols arity necessarily predicate symbols 
proof 
total 
equivalent proof proceeds induction structure expressions examines rule definition separately 
variables trivially holds constant cv variables 

tn holds trivially coefficients cf 
verified rule applies function symbol 

sn tn ng holds trivially independently function predicate symbol coefficients positive coefficient applied 
get norm ts proposition monotonic 
get monotonic norm counting symbols 
denote norm sym linear norm obtained setting corollary linear norm monotonic 
proposition 
monotonic norms satisfying proposition 
lexicographical ordering oe lex defined oe lex iff kg ksk ktk gamma ksk ktk monotonic wfo 
proof 
standard results see know wfo wfo :10.1.1.15.3043
prove satisfies rules definition 
rule easy kxk ky variables 
examining rules note lex equivalent saying kg ksk ktk exists kg ksk ktk gamma ksk ktk examine rule definition 
prove lex rule holds 
examine case lex ksk kt know ksk kf tn monotonicity total 
equivalent 
holds lex tn 
examine second case lex kg ksk kt gamma ksk kt deduce ksk kf tn prove ksk kf tn monotonicity know ksk kf tn apply monotonicity deduce kt kf tn infer desired property ksk kt 

rule prove lex ng rule holds 
cases 
ks kt monotonicity know kf sn kf tn kg 
sn lex tn 
case know value kg ks kt gamma ks kt letting denote minimum value holds know ks kt jg ks kt monotonicity deduce jg kf sn kf tn deduce monotonicity kf sn kf tn deduce kf sn kf gamma tn kf tn just prove kf gamma tn kf tn order affirm kf sn lex kf tn hold monotonic norms know satisfies proposition deduced fact coefficient cf 
important norms satisfy proposition 
counterexample follows 
kak kbk kf kf 
kak kbk kf kf 
oe lex lex lex condition monotonicity oe lex violated 
proposition slightly general current version sufficient show desired result wfo online practice monotonic 
example refined wfo defined monotonic definitions sum number function symbols subset argument positions atoms 
wfo immediately covered proposition 
algorithms differ way choosing positions measure 
early algorithms simply measure input positions ones dynamically refine argument positions measured measured norm 
definitions lexicographical order selected argument positions 
wfo monotonic corollary propositions 
non monotonic wfo collection articles defined specifically definition section uses selector functions focus subterms measured 
return approach 
mentioned techniques sections respectively require sequence admissible wrt unique wfo split sequence finite number subsequences apply different monotonic wfo subsequences 
similar refinements developed wqo formal study refinements main focus see discussion section 
showing theta strictly powerful union monotonic wfo adapt class simplification orderings term rewriting systems 
turn power class subsumed theta 
definition 
simplification ordering wfo oe expressions satisfies 
oe oe replacement property 
oe subterm property 
oe soe oe tfl variable substitutions oe fl invariance variable replacement 
third rule definition new wrt term rewriting systems implies variables treated unique new constant 
turns lot powerful wfo simplification orderings recursive path ordering knuth bendix ordering lexicographic path ordering name just :10.1.1.25.9200
wfo proposition simplification orderings kak kf subterm property hold associated wfo 
addition proposition allows special treatment predicates 
hand wfo simplification orderings monotonic definition 
proposition 
oe wfo expressions 
admissible sequence wrt oe admissible sequence wrt theta oe monotonic simplification ordering 
proof 
observe wfo oe expressions admissible sequence wrt oe admissible sequence wrt theta iff thetat 
theta picture applicable trivially implies transitivity oe sequence admissible wrt theta strictly descending wrt oe 
hand assume theta means sequence admissible wrt wrt theta contradiction 
proof monotonic wfo oe theta picture applicable straightforward induction structure tricky aspect second rule monotonicity holds function symbol 
predicate symbol theta hold supposed predicate function symbols distinct 
oe simplification ordering apply lemma deduce oe superset strict part theta oe delta 
examine possibilities theta delta case deduce oe second theta theta case identical variables 
take substitution oe assigns variables unique variable soe toe soe toe 
means hold invariant variable replacement 
observe transitivity oe required proof proposition simply hold founded relations 
means admissible sequences wrt theta superset union admissible sequences wrt simplification orderings monotonic wfo 
words matter refinement put approach monotonic wfo simplification orderings expect approach theta limit 
simple example hope 
example 
take sequence ffi sequence admissible wrt theta thetaf thetab thetaa thetab thetaa thetab 
monotonic wfo oe admits sequence 
precisely admit ffi violates rule definition oe monotonic 
violates rule definition oe simplification ordering 
new results relating theta monotonic wfo shed light theta usefulness context ensuring online termination 
course admissible sequences wrt theta superset union admissible sequences wrt wfo 
instance list length norm monotonic kt kt theta sequences admissible wrt list length wrt theta 
reason particular nonmonotonic wfo general completely ignore certain parts term theta inspect part 
ignores subterm true theta sequence admissible wrt wrt theta 
reason wfo defined definition mentioned monotonic allowed completely focus subterms fully ignoring subterms 
automation technique addressed 
wfo immediately apply idea continually refining measured subterms simply plunge deeper deeper terms termination ensured 
step automatic implementation section require formally compare wqo approaches ability completely ignore certain parts theta wqo finite sequences repetitions admissible wrt wfo map element second element 
observe predicate symbols valid expression enabled ignore arguments predicates proposition 
expression beneficial practical programs 
seen earlier theta flexible combined characteristic trees see 
return issue metaprogramming section 
course wfo monotonic devise wbr cf 
lemma admissible sequences 
easily attained theta achieved wfo approach monotonic 
take sequences 
sequences admissible wrt theta illustrates flexibility quasi orders compared founded ones online setting exists wfo monotonic admit sequences 
illustrates wqo way compare predecessor state process 
get infinite derivations form 
short note offline termination example shows theta orders general directly static termination analysis 
explain mean 
take program containing clauses 
cases body embedding head combination clauses leads non terminating program 
theta construct founded orders static termination analysis 
take clause head body incomparable theta 
simply extend theta stating making head strictly larger body atom 
mentioned extension wqo wfo 
know program just consisting terminating 
analyse extended wqo body strictly larger head luckily prove termination way extending theta head strictly larger body 
nearly foundedness eagerness section technique wfo formally introduced nearly foundedness 
mentioned earlier techniques start coarse wfo allow go wfo need cf 
example 
context want go clearly impossible 
wfo compare closest predecessor transitivity order strict decrease enforced step 
wfo usually extended incorporate variant checking require inspecting predecessor anyway strict weight decrease see 
continuously refined enabling clever choice weights predicates respective arguments deciding appropriate weights extremely difficult impossible see examples section 
example measuring sum arguments 
process refining consist dropping arguments 
example suppose sequence admissible wrt initial wfo 

case move refinement argument measured making enabling move guarantee sequence admissible wrt instance sequence 
solve problem earlier algorithms verified refinement keeps sequence admissible disallowed 
problem approach re checking entire sequence expensive 
advocates solution re checking entire sequence grounds threaten termination provided refinements founded 
leads sequences founded nearly founded meaning 
finite number pairs summary motivation nearly foundedness lies speeding construction admissible sequences re scanning initial sequence refinement 
side effect approach admit sequences solve earlier examples suitably large depth bound 
theoretical point view argue difficult justify somewhat unsatisfactory 
call technique eager admits sequences admitted variant test admits sequences containing variants 
call technique strictly eager admits sequences contain occurrence syntactic term 
depth bound technique strictly eager obviously undesirable property indicating ad hoc behaviour 
said eagerness 
instance context partial deduction unfold fold program transformation eager unfolding hide possibilities perfect folding variants lead large specialised programs 
approach homeomorphic embedding eager wfo wqo approach distinguish variants 
show nearly foundedness leads strict eagerness 
formalise way nearly founded sequences constructed 
define founded order oe acting set wellfounded orders expressions 
construct admissible sequences expressions wrt oe start wfo sequence longer see discussion section concerning variant test covering ancestors 
extended 
case wfo admits offending step provided oe required initial sequence admissible wrt just step admitted 
continue expanding sequence reach offending step try refine oe 
expansion possible 
example 
take program 
ajy bjt bjt ajy define founded orders iff ks ts ks ts kt ts kt ts iff ks ts kt ts iff ks ts kt ts define wfo oe founded orders oe 
oe 
words refine turn refined 
construct admissible sequence terms appear twice refinement example proves nearly foundedness results strict eagerness 
side effect example shows nearly foundedness approach mapped wfo approach involved 
unclear situations arise practice believe strict eagerness just mathematically unsatisfactory aspects nearly foundedness 
refined treatment variables theta lot desirable properties suffers drawbacks 
observed example homeomorphic embedding relation theta defined definition crude wrt variables 
fact variables treated variable practice clearly undesirable logic programming context 
intuitively example theta justified see definition theta 
seen standing eq embeds reverse hold 
secondly theta behaves quite unexpected ways context generalisation posing subtle problems wrt termination generalisation process 
example 
take instance generalisation algorithm appears disguise lot partial deduction algorithms 
context set atoms sldnf trees constructed atoms leaves trees 
goal algorithm extend leaf atoms covered 
input finite sets atoms output finite set atom instance atom initialisation remove element instance element theta add msg add basic idea algorithm theta keep set finite limit 
algorithm keep finite terminate 
take example fp fp remove fp iteration algorithm instance theta 
calculate msg fp loop get fp 
remedy problems introduced called strict homeomorphic embedding follows definition 
theta expressions 
strictly embeds written theta iff theta strict instance example 
theta theta 
note theta theta small experiment specialising query rotate ecce system theta theta respectively conjunctions global control rotate program rotating binary tree demonstrates interest theta theta obtain speedup compared theta 
notice replace theta example theta longer problem termination see termination proof algorithm containing example 
proven 
theorem 
relation theta wbr set expressions finite alphabet 
observe theta wqo transitive example theta theta theta 
feel dissatisfied definition reason 
going looks dangerous transition dangerous especially database setting 
take example simple datalog program just consisting clause 
obviously terminate fail finitely queries theta allow full unfolding finite failure detected relying solely theta practical side means theta theta allow full unfolding terminating queries datalog programs allow full unfolding terminating ground queries range restricted datalog programs 
remedy develop refinement theta definition 
define theta var iff delta variant theta var theta var theta var theta var 
obvious theta var strictly powerful theta strictly general variant possible delta 
solves generalisation problems theta 
addition theta var property query datalog program ld tree admissible sense selected literal theta var covering ancestors theta datalog atoms theta diving rule theta applied 
theta var equivalent variant test 
derivation leads goal ln variant covering ancestor possible repeat derivation real loop 
theorem 
relation theta var wqo set expression finite alphabet 
proof appendix observe theta var theta theta wqo infinite alphabet 
section 
discussion observe variant test surprisingly complete datalog general arbitrary computation rules 
take program just consisting 
query finitely failed anonymous referees pointing 
derivation shows fail second step matter select variant covering ancestor variant test prevent full unfolding 
alternate approach definitions aspect treating variables refined way numbering variables mapping stipulating theta iff 
instance de bruijn numbering variables proposed :10.1.1.16.3949
approach somewhat ad hoc flavour 
take instance terms 
term instance theta theta 
depending particular numbering theta theta apparent reason expression considered smaller 
theta var may interesting local control compared theta due improved unfolding capabilities datalog programs theta interesting local control partial deduction 
go theta allow unfolding 
able unfold usually able go loop 
global control interesting specialise separately allowed theta theta var theta see rotate experiment 
extended homeomorphic embedding theta definition refined treatment variables better behaviour wrt generalisation theta definition somewhat unsatisfactory 
point restriction finite alphabet 
lot practical logic programs arithmetic built ins finite alphabet longer sufficient 
luckily fully general definition homeomorphic embedding remedies aspect :10.1.1.15.3043
allows functors variable arity 
show definition adapted logic programming context 
unsatisfactory aspect theta theta var 
ensure theta theta theta 
words refined treatment variables performed top recursively structure expressions 
instance means theta handle rotate better theta improvement go away add layer 
proposes consider possible numberings leading :10.1.1.16.3949
complexity number variables terms compared 
unclear relation compares theta theta var seen associative operators 
new refined embedding relation remedies somewhat ad hoc aspect theta definition 
theta wbr fun functors wbr sexp sequences expressions define extended homeomorphic embedding expressions rules 
theta variables 
theta theta 
theta fun mg theta hs sexp ht definition requires wbr fun functors 
finite alphabet equality wqo obtain pure homeomorphic embedding special case 
context partial deduction know functors occurring program text goal analysed finite number 
call functors static dynamic 
wqo obtained defining dynamic particular types functors natural wqo wbr exists numbers 
definition instantiate sexp performs refined treatment variables discussed section 
example define hs sexp ht iff ht strictly general hs 
observe means sexp hold 
relation wbr lemma strictly general relation wfo 
contrast theta theta var refinement applied recursively theta example theta 
reason recursive strict instance test incorporated theta authors sure remain wbr proof 
fact recursively applying strict instance looks dangerous 
take atoms 
fact theta theta considering static functors wonders possible create infinite sequence atoms producing 
theta luckily theta theta satisfies wqo requirement definition 
construct sequence theta conform definition 
theorem shows sequence constructed 
slightly strengthen point definition requiring hs strict instance selected subsequence ht longer wqo sequence expression shows 
slightly strengthened embedding relation embedded definition unmodified theta theta theta 
theorem 
theta wbr expressions 
additionally fun sexp wqo theta proof appendix representation problem metaprogramming seen earlier section theta flexible combined characteristic trees see 
section show subtle problems remain 
discuss issue representing object level programs meta level 
setting logical variables basically different approaches representing object level expression say atom meta level 
approach uses term object level representation 
called non ground representation represents object level variable meta level variable 
second approach term struct var struct represent object level atom 
called ground representation represents object level variable ground term 
contains examples particular ground representation section 
denote ground representation expression object level ground representation var struct struct var struct struct clause struct struct fig 

ground representation particular representation number layers define enc encoding function go call object level meta level 
non ground vanilla example enc solve 
nested vanilla get enc solve solve depth race 
ground representation get enc solve struct var cas 
say wfo wbr invariant particular encoding enc admits sequence calls admits enc enc enc 
solving representation problem amounts finding detailed discussion refer reader 
adequate wfo wbr invariant encoding powerful object level obviously total relation wqo invariant encoding enc 
conjecture prove theta solves representation problem vanilla encoding 
hope holds ground representation depicted 
unfortunately case due problems multiple arity predicate symbol occur multiple arity happen 
thetap account different predicate 
ground representation struct theta struct arity translated argument fixed arity containing list length simple solution problem predicate symbol single arity 
variable encoding represent variables integers form ks theta var 
case theta encoding admissible 
solution different functor distinct variable meaning infinite alphabet theta define wqo functors treating variables incorporating refinements similar theta theta var multiple embeddings argument unfortunately absence variables function symbol occurs single arity theta invariant ground representation 
example thetaf struct theta struct struct 
reason coupling rule 
definition theta checks embedded holds embedded hold 
rule disallows search argument hold 
exactly allowed working ground representation due fact argument tuple translated list 
solution problem weaken theta allows search argument multiple times embedding definition 
theta gamma define weak homeomorphic embedding expressions rules 
theta gamma variables 
theta gamma theta gamma 
theta gamma ng theta gamma note contrary theta equal theta gamma 
theta theta gamma conjecture theta gamma invariant ground representation enc provided problems concerning multiple arity variables resolved 
conjecture enc theta enc iff theta gamma corollary enc theta enc iff enc enc theta enc enc remains open problem find strengthening theta invariant enc 
possible achieve refinement extends kruskal theorem 
pragmatic solution course simple de encode data possible program apply theta theta de encoded data 
requires knowledge particular encodings appear 
parsing problem context meta programming 
called parsing problem 
provide view parsing problem terms invariance representation 
partial deduction usually doesn compare entire goals just selected atoms 
initial motivation allow liberal unfolding 
take example program containing take goal 
select obtain resolvent 
inspecting entire goals help notice growth structure unfolding 
just examine sequence selected literals allowed select sensible safe thing touched 
example take program consisting single clause unfold just looking theta selected atoms fail look entire goal able fully unfold 
problem meta programming context refinement invariant non ground representation 
take standard vanilla encoding program consisting single clause solve true solve solve solve refinement usually compares sequences covering ancestors 
take example program consisting single fact unfold query 
start selecting gives goal 
try select sensible thing touched 
examine sequence selected literals get hp admissible wrt theta extensions discussed 
overcome register resolution relationships check theta wfo wqo approach sequences covering ancestors 
case ancestor get sequence hp course admissible wrt wfo wqo 
solve clause solve clause hope looking theta selected literals possible fully unfold solve similar manner detect finite failure 
examine sequence goals needed detect finite failure solve clause solve solve solve solve solve clause solve fail unfortunately third step solve theta solve holds theta theta unable fully unfold solve theta selected literals entire goals 
problem multiple atoms single term refinement looking selected atom scale metalevel 
hard see problem solved general manner know solve eventually decompose constituents giving opportunity continue solve stopping unfolding solve 
presents solution problem vanilla scale slightly involved 
discussion course theta ultimate relation ensuring online termination 
proven extremely useful superimposed determinate unfolding context local control partial deduction theta theta theta allow unfolding desirable efficiency concerns unfolding imply better specialised program 
refer solutions developed 
similar problems arise setting global control refer discussions experiments 
issue efficient implementation homeomorphic embedding relation remains open 
section shown efficient way wfo avoids re scanning entire sequence refinement undesirable properties 
applications theta theta theta remain restrictive 
particular deal satisfactorily fluctuating structure arising certain tasks 
characteristic trees remedies problem extent totally 
step solution 
light interest study extensions homeomorphic embedding relation proposed context static termination analysis term rewrite systems useful online setting 
summary shed new light relation wqo wfo formally shown wqo interesting wfo ensuring termination online setting program specialisation analysis 
illustrated inherent flexibility theta proved despite simplicity strictly generous class monotonic wfo 
wfo automatic online termination far monotonic formally establishes interest theta context 
compared techniques nearly foundedness shown techniques contrary theta lead undesirable property strict eagerness 
new embedding relations theta theta var theta inherit properties theta providing refined treatment logical variables 
believe refinements value contexts languages context partial evaluation programs supercompilation functional programming languages specialisation time variables appear :10.1.1.35.9833
believe theta provides theoretically practically satisfactory basis theta theta 
believe theta play role areas ensuring termination controlling abstraction model checking infinite systems 
promising results obtained ecce applied systems expressed petri nets calculus 
danny de schreye robert gluck jesper jrgensen bern martens maurizio jacques morten heine discussions joint research led 
anonymous referees patrick cousot renaud marlet bern martens provided extremely useful feedback 

albert falaschi juli vidal 
improving control functional logic program specialization 
levi editor static analysis 
proceedings sas lncs pages pisa italy september 
springer verlag 

falaschi juli vidal 
lazy functional logic programs 
proceedings pepm acm sigplan symposium partial evaluation semantics program manipulation pages amsterdam netherlands 
acm press 

falaschi vidal 
narrowing driven partial evaluation functional logic programs 
riis nielson editor proceedings th european symposium programming esop lncs pages 
springerverlag 

apt 
logic programming 
van leeuwen editor handbook theoretical computer science chapter pages 
north holland amsterdam 

bol 
loop checking partial deduction 
journal logic programming 

bowers 
representing godel object programs godel 
technical report cstr university bristol november 

bruynooghe de schreye martens 
general criterion avoiding infinite unfolding partial deduction 
new generation computing 

de schreye 
termination logic programs story 
journal logic programming may 

dershowitz 
termination rewriting 
journal symbolic computation 

dershowitz 
jouannaud 
rewrite systems 
van leeuwen editor handbook theoretical computer science vol 
pages 
elsevier mit press 

dershowitz manna 
proving termination multiset orderings 
communications acm 

gallagher 
tutorial specialisation logic programs 
proceedings pepm acm sigplan symposium partial evaluation program manipulation pages 
acm press 

gallier 
special kruskal theorem ordinal gamma survey results proof theory 
technical report university pennsylvania october 

gluck jrgensen martens 
controlling conjunctive partial deduction definite logic programs 
swierstra editors proceedings international symposium programming languages implementations logics programs plilp lncs pages aachen germany september 
springer verlag 

gluck leuschel 
abstraction partial deduction solving inverse problems transformational approach software verification 
submitted 

gluck 
roadmap supercompilation 
danvy gluck thiemann editors proceedings dagstuhl seminar partial evaluation lncs pages dagstuhl 
springerverlag 


algorithmic aspects ordered structures 
phd thesis technische universitat berlin 

hanus 
integration functions logic programming 
journal logic programming may 

henderson 
functional programming application implementation 
international series computer science 
prentice hall englewood cliffs 

higman 
ordering divisibility algebras 
proceedings london mathematical society 

hill gallagher 
meta programming logic programming 
gabbay hogger robinson editors handbook logic artificial intelligence logic programming volume pages 
oxford science publications oxford university press 

hill lloyd 
godel programming language 
mit press 

holldobler 
foundations equational logic programming 
lnai 
springerverlag 

huet 
confluent reductions properties applications term rewriting systems 
journal acm 

jaffar maher 
constraint logic programming survey 
journal logic programming 

jones gomard sestoft 
partial evaluation automatic program generation 
prentice hall 

jrgensen leuschel martens 
conjunctive partial deduction practice 
gallagher editor proceedings international workshop logic program synthesis transformation lncs pages stockholm sweden august 
springer verlag 

kruskal 
quasi ordering tree theorem conjecture 
transactions american mathematical society 

gallagher 
constraint partial evaluation rewriting functional logic programs 
fuchs editor proceedings international workshop logic program synthesis transformation lncs leuven belgium july 

lescanne 
rewrite orderings termination rewrite systems 
tarlecki editor mathematical foundations computer science lncs pages poland september 
springer verlag 

lescanne 
rewrite orderings quasi orderings 
technical report inria lorraine france january 

leuschel 
ecce partial deduction system library benchmarks 
obtainable www cs kuleuven ac 

leuschel 
advanced techniques logic program specialisation 
phd thesis leuven may 
accessible www cs kuleuven ac michael 

leuschel 
formal comparison founded quasi orders online termination 
editor logic program synthesis transformation 
pre proceedings manchester uk june 

leuschel 
power homeomorphic embedding online termination 
levi editor static analysis 
proceedings sas lncs pages pisa italy september 
springer verlag 

leuschel de schreye 
creating specialised integrity checks partial evaluation meta interpreters 
journal logic programming 

leuschel martens 
partial deduction ground representation application integrity checking 
lloyd editor proceedings ilps international logic programming symposium pages portland usa december 
mit press 

leuschel martens 
global control partial deduction characteristic atoms global trees 
danvy gluck thiemann editors proceedings dagstuhl seminar partial evaluation lncs pages dagstuhl 
springer verlag 

leuschel martens de schreye 
controlling generalisation partial deduction normal logic programs 
acm transactions programming languages systems january 

lindenstrauss sagiv 
unfolding mystery mergesort 
fuchs editor proceedings international workshop logic program synthesis transformation lncs leuven belgium july 

lloyd 
foundations logic programming 
springer verlag 

lloyd shepherdson 
partial evaluation logic programming 
journal logic programming 

marlet 
vers une formalisation de evaluation 
phd thesis universit de nice sophia antipolis december 

martens 
semantics meta programming control partial deduction logic programming 
phd thesis leuven february 

martens de schreye 
semantics definite meta programs non ground representation 
apt turini editors meta logics logic programming pages 
mit press 

martens de schreye 
untyped non ground meta programming problem 
journal logic programming 

martens de schreye 
automatic finite unfolding founded measures 
journal logic programming august 

martens de schreye ath 
sound complete partial deduction unfolding founded measures 
theoretical computer science 

martens gallagher 
ensuring global termination partial deduction allowing flexible 
sterling editor proceedings iclp pages japan june 
mit press 

martin 
sonic partial deduction 
technical report department electronics computer science university southampton 


melli es 
duality kruskal dershowitz theorems 
larsen editor proceedings icalp lncs aalborg denmark 
springer verlag 

middeldorp zantema 
simple termination rewrite systems 
theoretical computer science 

murthy russel 
constructive proof higman lemma 
proceedings fifth annual ieee symposium logic computer science pages alamitos california 
ieee computer society press 

nash williams 
quasi ordering finite trees 
proc 
cambridge phil 
soc 


termination proofs logic programs 
lncs 
springer verlag 


unavoidable set trees generalize kruskal theorem 
journal symbolic computation 


decidability complexity automated reasoning relevant logic 
phd thesis australian national university september 

ruf 
topics online partial evaluation 
phd thesis stanford university march 


automatic partial evaluator full prolog 
new generation computing 

simpson 
ordinal numbers hilbert basis theorem 
journal symbolic logic 

gluck 
algorithm generalization positive supercompilation 
lloyd editor proceedings ilps international logic programming symposium pages portland usa december 
mit press 

gluck jones 
positive supercompiler 
journal functional programming 

stillman 
computational problems equational theorem proving 
phd thesis state university new york albany 

turchin 
concept supercompiler 
acm transactions programming languages systems 

martens 
parse parse 
fuchs editor proceedings international workshop logic program synthesis transformation lncs leuven belgium july 


complexity bounds finite forms kruskal theorem 
journal symbolic computation november 

weise ruf seligman 
automatic online partial evaluation 
proceedings conference functional programming languages computer architectures lncs pages harvard university 
springer verlag 
assorted proofs lemma wbr wfo founded order defined iff 
wbr furthermore set admissible sequences 
proof 
suppose infinite sequence elements definition means particular means infinite sequence 
contradiction definition founded order wbr shows admissible sequence admissible sequence obvious transitivity admissible sequence corollary 
monotonic norm expressions 
theta ksk ktk 
proof 
theta know proposition ksk ktk ksk ktk ksk ktk 
lemma 
theta diving rule definition 
proof 
wfo monotonic see proposition 
corollary know try apply diving rule establish theta tn theta kt contradiction kt gamma gamma 
outermost level apply rule finished coupling rule 
apply rule theta rule applied deduce theta lemma holds induction structure theorem relation theta var wqo set expression finite alphabet 
proof 
theta var trivially transitive denote variants var delta delta delta delta var delta var delta delta var var var take infinite sequence order theta var satisfy wbr requirement show theta var variants sequence theta var theta var theta var satisfies wbr requirement 
assume variants 
remove theta sequence 
lemma know finitely diving rule variants remaining sequence infinite 
repeat construction second element third element 
obtain infinite sequence 
know theta wqo 
theta construction know delta theta var theorem theta wbr expressions 
additionally fun sexp wqo theta proof 
suppose fun sexp wqo 
know theorem extra condition point requiring hs sm sexp ht tni wqo :10.1.1.16.3949
refer wqo theta 
simply define mapping expressions expressions 
kxk kf tn ht tni kt new unused binary functor encoding generating new distinct unused functors sequence expressions 
extend fun functors saying fun iff sexp symbol 
expressions ksk theta ktk theta shown structural induction sketch diving rule concluding theta tn argument ktk successful supposed constants ht tni distinct initial functors 
dive second argument ktk ht tni kt fun dive arguments kt step 
corresponding diving applicable tn able deduce theta induction hypothesis 
coupling rule concluding sm theta tn know hs sm theta ht tni choice coupling occurs binary functor argument ksk compared argument ktk 
words generates constants know hs smi fun ht tni equivalent hs smi sexp ht tni 
additional criterion rule 
theta satisfied 
apply induction hypothesis ks theta kt conclude theta hold 
conclude sm theta tn 
theta wqo theta infinite sequence terms kt theta kt theta 
case fun sexp wqo apply reasoning kruskal theorem extends wbr see 
small experiments ecce system purpose appendix illustrate flexibility homeomorphic embedding relation provides straight box intricate quasi orders handle examples 
experiment ecce partial deduction system unfolding rule theta allows selection determinate literals left literals goal covering ancestor embedded theta 
ease readability specialised programs form 
take mergesort program somewhat problematic lot static termination analysis methods 
illustrate generosity theta quicksort program taken qsort 
qsort split qsort qsort append 
append 
append append 
split 
split 
split split 
split 
partial evaluation query qsort 
resulting specialised program follows full unfolding achieved qsort 
take mergesort program somewhat problematic lot static termination analysis methods 
mergesort 
mergesort 
mergesort xs ys split xs mergesort mergesort merge ys 
split 
split xs ys zs split xs zs ys 
merge xs xs 
merge xs xs 
merge xs ys zs 
merge xs ys zs 
merge xs ys zs merge xs ys zs 
partial evaluation query mergesort 
resulting specialised program shows homeomorphic embedding allowed full unfolding mergesort mergesort 
took ecce sparc classic produce program including post processing writing file 
achieve feat interpose levels 
take vanilla solve mergesort object level solve 
solve claus solve solve 
claus mergesort 
claus mergesort 
claus mergesort xs ys split xs mergesort mergesort merge ys 
claus split 
claus split xs ys zs split xs zs ys 
claus merge xs xs 
claus merge xs xs 
claus merge xs ys zs 
merge xs ys zs 
claus merge xs ys zs merge xs ys zs 
claus 
claus solve mergesort 
partial evaluation query 
homeomorphic embedding allowed full unfolding 
took ecce sparc classic produce program including post processing writing file 
take small datalog program computing transitive closure graph arc 
arc 
trans arc 
trans arc trans 
partial evaluation query trans 
full unfolding accomplished illustrated specialised program trans 
trans 
example taken 
produce 
produce xs ys produce xs ys 
consume 
consume xs consume xs 
partial evaluation query produce consume 
solve setting unfolding wfo needs partition measure functions context account 
adequate unfolding simply achieved theta determinate unfolding illustrated specialised program derived ecce default settings 




