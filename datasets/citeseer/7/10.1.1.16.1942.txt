class object model program transformations doctoral program engineering university tsukuba japan january dissertation submitted graduate school engineering university tsukuba partial fulfillment requirements degree doctor philosophy engineering expert programmers forced develop large complicated programs strong desire write codes viewpoints runtime efficiency understandability expect translator generate code just fit needs possible 
fitting usually requires complicated customization translator done experienced compiler experts programmers reflect ideas translators easily especially programmer demands quality practical programming tools severe 
situations lead necessity develop flexible approach specific programmers reflect experience knowledge translators 
technology enables reuse larger software components available emergence object oriented paradigm widened applicability reusable code pieces 
class objectoriented modularization encapsulate design decisions perfectly especially crosscut module structure program code pieces crosscutting program tangle codes scatter entire program class modularization eventually violated 
kind violation may happen modern network programming involving distribution security issues 
thesis addresses solve crosscutting problems losing object oriented framework appearance runtime performance 
cope problems transformational system embed crosscutting code entire program automatically hide scattered code appearance 
runtime performance achieved transformational approaches inherently produce necessary elaborate code expert programmer experiences 
purpose propose class object model transforming object oriented programs develop powerful transformational systems compiler experts object oriented programming experts 
proposed class object model data model representing logical structure object oriented program logical alternations 
order ease description transforma tional systems allow users describe transformations programs intuitive notions object oriented programming notions compiler implementations 
proposed class object model powerful transformations compiler experts objectoriented programming experts expected exist compiler experts familiar object oriented programming 
reuse defined program code modules regarded reduce cost software development keeping programmers away continuous rediscovery concepts software industry 
thesis discloses design implementation practical program transformation systems proposed class object model openjava javassist general purpose transformational systems addistant special purpose system support distributed programming 
openjava object oriented macro system transformations source code program written java 
javassist java bytecode manipulating tool transformations binary programs java virtual machines 
addistant bytecode translator built javassist application case study javassist 
addistant legacy java software modified translated programs executed distributed environment 
applications programmers select remote implemented class 
viewpoint reflection transformational systems regarded reflective systems providing architectures structural reflection avoiding runtime overhead general reflection 
systems freely available widely world 
ii acknowledgments profoundly professor university tsukuba supervisor university tsukuba 
express deep gratitude professor shigeru chiba tokyo institute technology supervised thesis 
served great stimulus study reflection metaobject protocols 
professor doug lea suny doctor brent ibm watson research center professor james noble victoria university wellington professor mary beth rosson virginia tech doctor richard gabriel sun microsystems professor ron goldman stanford university gave valuable guidance thesis construction oopsla doctoral symposium 
doctor marc olivier laas cnrs reviewed draft thesis suggesting improvements 
thesis reviewed submitted version thesis final version reflects comments 
organized professor professor tanaka professor professor nishihara professor kato university tsukuba professor nakata university 
professor nakata university professor yamashita saga university supervisors belonged lang programming language group university tsukuba 
doctor david powell doctor jean charles fabre laas cnrs managed stay laas 
colleagues high level language software architecture group lang group university tsukuba especially professor university library information science professor yasushi university tsukuba professor hideki sakamoto tsukuba international university ibm tokyo research lab sasaki hitachi 
part friends related research companies just share fun 
especially university tokyo university tsukuba iii juan carlos ruiz garcia laas cnrs miyamoto ibm university tsukuba clemson university eric university chile indirect great influence way thinking 
doctor james gosling sun microsystems gave chance join table breakfast talk encouraged contribute java community 
financially acm supported join oopsla acm conferences 
laas cnrs supported research toulouse france 
sun microsystems supported visit firm silicon valley usa 
thesis project conducted mainly university tsukuba ibaraki japan partly tokyo institute technology tokyo japan 
iv contents limitations object orientation 
problems program transformations 
development costs translator 
transformational systems 
goal higher abstractions powerful transformations class object model approach 
related 
macro systems preprocessor toolkits 
reflection 
compile time mops meta object protocols 
thesis ation 
class object model motivating examples 
implementing adapter classes 
implementing proxy classes 
ordinal transformational systems 
modeling object oriented programs class objects 
representing data type 
apply transformations 
openjava problems ordinary macros 
programmable macros 
representation object oriented programs 
openjava 
macro programming openjava 
class objects 
class object api details 
type driven translation 
translation mechanism 
contents vi syntax extension 
metaclass model openjava 
related 
summary 
javassist extensions reflection ability java 
javassist 
implementations structural reflection 
load time structural reflection 
javassist api 
examples 
binary code adaptation 
behavioral reflection 
remote method invocation 
related 
summary 
addistant addistant 
design goal 
remote 
object allocation 
bytecode delivery 
implementation issues 
single system image 
bytecode modification 
distributed swing applications 
policy file 
performance measurement 
related 
summary 
list figures structure adapter pattern 
structure proxy pattern 
scattered spreading information program 
translation naive mop 
application macro openjava 
macro openjava 
translatedefinition 
replacement class instance expressions 
example syntax extension openjava 
meta program ed suffix 
class exemplar 
execution time reification reflection 
vii list tables member methods ojclass non class types 
member methods ojclass introspection 
member methods ojclass modifying class 
basic methods ojmethod 
member methods ojclass introspection 
member methods place macro expansion applied 
methods ctclass introspection 
methods introspection 
methods alteration 
methods 
applicability approaches 
feature proxy class class widget 
remote method invocation 
window drawing 
response time seconds mouse click 
size data kbyte exchanged network 
viii chapter expert programmers forced develop large complicated programs strong desire write codes viewpoints runtime efficiency understandability expect translator generate code just fit needs possible 
fitting usually requires complicated customization translator done experienced compiler experts programmers reflect ideas translators easily especially programmer demands quality practical programming tools severe 
situations lead necessity develop flexible approach specific programmers reflect experience knowledge translators 
technology enables reuse larger software components means reflect experiences actual programming 
reuse technologies available emergence object oriented paradigm simula dynamic binding polymorphism classes widened applicability reusable code pieces 
mechanisms enable inversion control reuse components allows build framework 
larger component main system design reusable object oriented framework addition reusable sub systems 
reuse defined program code modules regarded reduce cost software development keeping programmers away continuous rediscovery concepts software industry 
class object oriented modularization encapsulate design decisions perfectly especially crosscut module structure program code pieces crosscutting program tangle codes scatter entire program classbased modularization eventually violated 
kind violation may happen modern network programming involving distribution security chapter 

address solve crosscutting problems losing object oriented framework appearance runtime performance 
cope problems transformational system embed crosscutting code entire program automatically hide scattered code appearance 
runtime performance achieved transformational approaches inherently produce necessary elaborate code expert programmer experiences 
purpose propose class object model transforming object oriented programs develop powerful transformational systems compiler experts object oriented programming experts 
proposed class object model data model representing logical structure object oriented program logical alternations 
order ease description transformational systems allow users describe transformations programs intuitive notions object oriented programming notions compiler implementations 
thesis discloses design implementation practical systems proposed class object model openjava javassist general purpose program transformation systems addistant special purpose system support distributed programming :10.1.1.1.8863
viewpoint reflection transformational systems regarded reflective systems providing architectures structural reflection avoiding runtime overhead general reflection 
limitations object orientation object oriented modularization classes powerful fails encapsulate design decisions crosscut module structure program 
code pieces crosscutting program tangle code scatters program 
example crosscutting design decision objects distribution network 
code related concerns objects distribution tangled code scatters number classes 
lack modularization implies low reusability low maintainability code pieces 
programmers change decomposing points program distributed environment reducing overhead network communication change design decision brings modification remote local object allocation code scattering program 
modify number code pieces implementing simple change distributed design decision 
responsibility low reusability weighs designer problematic program language programmers chapter 
describes program 
impossible give settlement design long language 
design patterns give sophisticated designs solving design problem design pattern offers benefits implies additional drawbacks program 
example preserve maintainability design structure algorithm non distributed part program typical represent remote object proxy object 
design known proxy pattern enables writing simple clients code remote objects remote objects local objects 
describing proxy class tedious task programmers provide lots proxy classes class instances remotely accessed 
special compilers automatically generates proxy classes original classes proposed addressing modularization limitation object oriented languages 
example distributed programming distributed allocation coding 
factory pattern allows write centered code controlling instance allocations factory class 
change policy distribution objects overriding factory methods subclass factory class 
design class factory role provide number factory methods combinations instantiated classes contexts creating instances 
write redundant code tedious error prone task 
software industry needs flexible fine grained modularization mechanism software complexity software increases drastically computing power massive storage pervasive network infrastructures growing heterogeneity computing platforms available 
important challenges enhance fundamental support reuse object orientation order draw abilities frameworks design patterns techniques reuse software 
application frameworks design patterns techniques existing reuse mechanism object oriented application frameworks object oriented design patterns suffers limitation base object oriented models provided object oriented programming languages 
limitation simple object oriented languages class mechanisms known domain specific language extensions known solve problem 
language specialized language allows solutions expressed idiom level abstraction problem domain 
modularization mechanism supplied quite suitable reuse 
multipurpose super rich language providing specific application domain solution application domain 
di chapter 
rectly supports programmers specific application domains expressive applications 
order achieve suitability applications language desired facilities supporting primitives application domain 
multi paradigm language supports tons language primitives tends complex specifications learn 
support applications unknown language designed 
problems program transformations choice free limitation language extend language desired features 
implement extension translator 
transformation mapping programs programs implementation language extension implement demand 
krueger transformational systems different approaches software reuse 
implementation transformation kind software library applied software 
approach reusable software transformations provide flexible reusability approaches decomposing points software modules freely definable transformational approach 
development costs translator developing transformation reusable unit tends cost relatively approaches reusability developed units 
naive system lifted abstraction level transformation reduces difficulty flexibility modularization advantage transformational approach software reuse 
instance define macro simple limited just substitution keyword keyword followed parameter variables 
developing translators stand programs scratch effort intensive way building translators 
design implement internal source representation code performing analysis optimization generation scratch 
case translator expects input text form need build lexer parser converting source text internal representation 
lexer parser generated tools lex yacc 
piece reusable infrastructure available approach 
addition large effort needed build translator scratch approach impairs integration different notations development chapter 
tools 
translator uses internal source representation provide interfacing facilities 
result get language landscape consisting islands domain specific languages 
typically implement translator follows 
input internal representation source form text translator needs parse text internal representation 
cases internal program representation form syntax tree 
examples representations data control flow graphs 

code analysis analyzes code obtain information program data control flow 
needed check structure input program choose apply adequate transformations 

transformation performs required transformations internal program representation 

output internal representation needs transform internal representation back textual representation 
class output facilities code generation backends generate 
transformational systems transformational systems support system development translators 
transformational system provides toolkits frameworks partial transformation processes commonly translators 
transformational systems consist elements data structure internal program representation built data structure representing program save translator developers providing selves 
code analysis facilities transformational systems provide code analysis facilities data control flow analysis 
needed check structure input program guide selection appropriated transformations 
transformation engine called rewrite engine transformation engine applies user provided transformations internal program representation 
responsibilities transformation engine scheduling transformations determining order applying transformations 
chapter 
input output facilities internal representation source form text need parser transform internal representation 
various transform internal representation back textual representation 
class output facilities code generation backends generate machine code target platform 
class input output facilities editors allow directly edit internal representation render different ways 
provided intentional programming system 
goal higher abstractions powerful transformations goal thesis provide design model high level abstractions building object oriented transformational systems 
preserving expressive power fully featured transformational system transformational system give way simply intuitively describe object oriented program transformations 
transformational system simple descriptions object oriented program transformations provide declarative data format internal program representation format syntax tree format procedural data control flow graphs suitable representing object oriented logical structure program 
analysis facilities transformational systems provide code analysis facilities suitable capturing mechanism base object oriented language 
event driven style rewrite engine determining apply transformations complicated task automated 
abstracted input output facilities fetching source files program hidden 
class object model approach higher abstraction design model required system program transformation programmers simply write metaprogram dealing large complex code transformation 
especially number transformations typical object oriented program require highly abstracted data model directly deal objectoriented logical structure program 
chapter 
class object model proposed thesis gives logical class representation class declaration program source 
design model captures declarative construct classes including inheritance mechanism access controlling data hiding 
supporting callee side transformation addresses polymorphic mechanism dynamic binding 
approach translator program directly manipulate important object oriented language constructs declaration inheritance encapsulation access control polymorphism dynamic binding 
simply intuitively describe object oriented transformations transformational systems designed model 
related translator generator program takes higher level specification piece software produces implementation 
piece software large software system component class procedure 
approach software reuse researched generators cutting edge implementation technologies include metaprogramming aspect oriented programming intentional programming 
krzysztof czarnecki ulrich eisenecker tied kinds closely related researches concept generative programming 
thesis stream 
macro systems preprocessor toolkits macro systems typical systems manipulating source text transformation early days 
lisp macros scheme macros known powerful macro systems programmers describe transformation process procedural manner languages 
traditional lisp style macro systems metaprogram macro needs handle syntax tree ast source text piece original program 
designed implementing small localized transformations 
java syntax extender adds java language macro facility similar dylan offers fully procedural macro engine 
programmers keyword writing code extended syntax 
define translator implementing extension translator bound keyword 
translator transforms code written extended syntax 
call type applying macros keyword driven macro application 
typical macro macro system applied java 
metaprogram handles code form skeleton syntax tree insist fewer categories chapter 
typical ast represents basic shapes distinctions necessary macro processing 
translator transforms code piece library providing syntactical pattern matching code construction utilities 
jakarta tool suite set precompiler compiler tools extending java domain specific constructs 
main tools jak bali 
jak supports definitions ast constructors 
asts created typed code quotes manipulated ast cursors library tree traversing left right 
bali parser generator users create syntactic extensions familiar bnf style regular expression repetitions 
result parsing ast modified tree walk 
large ast hard handle fixed traversal style 
epp extensible preprocessor kit java 
application framework preprocessor type language extension systems 
parser epp written recursive descent style provides hooks extensions 
hooks extension programmer introduce new features possibly associated new syntax 
grammar rules handled modular way possible remove original grammar rules standard java 
epp enables preprocessor programmers write extension separate module called epp plug ins 
plugins cause collision user incorporate multiple plug ins epp simultaneously 
fact powerful locally limited translation programmers write recursive descent parser 
reflection reflection model language extension 
concept reflection originally proposed smith lisp 
generally kinds functions 
introspection 
introspection mechanism obtain information program program 
change behavior implementation program program 
program performs reflective computation introspection called meta level program program reflective computation performed called base level program 
generally difficult archive fully available execution overheads metalevel computation 
reflection mechanisms programmers handle behavior program class language string integer boolean 
reflection objectoriented programming usual provide class metaclass representing instance objects metaobjects non level things 
software engineering viewpoint reflection tool chapter 
tion concerns letting programmers write program higher level abstraction modularity 
reflection technique changing program behavior program 
example number reflective systems provide metaobjects intercepting object behavior method invocations field accesses 
metaobjects weaving programs separately written distinct aspects application algorithm distribution resource allocation user interface single executable program 
previous reflective systems satisfy requirements software engineering 
abstraction provided metaobjects intercepting object behavior easy understand implementing limited kinds separation concerns 
type reflection involves runtime penalties 
reflective systems enable fine grained program weaving perform reflective computation possible compile time avoiding runtime penalties 
point define interface metaobjects realize mechanisms called metaobject protocol mop 
mops simply designed implemented provide interpreters executional environment 
source program run interpreter modify interpreter change behavior 
reflection mechanisms fully provided method design implementation causes serious overhead execution 
runtime reflection clos common lisp object system mop exemplary model provide fully functional reflective support language 
open adaptable implementation modified provide features part standard clos behavior 
employs class metaobjects metaobjects objects 
currying technique allows metaobjects clos mop partly run compile time rest computation metaobjects performed runtime 
metaobject selected source program determined runtime 
abcl compilation framework object oriented reflective languages 
framework meta level language exposed programmer pure meta circular interpreter organized objectoriented way traditional approaches 
interpretation overhead effectively eliminated compiler technique partial evaluation 
programmers write meta program easily system consider execute compile 
chapter 
implementing effective partial evaluator difficult 
fact effective java 
reflection java java provides limited reflection mechanisms 
java reflection api enables introspection 
class loader api enables 
researches reflection java 
java core reflection api provides type safe api supports introspection classes objects current java vm virtual machine runtime 
api construct new class instances new arrays access modify fields objects classes invoke methods objects classes access modify elements arrays programmers want easily handle classes unknown programming time order provide applications debugger javabeans java object serialization 
applications needs getting information classes members classes members kind information unavailable compile time impossible write program unknown classes strongly typed languages api 
java reflection api programmers handle classes fields methods constructors objects 
instance metaobject get name class invoke method object code object unknown 
class unknown getclass field field getfield name string name string field get api refined introspection runtime especially security issues runtime mechanism 
version standard java java reflect proxy provided 
java vm uses class loaders load class files create class objects 
class loaders instances subclasses class classloader chapter 
provided java api programmers define new subclasses java program 
subclass classloader programmers change behavior program modifying loaded bytecode 
execution overheads loading modifying bytecodes small useful 
applications demonstrated liang kirby 
changing source class files remote host network easy dynamic class loading mechanism difficulty programming easy manipulate bytecodes directly 
extended java interpreter allows structural behavioral reflection 
system consists os application program base system meta system 
computation base system raises events events delivered meta system 
meta system evaluates events reacts specific manner 
events handled synchronously 
base level computation suspended meta object processes event 
gives meta level complete control activity base system 
happens depends entirely meta object 
base object invoke method meta object directly 
called explicit meta interaction control meta level base level 
limiting point alteration behavioral reflection succeeded achieving efficient execution applications comparatively runtime mop 
allow syntax extensions language 
compile time mops meta object protocols version provides extensible language 
translation performed type objects classes 
higher level languages basic constructs complicated compilers basic constructs class object oriented languages objects classes methods kind translation controlling effective extending behavior objects needs local translation scattered program 
easy write translation class declaration 
gives programmer part ast syntax tree translate 
gives contextual information parse tree suitable handling object oriented semantics 
thesis organization rest thesis organized follows 
chapter give concept class object model program transformations 
chapter 
implemented program transformation frameworks model java 
transforming program source text written java programming language transforming program java byte code compiled code direct execution java virtual machines 
framework named openjava javassist :10.1.1.1.8863
chapter describes design implementation openjava macro system employing class object model source text source text transformation 
chapter describes design implementation javassist bytecode editing tool employing class object model bytecode bytecode transformation 
systems designed general purpose transformations object oriented program designed transformational system specially targeting support distributed programming 
system named addistant build top javassist 
chapter describes design implementation addistant 
addistant proof expressing power transformational systems class object model constructing non trivial relatively large application 
thesis concludes projection chapter 
chapter class object model class object model proposed thesis representation program transformations higher level abstraction 
data model directly represents logical structure class type driven application transformation 
focusing thesis object oriented languages mechanism class inheritance 
including simula founder object oriented languages object oriented languages share language constructs 
popular object oriented languages smalltalk java 
core concept proposing model applicable transformations programs object oriented languages classes inheritance java explanation object oriented program systems implemented java demands support programming design patterns motivation object oriented transformations 
design patterns help developers choose design alternatives system reusable avoid alternatives compromise reusability 
description communicating objects classes pattern polished number times long time 
programmers designers apply patterns program adequately say design pattern sophisticated particular context 
problems coding overhead implementing design pattern address programming support address changing design program 
chapter show motivating examples represents typical requirements object oriented program transformations 
describe core concept design class object model 
chapter 
class object model motivating examples design patterns useful guidelines writing objectoriented programs programs written design patterns complex errorprone structure programs easy understand 
programmers design patterns write annoying code implement patterns concept design pattern orthogonal programming languages smalltalk 
design patterns just descriptions apart code line code explicitly represents design pattern program role design pattern class plays 
number researchers argued problems proposed syntax extensions extended language constructs help design pattern users write programs improve readability programs written design patterns 
order support programming kinds specific application domains distributed programming extended languages useful 
languages round power applications suitable applications domain 
achieving suitability applications language desired mechanisms supporting primitives application domain 
multi paradigm language supports mechanisms language primitives tends complex specifications learn 
extensible language programmers choose appropriate language mechanisms demand meets 
programmers may add new extension new application domain 
rest section shows example applications need support extended language mechanisms motivate provide extensible language 
implementing adapter classes suppose programmer adapt class vector listing interface stack listing declared follows listing vector java public class vector boolean isempty enumeration elements object 
void addelement object 
listing stack java public interface stack chapter 
class object model boolean isempty enumeration elements object peek void push object object pop adapter pattern case convert interface class interface clients expect 
adapter lets classes incompatible interfaces 
shows structure adapter pattern 
client uses interface target request adaptee adapter request uses adaptee 
request adaptee structure adapter pattern 
interface stack corresponds adaptee target respectively 
adapter pattern programmers write class correspondent adapter listing java public class implements stack private vector vector boolean isempty return isempty enumeration elements return elements object peek return void push object return addelement object pop 
class extends class vector interface stack 
class subclass class vector single adapter may vector subclasses 
case programmers faced problems writing class plays role adapter 
problems chapter 
class object model 
class written adapter adapter pattern difficult find fact source code 
design pattern 
role class 

programmers add field holds vector object constructor accept 
isempty elements shared class vector class programmers repeatedly write code 

programmers reuse part implementation apply adapter pattern coding design pattern reusable 

body method peek method invoked vector object value obtained invocation returned 
trivial operation object appears method push 
describing operations boring task errorprone 
problems design patterns problems reported number researchers 
bosch called problems traceability loss self problem reusability implementation overhead 
implementing proxy classes proxy pattern distributed programming provide surrogate placeholder object control access 
shows structure proxy pattern 
client request 
uses uses interface subject request 
proxy request request request 
structure proxy pattern 
making class window accessible remotely proxy class window proxy provided proxy pattern follows chapter 
class object model listing window java public class window extends component void component int direction boolean 
listing java public class extends window void component int dir int classid objectid object args new object new integer dir broker invoke classid objectid args boolean int classid objectid object args new object return broker invoke classid objectid args boolean equals object obj int classid objectid object args new object obj return broker invoke classid objectid args 
surrogate window object class provide interface window include equals method window implicitly inherited superclass component 
method implement packing method arguments communication object request broker 
see lot similarity methods programmers write scratch programming supports 
code translator support distributed programming common technique helping programmers write program easily 
java systems support distributed object programming 
system provides compiler transforming source program written ordinal java works distribute environment run ordinal java vm virtual machine 
instance standard java rmi developed sun microsystems provides compiler provides compiler 
systems programmers describe class representing object produced works remote systems object chapter 
class object model exists local system 
write program handling remote objects considering communicate objects network 
achieve transparency programming remote objects compilers accepts source program written local object ordinal way produce proxy class representing actual communication remote systems server skeleton class working remote systems 
problem provide new compiler new system supporting distributed programming 
research level proposal distributed systems 
researchers implement new compiler provide proposing systems 
industry lot distributed systems 
ordinal transformational systems ordinal syntax tree representation easy implement transformations spreading source program localized translator 
example easy write metaprogram adding method certain name case methods name class 
design preprocessors order invoke method translate node objects parse tree fixed post order pre order 
design preprocessor difficult meta programmers translate part parse tree information part parse tree 
definition fields methods class declarative object oriented languages availability information fixed post order pre order parse tree 
furthermore inherited fields methods described local parse tree directly 
class method may distinguishable processing source program 
example translating part class panel easy test class panel method validate method validate may defined part translated may inherited superclass container class panel 
consequently localized translators handle examples shown handle application examples handled lisp macro advanced system 
syntax driven translation define translate program order implement desiring behavior 
case change regular method invocation invocation method object remote com chapter 
class object model class validate class container extends container graphic gc class panel void extends add container class panel void remove extends container graphic gc void validate void add graphic gc void add scattered spreading information program 
puter programmers define meta level program implementing algorithm source code translation program thomas translated program call method invoke object network connection access remote server remote invoke new object thomas current preprocessors programmers represent algorithm translation transforming parse tree ast way defining translate varies system 
suppose language system simplest compile time mop meta object protocol 
mop model follows node parse tree metaobject 
classes varies kinds syntactic elements variable declaration expression statement 
metaobject method translate transforms corresponding part parse tree returns transformed 
compiling executable code system invokes method translate metaobject root parse tree method translate recursively root leaves 
order implement language extension programmers redefine classes chapter 
class object model methodcall translate translate number translate ast translate translate translate 
translation naive mop 
ast node metaobject method call method translate returns parse tree representing desired behavior 
instance example implemented defining class listing substituting regular class method call listing 
listing class default method call metaobjects class methodcall implements expression ref string name expressions args methodcall expression ref string name expressions args ref ref name name args args expression translate arguments arguments translate return listing class customized method call metaobjects class extends methodcall 
methodcall translate expression expr new classname remote new object args expressions new expressions ref name methodcall result chapter 
class object model new methodcall expr invoke return result translate natural users want remote objects non remote local objects source program 
switching translations naive mops described difficult distinguish syntactical difference semantical difference 
example method call expressions code string name info getname remote name naive mops difficult access info remote method invocation access remote regular 
modeling object oriented programs class objects translator handle object orientation order provide code generation modification addressing problems stated previous section transformations 
class object model proposed thesis model metaprogramming interfaces metaprogram directly state object orientation 
section describes treated model 
classes play important roles logical structure program object oriented program written class languages java 
classes declarative language constructs provide declarative methods fields attributes 
data structures syntax tree raw bytecode instructions suitable directly describing object oriented high level transformation metaprogram 
addition ability directly handling data flows addressed ordinal program transformation systems object oriented program transformation requires direct support declarative language constructs 
class object model data model representing transformations data type denoted class 
class object instance class object model aspects 
logical structure class transformation framework suitable object oriented program transformations 
chapter 
class object model representing data type object oriented programs objects 
object packages data procedures operate data 
procedures called methods 
object performs operation receives message client 
messages way get object execute operation 
interfaces fundamental object oriented systems 
objects known interfaces 
way know object ask going interface 
object interface says implementation different objects free implement requests differently 
means objects having completely different implementations identical interfaces 
types operation declared object specifies operation name objects takes parameters operation name objects takes parameters operation return value 
known operation signature 
set signatures defined object operations called interface object 
object interface characterizes complete set requests sent object 
request matches signature object interface may sent object 
type name denote particular interface 
speak object having type window accepts requests operations defined interface named window object may types widely different objects share type 
part object may types widely different objects share type 
part object interface may characterized type parts types 
objects type need share parts interfaces 
interfaces contain interfaces subsets 
say type subtype interface contains interface supertype 
speak subtype inheriting interface supertype 
class object oriented language programmers describe particular interface declaring type 
speak object having type window accepts requests operations defined interface named window object may types widely different objects share type 
part object interface may characterized type parts types 
objects type need share parts interfaces 
interfaces contain interfaces subsets 
say type subtype interface contains interface supertype 
speak subtype chapter 
class object model inheriting interface supertype 
java programmers reserved words class interface declaring types 
object class defines data behavior 
class kinds members member classes fields data variables associated class objects 
fields store results computations performed class 
methods contain executable code class 
methods built statements 
way methods invoked statements contained methods ultimately directs program execution 
inheritance major benefits object orientation ability extend subclass behavior existing class continue code written original class acting instance subclass 
original class known superclass 
extends class create new class new extended class inherits fields methods superclass 
subclass specifically override behavior superclass subclass inherits behavior superclass inherits fields methods superclass 
addition subclass add new fields methods add new behavior 
look example extending class 
extends point class represent pixel shown screen 
new pixel class requires color addition coordinates declared point class pixel extends point color color public void clear super clear color null pixel extends data behavior point superclass 
pixel extends data adding field named color 
pixel extends behavior point overriding point clear methods 
pixel objects code designed point objects 
method expects parameter type point hand pixel object just works 
point code pixel hand 
feature known polymorphism single object chapter 
class object model pixel poly forms morph object point object 
pixel behavior extends point behavior 
extended behavior entirely new adding color example restriction old behavior follows original requirements 
example restricted behavior objects live inside kind screen object restricting dimensions screen 
original point class forbid restrictions coordinates class restricted range violate original class behavior 
extended class overrides behavior superclass providing new implementations inherited methods 
extended class defines method signature return type method superclass 
pixel example override clear obtain proper behavior pixel requires 
clear pixel inherited point knows point fields obviously know new color field declared pixel subclass 
dynamic binding request sent object particular operation performed depends request receiving object 
different objects support identical requests may different implementations operations fulfill requests 
run time association request object operations known dynamic binding 
dynamic binding means issuing request doesn commit particular implementation run time 
consequently write programs expect object particular interface knowing object correct interface accept request 
dynamic binding lets substitute objects identical interfaces run time 
substitutability known polymorphism key concept object oriented systems 
lets client object assumptions objects supporting particular interface 
polymorphism simplifies definitions clients decouples objects lets vary relationships run time 
member class object accessible class object understanding debugging maintaining programs impossible task 
contracts classes relied piece code directly access field change way violate contract 
strengths object oriented programming support encapsulation data chapter 
class object model hiding 
achieve need way control access members class interface access class interface 
java control specified access modifiers class interface member declarations 
private members declared private accessible class 
package members declared access modifier accessible classes package class 
protected members declared protected accessible subclasses class classes package class 
package members declared public accessible class accessible 
available methods differs depending class class objects accessed 
apply transformations controlling scope translation important 
system provide ability apply translation pieces programs satisfy conditions restricted region programs 
incorporate extensions language system control scope translation extension unexpected collisions extensions occurs 
scope control programmers carefully define meta program compatibility extensions 
specified system behaves collision occurs 
type driven translation extending behavior class useful programmers translation applied code pieces related class 
type driven translation mechanism translation scope control 
mechanism translations performed types object classes 
possible design mechanism describe metaclass define transformations instances base classes 
base class corresponds instance metaclass 
default metaclass defined translation 
meta programmers define new subclass default class implement desiring extensions specify relation new metaclass appropriate classes 
system applies translation program pieces objects instantiates class related metaclass 
chapter 
class object model simple base level code declaring class hello 
listing hello oj public class hello instantiates public string say return hello world notation class instantiates specifies class related metaclass class object representing class instance class result translation objects type performed definition class class defined change behavior method call instance class object prints called method name purpose debugging 
notation listing hello objects additional behavior printing method name called 
point view extending java object oriented language natural switch extension type objects 
believe method scope control best ways alternatives choice translation scope controls delegation mpc system mixins epp pattern matching 
scope controlling method founded demonstrated useful applications chiba 
translation callee side caller side region source code translated part related object discussed 
parts source code categorized point view 
categories relation object 
callee side declaration class 
caller side accesses object performed occurs 
non related parts parts source code category protected translation object 
part callee side class declared field declarations method declarations constructor declarations described 
rest caller side accesses object fields methods constructors class performed 
chapter 
class object model implement transformation method print name invocation candidate translate method declaration declaration class hello program follows public class hello public string say system println say called string result original say system println done return result private string original say return hello world order change behavior hello objects candidate translate part program methods class hello called 
possible achieve purpose metaclass verbose class callee side translation translating code hello new hello string str say code hello new hello string str invoke hello say function string invoke hello say hello obj system println say called string result obj say system println done return result applicability kind translation different example able achieved side translation 
fact trade offs caller side translation callee side translation 
limitation callee side translation 
order large numbers fine grained objects efficiently programming technique give shared objects objects generated time chapter 
class object model shared objects interchangeably 
technique known design pattern 
suppose simple program providing feature follows public class image bitmap private font int height bitmap height static font null null public static font int height height height null height new height return height return new height case program saves system memory computation time providing method generated objects hiding constructor class 
order implement optimization transparent users caller side translation replace constructor invocation method call 
implementation impossible callee side translations 
problem caller side translation 
suppose class hello subclass class object 
class object instance method tostring return string object representing identical string object object class hello overrides method return string object hello 
execute program compiled run regular java environment object obj new hello system println obj tostring java vm prints follows hello means method tostring chosen active type object obj static type 
causes dynamic chapter 
class object model binding mechanism object oriented language 
compiletime type obj detected superclass object variable obj example 
generally impossible determine active type obj compile time 
caller side translation defined class hello system apply obj 
consistency changing behavior lost translation instance member accesses caller side useful purpose optimization keep consistency class static member accesses 
changing behavior object type callee side translation useful keep consistency translation 
system provide powerful callee side translation addition translating 
chapter openjava chapter presents openjava macro system developed java 
traditional macro systems designed non objectoriented languages difficult write number macros typical object oriented programming require ability access logical structure programs 
drawbacks traditional macro systems syntax trees representing source programs 
chapter points problem shows openjava addresses problem 
key idea openjava metaobjects originally developed reflective computing representing source programs 
reflection technique changing program behavior program 
software engineering viewpoint reflection tool separation concerns letting programmers write program higher level abstraction modularity 
example number reflective systems provide metaobjects intercepting object behavior method invocations field accesses 
metaobjects weaving programs separately written distinct aspects application algorithm distribution resource allocation user interface single executable program 
previous reflective systems satisfy requirements software engineering 
abstraction provided metaobjects intercepting object behavior easy understand implementing limited kinds separation concerns 
type reflection involves runtime penalties 
reflective systems enable fine grained program weaving perform reflective computation possible compile time avoiding runtime penalties 
hand typical tool manipulating program compile time macro system 
performs textual substitution chapter 
openjava particular aspect program separated rest program 
example macro system allows separate definition constant value rest program constant value number distinct lines 
lisp macro system provides programmable macros enables powerful program manipulation 
macro expansion done compile time macros imply runtime penalties 
abstraction provided traditional macro systems sophisticated macros deal textual representation program program manipulation depending semantic contexts program implemented macros 
chapter proposes macro system integrating features reflective approach words compile time reflective system behavioral reflection structural reflection 
key idea macro system called openjava macros meta programs deal class objects representing logical entities program sequence tokens syntax trees asts 
class objects textual semantic aspects program macros openjava implement fine grained program weaving previous reflective systems 
access semantic contexts needed macro expansion 
chapter presents openjava implement macros helping complex programming design patterns 
rest chapter section presents problem ordinary macro systems section discusses design implementation openjava addresses problem 
compare openjava related section 
section concludes chapter 
problems ordinary macros macro systems typical language extension mechanisms 
define macro system programmers specify symbol function call replaced expression replacement simple token substitution 
common lisp programmers write powerful macros 
powerful macros cover requirements object oriented languages programming 
programmable macros macros common lisp programmable macros 
specify replace original expression common lisp 
macro function receives ast syntax tree substitutes original expression 
macro system powerful object system common lisp clos implemented macro system 
chapter 
openjava programmable macros developed languages complex syntax ms macro systems macro functions written extended language providing special data structure representing asts 
users ms define new syntax expanded regular syntax 
parameter macro function receives ast code processed macro function 
essential issue designing programmable macro system data structure representing original source program 
essential issue specify apply macro source program 
systems employed asts 
mechanisms proposed 
trigger word specified macro 
example trigger word expressions expanded macro 
way macros trigger words 
instance impossible selectively apply macro expressions adding string objects 
macro systems provide fine grained control apply macro 
macro applied expressions statements matching pattern specified bnf 
epp macros applied specified syntax elements statements expressions 
need put trigger word front statements expressions 
representation object oriented programs macro systems asts representing source program asts best representation macros macros typical object oriented programming require different kind representation 
asts purely textual representation independent logical contextual information program 
example ast represents binary expression ast tells operator operands tells types operands 
writing macro possible asts macro expansion depends logical contextual information binary expression 
great demand macros depending logical contextual information object oriented programming 
example design patterns require relatively complicated programming 
require programmers repeatedly write similar code 

help programming researchers proposed extend language provide new language constructs specialized particular patterns 
constructs implemented macros implemented far custom preprocessor 
macros implementing constructs depend logical contextual infor chapter 
openjava mation programs implementable top traditional ast macro systems 
suppose write macro helping programming observer pattern describing dependency objects 
pattern java standard library called event listener model 
example java program displays menu bar define listener object notified menu select events 
listener object instance class implementing interface class implements void 
void return void return class declare methods event handling events menu cancel event simply ignored 
write macro automating declaration methods handling ignored events 
macro definition re written class follows implements void 
follows clauses specifies macro applied class definition 
declarations automated 
macro inspects methods declared interface implemented class 
inserts declarations methods class 
writing macro difficult traditional ast macro systems depends logical information definition class 
class definition large ast macro program interpret ast recognize methods declared 
macro program construct asts representing inserted methods modify original large ast include asts 
manipulating large ast difficult task 
reduce difficulties macro systems provide logical contextual information programs macro programs 
macro systems providing logical information 
example xl systems functional language object oriented language 
chapter 
openjava openjava openjava advanced macro system java 
openjava macro programs access data structures representing logical structure programs 
call data structure class objects 
section presents design openjava 
macro programming openjava openjava produces object representing logical structure class definition class source code 
object called class object 
class object manages macro expansion related class represents 
programmers customize definition class objects describing macro expansion 
call class class object metaclass 
openjava metaprogram macro described metaclass 
macro expansion openjava divided macro expansion class declarations callee side second expressions accessing classes caller side 
applying macros fig 
shows sample macro openjava 
adding clause instantiates just class name class declaration programmer specify class metaobject class instance metaclass sample program class object instance 
metaobject controls macro expansion involved 
declaration 
class instantiates extends implements 
application macro openjava metaclass inherit metaclass ojclass built class openjava 
translatedefinition fig 
method inherited ojclass invoked system macro expansion 
instantiates clause class declaration openjava creates instance metaclass indicated instantiates clause assigns instance class object representing de chapter 
openjava class extends ojclass void translatedefinition 
macro openjava class 
openjava invokes translatedefinition created class metaobject macro expansion class declaration 
translatedefinition declared ojclass perform translation subclass ojclass override method desired macro expansion 
example translatedefinition add new member methods class calling member methods ojclass 
modifications reflected source program final stage macro processing 
describing metaprogram method translatedefinition implementing macro observer pattern section shown fig 

metaprogram obtains member methods including inherited ones defined class invoking class object 
member method declared interfaces implemented class generates new member method doing adds class invoking addmethod class object 
void translatedefinition ojmethod int length modif modif isabstract ojmethod new ojmethod getname return addmethod translatedefinition class represented class object member method represented method metaobjects 
openjava classes member methods chapter 
openjava member fields constructors represented instances class oj class ojmethod respectively 
metaobject represent logical structures class member definitions 
easy handle compared directly handling large asts representing class declarations collecting information scattered asts 
class objects shown section problem ordinary macro systems primary data structure asts syntax trees far logical structures programs object oriented languages 
objectoriented languages java class definitions play important role logical structure programs 
openjava employs class object model originally developed reflective computing representing logical structure program 
class objects easy meta programs access logical structure program 
hiding syntactical information java programmers various syntax describing logically thing 
syntactical differences absorbed metaobjects 
instance notations declaring string array member field string string string array fields 
awkward write metaprogram syntactical differences member fields considered 
provides member methods gettype settype handling type member field 
gettype oj field metaobjects representing returns class object representing array type class string 
additionally elements grammar represent element logical structure language 
element edited edited 
instance member method ojclass modifying name class changes class name class keyword class declaration changes name constructors 
logically structured class representation simple asts arranged abstracted properly represent logical structure class definition 
data structure carefully designed corresponded grammar language chapter 
openjava logical constructs language classes member methods 
especially easy handle logical information program including association names types 
instance member method ojclass returns member methods defined class methods immediately declared class inherited methods 
contain type information definition super class accessible 
class object api details root class class objects ojclass 
member methods oj class obtaining information class shown tab 
tab 

cover attributes class 
openjava types including array types primitive types int corresponding class objects 
member methods shown tab 
metaprograms inspect type ordinary class 
tab 
gives methods modifying definition class 
metaprograms override translatedefinition ojclass calls methods executing desired modifications 
instance example shown fig 
adds newly generated member methods class addmethod 
table member methods ojclass non class types boolean 
boolean 
boolean 
ojclass returns class object type array components 
metaobjects obtained class objects method ojclass obtain superclass class returns class object class name string 
result metaprogram returned class object directly obtain information superclass 
openjava automatically generates class metaobjects demand classes declared chapter 
openjava table member methods ojclass introspection string returns package name class belongs 
string returns unqualified name class 
returns modifiers class 
ojclass returns superclass declared explicitly implicitly 
ojclass returns declared superinterfaces 
returns static initializer statements 
returns declared fields 
ojmethod returns declared methods 
returns constructors declared explicitly implicitly 
ojclass returns member classes inner classes 
ojclass 
chapter 
openjava table member methods ojclass modifying class string string name sets unqualified name class 
sets class modifiers 
ojclass ojclass sets superclass 
ojclass ojclass faces sets superinterfaces declared 
field removes field class declaration 
ojmethod ojmethod method removes method class declaration 
constr removes constructor class declaration 
field adds field class declaration 
ojmethod addmethod ojmethod method adds method class declaration 
constr adds constructor class declaration 
source file classes available form bytecode classes source code available 
returned value member method tab 
instance class 
class represents set class modifiers public final 
metaprograms care order class modifiers hides useless information 
class ojmethod return type ojclass represents logical structure method 
similarly class ojclass class member methods examining modifying attributes method 
basic member methods ojmethod shown tab 

type information obtained methods represented class object 
instance returns class object return type method 
feature ojmethod respectively represent member field constructor 
class return type member method class ojmethod represents statements method body 
instance consists objects representing expressions statements 
objects ast data struc chapter 
openjava table basic methods ojmethod string getname returns name method 
returns modifiers method 
ojclass returns return type 
ojclass returns parameter types declaration order 
ojclass returns types exceptions declared thrown 
string returns parameter variable names declaration order 
returns statements method body 
string string name sets name method 
sets method modifiers 
ojclass sets return type 
ojclass sets parameter types declaration order 
ojclass sets types exceptions declared thrown 
string sets parameter variable names declaration order 
sets statements method body 
chapter 
openjava tures contain type information 
thought logical structure statements expressions java represented asts 
logical structure class tab 
shows member methods ojclass handling logical structure class 
methods metaprograms obtain information considering class inheritance member hiding 
member methods implemented combining member methods tab provided convenience 
think providing methods significant viewpoint class objects represent logical structure program 
table member methods ojclass introspection ojclass returns interfaces implemented class superinterfaces interface 
boolean ojclass determines class interface superclass class interface 
ojmethod ojclass situation returns class available situation including declared inherited superclasses superinterfaces 
ojmethod string name ojclass types ojclass situation returns specified method available situation 
ojmethod string name ojclass types ojclass situation returns method name invoked arguments types available situation 
considering class inheritance mechanism member methods defined class member methods described class declaration inherited ones 
method metaobjects obtained invoking class object include methods explicitly declared class declaration methods inherited superclass superinterfaces 
accessibility class members restricted java member modifiers public protected private 
returns member methods available class specified argument 
instance specified class subclass package returns member methods public modifier 
chapter 
openjava fig 
metaprogram passes obtains member methods defined class 
type driven translation macro expansion openjava managed metaobjects corresponding class type translation said type driven 
example member method translatedefinition ojclass overridden translate class declarations specified classes callee side translation 
addition callee side translation ojclass provides framework translate code related corresponding class spreading program selectively caller side translation 
parts related certain class example instance creation expressions field access expressions 
take example macro enables programming pattern explain mechanism 
design pattern applied objects sharing support large numbers fine grained objects efficiently 
example macro supporting uses pattern need translate instance creation expression class glyph new glyph class method call expression class method returns object glyph correspondent argument generated creates new object return 
way program glyph objects automatically shares object glyph generating objects letter 
ordinary programming glyph objects pattern programmers explicitly write program creations glyph objects 
support macro instance creations syntax pattern automatically 
openjava kind macro expansions implemented defining metaclass applied class glyph 
ojclass fig 
method receives class instance creation expression returns translated expression 
system openjava examines source code apply member method glyph instance creation expression perform macro expansion 
member method receives object representing class instance creation expression environment object representing environment expression 
environ chapter 
openjava expression expr environment env args expr return new methodcall args replacement class instance expressions ment object holds name binding information type variable scope expression 
openjava uses type driven translation enable comprehensive macro expansion partial code spreading various places program 
macro systems object oriented programming languages needed translate class declaration simply translating expressions class needed 
openjava defining methods selectively apply macro expansion limited expressions related classes controlled metaclass 
kind mechanism seen ordinary macro systems systems 
tab 
shows primary member methods ojclass overridden macro expansion caller side 
table member methods place macro expansion applied member method place applied macro expansion translatedefinition class declaration class instance allocation expression array allocation expression class name method class expression field read expression field write expression casted expression type casted expression type translation mechanism source program processor openjava 
analyzes source program generate class object class 

invokes member methods class objects perform macro expansion 

generates regular java source program reflecting modification class objects 
chapter 
openjava 
executes regular java compiler generate corresponding byte code 
order translations methods ojclass name start expand performs translation affect expressions source program declaring class expressions may translated translatedefinition class object callee side translation 
different class objects affect part source program 
openjava resolve macro expansion system invokes translatedefinition callee side translation apply caller side translation source code class declarations applied callee side translation 
design metaprogram considering specified order translation 
rule translatedefinition changes instance creation expression class defined metaclass performed 
openjava system performs translatedefinition superclasses system performs subclasses superclasses 
class definition strongly depends definition superclass translation class varies depending definition superclass 
settle definition superclasses system translates source program declaring superclasses 
additionally cases definition class affects result translation class openjava translatedefinition explicitly specify translatedefinition performed 
case dependency relationships translation macro expansions consistent order translation specified address translation results 
dealing separate compilation java classes program exist source code byte code class file 
source code class system specify metaclass instance perform appropriate instance creation expressions openjava automatically preserves meta level information metaclass name class processes callee side translation class 
preservation implemented translating information string held field special class chapter 
openjava compiled byte code 
system uses byte code obtain necessary meta level information process source code class 
additionally request system preserve customized meta level information class 
meta level information preserved special attributes byte code 
openjava information compile time runtime 
order save runtime overhead chose preserve information separated byte code loaded jvm runtime 
syntax extension openjava macros metaclass introduce new class member modifiers clauses starting special word limited positions regular java grammar 
newly introduced clauses valid parts related instances metaclass 
class declaration callee side positions allowed introduce new clauses block member declarations block method body method declaration field variable field declaration 
class declarations caller side allowed position name class 
limited positions new clauses system parse source programs conflicts extended grammars 
care conflicts clauses 
class instantiates adapts vector stack 
example syntax extension openjava fig 
shows example source program macro metaclass supporting programming adapter pattern 
metaclass introduces special clause adapts programmers write special description adapter pattern class declaration 
adapts clause fig 
adapter class stack class vector 
information clause chapter 
openjava class objects representing performs macro expansion 
class objects semantical information added new clause recognized regular java source code 
static string keyword keyword equals adapts return new new new new new new return null meta program customized suffix introduce adapts clause implement member method metaclass shown fig 

member method invoked system needed returns object representing syntax grammar special word 
instance class implements recursive descendant parser ll analyzes token series generate appropriate ast 
system uses objects obtained invoking complete parsing 
objects openjava provides class library subclasses parsers regular java syntax elements synthesizing parser tying repeating selecting objects 
define desired clauses library implementing new subclass 
metaclass model openjava class managed single metaclass openjava 
useful programmers apply metaclasses class implement feature problem conflict translation metaclasses 
metaclass class manage subclass metaclass perform callee side caller side translation specified metaclass source program declaring 
member classes local classes anonymous classes java language instance metaclass openjava 
programmers may apply desired metaclass classes 
chapter 
openjava related number systems class object model representing logical structure program krs clos mop smalltalk 
reflection api java language uses model reflection api allow change class objects allows inspect 
furthermore reflection api uses class metaobjects making class definition accessible runtime 
hand openjava uses class objects macro expansion compiletime 
uses class object model 
openjava inherits features type driven translation mechanism 
data structure mainly ast syntax tree 
mpc epp similar respect data structure 
mentioned section ast appropriate abstraction macros frequently objectoriented programming 
summary chapter described openjava macro system java providing data structure called class objects 
number research activities done enhancing expressive power macro systems 
research stream 
openjava macro system data structure representing logical structure object oriented program 
easier describe typical macros object oriented programming difficult describe ordinary macro systems 
show effectiveness openjava implemented macros openjava supporting programming design patterns 
chapter javassist chapter presents javassist bytecode editor developed java 
openjava javassist employs class object model proposed thesis 
javassist apply design class object transformations java bytecode compiled binary representation java program 
javassist handles bytecode transformations javassist limited compile time 
java programming language supporting reflection 
reflective ability java called reflection api 
restricted introspection ability introspect data structures program class 
java ability alter program behavior limited allows program instantiate class get set field value invoke method api 
address limitations java reflection api extensions proposed 
extensions enable behavioral reflection ability intercept operation method invocation alter behavior operation 
operation intercepted runtime systems extensions call method metaobject notifying event 
programmer define version metaobject metaobject executes intercepted operation customized semantics implement language extension specific application domain fault tolerance 
behavioral reflection provides ability alter behavior operations program provides ability alter data structures program statically fixed compile time languages lisp defined 
ability called structural reflection allows program change example definition class function record demand 
kinds language extensions require ability implementation implemented straightforward program behavioral chapter 
javassist reflection complex programming tricks needed 
simply implement language extensions chapter presents javassist class library enabling structural reflection java 
portability important java designed new architecture structural reflection implemented modifying existing runtime system compiler 
javassist java implementation architecture 
essential idea architecture structural reflection performed bytecode transformation compile time load time 
javassist allow structural reflection compiled program loaded jvm 
feature architecture provides source level abstraction users javassist deep understanding java bytecode 
architecture execute structural reflection faster compile time metaobject protocol openjava 
rest chapter overview previous extensions enabling behavioral reflection java point limitations extensions 
design javassist section show typical applications javassist section 
section compare architecture related 
section 
extensions reflection ability java java reflection api dose provide full reflective capability 
enable alteration program behavior supports introspection ability introspect data structures example inspecting class definition 
design decision acceptable implementing full capability difficult decline runtime performance 
implementation technique partial evaluation proposed feasibility technique java clear 
extensions java reflection api proposed 
avoid performance degradation extensions enable restricted behavioral reflection 
allow alteration behavior specific kinds operations method calls field accesses object creation 
programmers select operations alter behavior 
compilers runtime systems extensions insert hooks programs execution selected operations intercepted 
operations intercepted runtime system calls method object called metaobject associated operations target objects 
execution intercepted operation implemented method 
programmers define version metaobject implementing new behavior intercepted operations 
runtime overheads due restricted behavioral reflection low chapter 
javassist execution intercepted operations involves performance penalty rest program runs overheads 
especially hooks interception statically inserted program compilation runtime overheads lowered 
statically insert hooks reflective java performs source source translation compilation performs bytecode level transformation program loaded jvm 
internally performs bytecode level transformation customized jvm 
uses customized just time compiler jit improving execution speed inserted hooks 
hook insertion technique known applied languages 
restricted behavioral reflection useful implementing various language extensions kinds extensions intuitively implemented kind reflection 
example extensions binary code adaptation bca mechanism altering class definition binary form conform changes definitions classes 
suppose write program class library obtained third party 
example class calendar implements interface writable included class library class calendar implements writable public void write 
class calendar implements method write declared interface writable 
suppose third party gives new version class library interface writable renamed printable declares new method print 
program conform new class library edit definitions classes implementing writable including calendar class calendar implements printable public void write 
public void print write system interface calendar changed printable method print added 
bca automates adaptation automatically alters class definitions binary form configuration file specifying alter 
note method body print identical updated classes print implemented functionality provided write old version 
configuration file supplied library developer run program concern evolution class library 
chapter 
javassist unfortunately implementing bca behavioral reflection intuitive straightforward 
behavioral reflection directly provide ability alter data structures class definition construct new data structure reflective computation indirectly implemented 
example implementation bca behavioral reflection defines metaobject indirectly performing adaptation specified configuration file 
example metaobject associated calendar watches method calls calendar objects 
method print called metaobject intercepts method call executes computation corresponding print calendar object 
metaobject intercepts runtime type checking jvm recognizes calendar subtype printable 
recall java statically typed language original calendar subtype writable 
ability alter data structures program called structural reflection directly supported previous systems 
number language extensions easily implemented structural reflection behavioral reflection previous systems addressing extensions 
focused language extensions implemented altering behavior method calls 
javassist simply implement language extensions bca shown previous section developed javassist extension java reflection api enables structural reflection behavioral 
javassist new architecture structural reflection implemented modifying existing runtime system compiler 
implementations structural reflection structural reflection ability allow program alter definitions data structures classes methods 
provided languages smalltalk clos 
languages implement structural reflection support mechanisms embedded runtime systems 
runtime systems contain internal data representing definitions data structures class support mechanisms allow program directly read change internal data execute structural reflection correspondent data structures 
accept implementation technique javassist needs modify standard jvm portability important java 
furthermore naive application technique java cause serious chapter 
javassist performance degradation jvm technique difficult runtime systems employ optimization techniques static information executed programs 
program may altered runtime efficient dynamic recompilation required redoing optimization demand 
example method inlining difficult perform 
inlined method altered runtime structural reflection inlined code updated 
runtime system record code inlined 
spend large amount memory space 
example table technique typical implementations 
technique statically constructs method dispatch tables invoked methods quickly selected constant offset tables 
new method added class runtime dispatch tables may updated offsets tables may recomputed 
dynamic recompilation technique far gradually optimizing hot spots compiled code runtime assuming program changed runtime 
effectiveness dynamic recompilation assumption open question 
problem correctness types 
java statically typed language variable type bound object subclass program freely access change internal data jvm may dynamically change super class class 
change causes type error binding variable type object address problem extra runtime type checks restrictions range structural reflection needed 
load time structural reflection avoid problems mentioned designed new architecture structural reflection need modify existing runtime system compiler 
hand enables structural reflection program loaded runtime system load time 
javassist class library enabling structural reflection architecture 
java bytecode obtained compilation program stored class files corresponds distinct class 
javassist performs structural reflection translating alterations structural reflection equivalent bytecode transformation class files 
transformation modified class files loaded jvm alterations allowed 
javassist standard jvm may various optimization techniques 
javassist user class loader 
java allows programs define versions class loader fetch class file standard resource network 
typical definition class loader follows chapter 
javassist class extends classloader public class string name byte bytecode name return bytecode private byte string name read class file resource 
methods inherited class loader 
request jvm load class constructed bytecode array byte 
returned value class object representing loaded class 
class manually loaded instance loader classes referenced class loaded class loader 
jvm automatically calls class loader loading demand 
javassist helps shown obtain bytecode requested class 
regarded class library reading bytecode class file altering 
similar class libraries javassist provides source level abstraction knowledge bytecode data format class file 
javassist designed difficult wrongly produce class file rejected bytecode verifier jvm 
javassist api overview javassist api 
reification reflection step javassist create ctclass compile time class object representing bytecode class loaded jvm 
step reifying class accessible program 
stream inputstream reading class file local disk memory network ctclass new ctclass stream creates new ctclass object representing bytecode class read class file contains symbolic information reify class 
constructor ctclass receive string class name inputstream 
class name javassist searches class path finds inputstream reading class file 
call various methods ctclass object altering class definition 
changes class definition reflected chapter 
javassist bytecode represented object 
obtain bytecode loading altered class jvm method called object byte bytecode loading obtained bytecode jvm regarded step reflecting ctclass object base level 
javassist provides methods step 
example method compile writes bytecode output stream local file network 
method load directly loads class jvm class loader provided javassist 
returns class object representing loaded class 
recall class included java reflection api ctclass javassist 
note javassist provide framework specifying classes processed javassist 
programmer class loader freedom respect framework 
example class loader may process classes javassist specified configuration file read 
may process hard coded algorithm 
javassist allows user class loader define new class scratch reading class file 
useful program needs dynamically define new class demand 
ctclass object created follows ctclass new created object represents empty class methods fields methods fields added class javassist api shown 
called object returns bytecode corresponding empty class 
introspection javassist provides methods class represented ctclass object 
part javassist api compatible java reflection api javassist provide methods creating instance invoking method methods meaningless load time 
table lists selected methods introspection 
ctclass objects returned constructed class files class path 
represent original class definitions accept introspection alteration 
alter class ctclass object explicitly created new operator 
modifications object effect ctclass object returned 
example suppose chapter 
javassist table methods ctclass introspection method description string getname gets class name int gets class modifiers public boolean determines object represents class interface ctclass gets super class ctclass gets interfaces gets fields declared class gets constructors declared class gets methods declared class table methods introspection method description string getname gets field name ctclass get class declaring field int gets field modifiers public ctclass gettype get field type method description string getname gets method name ctclass get class declaring method int gets method modifiers public ctclass gets types parameters ctclass gets types exceptions method may throw boolean returns true method constructor boolean returns true method class initializer class inherits class object created new method added object modification reflected object returned ctclass object inherits ctclass object created new converted bytecode loaded jvm 
information fields methods provided objects separate ctclass object provided objects obtained objects obtained respectively 
information constructor provided ct method object 
table lists methods introspection 
chapter 
javassist table methods alteration method ctclass description void class public void class void remove final modifier class void string name change class name void ctclass change super class void ctclass change interfaces void 
add new constructor void add default constructor void 
add new method void addmethod 
add new method void 
add new wrapped method void 
add new field method description void field public method description void method public void instrument 
modify method body void 
substitute method body void 
substitute method body alteration difference javassist standard java reflection api javassist provides methods altering class definitions 
methods alteration defined ctclass table 
methods categorized methods changing class modifiers methods changing class hierarchy methods adding new member 
carefully selected satisfy design goals 
design goals 
goal provide source level abstraction programmers 
javassist designed programmers knowledge java bytecode 
second goal execute structural reflection efficiently possible 
goal help programs perform structural reflection safe manner terms types 
goal significant design decision programmers specify method body 
suppose new method added class 
sequence bytecode specifying body method programmers get great flexibility learn details bytecode 
achieve goal javassist allows copy method body existing method design decision restricts flexibility added method 
copied bytecode sequence adjusted fit destination method 
example bytecode chapter 
javassist accessing member variable contains symbolic type 
replaced class declaring destination method 
despite known quasi equivalence java source code bytecode correspondence source level bytecode level alterations straightforward 
hiding gap levels programmers part goal 
example renames class substitutes new name occurrences old name definition class including method signatures bodies 
modifying single constant pool item performs substitution 
constructor calls constructor class executes bytecode constructor modified bytecode contains symbolic name class declaring constructor 
modified indicate new name 
performs similar substitution 
called occurrences old super class name replaced new name constructors modified call constructor new super class 
exception substitution 
name original super class java lang object root class hierarchy perform substitution modifies constructors 
java lang object representing class 
example addelement java util vector takes parameter class java lang object super class java util vector means addelement takes instance super class 
second design goal reduce overheads due class loading javassist 
javassist implementing mobile agent system javassist inserts security check code bytecode javassist transform bytecode received network efficiently possible 
mobile agents frequently move hosts ignore loading time bytecode implementing mobile agents 
design decision programmers specify method body influenced second goal 
javassist source code specifying body added method 
source code compiled fly class loaded jvm 
naive implementation source code approach produce complete class definition including added method source level compile java compiler javac 
show implementation implies serious performance penalties 
achieve practical efficiency need special compiler quickly compile method body 
adopt source code approach limitations resources 
javassist allows copy pre compiled chapter 
javassist method body class 
approach imply overheads due source code compilation load time 
third design goal prevent programs wrongly produce class including type incorrectness 
achieve goal javassist allows limited kinds alteration class definitions 
general reflective systems impose restrictions structural reflection programs falsely collapse reflection 
suppose reflective system allows remove field class runtime 
instances class appropriate system simply discards value removed field instances 
erroneous bytecode produced javassist rejected bytecode verifier damage jvm 
restricting reflective capability javassist necessary awkward correct program producing erroneous bytecode 
reason javassist provide methods removing method field class cause type incorrectness method accessing removed method field 
javassist imposes restrictions class passed method changing super class 
new super class subclass original super class may methods implicitly cast instance class original super class 
course new super class final 
furthermore javassist provide method changing parameters method 
programmers recommended add new method name different parameters 
adding new member javassist provides methods adding new method class 
avoid abstraction performance problems mentioned addmethod receives object specifies method body 
signature addmethod shown void addmethod string name map name specifies name added method 
method body copied method method body copied existing compiled method source code compilation needed load time raw bytecode addmethod 
programmers describe method body java compile advance 
javassist reads bytecode compiled method adds class 
improves execution performance javassist compiler run load time 
chapter 
javassist method body copied class names appearing body replaced hash table map 
example programmers declare class public class extends java util vector public void add super addelement copy method add class method add ctclass class map new map put java lang string addmethod map class name java lang string substituted occurrences class name add 
added method follows public void java lang string super addelement javassist provides method adding new method 
allows generic description method body void int modifiers ctclass string name ctclass parameters ctclass exceptions body parameters specify modifiers return type method name parameter types exceptions method may throw 
body added method copied method specified body 
matter signature added method method specified body signature object object args value type fill gap signature signature added method implicitly wraps copied method body glue code constructs array actual parameters passed added method assigns args executing copied method body 
glue code sets constant value specified passed 
current version javassist integer value addmethod replaces occurrences name class declaring copied method 
class name appear source level corresponding bytecode may include 
chapter 
javassist string object specified constant value 
example constant value pass name added method 
value returned copied method body object object 
glue code converts value type specified 
returns converted value caller added method 
type conversion fails exception thrown 
methods added involve runtime overheads due type conversion single method body template multiple methods receiving different number parameters 
examples 
javassist provides method adding new field class void int modifiers ctclass type string fieldname string accessor init accessor null method adds accessor method returns value added field 
name accessor specified accessor 
parameter init specifies initial value added field 
initial value parameters passed constructor newly created object result call static method 
altering method body javassist allow remove method class provides methods changing method body 
substitute method body original body void map void param correspond addmethod respectively 
copies method body method class names appearing body replaced different names map 
copies method body wraps copied body glue code 
signature object object args value type javassist provides method modifying expressions method body 
instrument performs modification void instrument converter parameter converter specifies instrument method body 
object perform various kinds instrumentation 
table lists methods provided current implementation javassist 
chapter 
javassist table methods method description void change field access expression access different field 
void replace new expression static method call 
void replace field read expression static method call 
void replace field write expression static method call 
direct object replace specific kind expressions hooks invoke static methods executing expressions customized manner 
idea came operator overloading 
designed safely altering behavior operators new 
dot independently context 
example expressions instantiating specific class replaced expressions calling static method 
suppose variables represent class respectively 
program 
conv new conv create instrument conv instruments body method represented object expressions instantiating class new translated expressions calling static method create declared class create parameters new expression passed static method 
reflective class loader class loader provided javassist allows loaded program control class loading class loader 
program loaded javassist class loader includes class intercept loading self modify bytecode avoiding infinite recursion loading class intercepted interception prohibited 
load method ctclass requires program chapter 
javassist loaded javassist class loader methods javassist class loader 
java standard class loader allows self reflective class loading security reasons 
allowed program may change private fields public ones load time reading hidden values 
furthermore java program creates class loader loads class class loader loaded class regarded different class denoted name appearing program 
class loaded class loader loaded program 
javassist class loader javassist user class loader 
kinds usage javassist user class loader web server line 
security reasons applet usually prohibited user class loader 
write applet working javassist web server replacement user class loader 
classes applet loaded web server jvm web browser customize web server runs javassist processing classes sending web browser 
javassist includes simple web server written java basis customization 
extend perform structural reflection javassist 
program customized web server follows receive request web browser 
ctclass new ctclass requested class structural reflection needed 
byte bytecode send bytecode web browser 
sending requested class web browser performs structural reflection class algorithm example configuration file 
usage javassist line 
perform structural reflection class overwrite original class file class bytecode obtained result 
altered class loaded jvm user class loader 
example line javassist ctclass new ctclass rectangle structural reflection needed 
compile writes bytecode original class file 
program performs structural reflection class rectangle overwrites class file class bytecode obtained 
chapter 
javassist examples section shows applications javassist 
illustrate javassist implement non trivial alteration required applications despite level abstraction 
binary code adaptation mechanism binary code adaptation bca automatically alters class definitions file written users called delta file delta class implements writable rename writable printable add public void print write system delta file specifies adaptation mentioned section 
javassist implementor bca write parser delta file user class loader performing adaptation javassist 
example parser translates delta file shown java program shown class exemplar implements printable public void write dummy public void print write system class adaptor public void adapt ctclass method print exemplar ctclass interfaces int interfaces length interfaces getname equals writable interfaces ctclass forname printable interfaces addmethod new return class exemplar compiled adapter advance adapt object representing print 
adapt uses reification introspection api javassist obtaining 
constructs ctclass object representing exemplar obtains object ctclass 
class file exemplar automatically javassist class path loading adapter 
user class loader calls adapt adaptor class loaded jvm 
creates ctclass object representing loaded class calls adapt object 
method adapt performs adaptation chapter 
javassist loaded class implements writable 
user class loader converts ctclass object bytecode loads jvm 
note implementation intuitive implementation behavioral reflection 
simpler implementation reflection implementor care lowlevel bytecode transformation 
users bca directly write classes exemplar adaptor delta file implementation simpler need parser delta file 
behavioral reflection behavioral reflection enabled implemented approximately line program including comments javassist 
key idea implementations insert hooks program class loaded jvm 
see overview user class loader performing insertion javassist 
metaobject instance subclass metaobject public class extends metaobject public object string methodname object args called method call intercepted 
public object string fieldname called value field read 
public void string fieldname object value called field set 
field accesses method calls instance public class public int int return public int intercepted metaobject user class loader alters definition class public class implements metalevel public int int notify metaobject public int private metaobject metaobject new public metaobject return metaobject public int orig int return public static int read object target notify metaobject public static void write object target int value notify metaobject simplicity implementation ignores static members extending implementation handling static members possible ability javassist 
chapter 
javassist class exemplar private metaobject metaobject public object trap object args string methodname return metaobject methodname args public static object object args string name metalevel target metalevel args return target name public static object object args string name metalevel target metalevel args object value args target name value class exemplar interface metalevel declares method 
alteration performed ability javassist 
interface metalevel added ctclass 
field metaobject accessor added ctclass 
intercepting method calls user class loader copy method calling addmethod ctclass 
example adds orig copy 
replaces body method copy body method trap exemplar see 
modification performed 
gap signatures trap filled 
substituted method body notifies metaobject interception 
parameter args list actual parameters second name name copy original method orig 
parameters metaobject invoke original method java reflection api 
intercepting field accesses user class loader instruments bodies methods classes 
accesses field translated calls static method read write 
instrumentation performed instrument 
methods read write notify metaobject accesses 
added add wrapper ctclass copies exemplar 
gap signatures read write method name overloaded copy method different name orig orig 
chapter 
javassist filled 
example actual parameters read converted parameter args 
second parameter name accessed field 
remote method invocation generating stub code remote method invocation application javassist 
java program directly call method remote object different computer 
needs java rmi tools generating stub code translates method call lower level network data transfer tcp ip communication 
java rmi tools compile time ones program processed rmi compiler generates saves stub code local disk 
program java rmi subject protocol api specified java rmi 
javassist allows programmers develop version rmi tools specify customized protocol produce stub code compile time runtime 
suppose applet needs call method counter object web server written java 
remote method invocation applet needs stub code defining proxy object counter object set methods counter object 
counter object method proxy object method signature 
method proxy object serializes parameters sends web server invoked counter object received parameters 
stub code generated runtime javassist server side sent demand applet side 
applet programmer easily write applet concern low level network programming 
stub code accessing counter object follows public class private rmi public int rmi new public int int value remote method invocation instance proxy object 
object handles low level network communication 
class provided runtime support library 
defined confines javassist 
field rmi added ctclass initialization rmi constructor specified object passed 
chapter 
javassist method added ctclass copy method invoke exemplar shown class exemplar private rmi object invoke object args string methodname return rmi rpc methodname args gap signatures invoke filled 
called actual parameter value converted array object assigned args 
methodname set method name called object serializing parameters sends web server 
note parameters serialized ability standard java converted array object 
stub code generation example straightforward implement behavioral reflection 
typical implementation behavioral reflection proxy object instance class counter method calls proxy object intercepted metaobject forwarded remote object class produced 
proxy object created constructor declared counter called may cause fatal side effects class counter defined class server side proxy object side 
related reflection java enable behavioral reflection java javassist enables structural reflection 
suitable implementing different kinds language extensions 
javassist indirectly covers applications class loader providing functionality equivalent implemented javassist showed section 
performs bytecode transformation class files jvm loads javassist insert hooks interception bytecode run metaobjects time 
enable reflection runtime ability structural reflection restricted behavioral reflection 
java reflection api extended jdk beta partially enable behavioral reflection 
new api allows program method name overloaded distinction 
chapter 
javassist dynamically define proxy class implementing interfaces 
instance proxy class delegates method invocations object type independent interface 
javassist system enabling structural reflection java 
example kirby proposed system enabling structural reflection called linguistic reflection java system allows dynamically define new class alter class definition load time 
system java program produce source file new class compile external compiler javac load compiled class user class loader 
reported system defining class optimized runtime condition 
compile time metaobject protocol compile time metaobject protocol architecture enabling structural reflection modifying existing runtime system 
open java java implementation architecture 
javassist restricts structural reflection time class loaded jvm designed mainly line compile time 
openjava source code basis javassist bytecode basis openjava reads source code creating object representing class method field 
alteration object translated corresponding transformation source code 
bytecode altered class obtained compiling modified source code 
openjava source code basis deal syntax extensions framework structural reflection 
example extend syntax class declaration possible add annotation class declaration 
hand source code basis means openjava needs source file processed class javassist needs class file compiled binary 
disadvantage source files available class provided third party 
openjava involves performance overhead due handling source code source file class parsed reification compiled reflection 
overhead compensation capability fine grained transformation source code including syntax extension negligible openjava class loader altering loaded class 
kinds applications mobile agent system need fine grained transformation fast class loading 
implementations openjava javassist tuned performance difference openjava javassist notable respect reification reflection 
class loader implemented openjava javassist javassist achieves shorter loading time 
show performance difference compared javassist chapter 
javassist processing time sec openjava javac jikes javassist size class file kbyte execution time reification reflection openjava classes specjvm supplied source text 
measured time needed reifying class altered 
lists results 
execution time minimum trial 
trial repeated reification continuously second repetition 
program gradually loaded jvm repetition tremendously slow 
compiling modified source file openjava requires run java compiler 
actual time reification openjava takes compiling time java compiler jikes compiler standard javac compiler addition processing time openjava parser 
javassist processed class times faster openjava 
note execution time javassist shorter time needed compiling modified source file 
javassist move compilation penalties earlier stage 
method body compiled javassist running pre compiled advance resulting bytecode directly copied target class run time 
bytecode translators bytecode translators provide functionality similar javassist 
enable java program alter class definition load time 
toolkits directly dealing bytecode raw data structure class file 
example classes included code 
show designed experienced programmers deep understanding java bytecode want implement complex transformation 
chapter 
javassist hand javassist designed easy require programmers knowledge java bytecode provides source level abstraction manipulating bytecode relatively safe manner 
range instrumentation method body restricted showed javassist implement non trivial applications 
javassist regarded front easily safely bytecode translator replacement bytecode translators 
bytecode instrumentation implementing reflective facility known technique smalltalk 
uniqueness javassist design api providing source level abstraction 
javassist api carefully designed avoid wrongly producing class definition containing type incorrectness 
time mops just time compiler allows java program control bytecode compiled native code 
provides better flexibility javassist respect instrumenting method body allow add new method field class 
difficult javassist requires programmers knowledge java bytecode native code 
knowledge java bytecode programmers mechanism translating bytecode parse tree equivalent java program overheads due translation reported 
idea enabling reflection load time avoiding performance problems clos mop 
example clos mop allows program alter algorithm determining super classes class super classes statically determined class loaded program dynamically change super classes runtime 
summary chapter javassist extension java reflection api 
extensions enables structural reflection java allows program alter class definition dynamically define new class 
number language extensions easily implemented structural reflection behavioral reflection 
avoiding portability performance problems design javassist new architecture structural reflection 
javassist performs structural reflection instrumenting bytecode loaded class 
chapter 
javassist standard jvm compiler structural reflection allowed class loaded jvm load time 
standard jvm classes processed javassist subject bytecode verifier java 
javassist breaks security guarantees java 
followings important features javassist javassist portable 
implemented java native methods runs standard jvm 
need class library 
portability significant java programming 
javassist provides source level abstraction manipulating bytecode safe manner bytecode translators provide higher level abstraction 
users javassist deep understanding java bytecode careful avoiding wrongly making invalid class rejected bytecode verifier 
javassist needs source code openjava system structural reflection source level abstraction 
openjava performs structural reflection transforming source code parse compile source code reifying reflecting class 
class loader javassist load class faster openjava 
openjava enables fine grained manipulation class definitions resulting definitions may smaller efficient ones javassist 
architecture designed javassist applied object oriented languages compiled binary program includes symbolic information construct class object 
api individually designed language allows program alter class definitions safe manner respect semantics language 
chapter addistant chapter proposes system named addistant enables distributed execution legacy java bytecode 
legacy means software originally developed executed single java virtual machine jvm 
adapting legacy software distributed execution multiple jvm developers addistant specify host instances class allocated remote implemented 
specification addistant automatically transforms bytecode load time 
technical contribution addistant covers number issues implementing distributed execution real world 
fact addistant adapt legacy program written swing library swing objects executed local jvm rest objects remote jvm 
object oriented distributed software developed various programming tools environments 
example number object request brokers proposed just mention allow programmers easily object accessed remote host network 
programmers define interface object interface definition language 
example distributed programming language emerald 
language provides language constructs creating objects remote hosts migrating host 
programming tools environments mainly developing new distributed software scratch adapting legacy software distributed execution multiple hosts 
legacy means software originally developed intent executed single host 
existing tools environments helpful modifying legacy software part software executed remote host 
programmers manually modify source text program follow programming conventions specified tools chapter 
addistant special language constructs 
modification takes long time error prone 
impossible program text available modifiable 
practical demands adapting legacy software distributed execution disappear 
number legacy software programmers continue develop legacy software non distributed software easier develop distributed software 
support distributed execution legacy software written java developed system named addistant 
addistant helps developers modify legacy java programs run multiple java virtual machines jvm 
performs letting developers specify allocate instances class multiple hosts policy file separated original program 
instances class subject allocation policy 
real software contains large number objects realistic individually specify object allocated 
translating bytecode legacy java software specification specified classes executed jvm running remote host 
addistant need source code translation 
translated bytecode regular java bytecode 
custom jvm needed execution 
delivering translated bytecode remote jvm 
delivery performed runtime system addistant 
translation addistant implemented synthesis re engineering ideas existing programming tools environments distributed software 
proxy master model proxy object forwards method invocations remote object network generation classes proxy objects automatically managed addistant hidden developers 
technical contribution addistant covers issues encounter applying proxy master model real software development java 
example jvm allow modifying bytecode system classes load time proxy master model implemented known straightforward translation requires bytecode translation related classes including system classes 
avoid problems addistant provides multiple implementation approaches developers choose class 
typical application addistant apply functional distribution legacy java program modules program executed remote host suitable functionality modules 
example addistant adapt legacy program swing class chapter 
addistant library java graphical user interface gui library gui objects executed host front user objects remote high performance host 
resulting program produced addistant achieves performance 
effects achieved window system enables program show windows remote display experiments showed addistant achieve better response time gui window system 
window system implements distribution level runtime library needs network communication drawing primitive 
hand addistant implements distribution translating program including library code user code 
higher level distribution significantly reduces amount network communication 
fact suggests distributed program developed program translator give better performance runtime library 
rest chapter section presents architecture addistant 
section describes java related implementation issues 
section show addistant adapting legacy software swing class library distributed execution 
section discusses related 
section concludes chapter 
addistant addistant java programming tool adapting legacy software developed intent executed single jvm distributed execution objects software executed remote host 
adaptation performed bytecode translator load time 
section mentions design issues tools addistant presents addistant deals 
design goal developing distributed software scratch adapting legacy software written java distributed execution needs special tool support 
tool support programmers read program software modify objects allocated remote host method invocations specially treated network 
manual modification troublesome error prone programming tool automate modification 
number researchers proposing java distributed languages languages suitable purpose 
distributed language programmer needs obtain source code program usually unavailable supplied chapter 
addistant third party 
modify program special syntax provided language 
example case language proposed regular java statement creating object frame new frame great encyclopedia replaced statement frame frame great encyclopedia special syntax 
obtain source code edit statements 
existing object request brokers orb suitable 
mainly making legacy software component larger distributed software 
orb distributing modules software remote host programmer manually split software modules modify program interactions modules subject protocols orb 
example java rmi requires remote method invocations performed interface types 
suppose method show called remote instance class frame 
programmer declare new interface modify declaration class frame class frame implements interface 
substitute occurrences class name frame program 
care number issues remote object creation polymorphism 
ideal tool adapting legacy software distributed execution provide features remote tool hide implementation details remote object programmers 
programmers modify program remote program follow particular protocol specified tool 
policy object allocation tool allow programmers easily specify object allocated local host remote host 
programmers may know details program legacy software object allocation specified appropriate level 
program delivery tool able automatically deliver program modules remote host modules executed host 
chapter 
addistant rest section focus implementation remote 
describe users addistant specify policy object allocation 
describe addistant implements program delivery 
remote addistant implements remote bytecode translation load time 
run translated software custom jvm needed addistant needs regular jvm running host 
addistant employs proxy master model known remote proxy pattern remote method transparently invoked syntax local method 
model object methods invoked remote host associated object called proxy existing remote host 
distinction call object master 
proxy provides set methods master delegates method invocation master 
encapsulates details network communication necessary remote method invocations 
unfortunately single implementation approach proxy master model deal kinds classes 
approach covers classes satisfying criteria peculiar approach 
design programming tool legacy software may written choose single approach enforce criteria program 
example approaches needs modify declaration class master objects 
jvm accept modified system classes instance system class remote object approach 
different approach case 
avoid problem addistant provides different approaches implementing proxy master model 
currently provides approaches replace rename subclass 
developers choose class master 
differences approaches mainly proxy class declared caller side code expressions remote method invocations modified master class modified 
approaches cover cases practical development experiences swing library 
choose approaches developers know class master meets features call master object passed remote method parameter call manner 
passed call value manner 
chapter 
addistant heterogeneity variable class type able hold local remote 
kinds master objects require feature 
example instances gui class exist host front user 
instances local host remote host 
case local remote coexist single host 
bytecode transforming bytecode 
required jvm prohibits developers modifying replacing bytecode system classes java util vector 
feature divided sub features class declaration master objects original class master classes accessing master objects referrer classes master classes creating master objects factory classes respectively 
remainder subsection presents details approaches conditions approaches 
summary conditions listed table 
table applicability approaches 
mark indicates approach probably unavailable case feature required 
replace rename subclass copy call heterogeneity bytecode original class referrer classes factory classes replace approach 
approach replace approach 
available heterogeneity feature required original class 
developers apply approach non system classes masters allocated host 
suppose class master object widget 
heterogeneity feature required widget objects local remote 
addistant uses original widget class local host generates version widget class remote hosts table 
version corresponds proxy class original widget class 
addistant sends bytecode proxy class host remote widget masters 
chapter 
addistant table feature proxy class class widget approach 
assume original widget subclass object 
replace rename subclass proxy class widget superclass proxy object object widget variable type proxy widget widget different version widget class 
rename approach 
second approach rename approach 
replace approach available declaration original class modifiable 
rename approach case requires referrer classes factory classes modifiable 
replace approach rename approach available heterogeneity feature required 
developers apply approach classes java awt window 
rename approach addistant generates proxy class original class widget different name 
addistant uses proxy class remote 
modifies bytecode referrer classes hosts widget objects remote occurrences original class name widget replaced proxy class name 
addistant modify referrer classes host widget objects local 
addistant modifies factory classes host widget objects remote 
widget objects created host addistant replaces occurrences widget bytecode factory classes 
example translates statement frame new frame statement new statement creates proxy object requests remote host create master object 
subclass approach 
third approach subclass approach 
available heterogeneity feature required 
developers apply approach classes java util vector 
chapter 
addistant approach proxy class subclass original class widget 
local remote type widget coexist host 
local points widget object 
remote points object 
rename approach approach needs modify factory classes host master objects remote 
furthermore approach may require original class modifiable 
original class final class includes final method final class include final method 
proxy class subclass original class override methods declared original class 
second constructor original class causes inappropriate side effects fails create object addistant add class constructor performing constructor proxy class call 
remember constructor call constructor super class java 
example original constructor class widget may access local graphic device 
called constructor subclass widget may throw error absence graphic device host object created 
note subclass approach require original class modifiable original class final class constructors cause inappropriate side effects 
instance bytecode system class java io file 
class system classes referrer classes 
heterogeneity feature required replace rename approaches java io file 
hand subclass approach class 
copy approach 
copy approach 
approach primitive types int classes java lang string instances immutable 
copy approach chosen class remote instance exist 
local instance passed remote method addistant shallow copy instance remote host 
local copy passed method 
copy approach passed remote method call manner 
copy approach need modify bytecode 
addistant provides slightly different version copy approach chapter 
addistant write back copy approach 
approach chosen contents copy passed remote method written back master object executing remote method 
example suppose writeback copy approach chosen array byte 
code byte buf 
inputstream read buf call read remote object inputstream copy buf remote host 
local copy passed read 
write back copy approach chosen contents copy written back buf executing read 
byte data read input stream eventually stored buf 
object allocation addistant allows developers specify policy object allocation class 
allow different policy object addistant tool modifying legacy software realistic developers specify policy occurrence new operator object creation appearing program may written 
developers declare instances class allocated specific host 
host specified class expression new create instance executed host interpreted instance created probably remote host hand host specified class expression new executed host interpreted instance locally created host declaration developers written policy file addistant reads startup time 
policy file written xml syntax 
example declaration import proxy rename display java awt import means instances classes included java awt package allocated host specified variable display 
remote instances implemented rename approach 
variable display bound real host name run time 
attribute instances class allocated host expression new executed 
chapter 
addistant note java awt means classes included java awt package 
mean sub packages java awt awt image sub packages irrelevant parent package respect language semantics 
example access rights class equivalent ones packages parent package sub package 
specify classes sub packages java awt java awt 
classes included package subclasses class package specified 
example declaration import proxy rename display subclass java awt component import means rename approach subclasses class component including component 
specify subclasses excluding parent class subclass 
implementation approaches remote restrict policies object allocation 
replace rename approaches require local remote coexist field specified instances created host 
hand copy approach allow developers specify field deal remote 
bytecode delivery addistant provides mechanism automatically distributing bytecode host hosts 
users run class loader addistant host 
program starts host creates object remote host class loader host sends necessary bytecode class loader host object created host bytecode modified modified class loader host sent host bytecode system classes class loader host loads local file system host regular class loader java fetches bytecode demand class loader addistant may fetch bytecode certain classes advance 
example suppose rename approach specified subclasses class class loader addistant loads class read bytecode class specified name appearing bytecode examine class subclass class name replaced name proxy class 
class loader addistant loads class subclasses chapter 
addistant implementation issues single system image implementation issues keeping semantics java language distributed program execution providing single system image multiple jvms 
sub section describes addistant deals issues 
remote field access 
naive implementation proxy master model support remote field accesses addistant translates field access bytecode static method invocation class enables remote field accesses 
suppose class point declares field field accessed follows point 


remote point objects implemented rename approach code translated code 
read 
write 
static methods read write implement remote field accesses 
declared proxy class produced addistant 
translation applied remote field accesses 
addistant deal remote field accesses embedded bytecode example bytecode system classes 
equality remote 
addistant preserves semantics equality operators respect remote 
addistant maintains table proxy objects host exists single proxy object referencing master object 
addistant gives unique identifier master object sends identifier master object passed parameter network remote method 
looks corresponding proxy object table passes proxy object destination method 
proxy object table addistant creates registers table 
chapter 
addistant self deadlock avoidance 
addistant host invoke method remote object receive method invocation remote object 
remote method call host host may cause method call back case method call handled thread requested method call host may occur methods synchronized ones 
suppose button object listener object exist different hosts display host application host respectively 
declarations class button listener follows class button listener listener synchronized void push listener pushed synchronized getstate 
class listener void button button 
button getstate 
push invoked button object calls remote listener object 
getstate called back button object 
push getstate executed different threads deadlock occurs threads try lock button object time 
deadlock occurs objects exist host methods executed thread 
order ensure thread executes methods called back addistant establishes communication channel thread executing push executing handle push 
communication channel stored thread local variable implemented java lang 
thread uses channel remote method invocation waits result invocation request invocation remote thread sharing channel 
calls get state sends request getstate remote thread connected communication channel thread executing push blocking wait result 
chapter 
addistant thread invokes requested getstate send result get state channel continues wait result original 
push getstate executed thread deadlock avoided 
distributed garbage collection 
addistant maintains table objects exported remote host 
exists proxy object remote host master object recorded table garbage collected 
proxy objects garbage collected master object removed table 
master object master object garbage collected 
table proxy objects checking equality remote implemented weak mechanism java 
element table weak proxy object 
proxy object garbage collected garbage collector determines table refers proxy object 
currently addistant collect objects remote cycles 
algorithms known dealing distributed cycles efficiently implementing algorithms straightforward modifying jvm 
example distributed mark sweep algorithm need mechanism tracing object 
java reflection api provide mechanism 
expect weak object help solve problem implementation details open 
bytecode modification bytecode translation toolkit 
research aims development addistant examine expressive power javassist toolkit implementing bytecode translator java 
similar toolkits javassist provides source level view bytecode developers manipulate bytecode detailed knowledge bytecode specifications 
javassist easier naive toolkits source level debugger easier assembly level debugger 
hand javassist restricts ability modify bytecode 
allow bytecode modification difficult express source level view 
show expressive power javassist powerful implement real application developed addistant confines javassist api application programming interface 
undocumented low level api 
bytecode modification ad chapter 
addistant distant needs easily implemented source level abstraction provided javassist 
bootstrap classes 
command line option provided sun jvm modify bytecode system classes jvm load modified bytecode bootstrap time 
option extends range classes approaches provided addistant implementing proxy master model applicable 
modify bytecode system classes sun license terms prohibit modification 
modify consistently modifying system classes difficult runtime systems system class loader depends definition system classes 
distributed swing applications section presents addistant adapt legacy software swing class library gui objects allocated remote host users interact software gui shown remote display 
swing class library gui library included standard java runtime environment 
effects achieved window system addistant achieve better performance drawing operations directly performed host display 
typical benefit functional distribution 
window system needs network communication primitive drawing operation communication overheads tend performance bottleneck 
section policy file adapting legacy software swing class library distributed execution 
show results performance measurement 
policy file typical policy file adapting software swing class library policy import proxy rename display subclass java awt subclass swing subclass accessibility subclass java util import import proxy rename application java io inputstream outputstream reader writer swing import import proxy subclass subclass java util dictionary chapter 
addistant subclass java util import import proxy array import import proxy replace application user import import proxy copy import policy variable display indicates host gui objects allocated 
variable application indicates host rest objects allocated 
import declaration listed higher priority 
policy file specifies gui objects allocated display host remote objects implemented rename approach 
array type array back copy approach 
instances classes system classes user allocated application host remote implemented replace approach 
rest classes processed copy approach 
performance measurement performance measurement host computers 
machine linux 
display server executing gui objects 
machine solaris 
application server executing objects 
hotspot jvm jdk machines 
connecting machines kinds network base tx full duplex base half duplex 
remote method invocation 
measuring performance gui compared execution time remote invocations empty methods addistant ad java object request brokers orb version java rmi included jdk java class broker version 
changed number types parameters measured elapsed time remote method invocation 
changed network connecting hosts 
table lists results 
results showed addistant achieved comparable performance orb case byte array passed 
parameter encoder decoder addistant tuned addistant write back copy approach passing array parameter orb write updated contents array back executing method 
chapter 
addistant table elapsed time milliseconds remote method invocation 
ad indicates addistant 
base tx full duplex base half duplex ms ad ad void void int int int void int int int int int int int void string string string void string string string void byte measurement string type parameters included ascii characters 
size string array 
size byte array 
window drawing 
measure performance gui prepared java programs 
displays single window java awt frame object containing components 
second displays single empty internal window swing object window swing object 
third displays single internal window containing buttons swing jbutton object window 
size window size internal window 
compared window system addistant measuring elapsed time program took creating drawing window internal windows remote display 
window system showed window remote display connecting remote server 
gui library compatible swing class library enables show window remote display 
addistant showed window remote display allocating gui objects remote host display 
table listed results 
drawing image complex addistant showed better performance allocates part instances swing classes remote host display needs larger number remote method invocations drawing window 
hand addistant allocates instances swing classes remote host interactions swing objects local method invocations 
addistant general purpose bytecode translator allows developers easily customize object allocation maximizing performance 
implementation black box 
chapter 
addistant table elapsed time seconds drawing window 
window addistant base tx full duplex components internal window buttons base half duplex components internal window buttons window system asynchronously executes server client elapsed time listed table indicates time needed sending requests client server 
indicate actual elapsed time drawing window 
fact observed response time gui implemented top window system considerably slower top addistant 
confirm observation conducted experiment 
wrote java program displays button window button clicked graphic image shown window 
table listed results experiment 
measured elapsed time button clicked mouse image shown 
time measured hand 
means response time short measure 
swing class library caches drawn image addistant responded quicker window mouse click second time 
window transfer drawn image time client server 
time addistant achieved best performance network base window system transfer larger amount data hosts 
table listed results measurement size data exchanged network interaction 
window system needs megabytes addistant kilobytes 
large amount exchanged data performance bottleneck 
table response time seconds mouse click 
base tx full duplex base half duplex sec 
window addistant window addistant st nd chapter 
addistant table size data kbyte exchanged network 
window addistant st nd related transparent distribution run java program distributed environment extended java virtual machines developed 
virtual machines cjvm java dsm jessica provide single machine image network connected computers workstation pc cluster 
multiple threads executed parallel running multi processor machine shared memory 
virtual machines need modify program run 
difference addistant virtual machines addistant uses standard jvm mainly functional distribution objects run suitable host computation objects 
extended java language parallel distributed computing 
introduced extended modifier remote class declarations 
users addistant modify program users append extended modifier remote class declaration instance class accessed remote 
number object request brokers java 
including java rmi require remote object accessed interface type 
developers may largely modify programs adapt legacy software distributed execution 
java class broker avoids problem technique similar subclass approach 
requires developers modify program follow programming convention 
example regular java program frame new frame great encyclopedia button new button add translated program runtime distribution manager object object params great encyclopedia frame frame create frame params button button button new button add chapter 
addistant remote display window system enables java program show graphical output display remote host 
addistant window system require developers modify programs remote display 
shown section window system efficient addistant 
gui library compatible standard java gui library 
substituting standard library developers extend programs modifications remote display output 
underlying network communication encapsulated library 
addistant regarded tool semi automatically producing library standard java gui library 
production addistant library user code resulting software achieve better performance 
aspect oriented programming addistant developers describe policy file adapting software distributed execution 
policy file considered separate description distribution aspect context aspect oriented programming aop 
context addistant tool weaving java program written single jvm description separately written distribution aspect 
proposing distribution aspect new 
example provides aspect language distribution 
allows programmers separately describe parameter passed remote procedure addistant allows describe objects allocated proxy objects implemented 
furthermore design goal support development distributed software scratch 
goal addistant add new aspect existing software adaptation 
description policy file part program text meta level instructions modify existing program 
summary chapter addistant programming tool adapting legacy java software distributed execution 
addistant performs adaptation bytecode translation load time 
source code needed adaptation 
users addistant write policy file specifying instances class allocated remote instances implemented 
users select implementation approach provided addistant 
chapter 
addistant implementation approaches new contribution chapter reveals letting developers select implementation approach class necessary adapting legacy java software real world distributed execution 
chapter practical issues consider adaptation 
ability addistant limitations 
developers addistant need read modify source code knowledge source code example class objects allocated remote host 
addistant provides class distribution instances class allocated host 
limitations acceptable gui examples open question contexts 
chapter showed addistant adapt java program swing class library gui objects allocated remote host display 
functional distribution addistant showed better response time gui distribution window system class library 
fact suggests functional distribution give performance library code split distributed multiple hosts 
hand addistant split program including user library code distribute objects maximum performance obtained 
chapter thesis proposed class object model new data model transformation object oriented programs 
key concept class object model capture object orientation programs 
designing metaobject protocols considering mechanism data types targeting object oriented language enables direct manipulation object oriented constructs 
declarative language constructs classes inheritances mechanism considered 
model allows transformational system provide sophisticated interface metaprograms simply intuitively describe transformation object oriented language constructs programs translated 
contribution proposed model suggests new design approach programming support especially programming languages 
systems proposed design model commonplace provide transformations reusable software artifacts 
powerful transformations compiler experts object oriented programming experts expected lot knowledge worth reusing software engineering 
thesis contributed giving practical applications class object model program transformations 
built transformational systems model 
design space systems differs perspective generality format targeting programs 
openjava javassist supply users generic metaobject protocols transforming object oriented programs addistant supplies users programming interface specific distributed domain 
openjava transforms source text programs javassist application addistant transform bytecode programs 
addition contribution practical applications class object model contributions transformational system 
chapter 
system openjava 
openjava object oriented macro system employing class object model transformations source text program written java 
syntax tree provides data structure represents logical structure object oriented program 
easier describe typical macros object oriented programming difficult describe ordinary macro systems 
show effectiveness openjava implemented macros openjava supporting programming design patterns 
point reflection openjava provides mechanism compile time structural reflection limited syntax extensibility 
structural reflection change structure program change behavior program ordinal runtime reflection call behavioral reflection 
second system javassist 
javassist java bytecode manipulating tool employing class object model transformations binary programs java 
javassist provides source level abstraction manipulating bytecode safe manner bytecode translators provide higher level abstraction 
users javassist deep understanding java bytecode careful avoiding wrongly making invalid class rejected bytecode verifier 
openjava javassist provides mechanism structural reflection reflective computation done load time classes loaded java virtual machines 
call load time structural reflection 
allows program alter class definition dynamically define new class 
number language extensions easily implemented structural reflection behavioral reflection 
third system addistant 
addistant programming tool adapting legacy java software distributed execution 
built javassist performs adaptation bytecode translation load time 
source code needed adaptation 
users addistant write policy file specifying instances class allocated remote instances implemented 
users select implementation approach provided addistant 
implementation approaches new contribution addistant reveals letting developers select implementation approach class necessary adapting legacy java software real world distributed execution 
practical issues consider adaptation 
direction research construct frameworks aop aspect oriented programming support 
aspectj provides generalpurpose aop support 
aspectj programmers describe separated code called aspects originally difficult separate chapter 
aop support 
aspects reusable aspectj 
domainspecific aspect languages solve problem transformational system proposed model generic framework domain specific aspect language 
fact addistant regarded distributed domainspecific aspect oriented programming language 
bibliography factor cjvm single system image jvm cluster 
proceedings icpp ieee 
arnold gosling holmes java programming language ed 
addison wesley ch 
chapter garbage collection memory pp 

bachrach java syntactic extender 
proceedings oop sla tampa florida usa october sigplan notices vol acm pp 

bal steiner tanenbaum programming languages distributed computing systems 
acm computing surveys 
balzer year perspective automatic programming 
ieee transactions software engineering november 
batory smaragdakis jts tools implementing domain specific languages 
proceedings fifth international conference software reuse victoria canada june ieee press 
black hutchinson jul levy carter distribution types emerald 
ieee transactions software engineering se january 
bosch language support design patterns 
tools europe paris france feburary 
bosch design patterns language constructs 
journal object oriented programming may 
brant foote johnson roberts wrappers 
ecoop object oriented programming lncs springer pp 

bibliography noy partially evaluating reflection java 
proc 
symposium partial evaluation semantics program manipulation pepm sigplan notices vol 
acm pp 

briot cointe programming explicit metaclasses smalltalk 
proceedings oopsla new orleans louisiana usa october meyrowitz ed sigplan notices vol acm pp 

brown macro processors techniques portable software 
wiley 
ra seamless computing metacomputing java 
concurrency practice experience november 
chiba metaobject protocol 
proceedings oop sla sigplan notices vol acm acm press pp 

chiba macro processing object oriented languages 
proceedings tools pacific australia november ieee ieee press 
chiba load time structural reflection java 
ecoop object oriented programming sophia antipolis cannes france june lncs springer verlag pp 

chiba kiczales lamping avoiding confusion meta helix 
proceedings nd international symposium object technologies advanced software lncs springer pp 

chiba masuda designing extensible distributed language meta level architecture 
proc 
th european conference object oriented programming lncs springer verlag pp 

chiba structural reflection java bytecode instrumentation 
ipsj journal 
japanese 
cohen chase kaminsky automatic program transformation 
usenix annual technical conference new orleans louisiana usa june usenix 
cointe metaclasses class model 
sigplan notices december 
bibliography czarnecki eisenecker generative programming methods tools applications 
addison wesley june 
dahl nygaard simula common base language 
tech 
rep norwegian computer centre oslo norway 
dahm byte code engineering api 
report institut informatik freie universit berlin berlin germany july 
ducasse message passing abstractions elementary bricks design pattern implementation 
object oriented technology ecoop workshop reader lncs springer 
dybvig friedman haynes expansion passing style general macro mechanism 
lisp symbolic computation june 
ellis stroustrup eds 
annotated manual 
addison wesley 
ellis stroustrup eds 
annotated manual 
addison wesley 
fabre metaobject architecture fault tolerant distributed systems friends approach 
ieee transactions computers 
futamura partial computation programs 
proceedings rims symposia software science engineering lncs springer pp 

gamma helm johnson vlissides design patterns elements reusable object oriented software 
addison wesley 
gil lorenz design patterns language design 
ieee computer march 
goldberg robson smalltalk language implementation 
addison wesley 
klein der jumping meta level behavioral reflection fast flexible 
proc lncs springer pp 

gosling joy steele jr java language specification 
addison wesley 
bibliography har el java class broker seamless bridge local distributed programming 
parallel distributed computing 
hicks jagannathan kelsey moore transparent communication distributed objects java 
proceedings acm conference java grande palo alto ca usa june pp 

june 
distributed execution java programs 
proceedings 
lzle ungar third generation self implementation reconciling responsiveness performance 
proc 
acm conf 
object oriented programming systems languages applications sigplan notices vol 
pp 

ibm 
remote windowing toolkit 
www ibm com java html july 
extensible java preprocessor kit tiny data parallel java 
proceedings california december 
ishikawa hori sato design implementation metalevel architecture mpc approach 
proceedings reflection april pp 

javasoft 
java core reflection api specification 
online publishing january 
johnson foote designing reusable classes 
journal object oriented programming 
kal design implementation parallel java global object space 
proceedings pdpta conference parallel distributed processing technology applications nevada usa pp 

keller lzle binary component adaptation 
ecoop object oriented programming lncs springer pp 

kiczales hilsdale hugunin kersten palm overview aspectj 
ecoop object bibliography oriented programming budapest hungary june knudsen ed lncs springer verlag pp 

kiczales lamping issues design specification class libraries 
proceedings oopsla pp 

kiczales rivi res bobrow art metaobject protocol 
mit press 
morrison stemple linguistic reflection java 
software practice experience august 
klein der efficient run time meta architecture java 
proc 
international workshop object orientation operating systems ieee 
kohlbecker friedman felleisen duba hygienic macro expansion 
proceedings acm conference lisp functional programming cambridge massachusetts usa august acm acm press pp 

krueger software reuse 
acm computing surveys 
ladd language implementing language processors 
ieee transactions software engineering november 
liang bracha dynamic class loading java virtual machine 
proceedings oopsla sigplan notices vol acm acm press pp 

lopes kiczales language framework distributed programming 
technical report spl xerox palo alto research center palo alto ca usa 
ma wang lau jessica java enabled single system image computing architecture 
journal parallel distributed computing 
maddox semantically sensitive 
tech 
rep ucb csd university california berkeley california usa 
maes concepts experiments computational reflection 
proceedings florida usa october sigplan notices vol acm acm press pp 

bibliography matsuoka asai yonezawa compiling away meta level object oriented concurrent reflective language partial evaluation 
proceedings oopsla austin texas usa october sigplan notices vol acm pp 

october 
yonezawa design partial evaluation metaobjects concurrent reflective languages 
ecoop object oriented programming lncs springer pp 

demeyer engel making design patterns explicit face framework adaptive composition environment 
proceedings esec fse september springer verlag pp 

musser stepanov algorithm oriented generic libraries 
software practice experience july 
srinivasan lea remote objects java 
proceedings iasted international conference networks january 
ogawa matsuoka maruyama kimura open ended reflective jit compiler framework java 
proc 
ecoop springer verlag 
appear 
philippsen zenger transparent remote objects java 
concurrency practice experience 
rohnert proxy design pattern revisited 
addison wesley pp 

pree automated support software development frameworks 
proceedings ssr acm sigsoft symposium software reusability pp 

scheifler gettys window system 
acm transactions graphics 

addison wesley longman 
death computer languages birth intentional programming 
tech 
rep msr tr microsoft research microsoft redmond wa september 
bibliography smith reflection semantics lisp 
proceedings popl acm symposium principles programming languages pp 

implementing patterns 
pattern languages program design 
addison wesley ch 
pp 

steele jr overview common lisp 
proceedings acm symposium lisp functional programming pittsburgh pa usa august acm pp 

sun microsystems java remote method invocation specification 
java sun com products jdk rmi 
sun microsystems java foundation classes 
java sun com products jfc 
sun microsystems java tm sdk documentation 
version 
separation distribution concerns distributed java programming 
addendum proceedings conference object oriented programming systems languages applications oopsla addendum doctoral symposium tampa bay florida usa october acm pp 

chiba programming support design patterns compile time reflection 
proceedings oopsla workshop reflective programming java pp 

chiba macro system class objects java language 
ipsj journal 
japanese 
chiba openjava class macro system java 
reflection software engineering july stroud eds lncs springer verlag pp 

sasaki chiba bytecode translator distributed execution legacy java software 
ecoop object oriented programming budapest hungary june knudsen ed lncs springer verlag pp 

weise crew programmable syntax macros 
sigplan notices 
bibliography welch stroud evolution reflective java extension 
proc lncs springer pp 

wu reflective java reflective component transaction architecture 
proc 
oopsla workshop reflective programming java 
fabre chiba eds 
yu cox java dsm platform heterogeneous computing 
concurrency practice experience 
