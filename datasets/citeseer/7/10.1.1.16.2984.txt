computational interpretations linear logic samson abramsky department computing imperial college science technology medicine queen gate london sw bz england sa doc ic ac uk appear theoretical computer science february study girard linear logic point view giving concrete computational interpretation logic curry howard isomorphism 
case intuitionistic linear logic leads refinement lambda calculus giving finer control order evaluation storage allocation maintaining logical content programs proofs computation cut elimination 
classical case leads concurrent process paradigm operational semantics style berry boudol chemical machine 
opens promising new approach parallel implementation functional programming languages offers prospect typed concurrent programming correctness guaranteed typing 
inception linear logic gir offered great promise formalism particularly suited serve interface logic computer science 
ffl logical side linear logic combines symmetries classical logic manifest gentzen sequent calculus constructive content intuitionistic logic 
ffl computational side linear logic offers logical perspective computational issues control resources order evaluation 
contrast extant declarative languages logical content search efficiency require elaborate infrastructure implementation techniques draw inspiration mathematical structure language 
paradigm followed girard seeking apply linear logic computation curry howard isomorphism see glt propositions logical formulae interpreted types proofs programs process normalization cut elimination computation 
paradigm cornerstone connections intuitionistic logic functional programming category theory see hue 
firmly established major component logical foundations programming 
case intuitionistic logic relates typed calculus typed functional programs canonical syntax proofs intuitionistic logic reduction terms normal form program execution normalization proofs 
particularly satisfying correspondence case intuitionistic logic formalism computational side immediately recognisable attractive programming paradigm extensively developed advocated significant community software practitioners tur bw fh pj 
lacking date development linear logic comparably attractive computational interpretation 
interpretation main ingredients ffl interpretation proofs programs formed expressions programming notation 
ffl operational semantics programs embodying clear conception program execution 
semantics formulated suitable level abstraction unencumbered implementation details serve specification language 
basis linear logic computational aspect studied general framework programming language semantics developed considerable success years 
computational intuitions proposed connection linear logic precise actual advantages computational formalism assessed relation claims behalf 
said programme runs somewhat counter advocated girard 
adopted methodological principle avoiding bureaucracy syntax gir aiming geometrical view computation exemplified geometry interaction gir interprets cut elimination linear logic iterations operators algebras 
perspective seeking seen step 
see complementary girard 
giving simple concrete computational interpretation linear logic connections computational formalisms apparent immediately meaningful programming terms hope linear logic accessible computer scientists provide basis substantial applications 
time hope establish connections girard geometrical approach left 
contents follows 
section review connections intuitionistic logic typed calculus functional programming describe operational semantics calculus style inspired martin lof ml currently natural relational semantics widely programming language specification kah mth 
give correspondence natural deduction sequent calculus presentations intuitionistic logic 
standardly type inference system functional programming forms basis refinement intuitionistic logic linear logic 
section intuitionistic linear logic fragment containing omega gammaffi phi 
fragment gives rise refined version functional programming 
term calculus notations proofs fragment essentially refinement calculus allows greater control computational behaviour preserving strict correspondence terms proofs 
give operational semantics language natural semantics style achieving basic aim giving computational interpretation intuitionistic linear logic 
study various aspects sections 
section sketch possible applications static program analysis optimization give detailed description sequential implementation linear term calculus terms variant secd machine lan 
section establish basic theoretical properties calculus second order propositional version 
turn classical linear logic sections 
regarded main contribution 
material intuitionistic linear logic interesting right included mainly expository purposes 
classical linear logic requires radical departure functional framework going way intuitionistic linear logic helps cushion shock 
section introduce proof expressions notation proofs classical linear logic concurrent operational semantics style berry boudol chemical machine bb 
basic theoretical properties proof expression calculus established section 
parallel implementation sketched section 
great pleasure acknowledge enormous amount learnt writings lectures conversation jean yves girard originator linear logic 
learnt great deal yves lafont introduced linear logic tour duty imperial 
tried give self contained account linear logic reflecting understanding intuitions course learnt presentations 
computational interpretation intuitionistic linear logic described section clearly owes previous yves lafont laf holmstrom hol 
key ingredients new clarified simplified essential fashion comparison previous works 
similar remarks apply discussion pragmatics implementation section 
material section new regarded straightforward adaptation similar results calculi 
material classical linear logic sections new connections proof nets discussed section 
phil wadler phil scott andre scedrov stimulating discussions 
particularly christian retor steve vickers helpful discussions matters mike mislove inviting give talk mfps workshop kingston may preliminary topic paul taylor linear logic font diagram macros science engineering research council esprit basic research action project financial support 
preliminary version released technical report abr benefited comments corrections number people particularly phil wadler anne troelstra ian mackie especially yves lafont 
ugo silvio bringing papers sol val attention 
intuitionistic logic functional programming section essentially reviews standard material style presentation operational semantics assignment terms proofs sequent calculus widely known deserve 
general background glt 
natural deduction natural deduction intuitionistic logic strictly speaking minimal logic shall point 
ease comparison sequent calculus natural deduction sequent form objects derived sequents gamma delta range sequences formulas including empty sequence write gamma delta concatenation sequences 
distinguishes system natural deduction form rules connective structured rules elimination rules 
axiom id structural rules exchange gamma delta gamma delta contraction gamma gamma weakening gamma gamma logical rules gamma gamma gamma gamma gamma gamma gamma gamma gamma oe gamma gamma gamma oe oe gamma gamma oe gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma note action natural deduction style logical rules right hand side turnstile 
notice asymmetry rules conjunction disjunction 
structural rules easy derive variant oe gamma gamma oe delta gamma delta cut rule gamma delta gamma delta basic rule natural deduction 
term assignment natural deduction assign terms typed calculus natural deduction proofs 
point view significance give functional interpretation intuitionistic proofs embodiment heyting semantics intuitionistic logic formulas propositions interpreted means proofs proof conjunction pair proofs conjuncts proof implication oe constructive function mapping proofs proofs proof disjunction proof proof information disjunct proved 
propositions viewed data types theta cartesian product oe function space disjoint union functional programming point view programs terms primary interest 
perspective type inference system functional programs assigns types terms logical system assigning terms proofs 
course advantage isomorphism views coexist 
term version natural deduction objects derived form distinct variables term 
system style curry church bh terms embedded types types assigned 
choice technical convenience necessity certainly reflect ideological commitment 
axiom id structural rules exchange gamma delta gamma delta contraction gamma gamma weakening gamma gamma logical rules gamma gamma gamma gamma ht ui gamma gamma gamma fst gamma gamma snd oe gamma gamma gamma oe oe gamma gamma oe gamma gamma tu gamma gamma gamma inl gamma gamma inr gamma gamma gamma gamma gamma case inl inr operational semantics proof theoretic point view step set equational theory terms reflecting intended notion equivalence proofs translate normalization proofs reduction terms normal forms 
shall proceed different fashion method presenting operational semantics inspired martin lof ml currently widely name natural relational semantics kah mth 
number reasons choice ffl style formalization operational semantics better suited specifying realistic programming languages evaluation strategy intrinsic part language equational theory term rewriting system 
ffl style robust extends smoothly languages incorporating features lazy evaluation general recursion longer case program normal form 
ffl technical advantages witnessed sections 
main results considerably easier prove 
may objected weaker corresponding results reduction normal form wider range applicability situations stronger results may fail 
ffl telling point martin lof style operational semantics theory reductions proofs significantly lacks evaluation rules formally inevitable write 
contrast commutative conversions disjunction awkward 
evaluation rules capture done computation 
presenting operational semantics typed calculus shall explain general concepts underlying approach 
firstly classification constructions terms groups constructors corresponding rules destructors corresponding elimination rules 
classification course goes right back pioneers mccarthy mcc landin lan lacked perspective 
constructors produce information pieces structured data destructors consume 
basic unit computation reduction step destructor meets corresponding constructor author suggestive think particles information anti information colliding annihilating possibly generating new particles communication event 
note operational significance type checking precisely ensure constructor type collides destructor different type consumer plug producer communication occur 
think computation applying programs closed terms 
effect computation reduce program canonical form quantity information explicit put constructor form 
point bifurcation occurs lazy including call name evaluation principle producing little information possible stage evaluation eager including call value evaluation possible produced 
determines evaluation strategy operational semantics 
proof system enforce strategy 
surprising extensional differences strategies show calculus presence non terminating programs see plo strict correspondence typed programs proofs strong normalization programs strategies terminate 
notable features linear logic clear perspective lazy vs eager evaluation provided pure logical level absence divergence 
see section 
lazy eager strategies shall specify set canonical forms operational semantics terms evaluation relation read evaluates converges canonical form 
lazy evaluation canonical forms programs closed terms constructor top 
canonical forms ht ui inl inr evaluation relation defined inductively satisfying clauses ht ui ht ui hu vi fst hu vi snd tu inl inl inr inr inl case inl inr inr case inl inr eager evaluation canonical forms hc di inl inr canonical forms 
note abstraction canonical evaluate programs may closed 
exactly mirrors done actual eager evaluation languages ml mth 
evaluation relation ht ui hc di hc di fst hc di snd tu inl inl inr inr inl case inl inr inr case inl inr sequent calculus review sequent calculus presentation intuitionistic logic 
objects derived calculus exactly sequents gamma version natural deduction 
difference appears form rules 
firstly cut rule gamma delta gamma delta taken primitive sequent calculus 
axiom structural rules 
logical rules different structured left right rules elimination rules 
right rules rules natural deduction 
left rules introduce principal connective left turnstile 
logical rules gamma gamma delta gamma delta gamma gamma gamma gamma gamma oe gamma gamma gamma oe oe gamma gamma delta gamma oe delta gamma gamma gamma gamma gamma gamma gamma gamma gamma importance sequent calculus symmetries brings light forcefully argued girard glt 
symmetries partially view intuitionistic sequent calculus incorporates important asymmetry single formula appear right hand side turnstile 
intimately linked possibility functional interpretation intuitionistic logic corresponds asymmetric nature functions respect inputs premises outputs 
symmetry exist left right rules nicely related earlier discussion constructors destructors 
constructors generated right rules build structure output 
destructors generated left rules decompose structure input 
familiar instance pattern conditional generalized case statement typed calculus generally destructors correspond pattern matching important feature functional programming languages bw fh tur 
function types destructor application decomposes function graph 
term assignment sequent calculus show terms assigned proofs sequent calculus 
terms assigned form sequents course exactly natural deduction 
point show actual assignments corresponding sequent calculus rules 
principle follow automatically known translations sequent calculus natural deduction see glt known 
cut rule gamma delta gamma delta logical rules gamma gamma delta gamma delta ht ui gamma gamma gamma fst gamma gamma snd oe gamma gamma gamma oe oe gamma gamma delta gamma oe delta gamma gamma gamma inl gamma gamma inr gamma gamma gamma gamma case inl inr note terms generated cut free proofs normal form particular terms generated left rules variables head position redexes created 
redexes arise result substitutions performed applications cut rule 
computation concentrated process cut elimination 
intuitionistic linear logic basic idea linear logic gir control resources 
functional framework resource may taken piece information data supplied input computation 
structural rules intuitionistic logic excluding trivial exchange rule allow copy resources contraction discard weakening contraction gamma gamma weakening gamma gamma specifically contraction allows multiple occurrences variable appear proof term weakening allows variables introduced premises appear proof term 
linear logic arises dropping structural rules 
means input exactly producing output 
immediate implications interpretation logical connectives 
firstly find distinct interpretations conjunction programming terms type pairs values arise ffl wish components pair unique occasion input lose ability project 
leads version conjunction tensor product omega ffl wish project unique occasion input choose take second projection part input see 
additive conjunction appears kind choice external choice terminology csp hoa consumer datum 
ffl disjoint sum additive disjunction phi appears internal choice discretion producer datum choice value form inl value form inr 
ffl linear implication gammaffi type functions argument exactly internalizing linear inference 
connectives far weak provide useful expressive power 
regained weakening contraction controlled form omnipresent structural rules reflected datatype exponential course 
effect copies value type available may needed 
recovered adequate expressive power witnessed fact intuitionistic logic interpreted linear logic connectives 
particular intuitionistic implication recovered oe gammaffi decomposition implication programming terms function type interesting aspects linear logic 
flesh intuitive ideas giving sequent calculus formalization intuitionistic linear logic 
axiom id structural rule exchange gamma delta gamma delta cut rule gamma delta gamma delta logical rules gamma gamma gamma gamma omega gamma gamma delta gamma delta omega omega gamma gamma gamma omega gammaffi gamma gamma gamma gammaffi gammaffi gamma gamma delta gamma gammaffi delta gamma gamma gamma gamma gamma gamma gamma gamma gamma phi gamma gamma gamma phi gamma gamma phi phi gamma gamma gamma gamma phi gamma gamma gamma dereliction gamma gamma gamma means sequence form 
contraction gamma gamma weakening gamma gamma essence distinction additive multiplicative connectives conveyed fact different contexts combined interaction omega gamma gammaffi gamma contexts gamma phi gamma 
reflects fact additives choice components pair guards case phi inputs alternatives ensure input exactly producing output 
note key role left rules defining type proper treatment rules technical crux computational interpretation intuitionistic linear logic 
linear term calculus give terms proofs intuitionistic linear logic 
calculus terms drawn refinement calculus 
key role played pattern matching constructs corresponding left rules logic 
minor complication syntax terms context free reflect linearity constraints syntactic constraints occurrences variables corresponding semantic constraint inputs exactly 
formalize notions convenient auxiliary syntactic category patterns 
range finite sets variables 
px set patterns variables defined follows hx xi fxg omega fx yg define linear terms free variables inductively follows ffl fxg ffl ffl omega tu ffl ht ui ffl inl inr ffl fxg ffl ffl fxg fyg fx yg case inl inr assignment linear terms proofs intuitionistic linear logic style term sequent calculus previous section 
sequents form linear formulae built connectives omega gammaffi phi distinct variables fx note rules subject implicit constraint linearity conditions formedness terms satisfied 
constraint met distinct variables instances axiom 
axiom id structural rule exchange gamma delta gamma delta cut rule gamma delta gamma delta logical rules gamma gamma gamma gamma omega gamma gamma delta gamma delta omega omega omega gamma gamma gamma omega omega gammaffi gamma gamma gamma gammaffi gammaffi gamma gamma delta gamma gammaffi delta gamma gamma gamma gamma ht ui gamma gamma gamma hx gamma gamma yi phi gamma gamma gamma inl phi gamma gamma inr phi phi gamma gamma gamma gamma phi case inl inr gamma gamma gamma dereliction gamma gamma contraction gamma gamma weakening gamma gamma operational semantics give operational semantics linear term calculus exactly style supporting intuitions semantics calculus previous section 
notable difference emerges immediate evidence refined computational content linear types 
intuitionistic logic perfectly neutral evaluation strategy adopt calculus linear logic logical structure types gives clear indication form evaluation employ ffl term tensor type omega know consumer destructor context delta omega evaluate term pair components 
clearly indicates eager evaluation 
similarly term type gammaffi evaluate abstraction applied argument evaluate exactly 
evaluation argument exactly slogan call value myc 
consumer term type phi evaluate term form inl inr evaluating appropriate arm case statement eager evaluation indicated 
ffl hand value type evaluate pair exactly component context 
predict component clear evaluating component advance actual lead general redundant computation 
lazy evaluation indicated 
value type may discarded altogether evaluation advance actual may lead redundant computation lazy evaluation indicated 
get classification ffl omega gammaffi phi eager evaluation ffl lazy evaluation particularly interesting interpret intuitionistic types theta gammaffi see intuitionistic function type operationally call name lazy argument frozen lazy evaluation type 
mixed evaluation strategy linear types incorporating high degree eager evaluation supports lazy evaluation higher level intuitionistic types 
say gives rational reconstruction logical terms standard method implementing lazy evaluation top eager evaluation strategy introduced landin lan secd cam machines hen hue 
idea standardly modelled denotational semantics lifting plo type partial alternatively strict functions 
account requires presence divergent programs linear decomposition gammaffi 
motivating remarks operational semantics 
canonical forms ht ui omega inl inr canonical 
evaluation relation omega omega omega omega tu ht ui ht ui hv wi hx hv wi yi inl inl inr inr inl case inl inr inr case inl inr rules codify previous discussion direct fashion 
note rules corresponding contraction weakening respectively copy discard inputs 
pragmatics implementation section sketch promising applications program analysis optimization opened computational interpretation intuitionistic linear logic previous section 
describe secd machine implementation linear calculus 
logical compilation mentioned translation intuitionistic logic intuitionistic linear logic 
full translation formulas follows oe ffi ffi gammaffi ffi ffi ffi ffi ffi ffi phi ffi important note translation works just level theorems provable sequents proofs 
proof sequent gamma intuitionistic sequent calculus translated proof gamma ffi ffi intuitionistic linear logic 
turn induces translation terms linear terms 
throws interesting aspect curry howard isomorphism seen discussed literature interpretation logic level proofs induces compiler programs corresponding proofs programs course correctness compiler follow directly logical properties interpretation 
particular appropriate speak compiling terms linear terms linear types finer grained lower level programming sense 
describe translation explicitly see gir details 
main points sufficiently clear examples 
examples 
consider combinators fx gx terms linear uses twice discards consider linear terms fx gy derive typing judgements ff gammaffi fi gammaffi fl gammaffi ff gammaffi fi gammaffi ff gammaffi fl ff gammaffi fi gammaffi ff logic program analysis examples illustrate point typings obtained general terms 
optimize types obtained uniform translation linear logic 
ff oe fi oe fl oe ff oe fi oe ff oe fl ffi ff gammaffi fi gammaffi fl gammaffi ff gammaffi fi gammaffi ff gammaffi fl ff oe fi oe ff ffi ff gammaffi fi gammaffi ff introducing fewer types increase eager possibly parallel evaluation course justification improved typings 
exactly kind information strictness analysis tries extract ah 
uses information explicit linear types 
know value shared type safely update place necessarily unique occasion access get handle place update analysis ah 
consider refinements type instances indexed expressions describe patterns usage precise ways 
done complexity theory gss system bounded linear logic described graded resource polynomials 
leads term assignment exactly polynomial time computable functions typable 
connections complexity analysis san 
general framework suggested ideas called logic program analysis analogy established subject semantics program analysis ah gj 
course approaches complementary 
real applicability approach remains demonstrated looks genuinely promising number researchers preliminary investigations lines laf hol wad 
contribution suggest linear term calculus introduced previous section may form medium performing static analysis optimization 
may start standard functional program translate uniform method linear calculus try linearize minimize usage exponential types 
provide sound basis performing useful optimizations 
linear secd machine describe implementation linear term calculus variant secd machine lan 
possibilities parallel evaluation calculus exist implementation shall describe purely sequential 
case potential parallel execution greater classical linear logic treated sections 
follow lucid exposition standard secd machine hen fairly closely 
machine list structured store 
shall turner notation tur list operations empty list infix cons delta delta delta 
objects manipulated machine inductively defined follows ffl code list instructions 
ffl instruction forms hd tl ret push pop ap unit pair fst snd inl inr case read dup codes 
ffl value forms inl inr fcl ccl ocl values codes environment 
values form fcl ccl ocl called function choice course closures respectively 
ffl environment list values 
state machine determined registers ffl current expression evaluation stack evaluation terminates resulting value top stack 
ffl environment giving values free variables current expression 
ffl code corresponding current expression 
ffl dump stack suspended procedure activations represented triples 
operation machine described transition rules specifying effect instruction see 
note instruction obviously implemented constant time conventional machine 
define compiler linear terms secd codes 
precisely define function linear term list variables variable occurs yields code linear secd machine 
definition induction structure 
notation infix list concatenation 
tl tl hd index occurence starting 
unit omega pair omega push push pop pop pop ret tu push ap gamma 
hd gamma 
tl gamma 
ret gamma 
push gamma 
pop gamma 
gamma 
fcl unit gamma 
gamma 
pair gamma 
gamma 
fcl ap gamma 
gamma 
ccl ccl fst gamma 
ccl snd gamma 
inl gamma 
inl inr gamma 
inr inl case gamma 
inr case gamma 
gamma 
ocl ocl read gamma 
dup gamma 
linear secd machine transitions ht ui ret ret hx fst push pop yi snd push pop inl inl inr inr case inl inr case pop ret pop ret ret read push pop dup push push pop pop correctness implementation respect operational semantics stated follows 
write 
closed code value write gamma 
correctness implementation typable programs attempt prove correctness 
main point implementation independent semantics respect correctness formulated 
yves lafont described implementation intuitionistic linear logic terms linear machine laf related machine way categorical machine related standard secd machine see hue 
reader referred laf interesting discussion implications implementation kind storage allocation particular elimination garbage collection 
implementation means committed complete avoidance sharing 
dup instruction interpreted usual way list structured memory creates copy pointer top stack implementing copying type sharing 
little additional ensure standard function type gammaffi implemented standard call need technique pj 
shall briefly describe done 
firstly introduce new instruction upd new form value representing consolidation value closure 
compilation changed replacing ret upd 
transition read replaced transitions ocl read gamma 
read gamma 
notation ocl means location cell representing closure 
transition upd upd gamma 
transition location closure written consolidated value 
approach just values non exponential types implemented sharing 
offer better balance sequential implementations lafont approach consistent idea linear types increase efficiency described previous subsection 
contrast situation different parallel implementation avoidance sharing potentially greater benefits 
concurrent operational semantics classical linear logic section avoid sharing thorough going fashion parallel implementation discussed section 
basic theory linear calculus systems considered far weak expressive power corresponding logical terms intuitionistic propositional calculus programming terms simple typed calculus linear refinements 
shall deceptively simple looking extension fact generates enormous increase expressive power 
addition second order propositional quantifiers programming terms impredicative quantification types enabling definition polymorphic functions 
implicit typing approach extension looks particularly simple appear term level philosophy types compile time constraints actual computation 
reflects current practice languages ml mth miranda tur haskell hw 
syntax formulas extended propositional variables ff fi fl universal quantifier ff system ill sequent formulation linear logic section extended second order version ill rules gamma gamma gamma ff gamma gamma ff gamma ff right rule subject side condition ff appear free gamma 
linear term calculus unchanged term assignment extended ill follows gamma gamma gamma ff gamma gamma ff gamma ff course operational semantics left unchanged 
system seen refinement system glt second order intuitionistic propositional calculus term assignment implicit typing version accordingly name system lf linear system 
system interpreted lf obvious extension translation intuitionistic logic ill mentioned 
significance system represent provably total recursive functions second order arithmetic glt 
inductive types lists trees encoded system surveys programming system see glt rey hue 
determinacy convergence turn basic metatheory system lf 
major results system undoubtedly satisfies church rosser strong normalization properties glt 
results concern reduction apply strategies 
church rosser property implies reduction strategies lead result normal form terminate strong normalization says strategies fact terminate 
analogous properties formulated terms style operational semantics 
corresponding church rosser property determinacy closed implies corresponding strong normalization convergence closed typable system lf derived lf type properties say evaluation prima facie just binary relation programs canonical forms fact total function typable programs 
properties clearly weaker cr sn study 
ffl firstly results extend smoothly situations stronger properties fail 
example section prove corresponding results computational interpretation classical linear logic church rosser property fails theory reduction applied sequent proofs proof nets gir 
extend calculus general recursion strong normalization definitely lost convergence refined semantic soundness dm plus computational adequacy mc 
ffl explained evaluation relation reflects intrinsic computational content linear types natural object study 
ffl proofs determinacy convergence considerably simpler technical proofs cr sn 
firstly theorem system lf satisfies determinacy 
proof 
induction length inference form case clause inductive definition evaluation relation applicable 
induction hypothesis rules corresponding phi gamma applicable 
turn convergence 
proof simplified suitably modified version girard original proof sn system gir see gal exposition 
idea evaluation relation give realizability semantics types 
take semantic type set closed linear terms subset 
interpret linear connectives follows ft omega ft omega gammaffi ft tu ft hu vi phi ft inl inr ft ug 
define ff definitions induce semantic function delta texp tenv 
texp set linear type expressions tenv tvar 
set type environments mapping type propositional variables semantic types 
give realizability interpretation sequents gamma tenv gamma state basic result theorem realizability gamma derivable system lf gamma proof 
induction derivation gamma lf 
cases illustrate argument quite sufficiently 

gammaffi gamma gamma delta gamma gammaffi delta gamma delta gammaffi induction hypothesis gamma gammaffi implies wt induction hypothesis delta wt linearity wt gamma gammaffi delta required 

contraction gamma gamma gamma induction hypothesis gamma applying definition evaluation relation conclude required 

gamma gamma gamma ff induction hypothesis gamma gamma ff occur free gamma equivalent gamma ff 
gamma ff simple consequence realizability theorem theorem system lf satisfies convergence 
proof 
suppose derivable system lf 
apply gamma freely loss generality assume closed 
realizability theorem 
write ff quantifier outermost 
ff contradicting 
case realizability semantics outermost connective immediately implies 
classical linear logic intuitionistic linear logic essentially refinement ordinary intuitionistic logic computational interpretation refinement calculus 
full system linear logic emphasis refer classical linear logic cll represents radical departure tradition constructive logic computational interpretation requires corresponding departure functional framework 
basic step extension intuitionistic classical linear logic linear negation idea obey kind laws classical negation constructive content retained linearity 
requires number new connectives duals existing ones dual par dual omega 
dual dual 
additive constructs phi dual cll 
linear negation characterized laws omega phi ff ff gammaffi syntax linear formulas cll defined follows 
formulas built propositional variables ff fi fl linear negations ff fi fl connectives quantifiers units multiplicatives omega additives phi exponentials 
quantifiers linear negation definitionally extended general formulas equations linear implication treated derived operator defined equation 
proof system cll fully symmetric sequent calculus sequents form gamma delta intended meaning formula gamma gammaffi delta valid 
considerable economy observing sequent gamma delta equivalent sequent gamma delta sufficient consider right sided sequents 
sequent calculus presentation cll follows 
axiom exchange gamma delta gamma delta cut gamma delta gamma delta unit perp gamma gamma times gamma delta gamma delta omega par gamma gamma gamma gamma gamma plus gamma gamma phi plus ii gamma gamma phi dereliction gamma gamma course gamma gamma weakening gamma gamma contraction gamma gamma gamma gamma ff exists gamma ff gamma ff note rules obtained rules ill equations shifting premises right turnstile 
example gamma phi gamma translate instances rule gammaffi gamma translates par rule gammaffi gamma times rule 
particular shows ill interpreted subsystem cll intuitionistic logic interpreted cll 
question arises give computational interpretation cll merely extension ill embodies radical change perspective asymmetry inputs outputs abolished apparently formal fiat 
mean computational terms 
sharpen ideas focus cut rule 
ill appears gamma delta gamma delta cll gamma delta gamma delta important formal difference versions cut rule 
intuitionistic version asymmetric left premise distinguished right fact cut formula appears output position input position premise 
reflected programming level fact cut interpreted system lf non commutative operation function composition expressed syntactically substitution 
contrast cut rule cll fully symmetric cll equality equally write delta gamma delta gamma exchange rule different order formulas resulting sequent significant 
programming level expect interpret cll cut rule commutative operation 
point natural invoke concurrency theory offering just kind generalization need 
milner emphasized concurrency mil mil communicating processes thought generalization functions key operation parallel composition commutative operation generalizes function application composition 
may attempt replace expression evaluation concurrent process execution underlying computational paradigm interpret cut suitable form parallel composition 
course ideas entirely line girard emphatic hints classical linear logic opens way logical view parallel computation gir gir 
shall computational interpretation cll seeks embody ideas simple elegant form general framework established preceding sections 
define syntax proof expressions give proof expressions sequent proofs cll operational semantics proof expressions 
syntax proof expressions firstly point terminology shall list mean finite sequence 
define number syntactic categories ffl set names ranged range lists names 
ffl terms forms omega inl inr terms proof expressions 
ffl form terms 
theta xi range lists 
ffl proof expressions form theta theta list list terms 
range proof expressions 
notation 
occurrences term form said passive occurrences active 
syntactic expression term proof expression write set names occurring pn set names occurring actively passively shall define assignment proof expressions sequent proofs cll 
idea proof pi sequent assign proof expression theta theta corresponds uses cut rule pi 
ensure suitable linearity constraints satisfied shall adopt name convention cf 
variable convention bar different names introduced instance axiom course rules 
proof expression assignment cll axiom exchange theta gamma delta theta gamma delta cut theta gamma xi delta theta xi gamma delta unit perp theta gamma theta gamma 
times theta gamma xi delta theta xi gamma delta omega omega par theta gamma theta gamma theta gamma xi gamma gamma theta xi plus theta gamma theta gamma inl phi plus ii theta gamma theta gamma inr phi dereliction theta gamma theta gamma weakening theta gamma theta gamma contraction theta gamma theta gamma course theta gamma gamma theta theta gamma theta gamma ff exists theta gamma ff theta gamma ff operational semantics linear cham complete computational interpretation classical linear logic giving operational semantics proof expressions 
directly defining relation evaluation canonical form shall define step transition relation proof expressions define canonical forms certain normal forms respect relation 
notion computation proof expressions inherently parallel model form pool concurrent processes 
fact presentation operational semantics fits nicely framework chemical machine proposed berry boudol bb paradigm concurrent machines 
describe basic ideas available concurrency models architectural concepts networks processes communicating means ports channels 
concepts convey rigid geometrical vision concurrency 
chemical machine model radically different paradigm concurrent components freely moving system communicate come contact 
intuitively state system chemical solution floating molecules interact reaction rules magical mechanism solution allowing possible contacts molecules chemistry result brownian motion don insist particular mechanism implementation matter 
solution transformation process obviously truly parallel number reactions performed parallel provided involve disjoint sets molecules 
molecules linear cham 
refer theta theta solution main body 
idea computation done solution result recorded main body 
think single sequential process tightly coupled synchronous parallel composition processes proceeding lockstep 
modelled membranes berry boudol terminology shall pursue idea 
distinguish kinds rule cham cf 
mil structural rules describe magical mixing solution reaction rules describe actual computation steps 
structural rules basic structural rules ffl ff ffl ff says regarded multiset exactly terms second lists regarded multisets 
rules applied context theta ff xi theta ff xi basic metarule cham refers transition relation gamma 
defined 
magical mixing rule ff gamma 
ff gamma 
regard metarule really part specification machine description actual computation step 
notational variants shall need consider variants terms occurring proof expression copies names replaced fresh names occurring order implement global condition local way need little extra structure 
fix bijection theta fl rg extend name convention name hx si introduced proof expression component distinct name occurring expression 
term define result replacing occurrence name hx si hx sli hx sri respectively 
idea invariant established proof expression assignment maintained transition relation defined distinct names hx si hy ti occurring implies incompatible upper bound prefix ordering 
reaction rules rules describe lists adjacent react giving rise new lists 
notation write denote list communication gamma 
unit gamma 
pair omega gamma 
case left theta xi inl gamma 
theta case right theta xi inr gamma 
xi read theta gamma 
theta discard gamma 
copy gamma 

reaction rules contribute global transition relation proof expressions metarule reaction context rule theta gamma 
xi theta theta theta gamma 
theta xi theta cleanup rule rule computation consolidating information back main body proof expression theta somewhat analogous collecting answer substitution prolog computation 
cleanup theta gamma 
theta define result computation 
proof expression theta canonical gamma normal form theta form name cut free theta empty 
definition define evaluates canonical form def gamma 
canonical discussion firstly consider computational intuitions rules 
key rule communication involves interaction 
ill calculus variables place holders substitution 
cll occurrences name thought ends channel communication rule uses channel connect processes terms 
linearity amounts restriction channels 
computational aspect interesting rules additives exponentials 
cases lazy types concurrent framework implemented form explicit synchronization 
role forms 
cases proof expressions suspended execution resumed sufficient information available computational terms sufficient demand generated 
case additives rule classical dualities equivalent intuitionistic rule phi gamma corresponds case statement choice alternatives 
clearly want evaluate expression corresponding alternative chosen wait choice 
done term cut term denoting proof dual phi form inl proof inr proof case left case right rules 
defer evaluation proofs side formulas gamma rule choice 
don know till proofs taken 
accomplished replacing proof terms names turn embedded complex proof terms cut terms 
names rises surface computation able proceed choice associated rule generated name resolved application case left case right rule 
suppose case left rule applied 
point released solution communication rule bond form proceed 
similar considerations apply rules exponentials 
idea term type specifies copies term type required terms side formulas gamma course rule generated term directed ask corresponding multiple copies input 
logical side reaction rules correspond exactly key steps cut elimination precisely evaluation canonical form 
spelled detail proof realizability theorem reader strongly encouraged transitions described detail 
rule clear logical content 
brief remarks relationship proof expressions girard proof nets gir 
detailed comparison left 
roughly speaking proof expressions correspond proof nets lazy forms proof boxes reaction rules symmetric contractions described gir 
precise comparison require care example channels axiom contraction synchronization associated lazy types calculus appear proof net formalism 
author impression representations merits uses ffl proof nets visually appealing support geometric insights structure proofs 
multiplicative fragment boxes cumbersome negates advantages 
ffl proof expressions efficient syntactic vehicle making precise definitions carrying detailed proofs linear notation writing linear proofs 
reader left form opinion relative merits proof expressions vs proof nets syntactic medium importantly succeeded making computational reading linear logic particularly connections concurrent computation substantial convincing 
full evaluation include material sections 
briefly indicate significant difference approach compared girard overlooked 
keeping general philosophy operational semantics set section operational semantics evaluation canonical form normal form 
feel choice amply justified general arguments section evidence definitions section detailed results section 
recapitulate ffl operational definitions compact elegant memorable calculus gir 
ffl correspond better done implementation 
see section 
ffl considerable technical benefits main determinacy preserved 
see theorem lemma 
time lost see theorem 
realizability interpretation linear types essentially girard computation rules suffice prove realizability theorem 
basic theory pe name formal system second order propositional cll assignment proof expressions pe analogy girard pn 
shall study basic properties system 
notation 
write pe theta gamma sequent theta gamma derivable pe firstly consider important structural conditions proof expressions 

linearity 
proof expression linear ffl name occurring exactly twice 
ffl term occurring proof expressions linear 

acyclicity 
proof expression define graph types arc follows ffl nodes set occurrences terms 
blur distinction terms occurrences notation reader aware 
ffl arc iff conditions holds occurs omega omega occurs occurs occur occurring ffl arc iff disjoint occurrences 
cycle sequence delta delta delta occurrence repeated proof expression acyclic cycles 
acyclicity understood appropriate hereditary condition ensure self loops appear typable proof expression apply transitions 
read disjoint connected 
acyclicity precludes contradictory situation nodes disjoint connected 
proposition pe theta gamma theta linear acyclic 
proof 
induction derivations pe linearity immediate form rules name convention 
acyclicity consider case cut rule theta gamma xi delta theta xi gamma delta name convention theta xi link proof expressions 
cycle theta xi fact lie theta xi contra hypothesis 
proposition suppose gamma 
linear acyclic proof 
firstly show linearity preserved cases rule derive gamma 
unit pair trivial 
communication gamma 
net effect delete occurrences cleanup theta gamma 
theta 
linear net effect delete occurrences case left inl gamma 
theta theta definition linearity linear implies linear 
name occurring occurrences net effect transition delete occurrences 
case right symmetrical case left 
read trivial transition effect number name occurrences 
discard gamma 
similarly case left linear effect delete occurrences 
copy gamma 

linear delta delta rename outside net effect delete add copies furthermore linear 
show preserved require assumption linear 
general technique show cycle transformed contradicting assumption acyclic 
argue cases gamma 
derived 
cleanup theta gamma 
theta 
path delta delta delta delta delta delta transformed delta delta delta delta delta delta communication gamma 
cycle transformed replacing sub path delta delta delta delta delta delta delta delta delta delta delta delta unit trivial 
pair omega gamma 
consider link delta delta delta delta delta delta putative cycle replace link delta delta delta delta delta delta case replace delta delta delta omega delta delta delta case left inl gamma 
theta theta linear assumption disjoint remainder cycle containing links cycle containing link lie entirely cycle occurred case right read similar case left 
discard trivial 
copy gamma 

arguing proof linearity know linear disjoint rest cycle containing node lie wholly imply cycle contra hypothesis 
similarly cycle replacing sub paths delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta obtain cycle contra hypothesis 
case done yields delta delta delta delta delta delta replace delta delta delta delta delta delta 
remainder section assume proof expressions consideration linear acyclic 
determinacy prove suitable version determinacy pe state properly need definition 
definition renaming permutation ae extended substitution terms proof expressions usual way 
define structural equivalence proof expressions def ae ae ff structural equivalence merely factors irrelevant syntactic detail similarly ff equivalence calculus bar 
state appropriate form determinacy determinacy remainder subsection devoted proving property 
firstly convenient decompose transition relation gamma 
define gamma 
iff gamma 
derived reaction rules gamma 
iff gamma 
derived cleanup rule 
clearly gamma 
gamma 
gamma 
proposition gamma 
gamma 
ff gamma 
gamma 
proof 
critical pair gamma 
arises communication rule 
acyclicity precludes situation remaining possibility psi gamma gamma gamma gamma gamma gamma psi gamma gamma gamma gamma gamma gamma proposition gamma 
gamma 
gamma 
gamma 
proof 
case critical pair theta psi gamma gamma gamma gamma gamma gamma theta theta proposition gamma 
gamma 
gamma 
gamma 
proof 
linearity case critical pair theta psi gamma gamma gamma gamma gamma gamma theta theta theta theta proposition gamma 
gamma 
gamma 
gamma 
proof 
theta gamma 
theta gamma 
xi gamma 
xi gamma 
xi standard arguments bar propositions imply corresponding properties gamma 
gamma 
show gamma 
confluent structural equivalence 
theorem gamma 
gamma 
gamma 
gamma 
proof 
consider diagram delta delta delta delta delta delta firstly proposition gamma 
written gamma 
gamma 
similarly gamma 
filled ff proposition filled filled proposition 
immediate corollary confluence theorem determinacy convergence aim subsection prove convergence pe theta gamma theta fact shall prove stronger result typable proof expression canonically strongly normalizing notation csn transition sequence gamma 
gamma 
gamma 
delta delta delta ends canonical form 
firstly prove useful lemma play role analogous girard standardization theorem gir 
lemma gamma 
csn csn 
proof 
making number reductions proved 
firstly clearly suffices prove gamma 
csn csn general case follows immediately induction 
note suffices prove gamma 
sn sn suppose holds gamma 
csn 
transition sequence ends normal form determinacy canonical form evaluates 
suffices prove gamma 
sn sn sn means gamma 
sequence starting ends gamma 
normal form 
fact sn sn 
see suppose contradiction sn 
infinite sequence gamma 
gamma 
gamma 
delta delta delta infinitely gamma 
steps sequence proposition construct infinite gamma 
sequence sn 
finitely gamma 
steps infinite gamma 
sequence impossible gamma 
obviously strongly normalizing 
prove 
suppose gamma 
infinite sequence gamma 
gamma 
gamma 
delta delta delta propositions proceed diagram delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta diagram extended indefinitely ff case infinite gamma 
sequence sn sn required 
define def immediate corollary lemma proposition csn 
light proposition write csn 
define def 
proceed proof convergence lines girard proof strong normalization pn gir style section significant modifications dictated differences framework 
firstly notation 
proof expressions theta xi define cut theta xi precisely choose form cut compare definition substitution bar generally take renaming granted refer explicitly 
note cut defined proof expressions non empty main body shortly take steps minor nuisance 
define def cut definition easily seen independent choice pe set linear acyclic proof expressions non empty main body 
pe define fp pe standard facts galois connections coh proposition operator delta monotone inflationary idempotent 
ii 
iii pe pe 
semantic type subset pe satisfying ffl ffl ffl write set semantic types 
lemma cut 
proof 
suppose 
possibilities sn 
lemma implies sn sn cut cut 
non canonical normal form 
means gamma 
theta names reaction rule applicable cut gamma 
xi normal form derivable expression contain non canonical 
case entirely similar 
lemma pe ii proof 
cut lemma 
ii see suppose cut gamma 
lemma cut required 
proposition pe satisfies proof 
lemma proposition ii 
give realizability interpretation linear types elements firstly define operations proof expressions corresponding logical rules pe id unit perp theta theta par theta theta times theta xi theta xi omega theta theta inl theta theta inr ofcourse der theta theta weak theta theta con theta theta provisos renaming cut construct apply operations ensures cut operations create communication arguments 
easily follows operations satisfy delta delta delta sense purpose realizability semantics formulate sufficiently strong inductive hypothesis allow extend cut 
define ff ug propositions remarks immediately preceding definitions yield semantic types 
remaining connectives defined duality force equations satisfied omega phi definitions induce semantic function delta texp tenv texp set linear type expressions formulae cll tenv tvar set type environments ranged lemma texp tenv proof 
immediate fact realizability interpretation linear connectives satisfies 
give realizability interpretation pe sequents 
firstly theta xi define delta theta xi standard proviso renaming ensure disjoint write pq delta delta delta abbreviate delta delta delta delta delta delta delta delta 
define theta gamma def tenv gamma theta gamma gamma final preliminary define shift operator pe oe theta theta clearly oe 
generally permutation kg theta theta note relationship cut oe delta prove basic result realizability interpretation 
theorem realizability pe theta gamma theta gamma 
proof 
induction derivations pe 
axiom fix tenv show id pq 
id pq gamma 
cut cut assumption 
id pq 
exchange immediate remarks permutations preceding theorem 
cut theta gamma xi delta theta xi gamma delta theta xi fix tenv gamma delta show cut 
induction hypothesis pr qs 
oe oe cut oe oe 
cut oe oe ff cut cut 
perp theta gamma theta gamma theta fix tenv gamma show 
perp qq oe perp proposition iii suffices show oe perp perp 
perp gamma 
induction hypothesis perp qq 
unit show 
proposition delta inflationary unit cut unit 
par theta gamma theta gamma theta fix tenv gamma show par qq oe par applying proposition iii definition see sufficient consider form times par gamma 
qrs induction hypothesis qrs par 
times theta gamma xi delta theta xi gamma delta omega omega theta xi fix tenv gamma delta show omega times qr 
induction hypothesis ps qt 
oe oe applying proposition specifically fact delta inflationary definition see times oe oe cut times oe oe 
cut times oe oe ff times qr times qr 
theta gamma xi gamma gamma theta xi fix tenv gamma show pr 
reasoning case par suffices consider form case gamma 
ps induction hypothesis ps pr 
second case similar 
plus left theta gamma theta gamma inl phi theta fix tenv gamma show phi qq 
induction hypothesis qr oe oe phi cut oe 
cut oe ff qq qq 
plus right similar plus left 
dereliction theta gamma theta gamma theta fix tenv gamma show der qq 
reasoning case par suffices consider form ofcourse der gamma 
qr induction hypothesis qr 
der qq 
contraction theta gamma theta gamma theta fix tenv gamma show con qq 
reasoning case par suffices consider form ofcourse con gamma 
con con xi xi recall renaming definition delta 
con induction hypothesis con qq 
weakening theta gamma theta gamma theta fix tenv gamma show weak qq 
suffices consider form ofcourse weak gamma 
weak weak 
induction hypothesis weak qq 
course theta gamma theta gamma theta fix tenv gamma show ofcourse qq 
induction hypothesis qr oe ofcourse oe cut ofcourse oe 
show implies ofcourse qq 
firstly claim sufficient prove ofcourse qq form ofcourse ofcourse ofcourse see define oe gamma theta theta note ofcourse qq par gamma oe gamma ofcourse times gamma oe par gamma oe gamma ofcourse times gamma oe par gamma oe gamma ofcourse gamma gamma ofcourse gamma jg oe par gamma oe gamma ofcourse gamma ofcourse gamma jg proposition iii 
establish desired relationship cut ofcourse oe ofcourse qq 
corresponding point proof gir girard able commutative conversions ofcourse qq gamma 
cut ofcourse oe commutative conversions part calculus need elaborate argument 
shall technique inspired concurrency theory mil 
say relation pe simulation satisfies prq gamma 
gamma 
gamma 
rq need establish notation 
write ofcourse qq xi cut ofcourse oe xi theta xi disjoint names occurring remainder expressions 
define relation rq iff xi sk sk sk xi sk sk sk fs pairwise incompatible subset fl rg sk xi disjoint names occurring remainder expressions 
ffl xi xi ofcourse ofcourse oe 
claim simulation 
prove suppose rq consider various cases gamma 
rule applied occur xi take apply rule corresponding get rq communication rule applied xi possibility condition names xi incorporated definition corresponding rule applied obtain rq final case considered rule applied loss generality magical mixing rule take 
sub cases 
read rule applied say case gamma 
gamma 
xi theta sk sk sk xi theta sk sk sk ii discard rule applied case gamma 
gamma 
xi sk sk sk xi sk sk sk iii copy rule applied case gamma 
gamma 
xi sk sk sk xi sk sk sk prove cut ofcourse oe ofcourse qq 
define finite infinite sequence rq follows ffl ofcourse qq cut ofcourse oe 
ffl normal form sequence terminates choose gamma 
fact rq obtain gamma 
gamma 
rq suppose ofcourse qq 
cases ffl ofcourse qq infinite gamma sequence applying argue induction infinite gamma sequence sequence infinite 
means infinite gamma 
sequence 
ffl ofcourse qq gamma 
non canonical normal form applying determinacy sequence non canonical normal form 
clearly rq implies non canonical normal form 
case see ofcourse qq cut ofcourse oe ofcourse cut ofcourse oe ofcourse qq required 
theta gamma theta gamma ff theta fix tenv gamma show ff qq 
reasoning case par suffices consider ff 

condition gamma gamma ff 
induction hypothesis respect ff 
qq 
exists theta gamma ff theta gamma ff theta fix tenv gamma show ff qq 
induction hypothesis ff qr 
ff ff 
ff 

just point proof secondorder comprehension 
oe ff cut oe 
cut oe ff qq qq 
immediate consequence realizability theorem get theorem convergence pe theta gamma theta 
proof 
realizability theorem pe theta gamma theta gamma choose tenv gamma conclude implies lemma 
canonical vs cut free expect distinction canonical cut free arises practice lazy types fully evaluate proofs lazy types advance information telling arm case statement evaluated copies required 
task subsection turn expectation theorem 
provide nice illustration acyclicity guarantees deadlock freedom 
proposition pe theta gamma theta xi gamma contain occurrences pn 
proof 
sketch proof result surprising details quite lengthy 
idea introduce typed version pe church style cf 
bh proof expressions embedded types particular names decorated types 
quantifier rules interpreted non trivially version theta xi gamma theta gamma ff xi ff theta gamma ff theta gamma hb ti ff ff occur free theta rule 
rules linear cham modified fairly obvious fashion interesting case communication rule gamma 
note new typed 
new reaction rule quantifier forms ff theta hb ui gamma 
theta ff ff previous results section transferred typed version system 
consider property typed proof expressions occurring contain occurrences pn 
property easily checked hold derivable proof expressions preserved transition relation 
stripping types establishes proposition 
appearance hypotheses proposition surprise 
provides information hiding cf 
mp information hidden may include lazy types 
theorem pe theta gamma gamma contain occurrences theta cut free 
proof 
suppose contradiction xi cut free xi contains linearity occurrence xi main body active occurrence contradict canonical passive occurrence precluded assumption gamma proposition 
occurrence xi delta delta delta note canonical 
reasoning continue path indefinitely finite eventually get cycle contradicting acyclicity give examples illustrate theorem 
firstly note unique cut free proof axiom cut free proofs phi inl phi inr phi think phi type bool booleans say tt inl ff inr 
proof type bool containing cuts yield proof expression implies cut free tt ff computation type bool yield honest god explicit boolean value 
consider standard representation system natural numbers type church numerals ff ff oe ff oe ff oe ff translation cll yield type ff ff omega ff ff ff contains computations type general yield cut free results normal forms 
pointed gir essential exponential iterating successor function natural numbers fact defined linear logic type nat ff ff gammaffi ff gammaffi ff gammaffi ff ff ff omega ff ff ff theorem apply type get cut free proofs type nat 
idea applied usual order algebraic data types lists trees operational semantics yields fully evaluated cut free proofs observable types 
implementation notes firstly consider sequential implementation proof expressions 
main point show magical mixing linear cham fact implemented simple efficient way 
implementation uses data structures stack processed name queue 
internal representation names pointers entries queue 
entry states empty pending 
initially entry name empty 
encountered stack name queue entry pointed inspected 
empty state changed pending stored 
pending term stored entry deleted name queue returned free store pushed stack 
implements communication rule 
reaction rules implemented straightforwardly note copy rule requires creation new entries name queue 
worth pausing point note simple implementation closures environments garbage collection supports powerful higher order functional programming language system lazy eager modes evaluation 
consider prospects parallel implementation 
assume architecture network agents processor memory pairs capable sending data 
distributed network 
agent executes instance sequential interpreter described stack name queue held local memory 
names represented pairs network wide unique identifier agent name queue entry held location local memory agent entry 
names names represented global addresses 
difference way interpreter works encountered sent agent processing course incoming requests kind handled 
sherlock holmes story main point implementation scheme dog didn bark 
particular ffl requirement inter agent sharing synchronization arises handling names described 
simpler proposals architectures perform parallel graph reduction jjk 
ffl centralized resources 
distinguished nodes network 
agent runs instance program 
ffl elimination garbage collection probably greater value parallel implementation sequential 
ffl prospects applying static analysis techniques obtain mappings sets agent network optimize locality time name encountered agent near reducing cost communication 
particular linearity channels exactly determine strength connection terms simply count 
contrast occam csp hoa matters number channels processes common number times channels 
mapping algorithm attempt optimize locality making distance inversely proportional strength connection 
course far story 
significant point need loadbalancing maintaining loading network 
structure linear cham offers support 
rule increases size proof expression copy rule provides natural place loadbalancing performed 
hope static analysis techniques compile load balancing keeping trade locality 
remarks section speculative detailed needed evaluate ideas 
believe genuine promise 
key point closer marriage mathematical form computational content linear logic offer better possibilities efficient implementations arise naturally logical structure language 
abr abramsky 
computational interpretations linear logic 
technical report doc imperial college department computing october 
ah abramsky hankin editors 
interpretation declarative languages 
ellis horwood 
bar barendregt 
lambda calculus syntax semantics 
north holland revised edition 
bb berry boudol 
chemical machine 
conference record seventeenth annual acm symposium principles programming languages pages 
bh barendregt 
types lambda calculi programming languages 
proceedings esop 
bw bird wadler 
functional programming 
prentice hall 
coh cohn 
universal algebra 
reidel 
dm damas milner 
principal type schemes functional programs 
conference record ninth annual acm symposium principles programming languages pages 
fh field harrison 
functional programming 
addison wesley 
gal gallier 
girard de 

odifreddi editor logic computer science 
north holland 
gir 
girard 
interpr etation fonctionelle elimination des coupures dans arithm etique ordre sup erieur 
phd thesis university paris vii 
gir 
girard 
linear logic 
theoretical computer science 
gir 
girard 
geometry interaction interpretation system ferro editor logic colloquium 
north holland 
gir 
girard 
geometry interaction 
gray andre scedrov editors categories computer science logic volume contemporary mathematics pages 
american mathematical society 
gj ganzinger jones editors 
programs data objects volume lecture notes computer science 
springer verlag 
glt 
girard lafont taylor 
proofs types volume cambridge tracts theoretical computer science 
cambridge university press 
gss 
girard scedrov scott 
bounded linear logic 
buss scott editors proc 
math 
sci 
institute workshop feasible mathematics 
birkhauser 
hen henderson 
functional programming applications implementation 
prentice hall 
hoa hoare 
communicating sequential processes 
prentice hall 
hol holmstrom 
linear functional programming 
johnsson peyton jones karlsson editors proceedings workshop implementation lazy functional languages pages 
hue huet editor 
logical foundations functional programming 
addison wesley 
hw hudak wadler 
report functional programming language haskell 
technical report yaleu dcs rr department computer science yale university november 
jjk johnsson peyton jones karlsson editors 
proceedings workshop implementation lazy functional languages 
programming methodology group chalmers university 
kah kahn 
natural semantics 
proc 
symposium theoretical aspects computer science volume lecture notes computer science pages 
springer verlag 
laf lafont 
linear machine 
theoretical computer science 
lan landin 
mechanical evaluation expressions 
computer journal 
lan landin 
correspondence algol church lambda notation 
communications acm 
inmos occam manual 
prentice hall 
mc meyer 
semantical paradigms 
proc 
third annual symposium logic computer science pages 
computer society press 
mcc mccarthy 
basis mathematical theory computation 
hirschberg editors computer programming formal systems pages 
north holland 
mil milner 
calculus communicating systems volume lecture notes computer science 
springer verlag berlin 
mil milner 
communication concurrency 
prentice hall 
mil milner 
functions processes 
proceedings icalp volume lecture notes computer science pages 
springer verlag 
ml martin lof 
intuitionistic type theory 
bibliopolis 
mp mitchell plotkin 
types existential type 
conference record twelfth annual acm symposium principles programming languages pages 
mth milner tofte harper 
definition standard ml 
mit press 
myc mycroft 
theory practice transforming call need callby value 
robinet editor international symposium programming volume lecture notes computer science 
springer verlag 
pj peyton jones 
implementation functional programming languages 
prentice hall 
plo plotkin 
call name call value lambda calculus 
theoretical computer science 
plo plotkin 
lectures predomains partial functions 
notes course center study language information stanford 
rey reynolds 
approaches type structure 
ehrig floyd nivat thatcher editors mathematical foundations software development volume lecture notes computer science pages 
springer verlag 
san sands 
complexity analysis lazy higher order language 
proceedings second glasgow workshop functional programming 
sol 
typed calculus fragment linear logic 
theoretical computer science 
tur turner 
miranda non strict functional language polymorphic types 
jouannaud editor functional programming languages computer architectures volume lecture notes computer science 
springerverlag 
tur turner editor 
research topics functional programming 
addison wesley 
val 
judgement calculus intuitionistic linear logic proof theory semantics 
technical report university milan dip 
scienze dell informazione 
wad wadler 
linear types change world 
broy jones editors programming concepts methods 
north holland 

