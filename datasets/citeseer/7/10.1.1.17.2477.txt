computability partial continuous functionals dag normann february show recursive total continuous functional representative partial continuous computable hierarchy partial continuous functionals 
equivalently representative pcf definable partial continuous functionals pcf plotkin programming language computable functionals 
kleene extended concept relative computations computations relative objects arbitrarily finite pure types 
defined relation inductively clauses generally known 
kleene total tp set natural numbers tp consist total functions tp kleene isolated countable 
tp countable global action countable inputs coded countable way associates 
kleene showed functional computable countable func countable 
department mathematics university oslo box blindern oslo norway 
math uio independently kreisel introduced hierarchy continuous 
continuous hierarchy restrict pure case ct ct ct continuous way 
main difference kleene hierarchy kreisel hierarchy kleene hierarchy extensional 
take hereditarily extensional collapse countable get continuous 
extensional variant continuous functionals 
original definitions ad hoc features experience shown number characterisations hierarchy constructed natural choice hierarchy pure types application determined finitary information 
ershov characterised continuous hereditarily tal objects hierarchy partial continuous 
essence domains define continuous 
established ory algebraic domains scott ershov domains see hansen general natural domain theory framework constructing continuous 
approach taken normann ql 
berger smooth theory domains discuss concept totality setting establish kreisel shoenfield theorem higher types 
continuous domain theory gives hierarchies consider partial continuous function als hereditarily total objects forming hierarchy hierarchy ct identify hereditarily equal objects 
kleene schemes sense hierarchies ct ne ne 
requirements termination restricted ct hierarchy compared hierarchy 
scheme functional application require total compute hierarchy may partial compute hierarchy 
consider hierarchy computation case respect extensional equality essentially computing ct hierarchy 
higher type computable ct hierarchy hierarchy 
berger observed fan functional shown tait computable computable computations take place hierarchy 
application recursion theorem show functional introduced gandy showed hyland computable fan func tional computable hierarchy 
berger conjectured recursive functional computable hierarchy 
main result conjecture true 
recursion theory interest theoretical computer scientists 
plotkin defines programming language pcf typed calculus local fixpoint operators type 
type structure ground types natural numbers boolean values closed formation function types 
algebraic domains defines semantics pcf extension typ 
shows recursive object see defini tions pcf definable relative parallel continuous operator parallel continuous operator 
plotkin discuss totality connection denotational operational semantics 
theorems answer problems stated 
pcf definable objects pure types exactly computable objects partial continuous 
observed berger 
proof follows line argument developed platek establishing platek notion computability kleene notion 
mixed type isomorphic retraction pure type primitive recursive projection inclusion maps 
shown detail total partial objects construction cases 
consequence results hold mixed types 
setting main theorem reads recursire total rr equivalent total rr pcf definable 
may find 
am grateful useful discussions berger enlightening comments plotkin 
main theorem section give basic definitions state standard facts domain theory state main theorem 
standard text domain theory background 
consider algebraic domain just domain set ideals set partially ordered compacts closed upper bounds finite bounded sets ideals ordered inclusion define hierarchies setting 
definition domain domain details definition 
compacts just domain elements compacts sets compacts bounded 
po set compacts 
ordered follows 
order 
po vi ri ai 
domain elements ideals compacts identify compact ideal generated 
organise typed hierarchy defining application follows oz oz compact compact oz 
way viewed hierarchy partial continuous functionals 
call pair basic compact identify 
definition oz set hereditarily total objects 
longo moggi showed relation equivalence relation total object type respects relation 
kleene kreisel density theorem equivalent oz bounded words oz consistent 
relation equality 
state kleene kreisel density theorem 
definition ct typed hierarchy isomorphic set equivalence classes induced application operator 
easy see compacts po enumerated way relevant relations operations compacts replaced primitive recursive operations numbers 
enumeration define recursive sets compacts recursive enumerations sets compacts 
definition ct representative element corresponding equivalence class 
ct recursive representative enumerable 
generally accepted terminology call recursire set compacts recursively enumerable 
concept called scott computable 
computable hierarchy 
ct computable representative computable 
enumerations elements extent correspond kleene associates 
definition recursive equivalent classical functional recursive associate 
discussed normann 
standard view recursively enumerable elements effective domain effective objects 
theorem main theorem functional ct recursire computable 
statement weaker statement recur enumerable element computable partial continuous functionals statement incorrect observed plotkin equivalent pcf 
lead reader proof main theorem steps 
theorem trivially correct easy challenge comes type 
consider special case type functionals key algorithm transparent adjust algorithm general case type 
prove theorem strengthening main theorem induction type 
prove theorem theorem restricted effective operators 
unfortunately need slightly elaborate construction order obtain theorem 
induction hypothesis require theorem correct types 
theorem easy known types proof type just special case general proof higher types 
reason splitting type type improve readability argument reason focusing special case section 
kleene kreisel density theorem stated follows setting proposition uniformly recursire po object kt standard proofs density theorem find enumeration compacts primitive recursire uniformly kleene shows represents primitive recursire ct 
correct chosen primitive recursire give example 
special case definition rm mc enumeration constant finite set 
constitutes dense set standard topology finite sequence natural numbers set natural numbers natural numbers ar denote infinite sequence obtained concatenation 
definition recursire non wellfounded tree sequences natural numbers recursire enumeration 
nv nk constant 
face defined operator set priori need defined continuous 
show restriction computable element functionals ct corresponding similar played important showing limitations computability ct see normann 
recursire infinite branch hierarchy ct 
proved argument similar tait prove fan functional 
really proof consequence 
state prove order give reader better intuition nature functional lemma pt restriction recursire object 
proof 

vm 
number vm ek 
ifwe vary 
find tree founded 
clearly 
satisfied compact 
upper bound eft exist satisfying 
actual value 
lemma pt 
pt restriction computable proof 
pv bc th approximation pt ek constant 
find lim 
consider defined restriction uniformly computable give obvious algorithm computing partial thing notice verify quantifiers bk sequential test parallel test 
particular means partial computation terminates 
introduce functions ranging defined simultaneously follows crr 
rnr rnr 
compute follows search 
recursion theorem partial computable functionals satisfying equations 
show means 

basic compact 
try compute realise ore knowing algorithm 
reversed induction prove reach 
show computation terminates supposed 
induction hypothesis see step search test terminate 
test terminate stage search gets far 
point search stops 
cases case 
algorithm induction hypothesis 
case 
rmr rr stopped search 
algorithm induction hypothesis 

show obtaining 
prove nontrivial inequality choose show constant wehave assumed particular definition constant 
proof complete 
designed algorithm partial get termination exactly rr provided defined correct value 
case climb termination 
refer lemma proofs theorems see consider special case relates general case 
corollary recursire non wellfounded tree defined 
computable pcf definable 
proof proof emma 

computable termination requires termination require termination type prove main theorem type general 
key idea proof special case generality forces proof technically complicated key algorithm may hidden technicalities 
sense say replace tree set basic compacts 
section recursive recursive enumeration basic compacts 
construct functional computable may assume form finite sequence natural numbers really essential argument 
ri sequence zero functions previous section 
ai consistent bj 
say critical ifs rm rm choice 
number aj critical say show computable agrees show compute total equivalent lemma agrees computable equivalent 
proof ra contains object point introducing ra 
unique argument special case define computable prove agrees 
qn avm computable object analogy bv special case 
observe monotonicity properties define recursion theorem analogy construction special case 
ir bn 

computing search termination requires terminates sn irv case select bn proof special case 

choose 
reversed induction show terminates 
repeat details argument just notice care shown case argument shows unique definition 
extra bonus obtain recursively able construct enumeration get 
consequence lemma cn recursire enumeration basic compacts object total 
defined construction 
fv proof computing rely finding 
possi bilities 
search terminate 

find qs 
find fq bn compute qs order compute qs 
find fq bn sn 
requires find nl bn order obtain need nl property see way algorithm terminate 
lemma proved 
corollary recursively enumerable con structed 

proof terminates 
lemma rn 
means general case arbitrary types proof type adjust situation higher types 
return special case order discuss problem 
algorithm want compute rn case argue terminates rn compact case algorithm interpretation extends crn terminate 
want carry similar construction types larger need enumerate dense set total extensions com pact type need elaborate notation main obstacle 
problem algorithm com puting primitive recursire extensions compact induce elements containing just consistent 
illustrate lowest possible type 
example rl pairwise inconsistent compacts type rl 

iv total recursire functional type consistent 
computation iv seen sequential process stage independently ask particular means basic compact iv extend intersection domains empty 
construction section seen construction uniform algorithm computing enumeration basic compacts 
fact uniform algorithm type order prove main theorem type produced algorithm type trivial produce algorithm type enumeration basic compacts iv 
compute iv gorithm search consistent iv 
course mean sequential interpretation algorithm 
main theorem consequence general theorem 
sn nc enumeration basic compacts uniformly computable sn nc kt proof assume theorem holds 
en 
basic compacts 
give algorithm computing fixed effective enumeration basic compacts type 
compact po unique finite enumeration increasing sequence 
likewise enumeration cj induces enumeration 
enumeration effective recursive 
functional constructed enumeration 
induction hypothesis 
po partial functional obtained enumeration described 
computable uniformly index induction hypothesis 
primitive recursive indexed family primitive recursive enumerations basic compacts type 
extends enumeration 
enumerates basic compacts element 
dense set enumerations elements extending enumeration existence enumeration consequence kleene kreisel density theorem 
claim rr bs bj rr consistent proof assume 
choose enumeration extending fixed enumeration 
induction hypothesis constructed enumeration 
extends bj contradicting 
claim bn proof define 
show consistent consistent 
choose 
total extending ii choose enumerations extending fixed extending enumeration fl total objects equivalent obtained enumerations 
fl equivalent 

induction hypothesis compact enumeration initial segment enumeration argument shows total equivalent arr rr 
rr basic compact 

construction rj bj 
rr err bs turn rr rr 
consequently rr basic compact form 
ends proof claim 
ready induction step 
change notation may proof case type 
replace ir mean functional computed enumeration replace definition ra critical critical consistent ra vice versa relevant choice 
decidable find critical aj 
final change rn satisfying claim showing algorithm terminates total total 
proof showing 
algorithm need value sufficient show bo argument section get rn rn rn follows proof complete 
finite sequence natural numbers problem making algorithm ri uniformly extend problem standard dense set extensions higher types 
algorithm give simply enumerations extend enumeration partial enumeration enumeration 
induction hypothesis underlying construction suitable associates extensions compact get computable version extension maps 
alternative complete domains basis semantics programs may effective domains 
standard means restricts attention domain objects corresponding ideals 
leads alternative notion totality hereditarily effective operators 
modify construction construction order obtain theorem effective case 
hand construction prove theorem complete case 
definition 
recursive 
theorem uniformly computable recursire enumeration basic compacts fl fl 
proof proof theorem directly valid 
explain difficulty construction adjusted order avoid 
proof claim general case need show 
construction recursire recursire 
prove total ineffective enumeration 
enumeration basic neighbourhoods order enumerate po turn define way get obstacle consider possible versions basic compacts version way write compacts enumerated prefixed way 
replace versions crn new sing previously point course enumeration corresponding version 
define enumeration giving rise recursive may recursive enumeration recursive prove rest argument proof theorem 
comments notions higher type ity unpublished notes 
berger objekte und der german thesis 
berger total sets objects domain theory annals pure applied logic 
ershov yu 
computable functionals finite type algebra logic 
hyland 
continuous functionals annals mathematical logic 
kleene recursire functionals quantifiers finite types 
kleene countable functionals heyting ed 
constructivity mathematics north holland 
kreisel interpretation analysis means functionals finite type heyting ed 
constructivity mathematics north holland 
longo moggi hereditarily partial effective functionals recursion theory higher types jour 
symbolic logic 
computation higher types springer lecture notes mathematics 
normann continuous functionals springer lecture notes mathematics 
normann continuous functionals appear ed 
handbook computation theory elsevier 
normann continuous functionals computations recursions degrees annals mathematical logic 
plotkin lcf considered programming language theoretical computer science 
plotkin full abstraction totality pcf draft 
hansen mathematical theory domains cambridge tracts theor 
comp 
science cambridge university press tait continuity properties partial recursire functionals finite type unpublished notes 

