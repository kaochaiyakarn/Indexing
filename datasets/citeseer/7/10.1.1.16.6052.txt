framework compiling preferences logic programs james delgrande school computing science simon fraser university burnaby canada jim cs sfu ca torsten schaub institut ur informatik universit potsdam postfach potsdam germany torsten cs uni potsdam de hans tompits institut ur informationssysteme abteilung systeme technische universit wien wien austria tompits kr tuwien ac introduce methodology framework expressing general preference information logic programming answer set semantics 
ordered logic program extended logic program rules named unique terms preferences rules set atoms form names 
ordered logic program transformed second regular extended logic program preferences respected answer sets obtained transformed program correspond preferred answer sets original program 
approach allows specification dynamic orderings preferences appear arbitrarily program 
static orderings preferences external logic program trivial restriction general dynamic case 
develop specific approach reasoning preferences preference ordering specifies order rules applied 
demonstrate wide range applicability framework showing approaches brewka eiter captured framework 
result transformations extended logic program affiliated school computing science simon fraser university burnaby canada 
existing implementations dlv smodels 
developed freely available compiler front programming systems 
commonsense reasoning general logic programming particular frequently prefers application rule 
example buying car may various desiderata mind inexpensive safe fast preferences come varying degrees importance 
legal reasoning laws may apply different situations laws may conflict 
conflicts resolved appeal higher level principles authority recency 
federal laws higher priority state laws newer laws take priority old 
preferences authority holding recency may required 
logic programming basic logic programs employ negation failure issue preferences basic logic program guaranteed single unique set 
basic logic programs expressively weak 
negation failure introduced extended logic programs gelfond lifschitz longer guaranteed single set may answer sets giving feasible set 
priori reason accept answer set noted may reasons prefer 
situation preferences usually expressed strict partial order set rules 
example consider program technical definitions notation introduced section identifies respective rule 
program regular answer sets containing bg containing cg answer set rules applied second assume reason prefer expressed case want obtain just answer set 
numerous proposals expressing preferences extended logic programs including sakama inoue brewka gelfond son zhang foo brewka eiter wang general approach employ meta formalisms characterising preferred answer sets 
instance common approach generate answer sets program fashion select preferred set 
consequently non preferred preferred answer sets generated preferred sets isolated filtering step 
approaches generally higher complexity underlying logic programming semantics see section details 
goal general methodology framework expressing implementing preferences ii preferred answer sets generated 
describing general methodology logic program preferences translated second regular logic program answer sets second program precise sense correspond express preferred answer sets 
possible encode preferences logic programming framework 
argue framework general admits encoding different preference strategies 
able express dynamic preferences logic program contrast previous adopts external static preference order 
complexity approach complexity class underlying logic programming semantics 
approach suited prescriptive interpretation preference preference ordering specifies order rules applied 
developing exploring preferred interpretation preference strongly prescriptive interpretation preference 
show possible encode interpretations 
show brewka eiter approach preference brewka eiter expressed framework 
encoding shows handle descriptive oriented approaches 
encodings approaches wang briefly described 
general framework provides common basis different approaches expressed compared 
equivalently framework provides common setting various different strategies encoded 
provides uniform way capturing different strategies originally heterogeneous ways 
translations sense axiomatise preference ordering understood 
notion semantics major concern discuss various encodings connection notion order preservation 
fact strategy discussed section developed just concept order preservation 
lastly translate program extended logic program straightforward implementing approach 
developed translator ordered logic programs serves front logic programming systems dlv eiter smodels niemel simons possibility utilise existing logic programming systems implementation purposes major advantage framework 
contrast approaches change semantics require dedicated algorithms solve respective reasoning tasks hand 
section gives background terminology notation section describes methodology 
develop central approach section explore formal properties 
section presents encoding brewka eiter approach section considers 
sections issues implementation conclude short discussion 
strongly extends delgrande delgrande delgrande delgrande definitions notation deal extended logic programs lifschitz contain symbol classical negation addition negation failure 
allows distinguishing goals fail sense succeed goals fail stronger sense negation succeeds 
classical negation referred strong negation whilst negation failure termed weak negation 
formal treatment propositional languages 
non empty set symbols called atoms 
choice determines language programs consideration 
usual literal expression form atom 
assume possibly infinite set atoms 
set literals denoted la short 
literal preceded negation failure sign said weakly negated literal 
rule expression form lm lm literal 
literal called head set fl lm lm body said basic rule called fact 
allow situation absent case called constraint 
extended logic program simply program finite set rules 
program basic rules basic 
simplicity associate language program set literals set rules induced head denote head rule body denote body furthermore body fl lm body flm elements body referred prerequisites body said prerequisite free 
say rule defeated set literals iff body 
set literals consistent iff contain complementary pair literals 
say logically closed iff consistent equals furthermore closed basic program iff head body particular closed basic program body constraint 
smallest set literals logically closed closed basic program denoted cn 
basic program set literals 
operator defined follows fhead body xg consistent 
iterated applications written 
known cn basic program 
rule 
denotes basic rule obtained deleting weakly negated literals body head body 
accordingly define usage head body 
reduct program relative set literals defined fr body words obtained 
deleting defeated 
deleting weakly negated literal occurring bodies remaining rules 
say set literals answer set program iff cn clearly answer set program holds 
set generating rules answer set fr body body comprises rules defeated prerequisite sequence hr rules grounded iff fhead ig inconsistent body fhead ig 
say rule grounded set rules iff grounded enumeration body head 
answer set semantics extended logic programs defined gelfond lifschitz generalisation stable model semantics gelfond lifschitz general logic programs programs containing classical negation 
reduct called gelfond lifschitz reduction 
ordered tagged logic programs logic program propositional language said ordered contains pairwise disjoint categories set terms serving names rules set regular propositional atoms program set preference atoms names 
assume furthermore bijective function 
assigning rule name simplify notation usually write abbreviate 
relation written leaving naming function 
implicit 
elements express preferences rules 
intuitively asserts higher priority viewed having precedence sense considered 
note authors opposite sense 
formally alphabet ordered logic program understood triple extended logic program la bijective function set names follows leave set names naming function implicit associate notion ordered logic program underlying extended logic program 
note authors example niemel simons grounded refer process eliminating variables rule replacing set ground instances 
term grounded grounded enumerations 
discuss replacing variables ground terms section refer instantiation rule 
practice function required injective rules participating preference relation require names 
note determined important note impose restrictions occurrences preference atoms 
allows expressing preferences flexible dynamic way 
instance may specify may rely preference atoms 
special case programs containing preference atoms facts 
say logic program statically ordered form extended logic program la static case regarded induced external order rules holds iff fact included ordered program 
explicit denoting statically ordered program pair program stipulate statically ordered program strict partial order 
static concept preference corresponds previous approaches preference handling logic programming nonmonotonic reasoning preference information specified fixed relation meta level cf 
baader hollunder brewka zhang foo brewka eiter wang 
idea methodology compiling preferences straightforward 
preference handling strategy approach provides mapping transforms ordered logic program standard logic program answer sets preferred correspond standard answer sets 
intuitively translated program constructed way resulting answer sets comply interpretation preference information induced original program 
achieved adding sufficient control elements rules guarantee successive rule applications accord intended order 
control elements tags short newly introduced atoms allow detect control rule applications object language 
translation maps ordered logic programs standard logic programs language extended appropriate tags 
relation atom respectively want ensure considered sense rule known applied blocked ahead respect order rule application 
translating rules order rule application explicitly controlled 
purpose need able detect rule applies rule defeated need able control application rule antecedent conditions 
introduce rule program new special purpose atom ap detect case rule applicability conditions satisfied 
instance rule mapped rule ap consequent original rule replaced tag ap just recording fact applicable 
addition ap restores effect original rule 
mapping separates applicability rule actual application 
second detecting rule applicability conditions satisfied rule blocked introduce rule new atom bl 
cases rule applied may literal body appear answer set may literal body answer set 
rule get rules bl bl precise section tagging technique provides complete information applicability status rule respect answer set tagged program ap iff bl informally tagged program obtained treating rule described replacing rule appropriate rules corresponding 
relatively straightforward seen tags detect rule applied 
note fine grained approach obtainable distinguishing causes blockage means different tags bl bl 
lastly controlling application rule introduce atom ok body literals clearly transformed rule potentially applied ok asserted 
generally combine preceding mapping ok appear prerequisite rule 
example get ap ok bl ok bl ok tagging refined rule answer set tagged program ok ap iff bl preference handling informally conclude ok rule just ok respect exact meaning process fixed preference handling strategy 
instance strategy section ok concluded just known blocked applied 
tags single preference saying preferred encoded directly way appropriately tagged rules 
ok ok ap ok bl similar addition ok literals rules prerequisites introduce literals form ko weakly negated body literals rule 
transformed rule behaves exactly original defeat knock rule asserting ko 
instance adding ko body allow assert applicability asserting original consequent ko derivable 
means blocking rule application course appeared earlier literature ko commonly called ab abnormal mccarthy 
order preserving logic programs section elaborates fully prescriptive strategy preference handling having roots delgrande schaub idea approach select answer sets program generated order preserving way 
allows enforce ordering information construction answer sets 
order guarantee rules treated order preserving way strategy stipulates question applicability settled higher ranked rules lower ranked rules 
way rule defeated grounded lower ranked rules 
lower ranked rule may course depend presence absence literal appearing head higher ranked rule application lower ranked rules independent fact higher ranked rule applied blocked 
important guarantee selection existing answer sets rules original program considered cf 
proposition 
illustrate means statically ordered program taken baader hollunder program fr answer sets fp fg fp fg 
letters stand usual birds penguins flies wings respectively 
baader hollunder formulate approach default logic reiter consider gives rise constructions fpg fp fg fp wg fpg fp bg fp wg fp fg take closer look grounded enumerations associated construction leaves room grounded enumerations hr hr hr strategy enumerations order preserving reflect fact treated construction induces single grounded enumeration hr occur sequence 
question arises blocked order preserving way 
fact applied applicable prerequisites derived defeated point 
clearly application violates preference view strategy 
generated order preserving way strategy select preferred answer set intuition precise statically ordered programs 
definition statically ordered program consistent answer set 
called hr 
body fhead ig 

body body fhead ig 
condition guarantees generating rules applied order condition assures preferred inapplicable rule blocked due prerequisites defeated higher ranked unrelated rules 
condition property groundedness explicit 
standard answer set generated grounded sequence rules see sections property weakened preferences issue 
simplicity motivation static setting 
generalisation order preservation dynamic case section 
encoding show selection ordered logic programs back standard programs 
accomplished fully dynamic setting put forward section 
ordered program language obtained adding new pairwise distinct propositional atoms ap bl ok rdy 
translation maps ordered program regular program way 
definition fr ordered logic program logic program defined set consists rules body body head ap ap ok body bl ok bl ok ok rdy rdy rdy rdy ap rdy bl write deal statically ordered program rules express applicability blocking conditions original rules rule obtain rules rules form rdy 
ready auxiliary atoms ok 
rules form 
rule represented rules 
second group rules encodes strategy handling preferences 
rules quantifies rules conclude ok just ready applied respect rules 
necessary dealing dynamic preferences preferences may vary depending corresponding answer set 
rules specify pairwise dependency rules view preference ordering pair rules derive rdy fails hold ap bl true 
allows derive ok indicating may potentially applied applied applied 
important note strategies dealing preferences different strategies obtainable changing specification ok 
rdy 
see subsequent sections 
group rules renders order information strict partial order 
occurrences represented variables number rules limited max 
potential bottleneck translation clearly rule body may contain literals 
illustration approach consider program denotes name rule 
program regular answer sets answer sets respected overrides fact corresponds single answer set obtained 
see observe fhead 
get rdy reduced rules ok rule 
analogously get ap ap belongs answer set 
consider rules ap ok bl ok bl ok ap ok bl ok rdy ap rdy bl practice reduced number rules involved preference handling cf 
section 
ok rule leaves choice assume get ap get rdy ok results bl 
omitting details yields answer set containing excluding second assume eliminates turning defeated derivable 
inapplicable derivable ap presence ok 
ok derivable ap bl derivable 
circular situation unresolvable answer set containing deals exclusively static preferences simplified version translation 
statically ordered program static translation obtained 
replacing ok rdy rdy rdy ap rdy bl fs fs sg 
deleting 
note resulting program contain preference atoms anymore 
preferences directly woven resulting program order enforce order preservation 
formal elaboration result ensures dynamically generated preference information enjoys usual properties partial orderings 
define relation set literals relation holds iff proposition ordered logic program consistent answer set 

strict partial order 
static preferences answer set 
statically ordered programs show addition preferences increase number result ensures consider rules gather complete knowledge applicability status 
proposition ordered logic program consistent answer set 

ok 
ap iff bl properties shed light program induced translation elaborate logic programming operator reduct proposition ordered logic program consistent answer set 

defeated ok body ap max 
ok body implies bl 
defeated ok bl 
ok implies ap bl 
result captures prescriptive principle underlying ok literals way guiding inference process preference order 
fact shows derivation strictly follows partial order induced preference relation 
clearly carries images original program rules precise subsequent corollary 
theorem ordered logic program consistent answer set hr grounded enumeration set generating rules 
result obviously extends respective images rules corollary prerequisites theorem body body 
results reflect nicely prescriptive strategy enforced 
rule preferred rule images say occurs necessarily images preferred rule 
note existential quantification necessary blocked ways 
static preferences translation amounts selecting underlying unordered program defined definition 
theorem statically ordered logic program consistent set literals 
iff la answer set result provides semantics statically ordered programs provides exact correspondence answer sets issued translation regular answer sets original program 
particular shows implements selection function answer sets original program 
note inconsistent answer sets necessarily reproduced see consider fp inconsistent answer set answer set 
due fact rules removed case way derive ok literals 
hand show inconsistent answer set inconsistent answer set 
obtain corollary theorem demonstrating strategy implements selection function standard answer sets underlying program 
corollary statically ordered logic program set literals 
la answer set answer set 
note results directly carry general dynamic case dynamic setting admits way selecting answer sets undifferentiated way due lack uniform preference relation 
key difference static dynamic preference handling boils availability preferences 
full preference information available right start static case develops formation answer sets dynamic case 
viewpoint rule application dynamic setting necessitates question applicability settled higher ranked rules rule considered application knows higher ranked rules point 
considering rule application preferences form derived 
adds new requirement concept order preservation dynamic case expressed condition 
major consequence additional requirement restrict attention generating rules answer set anymore static case take rules program account matter eventually apply 
preference information drawn considered answer sets 
sure resulting preferences amount strict partial order 
purpose denote program obtained adding transitivity antisymmetry rules ft account obtain concept order preservation dynamic preferences 
definition ordered program consistent answer set called preserving exists enumeration hr observe static translation preserves inconsistent answer sets 


head 
body fhead ig 
body body fhead ig 
despite fact conception order preservation takes rules account opposed generating rules remains generalisation static counterpart definition 
fact conditions seen extension conditions definition sets generating rules entire programs 
illustration consider answer set answer set preserving 
see consider enumeration omitting rules simplicity 
write indicate hr preference induces condition occurs occurs condition 
furthermore due condition occurs condition necessities occurs intuitively enumeration corresponds images generating standard answer set viz 
discussed difference static case manifests condition reflects fact relevant preference information derived rule considered application 
mirrors strong commitment strategy successive development preferred answer sets accord groundedness 
different approach discussed section drops groundedness requirement 
illustrating condition consider programs fr fr programs standard answer set fa answer set preserving allows derive preference atom lower ranked rule considered application impossible enumeration satisfying condition enumeration dynamic extension approach dropping condition described section 
result demonstrating soundness completeness translation respect preserving answer sets 
theorem ordered logic program consistent set literals 
preserving answer set iff answer set 
obtain corollary 
corollary ordered logic program set literals 
answer set answer set preference information transformation amounts standard answer set semantics 
notions statically ordered dynamically ordered programs coincide case 
result expresses property terms order preserving answer sets 
theorem logic program la consistent set literals 
statements equivalent 
preserving answer set dynamically ordered program 



regular answer set logic program 
properties immediately obtain result encoding showing preference free programs yield regular answer sets 
corollary logic program la consistent set literals 
answer set iff answer set 
brewka eiter suggested properties termed principle principle ii argue defeasible rule system handling preferences satisfy 
result shows order preserving answer sets enjoy properties 
original formulation principle ii generic motivated aim cover different approaches possible instantiate terms current framework 
turns principle suitable statically ordered programs whilst principle ii admits guises statically ordered programs dynamically ordered programs 
principles ii formulated setting follows principle statically ordered logic program regular answer sets generated fr fr respectively 
sense definitions principle ii static version 
statically ordered logic program 
rule body frg statically ordered logic program 
preserving answer set frg 
principle ii dynamic version 
dynamically ordered logic program preserving answer set rule body preserving answer set frg 
theorem properties 

order preserving answer sets sense definition satisfy principles ii 

order preserving answer sets sense definition satisfy principle ii 
mention properties concerning computational complexity order preserving answer sets 
transformation clearly polynomial size ordered logic programs virtue theorems follows straightforward way complexity answer set semantics order preservation coincides complexity standard answer set semantics 
note results 
theorem order preserving answer sets enjoy properties 
ordered program checking answer set preserving np complete 

ordered program literal checking answer set preserving contains np complete 

ordered program literal checking contained answer set preserving conp complete 
variations strategy similar described advocated wang fixpoint definitions characterise preferred answer sets statically ordered programs turns preferred answer sets semantics implemented slight modification translation definition 
definition schaub wang prerequisites definition logic program defined fc rdy head purpose eliminate rules preference handling process head derived 
corresponding soundness completeness result schaub wang terms order preservation amounts weakening integration preferences groundedness definition schaub wang statically ordered program consistent answer set 
called preserving exists enumeration hr 
body fhead ig head fhead ig 

body body fhead ig head fhead ig 
primary difference concept order preservation original clearly weaker notion groundedness 
involves rules condition condition 
rest definition definition 
refer schaub wang formal details 
informally difference strategies explained means program fr clearly single standard answer set fa bg 
answer set generated enumeration preserves sense definition 
different adding condition 
accord approach wang modified concept order preservation accepts grounded enumeration hr strategies enforce selection standard answer sets underlying program 
new answer sets appear existing ones modified 
uncontroversial taken granted exemplified winner takes strategy 
approach wants apply highest ranked default possible highest ranked default 
accomplished removing rule rdy ap definition 
higher ranked rule applied lower ranked rules considered application anymore way derive indispensable ok literal ok 
similar strategy developed gelfond son cf 
section 
particular instance winner takes strategy inheritance default properties 
case ordering rules reflects relation specificity default rules prerequisites 
informally conflicting defaults determines specific respect rule antecedents defaults candidates application 
consider example defaults concerning primary means locomotion animals normally walk birds normally fly penguins normally swim 
expressed default rules follows learn thing penguin viz 
bird animal want apply highest ranked default possible highest ranked default 
significantly penguins swim default blocked say penguin question fear water viz 
don try apply default see fly 
chain rules expressing default properties elimination definition portrays apply possible prerequisite known true 
default chain applicable 
mentioned elimination allows lower ranked default rules applied case higher ranked rules blocked prerequisite derivable 
propagation ok 
atoms interrupted defaults considered 
brewka eiter approach preference turn strategy preference handling proposed brewka eiter brewka eiter approach fully prescriptive sense enforce ordering information construction answer set 
relies existence regular answer set underlying non ordered program order preservation verified separate test see definition 
original definition describe approach dealing ordered logic programs introduced brewka eiter brewka eiter deal statically ordered logic programs 
partially ordered programs reduced totally ordered ones fully ordered logic brewka eiter deal potentially infinite orderings limit finite programs 
program statically ordered logic program total ordering 
case arbitrarily ordered programs reduced restricted case way 
definition statically ordered logic program set literals 
preferred answer set iff preferred answer set fully ordered logic program 
construction preferred answer sets relies operator defined programs 
definition fully ordered prerequisite free logic program hr enumeration ordering set literals 
smallest logically closed set literals containing body head body fhead 
construction unique insofar fully ordered prerequisite free program standard answer set cf 
lemma 
accordingly set define preferred answer set prerequisite free logic programs exists definition fully ordered prerequisite free logic program set literals 
preferred answer set iff second condition definition amounts eliminating construction rules heads defeated illustrated logic program taken brewka eiter fr jg program fr answer sets fa bg bg 
application operator relies sequence hr illustration consider process induced fa bg second condition fg ag ag bg fag fag fag fa bg original definition brewka eiter deals infinite programs definition restricted finite logic programs 
note implicitly parameterized 
second condition fa bg preferred answer set 
argued brewka eiter brewka eiter answer set preserve priorities defeated fa bg applying rule preferred program preferred answer set 
definition accounts general case reducing prerequisite free 
checking regular answer set preferred brewka eiter evaluate prerequisites rules respect answer set definition fully ordered logic program set literals 
logic program obtained follows 
fr body xg 
iff max fr words obtained eliminating rule body substituting remaining rules results prerequisite free logic program 
preferred answer sets defined follows 
definition fully ordered logic program set literals 
preferred answer set 
standard answer set 
preferred answer set 
illustration consider example brewka eiter fr jg program fr standard answer sets fa bg fa bg 
turns leaving unaffected 
obtain preferred answer set 
contrast preferred 
get reproduces order preservation giving encoding approach brewka eiter provide insight semantics relation previous strategy terms notion order preservation 
approach equivalent strategy developed section normal prerequisite free default theories delgrande schaub interestingly result doesn extend normal prerequisite free theories 
difference caused second condition definition due different attitude groundedness see 
despite differences turns order preserving extension sense definition obtained brewka eiter approach vice versa cf 
delgrande schaub 
see consider example 
answer sets fp fg fp fg order preserving sense definition 
contrast answer sets preferred 
groundedness issue verifying order preservation approach brewka eiter due removal prerequisites definition 
precise means corresponding notion order preservation taken schaub wang definition schaub wang statically ordered program consistent answer set 
called preserving exists enumeration hr 

body body fhead ig head criterion differs definition aforementioned respects drops requirement grounded enumeration second adds second condition definition 
note preserving answer set generated grounded enumeration rules just property separated preference handling process 
grounded sequence preserving preserving enumerations supporting second answer set hr enumerations enjoys groundedness 
share appearance application relies reversal groundedness relation essential defeating considered application 
way satisfy condition 
discussion example shed light difference strictly prescriptive strategy discussed previous section brewka eiter descriptive approach 
descriptive attitude approach nicely illustrated example 
dropping requirement deriving prerequisite preferred rule way justifying answer set containing approach reasonable abandon strictly prescriptive view section adopt descriptive alternative characterisation preferred answer sets fully ordered logic programs originally proposition brewka eiter repeated theorem 
decomposing construction preferred answer set respective guess check step reflected definition 
know answer set containing certain formulas may rely dealing preferences 
descriptive flavour approach stems availability existing answer set underlying program dealing preference information 
instance regular answer set fa bg know derivable grounded fashion 
may rely information preferences account order underlying construction regular answer set may incompatible imposed preference information 
observe program observation highest ranked default applicability blockage asserted properties relies applicability ranked defaults effectively resulting circular situation destroying possible answer set 
encoding approach brewka eiter originally defined static case provide section encoding general dynamic case 
seen underlying preference handling strategy drops groundedness indispensable property standard answer sets 
consequence encoding keep strictly prescriptive nature section 
decouple generation standard answer sets actual preference handling process 
statically ordered program extend set rules ensures preferences preserved necessitating groundedness 
fact provides image similar section rules partially disconnected means extended language 
precise sequel 
program language assume disjoint language containing literals likewise rule results replacing literal analogy section map ordered programs language standard programs language obtained extending new atoms ok rdy bl ap 
definition fr ordered logic program logic program defined set consists rules body body body head ap ap ok body body bl ok bl ok ok rdy rdy rdy rdy ap rdy bl rdy head ok important note original program contained image translation 
show theorem allows construct standard answer sets answer sets 
answer set seen guess guess approach corresponds condition definition 
corresponding check viz 
condition definition accomplished remaining rules 
entering details stress principal differences rules translation section 
group rules synchronised original rules 
literals body primed body literals doubled original language 

encoding section second group rules accommodates modified strategy adding fifth rule 

integrity constraint added ruling unsuccessful candidate answer sets 
group rules expresses applicability blocking conditions 
rules form aim rebuilding guessed answer set form prerequisite free counterpart original program 
fact prerequisite refers body body guessed extension formula derived applying 
accounts elimination prerequisites condition definition 
elimination rules prerequisites derivable accomplished rules form 
rules form guarantee defaults rules higher priority 
fact derivable way 
application rules preference information enforced second group rules 
addition rules definition atom rdy derivable head true defeated relative candidate answer set 
treatment rules amounts elimination preference handling process originated second condition definition 
group rdy rules allows derive ok indicating may potentially applied applied applied eliminated preference handling process 
lastly rules unsuccessful attempts rebuilding answer set preference information 
way eliminate answer sets respect preferences 
illustration reconsider program preferred get ap ap ap ap ok ap ok ap ok bl ok bl ok bl ok bl ok suppose answer set containing standard answer set fa bg clearly contribute answer set belong 
having denies derivation ap 
get bl derive obtain ok 
satisfies integrity constraint destroys putative answer set hand 
desired answer set including complement consider preserving answer set fa bg case apply 
ok derive ap 
gives ok get bl 
derive ok ap 
integrity constraint invoked obtain answer set containing example consider program 
standard answer sets preferred ones ordering imposed 
suppose answer set containing yields rdy get ok 
having excludes ap ok bl ok inapplicable derivable higher ranked rules 
derive ok destroy putative answer set 
formal elaboration theorem gives major result section 
theorem statically ordered logic program consistent set literals 
preferred answer set iff la answer set follows elaborate structure encoded logic programs proposition ordered logic program consistent answer set 
results 
consistent standard answer set 
iff 
iff 
iff body body 
body 
property shows eliminated rules eventually inapplicable 
sufficient remove preference handling process rule blocked anyway 
analogy proposition result shows encoding treats rules gathers complete knowledge applicability status 
proposition consistent answer set ordered logic program 

ok 
ap iff bl result reveals alternative choice integrity constraint ap bl 
may wonder translation avoids explicit total extensions partial order 
theorem shows total extensions reflected subsequent derivation ok literals grounded enumerations generating default rules 
theorem consistent answer set statically ordered logic program hs grounded enumeration define fr head body define iff 
total ordering 
total ordering may ask need account inherited ordering condition definition 
fact taken care tags ap consequents rules guarantee isomorphism fa definition 
generally tagging consequents provides effective correspondence applicability default rules presence consequents answer set hand 
extensions dynamic case original elaboration preferred answer sets brewka eiter brewka eiter deals static case 
fact framework leaves room alternative extensions dynamic case depending preference information formed 
prescriptive option form preference information fly language close dynamic setting explored section 
descriptive approach gather preference information inside standard answer set formed language rely verifying preferences approach realised definition obtained replacing occurrences adding strict partial order 
refer variant obtained way difference strategies explained example 
consider ordered program fr clearly single answer set fa answer set accepted strategy underlying denied 
see observe necessitates preference information concerning higher ranked rules derived rule considered application formalised condition definition 
impossible rule dominates contains preference information accepts application order tolerating fact characterise strategy underlying transformation general dynamic case adapting static concept order preservation definition 
sufficient substitute definition 
contrast definition extension dynamic case avoids additional condition assuring preference information rule available considered application 
works gathers preference information language relies verifying preferences similar static setting dynamic strategy separates preference formation extension dynamic case briefly described default theories brewka eiter closer look encoding static preferences theorem reveals primed occurrences preference atoms 
preference verification 
different prescriptive strategy integrates processes necessitates concept order preservation including condition definition 
strategies differ strictly prescriptive strategies discussed section 
see consider program fr single answer set fa accept set preferred 
due discussed elimination groundedness preference test 
yields answer set way apply stipulated condition definition 
easy drop condition definition takes effort realise concept order preservation 
resort generate test construction similar 
apart original program language need constrained reconstruction process mirror language corresponding translation obtained definition follows 
ordered logic program collection rules obtained definition 
replacing ap ok body body leaves prerequisites rules intact 

deleting 
eliminates filter expressed condition definition define logic program 
show answer sets order preserving sense definition replaced leaves enumeration generating rules opposed entire program need stipulating condition definition anymore 
note strategy underlying amounts synergy borrowing guessing preferences sticks integration groundedness associated concept order preservation 
translations properties summarised table 
integration preference verification groundedness preference formation table summary dynamic translations 
implementation approach implemented serves front logic programming systems dlv eiter smodels niemel simons systems represent state art implementations logic programming family stable model semantics gelfond lifschitz instance dlv admits strong negation disjunctive rules 
resulting compiler plp preference logic programming implemented prolog publicly available www cs uni potsdam de torsten plp url contains diverse examples taken literature including preceding sections 
current implementation runs prolog systems eclipse sicstus comprises roughly lines code 
currently implements major strategies elaborated section respectively 
plp compiler differs approach described minor respects translation applies named rules leaves unnamed rules unaffected second admits specification rules containing variables rules form processed applying additional instantiation step 
syntax plp summarised table 
illustration give file meaning symbols internal false true neg prefix neg prefix infix body infix head infix rule infix prec name ok rdy ok rdy ap bl ap bl table syntax plp input files 
comprising example 
file read plp subject multiple transformations 
transformations rule centered sense apply turn single rule 
phase compilation system independent corresponds transformations preceding sections 
original file supposed extension lp result system independent compilation phase kept intermediate file extension pl applying implementation transformation source file neg name neg name 
source code example file example lp 
neg 
ap 
ap ok neg bl ok neg 
bl ok ap 
ap ok bl ok prec ok name rdy rdy 
rdy name name prec 
rdy name name prec ap 
rdy name name prec bl 
neg prec name name prec 
prec name name name prec prec 
name 
name 
false neg 
false neg 
false neg 
false neg 
false name name prec neg prec 
pretty printed intermediate code resulting example file example pl yields file 
see merely rules translated unaffected 
reasonable subject preference information 
similar prolog rule representing insofar body refers 
classical negation implemented usual way appeal integrity constraints 
compilation phase engaged explicitly command lp pl instance sicstus prolog typing lp pl examples example 
usually interested producing system specific code directly usable dlv smodels 
done means commands lp dlv lp sm produce system specific code resulting files having extensions dlv sm respectively 
files fed respective system standard command interpreter unix shell prolog system commands dlv smodels 
example compiling example lp dlv may proceed follows 
dlv examples example 
calling dlv examples example dlv dlv build ben apr gcc release true name name neg ok rdy rdy rdy prec neg prec ap rdy ok bl commands furnished option nice additional argument order strip auxiliary predicates 
dlv examples example nice 
calling dlv filter 
filter neg examples example dlv dlv build ben apr gcc release neg series commands engaged single means lp dlv lp sm respectively 
external plp illustrated 
treating variables preprocessing necessary instantiating rules compiled 
presence variables indicated file extension 
contents file instantiated systematically replacing variables constants freed function symbols replacing terms constants replaced clearly pragmatic approach 
elaborated compilation obtained proceeding right start system specific way 
illustration give formalisation popular legal reasoning example due gordon files obtainable intermediate pl files commands pl dlv pl sm respectively 
lp plp dlv sm dlv smodels standard output standard output au lp dlv lp dlv lp sm lp sm compilation plp external view 
person wants find security interest certain ship perfected legally valid 
person possession ship filed financing statement 
code ucc security interest perfected possession ship 
federal ship mortgage act sma states security interest ship may perfected filing financing statement 
ucc sma applicable question takes precedence 
legal principles resolving conflicts 
lex posterior gives precedence newer laws ucc sma 
lex superior gives precedence laws supported higher authority sma higher authority federal law 
compiling file legal yields result 
dlv examples variables legal nice 
calling dlv filter 
examples variables legal dlv dlv build ben apr gcc release possession ship neg newer ucc sma state law ucc federal law sma neg perfected details plp compiler cited url delgrande perfected ucc possession neg perfected 
neg perfected sma ship neg perfected 
newer neg state law federal law neg possession 
newer ucc sma 
ship 
federal law sma 
neg 
state law ucc 
lex posterior formalisation gordon legal reasoning example file legal 
approaches preference preference framework roots approach proposed delgrande schaub delgrande schaub handling preference information default logic 
preference information expressed ordered default theory consisting default rules world knowledge preference relation default rules 
ordered default theories translated standard default theories determining extensions theory preferences respected 
static dynamic orderings discussed albeit uniform manner realised case 
specifically delgrande schaub delgrande schaub notion order preserving extension defined static preference orderings 
encoding dynamic preferences relies additional predicate expressing non preference names rules 
contrast current framework specified right dynamic case static preferences just special instance dynamic ones 
furthermore delgrande schaub delgrande schaub primarily concerned specific preference strategy similar expressed definition whilst emphasis demonstrate flexibility framework providing encodings differing preference strategies 
lastly preference approaches requiring dedicated algorithms existence readily available solvers answer set semantics dlv smodels realisation current approach straightforward documented discussion section 
problem dealing preferences context nonmonotonic rule systems attracted extensive interest past decades 
fact nonmonotonic approach exist prioritised versions designed handle preference information form see gelfond konolige rintanen nebel eiter gottlob brewka brewka 
prioritised versions default logic logic programming answer set semantics includes baader hollunder brewka rintanen sakama inoue gelfond son zhang foo approaches discussed earlier 
argued delgrande schaub approaches divided descriptive prescriptive approaches 
case wish list intent way highest ranked rules applied 
case ordering reflects order rules applied 
relationship doyle wellman doyle wellman preferences discussed delgrande schaub rintanen addresses descriptive preference orders default logic 
notion preference differs conceptually preference orderings dealt 
particular rintanen approach meta level filtering process eliminating extensions considered preferred certain criteria 
method yields higher worst case complexity standard default logic providing polynomial hierarchy collapse similar method applied logic programs answer set semantics results likewise increase complexity 
consequently rintanen approach polynomial time translatable standard logic programs proviso efficiently represented framework 
furthermore argued brewka eiter rintanen approach obey principle ii exhibits counter intuitive results cases 
prescriptive approaches baader hollunder brewka prioritised variants default logic iterative specification extension modified 
preference information meta level static preferences considered default applicable iteration step primary difference approaches rests number defaults applicable step brewka allows applying single default maximal respect total extension maximal defaults step 
approaches violate principle shown rintanen result increase worst complexity compared standard default logic 
relevant reasoning tasks associated preference approaches translated polynomial time equivalent problems standard default logic preference methods amenable framework delgrande schaub delgrande schaub brewka baader hollunder deal context sensitive preferences 
previously discussed methods rely level approach treating preferences meta level defining alternative semantics 
similar methodology inherent approaches preference handling extended logic programming 
exceptions approach due gelfond son avoids defining new logic programming formalism order cope preference information utilises approach reifying rules preferences 
example rule expressed formula default reification corresponding term inside holds predicate respectively name rule 
semantics authors reverse order 
domain description terms set domain independent rules predicates holds 
rules regarded meta interpreter domain description 
interestingly approach notion defeat justifications contrast consideration rules approach 
specific strategy elaborated gelfond son differs ones considered preference stops application default defaults conflict default applicable gelfond son 
strategies studied delgrande schaub detecting conflicts approach necessitates extra conflict indicating predicate 
state explicitly con ict indicate conflict 
principle framework approach gelfond son offers variety different preference handling instances 
zhang foo presents operational semantics ordered logic programs iterative reduction standard programs 
approach admits static dynamic preferences dynamic case reduced static 
interestingly semantics nondeterministic flavour sense ordered program may reduced way standard program 
shown zhang somewhat elaborate semantics results worst case complexity lies second level polynomial hierarchy 
intrinsically harder standard answer set semantics providing polynomial hierarchy collapse 
consequently assuming proviso possible express zhang foo method framework polynomial way 
approach leads counter intuitive examples illustrated program zhang foo approach yields answer sets counter intuitive 
contrast answer set containing order preserving sense definition 
approach violates principle ii brewka eiter noted authors brewka eiter method sakama inoue interesting feature preference order relation names rules previous frameworks represents relation literals 
relation determine preference relation answer sets disjunctive logic program 
intuitively answer set preferable answer set iff literals priority literal strictly higher priority answer set preferred iff answer set strictly preferred minimality criterion answer sets approach presumably harder standard answer set semantics disjunctive logic programs yielding worst case complexity lies third level polynomial hierarchy 
restricting rules non disjunctive case sakama inoue approach admit polynomial representation framework providing polynomial hierarchy collapse 
approach satisfy principle ii brewka eiter cf 
geffner pearl approach preferences literals 
wang presents approach intermediate prescriptive approach described section delgrande descriptive approach brewka eiter expressed framework section 
encoding approach framework section 
obtain relations approaches 
ordered logic program dst preferred answer set preferred answer set preferred answer set answer set obtained approach described section section wang respectively 
results shown schaub wang dst preferred answer set preferred 
preferred answer set preferred 
preferred answer set answer set 
instance obtain converse 
example counterexample case second 
framework illustrates case delgrande wang brewka eiter hierarchy notions preference 
fact hierarchy practical value allows apply approach back semantics van der hoek validating strategies specific order logic programs 
idea interpret program respect strongest semantics gradually weaken strategy desirable set forthcoming 
feature common approaches statically ordered programs addition preferences increases number preferred answer sets 
fact seen preferences may strong deny existence preferred answer sets standard answer sets exist 
preferences impose additional dependencies rules respected standard answer sets 
related schaub wang shown programs order amounts stratification guarantee unique answer set 
delgrande schaub show graph structures introduced papadimitriou give sufficient conditions guaranteeing preferred extensions ordered default theories results obviously carry extended logic programming due results gelfond lifschitz discussion issues refinements briefly sketch range applicability point distinguishing features framework 
cf 
proposition brewka eiter draw reader attention expressive power offered dynamic preferences connection variables input language 
consider names rules containing variables respectively 
rule represents set ground instances constitutes concise specification 
approaches employ static preferences form approaches necessarily express enumeration static ground preferences single rule 
second note methodology applicable disjunctive logic programs rule heads disjunctions literals 
see observe transformed rules unfold conditions expressed body rules rule head remain untouched manifested rule 
addition handling preferences disjunctive rules approach allows express disjunctive preferences saying holds preferred informally mutually exclusive rules preference results answer sets 
straightforward way accommodating preferences literals instance put forward sakama inoue preference 
literals realised stipulating head head concluding remarks described general methodology logic programs containing preferences set rules compiled logic programs answer set semantics 
ordered logic program preference atoms appear program rules transformed second extended logic program 
second program explicit preference information appears preferences respected answer sets obtained transformed theory correspond preferred answer sets original theory 
main approach provide encoding capturing strongly prescriptive notion preference rules applied accordance prescribed order 
approach admits dynamic trivially static notion preference able specify preferences holding context default preference depends 
show approach brewka eiter expressed framework preferences 
extend approach handle dynamic case 
translations illustrate generality framework 
shed light specifically brewka eiter approaches provide translation encoding approaches extended logic programs 
sense methodology provides means different preference orderings image translation shows approach encoded extended logic program 
contrast definitions example illustrate succinctly main approach preferences brewka eiter relate 
general approach provides uniform basis diverse approaches encodings compared 
illustrated hierarchy approaches discussed section 
similarly framework allows potentially formalise interaction orderings inside framework specify theory interact 
approaches prove resulting transformations accomplish claimed appropriate rules image transformation treated correct order rules considered obtain preferred answer sets 
addition formal results illustrate generality approach formalising example due gordon giving examples context preference canceling preferences preferences preferences preferences default 
approach translating preferences extended logic programs advantages previous 
avoid level structure 
previous meta level approaches commit semantics fixed strategy approach gelfond son flexible respect changing strategies open adaptation different semantics different concepts preference handling illustrated encoding extension brewka eiter 
second translated program approach answer set preferred sense preferred answer sets specified ordering rules produced 
contrast previous approaches fashion select answer sets preferred 
expect approach pragmatically efficient avoids generation unnecessary answer sets 
section notes approaches higher level complexity hierarchy standard extended logic programs 
lastly compiling preferences extended logic programs light shed foundations extended logic programs 
particular show implicitly notions explicit dynamic preference expressed rules preference information increase expressibility extended logic program 
demonstrates approaches easily implementable 
describe compiler described fully delgrande front dlv smodels 
current prototype available www cs uni potsdam de torsten plp implementation core reasoning engine knowledge information system querying internet movie databases currently developed vienna university technology eiter serves modeling linguistic phenomena occurring phonology syntax besnard treated linguistics optimality theory prince smolensky 
author partially supported canadian nserc research 
second author partially supported german science foundation dfg tp third author partially supported austrian science fund fwf inf inf 
proofs usage provide lemmas proof 
lemma answer set logic program 

body body head 
head inverse propositions holds head head implies lemma answer set logic program 
grounded enumeration hr consistent body fhead ig 
dealing directly extended logic programming rules extend operator follows fr body body consistent fp lg 
clearly fhead extended logic program 
iterated applications written 
cn fhead propositions corollaries propositions lemma answer set logic program 

iff body body 
abbreviate rules 
body body body body 
body body body body 

body body body body 
result taken proposition brewka eiter theorem brewka eiter fully ordered program answer set 
preferred answer set iff rule 
body 
head rule 

head body 
sequel give proofs theorems order appear body 
proofs section proof consistent answer set ordered program 

rules members relation clearly transitive antisymmetric 
strict partial order 

suppose contains static preferences contains rules head atoms form names consistent answer set iff assumed consistent known properties answer sets holds answer set consistent 
follows iff answer set 
answer set immediate consequence 
proof consistent answer set ordered program 

prove propositions parallel induction base maximal element 
assumption 
implies rdy results ok cn cn closed ok cn 

distinguish cases ap lemma 
view ok cases true 
body body yielding bl analogy 
body body yielding bl analogy 
shows ap bl words ap iff bl step consider 
assume ok ap bl 
analogy base case rdy consider induction hypothesis ap bl body body implies rdy shown rdy 
fact closed get ok 

analogous base case 
proof consistent answer set ordered program consider 

ok body get body max 
body implies ap max 

ok body get body body body 
bl 

ok body 
assume minimal get body max 
implies bl max 
bl 
assume ap 
ap derived means rule obtain ok 
ok 
similar arguments show bl implies ok 
proof ordered logic program consistent answer set hr grounded enumeration consider 
show fhead ig 
particular rdy fhead ig 
fr ig fr ig furthermore fr ig fr ig fr ig body body 
case ok fhead ig fr ig proof statically ordered logic program la set literals 
part 

define draw propositions sequel 
lemma prerequisites la 
enumeration hr satisfying condition definition 
loss generality assume fr ig fr head la fhead ig la hr construct enumeration hr total orders induced hr hr respectively 
obtainable letting total extension 


head 
trivially satisfiable 

body fhead ig 
direct consequence condition definition 

body 
body fhead ig 
suppose direct consequence counterpart definition expressed condition 
consider smallest rule counterpart condition definition implies body fhead lg 
predecessor hr body fhead hg 
violating constraints position hr consequently obtain body fhead ig 
rule positioned maximal rule hr satisfies constraints 
get 
theorem answer set consequently obtain la la la part 
answer set 
theorem enumeration hs satisfying conditions definition 
define hr enumeration obtained hs 
deleting rules apart form 
replacing rule form define fhead ig 
la fhead ig 
hr enumeration hr satisfies condition definition virtue hs satisfying conditions definition 
condition direct consequence condition condition follows immediately condition condition consequence condition 
proof ordered logic program language part 
consistent answer set 
define fhead ap fn tg sg observe furthermore note useful relationships lemma iff consistent implies consistent 
lemma part show standard answer set cn 
observe ft part 
start showing closed consider body body 
body lemma 
implies note body implies body ok proposition 
fact closed implies ap get head definition consider fn lemma get get head definition consider lemma get get head definition note closure shows cn part 
show smallest set closed equivalently cn 
observe show induction cn 
base trivial 
step assume cn claim obviously holds 
head head head head ap ap ok body consequently fap ok body 
induction hypothesis body implies body cn 
implies body 
lemma get body implies cn closed get head cn 
head fn 
induction hypothesis get fn cn 
cn closed obtain head cn 
head 
induction hypothesis get cn 
cn closed obtain head cn 
shown cn 
standard answer set part ii 
show preserving answer set standard answer set grounded enumeration hs lemma 
define hr enumeration obtained hs 
deleting rules apart form 
replacing rule form 
removing duplicates increasing body body 
note hr satisfies condition 
direct consequence fact hs enjoys groundedness 
establishing condition consider 
body establishes condition done 
body body implies lemma 
ok proposition obtain precisely fhead kg 
duplicates occur rule blocked multiple ways 
way hr obtained hs obtain fhead ig 
obtain condition 
show hr satisfies condition 
consider body body body body assume lemma 
get lemma way hr obtained hs relation implies establishes condition 
addressing condition assume definition implies smallest head 
furthermore obtain lemma 
rdy ap rdy bl rdy proposition analogously consider enumeration hs particular rules defined hs grounded minimality due implies consequently construction hr hs implies establishes condition 
part 
consistent preserving answer set define fhead fap fbl fok note useful relationship lemma iff consistent implies consistent 
lemma show answer set cn 
part 
start showing closed show head body 
consider head ap 

clearly definition head ap 
consider ap ok body 
suppose ap ok body body 
assume fok body lemma get body accordingly body implies body 
implies ap definition 
consider bl ok 
suppose bl ok fl 
lemma imply body 
implying bl definition 
consider bl ok 

clearly suppose fok lemma implies body 
implying bl definition 
consider ok rdy rdy 

clearly trivially ok definition 
consider fc 
clearly head rdy 
trivially rdy definition 
consider 

clearly assume fn lemma get fn body analogy shown obtain ap head get 
consider 

clearly assume analogy get note closure shows cn part 
show smallest set closed equivalently cn 
preserving answer set enumeration hr satisfying conditions definition 
proceed induction hr show fhead ap ig fbl ig fok ig ig cn base consider consistent condition 
lemma consequently rdy cn closed get rdy cn fr ok rdy rdy closure cn implies ok cn 
distinguish cases 
suppose 
hr satisfies condition body 
implies body obtain lemma body 
obtain ap ok shown ok cn 
accordingly cn closed obtain ap cn 
closure cn fact head ap imply furthermore head cn 

satisfy condition body fhead body body lemma bl ok shown ok cn 
fact cn closed obtain bl cn 
step consider assume claim holds start providing lemma 
lemma induction hypothesis ok cn ig cn 
proof prove rdy cn suppose hr satisfies condition induction hypothesis implies ap cn bl cn 
condition head induction hypothesis get head cn 
obtain cn 
clearly rdy ap rdy bl cn closed obtain rdy cn 
shown rdy cn suppose get lemma implies rdy cn closed obtain rdy cn 
rdy cn cn closed obtain ok cn 
distinguish cases 
body fhead ig condition 
induction hypothesis obtain body cn 
lemma ok cn 
implies body 
lemma body 
implies ap ok body shown body cn 
fact cn closed get ap cn 
accordingly obtain head cn 
condition may distinguish cases 
body body lemma bl ok lemma ok cn 
fact cn closed obtain bl cn 
body fhead ig body fhead ig 
head induction hypothesis obtain cn 
lemma ok cn 
cn closed bl ok obtain bl cn 
proof suppose contains preference information 
obviously regarded dynamically ordered program statically ordered program 
theorems imply preserving 
proves equivalence 
inspecting conditions definition easily seen answer set trivially 
follows equivalent 
proof principle statically ordered logic program answer sets generated fr fr respectively assume suppose 
clearly consistent 
furthermore defeated hand fr follows body fhead rg turn implies body assumed obtain body fhead enumeration hr head body 
defeated contradiction 
follows principle ii 
statically ordered logic program answer set 
furthermore rule body frg statically ordered logic program strict partial order agrees rules 
show preserving answer set frg 
obvious answer set frg 
consider enumeration hr satisfying items definition respect frg hr enumeration frg remains show hr satisfies items definition respect clearly condition unaffected satisfied 
agrees rules condition holds 
condition holds virtue frg body principle ii 
dynamically ordered logic program preserving answer set consider rule body show preserving answer set frg 
principle ii holds trivially assume similar clearly answer set frg 
hr enumeration satisfying items definition 
define hr sequence starting continuing sequence hr resultant sequence enumeration frg 
claim satisfies items definition 
see note definition ordered program term occur rules assumed member relation holds rules consequently hr obeys items hr 
furthermore item holds frg 
concerning final condition definition observe frg frg frg 
satisfies condition satisfies body condition met 
follows preserving 
proofs section proof statically ordered logic program language abbreviate 
part 
consistent preferred answer set standard answer set 
define fhead fhead fok fap fbl note useful relationships lemma 
iff 
iff 
iff consistent implies consistent 
lemma iff show answer set cn 
part 
start showing closed show head body 
consider head ap 

clearly definition head ap 
consider ap ok body body 
suppose ap ok body body body 
assume fok body lemma get body accordingly body body implies body 
implies ap definition 
consider bl ok 
suppose bl ok fl 
lemma imply body 
implying bl definition 
consider bl ok 

clearly suppose fok lemma implies body 
implying bl definition 
consider ok rdy rdy 

clearly trivially ok definition 
consider fc 
clearly head rdy 
trivially rdy definition 
consider ok 
suppose ok 
impossible definition 
consider 

clearly assume fn definition implies transitivity definition get 
consider 

clearly assume definition implies definition get note closure shows cn 
part 
show smallest set closed equivalently cn 
show fhead cn observe fhead 
proceed induction show cn 
base trivial 
step assume cn consider head lemma head implies body 
induction hypothesis provides body cn 
fact cn closed implies head cn 
second show cn definition obviously implies cn 
hand clearly fact cn closed implies head cn body cn 
cn cn 
just shown cn holds get cn 
third show fhead ap fbl fok cn induction inducing definition 
base greatest rule 
analogy base case page proof prove ok cn 
show ap cn bl cn holds analogy general proof carried step 
step consider assume claim holds start providing lemma 
lemma induction hypothesis ok cn cn 
proof prove cn 
consider rdy 
distinguish cases 
assume head body 
body 
shown cn 
fhead jg implies fhead jg cn 
body rdy cn 
clearly rdy cn closed head rdy cn 
rdy cn 
assume consistent get trivially body cn 
cn closed head cn 
rdy cn 
induction hypothesis fap fbl cn get cn shown 
distinguish cases 
assume body 
body induction hypothesis get ap cn 
body ap cn 
clearly cn closed head cn 
rdy cn 
body dealt 
assume head induction hypothesis get bl cn 
body bl cn 
clearly cn closed head cn 
rdy cn 
shown rdy cn 
implies body cn 
clearly cn closed head cn 
ok cn 
distinguish cases 

assume body body 
body deduce lemma body 
lemma gives body 
just shown cn 
body imply body cn 
lemma get ok cn 
body cn 
cn closed head cn 
ap cn 
clearly ap cn fact cn closed head cn 
head cn 

assume body body 
theorem rule head body 
clearly implies head shown cn 
accordingly head cn 
induction hypothesis head cn 
lemma obtain ok cn 
body fok cn 
clearly head 
cn closed obtain head cn 
bl cn 

assume body body lemma ok cn lemma cn closed obtain head cn 
bl cn 
completes proof cn 
shown cn 
answer set 
part 
consistent answer set 
show la preferred answer set definition induces properties lemma iff consistent implies consistent 
lemma iff consider body head show preferred prove theorem rule ii head body iii standard answer set theorem choice implies body 
lemma body implies body 
ap consequently obtain bl theorem fact consistent 
body implies body 
bl body 
body fok head establishing condition ii 
precisely head ap fa fact implies body body holds 
lemma get furthermore body body 
establishing condition 
answer set minimal fok 
minimality bl 
obviously ap ap hand deriving ap 
implies ok particular rdy 
observe body shown 
just shown ap bl 
rdy implies lemma imply holds true 
case total order establishes condition iii 
obtain theorem preferred answer set 
proof ordered logic program consistent answer set 

consistency follows answer set cn 
cn observe head 
consequently cn 

consider show iff part 
suppose head ap get hold turn implies body body 
part 
assume suppose ap ok virtue constraint body body holds condition follows body turn implies exists head head condition get body body head body contradicting 
property simple consequence observation body body body item 
details follow 
part 
body body conditions body body yield body body 
implies part 
item holds body implies body 
relation body body body get conditions body body jointly imply body body 

consider 
part 
assume body body 
suppose body 
body suppose body 
body part 
suppose cases distinguish 
body body item furthermore virtue constraint ok body body 
means holds 
body body invoking item get 
suppose body 
item furthermore ok constraint 
follows holds 
proof analogous proof 
proof statically ordered logic program consistent answer set fr head body hs grounded enumeration lemma prerequisites 
proof analogous theorem 
theorem ok 

define 
definition total ordering 
furthermore implies 
baader hollunder baader hollunder 
prefer specific defaults terminological default logic 
bajcsy editor proceedings international joint conference artificial intelligence pages 
morgan kaufmann publishers 
besnard ph 
besnard mercer schaub 
optimality theory default logic 
submitted publication 
brewka eiter brewka eiter 
preferred answer sets extended logic programs 
cohn schubert shapiro editors proceedings sixth international conference principles knowledge representation reasoning pages 
morgan kaufmann publishers 
brewka eiter brewka eiter 
preferred answer sets extended logic programs 
artificial intelligence 
brewka eiter brewka eiter 
prioritizing default logic 
st holldobler editor computational logic papers honour wolfgang bibel pages 
kluwer academic publishers 
brewka brewka 
preferred subtheories extended logical framework default reasoning 
proceedings international joint conference artificial intelligence pages 
brewka brewka 
adding priorities specificity default logic 
pereira pearce editors european workshop logics artificial intelligence jelia lecture notes artificial intelligence pages 
springer verlag 
brewka brewka 
founded semantics extended logic programs dynamic preferences 
journal artificial intelligence research 
delgrande schaub delgrande schaub 
compiling reasoning preferences default logic 
pollack editor proceedings international joint conference artificial intelligence pages 
morgan kaufmann publishers 
delgrande schaub delgrande schaub 
expressing preferences default logic 
artificial intelligence 
delgrande schaub delgrande schaub 
role default logic knowledge representation 
minker editor logic artificial intelligence pages 
kluwer academic publishers dordrecht 
delgrande delgrande schaub tompits 
compilation brewka eiter approach prioritization 
guzman brewka pereira editors proceedings european workshop logics artificial intelligence jelia volume lecture notes artificial intelligence pages 
springer verlag 
delgrande delgrande schaub tompits 
compiler ordered logic programs 
baral truszczynski editors proceedings eighth international workshop non monotonic reasoning 
arxiv org print archive 
system 
delgrande delgrande schaub tompits 
logic programs compiled preferences 
baral truszczynski editors proceedings eighth international workshop non monotonic reasoning 
arxiv org print archive 
delgrande delgrande schaub tompits 
logic programs compiled preferences 
horn editor proceedings european conference artificial intelligence pages 
ios press 
doyle wellman doyle wellman 
impediments universal default theories 
artificial intelligence 
eiter gottlob eiter gottlob 
complexity logic abduction 
journal acm 
eiter eiter leone pfeifer scarcello 
deductive system nonmonotonic reasoning 
dix furbach nerode editors proceedings fourth international conference logic programming non monotonic reasoning volume lecture notes artificial intelligence pages 
springer verlag 
eiter eiter fink tompits 
generic approach knowledge information site selection 
proceedings eighth international conference principles knowledge representation reasoning 
morgan kaufmann publishers 
geffner pearl geffner pearl 
conditional entailment bridging approaches default reasoning 
artificial intelligence 
gelfond lifschitz gelfond lifschitz 
stable model semantics logic programming 
proceedings international conference logic programming pages 
mit press 
gelfond lifschitz gelfond lifschitz 
classical negation logic programs deductive databases 
new generation computing 
gelfond son gelfond son 
reasoning prioritized defaults 
dix pereira przymusinski editors third international workshop logic programming knowledge representation volume lecture notes computer science pages 
springer verlag 
gelfond gelfond przymusinska przymusinski 
relationship circumscription negation failure 
artificial intelligence february 
gordon gordon 
game artificial intelligence model procedural justice 
dissertation technische hochschule darmstadt darmstadt germany 
ren 
optimality theory textbook 
cambridge university press 
konolige konolige 
hierarchic autoepistemic theories nonmonotonic reasoning 
proceedings aaai national conference artificial intelligence pages 
morgan kaufmann publishers 
lifschitz lifschitz 
foundations logic programming 
brewka editor principles knowledge representation pages 
csli publications 
mccarthy mccarthy 
applications circumscription formalizing common sense knowledge 
artificial intelligence 
nebel nebel 
hard revise belief base 
dubois prade editors handbook defeasible reasoning uncertainty management systems volume belief change pages 
kluwer academic publishers dordrecht 
niemel simons niemela simons 
smodels implementation stable model founded semantics normal logic programs 
dix furbach nerode editors proceedings fourth international conference logic programming nonmonotonic reasoning pages 
springer verlag 
papadimitriou papadimitriou 
default theories extensions 
artificial intelligence 
prince smolensky alan prince paul smolensky 
optimality theory constraint interaction generative grammar 
technical report university colorado boulder 
reiter reiter 
logic default reasoning 
artificial intelligence 
rintanen rintanen 
prioritized autoepistemic logic 
pearce pereira editors proceedings european workshop logics artificial intelligence volume lecture notes artificial intelligence pages berlin september 
springer verlag 
rintanen rintanen 
complexity prioritized default logics 
journal artificial intelligence research 
rintanen rintanen 
lexicographic priorities default logic 
artificial intelligence 
sakama inoue sakama inoue 
representing priorities logic programs 
maher editor proceedings joint international conference symposium logic programming pages cambridge 
mit press 
sakama inoue sakama inoue 
prioritized logic programming application commonsense reasoning 
artificial intelligence 
schaub wang schaub wang 
comparative study logic programs preference 
nebel editor proceedings international joint conference artificial intelligence pages 
morgan kaufmann publishers 
schaub wang schaub wang 
semantic framework preference handling logic programming 
submitted publication extended version schaub wang 
van der hoek van der hoek 
classical general frameworks recovery 
horn editor proceedings european conference artificial intelligence pages amsterdam 
ios press 
wang wang zhou lin 
alternating fixpoint theory logic programs priority 
proceedings international conference computational logic volume lecture notes computer science pages 
springer verlag 
zhang foo zhang foo 
answer sets prioritized logic programs 
editor proceedings international symposium logic programming ilps pages 
mit press 
zhang zhang 
logic program updates 
www cit edu au yan 
submitted publication 

