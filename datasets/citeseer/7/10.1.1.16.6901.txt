international journal foundations computer science vol 
world scientific publishing standard non standard semantics semantics modifiers sergei abramov program systems institute russian academy sciences ru russia mail ru robert gl department information computer science school science engineering waseda university ku tokyo japan mail acm org received january revised may communicated sato toyama approach systematically modifying semantics programming languages semantics modifiers described 
semantics modifiers class programs allow development general reusable semantics components 
language independence achieved interpretive approach interpreter serves mediator new language language non standard semantics implemented 
inverse computation equivalence transformation neighborhood analysis shown semantics modifiers 
experiments modifiers show computational feasibility approach 
modifier projections allow cient implementation non standard interpreters non standard compilers program specialization powerful program transformation methods 
keywords programming languages program transformation non standard semantics partial evaluation supercompilation interpreters 

interpreters convenient way implement standard semantics programming languages 
interpreters just running programs 
combined semantics modifier standard interpreter port non standard semantics programming language 
supported invitation fellowship japan society promotion science 
leave department computer science diku university copenhagen denmark 
abramov gluck programs standard interpreter capable computational feat called semantics modifiers 
di erent forms program reuse algorithms reused means interpreters 
language independence achieved interpretive approach interpreter serves mediator new language language semantics modifier implemented 
allows development general reusable semantics components 
cient implementations new programming tools non standard interpreters non standard compilers obtained automatically program specialization powerful program transformation methods 
example inverse computation non standard semantics allows run programs backwards 
examining input output behavior programs powerful analytical tool find states leading critical state 
assume algorithm inverse computation programs exists 
task perform inverse computation programs usually attempt construct new algorithm examining existing algorithm 
far trivial error prone time consuming 
show problem performing inverse computation reduced problem writing standard interpreter porting existing algorithm standard interpreter 
possible inverse computation property semantics modifier 
possible application semantics modifiers domain specific languages 
languages easy express non trivial computational tasks particular application domain networks graphics expensive implement language requires development new set programming tools 
semantics modifiers inexpensive alternative individual construction tools inverse interpreters program transformers 
mind establish set semantics modifiers show correctness reuse di erent programming languages 
promises language independence drastically increase applicability non standard methods 
results show semantics modifiers exist remarkably wide class computational problems including inverse computation program transformation program analysis 
fact known tower interpreters porting programming languages platform just special case framework identity modifier 
results described see meta programming interpreters far powerful previously thought 

aim develop underlying theory semantics modifiers identify non trivial semantics modifier property give experimental evidence viability approach 
specifically contributions follows standard non standard semantics introduce semantics modifiers develop underlying theory sec 

second non standard semantics prove semantics modifiers property sec 

third put theoretical ideas trial implementing semantics modifiers non trivial algorithms examining computer experiments modify semantics small imperative language sec 

fourth give modifier projections show cient implementations non standard interpreters non standard compilers obtained program specialization sec 

extends earlier draws results 
assume familiarity basic notions partial evaluation source book 

preliminaries section defines basic notions particular data domains set representation programming languages interpreters 

universal data domain assume universal data domain dat programming languages represent programs di erent languages 
letting programs data form convenient dealing programs data objects 
suitable choice dat set expressions known lisp 
expressions defined grammar dat atom cons dat dat atom possibly infinite set symbols cons constructor 
definition says element dat atom form cons dat 
data program domains programming language mapped dat 
example list represented cons cons cons nil dat 
mappings usually straightforward shall discuss 

representing sets data represent subsets domain dat expressions variables short classes 
class constructive representation possibly infinite set data 
semantics modifiers defined set representation 
advantage avoid introducing di erent notations 
experiments expressions contain types variables variables ranges atom ranges dat indices distinguish di erent variables type 
expressions defined grammar exp atom cons exp exp abramov gluck definition shows exp extension dat represent elements exp dat need mapping exp dat shown 
var exp denote set variables occurring exp exp varlist exp denote list variables 
expression variables called ground meaning expression exp set data represented expression 
define formally substitutions 
definition substitution substitution exp 
exp list variable expression pairs variables pairwise distinct exp expressions 
result applying expression exp exp expression obtained replacing occurrence exp exp exp domain dom denotes set ground exp ground 
definition full valid substitution full valid substitution fvs exp set ground substitutions expression exp fvs exp var exp dom violate domains variables var exp 
definition class concretization class cls expression variables 
set data represented class cls denoted cls defined cls def dat fvs cls dat cls example consider class cls cons cons 
class cls nonground contains variables class cls obtained applying substitution cls ground 
cls represents set data cls cons cons atom dat 

programming languages definitions programming languages computation computational equivalence 
definition programming language programming language triple syntax set syntactically correct programs data domain set input output data semantics partial function 
definition computation pgm program dat data output applying pgm dat language pgm dat denote computation write pgm dat 
definition computational equivalence computations computationally equivalent compute output computations undefined 
customary dealing programs data objects avoid extra mappings di erent data domains universal data domain programming languages representing programs programming languages dat dat 
mappings essential discussion 
say standard semantics consider deterministic programming languages 
standard non standard semantics definition interpreter programming languages program intl interpreter pgm dat intl pgm dat pgm dat interpreter implementation programming language 
follows definition programming language implemented layers interpretation 
intl interpreter intn interpreter 
program pgm computed tower interpreters intl intn pgm dat pgm dat 
semantics modifiers section introduce notion semantics modifier 
show combined standard interpreter semantics modifier change semantics programming language 
key portability non standard semantics 

non standard semantics speak non standard semantics language relation input output programs executed non standard semantics satisfy certain property example require result inverse computation program represents possible input program standard computation 
semantics satisfies property called inversion semantics talk input output non standard computation usually terms request answer distinguish standard computation 
definition non standard dialect non standard semantics programming languages property non standard dialect pgm req result ans computation pgm req ans satisfies property semantics non standard semantics definition non standard interpreter programming languages property program intl non standard interpreter exists dialect intl interpreter 
non standard dialect programming language semantics defined non standard semantics dialect uniquely determined property fact may exist infinitely di erent dialects language example request inverse computation program may infinitely answers satisfy inversion property 
dialect may return di erent answer request answer correct wrt property abramov gluck say interpreter language implementation standard semantics non standard interpreter implementation nonstandard semantics standard semantics may infinitely non standard semantics non standard interpreter implementation 
term non standard semantics broad sense including simulation analysis transformation programs specified property 
semantics modifiers semantics modifiers take non standard semantics step 
combined standard interpreter semantics modifier port non standard semantics programming language 
ect non standard computation new language achieved applying semantics modifier sem modl standard interpreter intn illustrated fig 

definition semantics modifier programming languages property set programming languages program sem modl semantics modifier interpreters intn pgm req program intn non standard interpreter intn pgm req def sem modl intn pgm req lemma modifier condition programming languages property set programming languages sem modl program 
interpreters intn pgm req result ans computation sem modl intn pgm req ans satisfies property sem modl semantics modifier proof 
consider interpreter intn 
prove intn non standard interpreter intn pgm req def sem modl intn pgm req define language pgm req semantics defined pgm req sem modl intn pgm req non standard dialect definition conditions lemma def 
ii intn non standard interpreter definitions intn def 

def 
sem modl semantics modifier lemma convenient proving program semantics modifier 
proofs 
standard non standard semantics semantics modifier standard semantics non standard result sem modl intn pgm req ans fig 

standard non standard semantics semantics modifiers 

building non standard interpreters striking features semantics modifiers possibility port non standard semantics language price writing interpreter 
straightforward define non standard interpreter language semantics modifier standard interpreter language 
sem modl modifier intn interpreter non standard interpreter defined pgm req def sem modl intn pgm req performs non standard computation pgm req ans pgm req ans correctness non standard interpreter guaranteed correctness semantics modifier sem modl established ii correctness standard interpreter intn usually easier show correctness non standard interpreter 
example semantics modifier inverse computation define inverse interpreter standard interpreter intn see fig 
examples 
definition shows build di erent non standard interpreters combining semantics modifier di erent interpreters 
regardless interpreter semantics modification get precisely intended inverse computation 

levels interpretation non standard interpreter obtained semantics modifier result distinct transitions 
direct computation programs pgm dat 
transition direct computation programs interpretation intn pgm dat second transition direct computation interpretation non standard computation interpretation sem modl intn pgm req ans abramov gluck intnl interpreter intnl pgm dat standard interpreter define pgm dat def id modl intnl pgm dat id modifier sec 
pgm req def inv modl intnl pgm req inv modifier sec 
pgm cls def eqt modl intnl pgm cls eqt modifier sec 
pgm dat def nan modl intnl pgm dat nan modifier sec 
pgm dat standard interpreter pgm req ans inverse interpreter pgm cls pgm equivalence transformer pgm dat cls pgm dat neighborhood analyzer fig 

semantics modifier standard interpreter non standard interpreter 
clear transition adds extra computational overhead 
improve ciency non standard computation shall apply program specialization 
optimization important building practical nonstandard tools examine di erent ways optimization section 

observations source language general interested establishing semantics modifiers set programming languages 
fact modifiers going valid take starting point considerations source language semantics modifier particular includes set universal languages 
programming language universal su ciently powerful specify computable functions 
consequently universal language permits simulate computation programming language 
write interpreter language called self interpreter 
conclude source language semantics modifier fact modifier valid 
order write interpreter programming language source language universal 
second matter universal language choose universal language powerful write interpreter languages third possible write self interpreter observation implies provide non standard semantics programs means self interpreter 
sem modl semantics modifier sint self interpreter pgm program sem modl sint pgm req ans standard non standard semantics 
existence semantics modifiers far specified class semantics modifiers touched question semantics modifiers exist interesting semantics modifiers 
question answered directly 
semantics modifiers exist nonsensical semantics 
illustrate example 
language dialect programs pgm data req result computation call property pgm req 
property definition semantics modifier straightforward 
regardless interpreter intn program pgm input req result fixed value modl intn pgm req def non standard interpreter intn dialect defined intn pgm req def modl intn pgm req answer second question sections 
specifically show non trivial semantics satisfy requirements semantics modifiers 
standard computation standard interpreters sec 

non standard computation inverse computation sec 

program transformation equivalence transformation sec 

program analysis neighborhood analysis sec 

case specify non standard semantics prove nonstandard semantics constructive definition exists satisfies requirements semantics modifiers 
show constructive definitions exist demonstrate algorithms computer experiments 

standard computation identity modifier interpreters easily port programming languages machine familiar approach programming language development 
role interpreters change preserve semantics programming language di erent platforms 
essence method allows port programs machine execute programs combine language definitions definition definition big advantage semantics defined interpreter programs executed machine execute programs 
words standard semantics give standard semantics regarded identity operation algebra semantics modifiers identity modifier 
abramov gluck 
modifier identity semantics show tower interpreters falls class semantics modifiers introduce notion identity dialect language define semantics modifier identity semantics 
definition id dialect programming language id dialect pgm dat result computation pgm dat pgm dat pgm dat 
property id definition id modifier interpreter intl program id modl defined id modl intn pgm dat def intl intn pgm dat theorem modifier property id modl set programming languages id modl semantics modifier id proof 
program id modl semantics modifier id semantics lemma interpreters intn programs pgm data dat result produced computation id modl intn pgm dat satisfies property id def 
id modl intn pgm dat def 
intl intn pgm dat def 
intn pgm dat def 
pgm dat identity modifier program takes inputs interpreter intn program pgm data dat 
computes output pgm interpreting intn interpreter intl 
words familiar approach porting programming languages means interpreters instance semantics modification identity modification 
covers case meta interpreters popular executing operational language definitions prototyping languages 
meta interpreter program takes definition language definition language program corresponding data input gives meaning program 
role meta interpreter change preserve semantics defined language 
means applies semantics modifiers general applies interpreter towers meta interpreters particular 

non standard computation inversion modifier standard computation calculation output program input forward execution inverse computation calculation standard non standard semantics possible input program output backward execution 
advances direction achieved area logic programming solutions emerging logic proof theory 
inverse computation important useful concept areas 
typical applications range expert systems artificial intelligence model checking program verification cf 

section show problem performing inverse computation language reduced problem constructing standard interpreter written provided algorithm inverse computation 

modifier inverse computation introduce notion inverse dialect language notion define inverse interpreter language 
show inverse computation semantics modifier programming language 
definition inv dialect programming language nonstandard inv dialect pgm classes cls result computation pgm cls ans possibly infinite list ans 
substitutions satisfies condition cls inv pgm cls property inv inv pgm cls def dat dat cls pgm dat definition inv interpreter programming languages program inv intl inverse interpreter exists inv intl interpreter 
inverse computation inv intl write inv intl pgm cls ans 
say list cls request inverse computation class cls specifies set admissible input search space output 
set inv pgm cls solution inversion problem 
largest subset cls pgm dat elements dat solution 
computation constructive representation inv pgm cls called inverse computation 
request cls inverse interpreter performs inverse computation program pgm 
enumeration cls 
representation set inv pgm cls 
substitution exists computed finite time termination inverse interpreter guaranteed sophisticated strategies general undecidable substitutions 
inv intl inverse interpreter language inverse computation new language performed inverting interpreter 
defined universal solution possible input answer inversion problem 
existential solutions possible solution obtained picking arbitrary element universal solution 
abramov gluck definition inv modifier inverse interpreter inv intl program inv modl defined inv modl intn pgm cls def inv intl intn pgm cls 
theorem modifier property inv modl set programming languages inv modl semantics modifier inv proof 
lemma inv modl semantics modifier inv interpreters intn pgm classes cls result ans 
produced computation inv modl intn pgm cls 
satisfies property inv def 
inv modl intn pgm cls ans def 
inv intl intn pgm cls ans def 
dat dat pgm cls intn dat pgm cls format pgm dat pgm dat pgm cls intn pgm dat pgm cls pgm gnd pgm dat dat cls intn pgm dat pgm cls format dat dat cls intn pgm dat cls def 
dat dat cls pgm dat cls def 
inv pgm cls cls theorem states inverse computation performed programming language inverse interpreter standard interpreter written result obtained inverse computation interpreter result inverse computation theorem guarantees result correct program regardless intn algorithmic properties 
straightforward define inverse interpreter language standard interpreter fig 

results interesting reasons 
believe observation semantics modifier encapsulate essence inverse computation useful variety verification problems 
example reasoning correctness hardware software specification may need verify critical state reached earlier state 
observed earlier language paradigm quite irrelevant semantics modifier 
able apply inverse computation directly variety language paradigms petri nets having develop separate tools language 
exploiting connections may able significantly extend capabilities tools 
standard non standard semantics programming language perspective inverse programming style programming writes programs inverse computation produces desired result 
gives rise declarative style programming specifies result describes computed 
inversion problems restricted context logic programming proof theory 
inversion useful programming language direction algorithm easier define directions needed 
semantics modifier inversion problems solved languages writing inverse interpreter language 
experiments demonstrating computational feasibility ideas section 

program transformation equivalence transformation modifier going examine important class programs class equivalence transformers 
show equivalence transformers semantics modifiers respect equivalence transformation semantics 
substantial advantage developing new program transformers 
equivalence transformer modifies structure program purpose optimizing aspects program performance time space consumption preserving program functionality 
classical example translators convert programs language changing functionality 
examples program specializers construct cient specialized versions programs program composers transform composition programs single cient program 
refer programs collectively equivalence transformers 
examining modifier property equivalence transformation modifiers specialization translation 
section shall assume specific transformation method 
experiments choose concrete algorithm 

modifier equivalence transformation introduce notion dialect language notion define transformer language 
show transformers property semantics modifiers 
definition dialect programming languages non standard dialect pgm classes cls result computation pgm cls pgm program pgm pgm pgm cls property pgm cls def pgm pgm pgm argument list vars varlist cls fvs cls pgm cls pgm vars definition transformer programming languages program eqt equivalence transformer exists abramov gluck dialect eqt interpreter 
equivalence transformation eqt write eqt pgm cls pgm 
equivalence transformation semantics states program pgm class cls mapped functionally equivalent program pgm takes values free variables cls input 
equivalence transformer program produces pgm pgm cls input 
definition modifier equivalence transformer eqt program eqt modl defined eqt modl intn pgm cls def eqt intn pgm cls theorem modifier property eqt modl set programming languages eqt modl semantics modifier proof 
lemma eqt modl semantics modifier semantics interpreters intn programs pgm classes cls program pgm produced computation eqt modl intn pgm cls pgm satisfies property def 

pgm ground varlist pgm cls varlist cls fvs pgm cls fvs cls 
eqt modl intn pgm cls pgm def 
eqt intn pgm cls pgm def 
pgm intn pgm cls def 
pgm pgm pgm pgm argument list vars varlist cls fvs cls intn pgm cls pgm vars pgm gnd pgm pgm pgm pgm argument list vars varlist cls fvs cls intn pgm cls pgm vars def 
pgm pgm pgm pgm argument list vars varlist cls fvs cls pgm cls pgm vars def 
pgm pgm cls theorem asserts possibility design generic algorithms equivalence transformation principle apply programs written language interpretive definition 
straightforward define equivalence transformer language standard interpreter fig 

experiments section illustrate ideas supercompilation powerful transformation method capable program specialization program composition see projections section show transformer obtained transformer interpreter 

program specializer eqt modifier program specializer equivalence transformer specializes program respect part input 
specialized program faithful standard non standard semantics original program significantly faster 
specializer projections assert possibility specializing programs language interpreter language property identified generally semantics modifier property 
familiar definition program specializer show program specializer serve semantics modifier specialization translation 
definition specializer program pe program specializer programs pgm argument list length input sd classification pgm pe pgm dn specializer pe takes source program pgm sd classification known values input 
result residual program returns output applied remaining input pgm applied sd classification tells specializer part input known static part unknown dynamic 
clarity ordered arguments groups easy see arguments listed order provided appropriate 
sd classification added superscript programs readability just representation class 
example pe program specializer pgm program element argument list 
specialize pgm respect di erent combinations static dynamic input corresponding sd classifications 
pe pgm ss pgm pe pgm ds pgm pe pgm sd pgm pe pgm dd pgm define semantics modifiers specializer pe specialization translation 
pe program specializer intn interpreter pgm program arguments 
def 
computational equivalence intn pgm intn pgm pgm specialization modifier semantics modifier specialization pe mod defined follows pe mod intn pgm def pe intn sd pgm pe mod intn pgm pgm imply program specializer ine partial evaluation 
abramov gluck interpreter intn annotated sd meaning pgm static dynamic 
result applying pe mod intn pgm new program pgm easy verify program pgm specialized version program pgm pgm pgm asserts possibility specializing programs writing specializer application pe mod corresponds st specializer projection 
practical results specialization modifier reported 
ciency specialization process improved specializing specialization modifier pe mod 
transformation corresponds nd rd specializer projection 
translation modifier semantics modifier translation trans mod defined follows trans mod intn pgm nil def pe intn dd pgm trans mod intn pgm nil pgm case interpreter intn annotated dd pgm static dynamic 
note variable nil right hand side trans mod definition 
request empty 
result applying trans mod intn pgm new program pgm easy verify program pgm translated version program pgm pgm pgm asserts possibility translating programs writing translator 
application trans mod corresponds st futamura projection 
practical results translation modifier reported 
similar specializer projections ciency translation process improved specializing translation modifier trans mod 
transformation corresponds nd rd futamura projection 
discuss relation detail sec 

conventional translator define translation modifier modifier trivial transformational power 
modifier embeds pgm constant intn translates new program 
experience shows pgm translated intn 
clearly translation pgm expect 
hand know translation modifier program specializer form st futamura projection practical translation modifier shown series impressive experiments see 
practical evidence theoretical concept semantics modifiers put 
standard non standard semantics 
program analysis neighborhood analysis modifier similar inverse computation semantics neighborhood analysis ported programming language 
show correctness semantics modifier neighborhood analysis 

modifier neighborhood analysis program pgm data dat semantics neighborhood analysis set program data pairs compute result pgm applied dat 
neighborhood analysis applications program testing termination supercompilation tells change pgm dat ecting output computation 
definition nan dialect programming language nonstandard nan dialect pgm dat result computation pgm dat ans pair ans cls pgm dat cls pgm dat nan pgm dat property nan nan pgm dat def pgm dat pgm dat dat pgm dat pgm dat definition nan analyzer programming languages neighborhood analyzer exists nan dialect interpreter 
neighborhood analysis write pgm dat cls pgm dat set nan pgm dat semantics neighborhood analysis program pgm data dat 
largest set elements pgm dat pgm applied dat returns result pgm applied dat 
neighborhood analysis computes approximation nan pgm dat question functionally equivalent program data pairs undecidable general 
answer exists pair cls pgm dat represents subset nan pgm dat 
say class cls pgm dat neighborhood pgm dat pgm dat index cls 
class tells change pgm dat changing output computation 
safe trivial approximation provided pgm applied dat terminates singleton set containing pgm dat element 
clearly expect practical neighborhood analysis 
shall see sec 
exists algorithms produce non trivial approximations 
purposes define semantics modifier neighborhood analysis allows port analysis programming languages introduce notion program trivial neighborhood analyzer 
analyzer computes approximation set data class cls dat 
class cls dat produced program trivial nan analyzer tells input pgm changed changing output 
abramov gluck definition program trivial nan analyzer programming languages program program trivial neighborhood analyzer pgm dat pgm dat cls dat defined pgm cls dat nan pgm dat program trivial neighborhood analyzer neighborhood analysis performed programming language interpreter language written theorem guarantees correctness results 
definition semantics modifier nan mod straightforward 
definition nan modifier program trivial neighborhood analyzer program nan modl defined nan modl intn pgm dat def intn pgm dat theorem modifier property nan modl set programming languages nan modl semantics modifier nan proof 
lemma nan modl semantics modifier nan se mantics interpreters intn programs pgm data dat result computation nan modl intn pgm dat cls pgm dat satisfies property nan def 

intn ground class intn cls cls class ii intn intn cls intn intn cls nan mod intn pgm dat cls pgm dat def 
intn pgm dat cls pgm dat def 
intn cls pgm dat nan intn pgm dat def 
intn pgm dat intn pgm dat intn cls pgm dat intn pgm dat def 
pgm dat pgm dat cls pgm dat intn pgm dat def 
pgm dat pgm dat cls pgm dat pgm dat def 
cls pgm dat nan pgm dat theorem straightforward define neighborhood analyzer language interpreter fig 

experiments demonstrating semantics modifier neighborhood analysis section 
standard non standard semantics 
case study porting non standard semantics put ideas developed previous sections trial 
implementing semantics modifiers order functional language porting respective non standard semantics functional language imperative language 
emphasis case study demonstrating existence non trivial semantics modifiers scope give definitive account di erent algorithms practical ramifications 
section programming languages give overview experiments performed 

programming languages tsg mp choice source languages important studying foundational problems 
hand languages small develop fully implement algorithms hand languages large substantiate theoretical claims computer experiments 
choose language earlier context program transformation tsg firstorder functional language mp small imperative language 
syntax shown fig 

data domain cases set expressions sec 

tsg typed dialect order functional language 
tsg program list function definitions 
variables range atoms aname expressions name 
data structures constructed cons tested decomposed eqa cons 
language restricted 
semantics formally defined 
family languages clarifying essence supercompilation related issues meta programming 
mp small imperative language assignments loops 
mp program consists parameter list declaration local variables sequence statements 
mp program operates store consisting parameters local variables 
semantics conventional pascal style semantics 
language popular experiments partial evaluation 

experiments overview implemented semantics modifier tsg ported corresponding semantics tsg mp interpreter mp written tsg 
mp tsg interpreter experiments changes interpreter di erent semantics modifiers 
semantics modifiers implemented gofer dialect haskell 
compare results tsg mp example program naive pattern matcher experiments 
run times cpu seconds including garbage collection pc intel pentium ii mhz ms windows 
programs available www ru abramov gluck pgm fd fdn tsg program fd define fn vn function definition aname name variables range atoms exp alt cond term alternative call fn exp expn function call cond cons 
exp cdr test decomposition pair eqa 
test equality exp atom cons exp exp expression pgm mp program var parameters take initial value input varn additional variables initial value nil stmt statement body program stmt var exp assignment statement exp cond stmt stmt conditional statement exp cond stmt loop statement operation odo stmt 
stmtn compound statement 
exp stops program defines result computation value exp exp var expression ocar exp exp head tail list exp exp pair exp exp exp test atom exp exp test equality fig 

syntax programming languages tsg mp 
algorithms outlined respective sections 
detailed discussion algorithm interested reader referred original literature 
graph configurations describing algorithms 
specifically sections results modifiers standard interpretation sec 

inverse computation sec 

equivalence transformation sec 

neighborhood analysis sec 


identity modifier applied mp illustrate identity modifier implemented interpreters tsg mp tsg gofer interpreter mp tsg interpreter 
shortly describe interpreters assess interpretive overhead naive pattern matcher 
interpreters experiments sections 
interpreters mp programs run gofer interpreting mp tsg interpreter tsg gofer interpreter 
tsg gofer standard non standard semantics match define match pattern string call pattern string pattern string define pat str pattern string alt cons 
pat alt cons 
error atom expected alt cons 
str alt cons 
error atom expected alt eqa 
call pattern string call pattern string failure success define pattern string alt cons 
string call match pattern failure string representation str abc cons cons cons nil examples computation match str ab str tsg success match str ab str tsg failure match str ab cons cons nil tsg error atom expected fig 

naive pattern matcher written tsg 
interpreter plays role identity modifier sec 
mp defines standard semantics mp tsg 
tsg interpreter int written lines source text mp interpreter written tsg lines pretty printed source text functions tsg 
compare interpretive overhead naive pattern matcher written tsg mp 
programs shown fig 
fig 
respectively 
matcher takes strings input pattern string 
matcher returns success pattern string failure pattern string error atom expected error format strings 
implementation details matchers di er slightly di erent programming languages 
example consider pattern str aab string str 
ab computation match pattern string yields success 
run time matcher tsg sec mp sec 
interpretive overhead due times 
run time matcher written directly gofer sec 
interpretive overhead due int times 
surprising particular checking format input strings separate test pattern string tsg matcher fig 
lines 
mp matcher check combined testing equality current positions pattern string fig 
line construction ocar pat ocar str halts program result err err ocar pat ocar str atom 
abramov gluck pattern string str pat odo string odo str pat true pat str ocar pat ocar str odo pat str false failure success string failure fig 

naive pattern matcher written mp 
considerable interpretive overhead occurs due levels interpretation 
running matcher gofer times faster running matcher mp 
expected level interpretation multiplies run time significant factor 

inversion modifier applied mp section show inverse computation ported functional language imperative language 
giving algorithm inverse computation tsg show inverse computation performed mp 
inverse computation mp achieved standard mp tsg interpreter sec 


universal resolving algorithm inversion modifier exist di erent methods inverse computation 
universal resolving algorithm outlined section uses methods supercompilation particular driving 
idea algorithm appeared early seventies variants implemented functional languages 
algorithm performs inverse computation tsg implemented gofer lines pretty printed source text 
algorithm ura outline tsg program pgm class cls output algorithm starts driving initial configuration pgm cls builds potentially infinite process tree breadth strategy step driving configuration pgm cls algorithm may encounter basic cases 
driving finishes 
result pgm cls unification succeeds substitution substitution resulting standard non standard semantics unification cls cls added answer printed added 

contraction encountered configuration pgm cls split disjoint configurations pgm cls 
pgm pgm cls 
pgm pgm cls pgm cls pgm 
algorithm stops configurations process tree completed continues driving unfinished configuration pgm cls shall concerned technical details fact answer produced algorithm correct solution soundness substitution exists computed finite time completeness 
algorithm terminate search solutions may continue infinitely substitutions question solutions exist undecidable general 

porting inverse computation ura implements inverse computation tsg inverse interpreter tsg 
theoretical results sec 
inverse computation ported languages inv modifier defined inv mod intn cls def ura intn cls experiment compare power quality inverse computation tsg mp performed inversion tasks naive matchers written tsg mp 
task find set strings pattern substrings abc 
perform task leave input pattern unknown set input string abc desired output success 
task find set strings pattern substrings aaa 
perform task setting similar task pattern string aaa desired output set failure 
results 
ii shows results applying ura match written tsg 
answer task finite representation possible substrings string abc 
answer task finite representation strings substrings aaa 
ura terminates seconds task task 
iii iv shows results mp program 
answer task finite representation possible substrings string abc 
answer task finite representation strings substrings aaa 
ura terminates sec task sec task 
discussion 
inverse computation mp implemented inv mod produces results similar inverse computation tsg implemented directly ura 
noteworthy inverse computation mp done actual implementation restrictions variable domains classes disjoint 
empty restriction list shown figures 
results di er slightly fig 
compare ii line iv line due small di erences implementation source programs details see footnote abramov gluck inverse computation tsg 
set strings substrings abc 
ura match str abc success str cons str cons cons str ab cons str cons cons cons str abc cons cons str bc cons str ii inverse computation tsg 
set strings substrings aaa 
ura match str aaa failure cons cons cons cons cons cons cons cons cons cons iii inverse computation mp 
set strings substrings abc 
inv mod str abc success str cons str cons cons str ab cons str cons cons cons str abc cons cons str bc cons str iv inverse computation mp 
set strings substrings aaa 
inv mod str aaa failure cons cons cons cons cons cons cons cons cons cons fig 

inversion modifier inverse computation tsg mp matcher 
standard interpreter mp inverse interpreter mp 
demonstrates inverse computation ported successfully functional language imperative language 
inverse computation mp takes longer tsg due additional interpretive overhead times 
earlier inverse computation successfully ported tsg small assembler programming language called norma 
experiments give practical evidence viability approach porting inverse computation imperative programming language mp 
experimental aware ports inverse computation inverses imperative programs treating relational semantics logic program 

equivalence transformation modifier applied mp section show equivalence transformation supercompilation ported functional language imperative language 
giving algorithm supercompilation tsg show supercompilation performed mp 
transformation achieved standard mp sec 

transformation passes kmp test tsg mp 
standard non standard semantics 
supercompiler equivalence transformation modifier outline algorithm supercompilation tsg algorithm equivalence transformation 
detailed discussion supercompilation methods 
supercompiler tsg implemented gofer lines pretty printed source text 
algorithm scp outline tsg program pgm class cls algorithm starts driving initial configuration pgm cls builds process tree gr initially node labeled pgm cls accumulates list basic configurations basics 
node rooted process tree labeled active configuration pgm cls passive expression 
edge labeled contraction folding mark call substitution 
build finite graph construction controlled criterion whistle decides generalize 
algorithm supercompilation proceeds passes pass graph list basics constructed root list basics initialized initial configuration pgm cls second pass new graph constructed root initialized pgm cls list basics set basics 
graph converted described new tsg program pgm 
second pass increases sharing residual program improves quality residual program 
step driving configuration pgm cls algorithm may encounter basic cases driving finishes 
result pgm cls node passive labeled 
ii contraction encountered configuration pgm cls split disjoint configurations pgm cls pgm cls pgm cls pgm cls pgm cls pgm cls pgm cls prevent infinite development conditions checked identical modulo renaming folding 
unification pgm cls pgm cls succeeds substitution unification pgm cls pgm cls succeeds substitution current node pgm cls connected node pgm cls backward edge labeled call 
whistle 
current configuration pgm cls dangerously similar parent configuration pgm pgm pgm cls homeomorphic embedding order 
instance folding 
unification pgm pgm cls succeeds substitution current node pgm cls connected node pgm backward edge labeled call pgm added basics 
generalization 
configurations pgm cls pgm generalized specific generalization pgm unified configurations substitutions sg sg current node pgm cls connected new child node pgm edge labeled call sg configurations pgm added basics driving continues pgm downwards generalization 
branching 
child nodes pgm cls pgm cls connected current node pgm cls edges labeled corresponding contraction 
driving continues child nodes 
algorithm stops development nodes graph completed 
result graph gr list basics 
shall concerned technical details fact residual program pgm produced algorithm meets conditions defini abramov gluck specialization match supercompiler pattern str aab fixed scp match str aab gofer supercompiler returns residual tsg program str define str alt cons 
str alt cons 
error atom expected alt eqa 
alt cons 
alt cons 
error atom expected call chk ab failure call failure define chk ab alt eqa 
alt cons 
alt cons 
error atom expected alt eqa 
success call chk ab failure call ii specialization eqt mod pattern str aab fixed eqt mod str aab gofer eqt mod computation returns residual tsg program tsg str define tsg str alt cons 
str call find failure define find alt cons 
err alt eqa 
alt cons 
alt cons 
err call chk ab failure alt cons 
call find failure define chk ab alt eqa 
alt cons 
alt cons 
err alt eqa 
success call chk ab failure alt cons 
call find failure fig 

eqt modifier equivalence transformation tsg mp matcher 
tion algorithm scp equivalence transformer tsg 
implemented version algorithm common transformation systems transient reductions performed testing similarity ancestor transformer terminate 

porting supercompilation supercompiler scp described powerful equivalence transformer tsg 
shall modifier tsg tsg gofer equivalence transformation 
theoretical results sec 
supercompilation applied languages eqt modifier defined eqt mod intn cls def scp intn cls experiment order compare power quality supercompilation tsg mp known kmp test classical example standard non standard semantics program transformation 
consider naive pattern matcher tsg program match fig 

assume want transform match tsg program equivalent match specialized wrt pattern str aab string dat string tsg match str aab string tsg program obtained supercompilation scp match cls gofer cls str aab parameter pattern match known fixed str aab cls second parameter string unknown represented variable cls 
list restrictions variable domains empty 
consider program naive pattern matcher written mp fig 

transformation realized mp tsg interpreter eqt modifier eqt mod cls 
results 
shows residual programs produced specializing matchers wrt pattern str aab 
transformation time tsg program match sec transformation time mp program sec 
assess ciency residual programs computation str 
ab gofer success performed residual programs tsg 
run time sec cases 
discussion 
result supercompilation remarkable experiments naive pattern matcher program transformed cient 
comparing run time residual matchers tsg run time original matcher sec 
note input residual programs times faster original matcher written tsg 
case mp speed factor specialization performed eqt mod computation times optimizations achieved eqt mod elimination interpretive level full transformation naive pattern matcher cient kmp algorithm 
residual program tsg fully optimized program tsg di ers program correspond kmp matcher pattern aab 
supercompilation tsg implemented directly scp mp implemented eqt mod passes kmp test 
syntactic change done residual programs function variable names automatically generated scp letter unique number renamed readable 
residual programs di er due small di erences source programs see footnote 
abramov gluck noteworthy results mp achieved standard interpreter mp writing supercompiler mp 
demonstrates equivalence transformation supercompilation ported functional language imperative language 
supercompilation mp takes longer tsg due additional interpretive overhead times 
related experiment shown variant turchin supercompiler generated driving interpreter specializer projections powerful convert naive pattern matcher written order functional language self interpreter kmp matcher 
experiment extends result applying hand written supercompiler imperative language 
cases removal entire level interpretation due underlying driving algorithm 

neighborhood analysis modifier applied mp section show neighborhood analysis ported functional language imperative language 
giving algorithm neighborhood analysis tsg show analysis performed mp 
achieved standard mp tsg interpreter sec 


neighborhood analysis modifier outline non trivial algorithm neighborhood analysis tsg programs 
neighborhood returned algorithm describes set input data computation process trace output 
neighborhood analysis tsg implemented gofer program trivial neighborhood analyzer nan lines pretty printed source text 
algorithm nan outline tsg program pgm data dat cls general class representing possible inputs pgm 
algorithm performs tasks computation pgm dat driving pgm cls 
builds potentially infinite process tree driving selects branches driving chosen computation interpretation pgm dat 
step computing state pgm dat driving configuration pgm cls algorithm may encounter basic cases 
computation driving finish 
result computing pgm dat result driving pgm cls unification succeeds substitution 
algorithm stops returns cls 

test contraction encountered computation performs test computation step 
driving splits configuration pgm cls disjoint configurations pgm cls 
pgm pgm cls 
pgm pgm cls pgm cls pgm 
configuration pgm cls dat cls selected driven step configurations ignored 
shall describe technical details algorithm state fact algorithm computes correct results neighborhood analysis soundness algorithm terminates tsg programs pgm data dat pgm dat tsg terminates completeness 
standard non standard semantics 
porting neighborhood analysis algorithm nan implements neighborhood analysis tsg 
theoretical results sec 
neighborhood analysis ported languages nan modifier defined nan mod intn dat def nan intn dat experiment consider tsg mp matcher experiments neighborhood analysis 
nan match pat str cls pat str 
nan mod pat str cls pat str pat str ab str str pat str str str abc success 
results 
shows result experiment 
neighborhood analysis match returns pair containing output success computation match str ab str class cls pat str describing part input str ab str computation process 
class represented list str ab str components relevant computation marked variables underlined 
variables tell corresponding components replaced arbitrary atoms arbitrary expressions respectively changing computation process output program 
data represented class passes algorithm way 
run time analysis sec 
shows result second experiment 
applying modifier nan mod returns pair containing output success computation str str abc class describing part input str str abc computation process 
run time analysis sec 
result tells modifications changing computation process output input data data cons pat cons str input pat str cons cons atom represents argument list 
text mp program rename variables atoms satisfying restrictions ii atoms represent parameter variable list iii replace expression corresponding fragments program text iv replace constant cons nil nil cons 
comparing results experiments reader note experiment tsg program match program trivial neighborhood analyzer nan produces neighborhood input match describes part input takes part computation process 
abramov gluck nan match cons cons nil str ab cons cons cons cons cons nil str neighborhood input 
cons cons nil cons cons cons cons cons nil success output computation 
nan mod pat str cls pat str pat str data str str abc 
cons nil cons cons cons nil success output computation 
cls pat str neighborhood input 
program 
pattern string str pat odo string odo str string pat pattern nil nil pat str ocar pat ocar str odo pat pat str str failure success string failure data str str abc cons nil cons cons cons nil fig 

nan modifier neighborhood analysis tsg mp matcher 
second experiment mp program modifier nan mod produces neighborhood list pat str input pat str program 
consequence inserting additional interpretive level text program part input 
standard non standard semantics experimental results correspond results sec 
def 
theorem 
discussion 
experiments neighborhood analysis tsg implemented directly nan neighborhood analysis mp implemented eqt mod return non trivial results 
particular second experiment remarkable analysis done standard interpreter mp neighborhood analyzer mp 
shows neighborhood analysis ported functional language imperative language 
neighborhood analysis mp takes longer tsg due additional interpretive overhead times 
related experiment neighborhood analysis successfully ported tsg small assembler programming language called norma 
experiments give practical evidence viability approach porting analysis programming language mp 
result analysis various applications example program testing 

eliminating interpretive overhead modifier projections scheme non standard computation previous sections gives remarkable results ine cient involves levels interpretation 
section study di erent approaches improving ciency non standard computation program specialization 
show non standard interpreters non standard compilers generated specializing semantics modifiers respect standard interpreters 

ways ciency non standard computation semantics modifier sem modl involves interpretation levels program intn interpreted sem modl ii program pgm interpreted intn sem modl intn pgm req ans programs written languages involved program pgm program intn program sem modl 
hierarchy programs languages illustrated 
performance scheme improved removing interpretive overhead removing language language program hierarchy 
reduced hierarchies shown fig 

remove intermediate languages 
program specialization partial evaluation optimization technique known drastically improving performance programs reducing interpretive overhead collapsing towers interpreters 
impressive results achieved interpreter specialization ine partial evaluation 
optimization important practical basis building real non standard tools 
remainder section examine program specialization non standard computation cient 
abramov gluck sem modl sem modl intn pgm pgm pgm program hierarchy standard compilation generation non standard interpreter non standard compilation fig 

removing interpretive layers program hierarchy 
sem modl semantics modifier non standard semantics intn interpreter pgm program req request non standard computation 
answer ans result request req 
assume pe specializer case specializer cases multi language specialization different source target implementation languages see 
describing program specialization sd notation sec 

assume reader familiar basic notions self applicable partial evaluation example part ii 
standard compilation pe intn sd pgm pgm specializing interpreter intn wrt program pgm yields program pgm functionally equivalent pgm 
perform non standard computation modifier sem modl applied pgm general requires self interpreter cf 
sec 

interpretation pgm intn avoided non standard interpretation pgm remains 
generation non standard interpreter pe sem modl sdd intn pgm req ans specializing sem modl wrt interpreter intn yields non standard interpreter non standard interpretation intn sem modl avoided non standard interpretation pgm remains 
level non standard interpretation removed 
non standard compilation pe sem modl ssd intn pgm req ans specializing sem modl wrt program intn program pgm yields nonstandard program 
standard non standard interpretation levels removed non standard semantics internalized program 
standard non standard semantics 
modifier projections non standard tools cases carried applying program specializer initial projection 
idea self applying program specializer known futamura projections 
self application convert interpreters compilers generally programs level generating extensions known ershov generating extension 
program specializers capable transformation developed variety programming languages see 
interested transformation want produce cient tools non standard interpretation non standard compilation 
repeatedly applying specializer initial projection case leads nd rd futamura projection conversion interpreter compiler generation compiler generator 
application wellknown shall pursue 
cases interesting semantics modifier specialized standard interpreter 
repeatedly applying specializer pe initial projection case leads new projections non standard interpretation 
projections non standard interpretation shown 
projection produces non standard interpreter standard interpreter produces generator non standard interpreters semantics modifier produces generator generators non standard interpreters gg double self application pe note program gg precisely compiler generator produced rd futamura projection 
repeatedly applying specializer pe initial projection case leads new projections non standard compilation 
projections non standard compilation shown fig 
projection produces nonstandard program standard program produces non standard compiler standard interpreter produces generator nonstandard compilers semantics modifier produces generator generators non standard compilers gg triple self application specializer pe note gg level compiler generator special case multi level compiler generator 
shows application programs projections 
easy verify correctness equations def 

example illustrate projection transforms standard program pgm non standard program 
consider semantics modifier inv mod inverse computation def 

result nonstandard compilation pgm pe inv mod ssd intn pgm inverse compilation req dat req ans inv mod intn pgm req ans abramov gluck non standard interpretation tools pe sem modl sdd intn non standard interpreter pe pe sd sem modl sdd generator non standard interpreters gg pe pe sd pe sd generator generators ns interpreters non standard compilation tools pe sem modl ssd intn pgm non standard compilation pe pe ssd sem modl ssd intn non standard compiler pe pe ssd pe ssd sem modl ssd generator non standard compilers gg pe pe ssd pe ssd pe ssd generator generators ns compilers fig 

modifier projections non standard tools 
non standard interpretation sem modl intn pgm req pgm req intn pgm req gg sem modl sdd intn pgm req non standard compilation sem modl intn pgm req req pgm req intn pgm req gg sem modl ssd intn pgm req fig 

equations applying non standard tools 
program performs inverse computation request req 
runs pgm computation backwards 
reasons call inverse program pgm refer non standard compilation pgm inverse compilation 
expect program cient implementation inverse program 
provides novel connection inverse computation program inversion 
summarize inverse compilation implies operations 
inversion function program pgm 
representation inverted function program 
non standard compilation arbitrary semantics modifier sem modl 
sem modl modification function source program 
representation sem modl modified function program 
modifier projections show achieved program specialization transformation step 
cases exist di erent ways obtain functionally equivalent programs 
example non standard compilation achieved steps 
converting standard interpreter intn non standard interpreter specializing non standard interpreter wrt program standard non standard semantics pgm 
result non standard program 
pe sem modl sdd intn 
pe sd pgm non standard compilation example generation non standard compiler steps 
converting standard interpreter intn non standard interpreter generating non standard compiler self application specializer pe 

pe sem modl sdd intn 
pe pe sd sd non standard compiler 
comparison modifier projections futamura projections futamura projections tell convert interpreter compiler self application program specializer 
formally speaking modifier projections specialization pattern futamura projections modifier sem modl interpreter interpreter intn source program 
perspective modifier projections viewed extending futamura projections adding new application conversion standard interpreter non standard interpreter specialization semantics modifier transforming standard interpreter inverse interpreter 
application may surprising futamura projections reduced essence define conversion arbitrary programs interpreters semantics modifiers level generating extensions compilers non standard interpreters 
framework recover classical futamura projections projections choosing translation modifier sec 
specializer projections choosing specialization modifier sec 

case pgm request req empty second case pgm request req contains part pgm input 
consequently terminology compiler non standard interpreter translation semantics specializer non standard interpreter specialization semantics 
modifier projections fit specialization pattern futamura projections 
involve generation level generating extension requires double self application level compiler generator gg produced triple self application 
possible produce level generating extension directly classical level compiler generator gg require incremental generation steps explained 
clearly ershov classical level generating extension level generating extension 
programs examples multi level generating extensions 
projections tell non standard interpreters nonstandard compilers generated semantics modifiers 
stress importance transformations believe projections pose abramov gluck new challenges program specialization example generation inverse compilers suggest new ways program specialization abstracting semantics consideration call projections collectively modifier projections 

related section relates existing semantics modifiers including translation specialization inversion reviews application program specialization 
relates theoretical practical results di erent research areas exposition incomplete 
related discussed respective sections 
interpreters popular areas meta programming development programming languages sixties 
example meta interpreters extensively logic programming instrumenting programs providing powerful ways reasoning 
applications usually restricted changing inference rules underlying logic system general attempt radical semantics changes possible semantics modifiers 
just providing means implementing standard semantics programming languages interpreter hierarchies semantics modifiers provide new formalism implementing large family non standard semantics systematic manner 
ideas earlier identified instances general scheme 
example known interpreter hierarchies porting programming languages special case semantics modification identity modifier 
futamura projections seen early example semantics modification assertion translation semantics language interpreter 
similar assertion expressed specializer projections state specialization semantics language interpreter 
projections put partial evaluation 
results show ideas extended equivalence transformers 
possibility inverse computation inverting standard interpreter language 
logic programming system say prolog considered implementation inverse computation allows depending query run programs forwards backwards 
direction aware inverses imperative programs treating relational semantics logic program 
seen application particular instance general scheme independent particular language paradigm 
earlier inverse computation successfully ported imperative languages ura algorithm inverse computation functional language 
major problem running programs new level interpretation multiplies run time interpreted program significant standard non standard semantics factor 
done reduce costs interpretation various methods program specialization see 
partial deduction form program specialization reduce interpretive overhead 
considerable success achieved refinement methods ongoing ort 
ine partial evaluation wellknown power substantially reduce interpretive overhead successfully optimize levels interpretation 
applies ine partial evaluation interpreters domain specific languages written applications may viewed working examples translation modifiers 
specializer projections supported computer experiments 
bootstrap program transformers non trivial language extensions transforming programs written higher order language transformer order language 
substantial practical evidence exists equivalence transformation modifiers done regarding inversion modifiers 
experiments show specializing interpreter inverse computation invert programs 
small number publications studies problem program inversion 
modifier projections suggest new way constructing program inverters transforming inverse interpreter 
inserting interpreter source program program transformer achieve certain powerful transformations 
interpretive approach di erent primary goal expose information program transformer instrumenting standard interpreter combine standard interpreter di erent semantics modifiers uses interpreters may combined 
reflective languages continuation semantics suggested modifying controlling computations di erent meta levels known relation semantics modifiers 

investigated semantics modifiers starting theoretical considerations experimental assessment 
specified class semantics modifiers proved modifier property non standard semantics showed constructive definitions exist performed experiments porting semantics functional imperative language showed principle cient implementations obtained program specialization advanced methods automatic program transformation 
explored semantics modifiers ranging inverse computation equivalence transformation demonstrated non trivial algorithms exist case 
suggests large class computational problems superficially di erent studied language independent uniform manner 
noteworthy designing implementing non standard semantics equivalence transformers inverse interpreters far trivial 
abramov gluck summarize approach allows 
develop set generic modifiers language 
prototype non standard semantics new language standard semantics corresponding modifier 
produce cient implementations non standard interpreters nonstandard compilers program specialization 
clear challenging problems lie ahead regarding theoretical practical ramifications approach 
modifier projections promising fully implemented partial solutions exist 
implementation may require improvements program specializers program transformers 
theoretical constructions exhibit underlying structure problems assert quality obtained results 
challenging task development structured methods constructing semantics modifiers combination existing atomic modifiers 
proofs modifier theorems follow certain pattern 
suggests meta theorem 
topics semantics modifiers 
acknowledgments authors grateful valentin turchin introducing supercompilation principles metacomputation 
special due neil jones anonymous referees providing valuable comments earlier version 
careful proofreading 
authors colleagues group group stimulating discussions various topics related 

abramov metacomputation logic programming russian 

abramov metacomputation program testing st international workshop automated algorithmic debugging linkoping university sweden pp 


abramov metacomputation applications nauka moscow russian 

abramov gluck semantics modifiers approach non standard semantics programming languages third fuji international symposium functional logic programming eds 
sato toyama world scientific pp 


abramov gluck universal resolving algorithm inverse computation functional language mathematics program construction 
proceedings eds 
backhouse oliveira lncs springer verlag appear 

apt turini meta logics logic programming mit press cambridge massachusetts 
standard non standard semantics 
asai matsuoka yonezawa duplication partial evaluation better understanding reflective languages lisp symbolic computation 

bird programs machines john wiley sons london 

bjrner ershov jones eds partial evaluation mixed computation north holland amsterdam 

bondorf palsberg generating action compilers partial evaluation journal functional programming 

bowers gurr fast declarative meta programming pp 


consel new insights partial evaluation experiment esop ed 
ganzinger lncs springer verlag 

consel marlet architecture software methodology language development principles declarative programming 
proceedings eds 
palamidessi glaser meinke lncs springer verlag 

danvy bridge reflection partial evaluation pp 


danvy gluck thiemann eds partial evaluation 
proceedings lncs springer verlag 

darlington experimental program transformation synthesis system artificial intelligence 

dershowitz 
jouannaud rewrite systems handbook theoretical computer science ed 
leeuwen elsevier pp 


earley sturgis formalism translator interactions communications acm 

ershov essence compilation formal description programming concepts ed 
neuhold north holland amsterdam pp 


futamura partial evaluation computing process approach systems computers controls 

futamura takano essence generalized partial computation theoretical computer science 

gluck generation specializers journal functional programming 

gluck jrgensen generating optimizing specializers ieee international conference computer languages ieee computer society press pp 


gluck jrgensen generating transformers deforestation supercompilation static analysis 
proceedings ed 
le charlier lncs springer verlag 

gluck jrgensen automatic program generator multi level specialization lisp symbolic computation 

gl occam razor metacomputation notion perfect process tree static analysis 
proceedings eds 
cousot falaschi file lncs springer verlag 

gries science programming texts monographs computer science springer verlag new york 
abramov gluck 
harrison function inversion pp 


gluck reasoning hierarchies online specialization systems pp 


hudak report programming language haskell non strict purely functional language sigplan notices 

jones gomard sestoft partial evaluation automatic program generation prentice hall 

jones sestoft sndergaard experiment partial evaluation generation compiler generator rewriting techniques applications ed 

jouannaud lncs springer verlag 

jones sestoft sndergaard mix self applicable partial evaluator experiments compiler generation lisp symbolic computation 

jrgensen generating compiler lazy language partial evaluation nineteenth annual acm sigact sigplan symposium principles programming languages pp 


hudak semantics directed program execution monitoring journal functional programming 

kowalski algorithm logic control communications acm 

leuschel power homeomorphic embedding online termination static analysis 
proceedings ed 
levi lncs springer verlag 

mccarthy edwards hart levin lisp programmer manual mit press cambridge massachusetts nd edition 

mogensen partially static structures self applicable partial evaluator pp 


program transformation transitions experiments supercompiler perspectives system informatics 
proceedings eds 
bjrner broy lncs springer verlag 

generation inverse functions pp 


inversion metacomputation proceedings symposium partial evaluation semantics program manipulation acm press pp 


ross running programs backwards logical inversion imperative computation formal aspects computing 

sestoft structure self applicable partial evaluator technical report diku university copenhagen denmark nov 

gluck jones positive supercompiler journal functional programming 

sperber gluck thiemann bootstrapping higher order program transformers interpreters proceedings acm symposium applied computing eds 
george carroll oppenheim hightower acm press pp 

standard non standard semantics 
sterling shapiro art prolog mit press cambridge massachusetts 

takeuchi nity meta interpreters partial evaluation information processing ed 

elsevier science publishers pp 


thiemann sperber polyvariant expansion compiler generators perspectives system informatics 
proceedings eds 
bjrner broy lncs springer verlag 

turchin na equivalent transformations recursive functions defined proceedings symposium theory languages programming methods ussr pp 
russian 

turchin concept supercompiler transactions programming languages systems 

turchin algorithm generalization supercompiler pp 


turchin program transformation transitions journal functional programming 

van de computing springer verlag 

martens parse parse logic program synthesis transformation ed 
fuchs lncs springer verlag 

wand friedman mystery tower revealed description reflective tower lisp symbolic computation 
