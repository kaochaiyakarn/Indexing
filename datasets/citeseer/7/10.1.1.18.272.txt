efficient substring traversal suffix arrays toru arikawa kyushu university fukuoka japan presto japan science tel fax mail kyushu ac jp substring traversal problem problem enumerating branching substrings appearing text 
problem easily solvable suffix tree mccreight space efficient practically fast solution important 
devise simple efficient algorithm simulates traversal suffix tree text meyers gonnet baeza yates snider algorithm runs time bulk suffix array additional structure called height naive algorithm binary search suffix array requires time worst case 
space requirement bytes algorithm smaller bytes traversal algorithm suffix tree 
linear time computing height array suffix height arrays 
computer experiments real datasets showed traversal algorithm suffix array order magnitude faster naive simulation method comparable traversal algorithm suffix tree 
investigate traversal problem problem enumerating branching substrings appearing text 
known substring traversal problem easily solvable traversal suffix tree mc large scale applications bioinformatics data mining require practical scalable algorithm problem 
suffix space efficient data structure proposed independently allows efficient advanced pattern matching suffix tree 
widely believed problems solvable suffix tree solvable binary search suffix array slowdown log factor easily observe naive algorithm substring traversal problem requires time log time constant time lcp computation 
simple efficient algorithm simulates traversal suffix tree text time suffix array combined additional information called height array 
algorithm traverses virtual suffix tree left right scan height array stack complexity blocks furthermore show algorithm modified solve class problems occurrence count branching substring linear time algorithm computing height array hgt text suffix tree sa faster naive time algorithm requires worst case 
run computer experiments real dataset showed traversal suffix array order magnitude faster simulated suffix tree traverse array approach approach advantages suffix tree traversal approach simulated suffix tree traversal array approach fast traversal algorithm runs tinhe simulated tree traversal array algorithm runs tinhe log tinhe constant time lcp information 
ii space effi data structure requires bytes bytes suffix tree requires bytes 
iii effi external memory environment external traversal algorithm sequential algorithm small number random accesses main memory 
maximally utilizes characteristics external devices traversing huge suffix array external memory 
furthermore algorithm need indirect accesses text suffix pointers 
rest organized follows 
section prepare basic notions definitions 
section linear tinhe algorithms substring traversal problem related problems 
section show height array linear tinhe computable text suffix array 
section show experimental results section conclude results 
preliminaries strings alphabet letters 
denote set strings set nonempty strings assume total order 
define length isi denote th letter aj starting define respectively 
strings denote lcp prefix lcp short lcp lcp text length string ala special marker suppose 
denote th sux 
ambiguity arises 
string occurs exist integer isi called denote occ set occurrences denote su substr sets suxes substrings text respectively 
set positions say string exists position occurrence pint 
ordered trees traversals consider ordered compacted trees 
ordered tree ot compacted internal node ot children 
sux tree ordered compacted 
ot ordered compacted tree 
root ot denote root ot 
node ot write ot 
suppose ot leaves ordered le right 
say th leaf ot 
upward path path short sequence nodes fm vi parent edge appears 
upward path starts leaf 
leaf denote branch start ends root 
ot node 
denote ot subtree ot root define depth length depth path root ot 
node node denoted exists path denote lowest suffix tree text suffix array bc ca ab suffix tree suffix array lists nodes denote concatenation 
traversal ordered tree ot list vl consisting nodes ot node ot appears exactly zr bottom descendants appear vl 
post order traversal defined special class bottom traversals 
definition 
post order ordered tree ot root root denoted pot ot list nodes ot defined recursively follows 
ot consists single node pot ot 
ii vl children root order left right ot ot corresponding subtrees ot 
oh 

suffix trees suffix arrays follows text length tz ends marker suffix tr ee text denoted st compacted trie nonempty suffixes fig 

formally suffix tree ordered tree st defined follows 
edge nonempty substring label 
label encoded pair starting position length 
ii internal node going edges 
furthermore labels distinct edges sanhe node start distinct letters 
going edges ordered left right order letter labels 
iii node represents concatenating labels path root represent nonempty suffixes th suffix labeled node st def itr string denoted str obtained 
iv st exactly leaves th leaf represents define string depth fig 
show suffix tree string 
suffix tree st leaves internal nodes stored space 
mccreight gives elegant algorithm building sa tinhe constant size alphabet tinhe log large alphabet 
strings define iff lexicographically smaller equal suffix ar text 
array sa pl consisting starting positions lexicographically ordered suffixes 
vd definition sail starting position suffix rank suffix array equivalent array obtained storing leaves suffix tree st left right 
example sa suffix array fig :10.1.1.44.5506

suffix array define 
represents inverse mapping 


array hg 
array defined hg lcp ta ta rank array consisting lcp length lexicographically adjacent suxes 
define hg 
sux array height array hg text length occupy bytes respectively store 
build sux array text linear time linear time sux tree construction algorithm construction requires space building sux tree 
simple space ecient way build sux array text sorting algorithm strings 
myers algorithm algorithm fastest algorithms log time complexity large alphabet 
ternary quick sort practical choice building sux array 
substring traversal problem define canonical class substrings called branching substrings 
text length set positions 
define binary relation substrings substrings holds iff position appears appears define relation iff hold 
set positions omit superscript definition 
substring exists pair distinct suxes su zt lemmas known easily proved sux tree 
lemma le su array iff pair ha lemma iff member finite set objects sequence elements element appears exactly 
problem set branching substrings 
encode substring representation called pair rank length sa 
state problem follows 
definition 
problem problem printing traversal branching substrings text branching substring encoded info 
substring traversal suffix arrays section efficient algorithm solves substring traversal problem linear tinhe simulating traversal suffix tree arrays sa hgt 
linear tinhe algorithm building bottom traversal ordered tree restricted class operations leaves lowest 
modifying algorithm linear tinhe algorithm substring traversal sa hgt 
application show subword statistics problem solvable linear tinhe 
sonhe proofs omitted section 
details please consult 
nca 
rightmost branch decomposition ordered compacted tree 
shadowed line going upward fi om leaf root indicates rightmost branch 
denotes special top node 
algorithm bottom traversal input ordered compacted tree ot leaves 
output post order ot 
method empty stack bottom marker foreach th stage lca top pop report top push lca set loop algorithm traversing ordered compacted tree special top node ancestor node 
bottom traversal ordered compacted trees ot ordered compacted tree leaves convention assume special top ot 
assume special leaves assumptions means parent root ot root child child fig 
show algorithm bottom traversal computing post order traversal stack operations left right scanning leaves computation lowest common ancestors decision ancestor relation nodes 
write contents stack top bottom wl top bottom algorithm sentinel 
showing correctness algorithm start preparing notations 
refer th execution loop line line fig 
th stage 
stage th leaf dd branch root lca dd ca lca current previous leaves 
call lca leaf lca 
recall path written upward direction 
branch vl rightmost consists right edges rightmost child definition 
th rightmost longest rightmost branch starting denoted 
identify ordered tree ot set nodes path set nodes appearing ot set 
paths ot ui ot lemma ay der ed ad compacted tr ee ot leaves set ot 
lemma call decomposition br ach decom ot 
lemma characterizes post order traversal ordered compacted tree rightmost branch decomposition 
lemma ot az ordered compacted tree leaves 
pot ot 
ii holds post order traversal ot rightmost ot left right 
proof easy show induction number leaves ot 
contents stack executing steps line line th stage algorithm bottom traversal fig 

node child node child leftmost 
assumption ot compacted node non leftmost child 
lemma central correctness algorithm 
refer condition vj vj leftmost child vf lemma ad vl th 
th stage 
sch iff falsified 
proof show claim induction stages suppose 
lca top see conditions top lca top algorithm executes clauses 
algorithm pushes current leaf stack results 
leaf current branch consists leftmost edges claim immediately follows 
suppose claim holds stage 
current leaf current branch previous branch 
assume algorithm executing line fig 

induction hypothesis contents stack si subsequence ri 
put toi common ancestor breaking point loop line line removes stack nodes toi located 
successively clause line line inserts inserted line puts top th stage stack contains si tos 
node satisfies claim 
lca lca lowest common ancestor assume loss generality current path lca cr 
clearly non leftmost child lca branching node 
definition lca lca leftmost leaf subtree ot rooted 
see path ul consists leftmost edges 
nodes ul falsify exclusion condition appear non leftmost child exclusion condition appears lca sux sux 
induction hypothesis claim immediately follows 
completes proof 
corollary si vl vm vo vl vm proof immediate lemma 
lemma th rightmost ii stored top stack th stage ii prefix ode ii strictly algorithm traversal input suffix tree sa height array hgt text length output post order traversal branching substrings method empty stack bottom marker foreach th stage hgt hi pop report top set loop algorithm substring statistics input suffix tree sa aggregation operator initial assignment iti output substring statistics branching substrings method compute height array hgt sa stack foreach th stage hi ci hgt hi po top hi pop loop linear time algorithm substring traversal problem 
linear time algorithm computing substring statistics branching substrings 
proof see th branch written ul 

rn nodes 
definition lea show rightmost leaf subtree ot rooted 
immediately follows path ul consists rightmost edges 
hand see leaf belongs subtree ot rooted child 
common ancestor edge rightmost edge 
combining arguments know prefix ii ul coincides longest rightmost branch ii claim follows lemma 
theorem ot ordered compacted tree leaves algorithm bottom traversal fig 
outputs post order traversal pot ot ot total time time provided computable time left right leaves proof lemma show stage branch ii stacked top si th stage popped stack stage loop line line node ii descendants lca lca 
repeating process algorithm outputs ii th execution loop nodes rightmost decomposition ii ii reported duplicates 
lemma sequence 
ii coincides post order traversal ot 
linear time traversal suffix array fig 
shows algorithm traversal array simulates algorithm bottom traversal scanning suffix array sa hgt 
text length st suffix tree algorithm represent node suffix tree st pair integers 
node denote lad ranks leftmost rightmost leaves subtree st rooted definition 
node st info info satisfies rank leaf subtree st rooted length string represented admissible st pair represents node st lemma pair 
proof suppose pair represents node th leaf st corresponding pair 
condition know path root st 
node path mutually different depth depth uniquely determines node lemma denote node represented pair node exists 
algorithm bottom traversal types nodes lca 
represented arrays sa hgt follows 
lemma properties hold leaf lea ode lca lca hgt 
proof proof immediate definitions sa hgt 
general constant time decision relation putation 
special case decidable simply examining string depth nodes 
lemma th stage traversal array fig 
top ad hgt pair lca iff proof suppose algorithm just entered te th stage 
induction stage show observations 
steps stage line show lemma contents stack nodes path lca ancestor lca path 
claim holds odes st path claim show statements iii hold line 
steps line stage contents stack path lemma 
lca path 
follows claim statements iii hold 
completes proof 
pairs nd hgt obtained sa hgt constant time theorem immediately follows theorem lemma lemma lemma 
theorem text algorithm array fig 
computes give height array hgt post order traversal time ifo 
proof st suffix tree text clearly st ordered compacted tree leaves 
theorem lemma lemma lemma see algorithm visits nodes st post order 
execution access leaf push pop operations done constant tinhe 
representation hgt obtained constant tinhe arrays sa hgt 
computation reporting node takes constant tinhe node total computation tinhe 
see algorithm traversal array efficient external model 
suppose computer fast main memory constant size times slower external memory unlimited size 
performance external memory algorithm measured number os blocks fixed size counted number elements simplicity 
roughly speaking goal develop external memory algorithm complexity main memory algorithm complexity io 
furthermore block bull consecutive previous block raw dom 
theorem block size arid text algorithm array fig 
car ur ir block arid furthermore bulk maximum depth stack ot exceed complexity reduced block 
proof arrays sa hgt input external required scanning hgt push pop operations stack see read hgt leaf pair read write internal leaf node 
read write hgt consecutive complexities claimed 
maximum stack length constant number memory blocks sufficient keep stack 
application substring statistics problem string algorithms accumulation bottom traversal suffix trees 
show substring traversal algorithm section modified solve problems 
donhain elements associative binary operator unit text tis assignment elements text positions substring statistics sum stat af peo initial elements occurrences definition 
text initial assignment statistics problem report substring statistics stat branching substring substr 
example text set sonhe marked positions problem counting marked positions branching substring instance scheme 
case assignment naive algorithm substring statistics problem takes tinhe 
fig 
show algorithm substring statistics solving substring statistics problem linear tinhe 
corollary ill ear time algorithm computes statistics ir time computable 
proof theorem algorithm correctly simulates post order traversal suffix tree st post order traversal bottom traversals node visited algorithm ensured children visited statistics stat str reported 
linear time construction height array algorithm previous section uses height array hgt compute traversal branching substrings 
section linear time algorithm computes hgt text suffix array sa 
definition hgt obtained computing hgt lca asn asn naive method takes tinhe worst case case text hgt obtained product algorithm fast hgt input text length suffix tree sa output height array hgt method compute inverse array sa foreach position th stage sail hgt hgt lcp tp sa sa exception hgt lcp tp tq hgt loop skip letters linear tinhe algorithm computing height array hgt 
construction suffix array linear tinhe computation hgt useful applications 
fig 
show algorithm fast hgt computing height array hgt linear tinhe 
lemma essential correctness algorithm 
recall th suffix suffix rank respectively refer tp 

proof lemma omitted limitation space 
lemma ar text arid th ad th suffixes sa ad sa 
hgt hgt holds 
proof note ends marker suffixes mutually distinct 
rank qa qa 
clearly adjacent 
positions tp tq 
adjacent suffixes start different letters hgt lcp ts ts cp tp tq zero claim immediately follows hgt suppose adjacent suffixes tp ts tq ts start sanhe letter tip 
immediately follows tip common prefix length hgt lcp lcp tp tq lcp tp tq eq 

integer qa 
obviously lexicographically largest suffix tb lex tb tp hand tq implies tq tq ts cp ts ts eq 

combining eq 
eq 
hgt lcp tp tq lemma know lcp length say adjacent suffixes non zero skip letter comparisons computation lcp length 
letter comparison called text position examined mark letters consistently 
similar discussion see stage redundant comparison 
theorem 
theorem give text ad suffix array qa algorithm fast hgt fig 
computes height array hgt qa ir time 
access random unfortunately algorithm external memory model block size efficient 
experimental results implemented algorithm traversal linear section sec tion workstations sun ultrasparc mhz mb solaris 
experiments english text data mb compare algorithm traversal algorithm suffix array binary search algorithm suffix tree 
table show computation tinhe algorithms 
second third columns show computation times naive traversal algorithm binary algorithm traversal array algorithm suffix tree tree 
preprocessing tinhe building hgt included 
fourth fifth columns show computation times preprocess hgt naive algorithm naive hgt fast algorithm section 
height branching suffix tree edges average respectively 
table comparison computation tinhe english text collection mb 
substring traversal height array build algorithm binary tray array tree naive hgt tinhe see table observe algorithms significantly faster naive algorithms problems 
substring traversal problem space occupancies bytes bytes letter including text construction tinhe sec sec respectively suffix array suffix tree 
performance suffix array method similar suffix tree method easy scale space 
simple linear time algorithm simulating traversal suffix tree suffix array height array showed height array computable fi om text suffix array linear tinhe 
developed efficient algorithms text mining problem called optimal discovery techniques traverse algorithm suffix array storing sparse suffixes allowing quick reconstruction 
acknowledgments takeda shinohara discussions comments issue 
abe sakamoto arikawa text data mining discovery important keywords cyberspace proc 
ieee kyoto 
arikawa efficient discovery optimal word association patterns large text databases new computing 
bentley sedgewick fast algorithms sorting searching strings proc 
soda 
ferragina constructing suffix arrays external memory 
appeared proc 
th esa lncs 
gonnet baeza yates snider new indices text pat trees pat arrays 
retrieval data structures ad algorithms pages 
harris index monash univ 
arikawa linear time substring traversal suffix arrays doi tr feb 
faster suffix sorting report lu cs tr department computer science lund university sweden 
mccreight space economical suffix tree construction algorithm jacm 
myers suffix arrays new method line string searches siam 
schieber vishkin finding lowest common ancestors simplifications paral siam 
vitter external memory algorithms oc 
acm pods 
wang chirn mart shapiro shasha zhang oc 
sigmod 

