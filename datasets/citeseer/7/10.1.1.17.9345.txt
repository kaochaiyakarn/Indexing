functional programming january fl cambridge university press simple type theoretic foundations object oriented programming benjamin pierce david turner department computer science university edinburgh king buildings edinburgh eh jz develop formal type theoretic account basic mechanisms object oriented programming encapsulation message passing subtyping inheritance 
modeling object encapsulation terms existential types recursive records studies obtain substantial simplification model objects underlying typed calculus 
static type systems object oriented programming languages progressed significantly past decade 
line research begun cardelli cook reddy kamin developed cardelli cardelli wegner cardelli mitchell cardelli cardelli mitchell bruce wand canning cook castagna castagna ghelli graver johnson culminated type theoretic accounts bruce cardelli mitchell features languages smalltalk goldberg robson 
goal reformulate essential ideas accounts simpler type theory 
key step approach alternative treatment encapsulation 
reynolds identified complementary approaches encapsulation procedural abstraction relies hiding state private variables common collection procedures type abstraction reveals existence state externally prevents illegal access hiding type 
previous accounts objectoriented programming chosen procedural abstraction encoding objects elements recursive record types 
example type movable dimensional point objects usually encoded oint rec int setx int jg pierce turner choose type abstraction close analogy mitchell plotkin treatment conventional types existential types oint rep rep methods rep int setx rep int state object component state methods operating visible encoding existential type protecting state external access 
principal benefit change simplification underlying type theory allows give complete model encapsulation message passing subtyping inheritance including special names self super recursive types generally regarded essential bruce mitchell sophisticated record extension operations appear accounts 
basic encoding yields clear separation simple aspects object model encapsulation subtyping complex essential features inheritance 
regarding inheritance just matter programming terms constructions provided basic object model develop compare alternative implementations including implementation polymorphic classes useful extension attempted models 
expressive power model objects comparable previous models appears significant difference model requires different treatment binary methods section 
section develops encoding objects detail 
section introduce subtyping 
proper treatment interaction encapsulation subtyping requires mechanism expressing refined subtyping constraints obtain extending subtyping type operators 
section sketches simple high level syntax object type declarations uniform translation basic calculus 
section introduces basic concepts inheritance simple high level syntax class definitions 
sections show detail different forms inheritance implemented framework basic object model 
section develops longer example functional variant smalltalk collection classes illustrating interesting inheritance example generalized polymorphic collections section implementation inheritance 
section compare proposed static type systems object oriented programming survey extensions basic model 
model objects higher order explicitly typed calculus subtyping 
short appendix appendix summarizes syntax typing rules easy 
examples typeset prototype compiler typechecks evaluates declarations preceded symbol 
declarations may split number lines terminated semicolon 
symbol indicates rest line comment ignored compiler 
basic familiarity polymorphic type systems subtypes existential types simple type theoretic foundations object oriented programming conventional object oriented languages helpful understanding background reading topics mitchell plotkin cardelli wegner cardelli budd goldberg robson reynolds 
objects type theoretic accounts object oriented programming restrict attention purely functional objects methods return new copy internal state updating place 
questions typing affected simplification model straightforwardly extended include imperative style object oriented programming bruce van gent modulo technical proviso section 
state object represented single value 
example state dimensional point object coordinate field record val 
int method function implements transformation state 
example bump method point objects return state coordinate increased bump fun state int plus state bump val 
int 
int setx method takes extra parameter coordinate new state setx fun state int fun int setx val 
int 
int 
int returning new state object method may extract information 
example getx method returns current coordinate getx fun state int state getx val 
int 
int internal state smalltalk style object accessible methods object interface outside world expressed replacing type state token rep types methods bump rep rep setx rep int rep getx rep int formally replacement accomplished regarding type methods function representation type type record functions pointm fun rep bump rep rep setx rep int rep getx rep int pointm pierce turner function applied particular representation points record type int yield types methods objects representation 
object satisfying specification consists record methods type pointm rep concrete state type rep paired current state type rep surrounded abstraction barrier protects current state access methods 
encapsulation directly expressed existential type point rep state rep methods pointm rep point abstracting pointm point yields higher order type operator interface specification forms type objects satisfying object fun rep state rep methods rep object kind formed types int int int kind functions types types fun object takes argument kind returns type kind 
type point objects expressed concisely applying object constructor specification pointm point object pointm point stage separation point specification methods operator capturing common structure object types just matter notational convenience 
separation crucial handling interaction encapsulation subtyping 
new point objects created existential form packages witness type body element existential type example point object representation type int internal state method implementations created follows int state methods bump fun int plus setx fun int fun int getx fun int point val 
point note object oriented languages elements object type may different internal representations different implementations methods 
example point representation type int int implemented follows simple type theoretic foundations object oriented programming int int state methods bump fun int int plus setx fun int int fun int getx fun int int point val 
point internal bump method arbitrary point invoked message sending function point bump fun point open rep rep state methods bump state methods methods point point bump val 
point 
point open binding variable rep representation type record containing state methods variable typechecking rule open ensures representation type abstractly body open functions applicable state component state methods 
apply bump function methods state producing new value type rep create new point object having methods hidden representation type original 
name point bump introduces convention follow names function sends message objects type object tm 
point setx function implemented exactly way difference need add extra parameter new coordinate point apply function setx methods state point setx fun point open rep fun int rep state methods setx state methods methods point point setx val 
point 
int 
point getx method return new state don need create new point object just apply getx function methods state yield integer return point getx fun point open rep methods getx state point getx val 
point 
int pierce turner write programs send messages setx getx bump point objects point getx point bump point setx int conventional existential types modeling types differs modeling objects package instance existential type implementing type normally opened just soon created package representing object kept closed possible moment internal state methods combined body message sending function 
recursive records encoding objects sending message object usually modeled extracting method record applying additional arguments 
responsibility performing unpacking internal state placed receiver message give responsibility sender 
subtyping object oriented languages organize specifications objects subtype hierarchy capturing intuition objects may provide services 
example consider refined form point objects carry color position information cpointm fun rep getx rep int setx rep int rep bump rep rep getc rep color setc rep color rep cpointm cpoint object cpointm cpoint expect element cpoint safely context point expected 
intuition formalized extending calculus subtype relation writing gamma mean subtype assumptions gamma 
subtype relation straightforward higher order extension due cardelli mitchell familiar calculus second order bounded quantification cardelli wegner cardelli curien ghelli 
subtyping rules appendix easy check cpoint subtype point follows 
definitions cpoint point equivalent fi conversion cpoint rep state rep methods getx rep int setx rep int rep bump rep rep getc rep color setc rep color rep cpoint simple type theoretic foundations object oriented programming point rep state rep methods getx rep int setx rep int rep bump rep rep point rules existential record subtyping record cpoint point getx rep int setx rep int rep bump rep rep getc rep color setc rep color rep getx rep int setx rep int rep bump rep rep holds record fields types common fields agree 
encoding message passing section generalized interact properly subtyping 
example typing point bump allows applied element cpoint rules subsumption arrow result application element point element cpoint 
want result type cpoint point bump supposed functional analog operation sending bump method object 
unfortunate sending message caused sender lose information type receiver 
cardelli wegner proposed proper type function point bump point bump point subtype type point objects point bump map elements type results type 
intuitively reasonable typing unfortunately possible generalize implementation point bump possesses typing 
instructive check obvious generalization wrong bump fun point fun open rep rep state methods bump state methods methods typed 
typing rule open expression requires type expression opened form type declared form variable existential quantifier 
order open rule apply rule subsumption promoting type point legal point 
apply internal bump function state combine result old record methods justified claiming built internal state new point internal state element existential pierce turner rep ill typed 
effect problem introducing bounded quantifier element point rule subsumption applied leading irrevocable loss information 
simple semantic argument 
robinson tennent shows models example partial equivalence relations bruce longo inhabitants type point identity functions 
see imagine subtype point containing just element 
instantiate point bump pass element argument result clearly point 
element type point bump behaves identity function 
working calculus notion polymorphism parametric reynolds behavior polymorphic functions depend type arguments 
fact point bump identity function type implies identity function types 
obtain sound typing point bump need consider carefully want typing express 
case need able apply point bump elements arbitrary subtypes point suffices able apply elements arbitrary object types interfaces refined interface point objects point bump pointm object 
object informally clear meant quantification pointm 
need define means formally terms subtype relation type operator subtype 
fact reasonable alternatives purposes suffices consider simplest possible subtyping types simply extended pointwise operators 
operator subtype instantiated type results stand subtype relation particular say fun subtype fun st cpointm pointm checked getx rep int setx rep int rep bump rep rep getc rep color setc rep color rep getx rep int setx rep int rep bump rep rep possible instantiation type variable rep earlier implementation easily generalized possesses required type point bump fun pointm fun object open rep rep state methods bump state methods methods object simple type theoretic foundations object oriented programming point bump val 
pointm object 
object cpointm pointm apply version point bump type operator cpointm yielding message sending function maps element cpoint cpoint desired point bump cpointm val 
object cpointm 
object cpointm polymorphic message sending functions points applied colored points losing type information cp colored point write point getx cpointm point bump cpointm point setx cpointm cp int intuitively operator subtyping permits typing message sending operations distinguish updateable portions data structure subtyping allowed portions changed message sending functions subtyping permissible presence type constructors existential quantifiers introduce type variable bindings 
operator subtyping appears type theoretic accounts objectoriented programming 
mitchell uses explicitly cook hill canning bruce rely closely related formalism bounded quantification achieve similar effect 
mitchell honsell fisher type system delegation inheritance uses similar mechanism ensure soundness object extension operator 
high level syntax objects encodings bare order precise type theoretic treatment basic mechanisms object oriented programming 
course constructions verbose direct practice 
alleviate problem implementation provides concise high level syntax declaring object types associated message sending functions 
high level syntax object types relies observation functions point setx generated uniformly types methods declaration automatically generate types pointm point implementations point getx point setx point bump 
point rep getx int setx int rep bump rep pointm fun rep getx rep int setx rep int rep bump rep rep point object pointm pierce turner point getx pointm object 
int point setx pointm object 
int 
object point bump pointm object 
object intuitively generation functions quite straightforward compiler needs find occurrences representation type rep result types methods insert necessary re packaging code build new objects returning bare instance rep example implementation point bump generated compiler identical show section 
theoretical justification compilation procedure developed detail hofmann pierce 
declaration cpoint generates functions sending setx getx bump setc getc messages 
functions cpoint setx cpoint getx cpoint bump redundant corresponding point functions essentially typing 
general cpoint version method may specific type point 
example colored point getx method type pos pos type positive numbers subtype int 
case cpoint getx type cpointm object 
pos having point cpoint message sending functions useful 
cpoint rep getx int setx int rep bump rep setc color rep getc color cpointm fun rep getx rep int setx rep int rep bump rep rep setc rep color rep getc rep color cpoint object cpointm cpoint getx cpointm object 
int cpoint setx cpointm object 
int 
object cpoint bump cpointm object 
object cpoint setc cpointm object 
color 
object cpoint getc cpointm object 
color inheritance sections demonstrate inheritance implemented formal framework developed far 
important note basic theoretical completely finished point 
began simple model objects existential types capture essential notion encapsulation 
model refined object type constructor moving second order polymorphic calculus system higher order calculus richer set kinds system 
subtyping required extension basic calculus simple type theoretic foundations object oriented programming interaction subtyping encapsulation forced crucial refinement typing message sending functions point bump 
point require changes encoding objects underlying system types 
level values hand need fixed point constructor rec necessary model behavior self 
word inheritance describe variety language features allow object definitions constructed incrementally sharing implementations methods hierarchies classes 
think classes templates create objects extended create new classes 
adopting definition important distinction objects classes objects may manipulated sending messages methods may extended changed classes hand may extended sent messages 
high level syntax provided prototype compiler declaration creates class value named type class pointm may read class instances objects interface pointm convenience initial instance class named point new 
definition type constructor class section 
class point point vars int setx fun int state getx state bump state plus state class pointm point new object pointm phrase vars int declares internal state type record single field type int initial value point new 
allow internal state variable 
example declaration vars int int introduces instance variables declares internal state type record containing fields type int 
methods setx getx bump defined terms implicit parameter state represents internal state object 
field state accessed updated writing respectively 
shall see mean quite thing intuition similar 
multiple instance variables updated cascaded applications illustrates necessary specify state updated assumed argument state way update instance variable purely functional framework 
richer language side effects omit argument 
pierce turner wish setx getx bump methods colored points behave just points 
basic idea inheritance provide notation allows methods written just definition points reused definition colored points 
class cpoint cpoint point point vars color red inherit setx getx bump setc fun color state getc state class cpointm cpoint new object cpointm phrase point point class header inherit clause lines indicate declaration free standing defines behavior colored points incrementally respect existing class point 
new methods setc getc defined explicitly taken point 
object oriented languages inherit clause implicit methods explicitly overridden subclass definition inherited superclass 
compiling definitions low level typed calculus little straightforward 
object oriented languages carry idea inheritance significant steps 
may wish bump method definition points implemented terms calls setx getx methods changing state directly 
programming practice localizes behavior setting coordinate exactly definition setx method 
typical object oriented languages need satisfied providing ability send messages self object executing method self mentioned 
slightly different syntax viewing self just record methods object class point point vars int setx fun int state getx state bump self setx state plus self getx state class pointm point new object pointm implementation bump uses getx method self extract current coordinate increments uses self setx method store updated value state yielding new state returns result 
necessary pass state argument explicitly want apply methods turn example 
imagine colored point class provides new implementation setx simple type theoretic foundations object oriented programming updates coordinate usual changes point color blue example class cpoint cpoint point point vars color red inherit getx bump setx fun int state super setx state self setc state blue setc fun color state getc state class cpointm cpoint new object cpointm implementation bump self setc change color modifying directly 
defining setx clearly self setx 
defined coordinate setting behavior setx ideal forced redefine aspect behavior new setx refer original behavior setx method points 
ability provided implicit parameter super second line definition setx method 
note working purely functional language forced explicit state updated queried 
implementation setx state original state passed method implicit parameter state state field changed 
final result method new values second major step taken object oriented language designs arrange behavior new setx seen bump method defined earlier class point inherited cpoint sending bump colored point changes color blue incrementing coordinate cpoint new val 
object cpointm cpoint getc cpointm red color point bump cpointm val 
object cpointm cpoint getc cpointm blue color called late binding recursive bump self setx self getx cited characteristic feature object oriented languages 
shall see means necessary feature somewhat simpler equally useful variants inheritance built task providing interesting challenge fact provided quite straightforwardly stands additional evidence type theory rich capture wide variety object oriented features 
pierce turner implementing inheritance explain detail inheritance implemented 
simple version inheritance instance variables class accessible methods subclasses working stages introduce difficult technical constructions 
section develops sophisticated implementation superclass instance variables hidden subclasses 
version compiler uses base high level class definitions described previous section 
point section development somewhat technical 
details inheritance bearing basic object model developed early sections readers may want skim sections skip directly section 
essential differences class object threefold 
internals object protected hard encapsulation boundary way pull incremental modifications replace packaging 
languages sort incremental modification objects allowed called delegation notion encapsulation somewhat different kind considering 

methods object specialized internal states particular type typically records fixed collection fields 
subclass definitions may add new fields 
order deal flexibility methods class polymorphic final representation type 

methods object essentially functions states states 
implement behavior self introduced previous section necessary postpone deciding record methods special name self refers class instances self necessarily refer methods class methods subclass defined 
methods class thought functions self functions states states 
class essentially just object packaging left decisions representation recursive self postponed extended 
class instantiated form object representation self fixed methods concrete functions class pointm class cpointm object pointm cp object cpointm new new extend note classes values types write different simple type theoretic foundations object oriented programming classes type class pointm build objects type object pointm 
type colored point class subtype type point class type colored point objects subtype type point objects 
assume moment points colored points exactly representation type need deal inheritance methods int color color second point class previous section implemented pure record methods abstracted record self methods types fun self pointm getx fun setx fun fun int color color bump fun self setx plus self getx pointm val 
pointm 
pointm type assertion pointm included help typechecker print type readable form assertion equivalent verbose type printed 
recursive setx getx bump delayed referring setx getx fields self 
delayed resolved create instance supplying argument polymorphic fixed point operator rec create concrete record functions encapsulated point object state color red methods rec pointm object pointm val 
object pointm class superclasses behavior defined directly 
colored points hand defined incrementally means function mapping implementation point methods called super implementation colored point methods fun super pointm superclass methods fun self cpointm recursively defined self methods getx super getx setx super setx getc fun color setc fun fun color color bump super bump cpointm val 
pierce turner pointm 
cpointm 
cpointm getx setx bump methods inherited copying abstracted record point methods 
parameter self plays role delaying recursive colored point methods instantiation time 
happens 
create colored point object build implementation inherited point methods supplying record colored point methods obtained fixed point regarded record point methods cpointm subtype pointm cp state color red methods rec cpointm fun self cpointm self self object cpointm cp val 
object cpointm consider realistic case defining subclass involves extending state collection methods 
points represented just field representation colored points color field 
int int color color time provide general extension instantiation functions applied arbitrary class definitions 
new variability representations creates technical difficulty 
literally true setx method behaves identically points colored points setx points expects state argument type discards replaces new value setx colored points expects state argument type returns record new field copy old color field 
resolve difficulty need observation setx method points need know state type state contains coordinate 
needs way extracting component type state way overwriting just component produce new copy state 
abstracting pair functions extracting get overwriting put obtain new point class polymorphic final representation type finalr eventual subclass fun finalr fun get finalr fun put finalr finalr simple type theoretic foundations object oriented programming fun self pointm finalr getx fun finalr get setx fun finalr fun int put bump fun finalr put plus get pointm finalr val 
finalr finalr 
finalr finalr 
pointm finalr 
pointm finalr abstracting method interface pointm local representation type type yields type operator describing types arbitrary class definitions 
class fun fun finalr finalr 
finalr finalr 
finalr 
finalr class generic instantiation function new takes class initial state constructs object fixed point constructor choosing final representation local representation supplying identity function extractor argument function simply returns second argument 
new fun fun fun class fun state methods rec fun self fun fun fun self object new val 
class 

object point objects created applying new type point methods pierce turner representation type appropriately typed point class initial value representation type 
new pointm val 
object pointm write generic class extension function extend 
function abstracted ffl existing class definition superclass ffl function describes increment methods class new class ffl extractor get put converting representation type class desired representation type newr new class 
parameters extend constructs new class extractor converting finalr newr composed ones convert newr enable superclass methods access part state 
convenience define increment type 
class type abstracted implementation superclass methods 
increment fun superclass interface fun newm new class interface fun newr new representation finalr final representation finalr newr 
extractor finalr newr finalr 
finalr 
superclass methods newm finalr 
self methods newm finalr returning new methods increment extend fun superclass interface fun superclass representation fun newm new class interface fun newr new class representation fun superclass class superclass fun increment newm newr increment function fun get newr new super extractor fun put newr newr new super build extended class 
fun finalr fun finalr newr fun finalr newr finalr fun self newm finalr finalr superclass finalr fun finalr get simple type theoretic foundations object oriented programming fun finalr fun put self self class newm newr extend val 
newm newr class 
increment newm newr 
newr 
newr newr 
class newm newr colored point class implemented extending extend pointm cpointm fun finalr fun get finalr fun put finalr finalr fun super pointm finalr fun self cpointm finalr getx super getx setx super setx getc fun finalr get color setc fun finalr fun color put color bump super bump fun fun fun color color val 
class cpointm applying new yields object type object cpointm cp new cpointm color red cp val 
object cpointm manipulated sending messages section point getx cpointm point bump cpointm cp int private instance variables literature object oriented programming argued 
snyder giving subclasses direct access instance variables superclasses violation proper encapsulation discipline 
section develop alternative implementation extend new instance variables hidden subclasses 
methods defined point class see representation pierce turner int new methods defined colored point class see new instance variable color color color introducing higher level operations manipulating maps state vectors different shapes 
extractor larger type smaller type written extractor pair functions extracting component element overwriting component element new value extractor fun fun get put extractor simplest extractor maps type fun get fun put fun fun extractor val 
extractor extractors appropriate types form composition follows fun fun fun fun extractor fun extractor get fun get get put fun fun put put get extractor val 
extractor 
extractor 
extractor define extractors special case larger type just pair smaller type type pair fun fun fst snd pair fun fun get fun pair fst simple type theoretic foundations object oriented programming put fun pair fun fst snd snd extractor pair val 
extractor pair fun fun get fun pair snd put fun pair fun fst fst snd extractor pair val 
extractor pair crucial change definition operator class 
including explicit representation type type class existentially quantify class respect type variable stands hidden representation type chosen class built 
initial value local state component specified class chosen instantiation time 
class fun finalr extractor finalr 
finalr 
finalr class example class point objects fun finalr fun extractor finalr fun self pointm finalr getx fun finalr get setx fun finalr fun int put bump fun finalr self setx plus self getx class pointm val 
class pointm new function obtains representation type new object opening class reveal hidden representation type initial state immediately create new object hides representation representation type allowed escape 
new fun fun class open 
state pierce turner methods rec fun self self object new val 
class 
object similarly extend function opens packaged superclass reveal representation type initial state uses form representation type initial state new class pairing new local representation type new local state 
extractors local state superclass needed function builds superclass methods new class needed function build builds new local methods constructed extractor final representation type new state type pair new local state type superclass state type composing 
extend fun fun newm fun fun superclass class fun fun increment newm open superclass 
pair fst snd fun finalr fun extractor finalr pair fun self newm finalr finalr pair finalr get put finalr finalr pair self self class newm extend val 
newm class 

increment newm simple type theoretic foundations object oriented programming 
class newm class colored points defined extending point class extend pointm cpointm color red fun finalr fun get finalr fun put finalr finalr fun super pointm finalr fun self cpointm finalr getx super getx setx super setx getc fun finalr get color setc fun finalr fun color put color bump super bump val 
class cpointm cp new cpointm cp val 
object cpointm point getx cpointm point bump cpointm cp int high level class definitions section compiled straightforwardly calls extend function defined section 
method bodies implicitly abstracted state vector state setx method fun int state fun state int fun int put state notation accessing updating instance variables li accessing field th label li updating li field state vector compiled calls get put li get li li put get li ln get ln ln set instance variables local part state vector 
abbreviation kind polymorphic record update translated directly lower level record operations set instance variable names class definition known statically powerful extensible record types wand emy cardelli cardelli mitchell jategaonkar mitchell required 
course setting instance variables mutable implicit state variable state dropped need apply get put state vector state 
pierce turner example smalltalk style collections smalltalk collection classes cited paradigm example inheritance object oriented programming 
standard smalltalk programming environment includes rich variety class definitions data structures representing sets bags lists arrays sorts collections 
definitions classes organized inheritance hierarchy great deal functionality shared groups behaviorally similar classes 
section implement simple purely functional variant classes collection bag 
moment assume elements collection integers 
class forms root hierarchy collection classes describes behavior common integer collections 
provide just operations size counts elements collection fold applies function elements collection turn passing result previous application second argument case rep fold int 

size int fun rep fold rep int size rep int object fold object 
int size object 
int size method implemented straightforwardly terms fold 
fold implemented generically arbitrary collection behavior depends specific sort collection question words fold virtual deferred method supplied subclasses class virtual fold size self fold state int fun elt int fun count int succ count class new object keyword virtual inherits directs compiler copy listed methods self method vector super 
translation pure section 
bag simple sort concrete collection 
provide just operation addition fold size add method inserts new element bag simple type theoretic foundations object oriented programming rep fold int 

size int add int 
rep fun rep fold rep int size rep int add rep int rep object fold object 
int size object 
int add object 
int 
object class declaration bags implement add new fold declared virtual inherit size superclass 
list integers represent elements bag function fold function list representing elements bag class vars list int nil int inherit size fold fun fun int fun int state add fun int state cons int state class new object function cons builds new list old list element added front build lists type instantiate cons naming type elements argument 
note definition size inherits internal call fold method 
capability essence smalltalk style inheritance 
write simple program builds bag calculates size add new val 
object add val 
object size int polymorphic collections course able build collections elements type whatsoever just integers 
accomplished straightforward generalization implementation inheritance 
simplify presentation return pierce turner variant inheritance developed section instance variables superclasses visible subclasses 
introduce notion polymorphic class class sense section abstracted additional type parameter concrete representation type depends eventual value types finalr argument type operators similarly interface operator argument stands hidden representation type stands element type 
fun fun finalr finalr 
finalr finalr 
finalr 
finalr example collection class instance variables local representation type expressed operator fun interface collection methods fun fun rep fold rep 


size rep 
int collection class formed class integer collections abstracting fun fun finalr fun get finalr fun put finalr finalr fun self finalr fold self fold size fun state finalr self fold state int fun elt fun count int succ count val 
functions evident generalizations new extend 
show just simple type theoretic foundations object oriented programming fun superclass interface fun newm new class interface fun newr new representation element type finalr final representation finalr newr 
extractor finalr newr finalr 
finalr 
superclass methods newm finalr 
self methods newm finalr returning new methods fun superclass interface fun superclass representation fun newm new class interface fun newr new class representation fun superclass superclass fun build newm newr increment function fun get newr new super extractor fun put newr newr new super build extended class 
fun fun finalr fun finalr newr fun finalr newr finalr fun self newm finalr build finalr superclass finalr fun finalr get fun finalr fun put self self newm newr val 
newm newr 
newm newr 
newr 
newr newr 
newm newr representation interface specification polymorphic bags pierce turner fun fun rep fold rep 


size rep 
int add rep 

rep fun elements list suitable class definition fun fun finalr fun finalr fun finalr finalr fun super finalr fun self finalr add fun state finalr fun state elements cons state elements fold fun state finalr fun fun fun start state elements start size super size fun fun fun fun fun val 
create bag choose type elements initial value internal state color elements nil color val 
object color message sending functions bag add collection size abstracted type elements bag add val 
object 

object collection size val 
object 
int send messages integer bag follows bag add color color blue val 
object color bag add color color red val 
object color collection size color color int simple type theoretic foundations object oriented programming related bruce develops formal semantics previous models mitchell cook collaborators proof soundness high level object oriented language essentially features 
bruce model fundamentally quite similar developed 
particular bounded quantification corresponds higher order bounded quantification inh relation object types corresponds operator subtyping 
principal difference bruce uses recursive types type operators represent interface types objects leading conclude semantics language complex involving fixed points element type level believe complexity underlies basic concepts object oriented programming languages 
inherently complex features include implicit recursion inherent keyword self refer current object corresponding type 
bruce agree fixed points element level required model inheritance methods referring self argued complexity recursive types inherent basic concepts object oriented programming 
bruce account complicated fact uses recursive types interfaces existential types hiding instance variables clear needed 
formulate account terms primitive record operations bruce explicit extractors handle extension state inheritance bruce uses extensible records emy cardelli mitchell purpose 
course translation high level syntax described section pure generate appropriate extractors amounts implementing kind extensible records set fields record extended known statically full complexity row variables wand cardelli needed 
cardelli treatment object oriented programming aims describe basic features encapsulation subtyping inheritance bruce 
bruce cardelli adopts syntactic point view trying capture set fundamental requirements form typed calculus 
bruce basic model objects recursive records consequently recursive record types critical way 
bounded quantification cardelli uses set flexible record extension operators concept rows achieve degree abstraction necessary support inheritance 
cardelli shares concern formal economy high level calculus extensible records faithfully translated pure calculus bounded quantification 
dimension low level calculus simpler uses second order bounded quantification require higher order bounded quantification 
hand simpler omits recursive types favor existential types encoded universal quantification 
pierce turner abadi mitchell honsell fisher related models objects delegation inheritance ungar smith 
systems basic calculus formalism extended new syntactic forms designed directly capture operations message sending object construction 
semantics extended language set typing rules implicitly recursive types proved sound respect semantics 
difference class formulations objects inheritance formulations delegation appears mainly style notation formal problems arise cases handled similar techniques 
hard modify encodings objects sections obtain simple statically typed model delegation 
significant difference models proposed arises fact existential quantification recursive types types capture notion encapsulation 
foundational difference gives rise slight difference expressive power appears treatment binary general ary methods methods list arguments includes objects type receiver 
methods divided essentially different categories 
strong binary methods ability obtain direct concrete access internal states objects time 
typical example strong binary method union operation sets integers internal representation sets integers efficient data structure balanced tree 
internal representation normally exposed interface set objects implementation union able obtain internal representations arguments order perform task acceptable efficiency 

weak binary methods accept arguments type receiver need access internal states extra arguments directly 
usual example discussed literature static type systems objects equality methods point objects falls category important components point internal state exposed public interface possible compare point looking directly coordinate comparing number obtained asking coordinate 
models objects recursive types support weak binary methods strong ones 
model supports directly 
pierce turner propose easy generalization basic object model cardelli wegner partially types supports strong form binary methods 
generalization type theoretic machinery available ideas apply equally model higher order subtyping 
characterization object types studied hofmann pierce relate encodings existential types simple type theoretic foundations object oriented programming recursive types showing viewed valid implementations type system primitive object type constructor 
papers castagna ghelli longo castagna castagna ghelli proposed intriguing new approach foundations object oriented programming 
overloading subtyping basic encapsulation subtyping develop underlying calculus promises model features notably multi methods languages clos bobrow fall completely outside scope previous theories including 
benefits comparing type theoretic models objects sees clearly essentially different basic premises object oriented languages simula smalltalk messages exactly receiver strong notion encapsulation maintained languages family clos give strong notion encapsulation return symmetric notion method body selection types number arguments 
magnitude difference fact modeling clos multi methods require formal language non parametric notion run time computation types 
existing object oriented languages include mutable instance variables 
mutable state provided framework extending ref type constructor similar ml specifying call value reduction strategy 
necessitates small change fixed point operator object creation basic object model unaffected 
bruce van gent bruce van gent describe similar extension bruce language bruce 
approach extended typed account multiple inheritance adding intersection types coppo pierce 
ideas sharpened conversations dave berry kim bruce luca cardelli giuseppe castagna william cook giorgio ghelli carl gunter bob harper giuseppe longo dave macqueen robin milner kevin mitchell randy pollack nick rothwell stuart schieber phil wadler 
especially grateful martin hofmann important insights formal background constructions randy pollack helping understand kim bruce adriana mike fourman bob harper martin hofmann kevin mitchell suggested number improvements earlier drafts 
comments referees helped clarify details suggested important large scale reorganization presentation 
earlier version popl pierce turner 
jointly supported limited science engineering research council esprit basic research actions types confer 
pierce turner appendix gives short review explicitly typed calculus formal basis encoding objects 
formally type system straightforward generalization cardelli wegner bounded quantification notion type operator familiar girard system 
syntax typing rules summarized appendix examples typeset prototype compiler typechecks evaluates declarations preceded symbol 
declarations may split number lines terminated semicolon 
symbol indicates rest line comment 
compiler response expression print value type complex values printed val int variables lowercase letter allows distinguish variables type variables start uppercase letters 
bind top level expressions variables writing id example int record values written 
note record types slightly different brackets 
select elements record syntax label record record val 
int int record int notion subtyping cardelli wegner formalizes observation values certain types may safely substituted values types 
example allow record type int int context expecting record type int presence extra field detected context lead run time error 
subtype relation defined collection inference rules listed appendix form gamma example usual rule 
cardelli subtyping record types fl ng fk gamma gamma km jg gamma km jg fjl jg record consider example extract function extracts field argument record write abstraction syntax fun simple type theoretic foundations object oriented programming extract fun int extract val 
int 
int subtyping allows extract function accept records type int arguments records type subtype int extract int usual subtyping behavior function type constructor contravariant function argument type covariant result type 
intuitively function may replace function fewer demands arguments gives better result gamma gamma gamma gamma arrow type variable term syntax fun bound abstracted type variable ensures instantiation subtype write function polymorphic type requires record type containing field type int 
type application uses syntax 
fun int fun fst snd val 
int 
fst int snd int int val 
fst int snd int int operations booleans integers built false bool true bool bool 
bool bool 
bool 
bool plus int 
int 
int minus int 
int 
int eqint int 
int 
bool syntax existential types fairly standard 
consider implementation counters representation type int zero fun int plus iszero fun int eqint val 
zero int int int iszero int bool hide representation type int yielding type counters syntax 
actual representation type existential type specifies type external interface type annotation may omitted 
pierce turner counter implementation int 
interface type zero 
iszero 
bool counter val 
zero iszero bool subtyping allow bound existentially quantified type variable provides known partially types cardelli wegner 
types unpacked open construct 
example unpacking counter binds hidden counter representation binds implementation impl open counter impl 
impl iszero impl impl zero false bool rules existential types ensure way create counter operator impl zero similarly way modify examine counter impl impl iszero 
incorporates girard notion type operators girard thought forming simply typed calculus level types 
ensure formedness types type operators assigned kinds form expressions kind ordinary types expressions kind functions types types bind types type operators type variables way expressions compiler responds type type operator definition printing kind 
int 
int fun int val 
declare type type annotation preceding expression 
typechecker simply checks annotated type equivalent type expression type annotations usually simplify types printed typechecker 
abstraction type operators uses syntax fun uppercase fun indicating defining function types types values values 
pair fun fun fst snd pair simple type theoretic foundations object oriented programming fun bool bool fst true snd false pair val 
pair compiler allows omit kind annotation abstraction fun written fun fun fst snd example 
kind written top 
syntax allows bound variable omitted top example abbreviates top 
type written 
pointwise subtyping operators fun subtype fun subtype legal substitutions subtype possible substitutions assumptions formally suffices check subtype assumption top 
example fun subtype fun subtype 
summary appendix summarizes syntax typing rules typed calculus extension girard system girard subtyping 
ideas system due cardelli particularly structural subtyping notion power type cardelli extension subtype relation type operators developed cardelli mitchell cardelli mitchell bruce mitchell 
cardelli cardelli powerful treatment operator subtyping including monotonic antimonotonic subtyping addition pointwise subtyping 
omit detailed treatment semantics examples suffices regard meaning term normal form compiler uses call name untyped reduction strategy 
semantic model version extended recursive types including recursively defined values needed model self bruce mitchell bruce mitchell 
syntax 
notation typing rules follow define sets valid judgements forms gamma term type gamma type kind gamma subtype gamma context gamma formed context gamma abbreviates gamma gamma pierce turner 
definition sets kinds types terms contexts defined grammar kind types kind type operators type variable fun type operator application operator top top type function type universally quantified type existentially quantified type fjl jg record type variable fun abstraction application fun type abstraction type application ht ei packing open ha xi unpacking fl record construction field selection gamma ffl empty context gamma variable binding gamma type var binding bound 
convention write gamma gamma implicitly require defined gamma 

definition type closed respect context gamma ftv dom gamma 
term closed respect gamma ftv fv dom gamma 
context gamma closed 
gamma fg 
gamma gamma gamma closed closed respect gamma 
gamma gamma gamma closed closed respect gamma subtyping statement gamma closed gamma closed closed respect gamma typing statement gamma closed gamma closed closed respect gamma 
convention assume statements discussion closed 
particular allow closed statements instances inference rules 
assume variables bound context distinct names 
convention amounts regarding variables bound simple type theoretic foundations object oriented programming viewing bound variables debruijn indices de bruijn replaces usual side conditions rules 
contexts ffl context empty gamma gamma context tvar gamma gamma context var kinding tvar rule finds kind simply looking bound associated context finding kind bound 
example type variable introduced arrow rule context contains bound top top rule top tvar rule expected 
gamma gamma gamma tvar gamma atop gamma fun arrow gamma gamma gamma arrow gamma context gamma top top gamma gamma gamma 
arrow gamma gamma 
gamma gamma 
gamma context gamma gamma fjl jg 
record pierce turner subtyping gamma gamma fi gamma conv gamma context gamma gamma tvar gamma gamma refl gamma gamma gamma trans gamma gamma top tn gamma top tn top gamma gamma gamma gamma arrow gamma gamma gamma gamma gamma gamma gamma gamma fl ng fk gamma gamma km jg gamma km jg fjl jg record gamma atop gamma fun fun abs gamma gamma gamma app typing gamma gamma gamma subsumption gamma context gamma gamma var gamma gamma fun arrow simple type theoretic foundations object oriented programming gamma gamma gamma arrow gamma gamma fun gamma gamma gamma gamma au gamma gamma gamma hs ei gamma gamma gamma open ha xi gamma context gamma gamma fl fjl jg record gamma fjl jg gamma record abadi february 
baby modula theory objects 
research report 
digital equipment systems research center palo alto california 
bobrow demichiel gabriel keene kiczales moon 
common lisp object system specification document 
sigplan notices 
bruce mitchell january 
models subtyping recursive types higher order polymorphism 
proceedings nineteenth acm symposium principles programming languages 
bruce march 
equivalence semantic definitions inheritance object oriented languages 
proceedings mathematical foundations programming semantics 
bruce january 
paradigmatic object oriented language design static typing semantics 
tech 
rept 
cs 
williams college 
bruce january 
safe type checking statically typed object oriented programming language 
proceedings twentieth acm symposium principles programming languages 
bruce longo 
modest model records inheritance bounded quantification 
information computation 
carl gunter john mitchell editors theoretical aspects object oriented programming types semantics language design mit press appear 
earlier version appeared proceedings ieee symposium logic computer science 
bruce van gent 
new type safe object oriented imperative language 
submitted publication 
pierce turner budd 
object oriented programming 
reading ma addisonwesley 
canning cook hill mitchell september 
bounded quantification object oriented programming 
pages fourth international conference functional programming languages computer architecture 
cardelli 
amber 
pages cousineau curien robinet 
eds combinators functional programming languages 
springer verlag 
lecture notes computer science 
cardelli 
semantics multiple inheritance 
information computation 
preliminary version semantics data types kahn macqueen plotkin eds springer verlag lncs 
cardelli january 
structural subtyping notion power type 
pages proceedings th acm symposium principles programming languages 
cardelli october 
notes unpublished notes 
cardelli january 
extensible records pure calculus subtyping 
research report 
dec systems research center 
carl gunter john mitchell editors theoretical aspects object oriented programming types semantics language design mit press appear 
cardelli january 
typed foundations object oriented programming 
tutorial popl 
cardelli mitchell 
operations records 
mathematical structures computer science 
carl gunter john mitchell editors theoretical aspects object oriented programming types semantics language design mit press appear available dec systems research center research report august proceedings mfps springer lncs volume 
cardelli wegner 
understanding types data abstraction polymorphism 
computing surveys 
cardelli martini mitchell scedrov 
extension system subtyping 
pages ito meyer 
eds theoretical aspects computer software sendai japan 
lecture notes computer science 
springer verlag 
castagna ghelli longo 
calculus overloaded functions subtyping 
pages acm conference lisp functional programming 
san francisco acm press 
available rapport de recherche liens ecole normale sup erieure paris 
castagna may 
strong typing object oriented paradigms 
rapport de recherche liens 
ecole normale sup erieure paris 
pierce august 
multiple inheritance intersection types 
tech 
rept 
ecs lfcs 
lfcs university edinburgh 
available catholic university nijmegen computer science technical report 
submitted conference publication 
cook 
denotational semantics inheritance 
ph thesis brown university 
cook hill canning january 
inheritance subtyping 
pages seventeenth annual acm symposium principles programming languages 
carl gunter john mitchell editors theoretical aspects object oriented programming types semantics language design mit press appear 
simple type theoretic foundations object oriented programming coppo dezani ciancaglini 
functional characters solvable terms 
zeitschrift fur mathematische logik und grundlagen der mathematik 
curien ghelli 
coherence subsumption minimum typing typechecking mathematical structures computer science 
carl gunter john mitchell editors theoretical aspects object oriented programming types semantics language design mit press appear 
de bruijn 
lambda calculus notation nameless dummies tool automatic formula manipulation application church rosser theorem 

math 
ghelli october 
static type system message passing 
pages conference object oriented programming systems languages applications 
distributed sigplan notices volume number november 
girard 

interpr etation fonctionelle elimination des coupures de arithm etique ordre sup erieur 
ph thesis universit paris vii 
goldberg robson 
smalltalk language implementation 
reading ma addison wesley 
graver johnson january 
type system smalltalk 
pages seventeenth annual acm symposium principles programming languages 
hofmann pierce 
unifying type theoretic framework objects 
symposium theoretical aspects computer science 
extended version available view objects subtyping preliminary report university edinburgh lfcs technical report ecs lfcs 
jategaonkar mitchell july 
ml extended pattern matching subtypes preliminary version 
pages proceedings acm conference lisp functional programming 
kamin january 
inheritance smalltalk denotational definition 
pages proceedings acm symposium principles programming languages 
mitchell plotkin 
types existential type 
acm transactions programming languages systems 
mitchell january 
extension standard ml modules subtyping inheritance 
pages proceedings eighteenth acm symposium principles programming languages 
mitchell january 
typed foundation method specialization inheritance 
pages proceedings th acm symposium principles programming languages 
carl gunter john mitchell editors theoretical aspects object oriented programming types semantics language design mit press appear 
mitchell honsell fisher june 
lambda calculus objects method specialization 
ieee symposium logic computer science 
pierce turner january 
object oriented programming recursive types 
proceedings twentieth acm symposium principles programming languages popl 
pierce turner april 
statically typed friendly functions partially types 
technical report ecs lfcs 
university edinburgh lfcs 
available inria rocquencourt rapport de recherche 
reddy july 
objects closures semantics object oriented languages 
pages proceedings acm symposium lisp functional programming 
pierce turner emy 
typechecking records variants natural extension ml 
pages proceedings sixteenth annual acm symposium principles programming languages austin 
acm 
carl gunter john mitchell editors theoretical aspects object oriented programming types semantics language design mit press appear 
reynolds 
types abstraction parametric polymorphism 
pages mason 
ed information processing 
amsterdam elsevier science publishers 
north holland 
reynolds 
approaches type structure 
mathematical foundations software development 
springer verlag 
lecture notes computer science 
reynolds 
user defined types procedural data structures complementary approaches data abstraction 
pages gries 
ed programming methodology collection articles ifip wg 
new york springer verlag 
reprinted ed new advances algorithmic languages inst 
de recherche informatique automatique rocquencourt pages 
carl gunter john mitchell editors theoretical aspects objectoriented programming types semantics language design mit press appear 
robinson tennent october 
bounded quantification record update problems 
message types electronic mail list 
snyder 
encapsulation inheritance object oriented programming languages 
proceedings oopsla distributed acm sigplan notices 
ungar smith 
self power simplicity 
pages proceedings acm symposium object oriented programming languages systems applications oopsla 
wand june 
complete type inference simple objects 
proceedings ieee symposium logic computer science 
wand 
corrigendum complete type inference simple objects 
proceedings ieee symposium logic computer science 
wand june 
type inference record concatenation multiple inheritance 
pages fourth annual ieee symposium logic computer science 
