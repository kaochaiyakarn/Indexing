dwarf shrinking yannis nick roussopoulos yannis kotidis institute advanced computer studies labs research university maryland college park isis nick umiacs umd edu kotidis research att com dwarf highly compressed structure computing storing querying data cubes 
dwarf identifies prefix suffix structural redundancies factors coalescing store 
prefix redundancy high dense areas cubes suffix redundancy significantly higher sparse areas 
putting fuses exponential sizes high dimensional full cubes dramatically condensed data structure 
elimination suffix redundancy equally dramatic reduction computation cube recomputation redundant suffixes avoided 
effect multiplied presence correlation attributes cube 
dimensional cube shrunk way gb dwarf cube minutes storage reduction ratio 
dwarf provides precision cube queries self sufficient structure requires access fact table 
dwarf practical automatic discovery single pass fact table prefix suffix redundancies user involvement knowledge value distributions 
describes dwarf structure dwarf cube construction algorithm 
optimizations introduced improving clustering query performance 
experiments current implementation clude comparisons detailed measurements real synthetic datasets previously published techniques 
comparisons show dwarfs far outperform techniques counts storage space creation time query response time updates cubes 
data cube operator performs computation aggregate functions possible combinations grouping attributes :10.1.1.120.4505
inherent difficulty cube operator size computing storing 
number possible group bys increases exponentially number cube dimensions naive store cube behaves similar way 
authors provided useful hints cube computation including parallelism mapping string dimension types integers reducing storage :10.1.1.120.4505
problem exacerbated fact new applications include increasing number dimensions explosion size cube real problem 
methods proposed literature try deal space problem precomputing subset possible group bys gup bpt estimating values group bys approximation gm sfb agp online aggregation techniques :10.1.1.49.8797
defines dwarf highly compressed structure computing storing querying data cubes 
dwarf solves storage space problem identifying prefix suffix redundancies structure cube factor ing store 
name comes dwarf stars large condensed mass occupy small space 
dense mass ton cm prefix redundancy easily understood considering sample cube dimensions value dimension appears group bys ab ac abc possibly times group 
example fact table shown table keep referring value appear total times corresponding cube specifically group bys happens prefixes size greater note pair values appear ab group abc group 
dwarf recognizes kind redundancy stores unique prefix just 
store customer product price table fact table cube sales suffix redundancy occurs group bys share common suffix abc bc 
example consider value dimension appears fact table single value ai dimension example exists table value appears value 
group bys ai bj value value dimension happens second group aggregates tuples fact table contain combinations value dimension just value ai generally set values suffix redundancy multiplicative effect 
suffix redundancies apparent cases correlated dimension values 
correlations real datasets weather dataset experiments 
suffix redundancy identified construction dwarf cube eliminated coalescing space 
dwarf practical automatic discovery prefix suffix redundancies requiring knowledge value distributions having sophisticated sampling techniques 
dwarf storage savings spectacular dense sparse cubes 
show cases dense cubes size dwarf cube size fact table 
dense cubes savings entirely prefix redundancies cubes get sparser savings suffix redundancy elimination increases quickly dominant factor total savings 
equally significant reduction computation cost 
redundant suffix identified prior computation results substantial computational savings creation 
furthermore condensed size dwarf cube time needed query update reduced 
inherently dwarf structure provides index mechanism needs additional indexing querying 
self sufficient sense need access fact table answering views stored 
additional optimization implemented avoid precomputation certain group bys calculated fly fewer constant amount tuples 
information needed calculate group bys stored inside dwarf structure compact clustered way 
modifying value constant user able trade query performance storage space creation time 
optimization motivated iceberg cubes br may enabled user limited amount disk space limited time computing dwarf available 
demonstrate storage savings provided dwarf fraction savings attributed prefix suffix redundancies compare dwarf cube sizes binary storage footprint bsf views cube stored unindexed binary summary tables 
efficient feasible store cube sub cubes provides understood point useful comparing different stores 
compared dwarf cubes cubetrees shown kr exhibit better query response time better update performance storage indexed relations 
experiments show dwarfs consistently outperform cubetrees counts storage space creation time query response time updates full cubes 
dwarf cubes achieve comparable update performance partial cubes stored cubetrees having size dwarf cubes 
byte byte dwarf stores materialized views corresponding structures answer wider class queries footprint 
data sets compute dwarf cubes 
cube dimensions having cardinality fact table containing tuples 
bsf cube tb 
eliminating prefix redundancy resulted dwarf cube tb original size 
eliminating suffix redundancy reduced size dwarf cube just mb reduction bsf 
jim gray spirit pushing idea limits decided create dimensions bsf equal 
dwarf cube just gb took minutes create 
storage reduction ratio 
rest organized follows section presents dwarf structure formal properties 
sections explain dwarf cubes constructed queried updated 
section contains performance analysis 
related section reported section 
dwarf structure describe dwarf structure example 
define properties dwarf formally 
dwarf example shows dwarf cube fact table shown table full cube aggregate function sum 
nodes numbered order creation 
height dwarf equal number dimensions mapped levels shown 
root node contains cells form key pointer distinct value dimension 
pointer cell points node containing distinct values dimension associated cell key 
node pointed cell cells inside dominated cell 
example cell root dominates node containing keys 
non leaf node special cell shown small gray area right node holding pointer corresponding values node 
path root leaf corresponds instance group store customer product leads cell stores aggregate instance 
path cells open cell 
example leads cell corresponds sum prices paid customer product store 
leaf level cell form key aggregate holds aggregate tuples match path root 
leaf node cell stores aggregates cells entire node 
leads total prices group 
reader observe paths values extracted processing just tuple fact table lead cell stored different nodes bsf sizes size dwarf cubes enabling suffix coalescing accurately measured constructing dwarf cube traversing appropriately 
sizes dwarf cubes stated correspond full dwarf cubes dwarf cube table store dimension customer dimension product dimension introduce suffix redundancies 
coalescing nodes avoid redundancies 
nodes pointed pointer coalesced nodes 
properties dwarf dwarf previous algorithms proposed cube computation require dimension attributes integer type mapping types strings integers required methods require packing domain values zero cardinality dimension 
group dimensional cube expressed sequence values dimension refer coordinates group multidimensional space 
sql queries coordinates typically specified clause 
group th coordinate value cube th dimension left open correspond pseudo value 
dwarf data structure properties 
directed acyclic graph dag just root node exactly levels number cube dimensions 

nodes th level leaf nodes contain cells form key 

nodes levels th level non leaf nodes contain cells form key pointer 
cell non leaf node level points node level dominates 
dominated node node parent node 

node contains special cell corresponds cell pseudo value key 
cell contains pointer non leaf node leaf node 

cells belonging nodes level structure contain keys values cube th dimension 
cells node contain key value 

cell ci th level structure corresponds sequence si keys path root cell key 
sequence corresponds group dimensions unspecified 
group bys having sequence si prefix correspond cells descendants ci dwarf structure 
group bys common prefix stored exactly structure 

nodes leaf non leaf generate identical nodes cells structure storage coalesced copy stored 
case coalesced node reachable paths root share common suffix 
example node bottom product level cell node corresponds sequences share common suffix node coalesced node node descendant coalesced node reached multiple paths root 
traversal dwarf structure follows path length starting root leaf node 
form node val node val val meaning th key path value val th dimension pseudo value 
dwarf structure constitutes efficient indexing method requires additional external indexing 
define terms help description algorithms 
dwarf node defined node dwarfs nodes dominated cells dwarf node dominated cell called sub dwarf leaf node cells dominate nodes dwarf leaf node node 
number cells node nj cell ci dominates called branching factor ci 
sequence keys followed path root node level dwarf structure called leading prefix leading prefix contains coordinate called primary leading prefix content cell ci belonging node ci leaf node sub dwarf ci non leaf node 
evidence structural redundancy prefix redundancy path root dwarf structure leaf corresponds instance group 
dwarf creates minimum number cells accommodate paths 
cube level structure store maximum number cells required equal cardinality store dimension plus cell 
second level customer cube completely dense need number cells equal product 
cubes sparse need create cells 
case dense cubes storage required hold cells structure including cells comparable required hold fact table 
dwarf saturated cube dimensions cardinality dimension tree constant branching factor equal 
number leaf nodes non leaf nodes required represent tree nodes lea nodes non leaf node contains non leaf cells pointer leaf node contains leaf cells gates 
size non leaf cell units key pointer size leaf cell units aggregates key 
fact table saturated cube tuples 
size tuple ratio size dwarf fact table approximated ratio example full dense cube dimension cardinality dimension aggregate ratio dwarf representation needs storage fact table requires 
proves fact table certainly cube contains redundancy structure 
discussion serves demonstrate dwarf provides space savings case sparse cubes 
course case molap representation cube provide larger cube compression 
molap methods storing cube require knowledge discovery dense areas cube perform sparse high dimensional cubes 
hand dwarf provides automatic method highly compressing cube independently characteristics distribution density dimensionality 
data 
suffix redundancy dwarf store cells correspond empty regions cube node contains cell key value plus pointer cell 
minimum branching factor maximum value branching factor cell level card card cardinality dimension 
branching factor decreases descend lower levels structure 
approximation branching factor level structure assuming uniform distribution values dimension tuples fact table branch min card max number tuples fact table 
cube dense branching factor equal th level lowest number 
example sparse cube cardinality dimensions dimensions tuples branching factor reach value level log 
means sparse cubes branching factor close root levels deteriorates 
branching factor guarantees see section suffix redundancy exists level 
smaller value larger benefits eliminating suffix redundancy storage larger dwarfs avoided 
correlated areas fact table coalesced 
assume example set certain customers cs shop specific store views store customer customer share suffix corresponds set cs 
table customers shop store see nodes dwarf node coalesced node 
constructing dwarf cubes dwarf construction governed processes prefix expansion suffix coalescing 
non interleaved pass process construct cube prefix redundancy eliminated check nodes coalesced 
approach require enormous amount temporary space size leaf nodes larger size non leaf nodes time due size intermediate cube 
imperative able determine node coalesced node creating 
imposing certain order creation nodes suffix coalescing prefix expansion performed time requiring passes structure 
algorithm constructing dwarf cube terms frequently algorithm description 
node called ancestor iff descendant node 
construction dwarf cube node level dwarf structure closed exist unprocessed tuple fact table contains prefix equal primary leading prefix existing node dwarf structure closed considered open 
construction dwarf cube preceded single sort fact table cube dimensions primary key collating dimensions specific order 
choice dimensions ordering effect total size dwarf cube 
dimensions higher cardinalities beneficial placed higher levels dwarf cube 
cause branching factor decrease faster coalescing happen higher levels structure 
ordering user specified automatically chosen dwarf performing scan sample fact table collecting statistics cardinalities dimensions 
algorithm dwarf construction algorithm algorithm 
construction requires just single sequential scan sorted fact table 
tuple fact table corresponding nodes cells created levels dwarf structure 
scan continues tuples common prefixes tuple read 
create necessary cells accommodate new key values progress fact table 
step algorithm common prefix current previous tuple computed 
consider path need follow store aggregates current tuple 
nodes size common prefix path node created previous tuple 
dimensional cube new nodes need created expanding structure downwards node name prefix expansion equal number nodes closed 
leaf node closed cell produced aggregating contents aggregate values cells node 
non leaf node closed cell created algorithm called create sub dwarf cell 
example consider fact table table corresponding dwarf cube 
nodes numbered order creation 
tuple creates nodes nodes dimensions store customer product inserts cell node 
second tuple read shares prefix previous tuple 
means cell needs inserted node node node containing node closed 
cell node created aggregation trivial cell exists node 
third tuple read contains common prefix second tuple 
create cell node call node create sub dwarf node cell 
algorithm algorithm input sorted fact table number dimensions create nodes cells tuple tuple tuple fact table tuples exist unprocessed current tuple extract tuple sorted fact table common prefix current tuple tuple new closed nodes exist write special cell leaf node tuple stored rest new closed nodes starting parent node moving bottom create cells call algorithm create necessary nodes cells current tuple new nodes created tuple current tuple write special cell leaf node tuple stored open nodes starting parent node moving bottom create cells call algorithm algorithm suffix coalescing algorithm suffix coalescing creates sub dwarfs cell node 
suffix coalescing tries identify identical dwarfs coalesce storage 
dwarfs identical constructed subset fact table tuples 
prefix expansion create tree suffix coalescing 
algorithm algorithm 
requires input set dwarfs merges construct resulting dwarf 
algorithm helping function aggregates values passed parameter 
algorithm algorithm input set dwarfs dwarf return dwarf coalescing happens unprocessed cells exist top nodes find unprocessed key minimum value top nodes set cells top nodes having keys values equal level structure write cell write cell sub dwarfs create cell node aggregation calling return position disk resulting dwarf starts recursive algorithm tries detect stage sub dwarf resulting dwarf coalesced sub dwarf 
just dwarf coalescing happens immediately result merging dwarf obviously dwarf 
algorithm repeatedly locates cells top nodes smallest key processed cell resulting dwarf key needs created content sub dwarf produced merging contents cells set 
cases 
leaf node call function produce aggregate values resulting cell 

coalescing happen level 
call recursively create dwarf current cell check parts structure coalesced level lower 
cell resulting node created aggregating values node cells leaf node calling sub dwarfs node cells input 
example consider dwarf cube 
move step algorithm tuples table processed cell node calculated 
called create sub dwarf cell node 
sub dwarf exists points immediate coalescing happens case line cell points node points 
sub dwarf cell node created 
cell added resulting node sub dwarf created recursively calling input dwarf node top node 
coalescing happen 
similarly cells added resulting node coalescing happen level cases just contains keys 
cell node created line 
key included nodes pointed nodes leaf node aggregate values cells line 
memory requirements algorithm major requirements needs remember previously read tuple 
algorithm priority queue locate line cells minimum key contains step key top node dwarf 
worst case descend levels structure creating cell root node memory requirements priority queue memory requirements algorithm worst case fully dense dwarf cube equal size cell 
cube sparse number cells kept main memory smaller sum dimensions cardinalities exact number depends branching factor level structure 
incremental updates ability refresh data modern data warehouse environment currently important 
data stored increases complexity possibility incrementally updating data warehouse data mart essential 
recompute strategy keep pace needs modern business 
common strategy semi periodic bulk updates warehouse specific intervals date information essential 
priority queue 
details omitted space constraints 
section describe dwarf structure incrementally updated set delta tuples data sources earlier version dwarf cube 
assume delta updates smaller size compared information stored 
bulk incremental technique merges kr stored aggregates new updates stores result new dwarf preferable place method 
incremental update procedure starts root structure recursively updates underlying nodes finishes incremental update node corresponds special cell 
cross checking keys stored cells node attributes delta tuples procedure skips cells need updated expands nodes accommodate new cells new attribute values overflow pointers recursively updates sub dwarfs affected delta tuples 
delta information compared information stored number cells skipped larger number cells need updated 
case requires special attention descending structure reach coalesced node different paths 
get coalesced node check coalesced path valid insertion tuples caused coalesced pointer invalid 
case corresponding re evaluated new nodes written different area disk 
important realize invalid coalesced pointer mean entire needs copied 
coalescing nodes old dwarf happen just levels structure small fraction aggregate values calculated influenced update 
important observation frequent incremental update operations slowly deteriorate original clustering dwarf structure mainly overflow nodes created 
expected effect encountered dynamic data structures result online modifications 
dwarf targeted data warehousing applications typically perform updates scheduled periodic intervals envision running process background periodically reorganizing dwarf transferring new file clustering restored 
performance issues dwarf cubes query execution point query simple traversal dwarf structure root leaf 
level search cell having key th coordinate value query descend level 
th coordinate value follow pointer cell 
point query fast simply involves exactly node visits number dimensions 
range queries differ point queries contain dimension range values 
range specified th coordinate key satisfying specified range recursively descend corresponding sub dwarf depth manner 
result queries dwarf structure trivial memory requirements pointer level structure 
algorithms constructing dwarf cube certain views may span large areas disk 
example dimensional cube dimensions view abcd clustered views containing dimension views ab ac ad abc abd acd interleaved disk area view abcd occupies 
query multiple large ranges views fetch nodes contain data views 
reason deviate construction algorithm order cluster dwarf cube efficiently 
described section 
query performance dwarf remains far ahead closest competitor shown experiments section 
clustering dwarf cubes abc ac ab bc data cube lattice dimensions algorithms described section general principles constructing dwarf structures 
lot room improvement far clustering structure concerned 
mentioned algorithms cluster views cube accessing view requires accessing nodes probably different disk pages far apart 
section describe dwarf structure created clustered manner 
typically clustered version dwarfs decreased query response time real datasets factor 
lattice representation data cube represent computational dependencies group bys cube :10.1.1.41.1205
ex ample dimensions illustrated 
node lattice corresponds group view node dimensions 
example node ab represents group ab view 
computational dependencies group bys represented lattice directed edges 
example group computed ab group group abc compute group 
show dependencies adjacent group bys refer transitive closure lattice 
table illustrate ordering views dimensional cube 
second column table contains binary representation view bits cube dimensions 
aggregated dimension corresponding bit set true 
example view ab corresponds dimension aggregated 
views sorted increasing order binary representation 
ordering property view computed candidate ancestor views vi potential suffix coalescing computed 
note binary representation vi derived binary representation resetting true bit false 
essentially means binary representation vi binary representation precedes sorted ordering 
example table view ancestors ab ac 
demonstrates processing tree example table 
order chosen ancestor vi biggest common prefix view binary rep parents coalesce abc abc ab abc ac ac abc ab ac bc abc ab bc ac bc ab bc table view ordering example processing tree removing recursion algorithms section lines algorithm line algorithm able create view cube 
specifically detailed view example abc created view created algorithm 
easy iterate views cube described ordering create 
procedure clusters nodes view resulting dwarf structure behaves better 
example consider structure 
structure created algorithms section nodes written order 
note node belongs view store product written nodes belong view store customer product destroying clustering views 
procedure described creates nodes order maintaining clustering view 
table describes detail procedure 
optimizing view iteration view binary rep nodes store customer product create store customer close store product create coalesce store close customer product create coalesce customer product create close table example creating clustered dwarf implementation hybrid algorithm need iterate views 
hybrid algorithm takes advantage situation encountered creating view store customer view store described table 
iterating views create new nodes closed nodes writing cell 
situation evident sparse cubes usually cubes high dimensionalities 
assume dimensional cube tuples dimension cardinality 
assume data values uniformly distributed 
dwarf representation view abcde consists levels 
level node cells 
second level cell node cells 
third level assumed data uniform tuples nodes consist cell 
close corresponding cells right away 
avoid iterating views abcd abce abc 
coarse grained dwarfs dwarf structure achieves remarkable compression ratios calculating entire cube dwarf size cases sparse cubes quite larger fact table 
trade query performance storage space granularity parameter 
level dwarf structure dwarf construction number tuples contributes beneath currently constructed node level compute cells 
tuples contributing coarse grained area node stored tree fashion exploiting prefix redundancy plain tuples useful number dimensions larger avoid pointers overhead 
notice tuples need store coordinates path collapsed area gives missing information 
query accessing coarse grained area node require aggregate tuples produce desired result 
user modify parameter get dwarf structure needs 
experiments performance analysis performed experiments different datasets sizes validate storage performance tations 
tests section run single mhz celeron processor running linux mb ram 
gb disk rotating able write mb sec read mb sec 
purposely chose low amount ram memory allow effect disk evident demonstrate performance dwarf suffer limited memory resources available 
implementation reads binary representation fact table values mapped integer data bytes 
specified datasets contained measure attribute aggregate function experiments sum function 
reported times actual times contain cpu times total construction dwarf cubes including initial sorting fact table 
experiments compared dwarf cubetrees far storage space creation time queries update performance concerned 
kr cubetrees shown exhibit times faster query performance compared indexed relations half storage commercial relational system requires times faster update performance 
system shown outperform cubetrees far concluded challenging test dwarf 
cube construction prefix redundancy vs suffix coalescing experiment explore benefits eliminating prefix redundancy suffix coalescing com puting cube operator 
set experiments binary storage footprint bsf means comparison 
bsf representation models storage required store views cube unindexed binary relations 
representation br estimate time needed write output cube 
uniform dims bsf dwarf prefix dwarf mb time sec dwarf mb time sec mb mb gb gb gb gb tb tb pb pb table storage creation time vs dimensions table show storage compute time dwarf cubes number dims dimensions range 
fact table contained tuples dimension values uniformly distributed cardinality followed self similar distribution cardinality 
impose correlation dimensions 
bsf column shows estimate total size cube views stored unindexed relational tables 
dwarf prefix column shows storage dwarf suffix coalescing suffix redundancy elimination 
measure bsf size dwarf prefix size generated dwarf suffix coalescing turned traversed dwarf structure appropriately 
counted bsf dwarf prefix storage distributions results far savings concerned identical slightly smaller savings distribution just uniform sizes 
remaining columns show dwarf store footprint time construct distributions 
shows compression bsf size number dimensions storage savings bsf dwarf prefix dwarf uniform dwarf dimensions dwarf compression ratio bsf log scale vs dimensions increases 
observe cube sparser savings increase exponentially due suffix coalescing 
observe elimination prefix redundancy saves great deal suffix redundancy clearly dominant factor performance 
creation time proportional dwarf size 
uniform distribution posts highest savings 
effect skew cube tuples fact table contribute small part cube leaving parts empty 
denser areas benefit prefix elimination smaller sparser areas suffix redundancy eliminate fewer tuples exist 
table gives dwarf storage computation time dimensional cube number tuples fact table varies 
cardinalities dimension 
distribution dimension values uniform self similar 
set experiments shows store size computation time grow linearly size fact table doubling input tuples results little twice construction time storage required 
comparison full cubetrees uniform tuples dwarf mb time sec dwarf mb time sec table storage time requirements vs tuples experiment created cubes fewer dimensions order compare performance dwarf cubetrees 
created full cubes number dimensions ranging 
case fact table contained tuples created uniform self similar distribution 
show space required dwarf cubetrees store entire cube 
shows corresponding construction times 
figures see storage bytes cubetrees scale far storage space concerned number dimensions 
contrary dwarf requires space store amount information 
dwarf requires significantly time build cube 
cubetrees methods calculate entire cube perform multiple sorting operations data dwarf avoids computing large parts cube suffix coalescing identifies parts computed 
cubetrees uniform cubetrees self similar dwarf uniform dwarf self similar dimensions creation time sec cubetrees uniform cubetrees self similar dwarf uniform dwarf self similar dimensions storage space vs dims construction time vs dims comparison reduced cubetrees experiment compares construction time dwarf cubetrees cubetrees size limited dwarf structure 
refer type cubetrees reduced cubetrees 
useful examine cases high dimensional data cubetrees competitive structures may fit available disk space 
cubetrees store views cube operator decision views materialize 
pbs algorithm provides fast algorithm decide views materialize storage constraint time guaranteeing query performance 
pbs algorithm selects smallest views size typically views performed aggregation 
addition stored reduced cubetrees fact table order able answer queries queries section views materialized answered materialized views 
dataset dims tuples size mb cubetrees time sec dwarf time sec pbs views forest table storage creation time real datasets table gives dwarf reduced cubetrees storage creation times real datasets 
cubetrees created having size corresponding dwarfs 
construction times reduced cubetrees include running time pbs algorithm 
table shows number views contained reduced cubetrees 
real dataset contains weather conditions various weather stations land september 
dataset created sets input data contained dimensions dimensions 
second real data set contains forest cover type data bla includes cartographic variable estimate forest cover type land areas 
data sets attributes skewed dimensions substantial correlation 
reduced cubetrees calculate significantly fewer views dwarf dwarf cubes signifi cantly faster creation weather datasets took amount time cubetrees forest dataset 
important observation dwarf structure weather dataset dimensions smaller faster compute dwarf forest data dimensions 
top dimensions weather data highly correlated suffix coalescing happened top levels dwarf structure cases providing substantial space computational savings 
query performance section study query performance dwarf compared full reduced cubetrees 
give detailed analysis range queries applied different levels dwarf structure treated clustered unclustered structure 
dwarfs vs full cubetrees created workloads queries queried cubes created previous experiment full cubes dimensions tuples 
description workloads table 
probabilities range workload queries max min table workload characteristics dwarfs vs full cubetrees query experiment query workloads tables similar table give description notation 
important thing consider query workloads real data synthetic data produced uniform distribution values specified queries point values endpoints ranges selected uniform distribution 
self similar distribution produce values 
suitable suspect user typically interested querying denser areas cube 
probability new query related previous query 
olap applications users typically perform query execute series roll drill queries 
query generator produces query produces roll query probability drill query probability new query probability 
example workload creates new unrelated queries workload creates roll drill probability 
probability dimension selected participate new query 
example dimensional cube probability equal new queries include dimensions average 
probability specify just single value dimension participating query 
probability specify range values dimension 
way control selective queries value produces point queries value produces queries ranges dimension participating query 
experiments selected low values parameter high value result queries returning tuples usually 
range range dimension uniformly selected cover specified percentage cardinality response time sec dimension 
example dimension values ranging value maximum range force range dimension limited values 
range contains value 
cubetrees cubetrees dwarf dwarf dimensions response time sec cubetrees cubetrees dwarf dwarf dimensions query performance uniform data query performance self similar data returning experiment results workloads table cubes created previous exper shown figures 
dwarf outperforms cubetrees cases small dimensionality dwarf cubes orders magnitude faster 
main advantage dwarf cubes condensed storage allows keep main memory lot information cubetrees 
see dwarf performs better workload roll drill queries common path dwarf structure previously executed query disk pages corresponding common area main memory 
example dimensional cases uniform dataset response time drops seconds roll drill operations reduction self similar case improvement larger seconds 
reduction response time 
dwarfs vs reduced cubetrees set experiments compare query performance dwarfs reduced cubetrees 
datasets experiment real datasets described section forest 
cubetrees case contain views cube need explain answered queries non materialized views 
query non materialized view issued optimizer picks best materialized view answer share common prefix uses hash approach evaluate query 
shares common prefix result calculated fly advantage common sort order 
second case faster hash table 
optimizer needs estimates size views case exact sizes issuing appropriate queries dwarf structure 
real dataset created workloads queries characteristics table 
dims column denotes average number dimensions specified query 
notice workloads similar workloads respectively contain roll drill queries 
workload queries dims range max table workload characteristics dwarfs vs reduced cubetrees query experiment query performance dwarf reduced cubetrees table 
dwarf order magnitude faster reduced cubetrees weather datasets times faster forest dataset 
dwarf performs significantly better weather datasets due correlation attributes datasets 
coalescing happened top levels structure large fraction nodes top levels cached improving performance dramatically 
important observation dwarfs faster workload contains roll drill queries 
example workloads forest dataset dwarf faster 
notice type workloads limitation average number dimensions specified query favors cubetrees typically store views dimensions pbs algorithm 
workloads queries containing dimensions average performance cubetrees significantly worse 
reduced cubetrees dwarf workload forest forest evaluating ranges dwarf cubes table query times seconds queries real datasets initial concerns designing dwarf ensure query performance suffer queries large ranges top dimensions structure 
dimensions higher levels dwarf structure higher cardinalities large range example range containing values expensive large number paths followed 
experiment study query behavior dwarf queries ranges different dimensions issued 
created dimensional datasets having fact table tuples 
datasets dimension cardinality 
datasets cardinalities dimensions 
underlying data datasets produced uniform distribution datasets self similar distribution 
sizes dwarf cubes datasets mb datasets corresponding sizes mb 
decided create workloads queries consecutive dimensions contain ranges 
example name cube dimensions workload contain ranges dimensions second workload dimensions 
considered ranges dimensions 
workload contained queries 
set dimensions queried workload issued point query remaining dimensions probability value selected 
having point queries dimensions allowed queries hit different views ranged dimensions remained small probability point query dimension happens allowed multiple tuples returned query 
range dimension contained dimension values 
results datasets table datasets table 
view effect clustering dwarf cubes query times achieved dwarf original algorithms improving clustering way described section 
refer corresponding structure unclustered dwarfs 
comparison reasons included corresponding query times full cubetrees paragraphs focus discussion query performance dwarf cubes influenced location ranges 
behavior cubetrees explained kr 
ranged cubetrees dwarf unclustered result cubetrees dwarf unclustered result dims sec sec dwarf sec tuples sec sec dwarf sec tuples table time seconds queries datasets constant cardinality table uniform workload clustered dwarf observe query performance decreases ranges move lower dimensions 
case query values point dimensions ranged ones randomly hit different nodes upper levels structure 
effect consecutive queries follow paths vastly different locations dwarf file 
dwarf fit main memory larger area targeted queries workload swapping takes place fetch needed disk pages main memory worse query performance 
performance degrades queries move lower levels larger area dwarf file targeted queries caching effective 
need clarify single query ranges top dimensions expensive single query ranges lower dimensions 
consecutive queries involving ranges top levels structure benefit caching queries top level nodes ranges applied main memory 
kind queries exhibited better performance experiment 
behavior observed unclustered dwarf exception ranges 
case benefits reduced query cost outweigh cache effects resulting better performance 
unclustered dwarf performs worse clustered better compared cubetrees 
reason worse behavior unclustered dwarf mentioned interleaving views 
result disk pages fetched contain useless information query pages need fetched compared clustered dwarf 
concepts help explain behavior dwarf structure wrapped queries dimensions minimize effect online aggregation 
ranges top dimensions benefit cache performance increase query cost 
tradeoff determines performance 
similar behavior observed workload 
case queries address denser areas compared uniform case returned tuples performance demonstrate 
dwarf performs similarly case 
ranged cubetrees dwarf unclustered result cubetrees dwarf unclustered result dims sec sec dwarf sec tuples sec sec dwarf sec tuples table time seconds queries datasets varying cardinalities table presents query performance dwarf datasets 
extra parameter dominating considered different cardinalities range top dimension contains values range dimension 
effect different cardinalities evident workload 
happens range typically satisfied lot values uniform case recall values exist space 
evident number result tuples query performance improves queries applied dimensions smaller cardinalities 
basic concepts described table apply 
coarse grained dwarfs described section limit space dwarf occupies subsequently computation time appropriately setting minimum granularity parameter 
set experiments investigate construction time space query performance dwarfs influenced increasing threshold 
created dwarf structure dimension cubes datasets see previous experiment different values parameter issued queries resulting dwarf cubes 
description queries case rotated dimensions 
table presents creation times required storage time required execute queries dwarf 
uniform distribution distribution space mb construction sec queries sec space mb construction sec queries sec table performance measurements increasing increase value space dwarf occupies decreases time query performance degrades 
exception uniform distribution value reduction space improved query performance despite fact aggregations needed done fly 
reason coarse grained areas value fit pages faster fetch aggregation fly fetching pages get precomputed aggregate 
table pay construct time higher space savings 
value results storage savings speedup computation times 
various experiments concluded value typically provides significant storage time savings small degradation query performance 
updates section experimental results evaluate update performance dwarfs compared full reduced cubetrees 
synthetic dataset experiment dimension dataset 
originally constructed dwarf full cubetrees reduced cubetrees tuples proceeded add increments reach total tuples 
reduced cubetrees selected size dwarf cube constructed tuples 
table shows update time structures 
clearly see full cubetrees require significantly time size larger dwarf structure 
dwarf performs better compared incremental updates reduced cubetrees 
example incremental update reduced cubetrees took time dwarf 
update structures data difference update times smaller eventually dwarf expensive update incrementally 
main reason degradation dwarf clustering nodes expanded updates overflow nodes added structure 
demonstrate ran final dwarf structure increments applied set queries previous experiment 
dwarf required seconds time seconds reorganized dwarf 
notice cubetrees specification update algorithm kr kept optimized new storage writing new aggregates 
results having twice space requirements dwarf updates old structure input update process 
technique implemented dwarf 
increments reorganize dwarf structure background process writes new dwarf new storage restoring clustering 
example reorganize dwarf increments update time increment seconds faster corresponding update cubetrees 
benchmark data tested update performance dwarf benchmark cou density parameter set 
benchmark contains dataset cardinalities measure attributes 
mapped string data fact table integers randomly permuted fact table selected tuples tuples initially load cubetrees full reduced dwarf applied successive increments 
table shows results reduced cubetrees dwarf 
full cubetrees expensive update reduced cubetrees views update included results 
dwarf surpassed reduced cubetrees incremental updates 
interesting notice update time dwarf decreased tuples inserted 
mainly action full cubetrees time sec space mb dwarf time sec space mb reduced cubetrees time sec create update update update update update update update update update update table update performance synthetic dataset dataset corresponded dense cube number coalesced tuples small 
updating coalesced tuples time consuming part update operation dwarf 
tuples inserted fewer coalesced links existed update performance improved 
related dwarf reduced cubetrees action time sec space mb sec time create update update update update update update update update update update table update performance benchmark goal algorithm computes data cube take advantage commonalities different group bys 
techniques proposed include sharing partitions sorts partial sorts intermediate results group bys common attributes 
algorithm introduced aad sag 
idea convert cube lattice see processing tree compute group smallest parent 
overlap algorithm proposed overlaps computation group bys partially matching sort orders order reduce number sorting steps required 
example overlap uses sorted abc group order produce ac sort order 
sorting independently partitions abc main memory algorithm proposed tuples kept memory dimension array number dimensions :10.1.1.120.4505
array algorithm proposed :10.1.1.50.6608
algorithm uses memory arrays store partitions avoid sorting 
chunks dimension array dimension sub array corresponds page 
array stored units chunks provide clustering 
sparse chunks compressed 
algorithms proposed rs designed target sparse cubes 
partitions data units fit main memory called unit order compute cube 
authors observe buffering intermediate results requires memory sparse cubes choose buffer partitioned units repeated memory sorts 
picks minimum number sorts required compute cube corresponds memory unit 
bottom cube buc algorithm described br designed compute sparse iceberg cubes 
general iceberg cube problem compute group partitions combination grouping tributes satisfy aggregate selection condition 
iceberg cubes compute iceberg queries 
iceberg cubes buc stores partitions group value produced aggregating minsup tuples fact table 
parameter minsup called minimum support 
sparse iceberg cubes smaller full cubes minimum support pruning direct effect number views materialized 
assume cube dimensions cardinality fact table tuples uniformly distributed 
minimum support materializes views dimensions 
views contain group bys partitions minimum support 
performed approximating data cubes various forms compression wavelets multivariate polynomials bs sampling gm agp data probability density distributions sfb 
methods substantially reduce size cube store values group bys approximate providing accurate results 
cubetrees kr group bys mapped orthogonal hyperplanes multidimensional index 
common sort orders cluster points group continuous disk space 
packing algorithm guarantees full page utilization resulting space savings indexed relations 
updates handled merge packing algorithm scans old aggregates merges update increment sorted compatible order 
js cube forests proposed storing data cube 
cube forests similar dwarfs exploit prefix redundancy storing cube 
differ dwarf structure forest trees construction algorithms indexing methods cube forests additional trees paths cube tree template 
fh idea statistics tree st introduced 
tree prefix redundancy partially exploited 
unique suffixes stored just tree contained possible paths paths corresponding tuples inserted making inappropriate sparse datasets 
construction algorithm st exploit data locality clustering resulting inefficient cube computation 
notion base single tuple similar coalesced tuple previously 
algorithms described discovering tuples storage coalesced guarantees find tuples expensive computationally bu bst bst faster discover fewer coalesced tuples 
compared method provides efficient method automatic discovery coalesced tuples indexing produced cube done methods cube computation listed 
detailed comparison published submission 
dwarf highly compressed structure computing storing querying data cubes 
dwarf identifies prefix suffix structural redundancies factors coalescing storage 
dwarf structure shows suffix redundancy dominant factor sparse cubes elimination highest return storage computation time 
dwarf practical generated single pass data requires deep knowledge underlying value distributions 
scalable higher dimensions redundancy harvest 
dwarf store full cube possible compact size alternatively precompute aggregates computation costly done fly minimum granularity metric 
great reduction terms storage space dwarf structure exhibits positive effects terms query update performance 
dwarf structure plays double role storage indexing mechanism high dimension data 
roll drill queries benefit dwarf structure due common paths exploited caching 
terms update speed dwarf far outperforms closest competitor storing full data cube performance comparable competitor reduced storing partial cube size dwarf 
aad agarwal agrawal deshpande gupta naughton ramakrishnan sarawagi 
computation multidimensional aggregates 
proc 
nd vldb conf pages 
agp acharya gibbons poosala 
congressional samples approximate answering group queries 
proceedings acm sigmod international conference management data pages dallas texas 
bla jock 
forest dataset 
ftp ftp ics uci edu pub machine learning databases covtype 
bpt paraboschi 
materialized view selection multidimensional database 
proc 
vldb conf pages athens greece august 
br beyer ramakrishnan 
bottom computation sparse iceberg cubes 
proceed ings acm sigmod international conference management data pages pennsylvania june 
bs barbara sullivan 
space efficient way support approximate multidimensional databases 
technical report tr george mason university 
barclay gray 
spatial data warehouse 
cou olap council 
benchmark 
www org research htm 
deshpande agarwal naughton ramakrishnan 
computation multidimensional aggregates 
technical report university wisconsin madison 
fh fu joachim hammer 
new algorithm improving performance ad hoc olap queries 

fang shivakumar garcia molina motwani ullman 
computing iceberg queries efficiently 
proc 
th vldb conf pages august 
gray bosworth layman pirahesh :10.1.1.120.4505
data cube relational aggregation operator generalizing group cross tab sub totals 
proc 
th icde pages new orleans february 
ieee 
gupta harinarayan rajaraman ullman 
index selection olap 
proc 
icde conf pages uk april 
gm gibbons matias 
new sampling summary statistics improving approximate query answers 
proceedings acm sigmod international conference management data pages seattle washington june 
gup gupta 
selections views materialize data warehouse 
proc 
icdt conf pages delphi january 
hellerstein haas wang :10.1.1.49.8797
online aggregation 
proceedings acm sigmod conference pages tucson arizona may 
harinarayan rajaraman ullman :10.1.1.41.1205
implementing data cubes efficiently 
proc 
acm sigmod pages montreal canada june 
hahn warren london 
edited synoptic cloud reports ships land stations globe 
esd ornl gov ndp html 
js johnson shasha 
approaches index design cube forests 
data engineering bulletin march 
kr kotidis roussopoulos 
alternative storage organization rolap aggregate views cubetrees 
proceedings acm sigmod international conference management data pages seattle washington june 
roussopoulos kotidis roussopoulos 
organization bulk incremental updates data cube 
proceedings acm sigmod international conference manage ment data pages tucson arizona may 
rs ross 
fast computation sparse 
proc 
rd vldb conf pages athens greece 
nick roussopoulos john yannis kotidis 
dwarf structure creating storing querying highly compressed data cubes 
application patent office submitted june 
sag sarawagi agrawal gupta 
computing data cube 
technical report rj ibm almaden research center san jose ca 
shukla deshpande naughton 
materialized view selection multidimensional datasets 
proceedings th vldb conference pages new york city new york august 
sfb shanmugasundaram fayyad bradley 
compressed data cubes olap aggregate query approximation continuous dimensions 
proc 
intl 
conf 
knowledge discovery data mining kdd 
vitter wang iyer 
data cube approximation histograms wavelets 
proc 
th intl 
conf 
information knowledge management cikm 
wei wang hongjun lu feng jeffrey xu yu 
condensed cube effective approach reducing data cube size 
icde 
zhao deshpande naughton 
array algorithm simultaneous sional aggregates 
proc 
acm sigmod conf pages 

