static scheduling techniques retargeting high speed compiled simulators embedded processors machine description gunnar braun andreas hoffmann achim heinrich meyr aachen university technology rwth institute integrated signal processing systems aachen germany braun hoffmann meyr iss rwth aachen de instruction set simulators indispensable tools design programmable architectures software development 
due constantly increasing processor complexity frequent demand cycle accurate models simulators slow 
principle compiled simulation addresses shortcoming 
compiled simulators priori accelerate simulation highest achieved employing static scheduling techniques 
past statically scheduled simulators implemented specific dsp architectures 
approach discusses application static scheduling techniques retargetable simulation tools processor description language lisa 
principles implementation issues discussed results selected processor architectures 
categories subject descriptors simulation modeling simulation support systems simulation modeling model validation analysis programming languages design languages lisa general modeling computer architecture general terms design languages performance keywords compiled simulation static scheduling retargetable simulation instruction set architectures 
architectural simulators essential tools design programmable architectures software development 
partic permission digital hard copies part personal classroom granted fee provided copies distributed pro commercial advantage copies bear notice full citation rst page 
copy republish post servers redistribute lists requires prior speci permission fee 
isss october montr qu bec canada 
copyright acm 
processor architectures targeting market digital communications increasingly complex simulators 
complexity significantly improved performance processors opposite effect simulator speed 
simulators complex processor models run slowly impairs usefulness evaluating architecture implementations developing software 
compiled simulators programmable architectures proven outperform commonly interpretive simulators roughly orders magnitude speed loss accuracy 
principle compiled simulation takes advantage priori moves frequent operations simulation run time compile time order provide highest possible simulation speed 
fully compiled fully interpretive simulation different levels compiled simulation ranging mere compile time instruction decoding compile time scheduling pipelined processor models static scheduling 
simulators realized specific processor architectures 
compiled simulators programmable architectures complex pieces software difficult write debug validate 
efforts reduced retargeting simulators machine descriptions processor description language lisa :10.1.1.12.4355
compiled instruction set simulators generated lisa descriptions incorporate dynamic scheduler means task selecting operations overlapping instructions pipeline performed run time simulation 
explores application static scheduling techniques retargetable processor simulation processor descriptions lisa 
different approaches processor models different levels abstraction 
architecture descriptions lacking model instruction pipelines introduce technique instruction code translation technique static operation scheduling proposed cycle accurate models pipelines 

related hardware description languages hdl vhdl verilog systemc widely model simulate processors mainly goal developing hardware 
languages generally suited instruction set simulation cover hardware implementation details unnecessary performance evaluation software verification 
information processor instruction set assembly syntax completely missing 
detailed description hardware structures significant impact simulation speed impairing usefulness simulators architecture exploration software development 
instruction set architecture description languages adl allow modeling higher abstraction levels 
approaches address retargetable compilation simulation adls 
architecture description language nml initially developed retargetable code generation employed projects generation instruction accurate interpretive compiled instruction set simulators 
sim nml language extension nml enable cycle accurate modeling pipelined processors 
due simplicity underlying instruction sequencer possible describe processors complex pipeline control mechanisms texas instruments tms tms level cycle accuracy 
restrictions apply isdl supports development cycle count accurate models 
languages model instruction timing latency annotation cycle true modeling pipelined processors requires pipeline accurate behavior description pure semantics 
language expression rapid design space exploration dse allows cycle bit true modeling pipelined processors 
previous publications shown modeling real world architectures dsp texas instruments tms results available performance generated simulators 
adl derived earlier lisa extended support modeling multiple pipelines 
publications indicating realization cycle accurate simulators 
approaches retargetable simulation jacob system facile 
achieving reasonably high simulation performance employing compiled techniques retargetability limited small classes architectures 
summary approaches allows generation fast cycle accurate simulators pipelined processors suitable efficient architecture exploration software verification 
lisa language proven capable retargeting fast cycle accurate instruction set simulators various realworld dsp architectures 
larger parts information contained lisa model description utilized compile time increasing performance generated simulators shown sections 

lisa language lisa processor model mixed structural behavioral description modeled architecture 
structural part represented definition processor resources registers buses memories pipelines 
description processor instruction set including binary coding assembly syntax functional behavior timing distributed number operations 
instruction operations provide portions coding syntax contribute instruction behavior 
operations related concerning coding syntax behavior temporal execution order establishing tree structure attributes 
section focus laid behavior activation tree composed operations contributing behavioral model processor 
example shows exemplary implementation conditional branch instruction simple stage pipeline containing fetch decode execute writeback stage 
simplicity operation decode pipe dc declare group insn add sub branch coding insn insn branch activation test condition stall fetch activation insn operation branch pipe ex activation update pc flush fetch operation update pc pipe wb behavior uses pc pc 
example conditional branch instruction reasons information coding syntax partially omitted example 
decode operation defines group alternate operations add sub branch 
operations provide coding section group evaluated operations decoding respective operation activated 
activation operation leads execution corresponding behavior code function calls execution delayed instruction reaches pipeline stage operation assigned 
pipeline stage assignment achieved keyword followed pipeline stage identifier 
assuming decoding branch instruction operations test condition stall fetch executed immediately decode stage dc usually assigned particular pipeline stage shown 
branch operation executed occurence pipeline shift moving execution context instruction execute stage 
example shows difference compiletime run time conditions 
expression capital evaluated decoding operation selection construct embedded activation section evaluated simulator run time depends current state processor contents condition register condition evaluates true operations flush fetch update pc scheduled execution cycle instruction reaches writeback stage 
mechanisms pipeline stage assignment operation activation control operation timing lisa provides reserved operations controlling pipeline including executing shifting pipeline stalling flushing particular stages entire pipeline 
allows behavioral description complex interlocked multi issue pipelines 

compiled simulation objective compiled simulation reduce simulation time 
considering instruction set simulation efficient run time re semicolon inserts additional delay cycle ensure flush fetch executed cycle 
duction achieved performing repeatedly executed operations actual simulation run inserting additional translation step application load simulation 
preprocessing application code split major steps :10.1.1.12.4355

step instruction decoding instructions operands modes determined instruction word executable object file 
compiled simulation instruction decoding performed instruction interpretive simulators decode instruction multiple times part loop 
way instruction decoding completely omitted runtime signi cantly reducing simulation time 

operation sequencing process determining operations executed accomplishment instruction application program 
step program translated table structure indexed instruction addresses 
table lines contain pointers functions representing behavior code respective lisa operations 
involved operations identified step temporal execution order unknown 

determination operation timing scheduling performed step operation instantiation simulation loop unfolding 
behavior code operations instantiated generating respective function calls instruction application program unfolding simulation loop drives simulation state 
fully compiled simulation incorporates steps partial implementations compiled principle possible performing steps 
previous publications realization retargetable dynamically scheduled simulator implementing compile time instruction decoding operation sequencing :10.1.1.12.4355
operation scheduling performed simulator run time level compiled simulation refered dynamic scheduling 
regard implementation conditional branch instruction example means affiliation branch operation respective instruction identified run time operation scheduled activating operation decode executed 
run time scheduling achieved employing generic pipeline model parameterized lisa model description 
predefined pipeline operations execute shift flush stall activation code change state pipeline model run time simulation 
obvious maintainance pipeline model simulation time expensive 
execution profiling generated simulators texas instruments tms xx tms revealed roughly percent simulator run time consumed simulation pipeline 
situation improved implementing step operation instantiation consequently need simulation pipeline 
turn implies static scheduling words determination operation timing due overlapping instructions pipeline place compile time 
pipeline model instruction processor models shown operation instantiation gives significant performance increase models 
operation instantiation relatively easy implement instruction accurate models contrast pipelined models 

static scheduling generally operation instantiation described generation individual piece behavioral simulator code instruction application program 
straightforward instruction accurate processor models pipelined models require sophisticated approach 
considering instruction accurate models shortest temporal unit executed instruction 
means actions performed execution individual instruction determined instruction 
simulation pipelined models granularity defined cycles 
instructions active time due overlapping execution actions performed single cycle determined respective state instruction pipeline 
means instantiating operations single instruction application program behavioral code occurring pipeline state generated 
pipeline states exist instruction depending execution context instruction instructions executed preceding cycles 
implementation overview pointed previously principle compiled simulation relies additional translation step place simulation run 
step performed called simulation compiler implements steps section 
obviously simulation compiler highly architecture specific tool retargeted lisa model description 
paragraphs focus laid steps operation sequencing operation instantiation 
operation sequencing time instruction application program decoded sequence involved lisa operations determined path activation tree 
root activation tree represented reserved main operation 
particular operation responsible initiating operations pushing simulation forward run time 
naturally main operation assigned pipeline stage 
starting main operation occurring activations conditional branch instruction example leads activation chain shown 
grey shaded circles represent lisa operations involved execution branch instruction ordered assigned pipeline stages activation precedence intra instruction precedence 
instruction application program corresponding partial graph determined stored operation scheduler 
operation instantiation objective operation instantiation determination possible pipeline states instructions application program 
purely sequential pipeline flow case control hazards occur determination pipeline states achieved simply overlapping consecutive instructions subject structure pipeline 
order store generated pipeline states pipeline state tables providing intuitive representation instruction flow pipeline 
inserting instructions pipeline state tables refered scheduling 
pipeline state table dimensional array storing pointers lisa operations 
dimension represents location application location pipeline stage operation executed 
new instruction inserted state table intra instruction fetch fe dc ex wb main fetch test condition stall fetch decode add sub branch write register update pc flush fetch activation concurrent activation conditional activation activation chain conditional branch fe dc ex wb stalled decode decode sub incr add branch write write upd pc fe dc ex wb fetch fetch stalled decode decode decode sub incr add branch inserting instructions pipeline state table write write upd pc inter instruction precedence considered determine table elements corresponding operations entered 
consequently actual time operation executed depends scheduling preceding instruction scheduling operation assigned preceding pipeline stage current instruction 
control hazards causing pipeline stalls flushes influence scheduling instruction occurrence hazard 
simplified illustration scheduling process 
shows pipeline state table branch instruction inserted composed operations fetch decode branch update pc stall operation 
table columns represent pipeline stages rows represent consecutive cycles earlier cycles upper rows 
arrows emphasize activation chains 
scheduling new instruction follows precedence means fetch scheduled decode decode branch 
appropriate array element fetch determined assigned pipeline stage fe inter instruction precedences 
branch instruction follows add instruction scheduled fetch operation inserted operation add shown 
operations inserted precedences 
stall pipeline stage fe issued decode operation branch processed tagging respective table element stalled 
instruction scheduled stall accounted moving decode operation table row resp 
cycle see 
pipeline flushes handled similar manner selected table element marked flushed scheduling current instruction abandoned 
assuming purely sequential instruction flow task establishing pipeline state table entire application program straightforward 
sensible application contains certain amount control flow loops interrupting sequential execution 
occurrence control flow instructions scheduling process extremely difficult impossible cases 
table control flow instructions instruction type target address known 
paths direct branch compile time indirect branch run time direct cond 
branch compile time indirect cond 
branch run time applies calls return run time cond 
return run time software interrupts run time cycle pf fe dc ac rd ex cycle pf fe dc ac rd ex instruction different context control flow instructions overview common control flow instructions table 
generally instructions modifying program counter cause interrupts control flow 
furthermore instructions providing immediate target address branches calls target address known compile time scheduled statically 
scheduling conditional unconditional types instructions discussed paragraphs brief discussion indirect types section 
shows excerpt pipeline state table unconditional direct branch instruction tms dsp 
fourth cycle shown target address branch put program address bus scheduling continued subsequent instructions 
information required order perform compile time scheduling target address time program counter resp 
program address bus written extracted lisa model description contained activation graph 
instruction scheduled sequential context shown scheduler perform unrolling infinite loop enlarging pipeline state table 
order prevent behavior new instructions scheduled pipeline state reached dependent branch instruction 
comparing figures condition fulfilled enters pipeline 
row pipeline state table replaced link state 
scheduling conditional direct branches complex condition depend instruction executed 
scheduling performed eventualities condition true resp 
false splitting program alternative execution paths 
corresponding pipeline states shown 
selection appropriate block prescheduled pipeline states performed switching different state tables simulator run time 
address instruction bc addr 
pf fe dc ac rd ex bc addr bc addr bc addr bc stall stall addr bc addr bc addr condition evaluated pipeline behavior conditional branch order prevent doubling entire pipeline state table time conditional branch occurs alternative execution paths left soon generated state reached 
conditional instructions reside pipeline time usually length rows 
simulator instantiation instructions application program processed entire operation schedule established simulator code instantiated 
simulation compiler backend generates code operation table respective function pointers describing alternative representations application program 
example shows simplified excerpt generated code branch instruction 
cases represent instructions newline starts new cycle 
switch pc case fetch decode sub write registers case fetch decode test condition add case branch write registers fetch update pc fetch decode fetch decode load goto example generated simulator code limitations general instructions setting program counter value determined compile time indirect branches scheduled statically 
instructions target address known run time fallback dynamic scheduling inevitable 
performance gain statically scheduled simulation decreases occurrence unpredictable instructions fallback dynamic scheduling runtime expensive terms simulator speed 
fortunately applications number occurring direct branches calls outweighs number indirect ones 
generally data flow applications commonly dsp benefit static scheduling 
cycle limitation compiled simulators consider program code changes run time aligns field application dsp applications contrast operating systems instance 

code translation overview need scheduling mechanism arises presence instruction pipeline lisa model 
instruction accurate processor models pipeline benefit step operation instantiation 
technique applied called instruction code translation 
due absence instruction overlap simulator code instantiated instruction independently simplifying simulator generation concatenation respective behavioral code specified lisa description 
contrast direct binary binary translation translation target specific host specific machine code uses source code intermediate format 
keeps simulator portable independent simulation host 
limitations instruction code translation generates program code linearly increases size number instructions application simulation technique restricted small medium sized applications instructions depending model complexity 
large applications resultant worse cache utilization simulation host reduces performance simulator significantly 

implementation results order evaluate applicability efficiency statically scheduled simulation retargetable environment simulation generators implemented incorporate techniques static scheduling instruction code translation 
generators compiled simulators successfully generated model descriptions texas instruments tms dsp cycle accurate advanced risc machines arm microcontroller core instruction accurate 
processor model descriptions part previous realized designer weeks weeks respectively 
comparison implementation custom compiled simulator took twelve months 
benchmarking results obtained simulators mhz athlon pc running linux simulation host 
generated simulator code compiled gnu compiler gcc version optimizations turned 
shows simulation performance generated vendor simulator code composer studio running tap fir filter 
seen application static scheduling gives performance increase factor compared dynamically scheduled simulation 
roughly performance gain reported handwritten compiled simulator 
concerning simulation compiler backend instantiation simulator code generation source code proven efficient generation operation table see table simulator runs half speed directly instantiated 
lisa model arm core simpler model solely consequence lack pipeline 
naturally simulation performance roughly simulated instructions second dynamically scheduled simulator higher accurate model 
code translation second instructions second fir simulator performance fir adpcm simulator performance arm static scheduling src code gen static scheduling table gen dynamic scheduling ccs interpretive code translation dynamic scheduling applied simulator executes instructions second see 
reveals strong dependency simulation performance application size implementation protocol stack far complex terms number instructions application adpcm codec fir filter 
direct consequence circumstances discussed section 
application comprises machine instructions 

new approach applying static scheduling techniques retargetable processor simulation environments 
past steps compiled simulation instruction decoding operations sequencing applied explored implementation benefits limitations third step operation instantiation simulation loop unfolding 
performance results selected processor architectures proved feasibility value approach 
focus application real world processor architectures complex schemes vliw multi issue pipelines 
retargetable simulation current research aims retargeting code generators generation synthesizable hdl descriptions lisa architecture models 

engel 
generic tool set application specific processor architectures 
proceedings eighth international workshop hardware software codesign codes pages san diego ca usa may 

nml machine description formalism 
technical report technische universit berlin fachbereich informatik berlin 
russo devadas 
methodology accurate performance evaluation architecture exploration 
proc 
acm ieee design automation conference dac jun 

expression language architecture exploration compiler simulator retargetability 
proceedings european conference design automation test date mar 

generation software tools processor descriptions hardware software codesign 
proc 
acm ieee design automation conference dac jun 
hoffmann braun meyr 
survey modeling issues machine description language lisa 
proceedings ieee international conference acoustics speech signal processing icassp salt lake city usa may 
khare 
sat visual specification analysis tool system chip exploration 
proceedings th euromicro conference milan italy sep 
leupers landwehr 
generation interpretive compiled instruction set simulators 
proceedings asia south ic design automation conference asp dac jan 
hoffmann meyr :10.1.1.12.4355
retargeting compiled simulators digital signal processors machine description language 
proceedings european conference design automation test date paris march 
meyr 
fast simulation ti tms dsp 
proc 
int 
conf 
signal processing application technology pages san diego sep 
rajesh 
processor modeling hardware software codesign 
proceedings international conference vlsi design jan 

hardware software simulation 
proc 
acm ieee design automation conference dac 
schnarr hill larus 
facile language compiler high performance processor simulators 
proceedings acm sigplan conference programming language design implementation pldi utah usa jun 

processor description language supporting retargetable multi pipeline dsp program development tools 
proceedings international symposium system synthesis isss dec 
sites 
binary translation 
communications acm feb 
