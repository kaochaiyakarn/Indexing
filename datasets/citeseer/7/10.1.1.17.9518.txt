knowledge level reflection frank van harmelen bob wielinga bert schreiber werner martin hans akkermans brigitte bartsch erik uva gmd ecn bsr presents overview project 
defines notion knowledge level central project compares notion existing approaches reflection related fields investigates consequences concept knowledge level reflection general architecture knowledge level reflection model object component architecture nature reflective theories design architectures results actual experiments systems 
keywords knowledge systems reflection meta reasoning 
problem statement definition current knowledge systems lack capabilities perform number functions generally attributed human experts competence assessment knowledge base maintenance knowledge refinement sensible explanation adaptive interaction performance validation verification internal knowledge consistency fundamental premise underlies advanced functions knowledge systems realised creating system system able reason knowledge problem domain problem solving strategies scope competence history terms solved cases 
reflective research reported carried course reflect project 
project partially funded esprit basic research programme commission european communities project number 
partners project swi university amsterdam amsterdam netherlands netherlands energy research foundation ecn netherlands national german research centre computer science gmd st augustin germany bsr consulting munich germany 
reasoning requires self representation mechanism reasoning self representation means controlling interaction object problem solver reflective component 
reflective reasoning system able know solve particular problem 
capable indicating gaps knowledge base exist gaps may filled 
reflective system able act object problem solver adapt behaviour case difficult problem encountered impasse problem solving process occurs 
goal investigate flexible robust knowledge systems constructed concept reflection 
elaborate goal establish precisely mean reflection reflective systems consider scope reflection 
context reflection common sense meaning refers activity pondering oneself behaviour relation outside world 
ai research term reflective system identify class systems way knowledge able reason act 
view reflective systems closely related identical meta level systems maes nardi 
maes maes defines reflective system computational system knowledge data part external world object domain enabling reason act domain ability reason act 
reflection requires self representation causally connected smith object system actions object system reflected self representation changes self representation reflected object system 
maes distinguishes reflective systems meta systems 
take broader view reflection reflective system system knowledge part object component 
knowledge called model object component 
addition reflective system contains metaknowledge allows reason act object component 
principle object component meta component coincide case system fully reflective system 
cases knowledge object part system partial 
case system viewed consisting meta system object system 
view systems perform meta level reasoning maes defines maes considered subset partially reflective systems 
questions addressed realise flexible robust behaviour knowledge systems reflection 
various views reflection relate 
section nature object model needed perform variety reflective tasks sections 
meta knowledge needs represented order achieve reflective tasks section 
architectural choices designing reflective systems consequences choices section 
section presents examples reflective systems implemented 
approach background section discuss reflection distinct related areas science logic computer science 
areas give brief summary major topics problems approaches solutions concerning reflection indicate impact approach reflection described 
reflection logic building formal systems describe formal systems building systems self referential capabilities activities long standing tradition logic meta mathematics 
purpose section briefly important results achieved logicians area 
encoding truth provability earliest probably widely known self referential systems godel 
devised way encoding certain meta statements concerning syntax proof theory object formalism peano arithmetic statements object formalism 
predicates stating instance formula concerning natural numbers followed rule inference represented object predicates natural numbers 
construction prove certain properties self encoding systems theory encoding possible incomplete incompleteness theorem consistent theory prove consistency second incompleteness theorem 
proofs negative results relied possibility constructing self sentences encoded sentence pr ov stands encoding 
closely related result obtained tarski tarski 
proved explicitly add theory truth predicate defined true known tarski theory inconsistent 
proof relies construction self referential sentence liar sentence true leads contradiction 
attempts avoid negative results tarski 
kripke kripke suggested construction true true holds formulae closely related suggestion perlis perlis 
book turner turner provides excellent thorough exploration attempts encoding truth provability clear issues arising self unresolved 
inter theory inference feferman term reflection principle originated page reflection principle understand description procedure adding set axioms certain new axioms validity follows validity axioms formally express language evident consequences assumption theorems valid 
somewhat different term reflection principle logic ai 
originally weyhrauch find reflection principles defined statement relation theory meta theory formalised inference rule premise different theories object metatheories system 
standard examples form reflection principle inter theory inference rule rules reflecting object theory meta theory dow 
situation close described tarski difference course different theories avoiding contradiction generating self referential sentences 
rules associated theory framework imple mented fol weyhrauch 
system imposes constraints definition pt user fol implement truthful enlarged partial reflection defined literature review giunchiglia follows truthfulness allows extension results consistent enlarged reflection truthfulness dropped partial reflection allows extension results derivable 
definitional extensions 
rules reflection rules mentioned literature means possibility giunchiglia serafini generalises notion arbitrary inference rules link theories 
naming written true explicitly stating syntactic status want stay context order logic require pr ov true order predicates opposed say modal operators second order predicates order term particular name order formula 
implies sentences object language named terms argument meta predicates 
logicians employed types naming tarski quotation mark names str descr names 
quotation mark names associate formula constant name written 
encoding described example type naming 
structural descriptive names arbitrarily complex ground terms reflect structure sentence name 
types naming relations entirely sense names determined syntactic structure object expression 
hand argues naming defined non syntactic grounds semantic pragmatic opens possibility exploiting name re lation encode information object theory possible purely syntactic naming 
relation languages discussed crucial importance meta predicates prov names belong theory sentences 
del system formulae natural numbers encoded named natural numbers formulae names belonged theory bi lingual framework fol separates indicated subscripts derivability symbol rules avoids problems caused self context rules objects formulae names belonged language called mated approach rule proved derived inference rule words form partial reflection rule enlarged reflection principle 
rules bowen kowalski authors start object theory describe associated meta theory theories 
summary brief overview reflection encoding self logic 
fundamental tarski leading negative results properties self encoding systems incompleteness inconsistency 
kripke perlis attempts avoid negative results introducing variants truth predicate 
attempts avoiding inconsistencies systems iterated extensions axiom sets turing feferman word reflection principle originated 
third approach aimed avoiding self altogether separate meta theory proposed weyhrauch 
leads viewing reflection principles inter theory inference rules 
fundamental notion naming formulae ground terms encoding object theory meta theory done order framework 
final strand reflection logic encoding belief contrast described concerned encoding truth provability 
encoding belief logic modal order formalisms approaches suffer problems similar encountered encoding truth provability 
computational reflection term reflection computer science denote computational systems addition computation aspects world perform computation aspects data program execution process 
reflective system meta level architecture 
part system reasoned objectlevel represented meta level 
self representation object level causally connected term informally described maes link representation system represents changes changes accordingly representation truthful 
context smith introduces notions introspective integrity introspective force 
introspective integrity concerns question significant property representation meta level accordance content represented object level 
integrity quality representation meta level realised causal connection upwards 
introspective force involves realisation system reflective goals object level causal connection downwards 
implementation reflective computational system particular reflective architecture determines representation languages interpreters control flow system components provides mechanism implementing causal connections 
reflective programming language language supports programming reflective systems 
language facilities support writing computational systems able access manipulate causally con nected representations computation maes 
tive systems need programmed reflective languages computational reflection focussed definition reflective languages 
reflective languages reflective computation languages constitute landmarks brief history computational reflection concerns control object level computation 
lisp smith realised reflective functions interpreted meta circular interpreters 
meta circular interpreter explicit representation interpreter language run language 
meta circular interpreter explicit variable binding environment continuation interpreter lower level inspected influenced reflective function 
kr maes object oriented programming language 
reflective computa tion specified means meta objects represent reflective information access modify computation performed objects 
evaluated meta circular interpreter 
teiresias davis early example rule language allows meta rules order prune set object rules plausible reaching object level goal 
meta rules teiresias describe domain specific content plausible mention explicitly 
abstracting away domain meta rules uses term knowledge source order indicate form encoding rules 
refer knowledge roles specific domain objects clancey 
soar laird el attempt provide architecture general intel 
dedicated problem space hypothesis goal oriented behaviour search problem spaces 
originally conceived meta level reflective architecture soar specified multi level architecture reflect problem solving behaviour rosenbloom el 
architecture distinct meta levels problem space level contains operators states goals contexts production level applies productions condition action pairs long term memory objects working memory order implement oper preference level selects alternative candidate objects resulting productions signals impasse impossibility select object apply operator 
case subgoal setup explicit impasse occurred 
subgoal resolve impasse carried search new problem solving context level architecture applied may lead new resolved higher levels 
example impasse operator application resolved searches state allows execution operator 
selection impasse resolved look ahead search 
manner full capacity soar applied basic operations resolving reflecting problem solving capabilities 
architecture computational reflection oriented logic fol weyhrauch distinguishes theories meta theories order logic 
notable purpose reflection change theorem proving object theory evaluation meta theory 
meta theory may example consist subsidiary deduction rules shorten proof 
meta programming logic programming resulted various proposals meta level extensions logic programming languages form meta interpreters seminal bowen kowalski 
particular del hill lloyd serious attempt provide meta logical facilities declarative semantics 
approach clear distinction language object level representation syntactic naming relation 
summary reflection computational systems refers computation program aspects program 
purpose existing architectures mainly control object level computation 
order achieve purpose variety architectures conceivable 
differ self representation system causal connection self representation object level computation needed performing reflection locus action object meta level 
definition approach knowledge level reflection literature discussed previous section number topics re occur issues concerning reflection subfields 
section describe re occurring issues devote subsection 
subsequently define approach building reflective systems specific positions take issues devoting subsection issues 
issues building reflective systems nature object model object model mean representation model meta system object system reasons object system 
logic object model created applying syntactically defined naming relation object expressions resulting meta terms name object expressions subject meta theory 
computational reflective systems object representation captures various degrees abstractions computational mechanisms object system lsp meta theories deal function call continuations bindings environments krs deal message passing inheritance deals conflict resolutions sets shows reflective systems deal computational aspects object system 
cognitive science little consensus nature structure model knowledge 
soar architecture propose specific model originate cognitive science way represent emerging view field 
separation vs amalgamation issue concerns relation meta object system 
separate systems communicate subpart 
logic issue corresponds relations languages express meta theory approaches investigated 
computer science approaches sol representing separated approach lisp krs amalgamated approach 
cognitive science issue mention distinction underlies reflective access 
causal connection problems connecting object meta system third issue occurs subfields dealing reflection 
reflection rules logic causal connection computational systems influence meta cognitive processes way solve problem concerned connecting object meta component specify information flows complements influence 
switching locus action direct implication choice separating object system meta system decide system active point 
computer science literature described switch locus action cognitive science amounts switching cognitive meta cognitive activities 
notion switching directly logic logic deliberately abstracts control 
nature reflective theories approaches reflection share interest nature contents reflective components 
general formulated independent object system generic form topics interest treated reflective theories questions concerning general nature meta theories addressed subfields 
knowledge level reflection section define approach reflection differs existing approaches outlined section 
define approach terms position general issues building reflective systems discusses previous section 
position issue nature self representation markedly different existing approaches 
choice concerning issue largely determine position general issues 
object models treatment object model separates approach reflection markedly existing approaches literature 
logic computational approaches reflection object models detailed commitments syntactic computational aspects object system logic syntactic naming mirrors object system syntax meta theory meta components computational systems lisp krs detailed assumptions computational mechanisms object systems 
contrast approach reflection idea meta theory possible syntactic computational details object system 
meta theory concerned behaviour object system independently syntactic computational details behaviour realised 
coined term level form idea point view resembles advocated newell newell argued knowledge level appropriate level describing ai systems 
term knowledge level cause confused debate ai community 
context read term representation representation captures essential problem solving capabilities defining capabilities computationally realised 
meta theory concerned kind task performed object system diagnosis monitoring design knowledge needed perform task ot computational mechanisms perform task represent knowledge logical deduction messages objects production rules 
choice abstracting away meta theory object model computational implementational details motivated justified type reflective task want tackle meta theory 
discussed tasks competence assessment sensible explanation adaptive interaction tasks concerned essential problem solving capabilities object system quite independently capabilities realised 
sections devoted discussing structure contents object models meta theories required knowledge level reflection investigate implications commitment object models central issues building reflective systems discussed previous section 
separated systems commitment object models implementation details necessarily implies conceptual separation object system model meta level object system implemented system concerned implementational mechanisms symbol level aspects newell terminology object model meta level knowledge level representation object system 
section argue fact possible symbolic structures dual purposes object system symbol level computation object model knowledge level representation conceptually treated separate 
additional advantage separation object system representation meta level avoid paradoxes arising self referential constructs 
causal connection non syntactic distinctions commitment knowledge level object models means de part standard approach base object model syntactic distinctions object system 
discussed section want object model capture distinctions different types knowledge object system 
instance diagnostic system may want distinguish abstraction rules generalisation rules rules may represented object system syntax 
syntactic distinctions want capture semantic pragmatic distinctions elements object system different types knowledge 
object model categories necessarily syntactically distinguishable causal connection required link functional categories object model hand implementational structures object system underly categories hand 
describes non syntactic distinctions captured extending usual notion naming object meta theory 
locus action approach reflection commit specific ways switching locus action object meta system 
section investigate pro con various switching paradigms comparisons architectural conceptual grounds 
generalised reflective theories major advantage approach reflection meta theories applicable wider class object systems 
object models capture functional behaviour object systems away implementation details meta theories object models applicable object system realises certain functionality say abductive diagnosis design irrespective functionality implemented 
section argue reflective task problem solving task exception application domain somewhat different part external world problem solver investigate consequences 
section see possible apply multiple reflective theories single object system say reflective theory competence assessment sensible explanation 
similarly turn possible apply single meta theory multiple object systems requiring multiple models meta level 
introduce term arrangement en second 
course fully general variation possibility 
remainder devoted considering greater detail issues treated section 
section deals issues concerning self model section investigates general nature meta theories section discusses implementational consequences standpoint amalgamation vs separation sections investigate implementational issues related choices causal connection switching paradigm 
results model object component kads modelling object component pointed previous section nature model object component prime discriminating factor knowledge level reflection 
position taken previous section implementation independent knowledge level nature object model raises question realise object models 
answer question look developments field different reasons construction kbs models similar properties received attention past decade 
particular knowledge level models experiments models kads approach knowledge engineering breuker wielinga wielinga 
kads models contain types ingredients knowledge describing inferences needed application 
inferences describe basic reasoning steps wants domain roles pieces domain knowledge manipulated inferences play reasoning process 
set inferences graphically represented diagram showing input output dependencies inferences called inference structure 
knowledge structure domain specific knowledge required perform inferences 
basic reasoning steps inference process assume certain types domain knowledge 
control knowledge determine inferences sequenced particular situation 
notion task structure control knowledge 
task defines typical decomposition inferences sub tasks internal sequencing information 
different categories knowledge particular relations control knowledge invokes inference inference applies domain knowledge 
important property kads models independent specific details domain object system 
model contains object domain independent knowledge application task realised object system 
example case object system diagnosing faults audio system kads model contains knowledge diagnosing devices general contain knowledge specific audio systems 
knowledge engineering property exploited reusing parts model domains similar characteristics preventing knowledge engineer reinventing wheel time new application built 
type reflective systems aiming means self model general specific system constructed 
languages representing self model able knowledge level models self model reflective system necessary formal interpretable representation models 
kads framework literature breuker wielinga wielinga uses highly structured partly informal modelling language directly knowledge level reflection 
reflect different languages developed solving problem formal specification ml ml formal specification language kads models expertise 
language offers sorted logic module algebra defining multiple theories meta level organisation user definable naming relations theories 
detailed description ml reader remarked previous section internal structure kads models meta nature particular relation inferences domain structures 
meta object relation kads model confused meta object relation reflective system object system 
referred akkermans el 
example ml model problem solving method schreiber el 
operational specification model model el operational language implementing kads models 
model provides language constructs retain large degree information kads model addition implementation details 
way model ensures code final system access knowledge level model built 
information preserving property object system important facilitating requirement building type reflective systems aiming 
address issue concerning relation self model detail section 
opting kads models describe object system model meta level course kads framework describe meta theory 
meta system kbs right kbs application domain 
describe meta theory kads model containing ingredients domain inference control knowledge specified specific constraint kads model object system part domain knowledge meta system 
gives rise model meta theory depicted 
kads model meta system kads model object system control inference domain control inference domain kads models knowledge level reflection nature reflective theories purpose section investigate general nature contents reflective problem solvers 
reflective problem solvers perform tasks ordinary problem solvers expect general models available ordinary problem solving equally applicable reflective problem solvers 
section take existing kads model diagnose repair task model general types knowledge required reflective theory diagnoses malfunctions object system 
reflective task inference knowledge ascribe various behaviors reflective component instance predicting effort problem solving quality solution recognizing object problem solver dynamically re configuring problem solver cases unsatisfactory behavior 
notwithstanding variety identify generic tasks cover specific instances reflective reasoning 
way model reflective component regard consisting diagnose step potential causes incompetence located actions overcome incompetence 
slightly different monitoring control tasks explained model 
diagnose comprises inspecting resp 
analyzing object problem solver inter pr obtained findings terms potential causes incompetence 
diagnosis necessary example impasse object problem solver occurs 
error occurs analysis object problem solvers identify causes potential findings compared predefined norms interpretation step expand entire assessment task prediction task behavior system interest 
repair may viewed improving competence depending outcome diagnosis 
repair subtask consists pr repair actions applying object system 
repair step may refined priori configuration object system dynamic modification problem solving 
usually apply subtask modifies object system 
depicts inference structure diagnose repair model 
input analysis object system model precisely abstraction thereof 
analysis produces findings state object system quantitative description complexity problem number hypotheses set competing actions 
findings interpreted causes incompetence problem inconsistent state basis predicting behavior object system 
specific findings causes determine repair actions required overcome incompetence 
separating proposal repairs actual application allows choose incompatible proposals different modules 
storing allows module update knowledge analyzing proposing repairs 
instance reflective module decomposing problem accumulate solutions solved subproblems experiences 
inference structure diagnose repair tasks malfunctions play crucial role 
suggested essentially categories malfunctions responsible object unsatisfactory behaviour problem incompleteness uncertainty inconsistency redundancy 
categories sufficiency computing resources possibility parse situated implementation level 
reflective domain knowledge contrast layers model layer independent choice task reflective system 
diagnose repair case 
dependent layers fact studying reflective system reasons problem solver 
inference structure reflective competence assessment improvement domain layer supposed capture properties domain reasoning reflective case problem solver 
domain knowledge reflective systems consist parts model object system discussed section 
model object system may additional knowledge enabling reflective component perform task 
large extend knowledge embodies expertise knowledge engineers programmers evaluating programs 
specific type tasks performed determines kind knowledge expected reflective domain layer 
general categories knowledge distinguished domain layer general knowledge problem solving reasoning knowledge specific object task additional knowledge object domain additional knowledge object system realising task domain space architectures knowledge level reflection preceding sections concerned conceptual systems perform knowledge level reflection barely touched issue implement systems 
topic section 
lay design space actual construction reflective component connection object system 
dimensions design space follow specific nature reflective system concern realise model object system ii switch activity object meta system iii ensure correspondence object system model meta layer 
discussing design dimensions subsections discuss possibility implementing reflective specification level system 
single level systems principle reflective specification realised single level system inherent property reflective specification impossible integrate object system 
major reason choosing single level option computational efficiency 
practical reasons leaving object system intact 
difficult impossible modify existing code object system 
important opting multi level architecture offers number advantages high degree conceptual clarity modularity 
standard problems created non modularity amplified case complex systems investigated 
system development objectives require high level conceptual clarity modularity lead favoring multi level solution single level reusability reflective modules explanation maintainability 
realising model object system preceding sections extensively discussed nature object model meta level object model 
contains structural knowledge primitive inferences knowledge roles 
emphasis model object system desc knowledge structures object system 
section consider alternatives realisation model object system reflective architecture 
access procedures approach direct connection reflective inference layer language structures object system established means set procedures read write access 
separate meta representation object system employed 
read procedures fill update contents reflective knowledge roles 
write procedures directly modify language structures object system 
knowledge typing second approach introduces facility knowledge typing declaration conceptual types knowledge object system 
knowledge typing mechanism serves view object system attaches knowledge types language structures object system limits access parts object system declaration explicitly 
case separate meta representation object system employed 
separate representation third approach model object system represented separate data structure language different language object system 
results implementation reflective system corresponds exactly conceptual description systems preceding sections 
approach requires causal connection ensures integrity force representation 
see section 
language structures object system directly manipulated reflective system possible delay synchronisation representation object system 
allows multiple extensions modifications self model investigated reflective system time example comparison alternative applicable methods reflective system schedules object problem solving steps 
options realising object model summarised 
reflective layer object system access procedures reflective layer object system knowledge typing reflective layer obj ect model causal object system separate representation different ways realising object model guidelines access procedures realise model object system ad hoc manner 
knowledge typing mechanism constitutes model principled manner integral part language object system imposing suitable view object system 
knowledge typing mechanism view object system sense modifications model directly object system 
suitable reflective tasks react current situation immediate actions result inconsistency object system alternative extensions considered reflective task 
third approach separate representation allows alternative extensions model 
combination knowledge typing mechanism realises self model manner fully corresponds conceptual framework preceding sections 
advantage languages object system representation disjunct clarifying distinction mention reflective level object level 
major drawback separate representation requires specification self representation introduces computational complexity synchronisation discussed section 
switching paradigm conceptual view reflection outlined previous sections presents architectural problem represents agents object system meta system 
implement distribution activity parts reflective system 
switching paradigm constitutes second dimension design space tive systems 
laid number design options switching activity object meta layer re investigate context notion knowledge level reflection 
preferred switching paradigms obvious choice switching activity object meta layers subtask management reflective knowledge schedule subtasks object level 
subtask management successfully switching paradigm number experiments section 
different option occurring called ter nal switching 
idea introduce third module responsible switching activity object reflective layers 
call third module scheduler 
meta module object reflective layer determines active 
relation scheduler systems subtask management scheduler gives subtasks object reflective layer 
subtask management switching paradigm successfully number experiments section 
inadequate switching paradigms design option switching paradigm explicitly advocated meta simulation 
activity meta level requires complete description object system object model 
description simulate object system meta level 
turns option unsuitable realising kind reflective systems investigated 
major assumption underlying meta simulation representation object system reflective layer detailed allow full simulation object system means representation 
puts stringent requirements contents amount detail object model representation detailed allow full simulation object system 
requirement conflict major premise notion level reflection defined states object model abstracts computational aspects object system 
object model enable simulation object system 
adequate switching paradigms options switching paradigm design space 
options adequate choices suffer problem require reflective knowledge part object system having reflective knowledge reflective layer 
called cr isis management systems switch locus action takes place cr isis occurs object level computation 
meta system resolved crisis object system proceed computation 
examples definitions crisis object level knowledge applicable object level run resources object level needs information 
major drawback paradigm definition crisis needs inserted object system conceptually belongs meta level reflect act systems final option dimensions design space 
reflect act systems locus action moves object reflective layer predefined place object computation reached 
objections raised option switching happens predefined fixed places object system cod switching need defined meta level 
synchronising object model object system design option realising self model outlined section choose explicit representation object model separate ensure integrity force model respect system represents 
section discusses number possible ways realise synchronisation distinguished basis synchronisation takes place information copied object system model 
synchronise eager synchronisation obvious option ensure descriptions object system synchronised changes immediately propagated 
type synchronisation required monitoring type switching discussed technologically hard realise efficiently 
lazy synchronisation opposite eager synchronisation arrangement changes representation allowed happen propagation representation read operation performed representations update takes place 
advantage scheme course amount synchronisation performed system 
synchronise switching third option exploit control switching paradigm chosen 
particular control paradigm chosen involves explicit switch locus action subtask management crisis management reflect act synchronisation take place time locus control moved 
justification course switches representations modified read delay synchronisation point switching 
arrangement avoids unnecessary updates lazy synchronisation 
copy option dimension design space causal connection representation copied process synchronisation 
full copying easiest option course full copy representation translate entirely representation 
conceptually simple option lead efficiency problems representations large complicated 
incremental copying changed efficient complicated option copy parts representation modified synchronisation 
requires keeping track modification times parts different models 
option requires structural correspondence representations object problem solver elements representation linked corresponding elements representation 
quite strong requirement imposed full copying option previous paragraph 
incremental copying required final option copy tures changed structures needed irrespective changed 
longer requires timestamping datastructures possibly copies data 
course possible combine option previous absolutely amount data copied expense complicating implementation causal connection 
validation validate approach built reflective systems exploring broad conceptual architectural spectrum 
section gives survey experiments presents greater detail 
exhaustive description bartsch 
reflective assignment system object component object assignment system allocates components called slots satisfying certain requirements 
called office plan allocate employees office rooms 
office plan 
tried solve obviously inconsistent problems instance employees room offices 
detected solution propose compromises 
recognize problem need hours solve 
particular detect redundancies 
instance person sit single room trivially satisfies different room constraints may dropped 
cope underspecified problems evaluating restrictive constraints 
types malfunctions mentioned section uncertain knowledge caused problems system operated categorical knowledge 
tackle types malfunctions incomplete irrelevant knowledge built integrated meta components top office plan 
generic depend particular domain office planning 
certain extent specific particular problem solving technique employed object component 
meta components integration roughly spoken meta components feasibility studies resource management problem modifications 
simplifications relaxations elimi nate contradictions 
feasibility studies performed comparing available required resources 
knowledge prevent object component solving apparently unsolvable problems 
contradictions detected wrt 
requirements original problem statement wrt 
constraints internal representation relaxations negotiated user 
redundancies different types detected removed pairs requirements pairs constraints constraints conditions constraints possible value restriction constrained variables 
removing redundancies speeds solution process 
decomposition relaxation meta component decomposes problems solves stepwise possibly reusing previously partial solutions 
suitably composing solvable subproblems return approximate solutions overspecified problems 
component quick runtime increases linearly number subproblems stored library 
problem solving time substantially reduced 
contrast feasibility studies detect certain contrast contradiction removal specialized pairwise inconsistencies meta component detect solve inconsistencies 
resource limitations introduced limiting time number solutions desired 
satisfy meta component controls generate test kernel office plan iteratively allocating time slices generate test steps 
purpose achieve optimal performance limitations 
specify number solutions content see specify time willing wait system best produce solutions time combine 
case reasoning allows bypass entire problem solving process exploiting library complete cases 
incorporating problems relaxed solutions meta component cope inconsistent problems 
offers quick risky approach case library may contain similar case 
including case library meta component case reasoner second object component 
meta component decide invoke case reasoner office plan 
reflective system functionality object component extended inconsistent problems solved making compromises 
additionally system utility enhanced 
original system took input problem fell silent quite come solutions problem inconsistent 
reflective system choose number solutions want time willing spend relaxations 
shows dimensions utility values assign parameter 
combinations served meta components 
instance relaxed solutions solutions prespecified amount time 
serve impossible combinations introduced priorities relaxation important time important number solutions 
instance produce relaxed solutions predefined time limits 
case relax ignore time 
utility values office comic tackle dimensions plan time relaxation time quick min max long quick quick min max risky slow min max min max solutions utility dimensions specialists fit spectrum reflective systems altogether developed meta components operating different object systems combined reflective systems varying number meta object components 
reflective office plan system reflective system bartsch el chapter dealing bug qualitative reasoner 
certain circumstances system computes multiple instances parameter resulting different states identified 
bug repaired ways 
change library qualitative models prediction may counter intuitive 
fix bug code system require intimate knowledge lines prolog code probably lot debugging 
built meta component spots multiple parameter instances identifies merges corresponding states 
reflective system bartsch el chapter deal problem multiple diagnoses reasoners 
trying explain symptoms multiple fault diagnosis seek observations explain symptoms relax 
done computing specificity observations causal network considering applicability hypotheses currently observed symptoms 
multiple fault diagnoses approach allows take account dependencies symptoms physiological interactions diseases 
reflective system bartsch el chapter combines object components mentioned reasoner qualitative notation indicate system meta modules object modules 

abductive diagnosis fails produce explanation differentiate hypotheses causal connections missing retrieved qualitative simulation 
built meta component decides object component invoke situation controls possibly repairs initial strategy 
collection reflective systems covered broad scope including reflective diagnose repair tasks reflective resource management reflective strategy construction 
tackled different malfunctions inconsistencies redundancies incompleteness 
uncertainty treated played role object components 
meta components realize different reflective behaviors inspect modify different kinds knowledge object components 
table summarizes spectrum covered reflective systems 
dimension options explored type reflective system type reflective task diagnose strategy construction resource management malfunctions inconsistency incompleteness general inference structure exact match renamed simplified extended table spectrum covered experiments 
architectural alternatives explored develop reflective assignment system proceeded incrementally 
built constitute object component reflective system 
soon number interesting meta components available integrated system 
started integrating redundancy removing components added contradiction detection feasibility studies resource handling decomposition relaxation case reasoner 
support implementation technique modularize aspects concerning scheduling meta components coordination object component 
purpose introduced scheduling layer top task layers 
control different components exercised layer suitable switching paradigm external subtask management regime 
implementing meta components general purpose language lisp prolog developed language directly supports reflect approach 
language called model represents point design space laid previous section 
meta components defined language submit design decisions 
reason table sufficient options explored experiments design decisions model 
shortly comment entries 
representation implementation languages office allocation system model model implement object meta architectural dimension options explored experiments model experiments specification language ml model implementation language prolog model switching paradigm subtask management external object model scope representation partial complete access representation direct transparent synchronization direction scope full time switch lazy eager table architectural options explored components 
experiments object meta components mod ml logic language formalizing kads models implemented prolog 
scope model represented model object system extension conceptual model operational aspects 
complete model available implementation 
object components modeled ml explored alternatives 
represented parts accessed meta component dropped model completely corresponding system written prolog structure preserving way 
access model supports transparent access object model 
cases accessed explicit prolog representation model directly prolog code object system 
switching paradigm systems subtask management straightforward alternative 
systems external switching facility built model 
synchronization reflective systems require synchronization upwards object component modified 
require synchronization upwards downwards 
full incremental updates effected eagerly lazily switching times 
model update upwards done data required done downwards eagerly 
experiments explored quite different points design space defined section 
particular experiment office planning probably noticed need external scheduler 
conclude unique set design decisions guidelines gave section derived experiments 
differences common experiences 
meta components fit inference structure shown section 
provide starting point modeling meta component 
meta components operate partial model object system 
may mean components hand quite general hand complicated 
explored different types implemented object model realizing causal connection straightforward 
modify object systems 
strong evidence approach operating knowledge level models object components provided implemented structure preserving way 
nature reflection starting point reflect project notion reflection reasoning knowledge capabilities 
study literature reflection systematic investigation conceptual space spanned various forms reflective systems identified number key issues designer reflective system decide 
study literature reflection clear exist wide variety conceptualisations reflection despite differences various approaches reflection point number central notions 
concept self model 
second common idea find various approaches separation object meta system means coping problems self circularity inconsistency 
observations sketched developed reflect project new approach meta level reflective systems 
approach multilayered architecture sub system located layer reasons operates model sub represented layer 
approach reflects decisions 
clear separation meta object level 
main rationale choice circumvent problems related self 
consequence systems investigated fully reflective sense full self model partial 
second choice reflect project concerns nature model object system 
choose syntactic computationally oriented representation object system opted representation independent implementational details object system meaningful expressed ontology reflects purpose reflective reasoning 
approach taken reflect line modern approaches analyse describe knowledge systems 
consensus emerging order understand knowledge systems re knowledge flexible systems model knowledge reasoning processes necessary abstracts implementation details focusses knowledge content system wielinga 
newell newell introduced term level implementation independent descriptions ai systems term knowledge level reflection reasoning problem solving models 
nature reflective task associated meta theories reflection common sense meaning defines object reasoning self purpose reflection 
study reflection discovered different goals reflective reasoning may serve 
common example reflective task reasoning object system meta level reasoning 
task extensively studied literature types reflective tasks received attention 
reflect project studied reflective tasks concerned controlling object problem solver str reasoning limited resources non control related reflective tasks 
include estimate system solve problem principle difficult quality solutions produced object system multiple problem solvers 
reflective tasks studied prototype implementations similar structure 
analysis current state problem solving process 
expectations reflective component analysed measures proposed remedy problem 
order perform reasoning reflective component needs equipped meta theory problem solving processes take place object problem solver 
crucial role meta theories played knowledge deficiencies occur object problem solver 
categories deficiencies identified incomplete information uncertain information inconsistent information information irrelevant information 
meta theories various experiments specific type reflective task extent dependent specifics application domain object problem solver general patterns emerge meta theories 
meta theories reflection problem solving contain general knowledge problems search spaces solvability criteria execution time example meta theory resource limited reasoning task sufficiently general system generate test method 
argue level abstraction modelling object problem solver may high order achieve interesting reflective behaviour 
illustrated number examples abstracted models object system allows formulate interesting useful meta theories 
additionally implementation independent nature models serves basis reusable meta theories meta theories reused different object systems modelled model 
architectural options conceptual approach developed reflect number architectural options remain open 
ways model object system causal connection realised separate representational structure special access procedures defined inspect modify object system directly knowledge typing providing certain view object system access object knowledge 
separate representation option oo possibly combination knowledge typing appears flexible drawback maintaining consistency model actual object problem solver requires complex synchronisation 
second important choice point designer reflective system 
switching paradigm defines distribution activity object meta component 
number options suitable 
third architectural problem synchronisation model object system actual object problem solver 
identified dif ferent strategies synchronising eager synchronisation update changed lazy update piece information needed switching 
choice alternatives trade efficiency complexity 
architectural options explored tested various prototype systems 
experiments derived usefulness adequacy feasibility various options 
choices respect options depend taste style requirements reflective task 
technical advances addition conceptual theoretical advances project technical advances reflection offers 
systems 
reflect approach allows enhance capabilities existing system adding reflective component equipped model object system 
experiments office plan system garp system show little modification object system necessary meta component added 
model needed available specification system form kads models 
second advance reflect approach object problem solvers having re engineer systems 
example experiments existing diagnostic systems combined powerful system adding reflective module need modify individual object components 
second aspect possibility add additional capabilities competence assessment reasoning limited resources flexible control separate reflective modules existing kbs 
interactions components controlled straightforward scheduling module 
third advance reusability 
reflective modules implement general capabilities useful range knowledge systems 
approach taken reflect meta theory separated model object system may expect modules reusable 
example modules implementing explanation flexible control competence assessment largely independent nature object system 
summary conclude approach developed reflect significant application potential field knowledge systems 
argue capabilities described implemented object systems 
precisely architectural framework developed reflect provides modularity software needed seldom achieved 
unresolved issues reflect project laid foundations methodology building modular reusable flexible knowledge systems 
number issues remain studied 
important limitation results project scope 
need proof approach tested various prototypes scale real life applications 
experiments object problem solvers significant size garp complex reflective systems need built 
second area study nature meta theories 
said general patterns meta theories emerge research needed establish general ontology meta theory problem solving basis development meta theoretical specific reflective tasks 
experiments performed project concern assessment modification dynamic structures involved solving problem 
reasoning scope capabilities static knowledge order assess general competence problem solver difficult problem 
insights theoretical foundations diagnostic reasoning give hope meta theories developed generate advanced reflective behaviours certain classes object systems 
akkermans akkermans van harmelen th 
schreiber wielinga 
formalisation knowledge level models knowledge 
international journal intelligent systems 
forthcoming 
bartsch el bartsch van len 
studies experiments reflective problem solvers 
esprit basic research action reflect report ir bsr uva ii reflect consortium august 
bowen kowalski bowen kowalski 
amalgamating language met logic programming 
clark editors logic programming pages 
academic press 
breuker wielinga breuker wielinga 
model driven knowledge sition 
tasso editors topics design expert systems pages amsterdam 
north holland 
clancey clancey 
short lessons 
ai magazine august 
davis davis 
metarules reasoning control 
artificial intelligence 
feferman feferman 
transfinite recursive progressions axiomatic theories 
journal symbolic logic september 
giunchiglia serafini giunchiglia serafini 
multilanguage order theories propositional attitudes 
technical report irst trento italy january 
giunchiglia smaill giunchiglia smaill 
reflection constructive non constructive automated reasoning 
abramson rogers editors meta programming logic programming meta pages bristol june 
mit press 
dai research dept artificial intelligence edinburgh 
godel godel 
uber formal der principia mathematica und ver systeme 
math 
phys 
english translation frege godel source book mathematical logic van heijenoort ed harvard university press cambridge mass hill lloyd hill lloyd 
report preliminary version 
technical report tr computer science department university bristol march revised september 

model prototyping knowledge level 
proceedings expert avignon france pages 
kripke kripke 
outline theory truth 
journal philosophy 
laird laird newell rosenbloom 
soar architecture general intelligence 
artificial intelligence 
maes nardi maes nardi editors 
meta level architectures reflection amsterdam 
north holland 
maes maes 
computational reflection 
technical report free university brussels ai lab 
newell newell 
knowledge level 
artificial intelligence 
perlis perlis 
languages self foundations 
artificial intelligence 
rosenbloom rosenbloom laird newell 
meta levels soar 
meta level architectures reflection pages amsterdam 
north holland 
schreiber th 
schreiber wielinga akkermans 
differentiating problem solving methods 
th 

althoff gaines editors developments knowledge acquisition ekaw pages berlin heidelberg 
springer verlag 
smith smith 
reflection semantics procedural language 
technical report tr mit computer science lab cambridge massachussetts 
smith smith 
reflection semantics lisp 
proc 
th acm principles programming languages pages salt lake city utah 
xerox parc intelligent systems laboratory technical report isl 
tarski tarski 
der den sprachen 
philosophica 
english translation logic metamathematics tarski oxford university press 
turner turner 
truth modality knowledge representation 
pitman london 
van harmelen 
ml formal language kads models expertise 
knowledge acquisition 
special issue kads approach knowledge engineering 
van harmelen 
meta level inference systems 
research notes ai 
pit mann morgan kaufmann london san mateo california 
van harmelen 
definable naming relations meta level systems 
editor proceedings third workshop meta programming logic meta uppsala june 
springer verlag 
weyhrauch weyhrauch 
prolegomena theory mechanized formal reasoning 
ar intelligence 
readings artificial intelligence webber nilsson 
eds tioga publishing palo alto ca pp 

readings representation brachman levesque 
eds morgan kaufman california pp 

wielinga wielinga th 
schreiber breuker 
kads modelling approach knowledge engineering 
acquisition 
special issue kads approach knowledge engineering 

