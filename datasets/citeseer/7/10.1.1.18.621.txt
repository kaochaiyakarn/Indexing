appears oopsla conference proceedings 
interprocedural analyses enable optimizing compilers precisely model effects non inlined procedure calls potentially resulting substantial increases application performance 
applying interprocedural analysis programs written object oriented functional languages complicated difficulty constructing accurate program call graph 
presents parameterized algorithmic framework call graph construction presence message sends firstclass functions 
framework describe implement number known new algorithms 
empirically assess algorithms applying suite medium sized programs written cecil java reporting relative cost analyses relative precision constructed call graphs impact precision effectiveness number interprocedural optimizations 
interprocedural analysis enable substantial improvements application performance allowing optimizing compilers conservative assumptions procedure call boundaries 
program call graph representing possible callees call site procedure interprocedural analyses typically produce summaries effect callees call site summaries effect callers procedure entry 
summaries consulted compiling optimizing individual procedures 
unfortunately presence dynamically dispatched messages invocations computed functions set possible callees call site difficult compute precisely necessitating interprocedural analysis compute possible classes message receivers possible function values invoked 
effect interprocedural dataflow control flow analysis needed build data structure interprocedural analysis operates 
number algorithms proposed solve dilemma typically computing program call graph simultaneously performing interprocedural dataflow analysis 
algorithms different trade offs precision resulting call graph associated dataflow information cost computing call graph 
algorithm cost precision result dean current address digital equipment western research lab university avenue palo alto ca pa dec com impacted application programming style depth breadth class hierarchies relative frequency message sends versus direct procedure calls prevalence applications computed function values considered selecting call graph construction algorithm 
main contributions developing common framework describing wide range existing call graph construction algorithms assessing precision cost algorithms programs substantial size 
section lattice theoretic model contextsensitive call graphs 
element lattice corresponds possible call graph program call graphs lattice ordered terms relative precision 
section model generalized call graph construction algorithm describe different families call graph construction algorithms 
formalizing model call graphs highlight important similarities differences algorithms descriptions comparisons precise previous 
specify properties required safe solution cases compare precision call graphs constructed different algorithms 
model leads natural parameterized implementation framework implemented framework number call graph construction algorithms vortex optimizing compiler system dean 
call graph model algorithmic framework helped identify new interesting points design space call graph construction algorithms 
section empirically assess precision cost implemented algorithms applying suite cecil chambers java gosling programs 
benchmark applications order magnitude larger evaluate previous enabling assess algorithm scales larger programs 
studying quite different object oriented languages uses dynamically dispatched messages class functions extensively mixes dynamically dispatched messages traditional non object oriented operations investigate impact programming style algorithm effectiveness 
additional precision produced call graph algorithms value exploited effectively client optimizations 
assess bottom line impact call graph precision constructed call graphs drive interprocedural analyses optimizations reporting final execution speed executable size 
section discusses additional related section offers 
call graph construction object oriented languages david grove greg defouw jeffrey dean craig chambers department computer science engineering university washington box seattle washington usa grove chambers cs washington edu modelling call graphs subsection general model program call graphs informal terms 
formalize model lattice theoretic terms 
informal model call graphs program call graph directed graph represents calling relationships program procedures 
context insensitive call graph procedure represented single node graph 
node indexed set call sites call site source zero edges nodes representing possible callees site multiple callees single site possible dynamically dispatched message send application computed function 
shows context insensitive call graph corresponding example program 
context sensitive analysis procedure may analyzed separately different calling contexts context sensitive versions procedure called contour shivers 
model context sensitive analyses call graph having nodes call graph correspond contours call edge call site contour connects appropriate contour callee procedure 
different context sensitive analyses differ determine set contours create procedure contours select targets call 
depicts possible context sensitive call graph example program distinguishes calls max integer floating point parameters 
context insensitive analysis modeled restricting call graph single contour source level procedure 
algorithm specific decisions contour selection function information call site calling contour possible classes actual parameters call selects set callee contours create call graph link call site 
addition set callees call site contour call graph records set classes formal parameter local variable result procedure represented contour 
sets classes represent possible classes values stored corresponding variables run time 
record class sets global variables introduce special root terms procedure function method interchangeably 
system treats uniformly 
procedure main return procedure return max procedure return max procedure return max example program call graphs main max main max max example program context insensitive context sensitive contour local variables correspond global variables program 
module scopes modeled similarly 
contours represent lexical nesting relationships presence lexically nested procedures 
contour pointer lexically enclosing contour may global contour global contour lexically enclosing contour 
fashion avoid losing precision context sensitive analysis lexically nested procedures access free variables 
languages class function values function pointers treat source level occurrence function definition function address taken creating new class single method named apply body body function 
function lexically nested function class apply method considered lexically nested function 
evaluating function definition address function treated instantiation sites new class invoking function value treated sending apply message object representing function value 
encoding lets focus solely analyzing flow class instances program 
need record sets possible classes instance variable manner similar class sets local variables 
support array classes introduce single instance variable array class model elements array 
support context insensitive sensitive analyses instance variable contents instance variable declaration modeled instance variable contours 
instance variable contour maintains single set classes representing possible classes values stored instance variable contour run time 
analyses context insensitive respect instance variables single instance variable contour instance variable declaration 
precise analyses maintain separate instance variable contours inheriting subclass enabling analysis track possible classes instance variable separately 
algorithm specific decisions instance variable contour selection function model extend support lexically enclosing contour selection function maps contour set lexically enclosing contours 
extension allow model flexible analysis lexical environments supported infinitary control flow analysis nielson nielson 
similar strategy pizza implementation translate closures java odersky wadler 
returns set appropriate instance variable contours particular instance variable load store operation class set information object loaded stored 
analyses precise analysis classes instance variable contents 
treating different instantiation sites class leading distinct analysis time classes distinct instance variable contours simulate effect templates parameterized types relying explicit parameterization source program 
model analyses associating source level class multiple class contours 
class contour selection function applied class instantiation sites select set appropriate class contours model result instantiation 
previously described class information generalized class contour information including sets associated variables procedure contour actual parameter sets procedure contour selection function instance variable contour selection function information computed intraprocedural analysis individual contours 
summarize single general model procedure call graph encode context sensitive contextinsensitive call graphs 
wide range context sensitive call graphs represented choosing different values parameterizing functions contour selection function instance variable contour selection function class contour selection function 
lattice theoretic model call graphs subsection formalizes intuitive notions previous subsection lattice theoretic ideas 
formalization ensures grounded understanding call graphs provides vocabulary discussing particular call graph safe sound approximation real call graph call graph precise 
formalize possible outputs contour selection functions giving formal structure help comparing algorithms 
shows interesting elements regions call graph lattice 
traditional dataflow analysis kildall kam ullman opposite conventions interpretation cousot cousot top lattice element represents best possible optimistic call graph bottom element represents worst possible conservative call graph 
lattice set elements associated partial ordering elements pair elements set contains unique upper bound element unique greatest lower bound element 
downward semilattice lattice greatest lower bounds required 
set possible call graphs particular model context sensitivity form downward semilattice term domain refer downward semilattice 
dps supporting lattice constructors constructor pow maps input partial order lattice dps subset powerset defined partial order defined terms follows elements dps greatest lower bound member family constructors standard tuple constructor takes input partial orders generates new partial order cross product defined terms pointwise follows input partial orders downward semilattices downward semilattice greatest lower bound tuples tuple pointwise greatest lower bounds elements 
constructor map function constructor takes input unordered set partial order generates new partial order partial order defined terms follows partial order downward semilattice downward semilattice elements greatest lower bound constructor takes input partial order generates downward semilattice lifting union tuple domains elements elements partial order union individual tuple partial orders partial order es 
regions call graph lattice domain ideal diagram depicts lattice elements call graphs 
order call graph depict cone conservative precise 
top bottom elements corresponding empty call graph complete call graph respectively denoted point ideal identifies real usually uncomputable call graph described precisely greatest lower bound call graphs corresponding actual program executions 
particular program execution induces call graph cone ideal labeled opt optimistic 
call graph produced correct call graph construction algorithm cone ideal labeled sound 
sound opt dps dps dps dps bottoms powerset bottoms dps dps dps dps dps dps bottoms glb glb glb glb glb glb dom glb dom tuple tuple tuple call graph domain define call graphs terms algorithm specific parameter partial orders prockey classkey 
prockey parameter defines space possible contexts context sensitive analysis functions output domain algorithm procedure contour selection function 
parameter defines space possible contexts separately tracking contents instance variables output instance variable contour selection function 
classkey parameter defines space possible contexts context sensitive analysis classes output algorithm class contour selection function 
ordering relation partial orders derived domains indicates relative precision elements element precise conservative 
addition parameterizing partial orders call graphs rely unordered sets various program features class set source level class declarations set source level instance variable declarations procedure set source level procedure declarations variable set program variable names callsite set program call sites set source level loads instance variables set source level stores instance variables 
input parameter domains particular call graph construction algorithm sets abstracting program features construct domain call graphs produced algorithm shown 
definitions mutually recursive intend definitions correspond smallest solution equations 
context sensitive algorithms introduce additional mutually recursive definitions cause callgraph domains infinitely tall 
guarantee termination contour selection functions incorporate widening operation cousot cousot 
example agesen cartesian product algorithm uses elements domain component prockey domain elements 
presence closures lead infinitely tall call graph lattice agesen terms problem recursive customization describes methods detecting applying widening operation agesen 
components call graph instance variable contours procedure contours 
instance variable contours enable analysis dataflow instance variable loads stores 
component encodes source level declaration contour representing second component refines component restricting contexts cg cg cg definition call graph domain tuple class classkey pow tuple pow tuple procedure prockey map variable map callsite map map pow callgraph tuple contour applies 
final component represents set class contours stored instance variable contour 
similarly components procedure contour encode source level procedure declaration context contour applies 
third component tuple represents lexically enclosing contour analyze free variables 
fourth component maps local variables formal parameters contour procedure set class contours representing classes values may stored variable 
variable mapping contains entry special token return represents set class contours returned contour 
final components procedure contour encode inter contour flow data control caused procedure calls instance variable loads instance variable stores respectively 
soundness call graph sound safely approximates possible program executions conservative call graphs corresponding possible program executions 
call graph domain downward semilattice greatest lower bound program execution call graphs exists notate ideal call graph sound iff equal conservative ideal unfortunately general impossible compute ideal directly general infinite number possible program executions observation constructive test soundness constructively call graph sound procedure contour language specific intraprocedural dataflow constraints relate class contour sets contour variables formals locals special result token satisfied account result tokens callee contours call site contents accessed instance variable contours instance variable load site formal parameter callee contour call site formal class contour set conservative class contour set corresponding actual parameter call site instance variable contour accessed instance variable store site contents instance variable contour conservative class contour set value stored store site ideal cg instance variable contour contents contour conservative contents instance variable contour conservative key 
constraint instance variable contents ensures different degrees context sensitivity instance variables coexist ensuring class contour stored instance variable level context sensitivity conservative class contour appears contents conservative views instance variable 
algorithmic design space section generalized algorithm call graph construction 
generalized algorithm parameterized dimensions selecting different values parameters express previously described call graph construction algorithms 
shows schematic view generalized algorithm 
algorithm maintains worklist contours potentially unsound initialized initial call graph construction process 
inner loop algorithm consists evaluating current call graph selecting possible actions current call graph considered imprecise far ideal lattice algorithm may apply nonmonotonic improvement improve precision current call graph 
worklist empty current call graph sound algorithm terminates 
algorithm applies monotonic refinement removing contour worklist processing sound moving resulting call graph step closer soundness termination 
key parameters generalized algorithm choice domains prockey classkey associated contour selection functions section method construct initial call graph section available nonmonotonic improvement operations section 
section discusses monotonic refinement algorithm instances 
section contains comparison relative precision call graphs produced various algorithms described section section describes aspects implementation generalized algorithm 
generalized call graph construction algorithm call graph sound 
final call graph call graph unsound 
monotonic refinement moves call graph lattice select step additional precision desired 
non monotonic improvement moves call graph lattice call graph initial call graph construction contour discrimination described section call graph lattice parameterized domains prockey classkey define algorithm specific 
prockey part algorithm procedure contour selection function call site applicable method selection function computes elements prockey model information call site relevant invoked method 
procedure generalized algorithm maintains table mapping prockey elements associated contours 
appropriately selecting prockey values algorithm indicates call sites procedure share contours separate contours 
desired contour selection function may replace existing contours contours redirecting callers old contours appropriately 
may done avoid producing contours method adding general contours increase portion analysis adding specific contours 
similarly models possible outputs instance variable contour selection function applied instance variable load store site model relevant information site represents ability algorithm track contents single source level instance variable multiple ways 
classkey models algorithms ability distinguish different instances single class primarily track contents instance variables different class contours single class separately 
instantiation site class algorithm class contour selection function computes element key classkey model context creation downstream general framework uses pair class key class contour result instantiation 
various parameterizing domains interrelated example different classkey elements giving rise different prockey elements support specializing analysis procedures instance variables different class contours 
typical values domains fall general categories single point lattice selecting single point lattice lattice value prockey classkey results degenerate case contextinsensitive analysis 
algorithms cfa shivers shivers palsberg schwartzbach basic algorithm palsberg schwartzbach hall kennedy call graph construction algorithm fortran hall kennedy lakhotia algorithm building call graph languages higher order functions lakhotia examples instantiation framework 
algorithms perform context sensitive analysis instance variables classes single point lattice classkey domains independently choice prockey domain 
levels dynamic call chain commonly mechanisms distinguishing contours vector enclosing calling contours call site select target contour 
degenerates single point lattice context insensitive algorithm prockey corresponds analyzing callee contour separately call site classkey corresponds treating distinct instantiation site class separate class contour 
algorithm may fixed value program shivers cfa family algorithms shivers shivers cfa extension palsberg schwartzbach algorithm 
adaptive algorithms may different levels different regions call graph flexibly manage trade analysis time precision 
number algorithms unbounded finite values proposed ryder call graph construction algorithm fortran ryder callahan extension ryder support recursion callahan emami alias analysis algorithm emami treat non recursive path call graph creating new context 
alt martin developed aggressive call graph construction algorithm pag system levels recursion alt martin 
steensgaard developed chain algorithm handles nested lexical environments applying widening operation class sets formal parameters entries recursive cycles call graph steensgaard 
object oriented programs define cfa family algorithms denotes degree context sensitivity prockey domain denotes degree context sensitivity classkey domain 
parameter class sets commonly mechanism distinguishing contours abstraction call site actual parameters 
example abstraction alias relationships actual parameters basis context sensitivity algorithms interprocedural alias analysis landi wilson lam 
similarly algorithms interprocedural class analysis information classes actual parameters drive contour selection functions contour keys agesen cartesian product algorithm cpa agesen drawn domain key tuple single class contours formal parameter 
call site contour selection function computes cartesian product actual parameter class sets contour selected created element cartesian product 
eager splitting component phase plevyak iterative refinement algorithm plevyak equivalent straightforward form cpa 
worst case cpa may require contours analyze call site number arguments call site 
avoid requiring unreasonably large number contours agesen implements variant cpa term bounded cpa cpa uses single context insensitive contour analyze call site number terms cartesian product actual class sets exceeds threshold value 
experiments suggest bounded version cpa scales realm small benchmark programs 
example instr sched benchmark line cecil program cpa analysis completed seconds cpa analysis required seconds 
observed similar slowdowns larger java benchmarks lines 
new algorithm dub simple class sets scs draws contour keys domain key tuple sets class contours formal parameter 
call site contour selection function simply selects contour possibly creating new contour key exactly matches tuple class sets appear actual parameters 
re analysis contour actual class sets call site change previous values new contours selected created exactly match new actual parameters call 
bounded variant scs defined limit number contours created procedure falling back context insensitive summary procedure contour creation budget exceeded 
languages cecil chambers strongtalk bracha griswold expressive optional parameterized static type declarations abstraction static types actual type parameters provide hints contour selection function may effective 
pande algorithm interprocedural class analysis pande ryder built table selected algorithm descriptions algorithm prockey classkey cfa single point lattice single point lattice single point lattice scs single point lattice single point lattice cpa single point lattice single point lattice cfa single point lattice single point lattice cfa landi alias analysis landi uses extension landi conditional points information basis context sensitivity 
cpa scs style domains useful domains possible class es object instance variable accessed select right instance variable contour tracking contents instance variables different inheriting subclasses separately 
arbitrary plevyak invokes graph encodes arbitrary mapping contour call sites callee contours plevyak 
clearly flexible mechanisms lack structure difficult easily explain understand algorithms rely 
table domains chosen prockey classkey flow sensitive algorithms experimentally assessed section 
possible initial call graphs possible element call graph lattice domain initial call graph algorithms aware start opposite extremes top element call graph lattice 
practice algorithms really call graph global scope contour initial contour main function variables contours mapped empty class sets 
starting point majority algorithms including cfa cfa shivers shivers cartesian product algorithm cpa agesen plevyak iterative algorithm plevyak chien 
initial call graph algorithms apply monotonic refinement ensures reaching best possible fixed point solution algorithm 
bottom element call graph lattice complete call graph call sites calling contours variables holding possible classes 
practice filtered version unnecessary call arcs classes removed statically available information simple analysis selector removes call edges call sites contours incompatible names numbers arguments 
static uses static types variables type signatures procedures improve selector removing call arcs statically type correct removing elements variable class set conform variable static type 
intra improves selector static depending language statically typed performing intraprocedural analysis procedure compute precise approximations class sets local variables outgoing call arcs diwan modula optimizer diwan 
rta improves static performing bacon sweeney rapid type analysis rta linear time optimistic reachability analysis eliminate classes created methods invoked bacon sweeney 
rta applied dynamically typed languages build version rta selector unif improves rta performing near lineartime unification algorithm identify disjoint components program dataflow graph associate set reachable classes methods disjoint component defouw rta pessimistically assumes dataflow graph contains single disjoint component computes single set reachable classes methods entire program 
algorithm constructing unif adaptation steensgaard algorithm near lineartime points analysis programs steensgaard 
flavors sound legal solution initial call graph algorithms wish incur expense monotonic refinement produce sound call graph true algorithms listed start flavor apply non monotonic improvement improve precision initially imprecise presence class functions may call graphs close imprecise call site function assumed invoke class function program matching number arguments static type signature 
call graphs unif may reduce problem 
potentially interesting new place start call graph construction algorithms prof optimistic call graph constructed profile data runs program 
seeding call graph context insensitive profile derived call arcs sets classes enable context insensitive algorithms reach final sound solution rapidly starting sacrificing precision 
profile data call chain context grove seed context sensitive algorithms degrading final solution 
monotonic refinement monotonic refinement removes unsound contour worklist processes monotonically extending moving lower contour domain locally sound 
involves performing intraprocedural class analysis contour class sets formals potentially adding class sets local variables adding new contours call sites load sites store sites 
intraprocedural analysis analysis message sends consists steps set potentially invoked methods computed current class contour sets arguments perform compile time method lookup 
potentially invoked method contour selection function selects creates set contours method called call site actual argument class contour sets contours bound call site calling contour 
new contours created part contour selection added worklist 
class contour sets actual parameters added class contour sets corresponding formal parameters callee contour greatest lower bound operation merge class contour sets 
formal class contour set changes result callee contour added worklist may locally unsound need reanalysis 
set class contours returned message send greatest lower bound class contour sets bound return token callee contour 
analysis instance variable loads stores similar algorithm specific instance variable contour selection function selects creates set instance variable contours instance variable accessed subject soundness restrictions discussed section typically instance variable access site class contour set object accessed 
contours bound load store site accessing contour 
instance variable store class contours value stored added contents class contour set accessed instance variable contours 
instance variable load set class contours returned load greatest lower bound contents class contour sets accessed instance variable contours 
class instantiation sites class contour selection function generates set class contours typically class instantiated information current procedure contour 
analysis variable assignments traverses lexical contour links locate set class contours associated accessed variable 
assignment assigned class contour set added variable associated class contour set associated class contour set returned result 
intraprocedural analysis kinds statements expressions method language specific usually straightforward 
non local set class contours read intraprocedural analysis including result set callee contour contents set instance variable contour set associated global lexically enclosing variable generalized algorithm records dependency link set reading contour 
set grows dependent reading contours placed worklist set class contours intraprocedural analysis depended changed 
non monotonic improvement phase monotonic refinement results output call graph lower lattice conservative input call graph 
contrast output phase non monotonic improvement call graph higher lattice input call graph 
algorithms non monotonic improvement classified informally local global local non monotonic improvement characterized series small incremental steps call graph lattice 
example single intraprocedural clean pass performed compute intra selector static viewed local non monotonic improvement step procedure 
example local non monotonic improvement notion exact unions 
sound call graph variable class set contain class sets associated data flow arcs 
algorithms starting lead class sets proper supersets union class sets 
call graph improved making unsound replacing variable class set exact union class sets 
narrowing may enable downstream removals unreachable call arcs 
process continues fixed point reached 
face recursion call graph produced starting applying local non monotonic improvement exact unions completion precise call graph produced starting applying monotonic refinement completion 
bottom strategy may produce acceptable results quickly top strategy interrupted time resulting sound solution may useful component program development environment sound necessarily optimal call graph recomputed incrementally programming change 
global non monotonic improvement derived shivers proposal analysis shivers 
local non monotonic improvement may examine large regions call graph single improvement step may introduce new contours call graph 
occurs undesirable property current call graph detected corrected making jump current call graph potentially unsound call graph higher lattice 
undesirable property considered worth resolving source imprecision identified additional contours introduced strategic points hopes causing subsequent phases monotonic refinement rebuild call graph re introducing undesired imprecision 
implemented algorithm aware includes global non monotonic improvement plevyak iterative algorithm plevyak chien 
algorithm considers message send possibly invoked method undesirable property call graph attempts resolve non monotonic improvement 
control strategy computes candidate sound call graph running monotonic refinement completion followed check global non monotonic improvement 
refinement desired new contours created recorded invokes graph data structure contour selection functions 
algorithm iterates resetting call graph back reapplying monotonic refinement completion reach candidate sound call graph 
process repeats imprecisions resolved introducing new contours iterations performed 
weakness coarse grained control strategy large amounts monotonic refinement analysis time may spent reaching undesirable fixed points 
generalized algorithmic framework offers possibility monotonic refinement non monotonic improvement finer grain reaching high quality solutions faster 
relative algorithmic precision depicts relative precision final products various call graph construction algorithms described sections assuming procedure specialization performed compilation preserve contour level view program matches compilation configurations experiments described section 
algorithm depicted higher lattice algorithm input programs precise exists program precise cfa family algorithms form infinitely tall infinitely wide sublattice 
cfa cfa subfamily algorithms stands arbitrary finite value infinite values represented cfa family algorithms cfa shown 
specialization assumption cfa scs cpa produce call graphs identical effective precision 
contours created algorithms may superficially quite different collapsed reflect lack procedure specialization call graphs contain exactly call edges class sets 
costs computing call graphs 
worst case building cfa call graph requires creating infinite number contours building scs call graph requires creating exponential number contours building cpa call graph requires creating polynomial number contours 
despite poor worst case behavior experimental results reported section suggest scs may efficient algorithms 
implementation generalized algorithmic framework useful tool exploring algorithmic design space understanding previously described algorithms leads flexible implementation framework 
implementation assume number arguments procedure call bounded constant function program size 
relative precision computed call graphs ideal selector static rta dynamic intra static intra dynamic unif dynamic rta static unif static cfa scs cfa cfa cfa cfa cfa cfa cfa cfa cfa cfa cfa cfa 
cfa cfa 
cfa 
cpa scs cpa cfa prof optimistic sound prof prof prof prof 
interprocedural analysis vortex optimizing compiler infrastructure dean includes contour contour key classes related data structures body centralized code executing generalized algorithm monotonic refinement 
currently working adding support non monotonic improvement 
instantiating framework consists implementing concrete subclass ipca algorithm class implements contour selection functions 
mix classes provided implement common policies managing procedure instance variable class contours 
framework consists approximately lines cecil code instantiations measured section implemented additional lines code 
important considerations implementation framework managing time space tradeoffs 
previous systems explicitly construct entire interprocedural data control flow graphs 
approach viable small programs memory requirements quickly unreasonable context sensitive analysis large programs 
implementation explicitly store sets classes visible contour boundaries corresponding formal parameters local variables procedure return values instance variables 
derived class sets intra interprocedural data control flow edges re computed demand 
greatly reduces space requirements analysis increases computation time dataflow relationships continually recalculated 
analysis time interprocedurally algorithms larger programs greatly reduced significant loss precision eagerly approximating class sets set union operations 
number elements union exceeds threshold value compaction phase examines elements see classes union share common parent class 
candidate common parent fewest number subclasses included union selected subclasses added union 
approximation reduces size union vortex supports compact cone representation class set corresponding class subclasses dean may reduce number times contents change eagerly performing subsequent class add operations 
example largest cecil programs eager approximation reduced cfa analysis time factor resulting slowdowns resulting optimized executables 
currently intraprocedural phase interprocedural class analysis analyzes entire procedure 
implemented sparse procedure representation performs slicing remove details non object data control flow 
initial experience sparse representation little impact cecil programs virtually dataflow reduced analysis time memory usage smaller java benchmarks 
unfortunately implementation complete experiments section utilize old representation 
experimental assessment determine different interprocedural analysis algorithms perform practice implemented half dozen algorithm families framework assessed criteria relative precisions call graphs produced various algorithms 
relative costs various algorithms measured terms analysis time memory space 
differences call graph precision translate differences effectiveness client interprocedural analyses terms program execution speed executable size 
remainder section presents experimental results answering questions specific call graph construction algorithms simple selector cecil static java rta extended support class functions multi method dispatching cfa cpa scs instantiations kl cfa family algorithms 
section addresses questions presenting data analysis time space call graph precision 
sections address remaining question section reports impact interprocedural optimization section focuses individual contributions interprocedural optimizations 
performed experiments suite medium sized cecil java programs shown table 
experiments performed sun ultra model mb memory 
cost precision call graph construction algorithms comparison effectiveness algorithms analysis time space costs precision resulting call graph 
table reports algorithm program pair analysis time seconds growth process size analysis mb average number contours procedure average number times procedure analyzed 
difference numbers represents average number times procedure contours 
example analysis instr sched program scs algorithm took seconds process size grew mb analysis 
average contours created procedure procedure analyzed times contours procedure analysis re analysis take roughly amount time approximately analysis time spent contours see trends data excluding standard libraries 
cecil programs compiled line standard library 
java programs include line standard library 
cecil share approximately lines common support code type checking algorithms completely separate written different people 
java translators common code developed different people 
number roughly approximates actual maximum heap size sensitive heuristics garbage collector decide launch full collection expand virtual memory 
table benchmark applications program lines description cecil programs richards operating systems simulation deltablue incremental constraint solver instr sched global instruction scheduler typechecker typechecker old cecil type system new tc typechecker new cecil type system compiler old version vortex optimizing compiler java programs toba java bytecode code translator java cup parser generator espresso java source bytecode translator javac java source bytecode translator javadoc documentation generator java abstractions sets hash tables number clients 
larger cecil programs cfa infeasible compiler cfa fails complete hours 
scs cpa algorithms different contour discrimination strategies achieve approximately level context sensitivity 
cpa asymptotically better worst case running time programs benchmark suite scs uniformly faster 
larger relative increase analysis time cfa cfa java cecil 
due difference idioms languages 
cecil just textual occurrence object constructor class user shaded cells correspond configurations complete hours exhausted available virtual memory mb 
average number contours procedure cfa analysis cecil programs greater procedures loop analyzed scs contours 
limited context sensitivity partially compensates cecil user defined control structures 
table analysis time secs heap space mb contours procedure analyses procedure simple rta cfa scs cpa cfa cfa cfa cfa richards sec mb sec mb sec mb sec mb sec mb sec mb sec mb sec mb sec mb deltablue sec mb sec mb sec mb sec mb sec mb sec mb sec mb sec mb sec mb instr sched sec mb sec mb sec mb sec mb sec mb sec mb sec mb sec mb sec mb typechecker sec mb sec mb sec mb sec mb new tc sec mb sec mb sec mb sec mb compiler sec mb sec mb sec mb toba sec mb sec mb sec mb sec mb sec mb sec mb sec mb sec mb java cup sec mb sec mb sec mb sec mb sec mb sec mb sec mb espresso sec mb sec mb sec mb sec mb sec mb sec mb sec mb javac sec mb sec mb sec mb sec mb sec mb sec mb javadoc sec mb sec mb sec mb sec mb sec mb sec mb sec mb analysis time flow insensitive algorithms simple rta appears roughly linear size program practice asymptotically worst case suggests scale gracefully larger programs 
fact running rta combination optimization described section usually results net reduction compile time due removal unreachable procedures 
increasing value cfa algorithms small cecil programs result large increase analysis time routines called small number call sites 
start see expected exponential blow analysis time slightly realistic instr sched benchmark includes defined constructor method 
contrast java programs tend line object constructors new expressions 
tends larger increase number class contours cfa java cecil 
analysis times memory requirements performing various interprocedurally flow sensitive algorithms larger cecil programs strongly suggest algorithms scale realistically sized programs written language cecil 
scalability better java programs analysis times linear program size 
appears large percentage analysis time consumed contour reanalysis 
suspect majority reanalysis steps especially algorithms scs cpa allow contour incoming formal sets widened due dependencies results instance variable reads new class added contents instance variable accessing contours 
investigating seeding instance variable contents class sets derived dynamic profile data algorithms cfa scs cpa cfa perform context insensitive analysis instance variables 
may result substantial reductions contour reanalysis analysis time sophisticated algorithms feasible larger cecil programs 
re analysis time sharply reduced appears memory requirements may limit scalability interprocedurally flow sensitive algorithms 
previous assessed precision call graph construction algorithms reporting various metrics average cardinality class sets average number callees call site contour 
reporting statistics granularity contours useful comparing various context sensitive algorithms reflect effective precision call graph multiple versions procedure compiled analysis time contours 
previous systems cooper plevyak chien contours created interprocedural analysis shaded cells correspond configurations complete hours exhausted available virtual memory mb 
table average static dynamic callee procedures call site simple rta cfa scs cpa cfa cfa cfa cfa richards deltablue instr sched typechecker new tc compiler toba java cup espresso javac javadoc drive procedure specialization 
vortex compiler perform procedure specialization contours summarizing contour level information procedure granularity accurately reflect effective call graph precision seen stages vortex 
table reports static dynamic computed weighting call site execution frequency sample program execution number callees call site procedure level granularity 
observe interprocedurally flow sensitive algorithms cfa produce call graphs substantially precise simpler linear time algorithms benchmarks analysis completed context sensitive algorithms provide additional precision context insensitive cfa algorithm 
rta algorithm provides relatively small additional precision simple cecil programs successful java programs 
high degree average polymorphism call sites cecil programs flow insensitive algorithms due inaccuracy modeling flow class functions 
benchmarks dynamic degree polymorphism call sites usually higher static degree polymorphism 
difference quite large strongly suggests purely static metrics may accurately predict impact program execution speed 
precision data expect flow sensitivity cfa provide main improvements bottom line execution speed flow insensitive algorithms worse context sensitive algorithms better 
impact assess importance call graph precision bottom line performance impact interprocedural optimizations compared benchmark performance pair base configurations interprocedural optimizations pairs configurations performing interprocedural optimizations building call graphs produced different construction algorithms 
base configuration represents aggressive combination intraprocedural limited interprocedural optimizations include intraprocedural class analysis johnson chambers ungar hard wired class prediction common messages cecil programs deutsch schiffman chambers ungar splitting chambers ungar class hierarchy analysis dean inlining static class prediction dean closure optimizations cecil suite traditional intraprocedural optimizations common subexpression elimination constant propagation folding dead assignment elimination redundant load store elimination 
applied optimizations vortex compiler produce code compiled gcc produce executable code 
base profile configuration augments base class prediction hlzle ungar grove 
constructed call graph base ip configuration augmented base interprocedural analyses enabled intraprocedural optimizations base better class analysis side effect constructing call graph formal local global instance variable associated set classes instances may stored variable 
intraprocedural class analysis exploits sets upper bounds precise possible classes enabling better optimization dynamically dispatched messages 
mod analysis interprocedural analysis computes procedure set global variables instance variables may possibly modified calling procedure 
number intraprocedural analyses exploit information accurately estimate potential effect procedure calls local dataflow information 
exception detection interprocedural analysis identifies procedures guaranteed raise exceptions execution 
information exploited streamline calling conventions simplify intraprocedural control flow downstream calls exception free routines 
escape analysis interprocedural escape analysis identifies class functions guaranteed live lexically enclosing environment enabling function objects environments stack allocated kranz 
optimization applied cecil benchmarks 
side effect constructing call graph compiler identifies procedures unreachable program execution 
compiler compile unreachable procedures resulting substantial reductions code size compile time 
base ip profile configuration augments base ip configuration profile guided class prediction 
dynamic profile data derived base configuration profile configurations 
methodology may slightly benefits class prediction base ip profile configurations eliminates additional variable experiments 
displays application execution speed normalized speed application base configuration raw data appendix 
bars various profile configurations shown bars corresponding non profile versions highlighting additional benefit application execution speed base rta cfa scs cpa cfa cfa simple cfa cfa profile richards deltablue instr sched typechecker tc compiler speedup cecil toba java cup espresso javac javadoc speedup java dynamic profile data configuration 
pair bars labeled call graph construction algorithm produce call graph algorithm base version 
draw data programs simple interprocedurally algorithms simple rta produced little improvement execution speed high average degree polymorphism call sites shown table 
cecil programs interprocedurally flow sensitive algorithms cfa better provided significant boost performance speeds ranging times faster 
smaller cecil programs interprocedurally flow sensitive static analysis subsumed profile guided class prediction profile data remained important larger cecil programs 
context sensitivity important measurable impact typechecker benchmark 
suggests feasible apply context sensitive analysis larger cecil programs see additional benefit 
java programs interprocedural optimizations enabled modest improvements base configuration 
emphasized speedups relative optimized base configuration comparison base configuration average times faster sun jdk interpreter times faster sun jdk just time dynamic compiler times faster toba translator java times faster vortex implementation dean optimizations due gcc back 
optimization executable sizes interprocedural analysis configurations 
java programs executables smaller base configuration flow sensitive algorithms typically reduced executable size algorithms 
cecil programs decreases executable size ranged compiler benchmark instr sched benchmark 
interprocedurally algorithms enabled reductions additional flow insensitive algorithms 
context sensitive call graphs measurably improve effectiveness benchmark programs 
relative value interprocedural analyses results previous section summarize impact number interprocedural analyses optimizations single data point 
determining total speedup attributable optimization useful deciding analyses valuable include compilers 
partially answer question built measured variations base ip scs configuration instr sched javac benchmarks variation excluded interprocedural analyses 
comparing execution time variant full base ip scs configuration identify analyses substantial performance impact 
virtually improvement execution speed due class analysis 
version java system currently implement null pointer dereference checks multithreading dynamic class loading comparisons java implementations evidence base configuration efficient 
base ip scs excluded class analysis significantly slower version interprocedural optimizations enabled 
versions excluded interprocedural optimizations showed slight decreases execution time version optimizations enabled differences small considered significant 
interprocedural escape analysis little impact cecil programs vortex cecil implementation allows programmers annotate closures lifo virtually closures benchmarks annotated lifo 
vortex compiles ignoring annotations modified base configurations run half speed base configurations base ip scs configurations run essentially speed reported previously 
interprocedural escape analysis sufficient enable virtually closure allocation optimizations enabled source level annotations 
chose faster base configuration previous section avoid benefits interprocedural analysis cost non lifo closures non annotated base configuration somewhat reduced resorting interprocedural analysis simple intraprocedural techniques vortex implement due prevalence lifo annotations cecil source code 
related addition prior studying particular algorithms call graph construction discussed section exists large body prior interprocedural analysis optimization 
typically studied impact single interprocedural analysis context single language 
closely related trio parameterized algorithms interprocedural flow analysis higher order functional languages stefanescu zhou jagannathan weeks nielson nielson 
frameworks similar support construction context sensitive call graphs parameterized allowing express variety algorithms 
jagannathan weeks nielson nielson model formally program semantics treat interprocedural analysis interpretation formalize solution space interprocedural analysis 
frameworks general directly support non monotonic improvement initial call graphs object oriented features message passing context sensitive analysis instance variable class contours 
extend considering issue cross algorithm precision comparisons implementing framework optimizing compiler assessing impact interprocedural analysis empirically 
additionally framework stefanescu zhou appears limited various flavors dynamic call chain information contour keys 
agesen templates informal explanatory device description constraint graph instantiations cfa cfa plevyak algorithm agesen 
templates similar contours serve group summarize local constraints introduced procedure 
agesen formally define templates considers context sensitivity prockey domain 
hlzle agesen compared effectiveness interprocedural class analysis cartesian product algorithm profile guided class prediction optimization self programs hlzle agesen 
little performance difference optimizing configurations profile guided class prediction interprocedural class analysis techniques 
results cecil language similar self differ flow sensitive interprocedural class analysis appears significantly better profile guided class prediction 
developed conceptual model implementation framework encompasses wide range algorithms call graph construction object oriented languages 
framework empirically assessed variety algorithms applying suite medium sized applications written different object oriented languages 
interprocedural analyses especially interprocedural class analysis enabled substantial speedups cecil programs modest speedups java programs 
languages additional precision call graphs constructed interprocedurally flow sensitive algorithms large impact effectiveness client interprocedural analyses subsequent optimizations 
precise contour level call graphs constructed context sensitive algorithms yield correspondingly large increases application performance absence producing separate specialized compiled code procedure contour 
larger cecil programs may benefit experiments demonstrated scalability problems prevent context sensitive algorithms applied domain small benchmark programs 
search scalable effective call graph construction algorithm programs heavy polymorphism dynamic dispatching remains open problem 
hopeful new algorithmic instantiations section extensions unif local nonmonotonic improvement prof initial call graph result algorithm offers scalability reasonable precision 
important area investigating techniques support incremental reconstruction program call graph derived interprocedural information presence program changes 
incremental algorithms widen applicability interprocedural analysis enabling applied new domains day day program development environments support dynamic class loading 
acknowledgments michael ernst urs hlzle anonymous oopsla reviewers provided valuable feedback earlier drafts 
david bacon encouraged develop precision comparisons context sensitive algorithms depicted 
exact unions local non monotonic improvement due chris colby 
wish bjarne steensgaard helpful discussions area 
research supported part nsf number ccr nsf young investigator award number ccr office naval research contract number intel foundation graduate fellowship gifts sun microsystems ibm xerox parc pure software edison design group 
agesen ole agesen 
constraint type inference parametric polymorphism 
international static analysis symposium september 
agesen ole agesen 
cartesian product algorithm simple precise type inference parametric polymorphism 
proceedings ecoop aarhus denmark august 
springer verlag 
agesen ole agesen 
concrete type inference delivering object oriented applications 
phd thesis stanford january 
tr 
alt martin martin alt florian martin 
generation efficient interprocedural analyzers pag 
proceedings second international symposium static analysis pages 
springer verlag september 
bacon sweeney david bacon peter sweeney 
fast static analysis virtual function calls 
oopsla conference proceedings san jose ca october 
bracha griswold gilad bracha david griswold 
strongtalk typechecking smalltalk production environment 
proceedings oopsla pages october 
published acm sigplan notices volume number 
callahan david callahan alan carle mary hall ken kennedy 
constructing procedure call multigraph 
ieee transactions software engineering 
chambers ungar craig chambers david ungar 
customization optimizing compiler technology self dynamically typed object oriented programming language 
sigplan notices july 
proceedings acm sigplan conference programming language design implementation 
chambers ungar craig chambers david ungar 
iterative type analysis extended message splitting optimizing dynamically typed object oriented programs 
sigplan notices june 
proceedings acm sigplan conference programming language design implementation 
chambers craig chambers 
cecil language specification rationale 
technical report tr department computer science engineering 
university washington march 
cooper keith cooper mary hall ken kennedy 
procedure cloning 
proceedings ieee international conference computer languages pages oakland ca april 
cousot cousot patrick cousot radhia cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
conference record fourth acm symposium principles programming languages pages los angeles california january 
dean jeffrey dean 
program optimization object oriented languages 
phd thesis university washington november 
tr 
dean jeffrey dean david grove craig chambers 
optimization object oriented programs static class hierarchy analysis 
proceedings ecoop aarhus denmark august 
springer verlag 
dean jeffrey dean greg defouw dave grove litvinov craig chambers 
vortex optimizing compiler object oriented languages 
oopsla conference proceedings san jose ca october 
defouw greg defouw david grove craig chambers 
fast interprocedural class analysis 
technical report tr department computer science engineering 
university washington july 
deutsch schiffman peter deutsch allan schiffman 
efficient implementation smalltalk system 
conference record eleventh annual acm symposium principles programming languages pages salt lake city utah january 
diwan amer diwan eliot moss kathryn mckinley 
simple effective analysis statically typed object oriented programs 
oopsla conference proceedings san jose ca october 
emami emami rakesh ghiya laurie hendren 
context sensitive interprocedural points analysis presence function pointers 
sigplan notices june 
proceedings acm sigplan conference programming language design implementation 
gosling james gosling bill joy guy steele 
java language specification 
addison wesley reading ma 
grove david grove jeffrey dean charles garrett craig chambers 
profile guided receiver class prediction 
oopsla conference proceedings pages austin tx october 
hall kennedy mary hall ken kennedy 
efficient call graph analysis 
acm letters programming languages systems september 
hlzle agesen urs hlzle ole agesen 
dynamic vs static optimization techniques object oriented languages 
theory practice object systems 
hlzle ungar urs hlzle david ungar 
optimizing dynamically dispatched calls run time type feedback 
sigplan notices june 
proceedings acm sigplan conference programming language design implementation 
jagannathan weeks suresh jagannathan stephen weeks 
unified framework flow analysis higher order languages 
conference record popl nd acm sigplan sigact symposium principles programming languages pages january 
johnson ralph johnson 
ts optimizing compiler smalltalk 
proceedings oopsla pages november 
published acm sigplan notices volume number 
kam ullman john kam jeffrey ullman 
global data flow analysis iterative algorithms 
journal acm january 
kildall gary kildall 
unified approach global program optimization 
conference record acm symposium principles programming languages pages boston massachusetts october 
kranz david kranz 
orbit optimizing compiler scheme 
phd thesis yale university february 
department computer science research report 
lakhotia arun lakhotia 
constructing call multigraphs dependence graphs 
conference record twentieth annual acm sigplan sigact symposium principles programming languages pages charleston south carolina january 
landi william landi barbara ryder sean zhang 
interprocedural side effect analysis pointer aliasing 
sigplan notices june 
proceedings acm sigplan conference programming language design implementation 
nielson nielson flemming nielson hanne riis nielson 
infinitary control flow analysis collecting semantics closure analysis 
conference record popl th acm sigplan sigact symposium principles programming languages pages paris france january 
odersky wadler martin odersky philip wadler 
pizza java translating theory practice 
conference record popl th acm sigplan sigact symposium principles programming languages pages paris france january 
nicholas jens palsberg michael schwartzbach 
making type inference practical 
lehrmann madsen editor proceedings ecoop lncs pages utrecht netherlands june 
springer verlag 
palsberg schwartzbach jens palsberg michael schwartzbach 
object oriented type inference 
proceedings oopsla pages november 
published acm sigplan notices volume number 
plevyak chien john plevyak andrew chien 
precise concrete type inference object oriented languages 
proceedings oopsla pages portland october 
plevyak chien john plevyak andrew chien 
type directed cloning object oriented programs 
proceedings workshop languages compilers parallel computing pages 
plevyak john plevyak 
optimization object oriented concurrent programs 
phd thesis university illinois urbana champaign 
ryder barbara ryder 
constructing call graph program 
ieee transactions software engineering 
shivers olin shivers 
control flow analysis scheme 
sigplan notices july 
proceedings acm sigplan conference programming language design implementation 
shivers olin shivers 
control flow analysis higher order languages 
phd thesis carnegie mellon university may 
cmu cs 
shivers olin shivers 
data flow analysis type recovery scheme 
topics advanced language implementation 
mit press 
edited peter lee 
steensgaard bjarne steensgaard 
polyvariant closure analysis dynamic abstraction 
unpublished manuscript 
steensgaard bjarne steensgaard 
points analysis linear time 
conference record popl rd acm sigplan sigact symposium principles programming languages pages st petersburg florida january 
stefanescu zhou dan stefanescu zhou 
equational framework flow analysis higher order functional programs 
proceedings acm symposium lisp functional programming pages june 
wilson lam robert wilson monica lam 
efficient context sensitive pointer analysis programs 
sigplan notices pages june 
proceedings acm sigplan conference programming language design implementation 
appendix performance data table reports program execution times sun ultra model mb memory 
derived data 
table execution time secs base simple rta cfa scs cpa cfa cfa cfa cfa richards deltablue instr sched typechecker new tc compiler toba java cup espresso javac javadoc richards deltablue instr sched typechecker new tc compiler toba java cup espresso javac javadoc 
