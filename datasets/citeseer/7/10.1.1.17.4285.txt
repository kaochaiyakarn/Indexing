metaml multi stage programming explicit annotations walid taha tim sheard oregon graduate institute 
introduce metaml practically motivated multi stage programming language 
metaml real language 
built implementation solve multi stage problems 
metaml allows programmer construct combine execute code fragments type safe manner 
code fragments contain free variables obey static scoping principle 
metaml performs typechecking stages execution stage 
certain anomalies metaml implementation led formalize illustrative subset metaml implementation 
big step semantics type system subset prove type system soundness respect big step semantics 
software engineering point view means generators written metaml subset generate unsafe programs 
type system semantics full metaml ongoing 
argue multi stage languages useful programming languages right supply sound basis high level program generation technology support features possible programmers write staged computations significantly changing normal programming style 
illustrate provide simple stage example elaborating number practical issues 
design metaml main principles identified fundamental high level program generation persistence cross stage safety 
principles explain technical problems give rise address problems implementation 
keywords functional programming calculus high level program generation type safety type systems programming language semantics multilevel languages multi stage languages 
research reported supported usaf air materiel command contract nsf iri 
earlier version appeared proceedings acm sigplan symposium partial evaluation semantics program manipulation 
pp 
amsterdam netherlands june 
high level program generators increase efficiency productivity reliability quality software systems 
despite numerous examples program generation literature systems construct program fragments ad hoc techniques 
thesis designed statically typed multi stage programming language supplies sound basis high level program generation technology 
goal design language allows user construct combine evaluate programs higher level abstraction classic strings level 
language formal verification generated program properties easier 
staging multi stage programming concept stage arises naturally wide variety situations 
compiled language execution program involves distinct stages compiletime run time 
distinct stages appear context program generation generation compilation execution 
example yacc parser generator reads grammar generates code second program compiled third user runs compiled code 
multi stage program involves generation compilation execution code inside process 
multi stage languages express multi stage programs 
staging consequently multi stage programming address need general purpose solutions pay run time interpretive overheads 
studies demonstrated effectiveness staging :10.1.1.17.4285
generally little support writing multi stage programs directly high level programming languages sml haskell 
multi level languages proposed intermediate representation partial evaluation formal foundation run time code generation :10.1.1.28.4059
hope show carefully designed multi level language suited multi stage programming 
metaml metaml sml language special constructs multi stage programming 
metaml tightly integrated programs constructed combined compiled executed single paradigm 
programs represented syntax trees manner avoids going string representations 
verifying semantic properties multi stage programs possible 
key features metaml follows staging annotations distinct constructs believe basis general purpose multi stage programming 
static type checking multi stage program type checked begins executing ensuring safety computations stages 
cross stage persistence variable bound particular stage available futures stages 
cross stage safety input available particular stage earlier stage 
static scoping variables code fragments 
relationship lisp metaml annotations brackets escape run analogous lisp back quote comma eval constructs 
analogy useful reader familiar lisp 
brackets similar back quote 
escape similar comma 
run similar eval empty environment 
analogy perfect 
lisp ensure variables atoms occurring back quoted expressions bound rules static scoping 
example plus bind plus scope term occurs 
view important feature metaml 
view metaml semantics concise formalization semantics lisp constructs static scoping 
similar spirit brian smith semantically motivated lisp 
lisp dynamically typed metaml statically typed 
annotations viewed providing simple statically typed macro expansion system 
clear introduce demonstrate constructs 
important note annotations don allow definition new language constructs binding mechanisms expected macro expansion systems 
point back quote comma macros lisp 
leads problems 
non trivial formal semantics pages lisp code 
second way expand parse time lead representation overhead exponential number levels multi level program 
metaml avoids problems direct treatment bracket escape language constructs 
relationship linguistic reflection linguistic reflection defined ability program generate new program fragments integrate execution 
metaml descendent turn greatly influenced 
languages support linguistic reflection 
stage languages allowed users provide compile time functions macros directed compiler perform compiletime reductions 
emphasized computations representations program datatype definitions 
generating functions datatype definitions possible create specific instances generic functions equality functions pretty printers parsers 
provides abstraction mechanism available traditional languages 
metaml improves languages adding hygienic variables generalizing number stages emphasizing soundness type system 
relationship partial evaluation today sophisticated automatic staging techniques partial evaluation systems 
partial evaluation optimizes program partial information program inputs 
goal identify perform computations possible run time 
offline partial evaluation involves distinct steps binding time analysis bta specialization 
bta determines computations performed earlier stage names inputs available run time static inputs 
essence bta performs automatic staging input program 
bta actual values inputs available specializer 
annotations specializer performs computation produces text inclusion output residual program 
relationship partial evaluation multi stage programming intermediate data structure steps stage annotated program specialization phase stage execution stage annotated program produced bta 
gluck jrgensen proposed multi level bta showed efficient alternative multiple specialization 
underlying annotated language closely related metaml static typing 
explicit annotations 
bta performs staging automatically number reasons manual staging programs interesting desirable pragmatic 
subtlety semantics annotated programs warrants studying relative isolation added complexity partial evaluation issues bta 
pedagogical tool 
observed hard users understand workings partial evaluation systems 
new users lack mental model partial evaluation systems 
furthermore new users uncertain output binding time analysis 
annotations 
expressed 
really mean 
answers questions crucial effective partial evaluation 
bta involved process requiring special expertise annotations produces relatively simple easy understand 
observation programmers understand annotated output bta knowing bta works 
having programming language explicit staging annotations help users partial evaluation understand issues involved staged computation hopefully reduce steep learning curve currently associated learning partial evaluator effectively 
controlling evaluation order 
performance issue control evaluation order important 
bta optimizes evaluation order time arrival inputs just easier say wanted force bta discover 
automatic analyses bta necessarily incomplete approximate knowledge programmer 
explicit annotations programmer exploit full knowledge program domain 
language automatic staging having explicit annotations offer programmer designed back door dealing instances analysis reaches limits 
controlling termination behavior 
annotations alter termination behavior ways specialization annotated program fail terminate generated program termination behavior differing original program 
area active investigation partial evaluation programming explicit annotation gives user complete control responsibility termination behaviour staged system 
metaml staging annotations metaml staging annotations brackets escape run run lift lift expression hei builds piece code representation expression splices code obtained evaluating body surrounding bracketed expression 
expression legal lexically enclosing brackets 
expression run evaluates obtain piece code evaluates code 
expression lift evaluates value constructs piece code representing term ground type 
ground type type containing function type 
illustrate consider script small metaml session val triple lift val triple int fun yi val fn val code triple val code reader treat percentage signs white space explained section 
run code val int declaration defines variable triple 
addition component triple evaluated 
evaluation addition second component deferred brackets 
addition third component evaluated result lifted piece code 
brackets types read code int distinguish values values 
second declaration illustrates code abstracted spliced larger piece code 
third declaration applies function triple performing actual splicing 
declaration evaluates deferred piece code 
metaml construct larger pieces code run time fun mult mult val mult fn int val cube hfn mult hyi val cube hfn hint inti fun exponent hfn mult hyi val exponent fn int hint inti function mult integer piece code integer produces piece code way product construct code function performs cube operation generalized generator producing exponentiation function exponent note looping overhead removed generated code 
roles lift brackets create pieces code 
essential difference lift evaluates argument bracket 
function values lifted code lift derive high level intensional representation general 
see function values injected code fragments brackets 
escape allows evaluate lambda 
seen definition functions cube exponent 
having run language implies introducing kind reflection allows delayed computation activated 
syntactic precedence issues escape operator highest precedence higher function application 
allows write hf yi hf yi 
lift run operators lowest precedence 
scope operators extends right far possible 
possible write hf lift zi hf lift zi 
design metaml metaml designed statically typed programming language internal representation multi stage system 
primary goals metaml suitable writing multi staged programs second flexible possible third ensure reasonable things done annotations 
design choices different multi stage systems 
define semantics metaml syntactic notion level needed 
level expression number surrounding brackets minus number surrounding escapes 
possible variable level different level lambda abstraction binds 
sections discuss principles determining uses acceptable 
cross stage persistence cross stage persistence distinguishing feature metaml 
knowledge proposed incorporated multi stage programming language 
essence cross stage persistence allows programmer variable bound current level expression executed stage 
believe desirable natural property multi stage language 
type system ensure variables available expression evaluated 
level variable greater level bound say variable cross stage persistent 
user cross stage persistence means ability stage expressions variables defined previous stage 
bracketed expressions free variables lambda abstractions free variables resolve free variable occurrences static environment expression occurs 
think piece code containing environment binds persistent variables 
example program val ai computes code fragment ai 
percentage sign indicates cross stage persistent variables bound code local environment 
variable bound stage constant 
percentage sign printed display mechanism indicate variable new constant 
name provided hint user new constant originated 
evaluated stage return independently binding variable new context bound value local environment 
arbitrary values including functions injected piece code hygienic binding mechanism 
formally specifying behavior big step semantics turns non trivial 
interpreter multistage language behaviour manifests complex variable binding rules closures capture free substitutions 
implementation semantics addresses cross stage persistence novel way section 
cross platform portability high level program generation cross stage persistence comes price 
compilers maintain highlevel representation values run time able inject value code type means parts code fragment may printable 
stage performed computer second port local environment machine second 
arbitrary objects functions closures bound local environment cause portability problems 
currently metaml assumes computing environment change stages 
part mean having integrated system 
metaml currently lacks cross platform portability 
loss property price paid persistence 
cross platform portability usually issue run time code generation systems cross stage persistence fact appropriate systems 
hand problem cross platform portability similar lifting functional values partial evaluation type directed partial evaluation may provide solution problem :10.1.1.103.291
cross stage safety staged form typable expression typable multi stage language 
variable level level bound say violates cross stage safety 
cross stage safety prevents staging programs unreasonable ways case expression fn hfn operationally annotations dictate computing stage value available second stage 
metaml type system designed ensure typed programs won go wrong going wrong includes violation cross stage safety condition standard notions going wrong statically typed languages 
experience metaml having type system screen programs containing kind error significant aid hand staging programs 
hand staging short example metaml stage programs inserting proper annotations right places program 
programmer uses annotations modify default strict evaluation order program 
experience starting type function hand staged number different ways annotated quite tractable 
leads believe location annotations staged version program significantly constrained type 
example consider function member defined follows member int int list bool fun member null false hd true member tl function member type int int list bool 
strategy hand annotating program determine target type desired annotated program 
suppose list parameter available stage element searched available 
target type hand staged function int list 
annotating starting expression working inwards sub expressions covered 
step try find annotations fix type expression function type closer target type 
function realizes type member int list fun member null hif lift hd true member tl annotations explicitly dictated type 
annotation lift hd type replaces hd order ensure hd performed stage 
selections head element list delayed code constructed run stage 
brackets branches outermost expression ensure return value member code type branch needs annotations return value precisely 
moving function type int int bool forces types int int list respectively 
inwards branch condition inner expression particular forces type parameter type planned 
just branch outer statement inner statement return bool 
branch true fine 
recursive call member type escaped 
inserting escape implies recursion performed stage exactly desired behavior 
result staged member function piece code type bool 
evaluating hfn member hxi yields hfn true true true falsei back forth useful functions code types staging programs interesting pair functions useful back ai bi bi fun back hfn hxi forth bi 
ai bi fun forth xi similar construction stage member function type int list term hfn member hxi type hint 
experience annotating function type ai bi requires annotations annotating type bi easier think 
reasoning functions leads avoid creating functions kind need see code 
applies programs stages 
consider function back ai hh bii hh cii cii fun back hfn hfn hxi ii allows write program takes hai arguments produces stage stage function 
experience functions considerably fewer annotations easier think 
illustrated section 
reason interest back forth similar level expansion 
metaml back forth metalevel concepts optimizations class functions language user apply directly values appropriate type 
conjecture back forth form isomorphism interesting subsets types ai bi bi 
subsets exclude example non terminating functions set bi 
hope able confirms conjecture 
multi stage example information arrives multiple phases possible take advantage fact get better performance 
consider generic function computing inner product vectors 
stage arrival size vectors offers opportunity specialize inner product function size removing overhead looping body computation times 
arrival vector affords second opportunity specialization 
inner product vector taken times vectors specialized removing overhead looking elements vector time 
exactly case computing multiplication matrixes 
row matrix dot product row taken column second 
example appeared works 
give versions inner product function 
iprod staging annotations second iprod levels annotations third iprod levels annotations constructed back function 
metaml quote relational operators involving greater possible confusion brackets 
iprod int vector vector int fun iprod nth nth iprod iprod int fun iprod hfn hfn hh lift nth nth iprod ii hh ii ii int fun hh lift nth nth ii hh ii fun iprod back notice staged versions remarkably similar version version written back fewer annotations 
type infer ence mechanism interactive environment great help placing annotations correctly 
important feature metaml visualization help system affords 
testing iprod inputs immediately see results 
val iprod hfn hfn lift nth nth lift nth nth lift nth nth ii piece code run return function applied vector builds piece code 
building process includes looking element vector splicing actual value lift operator 
lift especially valuable wish inspect result phase 
evaluate code running apply result vector 
val run inti hfn nth nth nth note actual values array appear code access function nth appears constant expression applied second vector :10.1.1.103.291
code take full advantage information known second stage 
particular note generate code third stage may contain multiplication 
multiplications optimized 
write second stage function add index vector actual value vector piece code names second vector constructs piece code adds result multiplication code valued fourth argument special cases possible 
add int int fun add nth lift ei lift nth lift ei specialized function build second stage computation int fun hh add nth ii hh add nth ii fun iprod back observe result stage computation 
val iprod hfn hfn add nth hd add nth hd add nth hd ii code linear size vector lined calls add exponential 
reason having cross stage persistent constants add code indispensable 
observe result second stage computation val run inti hfn nth nth note multiplications contribute answer remain third stage program :10.1.1.103.291
vector sparse sort optimization dramatic effects 
formal semantics development metaml study formal semantics metaml ongoing research 
section type system metaml outline proof soundness simplified adaptation proofs appearing 
reader encourage consult sources detailed treatment results achieved 
big step semantics syntax core subset metaml follows hei run values 
values subset terms denote results computations 
relative nature brackets escapes important family sets values indexed level term just set 
values defined follows hv hv run hv run set values notable points 
values bracketed expressions 
means computations return pieces code representing programs 
second values contain applications inside brackets third level escapes values 
definition substitution standard denoted substitution free occurrences core subset metaml assigned big step semantics follows 












hv 
run 

hvi 

run 
run 


hei 
hvi big step semantics level 
returns value index left implicit semantics clarity 
type system judgement delta read type environment delta level syntactically surrounded occurrences run term type type assignment delta maps variables triple 
triple consists type level number surrounding occurrences run point variable bound see abs rule 
going wrong main kinds errors related staging annotations occur run time variable level level lambda abstraction bound domains relations levels types int hi type environments delta 
delta 
delta delta inference rules int delta int var delta delta br delta delta hei hi esc delta hi delta abs 
delta delta app delta delta delta run delta hi delta run fig 

type system run escape passed values having non code type run alters level argument lead type error 
kind error checked var rules 
assume program contains run annotations zero 
having rule allows cross stage persistence variables available current stage stages 
second kind error checked run esc rules 
detecting third kind error difficult problem accomplished keeping track surrounding occurrences run comparing surrounding brackets 
essence assuming type correct allow run removes explicitly manifest brackets 
incorporated variable rule condition ensures occurrence variable strictly surrounding brackets runs 
condition wrongly allow program hfn run hxi reduces term hfn xi value reduced 
general means careful open pieces code 
specifically sure run applied open piece code level free variables piece code drop level bound 
standard part language code normal type constructor needs special treatment level changed language constructs 
type preservation common type preservation proofs prove substitution lemma 
addition semantics expected respect notion level prove called promotion demotion lemmas lemma level properties 
type system important properties promotion delta delta implies delta delta flex 
delta implies 
delta demotion vn delta implies delta delta delta proof 
properties proved straight forward induction typing derivation 
proof demotion uses flex case abstraction takes advantage definition values case escape show escape level relevant 
lemma substitution 
delta 
delta implies delta delta proof 
straight forward induction height second typing derivation 
non trivial variable case uses promotion takes advantage condition prove main theorem theorem type preservation 
delta 
vn delta proof 
straight forward induction height evaluation derivation 
application level uses substitution run level uses demotion 
cross stage persistence monolithic variables cross stage persistence relaxed allowing variables available exactly stage 
case multistage languages known date :10.1.1.16.4975:10.1.1.28.4059
intuitively monolithic rule variables assume var monolithic delta delta allow general condition expression val lift fn hxi accepted inside brackets delta ff expression accepted monolithic variable rule 
note function type ff hffi provide functionality lift result applying lift value returns constant xi literal expression denoting value 
distinction seen level implementation semantics discussed big step semantics discussed 
type system rejects expression fn hfn inside escape delta ff 
limitations expressivity run type system admit lambda abstraction run 
large extent design choice compromise 
particular run function introduced language constant breaks safety type system 
section discuss expressivity problems arise design choice addressed current implementation 
typing top level bindings problem 
metaml program consists sequence top level declarations binding variables terms followed term program val program interpret top level declaration val application inconvenient situation bind value toplevel eventually want run safe run 
run typable type system 
interpretation val run untypable 
observations 
top level bindings number important properties bound bindings may top level binding level 
second top level bindings scope top level bindings 
furthermore top level binding scope variable bound level greater 
syntactically top level binding occur scope piece code free variables 
free variables run cause problem 
purposes type system throw away programs run applied code free variables cause computation get stuck type errors 
syntactic restrictions guarantee variables bound top level cause problem different type rule top level bindings allowing safe terms typable 
solution 
current implementation avoids problem metaml rule top level bindings interactive loop top 
delta delta delta val top level declarations system prints type binding entered user 
note printed 
theory existentially quantified rule 
practice large number 
intuitively large corresponds ability run values declared top level times want 
soundness top rule 
expression usually interpreted having operational semantics interpretation derive typing rule collecting simplified assumptions 
delta delta lam delta delta delta def 
app 
delta delta delta top rule equivalent non standard operational interpretation declaration val run number repeated occurrences construct appears superscript 
interpretation motivated fact term typable 
terms relation run 
typable derivation exists 
don perform substitution type checking derivation 
delta 
delta promotion lemma 
delta bra delta lam delta delta app delta run run delta val def arrive rule top collecting assumptions top tree derivation setting 
picking large works promotion lemma tells type checking top level binding possible possible run inside functions useful type system allowed express functions val fn int list run gen function takes list integers generates intermediate program list executes generated program 
type system core language admit term previously declared variable gen 
experience functions quite small achieve effect advantage power rule described val gen val run trick useful satisfactory point view modularity code forces kind inlining get type system 
conjecture possible relax type system somewhat rules run 
delta hi 
delta run base type int int list 
intuitively typing rule assures basic value involving code available level context surrounding occurrences run needed 
rule allow type expression 
ad hoc hope formulate systematic basis rules 
implementation semantics big step semantics capture relevant operational details addressed implementation metaml 
main exceptions need distinguishing real symbolic bindings run time generation names gensym cross stage persistent constants 
section semantics describes implementation 
worked hard keep implementation efficient faithful big step semantics formal proof relation ongoing 
real symbolic binds gensym cross stage constants implementation semantics consists rules reduction gamma 
essentially applying application run rules rebuilding gamma 
indexed level essentially constructing code evaluating escaped computations inside brackets environment gamma binds variable value 
reduction standard part 
subtlety relating variable binding causes problem environments somewhat complicated 
particular variables bound rebuilding place 
example rebuilding term hfn id hxi requires reducing application id hxi 
reducing application variable bound value 
intended semantics metaml really want variable simply name susceptible accidental name capture run time 
solve problem bindings environments come flavors real real symbolic sym 
extension environment real values occurs rule app 
values returned var reduction injected constant terms rebuilding 
essence tags real sym provide set coercions needed deal free variables implement persistence 
feature implementation semantics self contained substitution operation 
substitution performed rebuilding operation 
particular absence staging annotations rebuilding just capture free substitution symbolic variables bound gamma rebuilding rules abs capture free substitution bracket applied terms inside brackets describes delayed computations inside value constructed 
domains relations judgments gamma 
gamma 
rules int gamma 
int gamma 
abs gamma 
sym 
gamma 
abs gamma 
sym 
gamma 
app gamma 
gamma 
ffl 
real 
gamma 
app gamma 
gamma 
gamma 
var gamma real gamma 
svar gamma sym gamma 
dom gamma gamma 
gamma real gamma 
bracket gamma 
gamma 
bracket gamma 
gamma 
escape gamma 
gamma 
escape gamma 
gamma 
run gamma 
ffl 
gamma run 
run gamma 
gamma run 
run constant gamma 
gamma 
constant gamma 
gamma 
fig 

implementation semantics type system ensures rule abs embedded escapes level encountered rebuilding process rebuilding rule implements capture free substitution 
rebuilding rule escape escaped expression level indicates computation produce code valued result rebuilding returns term role judgement keep track level expression built 
level subexpression number surrounding brackets 
surrounding escape cancels surrounding bracket 
incremented expression inside brackets bracket decremented inside escape escape 
note rule escape level escape appear inside brackets 
reduction rule bracket describes code value constructed bracketed term embedded expression stripped brackets rebuilt level result rebuilding brackets 
summarize altogether rebuilding distinct roles 
replace known variables constant expression comes real bindings gamma rule 

rename bound variables 
symbolic sym bindings occur rules abs abs term rebuilt new names introduced avoid potential variable capture 
new names projected environment rule svar 

execute escaped expressions obtain code splice context escaped term occurs rule escape 
reduction rule run describes code valued term executed 
term reduced code valued term embedded term reduced empty environment produce answer 
empty environment sufficient cross stage persistent free variables original code valued term replaced constant expressions free variables handled idempotent case svar 
notion stage gave intuitive explanation stage 
presenting semantics metaml provide formal definition 
define trace stage derivation tree generated invocation derivation ffl 
cf 
run rule 
note notion level defined respect syntax notion stage defined respect trace operational semantics 
quite intuitive distinction clear especially comparable definition literature respect operational semantics 
levels subterms program stages involved execution program unrelated 
program run ii expressions levels 
define level program maximum level subexpressions level program 
evaluation expression just involves rebuilding involves derivations ffl 
hand evaluation slightly modified level program run run ii involves stages 
illustrate distinction levels stages define number stages program number times ffl 
derivation involved evaluation 
consider fn lift run arbitrary problem 
number stages program statically decidable 
furthermore say general occurrence run ultimately responsible triggering computation addition expression 
recognizing mismatch useful step finding type system metaml employs static notion level approximate dynamic notion stage 
lambda abstraction 
may appear staging requires lambda abstraction dual operation application 
may true certain applications domain program generation additional capabilities needed delayed computation maintain intensional representation users inspect code produced generators printed fed compilers 
compiled implementation lambda abstractions lose high level intensional representation possible 
second generators need perform evaluation lambda 
necessary staged application performs kind unfolding functions back 
prove effect escape lambda imitated call value calculus extending additional constructs 
explain point show example result encoding operational semantics metaml sml nj 
essential ingredients program requires abstraction application staging brackets dynamic non level abstractions escapes 
lambda abstraction unit encode bracket application unit encode run 
escape considerably difficult 
particular expression inside escape executed surrounding delayed computation closure constructed 
problem variables introduced inside delayed expression occur escaped expression 
example hfn hxi way imitate behavior uses non pure sml features 
simulate evaluation lambda exceptions simulate creation uninitialized cells 
consider sequence metaml declarations fun hfn hxi val pc fn xc xc xc val run pc corresponding imitation sml exception defined val undefined fn raise defined fun val xh ref undefined val xc fn xh val nc xc fn fn xh fn nc val pc fn xc fn xc xc val pc translation values type hffi encoded delayed computations type unit ff 
assigning lifted undefined value undefined 
ready write analog function function function creates uninitialized cell xh 
cell corresponds occurrences application hxi metaml definition intuitively fact xh uninitialized corresponds fact bound fixed value application hxi performed 
facility important metaml allows unfold functions dummy variables expression fn xh delayed lookup xh 
corresponds brackets surrounding expression hxi 
simply perform application function delayed construction 
important note applying passed function know value bound 
body function returns delayed lambda abstraction assigns delayed version xh simply includes applied escaped version nc body abstraction 
transliteration illustrates advantage metaml trying encode multi stage programs lambda abstractions exceptions 
metaml version shorter concise looks version easier understand 
consider implementation metaml approach hidden syntactic sugar alleviate disadvantages listed 
lambda delay method advantage simply machine independent manipulation lambda terms 
unfortunately fails meet intensional representation criterion incurs overhead necessarily incurred metaml version 
particular assignment xh delayed repeated time function returned 
happens application escaping nc 
expenses incurred metaml version intuitively operations connect meta level variable corresponding object level xh 
metaml overheads incurred exactly evaluation run pc opposed time function resulting pc applied 
optimization generated code semantics sufficient executing metaml programs code generated programs contain superfluous computations 
superfluous computations costly execute generated programs code larger harder humans understand 
follows discuss kinds computations deal problems implementation metaml 
safe beta reduction consider example val hfn val hfn big step semantics variable evaluates hfn fn 
metaml returns hfn attempts perform safe beta reduction piece code escaped 
beta reduction safe affect termination properties 
safe case particularly easy recognize application lambda abstraction constant variable symbolically reduced affecting termination 
justified fi rule expected hold levels 
performing safe beta step change termination order evaluation program performed code built repeatedly code run 
nested escapes consider case deeply bracketed term level escaped way level 
order execute term escapes level rebuilt times 
consider reduction sequence sketched term run run hh eii bound gamma show innermost run 

hh ii 

ei 
ii hh eii 
hh iii 


ii 
run hh eii 
term rebuilt times 
simple refinement prevent happening 
change rebuilding escaped expressions levels greater adding rule escape opt addition rule escape 
escape opt gamma 
gamma 
escape gamma 
gamma 
long sequence escapes surrounded equal number brackets gets rebuilt exactly 
optimization justified rebuilding performs useful 
note optimization eliminate redexes user expect see generated code hard understand particular program generated 
experience resulting smaller simpler programs easier understand optimizations worthwhile 
discussion related works nielson nielson pioneered investigation multi level languages level functional languages 
developed extensive theory denotational semantics level languages including framework interpretation 
framework developed general level language arbitrary possibly set 
nielson nielson proposed algebraic framework specification multi level type systems 
gomard jones statically typed level language partial evaluation untyped calculus 
language basis 
language allows treatment expressions containing monolithic free variables 
const construct constants ground type 
treatment variables implementation semantics inspired 
gluck jrgensen novel idea multi level bta efficient effective alternate multiple self application 
untyped multi level language scheme presentation 
metaml fewer primitives language focus program generation issues bta 
worth noting intermediate results printable high level intensional representation 
metaml cross stage persistence allows intermediate results stages contain constants intentional representation available 
convenient run time code generation proper specification metaml difficult 
example generic code generation functions define language 
second gluck jrgensen demonstrates impressive efficiency constraint solving methods perform analysis 
type underlying language statically typed 
thiemann studies level language eval apply call cc context partial evaluation larger subset scheme previously studied 
bta constraint solving 
problems eval call cc highlighted different notion types complexity introducing eval multi stage language manifest 
thiemann deals issue variable arity functions practical problem dealing eval scheme 
hatcliff gluck studied multi stage flow chart language called thoroughly investigated issues involved implementation language 
syntax graph explicitly captures information necessary specifying staging computation construct annotated number indicating stage executed variables annotated number indicating stage availability 
graph statically typed syntax formal semantics language quite sizable 
programming graph requires user annotate construct variable stage annotations ensuring consistency annotations user responsibility 
hatcliff gluck identified language independence internal representation code important characteristic multi stage language 
sheard nelson investigate stage language purpose program generation 
base language statically typed dependent types generate wider class programs possible metaml restricted stages 
sheard shields investigate dynamic type systems multi staged programs type obligations staged computations put till run time 
davies pfenning statically typed multi stage language mini ml motivated constructive modal logic :10.1.1.16.4975
formal proof equivalence binding time correctness modal correctness 
metaml motivated primarily operational considerations 
language constructs box box correspond roughly brackets run 
mini ml type constructor similar code 
mini ml simulate lift stage zero function example persistent 
functions back expressible mini ml multi stage language mini ml fl motivated linear time constructive modal logic :10.1.1.16.4975
language allows staged expressions contain monolithic free variables 
constructs mini ml fl prev correspond quite closely metaml brackets escape 
type constructor fl corresponds roughly code 
unfortunately eval longer expressible language 
moggi advocates approach level languages 
points stateful functions gensym newname semantics formal reasoning hard 
implementation semantics uses gensym big step semantics 
summary distinguishing characteristics languages discussed 
levels mean level language means multi level 
static typing means level statically checked 
facility example nielson nielson gomard jones gluck jrgensen thiemann hatcliff gluck fl levels hx xi static typing monolithic var :10.1.1.16.4975:10.1.1.28.4059
hx hxi reflection run eval persistence hx xi portability fig 

comparative feature set ongoing open questions reported directed attention important questions relating multi stage computation general metaml particular 
currently investigating number aspects metaml 
denotational semantics assigns meaning language 
expect works nielson nielson moggi serve basis assigning semantics metaml 

reduction semantics equational theory serve practical basis formal reasoning program optimizations equivalence programs 
reduction semantics investigated limited due subtlety non standard definition substitution 

metaml admits analog polyvariant specialization annotating differently copies program 
clear task easier programmer 

validating implementation respect formulations semantics metaml 

extending effects 
extension current type system effects obvious 
example adding sequencing la sml allows unsafe program val ref val hfn hxi val run 
providing general solution binding problem 
proposed solution binding problem top level solution carry bindings higher levels 

simplifying type system 
flex property suggests may sufficient keep track difference typing environment 
remedies limitation expressivity run ad hoc 
described multi stage programming language call metaml 
metaml designed programming language 
primary purpose support writing multi stage programs 
design choices different multi stage systems 
believe metaml helps understanding communicating ideas multi stage programs partial evaluation complex process bta way boxed unboxed distinction provides language understanding boxing optimizations source source transformations 
identifies number language features essential writing multi stage programs cross stage persistence 
ability variables past stage crucial writing staged programs manner programmers accustomed 
cross stage persistence provides solution hygienic macros typed language macros bind identifiers environment definition captured environment 
multi stage aware type system 
type checker reports phase errors type errors 
crucial debugging multi stage programs 
display code 
debugging important users observe code produced programs 
requires display mechanism pretty printer values type code 
display constants 
origin cross stage persistence constant hard identify 
named tags provide approximation constants came 
tags misleading quite useful 
connection hai hbi ha bi 
having mediating functions reduces drastically number annotations needed stage programs 
lift 
lift annotation possible force computation early stage lift value program incorporated stage 
may cross stage persistence lift unnecessary lift helps produce code easier understand constants explicit 
safe beta escape reduction 
optimizations improve generated code readable 
built implementation program examples larger examples cf 

currently implementation supports polymorphic type inference 
extending implementation include features sml 
acknowledgments research metaml benefited greatly collaboration benaissa eugenio moggi 
years fortune getting valuable inputs koen claessen olivier danvy rowan davies robert gluck jim hook neil jones john launchbury peter lee erik meijer flemming nielson dino oliva frank pfenning amr sabry phil wadler members 
special due lisa walton comments final manuscript 
anonymous referees careful constructive comments sharpened ideas improved organization presentation 
editor charles consel facilitating communication referees course review 

charles consel olivier danvy 
tutorial notes partial evaluation 
acm symposium principles programming languages pages january 

charles consel francois noel 
general approach run time specialization application conference record popl rd acm sigplan sigact symposium principles programming languages pages st petersburg beach florida january 

olivier danvy 
bridge reflection partial evaluation 
bjorner ershov jones editors partial evaluation mixed computation pages 
north holland 

olivier danvy 
type directed partial evaluation 
acm symposium principles programming languages pages florida january 
new york acm 

olivier danvy jens palsberg 
essence partial evaluation 
lisp symbolic computation 

rowan davies 
temporal logic approach binding time analysis 
proceedings th annual ieee symposium logic computer science pages new brunswick new jersey july 
ieee computer society press 

rowan davies frank pfenning 
modal analysis staged computation 
rd annual acm symposium principles programming languages popl st petersburg beach florida january 

robert gluck jesper jrgensen 
efficient multi level generating extensions program specialization 
swierstra hermenegildo editors programming languages implementations logics programs plilp volume lecture notes computer science pages 
springer verlag 

robert gluck jesper jrgensen 
efficient multi level generating extensions program specialization 
programming languages implementations logics programs plilp volume lecture notes computer science 
springer verlag 

robert gluck jesper jrgensen 
fast binding time analysis multi level specialization 
psi andrei ershov second international memorial conference perspectives system informatics volume lecture notes computer science 
springer verlag 

carsten gomard neil jones 
partial evaluator untyped lambda calculus 
journal functional programming 

brian markus mock philipose craig chambers susan eggers 
annotation directed run time specialization proceedings acm sigplan symposium partial evaluation semantics program manipulation pages amsterdam netherlands june 

john hatcliff robert gluck 
reasoning hierarchies online specialization systems 
olivier danvy robert gluck peter thiemann editors partial evaluation volume lecture notes computer science pages 
springer verlag 

fritz henglein christian mossin 
polymorphic binding time analysis 
donald sannella editor programming languages systems esop th european symposium programming volume lecture notes computer science pages edinburgh april 
springer verlag 

james hook tim sheard 
semantics compile time reflection 
technical report cse oregon graduate institute 

luke hornof charles consel jacques noy 
effective specialization realistic programs sensitivity 
sas pages paris france september 

luke hornof jacques noy 
accurate binding time analysis imperative languages flow context return sensitivity 
proceedings acm sigplan symposium partial evaluation semantics program manipulation pages amsterdam netherlands june 

neil jones 
mix years 
partial evaluation semantics program manipulation new haven connecticut sigplan notices vol 
september pages 
new york acm new york acm june 

neil jones 
writing interpreter specialisation 
olivier danvy robert gluck peter thiemann editors partial evaluation volume lecture notes computer science pages 
springer verlag 

neil jones carsten gomard peter sestoft 
partial evaluation automatic program generation 
prentice hall 

simon peyton jones john launchbury 
unboxed values class citizens non strict functional language 
functional programming computer architecture september 

richard kieburtz bellegarde jef bell james hook jeffrey lewis dino oliva tim sheard lisa walton tong zhou 
calculating software generators solution specifications 
tapsoft volume lncs pages 
springer verlag 

richard kieburtz laura mckinney jeffrey bell james hook alex jeffrey lewis dino oliva tim sheard ira smith lisa walton 
software engineering experiment software component generation 
th international conference software engineering march 

mark leone peter lee 
deferred compilation automation run time code generation 
technical report cmu cs carnegie mellon university dec 

mark leone peter lee 
declarative approach run time code generation 
workshop compiler support system software february 

michael lowry andrew thomas ian underwood 
automatic programming scientific subroutine libraries 
nasa science information systems newsletter 

robin milner 
theory type polymorphism programming 
journal computer system sciences 

eugenio moggi 
categorical account level languages 
mfps 

eugenio moggi walid taha benaissa tim sheard 
idealized metaml simpler expressive includes proofs 
technical report cse ogi october 

flemming nielson 
program transformations denotational setting 
acm transactions programming languages systems july 

flemming nielson 
correctness code generation level meta language 
robinet wilhelm editors proceedings european symposium programming esop volume lncs pages saarbrucken frg march 
springer 

flemming nielson 
level semantics interpretation 
theoretical computer science december 

flemming nielson hanne riis nielson 
level semantics code generation 
theoretical computer science january 

flemming nielson hanne riis nielson 
level functional languages 
number cambridge tracts theoretical computer science 
cambridge university press 

flemming nielson hanne riis nielson 
multi level lambda calculi algebraic description 
danvy gluck thiemann editors partial evaluation 
dagstuhl castle germany february volume lecture notes computer science pages 
berlin springer verlag 

flemming nielson hanne riis nielson 
prescriptive framework designing multi level lambda calculi 
proceedings symposium partial evaluation semantics program manipulation amsterdam june 

calton pu jonathan walpole 
study dynamic optimization techniques lessons directions kernel design 
technical report ogi cse oregon graduate institute science technology 

tim sheard 
user guide compile time reflective programming language 
technical report coins tech 
rep dept computer information science university massachusetts 

tim sheard 
automatic generation structure operators 
acm transactions programming languages systems october 

tim sheard 
guide time reflective ml 
available author home page october 

tim sheard 
type parametric programming 
technical report cse oregon graduate institute 

tim sheard 
type directed line partial evaluator polymorphic language 
proceedings symposium partial evaluation semantics program manipulation amsterdam june 

tim sheard neal nelson 
type safe abstractions program generators 
technical report ogi tr oregon graduate institute science technology 

mark shields tim sheard simon peyton jones 
dynamic typing staged type inference 
proceedings th acm sigplan sigact symposium principles programming languages january 

brian smith 
reflection semantics procedural language 
phd thesis massachusetts institute technology january 

brian smith 
reflection semantics lisp 
acm symposium principles programming languages january 

stemple stanton sheard morrison kirby fegaras cooper connor atkinson 
typesafe linguistic reflection generator technology 
technical report fide esprit bra project fide 

walid taha benaissa tim sheard 
multi stage programming axiomatization type safety 
th icalp aalborg denmark july 

walid taha tim sheard 
multi stage programming explicit annotations 
proceedings acm sigplan symposium partial evaluation semantic program manipulations pepm amsterdam pages 
acm 

peter thiemann 
partial evaluation full scheme 
gregor kiczales editor reflection pages san francisco ca usa april 
