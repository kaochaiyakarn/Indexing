hascasl integrated speci cation development functional programs lutz schr oder till mossakowski department computer science bremen university 
development programs modern functional languages haskell calls wide spectrum speci cation formalism supports type system languages particular higher order types type constructors parametric polymorphism contains functional language executable subset order facilitate rapid prototyping 
lay design hascasl higher order extension algebraic speci cation language casl geared precisely purpose 
semantics tuned allow program development speci cation re nement time staying close set theoretic semantics rst order casl 
number primitive concepts logic kept small possible demonstrate various extensions logic particular general recursion formulated language 
application formal methods speci cation development correct software critical problem transition level speci cations level programs 
hascasl development paradigm introduced problem tackled follows choose haskell pure functional language primary certainly exclusive target language avoiding need deal side ects impure features fact ml features primary obstacles design extended ml 
speci cation language hascasl designed extension completed rst order algebraic speci cation language casl higher order concepts partial function types polymorphism type constructors going times deviating 
extended language wide spectrum language particular powerful admit executable sublanguage close correspondence haskell avoiding need specialized interface language employed larch 
time simple keep semantics natural manageable 
way possible perform entire development process requirement speci cations executable prototypes successive re nements single language 
detail basic logic hascasl consists essentially partial calculus extended form type class polymorphism combines features haskell isabelle provided intensional henkin style semantics :10.1.1.22.782:10.1.1.47.1059
main semantic problem ensues treatment recursive types recursive functions available classical higher order logic 
traditional way dealing features denotational semantics needs talk things complete partial orders xed points 
possible add features language ecting basic language de nition complicating semantics means boot method consists writing relevant extensions speci cations basic hascasl 
force approach stems fact secondary internal logic lives scope abstractions 
internal logic means primitive concept grows naturally intensional semantics partial higher order logic 
interaction valued external logic speci cations internal logic basic version extremely weak may observed extended 
means suitably extended internal logic de ne type class complete partial orders style holcf recursive function de nitions available similarly internal logic allows coding relevant axioms recursive datatypes :10.1.1.35.4051
arrive methodology allows smooth transition requirements design speci cations speci ed partial higher order logic available holcf employ cpos recursion unde nedness represented 
way requirement speci cations avoid extra looseness arising cpos introduced design level xed set constructions generating cpos recursive datatypes 
corresponding speci cations detail associated methodology illustrated means brief example 
unexplained categorical terminology reader referred 
casl speci cation language casl common algebraic speci cation language designed cofi international common framework initiative algebraic speci cation development 
features include rst order logic partial functions subsorts sort generation constraints structured architectural speci cations 
de nition language cf 
full formal semantics laid 
semantics structured architectural speci cations independent logic employed basic speci cations 
order de ne envisaged extension casl sucient de ne underlying logic essentially notions signature model sentence satisfaction done 
basic hascasl logic shall proceed de ne hascasl logic 
economical possible primitive concepts way demonstrate important features may added built syntactic sugar non conservatively hascasl speci cations 
order avoid presentation shall overly details syntax full description :10.1.1.47.1059:10.1.1.13.362
roughly put logic hascasl moggi partial calculus equipped semantically harmless extensions ml polymorphism type constructors type classes embedded full featured external logic provided rst order casl :10.1.1.13.362
signatures sentences types associated hascasl signature built usual way basic sorts declared casl keyword sort type constructors declared arity 
particular built type constructors product types 
partial function types unit type unit 
types may aliased see details :10.1.1.47.1059:10.1.1.13.362
operators constants assigned type 
rst order casl user may specify subsort relation declared sorts relation extended types way described 
subsorting really play great role considerations omit feature rest presentation particular ignore casts term formation rules 
signatures come notion morphism reader referred details :10.1.1.47.1059:10.1.1.13.362
data determine notion term rules 
notations abbreviate sequences xn explicit projection symbols absent coded terms xed abbreviations fst snd obvious meaning 
terms fst denote domain restricted intersection domain term abbreviated res application regarded built operator obvious pro le extra typing rule application arbitrary terms required 
tuples arbitrary length regarded constructed iterated pairing 
terms may formulas external logic ers essentially ample features rst order casl strong existential equality de nedness predicate usual connectives quanti ers including disjunction negation existence 
external logic set apart distinctly weaker internal logic discussed 
models satisfaction hascasl meant extend rst order casl faithfully possible semantics necessarily set theoretic 
broad range choices unit sn fig 

term formation typing rules available set theoretic notion model higher order signatures principal options follows standard model partial function types interpreted full set partial functions interpretation extensional henkin model function types interpreted subsets full set functions way terms interpreted property called comprehension 
intensional henkin model function types interpreted arbitrary sets equipped application operation appropriate type 
comprehension required way terms interpreted part structure model just existence axiom 
intensional henkin models discussed :10.1.1.13.362
notion chosen hascasl reasons semantic methodological nature intensional henkin models 
moving away standard models avoids known incompleteness problems 
extensionality carries disadvantage destroying existence initial models signatures setting partial functions see simple example arguments favour intensional models total setting brought forward 
hand extensionality reason required user may easily enforced spec extensionality forall type 
categorical point view see think relevant intensional models attractive direct correspondence natural class categorical models see details :10.1.1.13.362
methodologically speaking intensional models er advantage allowing ne grained analysis function spaces 
instance possible treat operational semantics functional programming languages haskell directly higher order models 
context function space consists called closures function de nition bodies partial instantiations arguments 
intensional semantics possible distinguish di erent closures exhibit behaviour 
values internal language considered values history computation 
similar vein intensional models allow distinction various ways function may fail yield value cf 
ideas error cafeobj extensional setting function may merely de ned unde ned 
peculiarity intensional approach intended equality terms explicitly imposed models 
give deduction system existential equality read sides de ned equal 
deduction takes place context rule confused extensionality usual sense 
uses reasoning assumptions marked square brackets locally enlarged context rst premise reads deducible context additional assumption def 
def abbreviates notations refer substitution variables context may require splitting tuple components 
rule pr meant ways 
rule ax serves purpose accommodating axioms take form implications indicated context axioms needed order ensure correct behaviour subsorting overloading see details :10.1.1.47.1059:10.1.1.13.362
system derive strong equations side de ned equal terms provably strongly equal corresponding existential equation derived relevant de nedness conditions 
deduction system quite similar takes strong equality primitive notion systems easily seen deductive strength :10.1.1.13.362
envisaged models deduction complete shown completeness result fails extensional models :10.1.1.18.7716:10.1.1.13.362
de nition 
model hascasl signature assignment set type way unit interpreted singleton set product types interpreted cartesian products assignment partial interpretation function 
sn 
term type context xn 
interpretation functions required respect deducible equality terms extended mentioned subsorting axioms 
substitution modeled composition partial functions terms form xn interpreted appropriate product projections 
model morphism models family functions ranges types satis es homomorphism condition interpretation functions terms 
satisfaction formulae external logic models de ned obvious classical way 
var op sym tr cong def ax axiom def str def def unit def unit pr def fst snd pr def def def def def def def def 
fig 

deduction rules existential equality context 
may argue having interpret terms intensional model amounts losing compositionality sense basic constants interpreted interpretation terms may recursively constructed interpretation terms may reduced interpretation application usual combinators cf 


intensional henkin models de ned direct correspondence categorical interpretations called partial cartesian closed categories essentially categories partial function space objects representing partial morphisms way function spaces cartesian closed category represent total morphisms recall partial morphism span form belongs distinguished class monomorphisms admissible domains see detailed de nition :10.1.1.13.362
equivalence results partial calculi hand hand discussed 
interpretation gives rise intensional henkin model composing interpretation representable functor homc denotes terminal object process reversed fact mentioned total case 
type classes polymorphism top syntax far add type class oriented form shallow polymorphism really ecting semantics essential way 
improving language takes closer incorporating haskell sublanguage 
isabelle regard type classes subsets set types :10.1.1.22.782:10.1.1.47.1059
type class declared writing class cl class cl cl cl existing class class cl declared subclass 
built type classes class type types types subtyping relation 
constants declared polymorphic type classes giving type scheme variables universally quanti ed classes op cl type may contain type variable type variable may declared globally means keyword forall 
declaration ect adding type class cl instance signature point mechanism di erent isabelle operators instantiated types undesirable situations model theory matters 
sake readability omit explicit type information 
similarly axioms may enclosed universal quanti cation type variables assigned classes cl may contain type variable say types bound variables instantiations polymorphic constants 
axioms taken mean nite collection instances type 
particular quanti cation types allowed outermost level axioms 
instance declaration type class type classes separated commas may declare subclass assign type class sort declare arity type constructor sense isabelle stating constructed type belongs certain class argument types belong certain classes instance cl cl instance cl cl instance cl cl cl cl cl cl classes sort type constructor 
principle need attach axioms items directly instance declaration haskell instances expected provide implementations operators associated class occasionally want express fact axioms associated class implied ones instance 
may write list axioms possibly constant declarations grouping brackets directly declaration type variables declared instance declaration 
part speci cation type class xed idempotent look follows class proj forall proj op pr pr pr pr instance proj proj pr pr pr declaration implicitly produces proof obligation similar implies annotation casl states previously declared axioms type class roj example similarly isabelle hol meant follow axioms associated instance 
mechanism reason provide subclass declarations class instance 

polymorphism introduced essentially ml polymorphism construct missing regarded syntactical sugar 
discourse may create impression combination ml polymorphism higher order logic inconsistent 
case demonstrated shallow polymorphism coded away just replacing polymorphic operators axioms instances 
derivation girard paradox section assumption terms language identi ed untyped equality absence type annotations equality obviously unsound usual notions model paradox shows language equality inconsistent 
usual versions ml polymorphism instantiations polymorphic constants internally annotated types contradiction disappears 
predicates total functions non strict functions features appear missing type system hand predicates total functions provided casl hand non strict functions feature haskell 
features regarded syntactical sugar setting built far predicates represented partial functions unit 
idea de nedness partial functions corresponds satisfaction predicates 
types form unit abbreviation pred provided 
de nedness predicate def rst order casl interpreted type abbreviation hascasl 
expected behaviour due way partial functions composed 
direct way logical connectives predicate terms 
ingredients rudimentary logic available constant true predicate tt type just write tt tt unit conjunction operator unit logical operators possible non conservative see section 
de nedness predicate may introduce total function type abbreviation ff def tt total abstractions 
partial terms downcast subtype total functions 
unavoidable con ict hascasl haskell stems fact hascasl casl ml strict unde ned arguments yield unde ned values haskell functions allowed leave arguments unevaluated yield results unde ned arguments 
wellknown non strict functions may emulated means function types unit argument types support concept follows multi argument function predicate types number argument types may preceded question mark argument types implicitly replaced mentioned function type unit 
sake readability shall restrict exposition unary case 
extra typing rule application non strict functions operator symbol type term type term type implicitly replaced unit term fresh variable 
polymorphic operators type may non strict instantiations writing provided occurences variable argument type function type 
non strict abstraction typing derivation may extra typing rules introduced including term implicitly replaced unit obtained replacing occurences 
easily seen implies unit 
note order avoid certain algebraic ambiguities expressly provide built type abbreviation unit 
internal equality internal logic mentioned internal equality predicate speci cally included primitive hascasl 
predicate eq type pred considered representing internal equality eq equivalent terms deduction system due stronger property equivalence formulas pair elements model see :10.1.1.13.362
fact internal equality speci ed hascasl 
interestingly internal equality turns highly non conservative logic available abstracted predicates substantially richer normally available tt de ne internal connectives quanti ers way internal language topos 
speci cation internal equality internal logic 
casl annotation def indicates de nitional extension extension induces isomorphism model categories 
similarly implies precedes formulas logical consequences previous axioms 
may come surprise relevant formula shown expresses form extensionality known categorical models internally extensional see detailed discussion point 
spec forall type op eq pred eq tt res eq res eq def forall type ops ex pred pred impl pred unit unit ff pred unit neg pred unit pred eq tt impl unit eq unit unit impl impl impl ex pred unit impl impl ff unit neg unit impl ff implies forall type 
eq impl fig 

speci cation internal logic internal logic intuitionistic may truth values type pred unit regarded type truth values neg neg general di erent obvious deduction rules proved lemmas hard show rule 
formula internal logic term type unit derivable rules de nitions 
external logic remains classical soon predicate appears atomic formula internal truth values tt collapsed external false presence internal equality ect terms longer correspond programs equality function types undecidable 
consequence interpretation certain type de nitions changes substantially see 
see detailed analysis ect internal equality side categorical models 
external extensionality cf 
section internal logic classical sense truth values may tt ff implies sorts singletons 
course explicitly require tt ff recursive datatypes order represent functional programs hascasl recursive datatypes indispensable feature 
rst order casl recursive data types de ned means keyword type cf 
may quali ed preceding free generated type declaration de nes constructors optionally selectors declared type 
generated constraint introduces induction axiom intuitively means type term generated junk 
free constraint additionally produces case operator means terms kept distinct confusion 
de nition requires warning rst order casl meaning free type coincide corresponding structured free extension denoted keyword free followed speci cation curly brackets 
di erence free extension requires newly arising function types freely term generated undesirable ect precluding function de nitions types 
automatically generated operators axioms free datatype shown notation assumes type declaration form free type cn nkn ij non recursive equal generalization nested mutually recursive types great additional diculties 
axioms extensive internal logic introduced 
case pred nkn impl recursive occurences impl induction forall type op case 



nkn 
eq case equation constructor case def fig 

automatically generated axioms free datatypes operators take argument de ned type function argument constructor chosen depending constructor produced 
assume speci cation natural numbers primitive recursion 
de nition free datatype means axioms constitutes conservative extension provided argument types constructor contain built type constructors 
unit recursion limited right side function arrow 
seen means representing construction datatypes isabelle hol 
yoneda style extension result fact show natural numbers conservative internal logic clear internal equality type pred nat introduced conservatively 
technically impose restrictions types appear recursion 
case recursion left hand side function arrow usual russell type paradoxes appear 
consider type type abs rep 
axiomatizing untyped partial calculus 
presence internal equality negation available terms term res def rep produces russell contradiction 
contradiction case means predicates true sorts element 
hand speci cation non trivial models plain hascasl internal equality corresponding domain equation solved category pointed cpos partial cartesian closed suitable class subobjects gives rise henkin model 

interestingly type type abs rep required total untyped calculus usual non trivial models presence internal equality take cartesian closed category re exive object functor category set op topos gives rise henkin model internal equality 
yoneda embedding 
set op preserves cartesian closed structure partial cartesian closed structure re exive object provides non extensional model type :10.1.1.47.1059
recursive functions problem henkin semantics function types intensional extensional primitive recursive function de nitions general constitute de nitional extensions relevant functions may models interpretation function type 
possible impose cpo structure relevant types ensuring recursive functions live function type 
just case internal logic avoid actual extension language introduce cpo structure means suitable speci cations building speci cation internal equality cf 
section 
concept closely related holcf crucial di erence surrounding logic hol partial :10.1.1.35.4051
speci cation cpo structure xed point operator 
nat speci cation natural numbers sort nat operations nat suc nat nat usual axioms including induction primitive recursion require cpo structure de nition 
introduce type classes cpo cpo complete partial orders complete partial orders bottom respectively generic instantiations extend ordering products partial total continuous function types subclass restricts order equality 
continuous function types subtypes built function types introduced newly declared type constructor partial continuous functions required domains contain element chain contain supremum 
point subsorting features explanation largely skipped 
meaning extra syntactic features essentially casl injective implicit coercion subsort declared supersort true precisely elements subsort 
due de nitions predicates terms necessary order determine subsort uniquely 
elements function types compared pointwise elements product types compared componentwise 
introduce xed point operator polymorphic class cpo type continuous endofunctions operator de ne polymorphic unde ned constant 
course expect conservative internal logic 
obviously problems concerning consistency standard models orderings partial function spaces cpos bottom 
typical instance class cpo free datatype constructor arguments class cpo 
datatype instance automatically generated generation process invoked means keyword deriving borrowed haskell 
constructors section obtain instance cpo case 
case ff built syntactical sugar case operation applications di erent constructors incomparable applications constructor compared comparing arguments 
circularity de nition ordering recursive xed point operator 
imposes particular equation ordering equation determines ordering uniquely induction axiom 
easy see case operation restricted continuous arguments continuous ordering de nitions recursive functions 
actual recursive de nitions letrec construction usual way regarded syntactic sugar expression involves partial downcast total continuous function type 
long operators right types expressions denote functions call term context type class cpo continuous belongs subtype continuous functions de ned 
call type cpo type built basic sorts type variables class cpo means instance declarations type constructors particular cpo types class cpo 
proposition 
operator constants application occur variables cpo types continuous 
spec recursion nat class cpo forall cpo ops pred pred nat pred nat sup nat 
impl impl eq nat nat suc nat nat nat def sup impl sup impl sup nat impl def sup class pcpo cpo forall pcpo op bottom bottom instance cpo eq instance cpo cpo instance pcpo pcpo instance unit pcpo instance cpo pcpo type 

def impl def nat def sup impl ex nat def sup nat 
sup 
def impl instance cpo cpo type def gg instance cpo pcpo pcpo def forall pcpo ops eq eq impl op unde ned unit unit 
fig 

speci cation cpo structure xed point operator proof 
straightforward induction typing rules deduction 
crucial point notice continuity survives application abstraction 
consequence abstractions terms proposition belong subtype continuous functions possess xed point 
note xed point operator cpo type provided parameter instantiated cpo type 

di erent approach recursive function problem pursued synthetic domain theory sdt sdt type propositions truth value object topos domain classi er pred unit distinct impose requirement functions continuous somewhat di erently de ned ordering general fails antisymmetric order relation type propositions 
simplistic view internal equality necessarily fails monotone 
sdt approach put top hascasl internal equality de ned ects methodology need examined 
speci cation language spectrum continuity problem dealt fashion elements function types required continuous non continuous operators instance predicates admitted abstracted language available requirement speci cations expressive 
particular logic proper sense available terms type booleans type negation xed point 

continuous function types introduced bring back possibility specifying datatypes recursion left side partial function arrow need replace function type continuous function type cont resulting datatype usual solutions corresponding domain equation category cpos models 
hascasl speci cations haskell programs example consider requirement speci cation nite maps keys elements module library glasgow haskell compiler spec bool type type type type forall key eq elt elt elt type ops key elt key elt key elt key elt key elt key 
elt key elt elt key elt key elt forall key elt elt key def true false forall key elt elt key elt key bool speci cation datatype bool booleans constants rue alse type class eq corresponding haskell type class name boolean valued equality function 
re nement steps arrives design speci cation implements maps association lists necessarily ective way spec assoclist bool forall elt elt elt cpo key cpo eq free type list list deriving cpo type assoclist key elt list key elt ops assoclist key elt assoclist key elt key elt assoclist key elt assoclist key elt key elt assoclist key elt key 
elt rec assoclist key elt key case unde ned key elt elt assoclist key elt assoclist key elt rec key elt elt assoclist key elt case 
map operation de nition op rec syntactic sugar operation declaration op axiom 
xed point operator section 
speci cation executable monomorphic sense isomorphism unique model henkin style semantics intensional extensional generally infeasible impossible eliminate looseness inherent interpretation function types 
note particular types assigned general class type re ned types class cpo assoclist 
re nement expressed means standard casl structuring features view assoclist type 
assoclist ops 



transition cpo types standard types achieved simply forgetting cpo structure 
assoclist apart syntax issues form haskell program 
fact large subset haskell directly translated hascasl style example provided denotational semantics 
claim practice show denotational semantics compatible operational semantics existing haskell compilers sense operational semantics de nes model translation hascasl 
propose hascasl speci cation development functional programs particular haskell programs 
hascasl faithfully extends rst order casl intensional subsorted partial higher order logic type class oriented ml polymorphism 
semantics straightforward exible 
particular shown possible extend internal logic terms means speci cations written hascasl way turn recursive datatypes holcf style xed point theory speci able spectrum retained non continuous function types purposes requirement speci cations 
ended logic allows write functional programs speci cation language de nitional extensions programs natural direct correspondence haskell programs 
need mediating logic morphisms interface logics speci cations programs 
partly concern inclusion programming language features hascasl particular features provided glasgow extensions haskell 
rst steps agenda addition existential types provided established lead inconsistencies ones arising full system polymorphism cf 

possibly easier extensions concern multiparameter type classes constructor classes 
semantic properties obvious embedding rst order casl hascasl need elaboration particular casl structuring operations 
case rst order casl proof support hascasl supplied means encoding isabelle hol special attention paid coding intensional function types 
subsequent step aim integration corresponding tools languages maya environment provides management proof obligations structured speci cations management change speci cations programs evolutionary software development paradigm :10.1.1.47.1059
tool animating executable hascasl speci cations means translation haskell 
forms part dfg funded project hascasl kr 
partial support cofi working group esprit wg gratefully acknowledged cofi language semantics task groups 
wish bernd krieg br solution non strict function syntax problem christoph useful comments 

ad amek herrlich strecker concrete categories wiley interscience 

astesiano cerioli free objects equational deduction partial conditional speci cations theoret 
comput 
sci 


mossakowski integrating hol casl development graph manager maya submitted 

berghofer wenzel inductive datatypes hol lessons learned formal logic engineering theorem proving higher order logics lncs vol 
springer pp 


breazu tannen meyer lambda calculus constrained types logic programs lncs vol 
springer pp 


cofi common framework initiative algebraic speci cation development electronic archives www brics dk projects cofi 

cofi language design task group casl cofi algebraic speci cation language summary version documents casl summary july 

cofi semantics task group casl cofi algebraic speci cation language semantics note version july 

coquand analysis girard paradox lics ieee computer society june pp 
:10.1.1.35.4051

goguen categorical manifesto math 
struct 
comput 
sci 


goguen stretching rst order equational logic proofs partiality subsorts retracts appeared proceedings international workshop order theorem proving risc linz report pp 


grosu semantics spectrum lncs 

guttag horning garland jones wing larch languages tools formal speci cation springer 

henkin completeness rst order functional calculus symbolic logic 

hyland steps synthetic domain theory category theory lnm vol 
springer pp 


sannella tarlecki de nition extended ml gentle theoret 
comput 
sci 


lambek scott higher order categorical logic cambridge 

mac lane categories working mathematician springer 

mitchell scott typed lambda models cartesian closed categories categories computer science logic contemp 
math vol 
amer 
math 
soc pp 


moggi categories partial morphisms calculus category theory computer programming lncs vol 
springer pp 


partial lambda calculus ph thesis university edinburgh 

mossakowski krieg br subsorted partial higherorder logic extension casl workshop datatypes lncs vol 
springer pp :10.1.1.35.4051


till mossakowski casl semantics tools tacas graf schwartzbach eds lecture notes computer science vol 
springerverlag pp 


mosses casl guided tour design workshop datatypes lncs vol 
springer pp 


plotkin domains pisa notes www dcs ed ac uk home gdp 
poign speci cations theories models higher types inform 
control 
:10.1.1.35.4051
holcf higher order logic computable functions lncs vol 
pp 


rosolini continuity ectiveness topoi ph thesis university oxford 

schr oder classifying categories partial equational logic tech 
report university bremen available www tzi de hascasl ps 
schr oder mossakowski de nition hascasl tech 
report university bremen available www tzi de hascasl hascasl ps 
scott relating theories calculus curry essays combinatory logic lambda calculus formalisms academic press pp 


wenzel type classes overloading higher order logic theorem proving higher order logics lncs vol 
springer pp :10.1.1.35.4051


glynn winskel formal semantics programming languages mit 
