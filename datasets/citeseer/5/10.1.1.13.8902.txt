ordering heuristics arc consistency algorithms richard wallace eugene freuder department computer science university new hampshire kingsbury hall college road durham nh usa mail ecf cs unh edu arc consistency algorithms solving constraint satisfaction problems important constraint logic programming languages 
search order heuristics arc consistency algorithms significantly enhance efficiency implementation 
propose evaluate ordering heuristics 
care taken experimental design involving random problems statistical evaluation results 
heuristic identified yields savings average standard measure consistency pair checks reasonable heuristic computation cost 
arc consistency insures mutually constraining problem variables mutually consistent value find value satisfies constraint 
constraint specifies pairs values simultaneously assumed pair variables 
arc consistency fundamental concept constraint reasoning mackworth played significant role constraint logic programming dincbas van hentenryck arc consistency answer temporal reasoning questions meiri various forms arc consistency utilized various roles solve constraint satisfaction problems csps find values set variables satisfy set constraints 
artificial intelligence problems scene analysis scheduling viewed csps 
classes problems arc consistency processing essentially finds solution freuder deville van hentenryck algorithms repeatedly employ generalized forms arc consistency find solutions arbitrary problems mackworth material supported national science foundation 
iri 
government certain rights material 
done second author visiting scientist mit artificial intelligence laboratory 
freuder arc consistency preprocessing search may simplify problem point little subsequent search effort needed especially initial boundary conditions known waltz full partial arc consistency combined backtrack search hybrid algorithms nadel indication literature ordering heuristics improve performance relaxation constraint propagation algorithms achieve arc consistency waltz heuristics received systematic study 
contrasted considerable attention devoted ordering heuristics constraint satisfaction backtrack search 
initiates systematic study 
identify factors determine efficiency constraint propagation 
probabilistic arguments suggest relationship factors certain easily measurable problem characteristics 
ordering heuristics proposed problem characteristics 
careful testing random problems verifies expectations increased efficiency 
best heuristics halve number constraint checks standard measure performance 
worstcase complexity overhead involved computing ordering linear number constraints add worst case complexity arc consistency algorithm 
computation time data confirms efficacy heuristic 
experiments standard ac arc consistency algorithm mackworth ac mohr henderson better worstcase bound ac worst case bound optimal incurs time space costs building maintaining elaborate data structures 
ac subject ordering improvement demonstrate experimentally tests ac efficient ac 
expect ordering heuristics improve partial arc consistency algorithms haralick elliott dechter pearl nadel freuder wallace ideas generalizable higher level consistency algorithms montanari mackworth freuder cooper section reviews basic concepts 
section discusses factors determine efficiency relaxation problem section discusses orderings expected enhance performance priori 
sections describe methods results respectively experiments random constraint satisfaction problems designed assess effectiveness orderings heuristics 
section considers effort required obtain orderings specific heuristics 
section summarizes 
basic concepts constraint satisfaction problem csp involves set variables having domain values assume 
addition problem subject number binary constraints ij subset cartesian product domains binary constraint specifies pairs values simultaneously assumed pair variables 
binary constraints considered higher order csps represented binary csps rossi csp associated constraint graph nodes represent variables arcs represent constraints 
ac involves sequence tests pairs constrained variables say relaxed specifically values checked constraint see supported consistent value domain unsupported values deleted 
ac algorithm shown 
ordered pairs constrained variables put list pair removed relaxed values deleted pairs may need added determine deletions lead deletions 
initialize constraint exists empty select remove relax relaxation removes values add pairs vk constraint vk vk ac algorithm 
order pairs selected relaxation reduces question ordered pair selected 
specifically ordered initialization phase insert additions relaxation phase 
ordinarily initialization order simply derived order problem described maintained queue mackworth freuder nadel concerned heuristics ordering result efficient processing 
factors determine efficiency relaxation differences efficiency relaxation depend ordering ascribed factors value deleted relaxed performed constraints include tested restriction minimizing number tests deletion ii reduced pairs nodes adjacent node relaxed list minimizing number list additions relaxations 
factors consistent principle orderings domain values removed quickly possible asap principle 
idea stated waltz discussion filtering descriptions line drawings viz basic heuristic speeding program eliminate possibilities early possible 
heuristic characteristic efficient performance conformity principle determined advance 
bg ch ci cd ce cf constraint graph restriction diagram csp illustrating relaxation principles 
aspect csp structure affect efficiency order relaxation presence sequential dependencies pattern domain support 
example suppose values domain support value supported values domain case relaxing removes values supported values relaxed values removed time variable pair tested 
hand relaxed relaxed values removed values retained eventually eliminated 
failure observe dependencies result pairs put back list examined special case minimizing additions list variable pairs 
specific sequential dependencies gaschnig principles illustrated simple example figures 
csp case vari ables constraints constraint graph tree 
domains number values constraints number acceptable pairs 
includes restriction diagram showing values possibly deleted relaxation dependencies 
variable pairs domain subject restriction shown left column right includes values depth dependency subscripted variable names 
diagram gives parallel view relaxation 
dependency relations specific values shown arrows 
start abc def ghi ordering conforms asap rule ag remove cks def ghi ag remove def hi ag ag fails minimize pair checks list additions ag cks ag remove def ghi ag remove def hi ag fails minimize additions sequent depend 
violations ag cks ag remove bc def ghi ag remove def ghi ag remove def hi ag fails respect sequential dependency ag cks ag remove def ghi ag ag ag remove def hi relaxation different orderings 
course relaxation problem different ac list orderings shown 
constraint checks shown successive rows including variable relaxed ag indicates relaxed values removed number value pairs checked assuming lexicographic order current domains instance domain restriction 
example shows ordering consistent asap principle relaxed pair includes adjacent node list dependency respected relaxed domains reduced 
second example relaxed domains original sizes pair checks required 
third example relaxed pair removed list value deleted domain put back 
fourth example sequential dependency violated deleted relaxed lack support domain discovered second test 
rationale order heuristics ordering heuristics devised major features constraint satisfaction problems number acceptable pairs constraint constraint size satisfiability nadel ii number values domain iii number binary constraints variable participates equal degree node variable constraint graph 
simple examples heuristics expected improve efficiency relaxation ordering list variable pairs relative satisfiability proportion possible pairs acceptable ii ordering increasing size domain variable relaxed iii ordering descending degree node variable relaxed 
important note principles efficient relaxation described section depend differences features 
example domain size satisfiability constant 
easy construct similar examples degree node vary 
conversely variation features guarantee particular heuristic enhance efficiency 
example smaller domain size imply relaxation acceptable pairs include domain values 
means case ordering heuristics depends probabilistic arguments 
words show ordering expected enhance efficiency assumptions expected failure domain support 
binary constraint range possible product participating domains divided parts relaxation inevitable possible impossible respectively 
subranges inevitable dmax possible dmax dmax dmin dmin impossible dmax dmin dmin dmax dmin basis division hard see constraint size size largest domain values supported ii value larger domain supported largest possible constraint size larger product smaller domain size larger 
relaxed alternative description intervals inevitable possible impossible accordance asap rule ideal ordering heuristic insure pairs relaxation put list 
particular pairs relaxation inevitable tested 
reordering domain restriction property 
domain pair relaxation satisfiability smaller ordering increasing satisfiability obvious candidate heuristic 
variants idea ordering relative satisfiability satisfiability se discount effects domain size 
third heuristic type suggested argument 
suppose associated pair values probability included set acceptable pairs 
relation holds sizes domains expected size set constraint pairs domains jc ij jc ij jd jd case relaxed domain restriction expected average jd case expected size constraint set smaller domain size 
ordering jd equivalently jc ij jd may effective heuristic 
partitioning argument potential usefulness heuristics domain size 
suppose domains size relaxed domains size 
cases relative number possible values satisfiability inevitable range gamma gamma gamma respectively general number approximately jd similarly relative numbers possible satisfiability values possible impossible ranges approximately jd jd jd respectively 
larger jd relative number values impossible range smaller symmetry binomial expansion relative number possible constraints fall range 
suggests ordering increasing jd effective heuristic 
possibility order pairs decreasing difference size domain variable relaxed domain variable relaxed signs differences considered 
factors equal variable associated constraints value domain supported constraints 
suggests variables constraints tested ordering decreasing degree node constraint graph problem effective heuristic 
example effect heuristics illustrated variation queens problem 
basic problem queens placed board attack 
way represent csp define rows top bottom variables columns left right domain values 
variant domain value associated queen column 
relaxation reduces problem solution column variable column variable table shows number additions list total number value pairs checked heuristics introduced section 
variable pairs equivalent heuristic placed list lexicographic order 
results orderings included lexicographic ordering maintained queue explicitly nadel queue ordering appears method generally indicated ii alternative baseline provided mean random orderings derivation described 
results reversed orderings introduced sensitive method detecting influence heuristic yield results appreciably different orders 
problem effect ordering apparent dramatic 
orderings expected yield performance viz increasing satisfiability increasing size domain relaxed yield lower values measures comparison standards 
token excessive amount required relaxation ordering reverses orders 
noted treating list stack queue improve efficiency 
typical finding problems elaborate placement strategies tested 
table efficiency ac different ordering heuristics queens problem domain restricted ordering additions pair checks random order mn 
queue stack increas 

incr 
rel 

decr 
rel 
increas 
domain 
domain experiments random problems methods problem generation evidence concerning efficiency ordering heuristics obtained experimentally random csps 
main problem sets variables maximum domain size respectively 
number binary constraints specific variable pairs subject constraint size domain number acceptable pairs constraint specific value pairs constraint chosen order random methods 
procedure samples entire set possible csps specified limits producing problems heterogeneous features order ac list satisfiability domain size degree constraint graph node 
examine behavior heuristics csps graphs different density factor constraint number blocked dividing range possible values problem size quarter ranges 
samples problems solution solutions generated quarter range problems lowest quarter ranges variable problems 
method rarely generates variable problems solutions higher subranges 
csps solutions treated separately relaxation stops immediately values domain constraint eliminated 
limits number solutions set variable problems respectively balance representativeness 
variable problems quarter range solutions gave qualitatively similar results somewhat smaller differences 
evaluation performance relaxation performance evaluated basic measure number value pairs checked inclusion constraint 
measures identify factors underlying improvement performance related principles described section number list additions ii mean size domain restriction iii mean location value deletions sequence constraint checks sum products location number deletions divided total number deletions 
necessary assess required sort list initially keep order successive relaxations 
discussed section connection issue efficient sorting methods specific heuristics 
problem baseline perfomance obtained running ac randomly ordered lists 
tests original list produced placing variable pair initial set positions equal twice number constraints specified pseudorandom number 
relaxation execution orders produced placing added pair random possible positions element list 
ordering heuristic partitions set variable pairs feature problem 
equivalence class singleton orders consistent heuristic major step procedure choice variable pair check 
complete assessment heuristic consider range efficiency possible orderings 
feasible cases necessary rely random samples random orderings equivalent pairs initial list random insertion set equivalent pairs execution 
random lists lists ordered heuristics samples size preliminary tests showed gave sufficiently stable means compared samples 
differences orderings evaluated statistically repeated measures analysis variance anova followed nonorthogonal contrasts comparisons individual means 
mean refers specific problem set variable problems addition number pair checks problem mean runs just described 
separate analyses carried variable problems range constraints heuristics factors 
paired comparison tests evaluate differences mean performance constraint ranges orderings heuristic reversed ordering 
results sets random csps marked differences due ordering list variable pairs 
problem sets best orderings reduced number pair checks comparison ordering 
illustration gives results problem sets second subrange constraints 
main included orderings random rand lexicographic ordering maintained queue lex 
heuristic orderings included increasing satisfiability sat increasing size domain relaxed dom decreasing degree node deg 
variable problems effects range heuristic statistically significant 
contrasts orderings heuristic statistically significant sat dom deg 
second anova satisfiability heuristics increasing satisfiability relative satisfiability increasing value ij yielded significant effects range heuristic 
contrasts relatively satisfiability heuristics statistically significant contrast 
effectiveness simple satisfiability depends satisfiability se factor may size domains tend small low 
random lex queue sat dom rel sat cij di lex queue sat dom deg rel sat cij di var var relaxation effort different heuristics 
heuristic shown comparisons reversed order variable problems yielded statistically significant differences favor original heuristic 
shows heuristic effect efficiency distinguished statistically orderings 
heuristics consistent principles efficient relaxation described section indicated analyses list additions domain restrictions relaxation 
anova list additions orderings pair checks yielded statistically significant effects range heuristic nonorthogonal contrasts showed pattern statistically significant results 
fact best orderings required additions required orderings variable problems respectively 
major part improvement performance due reduction list additions 
small highly consistent differences average size domain restriction largest values associated best orderings smallest values reverse orderings 
finding rapid relaxation reflected lower mean values location deletions ratio mean values orderings versus best heuristics suggests heuristics minimized number value comparisons 
finding rapid relaxation course direct demonstration asap principle 
results pertain problems solutions 
problems solutions number pair checks required remove elements domain constraint showed differences orderings problems solutions 
case size differences greater mean performance ratios variable problems variable problems 
statistical analysis yielded pattern statistically significant differences problems solutions 
phase ac uses list variable pairs part algorithm tested amenability ordering heuristics variable problems 
list ordered lexically dom heuristic 
ordering heuristic fewer pair checks performed phase samples problems values deleted effects mean pair checks problems second constraint subrange lexical ordering dom 
far exceeds numbers required entire ac algorithm orderings cf 
similar differences ac subrange due need check value values adjacent domains find total support value 
reason analysis ac extensive examination respect average time complexity effects ordering useful 
effort required keep list ordered ordering heuristics significant effect efficiency relaxation costs incurred sorting original set pairs initial ordering maintaining proper order domains restricted pairs added relaxation execution ordering 
affect time complexity relaxation adjustments may necessary step procedure 
worth considering heuristics order list initially placement strategy stacking queueing relaxation efficient methods maintaining list order phase process 
evidence bearing efficiency initial ordering followed stacking queueing collected variable problems main experiments 
discussion results limited sat dom promising heuristics 
variable problems mean increase value pair checks initial ordering compared initial execution ordering sat dom 
variable problems corresponding increases 
indicates execution ordering significant effect performance carried efficient 
initial ordering performance achieved pigeonhole sort 
dom sufficient number equals maximum domain size large 
sat number holes equal largest product domain sizes longer times may required scan list useless steps due empty holes 
tests number set maximum 
list partially sorted way hole sorted insertion sort fast pairs order 
heuristics performance approximated sets experimental problems 
dom execution ordering straightforward efficient 
domain restriction affected pairs collected pigeonhole steps transferred step 
complexity involved collecting adjacent pairs checking list complexity algorithm maintained keeping list order 
sat process complicated need update representation constraints take ed steps 
affected pairs rearranged list addition adding adjacent pairs may require sort steps 
relaxation dom appears slightly efficient sat terms number pair checks efficiency greater 
dom appreciably faster lex confirmed timing tests variable problems 
average cpu time problem seconds respectively problem difference favor ordering heuristic 
ordering heuristics increase efficiency relaxation reducing number value pair checks factor average comparison orderings 
heuristics order list variable pairs conforms principles efficient relaxation discussed section major effect minimize list additions 
heuristics possible limit involved establishing maintaining effective ordering factor outweigh benefit gained relaxation 
conclude ordering increasing size domain relaxed effective general strategy enhancing performance algorithms establish full arc consistency 
richard suggested heuristics 
karl wrote program generate random csps 
cooper cooper 
optimal consistency algorithm 
artificial intelligence 
dechter pearl dechter pearl 
network heuristics constraint satisfaction problems 
artificial intelligence 
deville van hentenryck deville van hentenryck 
efficient arc consistency algorithm class csp problems 
proceedings twelfth international joint conference artificial intelligence pages sydney august 
international joint committee artificial intelligence 
dincbas dincbas van hentenryck simonis graf berthier 
constraint logic programming language chip 
proceedings international conference fifth generation computer systems tokyo 
freuder freuder 
synthesizing constraint expressions 
communications acm 
freuder freuder 
sufficient condition backtrack free search 
journal acm 
freuder wallace freuder wallace 
selective relaxation constraint satisfaction problems 
third international conference tools artificial intelligence pages san jose ca november 
ieee computer society press 
gaschnig gaschnig 
constraint satisfaction method inference making 
proceedings th annual allerton conf 
circuit system theory pages urbana il 
haralick elliott haralick elliott 
increasing tree search efficiency constraint satisfaction problems 
artificial intelligence 
mackworth mackworth 
reading sketch maps 
proceedings fifth international joint conference artificial intelligence pages cambridge ma august 
international joint committee artificial intelligence 
mackworth mackworth 
consistency networks relations 
artificial intelligence 
mackworth mackworth 
constraint satisfaction 
shapiro editor encyclopedia artificial intelligence 
vol 
pages 
john wiley sons new york 
mackworth freuder mackworth freuder 
complexity polynomial network consistency algorithms constraint satisfaction problems 
artificial intelligence 
meiri meiri 
combining qualitative quantitative constraints temporal reasoning 
proceedings ninth national conference artificial intelligence pages anaheim ca july 
american association artificial intelligence 
mohr henderson mohr henderson 
arc path consistency revisited 
artificial intelligence 
montanari montanari 
networks constraints fundamental properties applications picture processing 
information science 
nadel nadel 
precision complexity analysis framework deriving exact case results 
technical report department computer science wayne state university 
nadel nadel 
constraint satisfaction algorithms 
computational intelligence 
rossi rossi dhar petrie 
equivalence constraint satisfaction problems 
technical report act ai mcc austin tx 
van hentenryck van hentenryck 
constraint satisfaction logic programming 
mit press cambridge ma 
waltz waltz 
understanding line drawings scenes shadows 
winston editor psychology computer vision pages 
mcgraw hill new york ny 
