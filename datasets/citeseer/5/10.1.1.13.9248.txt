secure information flow linear continuations steve zdancewic cs cornell edu cornell university andrew myers cs cornell edu cornell university 
security typed languages enforce secrecy integrity policies type checking 
investigates continuation passing style cps means proving languages enforce noninterference rst step understanding compilation 
low level secure calculus higher order imperative features linear continuations 
linear continuations impose stack discipline control ow programs 
additional structure type system lets establish strong information ow security property called noninterference 
prove cps target language enjoys noninterference property show translate secure high level programs low level language 
noninterference proof rst kind language higher order functions state 

language mechanisms enforcing secrecy integrity policies attractive ordinary access control static information ow enforce policies 
policies require data protected despite manipulated programs access various information channels 
example policy prohibit personal nance program transmitting credit card information internet program needs internet access download stock market reports 
prevent nance program transmitting private information cleverly encoded compiler checks information ows program admissible 
extended revised version conference european symposium programming april :10.1.1.44.5122
department computer science cornell university ithaca ny usa research supported darpa contract monitored usaf rome laboratory 
government authorized reproduce distribute reprints government purposes notwithstanding copyright annotation thereon 
views contained authors interpreted necessarily representing ocial policies endorsement darpa afrl government 
kluwer academic publishers 
printed netherlands 
lincont tex formulating denning original lattice model information ow control terms type systems static program veri cation 
desired security property noninterference states data observable low security computation 
continuing example high security data credit card information low security computation downloading stock market reports 
noninterference says information transmitted insecure network depend credit card data program improperly transmit con information 
problem secure information ow studied context simple imperative languages 
secure information ow context higher order languages imperative features understood 
furthermore previous considered information ow properties source language 
source level analysis compiler transformations bugs 
may introduce new security holes 
appealing option verify output compiler instance typed assembly language proof carrying code :10.1.1.40.2507:10.1.1.40.2507:10.1.1.24.6526
proposes continuation passing style cps translations means studying noninterference imperative higher order languages :10.1.1.48.8807:10.1.1.48.8807:10.1.1.42.4772
approach bene ts 
cps expresses higher order programs form amenable proving noninterference results 
proof security seen generalization previous smith volpano :10.1.1.44.5122:10.1.1.149.7391
second cps useful representing low level programs opens possibility verifying security compiler output :10.1.1.24.6526:10.1.1.44.5122
observe section naive approach providing security types imperative cps language yields system conservative secure programs noninterference sense rejected 
rectify problem introduce linear continuations allow information ow control cps target language precise 
secure cps language explicit folk theorem cps literature continuation feature cps translation begun studied 
stack ordering property linear continuations crucial noninterference argument 
previous noninterference results call value languages theorem holds programs halt regardless high security data :10.1.1.40.1122:10.1.1.2.1684
consequently termination channels arise leak bit run average consider acceptable 
channels captured notion lincont tex noninterference high security data alter running time program change memory consumption 
noninterference holds despite apparent information leaks language provides means observing resources instance access system clock 
attempts address covert channels 
section shows naive type system secure information ow restrictive cps motivates linear continuations 
section presents target language operational semantics novel features type system 
noninterference theorem discussed section proofs interesting lemmas appendix section demonstrates viability language low level calculus showing cps translate higher order imperative programs 
conclude discussion related section 
cps security type systems secrecy integrity concerned tracking dependencies programs :10.1.1.34.3298
diculty implicit ows arise control ow program 
consider code fragment 
implicit ow value stored value stored examining contents program run gives information value information ow 
code secure high security variables low security 
high security means high secrecy low integrity 
dually low security means low secrecy high integrity programmer type system enforcing information ow policies assign type bool high security boolean type int low security integer 
type int program fragment type check low security type type check due implicit ow languages deal implicit ows associating security annotation program counter usually indicate pc 
example program counter point statement labeled indicate depend high security data 
branches conditional program counter depends value chosen give examples imperative pseudo code continuations introduced explicitly hi 
halt invoked hi 
actual syntax secure cps language section 
lincont tex halt hi 
halt hi hi hi 
halt hi halt letlin hi 
halt hi hi letlin hi 
halt letlin hi letlin hi letlin hi 
letlin hi 

examples information ow cps pc security label values constants example pick security annotation program counter consequently type int assignment illegal implicitly high security value assigned low security memory location 
fragment illustrates problem cps translation 
shows code control transfer explicit 
variable bound continuation jump indicated application hi 
invocation lifted branches conditional naive type system information ow conservatively require body write low security memory locations value apparently observable low security code 
program rejected writes low security variable code secure information ow continuation invoked branches 
hand example shows branches information learned observing linear type systems express exactly constraint branches :10.1.1.16.2984:10.1.1.49.4346:10.1.1.31.5002
making linearity explicit type system additional information recover precision source program analysis 
fragment illustrates simple approach addition normal construct include letlin introducing linear continuations 
program certi es secure low security variable 
lincont tex linearity allows precise reasoning information ow linearity insucient security presence rst class continuations 
example continuations linear implicit ow lets observe order invoked 
necessary regulate ordering linear continuations 
type system section requires exactly linear continuation available point eliminating possibility writing code example show section constraints sucient prove noninterference result 
simpler information ow analysis precise source language structure language limits control ow 
example known branches conditional return common merge point 
knowledge exploited obtain conservative analysis implicit ows standard cps transformation loses information unifying forms control single mechanism 
approach target language single underlying control transfer mechanism examples execute exactly code type system statically distinguishes di erent kinds continuations allowing information ow analyzed precision source 

linear continuations diving formal de nition secure cps language helpful intuition linear continuation ordinary continuations represent possible computation program 
manipulated encapsulates control ow aspects piece code 
powerful language constructs call cc expose continuations programmer rst class way allowing user manipulate control ow program directly 
continuations far common case 
observed control ow constructs continuations linearly exactly 
linearity arises restrictions source language functions return exactly merge points conditional statements reachable exactly way branch fact call cc nonstandard control ow operators discard duplicate continuations part dicult reason 
lincont tex combining linearity ordering continuations restricts manipulation 
fact ordered linear continuations essentially enforce stack discipline control 
introducing linear continuation analogous pushing activation record stack invoking linear continuation corresponds popping activation record 
constructs function call return nested blocks merge points conditionals high level structured programs implemented stack activation records ordered linear continuations natural describing control ow behavior 
ordered linear continuations type system description stack control constructs programming language syntax block structure 
separation essential preserving control ow information compilation steps cps transformation syntactic structure program altered 
main insight push information implicitly structure program explicit descriptions types program 

secure cps calculus target secure cps translation call value imperative language similar typed assembly language type system inspired previous language security research :10.1.1.24.6526:10.1.1.40.1122:10.1.1.2.1684:10.1.1.1.3704
section describes secure cps language operational behavior static semantics 

syntax syntax secure cps language 
standard practice information ow systems generalize high low security labels lattice possible security annotations 
elements ranged meta variables pc 
reserve meta variable pc suggest security label corresponds information learned observing program counter 
symbol denotes lattice ordering 
lattice join meet operations respectively greatest elements written 
ordering type system trivial exactly continuation allowed context 
possible generalize results account multiple continuations context :10.1.1.44.5122
lincont tex security labels pc base types int ref pc security types linear types base values bv hi pc values bv linear values lv primitives prim deref expressions prim ref set letlin lv goto lv lv 
syntax secure cps language types fall main syntactic classes security types linear types 
security types types ordinary values consist base type component annotated security label 
base types include integers unit 
continuation types written pc indicate security level types arguments 
notation represents void type indicating continuation returns value 
corresponding types base values bv include integers unit value hi type annotated memory locations continuations pc computation occurs secure values base values annotated security label 
variables range values 
adopt notation label label bv obtaining label type closed value extend join meet operation security types example value represents low security integer type int observable computation 
hand value represents high security integer observable computations top security clearance 
operational semantics ensure labels propagated correctly 
instance low security computation prevented observing sum contains information high security value lincont tex contain security annotations 
example type int ref represents type low security pointers high security integers distinct int ref type high security pointers low security integers 
data returned dereference operation protected join labels 
integers obtained pointers types receive security label 
ordinary continuation pc piece code expression accepts nonlinear argument type linear argument type 
continuations may recursively invoke name bound notation pc indicates continuation may called context program counter carries information security pc 
avoid unsafe implicit ows body continuation may create ects observable principals able read data label pc 
linear value lv variable ranged linear continuation contains code expression parameterized nonlinear argument just ordinary continuations 
linear continuations may recursive may invoked calling context linear types require pc annotation 
syntax serves distinguish linear continuation values nonlinear ones 
ordinary continuations label pc restricts continuation ects ordinary continuations pc constrained contexts opposed elimination contexts 
intuitively linear continuations capture security context created invoked restore program counter label captured 
primitive operations include binary arithmetic dereference means copying secure values 
primitive operations ect free 
program expressions consist sequence bindings primitive operations creation imperative updates set 
letlin construct introduces linear continuation 
code sequences terminated conditional statements nonlocal transfers control goto ordinary continuations linear continuations 
special linear variable halt type represent initial continuation 
corresponds bottom control stack 
formed programs terminate statements form halt nal result program 
lincont tex 
operational semantics operational semantics transition relation machine con gurations form hm pc ei 
notation xg indicates capture avoiding substitution value variable expression memories nite partial maps typed locations closed values 
notation denotes memory obtained updating location contain value type 
memory formed closed dereference operation value stored memory correct type 
denote empty memory write loc set location names occurring label pc machine con guration represents security level information learned observing location program counter 
instructions executed program counter label pc restricted update memory locations labels secure pc 
example shows valid store value memory location type security label data joined security labels program counter lower label security clearance needed read data stored location 
rules show program counter label changes branching data security level 
observing branch taken reveals information condition variable program counter higher security label pc 
shown rules computed values stamped pc label 
notation denotes semantic counterpart syntactic operation 
checks prevent illegal information ows direct means assignment 
shall show section typed programs illegal information ows ruled 
operationally rules goto similar causes control transferred target continuation 
di er treatment program counter label seen rules 
ordinary continuations stamp pc label program counter label annotation target continuation preventing implicit ows 
linear continuations cause program counter label restored potentially lowered context declared 
accordance label stamping intuition goto stamp pc label calling context value passed continuation 
lincont tex hm pc bv bv tpc hm pc tpc bv dom hm pc deref bv tpc hm pc primi hm pc prim ei 
hm pc pc label dom hm pc ref bv ei 
hm bv tpc pc efl tpc pc label dom hm pc set bv ei 
hm bv tpc pc ei hm pc letlin lv ei 
hm pc hm pc 
hm pc hm pc 
hm pc pc hm pc goto bv 
hm pc pc tpc hm pc hpc bv 
hm pc tpc 
expression evaluation mentioned formed programs contain free linear continuation variable halt consequently stuck term halt represents valid terminal state 

example evaluation section gives concrete example operational semantics 
consider evaluation shown 
shows program fragment syntax lincont tex hm letlin impl set 
hi set 
hi 
hm set 
impl hi set 
impl hi 
hm set 
impl hi 
hm impl hi 
hm set 
halt 
hi 
hm halt 
hi fa 


fa 


fa 


int ref int ref impl 
set 
halt 
hi 
example program evaluation secure cps language 
instance condition variable high security value program counter label initially lowest security label 
memory initially maps high security location value low security location value 
information summarized gure 
step transition introduces linear continuation impl binds variable indicated notation impl de nition invoked impl set pc label back 
step program transitions rule testing condition variable 
case high security program counter label increases program takes rst branch 
step transition rule updates contents memory location new value stored high security instantiating pc pc 
assignment succeeds location stores high security data location type int ref check pc label int fail type system section statically rules behavior making dynamic checks unnecessary 
fourth step linear invocation rule 
promised impl resets program counter label addition substitute actual arguments formal parameters body lincont tex continuation 
transition instance rule time updating contents low security value 
program di er ordinary continuation impl crucial di erence appear step rule forced rule 
note increases pc label continuation higher machine con guration 
case calling context pc body continuation forced 
possible write value low security location circumstances write program ordinary continuation place impl forcing high security location 

static semantics type system secure cps language enforces linearity ordering constraints continuations guarantees security labels values respected 
restrictions rule illegal information ows impose structure language prove noninterference property 
mixed linear nonlinear type systems type context split ordinary nonlinear section linear section :10.1.1.44.5122
nite partial map nonlinear variables security types admits usual weakening exchange rules omit 
linear part context consists single linear variable type 
variable exactly discarded 
parts context separated judgments distinct 
denote empty nonlinear context 
figures show rules type checking 
judgment form says ordinary value security type context linear values may mention linear variables judgments form lv 
values primitive operations may contain linear variables security value produced depends program counter 
judgment pc prim say context program counter label bounded pc prim computes value type 
similarly pc means expression type safe contains illegal information ows type context program counter label pc 
forms pc conservative approximation security label information ecting program counter 
expressions represent continuations return type associated judgments pc alternatively write lincont tex tv int tv hi tv ref tv tv dom pc pc pc tv 
value typing rules checking ordinary values tv tv shown part standard 
value contain free linear variables discarding copying value break linearity constraint variable 
continuation type contains pc label check body rule tv 
lattice ordering security labels lifts subtyping relationship values shown 
continuations exhibit expected contravariance rule 
usual invariant respect data stored security labels obey usual covariant subtyping 
consequently ref ref case ref ref linear values checked rules tl tl 
may safely mention free linear variables variables discarded 
may conclude linear variable formed exactly linear context rule tl 
linear continuation rule tl linear context top stack continuations invoked 
intuitively judgment says continuation body exit code may declare pc indicate return 
expressions type simply omit 
lincont tex pc pc pc pc 
value subtyping tl tl dom pc 
linear value typing internal linear continuations consumed 
simplicity disallow subtyping linear types 
rules primitive operations require calculated value security label restrictive current pc re ecting label stamping behavior operational semantics 
values read deref rule tp pick label prevents illegal information ows due aliasing 
lists rules typechecking expressions 
primitive operations introduced expression shown te 
rules creating new doing update rules te te require protect security program counter 
te condition pc label says data read may observed contexts able observe current program counter 
condition pc label te prevents explicit ows similar way 
possible formulate sound type system admits subtyping linear types see hints subtyping rule te 
lincont tex tp pc label pc tp int int pc pc int tp ref pc label pc deref 
primitive operation typing rule te illustrates conservative bound security level program counter propagated label check branches label test pc joined label data tested 
rule goto te restricts label calling context pc joined label continuation program counter label body checked pc prevents implicit information ows propagating function bodies 
likewise values passed continuation linear pick calling context pc constraint pc label carry information context continuation invoked 
rules letlin te te manipulate linear context enforce ordering property continuations 
letlin linear variable body continuation declared 
body declaration checked assumption new continuation available 
collectively manipulations amount pushing continuation control stack 
rule simply requires linear continuation invoked consumes linear continuation declared context corresponding popping control stack 
linear continuations capture pc restrictive label context introduced shown rule te 
rule goto rule constrain program counter label target continuation linear continuation restores program counter label captured 
linear continuations capture pc context mild assumption initial programs introduce linear continuation values variables letlin 
assumption rules trivially insecure programs execution lincont tex te pc prim pc pc prim te pc label ref pc pc ref te ref pc pc label pc set te int pc pc te hpc pc pc pc pc letlin hpc te pc lv pc pc pc label pc goto lv te lv pc label pc lv 
expression typing constraint required programs image cps translation section satisfy property 
type system sound respect operational semantics 
proof part standard style wright felleisen :10.1.1.44.5122:10.1.1.44.5122
simply state lemmas necessary discussion noninterference result section 
lincont tex lemma subject reduction 
pc formed memory loc dom hm pc ei 
hm pc pc formed memory loc dom 
lemma progress 
pc formed loc dom form exist pc hm pc ei 
hm pc note lemmas proved terms containing free occurrences linear variable 
progress lemma treats free linear variable initial continuation terminates program invoked 

noninterference section proves noninterference result secure cps language generalizing previous result smith volpano :10.1.1.44.5122:10.1.1.149.7391
approach preservation style argument shows particular invariant related low security views typed program maintained computation step 
informally noninterference result says low security computations able observe high security data 
term low security relative arbitrary point security lattice low security label 
similarly refers labels 
security level computation indicated label program counter computation place 
low security computation mean transition step operational semantics starting con guration step contains pc 
proof shows high security data computation arbitrarily changed ecting value computed result 
furthermore memory locations visible low security observers locations storing data labeled likewise una ected high security values 
characterization reduces noninterference problem showing program equivalent low security observer point view program di ers high security parts 
key argument formal de nition low equivalence intend capture property programs executions lincont tex indistinguishable observer able see low security portions memory machine state 
show con gurations hm pc hm pc behave identically low security point view 
clearly memories agree values contained locations 
addition pc pc meaning may perform actions modifying low security memory location visible low observers programs necessarily perform computation low security values 
hand pc actions invisible low view 
intuition guides formal de nition low equivalence write de nition builds standard alpha equivalence written base notion equality 
substitutions factor relevant high security values linear continuations reset program counter label 
definition substitutions 
context mean nite map variables closed values dom dom dom case 
substitution application written indicates capture avoiding substitution value free occurrences domain show equivalence nd substitutions containing relevant high security data look factoring high security data 
important piece proof track linear continuations restore program counter label 
stack ordering linear continuations comes play operational semantics guarantees program counter label monotonically increasing linear continuation invoked 
invokes linear continuation causes pc fall follow suit call equivalent continuation low security observer may distinguish stack ordering linear continuations exactly property forces invoke low security continuation note low security linear continuations relevant equivalence programs high security linear continuations programs may di er 
furthermore plan establish invariant respect operational semantics 
means able keep track relevant low security continuations introduced consumed letlin 
lincont tex slight technical diculty doing substitution style operational semantics want maintain invariant equivalent programs equivalent pending low security continuations 
statically linear variable context names continuations dynamically variables substituted away way name low security linear continuation 
get problem approach introduce auxiliary substitutions map stacks linear variables low security linear continuations 
top stack corresponds low security linear continuation invoked 
alternative operational semantics manipulates stack linear continuations directly de ne notion equivalence structured program con gurations 
alternative taken conference version allow multiple linear continuations variables linear context natural correspondence noncommutative linear logic :10.1.1.44.5122
approaches require essentially amount bookkeeping needed noninterference proof 
di erence bookkeeping gets done approach simpli es type system operational semantics expense complicating noninterference proof 
options push additional complexity operational static semantics respectively 
definition linear continuation stack 
ordered list stack linear type variables 
write indicate substitution maps linear value halt ng 
write top indicate top stack application stack substitution term de ned fk note order substitutions important continuation may refer linear variable linear continuation stacks equivalent domain map variable equivalent continuations 
ensure stack contains pending low security continuations 
definition letlin invariant 
term satis es letlin invariant linear continuation expression appearing lincont tex term binding position letlin satis es pc 
idea letlin invariant closed term satis es letlin invariant invocation linear continuation arise substitution words contains pending low security linear continuations 
extending ideas values memories machine con gurations obtain de nitions definition equivalence 
dom case label satis es letlin invariant 
dom case pc satis es letlin invariant 
exist plus terms satis es letlin invariant 
dom dom label implies dom dom 
put requirements de ne equivalence machine con gurations gives invariant noninterference proof 
definition noninterference invariant 
noninterference invariant predicate machine con gurations written hm pc hm pc holds exist substitutions terms conditions met 
ii top pc top pc iii pc pc pc pc iv loc dom loc dom 
vi satisfy letlin invariant 
lincont tex main technical noninterference proof preservation argument showing noninterference invariant holds transition 
pc low equivalent con gurations execute lock step modulo high security data 
program branches high security information jumps high security continuation programs may temporarily get sync time may ect high security data 
program counter drops low linear continuation computations return lock step execution 
rst show equivalent con guration evaluate lock step long program counter low security 
proof lemma appendix lemma low pc step 
suppose hm pc hm pc pc pc hm pc 
hm pc hm pc 
hm pc exist hm pc hm pc stack ordering property linear continuations explicit progress lemma prove equivalent high security con gurations eventually return equivalent low security con gurations 
proof appendix lemma high pc step 
suppose hm pc hm pc pc pc hm pc 
hm pc diverges hm pc 
hm pc exist hm pc hm pc lemmas prove noninterference 
assume program computes low security integer access data 
arbitrarily changing high security data ect program result 
lincont tex theorem noninterference 
suppose halt int int 
initial program label 
hm halt int 
hm halt int implies proof 
term xg term xg 
easy verify halt int int letting fx 
fx 
int 
halt int induction length rst expression evaluation sequence low high pc step lemmas plus fact second evaluation sequence terminates implies hm halt int hm halt int clause noninterference invariant implies soundness implies 
means clause iv range integers halt expressions arise substitution 
clause iii implies halt int halt int obtain desired 

translation section presents cps translation secure imperative higherorder language includes features essential demonstrating translation 
grammar source language 
source type system adapted slam calculus follow label stamping operational semantics :10.1.1.24.6526:10.1.1.40.1122
slam calculus performs access control checks source language type system concerned secure information ow 
judgment pc shows expression source type type context assuming program counter label bounded pc 
omit full account type system lincont tex int ref bv integers recursive functions bv secure values values function application ref creation dereference assignment conditional 
source language grammar focus interesting examples cps translation 
left hand side contains typing judgments interesting source expressions 
source types target continuations functions 
function types labeled latent ect lower bound security level memory locations written function 
type translation previous typed cps conversion terms mutually recursive functions base types security types linear continuation types int int ref ref shows term translation type directed map source typing derivations target terms 
simplicity un optimizing cps translation expect rst class linear continuations support sophisticated translations tail call optimization :10.1.1.42.4772
obtain full translation closed term type pass initial continuation variable instantiated correct type halt expected linear continuations introduced translation points correspond structure source program pushing activation record stack introduced pops occur 
linear variable represents current top stack continuation invoking cause activation stack popped executing body continuation note lincont tex pc pc pc pc pc pc pc pc pc label pc letlin letlin goto pc pc pc int pc pc pc pc letlin int pc pc pc int pc ref pc label pc letlin ref letlin set pc pc ref 
cps translation pc tpc fresh 
implicit control ow source language expressed linear continuations ordinary continuations express functions may copied invoked inherently nonlinear 
unique return continuation function represented linear continuation 
basic lemma establishing type correctness translation proved induction typing derivation source term 
result shows cps language precise source 
lincont tex lemma type translation 
pc pc pc proving cps translation operationally correct scope translation substantially identical translations shown correct 
expect simulation techniques due plotkin adapted prove similar correctness results transformation 

related constraints imposed linearity seen form resource management case limiting set possible computations 
linearity widely context memory consumption :10.1.1.16.2984:10.1.1.49.4346:10.1.1.1.3704:10.1.1.31.5002
linear continuations studied terms category theoretic semantics computational interpretation classical logic :10.1.1.43.8416
pfenning investigated connections ordered linear logic stack machines cps 
studied number situations continuations linearly 
linearity plays role security types process calculi calculus 
usual translation calculus calculus seen form cps translation enlightening investigate connections security process calculi low level code 
cps translation improve results binding time analyses 
particular damian danvy showed cps translation provably improves results binding time analysis calculus 
approach cps translation control ow binding time information 
results suggest connection binding time analysis security warrants investigation :10.1.1.34.3298
palsberg wand proposed cps transformation ow information control ow 
burn studied cps transformation means improving strictness analysis 
sabry felleisen observed analyses confuse continuations applied cps programs decreasing precision 
type system distinguishes linear nonlinear continuations avoid confusing calls returns 
linear continuations appear higher order analog control ow graph 
algorithms determining see muchnick text yield inference techniques linear continuation types 
conversely linear continuations lincont tex yield type theoretic basis correctness proofs optimizations post dominators 
system applies technology linear continuations achieve new results secure information ow domain 
ultimate goal produce compilers addition transforming code transform accompanying security policies low level code veri ed 
cps conversion compilers closure conversion hoisting various optimizations inlining constant propagation 
transformations may ect information ows build type systems rich express security policies low levels open question 
understanding secure information ow low level programs essential providing secrecy private data 
shown explicit ordering continuations improve precision security types providing target language suitable compilation high level secure programs 
linear continuations provide additional structure sucient prove strong security property noninterference 
james cheney olivier danvy dan grossman greg morrisett fran cois pottier stephanie weirich zheng comments drafts 
jon riecke interesting discussions slam calculus 
appreciated reviewers comments led cleaner presentation type system 

abadi banerjee heintze riecke core calculus dependency 
proc 
th acm symp 
principles programming languages popl 
san antonio tx pp 


abramsky computational interpretations linear logic 
theoretical computer science 

transforming timing leaks 
proc 
th acm symp 
principles programming languages popl 
boston ma pp 


appel compiling continuations 
cambridge university press 

hearn reddy thielecke linearly continuations 
proceedings continuations workshop 

bierman classical linear lambda calculus 
theoretical computer science 
lincont tex 
consel danvy better support static data flow 
hughes ed proceedings fifth acm conference functional programming computer architecture 
cambridge massachusetts pp 


crary walker morrisett typed memory management calculus capabilities 
proc 
th acm symp 
principles programming languages popl 
pp 


damian danvy syntactic accidents program analysis impact cps transformation 
proc 
nd acm sigplan international conference functional programming icfp 
pp 


damian danvy syntactic accidents program analysis impact cps transformation 
journal functional programming 
appear 
extended version available technical report brics rs 

danvy semantics directed compilation non linear patterns 
information processing letters 

danvy formalizing implementation strategies class continuations 
proc 
th european symposium programming vol 
lecture notes computer science 
pp 


danvy pfenning proving syntactic properties cps programs 
gordon pitts eds proceedings third international workshop higher order operational techniques semantics vol 
electronic notes theoretical computer science 
pp 


danvy filinski representing control study cps transformation 
mathematical structures computer science 

denning lattice model secure information flow 
comm 
acm 

denning denning certi cation programs secure information flow 
comm 
acm 

filinski linear continuations 
proc 
th acm symp 
principles programming languages popl 
pp 


flanagan sabry duba felleisen essence compiling continuations 
proc 
sigplan conference programming language design 
pp 


girard linear logic 
theoretical computer science 

goguen meseguer security policies security models 
proc 
ieee symposium security privacy 
pp 


harper lillibridge polymorphic type assignment cps conversion 
lisp symbolic computation 

heintze riecke slam calculus programming secrecy integrity 
proc 
th acm symp 
principles programming languages popl 
san diego california pp 


honda vasconcelos yoshida secure information flow typed process behaviour 
proc 
th european symposium programming vol 
lecture notes computer science 
pp 


honda yoshida uniform type structure secure information flow 
proc 
th acm symp 
principles programming languages popl 
pp 


jones gomard sestoft partial evaluation automatic program generation 
london uk prentice hall international 
available online www dina dk sestoft 
lincont tex 
morrisett walker crary glew system typed assembly language 
acm transactions programming languages systems 

muchnick advanced compiler design implementation 
morgan kaufmann publishers 

burn continuation passing transformation interpretation 
burn gay ryan eds theory formal methods proceedings imperial college department computing workshop theory formal methods 
isle thorns sussex pp 


myers jflow practical static information flow control 
proc 
th acm symp 
principles programming languages popl 
san antonio tx pp 


myers liskov decentralized model information flow control 
proc 
th acm symp 
operating system principles sosp 
saint malo france pp 


necula proof carrying code 
proc 
th acm symp 
principles programming languages popl 
pp 


palsberg wand cps transformation flow information 
journal functional programming 
appear 

plotkin call name call value calculus 
theoretical computer science 

pfenning properties terms continuationpassing style ordered logical framework 
despeyroux ed nd workshop logical frameworks meta languages 
santa barbara california 

pottier information flow inference free 
proc 
nd acm sigplan international conference functional programming icfp 
pp 


sabelfeld sands probabilistic noninterference multithreaded programs 
proc 
th ieee computer security foundations workshop 
pp 


sabelfeld sands model secure information ow sequential programs 
higher order symbolic computation 

sabry felleisen reasoning programs continuationpassing style 
lisp symbolic computation 

sabry felleisen continuation passing useful data flow analysis 
proc 
sigplan conference programming language design implementation 
pp 


smith volpano secure information flow multithreaded imperative language 
proc 
th acm symp 
principles programming languages popl 
san diego california pp 


turner wadler operational interpretations linear logic 
theoretical computer science 

volpano smith irvine sound type system secure flow analysis 
journal computer security 

wadler linear types change world 
broy jones eds programming concepts methods 

wadler taste linear logic 
mathematical foundations computer science vol 
lecture notes computer science 
springerverlag pp 

lincont tex 
wright felleisen syntactic approach type soundness 
information computation 

zdancewic myers secure information flow cps 
proc 
th european symposium programming vol 
lecture notes computer science 
pp 

appendix proofs appendix proves low high pc step lemmas section 
show standard lemmas substitution 
lemma low pc step 
suppose hm pc hm pc pc pc hm pc 
hm pc hm pc 
hm pc exist kk hm pc hm pc proof 
substitutions described conditions noninterference invariant 
pc clause iii implies equivalent expressions pc pc pc 
di erence behavior arises due substitutions di erent memories 
proceed cases transition step taken rst program 
main technique reason cases security level value step low security equivalence programs compute values extend substitutions contain high security data 
show representative cases detail give avor argument remainder follow similar fashion 
hm pc primi hm pc prim ei 
hm pc case form prim consequently transition rule 
locations terms lincont tex respectively condition noninterference invariant holds transition 
suces nd 
prim value take xg 
choices satisfy conditions 
prim value 
consider evaluation hm pc prim bv cases 
prim contain free variables condition iv violated evaluation rules imply label resulting value higher label constituent values label higher 
prim prim prim 
hm pc prim bv bv bv 
exist values bv bv 
take xg 
conditions iv vi hold trivially conditions ii iii easily veri ed operational semantics fact pc pc pc 
hm pc prim bv case 
prim contains variable forces high prim contains value explicitly labeled high label 
follows bv bv take fx 
bv fx 
bv easily seen satisfy conditions 
pc label dom hm pc ref bv ei 
hm bv tpc pc efl tpc case form ref bv note follows pc equivalent pc satisfying invariant 
simply take note efl tpc xg efl tpc xg satisfy required invariants 
leave unchanged ref take fx 
tpc hm pc letlin lv ei 
hm pc gi lincont tex lv halt noninterference invariant holds trivially transition 
lv hpc case letlin hpc pc simply take choose fy 
hpc satis es invariant iv terms typed 
case pc take choose ef hpc satis es invariant iv letlin invariant vi 
remaining invariants easily seen hold memories ordinary value substitutions change 
hm pc 
hm pc case form variable equivalence transition rule 
don change easy establish invariants hold 
variable 
similarly 
don know second program transitions case easy establish resulting con gurations clause holds original substitutions clause ii follows fact con gurations typed clause iii holds part lets relate high security programs clauses iv vi simple consequence equivalence pc pc pc hm pc goto 
hm pc pc case goto lv 
case pc pc invariant iii continuation note 
sub cases depending label 
suces take leave substitutions unchanged fgf pc yg 
label take fx 
pcg 
necessary constraints met yg 
case label 
pc pct pc 
resulting con gurations lincont tex satisfy part clause iii 
bodies continuations irrelevant long invariants satis ed follows build new value substitutions previous paragraph lemma high pc step 
suppose hm pc hm pc pc pc hm pc 
hm pc diverges hm pc 
hm pc exist hm pc hm pc proof 
cases transition step rst con guration 
pc rules increase program counter label may choose zero steps show preserved 
condition iii holds part 
invariants follow values computed memory locations written labels higher pc 
memory locations ected high security similarly te forces linear continuations introduced pc 
substituting maintains clause invariant 
consider case 
lv lv 
lv variable clause vi ensures program counter lv body 
pick steps second con guration easily follows resulting con gurations lv variable assumption pc 
assume diverge 
progress lemma hm pc 
hm pc assumption diverge 
simple induction length transition sequence shows program counter may 
invariant iv 
furthermore te requires label 
fx 
tpc fx 
tpc take restrictions domain tail choose 
necessary conditions satis ed easily veri ed operational semantics 
lincont tex 
