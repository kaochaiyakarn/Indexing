daisy dynamic compilation architectural compatibility kemal erik altman ibm thomas watson research center yorktown heights ny kemal erik watson ibm com vliw architectures offer advantages simplicity design high issue rates major compatible existing software base 
describe new simple hardware features vliw machine call daisy dynamically architected instruction set 
daisy specifically intended emulate existing architectures existing software old architecture including operating system kernel code runs changes vliw 
time new fragment code executed time code translated vliw primitives parallelized saved portion main memory visible old architecture machine monitor software residing read memory 
subsequent executions fragment require translation cast 
discuss architectural requirements vliw deal issues including self modifying code precise exceptions aggressive reordering memory presence strong mp consistency memory mapped implemented dynamic parallelization algorithms powerpc architecture 
initial results show high degrees instruction level parallelism reasonable translation overhead memory usage 
keywords instruction level parallelism object vliw nary translation background motivation long instruction word vliw architectures fer advantages design simplicity potentially short clock period high issue rates 
unfortunately high formance sufficient success 
major impediments vliw new ilp machine architecture inability run existing binaries architectures 
argued face permission digital hard copy part personal classroom granted fee provided copies distributed profit commercial advan tage copyright notice title publication date appear notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee 
isca denver usa acm keynote speech architectures run intel code may doomed failure regardless speed 
solve compatibility problem efficiently proposals plain caching lo 
object code translation approach software program takes input executable module generated old machine profile directed feedback information past available 
generates new executable module run architecture resorting interpretation difficult cases gives results plain 
nasty challenges static object code translation programs printing checksum shared variables self modifying code generating random number branch target address addressed static object code translation solution problems 
object code emulate applications written existing machine primitives may need generated emulate old architecture instruction unsafe simplifying assump tions may need ordering shared variable accesses number bits floating point representation get performance cast full compatibility sacrificed 
hard ware features help compatibility important old architecture designed new fast machine compatibility just emphasized came thought 
example set condition codes maintained quite different different architectures 
ob ject code translation approach allow running important applications old new machine provide replacement old machine terms speed range applications architecture fully binary compatible old hardware design run best performance old binaries new features new architecture improve performance bc object code translation recompilation solution perfect 
rapid adoption new tural features higher performance may possible certain circumstances scientific technical computing example 
computer designers underestimate strong inertia user community software vendors large resistance change 
approach translate old architecture instructions new internal representation vliw icache time hardware 
approach robust sense implements old architecture completely 
optimizations performed hardware limited compared software opportunities 
conversion old architecture representation memory internal icache representation complex especially attempts re ordering require substantial hardware design investment vlsi real estate 
alternative daisy instruction set front yorktown 
daisy employs software translation attractive dispenses need complex hardware sole purpose achieve compatibility possibly ugly old architecture 
appropriate superset features new architecture condition codes inx powerpc format daisy dynamically architected software efficiently emulate old architectures 
assuming clean slate hardware emulation software adopt simple design philosophy architectural features compilation techniques required software translation efficient compatible existing software 
attack problem current 
daisy focus mainly vliw new architecture ideas applied new superscalar design potentially new lp architectures break binary compatibility 
current compiler techniques attaining high ilp unacceptably slow dynamic parallelization requires real time performance compiler order overhead imperceptible user 
describe new significantly faster parallelization technique 
implemented technique powerpc report initial encouraging ep results 
feature new compilation technique ability maintain precise exceptions original instruction responsible exception identified exception occurs 
order elaborate hardware mechanisms maintain precise exceptions case done 
organized follows give example illustrating new fast dynamic compilation algorithm daisy 
various architectural features support high performance translation described 
describe dynamic translation mechanism daisy runs old software minimal hardware support 
discuss mapping mechanisms old code code back 
provide experimental results conclude 
compilation algorithm call original old architecture trying emulate base architecture 
vliw emulates old architecture called migrant architecture terminology 
base architecture architecture giving examples ibm powerpc 
traditional caching emulators may spend translate typical base architecture instruction depending architectural mismatch complexity emulated machine 
caching emulators fast optimization ilp extraction 
tradi tional compiler techniques hand extract considerable ilp cost overhead 
goal daisy obtain significant levels ilp keeping compilation overhead minimum meet severe time constraints virtual machine implementa tion 
traditional vliw scheduling daisy examines operation order occurs original binary code converting risc primitives oper ation 
risc primitive generated daisy imme finds instruction placed doing global scheduling multiple paths loop iterations maintaining precise ex 
shows example powerpc code conversion code conversion uses gorithm described 
discussion main points clear 
major points operations original powerpc code scheduled sequence vliw turns vliw instructions yielding ilp possible paths code 
operations added current path 
input data op eration available prior vliw operation performed early possible result placed renamed register architected original architecture 
renamed register copied original architected reg vliw 
illustrated xor instruction step result renamed copied original nation vliw 
having result available early instructions moved 
example step result copied 
note parallel semantics operations vliw read inputs outputs current vliw written 
renaming scheme just described places results architected registers base architecture orig inal program order 
stores operations animated version example please visit www research ibm com vliw 
cde add rl cl sli rl xor 
ada ra bc add rz bc ll cnt add rl xor vliw ir ll vl rl xor 
rb add xor bc bc ca code rl ll sli ls bc vliw add rl rz bc ll rs sub vliw ir rb bc example conversion powerpc code vliw tree instructions 
non destinations placed vliw current path 
way precise exceptions maintained 
example assume external interrupt occurs im finishes executing prior start vliw 
interrupt handler just incrementally compiled version standard pow interrupt handler 
looks pow architected registers 
registers appear instruction bc just completed execution control pass instruction sli 
instruction address register set proper powerpc address sli described section vliw expects value speculatively executed xor non register valid entry point handler return value saved powerpc interrupt handler value may corrupted return interrupt 
vmm interpret powerpc instruc tions starting instruction sli reaching valid entry vliw code depends values powerpc architected registers compile new group vliw starting instruction create valid entry point 
vliw instructions trees operations multiple conditional branches allowed vliw 
branch conditions evaluated prior execution vliw alu memory operations resulting path vliw executed parallel note approach works data mis interpreted code aggressively scheduled 
dis section side effects architected re sources occur point original program occur 
limit scheduling data halting translation unconditional branches 
address branch code reachable ways path page branch page indirect jump 
case address properly translated encountered path cases address translated executing program attempts branch ad dress 
section discuss vliw branch instructions facilitate cases 
example suggests instruction set tni jw architecture superset base architecture efficient execution 
example raises questions 
branch han 
different branch indirect branches handled 
questions arc addressed section 
essential architectural features ag reordering vliw usual support speculative execution moving loads stores optimistically chance overlap discussed 
furthermore code scheduled code cause errant execution 
order keep self contained wc briefly mention address problems 
register vliw additional exception tag bit indicating register contains result caused error 
opcode speculative version implementation operations set infrequent instructions load ters decimal divide decomposed simpler primitives non architected register speculative 
speculative operation causes error cause exception just sets exception tag bit result register 
exception tag may propagate speculative operations 
register exception tag non speculative commit operation non speculative operation exception occurs 
illustrated code code bc ll bc ll load addr load addr copy register architected base architecture 
loaded exception occurs load normally cause page fault segmentation violation 
exception tag bit set 
bc falls attempt copy result exception architected base 
bc taken execution con exception taken 
mechanism allows vmm move loads aggressively condi tional branches changing exception behavior original program 
discussed loads may moved stores proven store location 
turn aliasing speculative load store passed processor changed memory location code starting load 
allows optimistic execution loads single program strong multiprocessor consistency assuming memory interface supports strongly consistent shared memory 
possible distinguish dynamic compile time loads refer space executed order 
speculative memory mapped space load treated op exception tag result register load operation set 
load committed exception occur load re executed non speculatively time 
note exception tags registers part base architecture state invisible base architecture operating system need modified way 
precise exception mechanism need save restore non architected registers context switch time 
assume base archi tecture machine standard register oriented machine sequential semantics 
need case 
example outlines daisy approach implemented java stack machine 
base architec vliw parallel semantics means exchange code con sequential code introducing temporaries 
exchange sequential code 
page address mapping mechanisms section describe address space layout vliw migrant architecture compares base architecture 
describe layout allows translation mechanism migrant architecture runs old base architecture software minimal hardware support 
discuss layout page useful unit translation dynamic translation 
describe daisy robust presence self modifying self referential code possible entry points page need known translating particular entry point page 
vliw migrant architecture virtual memory divided sections illustrated 
low portion starting address mapped identity mapping vliw virtual address vliw real address identical base architecture physical address space 
real memory powerpc absolute memory physical memory 
fig ure example base architecture virtual page virtual address mapped base architecture phys ical page physical address vliw virtual address low portion vliw virtual memory normal virtual memory mechanism base architecture 
middle portion vliw virtual memory address space comprises read store rom contains virtual machine monitor vmm soft ware accomplishes dynamic translation base architecture code vliw code read write area store various data structures needed vmm nonexistent memory area hole vliw virtual address space 
middle section mapped identity mapping vliw virtual vliw real 
third top section translated code area starts large power address called vliw base ox 
ways section mapped page physical memory base ma chine low portion vliw virtual memory times larger page translated code area vliw virtual address space 
achieve efficient mapping base architecture code vliw code power reasonable value powerpc 
actual code expansion larger smaller described sections 
transla tion page physical address base archi tecture physical memory vliw virtual address vliw base 
translated code area mapped vliw virtual require vi real memory area times larger base architecture memory 
vmm translates pages execution attempt oc maps real vliw page frame pool page frames upper part vliw real storage discarding ones pool page frames available 
alternative maintain top section memory hash table translated entries 
hash table indexed base architecture physical address contains real address translated vliw code 
hash table maintained vmm adds entries hash table page entry points translated removes translations new pages need space 
approach advantages code translated page contiguous code need moved new entry point discovered wastage portion vliw real memory page need wasted actual translation requires nx expansion 
second mapping complicated approach slower 
simplicity shall discuss mechanisms mapping sections 
second approach extended straightforward manner accomplish actions described 
creation page translation suppose program running base architecture branches base architecture instruction physical address translated version program running vliw branch executed vliw base upper area vliw virtual address space 
assume physical address byte base architecture physical page ng 
base architecture page executed corresponding nx byte page vliw virtual address vliw base mapped vliw translation missing exception occurs handled vmm 
vmm creates translation base physical page physical address corresponding translated code area page map nx byte page frame upper area vliw real memory 
interrupted translated program resumed redo branch address nx base succeed 
fist page base architecture program branches physical address tz second different base architecture physical page executed page turn translated mapped manner 
concrete example shown suppose base architecture program begins operating system branches base architecture virtual address part ofthe ox ox 
base architecture virtual address mapped base architecture page tables base architecture physical address part ox fff 
vliw vliw virtual address vliw base part page ox bf 
translated code branch base virtual address really executed branch belongs vliw virtual page mapped 
branch initially causes translation missing vmm 
vmm creates translation base architecture physical page frame ox writes vliw page frame say vliw real address fff vmm maps vliw virtual page ox page frame ox fff 
interrupted translated program restarted branch vliw virtual address suc interrupt starts executing translated vliw code page 
emphasize contents upper portion vliw real memory managed vmm arc paged 
room needed newly translated code discards translation space 
point may desirable page translations disk save initially wc wish develop architecture requires base software system changes 
exceptions fielded vmm 
tion occurs vliw branches fixed offset type exception vmm area 
far wc described translation nio interrupts handled directly vmm 
type exception occurs translated code executing page fault external interrupt 
cases vmm determines base arc instruction executing exception occurred translation done maintaining precise interrupts described section possible 
vmm performs actions required base putting address interrupted base ar chi tee ture instruction specific register 
vmm branches translation base operating sys tem code handle exception 
operating system done processing interrupt executes return interrupt instruction execution interrupted code translation interrupted instruction 
need address problem branch base architecture address page identified possible entry point translation starting problem addressed section 
concern self referential code code takes checksum code floating point constants real code pc relative branches 
arc transparently handled fact registers base architecture including counter instruction address register contain values ease arch virt address space base arch phys address space vliw ms vliw virtual address space vliw real address space tms physical ba architecture page vliw base physical ba architecture page vliw base top real memory mapper lk page page pty memory ho area vw rom ox phys page phys page base architecture physical memory vliw address space layout virtual real identity map real identity area vmm rom ase architecture physical memory contain program running base architecture 
means code refer registers self referential code trivially handled 
final major concern code 
unit base architecture physical memory low section vliw virtual memory new read bit known base architecture 
unit size powerpc bytes byte 
vmm translates code memory unit sets read bit 
store occurs memory unit marked read processor interrupt occurs vmm invalidates translation page containing unit 
exception precise base architecture machine state time interrupt corresponds point just completing base architecture instruction modified code case code modification done program 
invalidating appropriate translation program restarted branching translation base architecture instruction modified code 
page currently executing modified page occur program restarted 
paragraphs describe logical behavior address mappings 
actual implementation multiple levels address mapping collapsed level cross page branches execute efficiently seen section 
branch instructions described section find trans lation base architecture instruction physical address branching virtual address vliw base 
instruction offset nin page translation offset vliw translated code page 
reality entry points valid time vliw page fact cross page branches deal 
multiple ways implementing cross page branches describe high performance tive 
describe lower performance cheaper alternatives 
high performance branches vliw primitive perform cross page branch ss page reg offset set added register reg obtain effec tive address base architecture 
effective address translated physical address base architec ture multiplied added translated vliw real address address branch target vliw 
base architecture physical address available base archi tecture exception occurs handler vmm exceptions fielded translated vliw code page available translation missing exception occurs 
target vliw marked valid entry invalid entry exception occurs 
execution proceeds target instruction 
give impression ofa ing cisc instruction assume vliw instruction translation lookaside buffer itlb maps base architecture virtual page numbers directly vliw nx real page frame numbers contain translated code 
software guarantee low order bits reg set low order bits effective address reg set immediately available 
low order bits tive address shifted left logz bits applied icache bits allows cache way associative 
time upper bits effective address arc sent itlb 
vliw real address comes icache directory matches vliw real address comes itlb occurs 
target vliw checked valid entry marker cycle optimistically executing target vliw valid entry recovering side effects occur causing exception case target vliw invalid entry 
icache occurs hardware handles 
handle itlb hardware sequencers lower level software implement micro interrupt itlb handler simpler lint philosophy design 
note software vliw horizontal microcode part vliw software necessarily slower horizontal microcode 
types branches 
goto set just branches vliw set current page check valid cn try 
ordinary intra page branches vliw branch 
long offset branch vliw real address link ter lr long set check valid entry itlb bypassed 
branches overflow area may primitives 
cross page branch itlb valid entries nism described intended reducing latency cross page branch 
give simultaneous itlb lookup address translation prior vliw send vliw real address icache advantages icache design 
reg offset translated real address virtual base placed 
lba reg offset goto real addr 
check valid go simpler cross page branches noted earlier give valid entry point approach 
translated code page base page consist vector pointers 
base instruction offset base architecture page vector element vz contain real address vliw code case entry offset created page real address translator routine create corresponding vliw code 
costs level indirection simpler manage 
put translated reg offset tl tl contains real address ptr code entry 
lra reg offset tl load ptr real addr code 
load real tl irl goto code 
valid entry cm goto additional simplicity give itlb simulate big direct mapped itlb memory software 
cases operations doing cross page branch may moved previous vliw latencies hidden 
finding exception causing instruction base architecture mentioned section exception oc vliw code vmm able find base instruction responsible interrupt register memory state just executing instruction 
virtual page address wa register maintained 
contains address current page original code updated translated code cross page branch executed 
simplest way identify original instruction caused exception place offset base instruction corresponding vliw op inside part table relates vliw instructions base instructions associated translation page 
example offset page kept io bit field vliw instruction 
bits assumes byte page aligned byte boundary 
vliw exception semantics en tire vliw appears executed error condition detected parcels offset identifies continue base code 
interpret ing base instructions may needed identifying interrupting base instruction register memory state just 
vliw sequential semantics order superscalar independently executable operations grouped vliw parcels logically preceded exception causing executed exception detected identification orig inal base instruction require interpretation 
ing base architecture code page offset corresponding vliw available original base instruction responsible exception matching assignments architected resources vliw instruction assignments base code starting base code offset 
way avoid extra fields tables pointers original base architecture instructions altogether follows assume vliw sequential semantics exceptions occur parcel vliw opposed vliw boundary 
scheme offsets vliw code relate base architecture tables 
scheme relies fact entry point group vliw known exact correspondence base architecture instruction 
group offset tz translation page original base instruction offset base architecture page 
describe scheme help example 
assume load address causes page fault 
determine base architecture address exception causing instruction vmm finds backward path exception causing parcel entry point group vliw exception registered vliw copy instruction exception bits associated acted 
vmm traces parcel start 
entry point group vliw vliw laid topological order entry point backward scan binary code interrupting parcel nearest entry point able rapidly identify path entry point interrupting parcel 
backward path copy bc vliw vliw load vmm remembers branch directions taken conditional branches case fact bc cr eq taken 
reaching top backwards path base architecture address corresponding calculated set ifthe code expansion 
case calculation yields address base architecture 
path followed forward order load vliw bc copy 
assignments architected registers conditional branches stores vliw code path assignments architected registers conditional branches stores base code path 
assignment cr matched 
load passed architecture 
correspondence bc address base architecture 
vmm recorded branch taken vmm moves instruction base architecture 
load base architecture matched copy vliw 
recorded copy caused exception determines load offending instruction 
vmm puts register base architecture identify exception branches vliw translation exception handler 
base architecture code experimental results cro bc cro eq ll load rs implemented incremental compilation tech nique rs essentially pow purposes 
version tal compiler incomplete anumber 
example combining optimization includes small subset combining possibilities software pipelining implemented 
provide nary results specint benchmarks aix utilities sieve program finding prime numbers stanford integer benchmark 
implementation daisy runs rs machines set rs simulation instructions di rect binary form generated vliw 
rs instructions emulate actions vliw 
effect compiled simulation method similar shade simulating vliw machine :10.1.1.13.6511
transitions vliw counter incremented vliw flowgraph edge 
edge counts information static properties edge alu usage histograms statistical data ob tained run 
call kernel routine translated real call kernel routines simulated current implementation 
applications spend time user library code learn significantly available ilp tradeoffs compiler techniques current implementation 
table contains pathlength reductions achieved specint benchmarks issue machine 
numbers obtained executing benchmarks full specint inputs resulting execution powerpc operations vliw instructions discerned mean infinite cache pathlength reduction 
pathlength reduction equal number operations rs execution trace divided number vliw instructions vliw execution trace 
pathlength reduction viewed measure infinite cache instruction level parallelism program 
vliw machine primitives similar pow vliw code cro load rs vliw bc cro eq copy rs rs ll finding base architecture instruction responsible exception table pathlength reductions code explosion moving powerpc 
integer floating point registers powerpc 
operation latencies powerpc 
total operations memory accesses total conditional branches way branching executed follows tree 
efficient hardware tree vliw described 
implemented incremental compilation algo rithm similar discussed generating binary vliw code assembly level listing produced 
daisy performance achieved quite low cost current experiments daisy required average instructions compile tion 
furthermore daisy comes traditional static vliw compiler im large number sophisticated optimizations takes approximately instructions compile instruction 
way comparison gee compiler average rs instructions machine instruction output 
imple mentation research prototype intended flexible cx 
expect reduce translation overhead significantly straightforward tuning eventual rewrite incremental compiler de ns cycle architecture arch issue alu mem act branches sieve sort wc architecture configuration different machine con sign matures 
rough guess base instructions base instruction achievable implementing aggressive compiler techniques 
code explosion statistics benchmarks table 
average code expansion translated page just code size empty wasted space pages due fixed expansion may lead additional overhead 
placed little emphasis implementation controlling code explosion expect reduce explosion implementations 
notice executed pages get translated code static compiler translates pages executable 
indicates small utilities pathlength reduction changes number resources available migrant machine 
benchmarks achieved ilp primitive machine vliw instructions ops may alu operations may memory ops branch allowed cycle 
performance diverges wide high machine ilp close achieved grep 
measure interest number branches executed 
discussed section branches expensive particularly low imple time permit obtain specint 
table overhead dynamic compilation 
table breaks number branches benchmarks 
powerpc distinct types branches direct branches branches link register branches counter register notice wide variety different benchmarks fraction instructions branches 
analysis compiler overhead table indicates extra runtime second pro gram due dynamic compilation assuming vliw ma chine running ghz assuming incre mental compiler program average ilp instructions cycle 
table devised rough formula relating amount reuse needed page instruction order vliw tal compiler faster base architecture executing particular program 

reuse mean number times translated instruction executes 
table gives idea reuse factor large programs spec benchmark suite 
table indicates high reuse factors mean 
static code sizes obtained rx installed compiler 
final example supports fact dynamic compilation practical 
consider worst case program jumps page page repeating code 
number unique code pages executed reasonable say large percentage increase time probably im perceptible expect millisecond required translate page 
number unique code pages large overhead dominated base architecture os paging activity 
course thrashing due translated code area large lead extreme slowdown prevented 
previous virtual machine concepts years example ibm vm operating systems virtual machines far implemented virtual architecture architecture daisy support different virtual mark tom ravi nair numbers constructing tools obtain 
fia program compress go wg ii branch type ii counter total total vliw exec total table number branches different benchmarks 
integer go ksim cl compress li 
tomcatv swim su cor table reuse factors spec benchmarks architecture vliw 
caching emulators commonly speeding emulation 
example instruc tion individually translated translation cached re emulated lo 
approach sophisticated reordering consequent difficult issues deal maintaining precise exceptions 
inspired vliw compiler research moon ebcioglu compiler techniques rau proposed new dynamic compilation algorithm faster existing vliw compilation techniques achieves run time performance 
initial page translation ideas inspired conte proposed translation page fault time 
approach intended achieving object code compatibility different gcn erations family vliw machines intended emulating existing architecture 
approach clever encoding guarantees size code change translation 
guarantee hold general virtual machine implementations 
dynamic translation hard ware internal vliw representation icache time achieves similar purpose requires complex icache processing hardware hard ware design investment allow sophisticated compiler techniques implemented software static translation executable modules ws done 
static translation address problem achieving compatibility old architecture including operating system code dc device drivers 
arc influences line thought believe combi nation ideas constitute new solution important compatibility problem 
described daisy approach making novel architectures fully compatible ing software base architecture 
daisy achieves special hardware emulation 
approach important making ultimate open system single hardware chip run multiple op erating systems base architectures 
chip constructed appropriate primitive operations multiple base powerpc 
similar technique applied aid migration new ilp architectures break binary compatibility 
space constraints permit elaborate affords practical means achieve oracle parallelism high compilation cost time entry point page encountered instructions page starting entry point interpreted tho execution path revealed interpretation say path compiled vliw stopping point encountered path group entered takes path performance high executes vliw code solely 
details may wish anonymous referees useful suggestions 
wish jaime moreno colleagues ibm observations discussion 
auslander philipose chambers eggers bershad fast effective dynamic tion pldi 

evolution machine architecture national computer conference pp 
cmelik keppel shade fast instruction set simulator execution technical re port university washington computer science engineering department cs edu research compiler papers shade html conte dynamic rescheduling object code compatibility vliw proc 
micro pp 

ebcioglu design ideas ture sequential software parallel pro cessing proceedings ifip wg working con ference parallel processing edited cos pp 
north holland 
available www research ibm com vliw ebcioglu altman daisy compilation architectural compatibility report 
rc ibm watson research center 
available www watson ibm com ebcioglu altman java ilp machine fast dynamic com proceedings ieee mascots tional workshop security efficiency aspects java israel january available www watson ibm com ebcioglu groves global compiler optimizations architectural features improv ing report 
rc ibm watson research center 
available www research ibm com vliw franklin 
fill unit approach multiple instruction issue proc 
micro 
lo emulation risc secret weapon byte april 
ll hwu real keynote speech micro november 
currently american cs ucdavis edu micro schlansker rau hpl architecture specification technical report hpl hewlett packard laboratories technical publications department page mill road palo alto ca feb 
scott mahlke william chen wen mei hwu ramakrishna rau schlansker sen superscalar processors proceedings fifth int conference architec ture support programming languages operating systems asplos boston ma oct pp melvin patt hardware support large atomic units dynamically scheduled ma chines proceedings st annual international symposium microarchitecture december 
moon ebcioglu resource constrained global scheduling technique super scalar proc 
micro pp 
ieee press december 
moreno ebcioglu altman sk 
chen compiler architecture inter action tree report 
rc ibm watson research center 
available www watson ibm com 
nair hopkins instruction level parallelism processors caching scheduled groups proceedings th annual acm ieee international symposium computer architecture denver colorado june 
rau dynamically scheduled processors proc 
micro ieee press december 
rotenberg bennett smith trace cache low latency approach high bandwidth instruc tion fetching proceedings th annual inter national symposium microarchitecture november 
ebcioglu architectural framework supporting heterogeneous instruction set architectures ieee computer vol 
june pp 

ebcioglu architectural cisc higher mance platforms proc 
international conference supercomputing pp 
acm press 
sites binary translation cacm vol 
pp 
feb 
alpha pc february 
