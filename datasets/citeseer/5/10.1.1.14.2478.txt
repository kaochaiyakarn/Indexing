syntax directed amorphous slicing sebastian danicic mark harman malcolm munro dave binkley mohammed lin hu zhang college brunel university university durham north charles street college south road durham baltimore new cross london ub ph uk 
dh le uk 
md usa 
se nw uk 
keywords amorphous slicing conditioned slicing transformation wsl fermat amorphous slice program constructed respect set variables 
amorphous slice executable program preserves behaviour original variables interest 
syntax preserving slices amorphous slices need preserve projection syntax program 
task amorphous slice construction harder result thinner preferable applications syntax preservation unimportant 
describes approach construction amorphous slices syntax tree program sliced require construction control ow graphs program dependence graphs 
approach strengths weaknesses discusses 
amorphous slicer part slicing system includes syntax preserving static conditioned side ect removal transformation phase slicing criterion guidance correctness proofs transformation steps mechanically veri ed 
system handles subset wsl general wsl constructs transformed 
focuses way system uses dependence reduction transformation tactics 
dependence reduction heart approaches amorphous slicing 
algorithms described performance assessed simple empirical study best worst case execution times implementation built top fermat transformation system maintenance re engineering 
program slicing automated source code extraction technique produces version program preserves projection original program semantics :10.1.1.20.9646
traditionally projection de ned terms subset variables interest constructed sole transformation statement deletion 
slice subprogram preserves subcomputation 
amorphous slicing variation traditional slicing semantic property retained slice maintains subcomputation syntactic restriction statement deletion relaxed :10.1.1.13.6694
sacri cing connection syntax smaller slices produced 
amorphous slicing useful applications slicing syntax important size reduction 
example applications slicing re engineering program de nition syntactically altered amorphous slicing may suitable syntax preserving slicing 
applications debugging syntax important amorphous slicing suitable compared syntax preserving slicing 
transformations tend reduce program size slices preserve projected semantics program slicing preserve syntax 
hand slicing transformation way preserves semantics program projection original semantics 
slicing transformation combined result amorphous slicing 
de nition amorphous slicing amorphous slice constructed program transformation simpli es program preserves ect original program respect slicing criterion 
syntactic freedom allows amorphous slicing perform greater simpli cation pi pi pi pi pi pi pi pi original traditional slice push transformation amorphous slice amorphous slicing produces thinner slices removing syntactic restrictions result amorphous slices need larger syntax preserving counterparts 
considerably smaller 
amorphous slicing thought generalisation slicing semantic requirement retained syntactic requirement relaxed 
amorphous slicing transformation traditional slicing 
similarly amorphous slicing thought generalization transformation semantic requirement preserve meaning program relaxed requirement projected semantics respect slicing criterion preserved 
amorphous slicing allows slicing tool semantics interest transformation reduce dependencies original program traditional syntax preserving slicing extract components computation isolated transformation 
consider simple program fragment leftmost section 
program computes face surface areas cylinder radius height computations value built terms previous values creating dependencies statements 
inter dependence inhibits simpli cation abilities traditional syntax preserving slicing 
example syntax preserving slice nal value variable contains program 
consider version original program central section 
version program produced simple code motion transformation rule 
rule pushes assignment forward program re writing expressions past assignment moves 
ect transformation meaning preserving breaks interdependence inhibits traditional slicing 
example example variable depends assignment statements push transformed version depends 
dependence reduction way transformation improve slicing simply obvious ways transformation improve slicing requirement syntax preservation removed 
example amorphous slice variable improved expression simpli cation replace expression pi pi expression pi describes implementation amorphous slicing tool mixes domain independent dependence reduction simpli cation transformations domain speci transformations pre processing transformation traditional slicing construct amorphous slices 
describes architecture system dependence reduction transformation component detail illustrates phase combines produce simpler slices worked example implementation amorphous slicer available experimentation web interface www brunel ac uk slicer 
transformation tactics system may nd application transformation programs 
example side ect removal tactic removes intraprocedural side ects dependence reduction tactic reduces inter dependence statements 
may useful enabling step transformation approaches may useful transformation automatic parallelisation 
rest organised follows 
section explains amorphous slice construction harder problem syntax preserving slice construction 
sections describe amorphous mw proc bound list key var flag var mw proc list key var flag var list key list key fi flag fi od od length peter var peter var length jane var jane var result result original program amorphous slice final value result program fragment interprocedural amorphous slices slicing system details algorithms dependence reduction transformation 
section presents simple worked example illustrates dependence reduction transformation process 
section compares syntax tree approach described conventional approach system dependence graph sdg highlighting strengths weaknesses approach 
section gives results simple empirical study best worst case performance times implementation amorphous slicer wsl 
section shows amorphous static slicing combined conditioned slicing produce amorphous conditioned slices 
section presents brief overview related 
sections 
amorphous slicing harder syntax preserving slicing construction amorphous slices harder construction syntax preserving slices transformation potentially applied amorphous slicing 
previously published algorithms amorphous slicing concerned intraprocedural transformations 
presents simple interprocedural amorphous slicing algorithm initial results performance dependence reduction transformation heart amorphous slicing algorithm 
current approach pushes intraprocedural analysis procedure function bodies 
limitations current approach possible construct interesting slices illustrate way interprocedural amorphous slicing improves interprocedural syntax preserving slicing 
example consider example leftmost section 
program written wsl 
syntax subset wsl 
main program consists nal lines code 
main program calls procedure called presence symbol required wsl unimportant 
rst parameters function bound list key passed value 
remaining parameters flag passed value result constitute results procedure 
var 
construct introduces local variable loop counter 
rest program uses algol subset wsl 
procedure searches list passed upper bound speci ed formal parameter bound reached list reached 
element key located search set index element flag set denotes true 
una ected flag set denotes false 
main program attempts calls determine element peter occurs strictly element jane list sets ag variable result accordingly 
slicing result illustrates di erence syntax preserving slicing amorphous slicing showing amorphous slicing allows simpli cation 
observe purpose determining value result returned parameter required 
flag parameter discarded 
syntax preserving slicing assignment statement conditional statement fi statement od sequence statements procedure mw proc var variable list value parameter list value result parameter list body procedure procedure call var function mw funct var variable list value result parameter list local variable list body function returns value expression function call interprocedural subset wsl architecture system reveal slice body procedure contain assignments formal parameter flag 
parameter bound required slice loop test substitution formal actual parameters simple code motion calls simpli ed substitution simpli cation formal parameter bound redundant dropped de nition call amorphous slice 
syntax preserving slicing prevented exploiting simpli cation opportunity syntactic restriction prevents substituting actual parameter corresponding formal parameter 
amorphous slice simpler corresponding syntax preserving slice syntactic subset 
system describes architecture amorphous slicing system developed part project 
current implementation available experiment web form interface www brunel ac uk slicer 
system consists number components described detail summarised 
phases side ect removal phase approach criterion guidance approach formalisation correctness proof transformations 
purpose section provide context description dependence reduction transformation drt step heart slicer described detail section 
undefined undefined undefined original side ect free version side ecting statements side ect free versions criterion guidance criteria selection component entirely human 
ultimate goal research project partly automate criterion selection component system produce guidance human selecting slicing criteria 
problem guiding choice criterion slicing criterion typically low level human maintenance engineer 
maintenance engineer typically wants ask questions form original program construct simplest program performs master le update operation replicates defensive programming features original closes reactor conditions ects back disk communicates way thermostat controller 
questions asked directly slicing clear map concepts le update defensive programming program variables 
shown combining slicing concept assignment possible construct executable concept slices strengths slicing concept assignment retained 
allows meta level guidance choice sets slicing criteria needed order construct slices 
executable concept slicing concept assignment phase locates candidate code high level criteria le update defensive programming 
concept de ned executable slicing ll gaps resulting subprogram executable extracted high level criterion 
high level criterion concept assignment corresponds set lower level criteria slicing 
approach combination slicing concept assignment described detail 
pre processing system involves pre processing original programs achieve side ect removal 
goal produce version program written form essentially functional sequencing 
eases transformation transformation rules typically easier de ne functional language :10.1.1.43.4834
side ect change program state occurs product evaluation expression 
side ect free expression evaluated simply returns value causing change state 
side ects tend inhibit transformation removed pre processing phase system 
provides examples code fragments side ects side ect free versions 
side ect removal transformation rewrites program may contain side ects semantically equivalent program guaranteed side ect free 
software engineering techniques slicing program transformation program analysis techniques bene 
function program returns program declare programs list procedures list functions main statement sequence true main main drt main drt drt main return od top level interprocedural amorphous slicing algorithm enabling steps 
algorithm achieved system described detail available non commercial www brunel ac uk 
language semantics automated proof checking underlying central phases amorphous slicer approach correctness assurance 
system partly automated formal proof process 
coq proof assistant express check proofs correctness slicing transformation components system 
semantic basis wsl weakest precondition wp program transformation 
order automate proofs slicing transformation algorithms wsl wp semantics wsl formalised coq type theoretic proof checking assistant 
operational semantics wsl constructed equivalence operation weakest pre condition semantics established 
advantages coq proof program transformation constructed coq system hand checked automatically coq system 
removes possible source problems known computer proofs thoroughly checked humans 
details approach formally assured machine checked transformations 
amorphous slicer central amorphous slicer contains subcomponents 
components iteratively applied reduction amorphous slice size possible 
top level algorithm employed central amorphous slicing system described 
gures detailing algorithms notation pattern matching structures components structures push rules rule assignment assignment absorb sub rule assignment assignment ref sub rule assignment sub fi fi rule assignment sub fi fi rule statement statement def st ref st ref st def st def st def st st st st st simplify transformation rules rule expression wsl symbolic computation library attempt simplify expression rule skip fi fi rule false fi rule false fi skip rules applied top level algorithm selected new structures constructed 
avoid confusion notation express algorithm syntactic constructs built quine quasi quotes concrete syntactic constructions wsl statements expressions 
wsl statement 
assignment algorithm level opposed wsl assignment syntactic constructor denoted list structures operated usual selectors head ail constructor append conjoining lists element list 
initial component central amorphous slicer traditional syntax preserving slicer uses traditional interprocedural slicer syntax preserving slicing syntax tree ast 
perform initial syntax preserving slicing step iteration begins perform syntax preserving slicing body iteration 
ect anecdotally faster initial slicing step relatively ecient removes large portion code reduces size problem iteration commences 
syntax preserving slicing domain speci transformations ect identical iteration terminate 
possibility reduction syntax preserving slicing step domain speci transformations designed ect reduce size program 
guarantees iteration eventually terminate 
nal component central amorphous slicer seeks additional transformation rules domain speci problems 
domain speci transformation dst exploits knowledge application domain order improve chances achieving slice size reduction 
earlier shown considerable improvement simpli cation dst 
dst component essentially opportunistic phase approach 
di erent applications require di erent transformation rule sets tailored problem hand 
transformations called targeted transformations targeted particular problem 
domain speci amorphous slicing improve evolutionary testing 
middle component system drt tactic aims remove dependencies improving likelihood subsequent slicing domain speci transformations applicable 
drt consists set transformations aimed reducing statement inter dependence 
phase amorphous slicing engine general purpose reduction inter dependence statements tend reduce size slices applications require slices small possible 
speci cs initial nal phases central slicer described 
dependence reduction component system useful transformation tactic right germane amorphous approach slicing 
described detail section 
dependency reduction transformation algorithm uses set transformation rules achieve form symbolic execution program 
transformation applied semantics preserving 
transformation rules 
rule form interpreted holds fragment transformed fragment 
terms ref def denote referenced de ned variables expression term sub returns expression results substituting occurrences variable expression expression rules implemented drt algorithm walks program ast applying auxiliary transformation tactic push 
push tactic takes assignment statement attempts push forward code sequence 
assignment passes statements de ned variable passed statements updated re ect symbolic ect assignment execution 
pushing forward assignment achieved applying push assignment rule shown 
assignment get stuck pushing process 
happens attempt push assignment variable past statement de nes situation push tactic ect statement sequence assignment pushed 
example consider simple code sequence computing drt requires computing push 
function push rule rst updates assignment orklist 
push algorithm main loop repeated requires pushing past 
doing orklist empty 
ect rst call push push rst assignment past assignments consequent ect replacing right hand sides assignments symbolically evaluated expressions 
rst call push orklist drt 
second iteration main loop drt calls push function drt sl statement sequence returns statement sequence declare cl orklist statement sequences predicate expression statements stuck boolean orklist sl orklist head orklist assignment statement cl stuck push head orklist tail orklist stuck orklist cl append append orklist tail orklist head orklist assignment statement head orklist statement head orklist append drt head orklist statement head orklist append drt head orklist statement head orklist append drt drt unrecognized statement encountered leave head orklist untransformed append head orklist orklist tail orklist move consider statement orklist od return append dependence reduction transformation algorithm function push statement cl statement sequence returns triple statement statement sequence boolean declare orklist statement sequence identi ers expressions statements orklist cl orklist head orklist assignment statement head orklist rule applies assignment vanishes result applying rule return skip append append orklist false rule applies pushes past assignment head orklist result rule applied append orklist tail orklist assignment got stuck front assignment head orklist return append orklist true head orklist assignment statement head orklist conditional pushes past conditional head orklist rule apply head worklist result rule applied head worklist append orklist tail orklist assignment got stuck front conditional head orklist return append orklist true head orklist statement rule applies head worklist result rule applied head worklist append orklist tail orklist assignment got stuck front statement head orklist return append orklist true od reaching point means get stuck passed statements cl return false push algorithm call push orklist 
drt calls push time push call orklist empty 
execution drt complete 
resulting transformation code produced notice dependence assignment assignments transformed process 
slicing new version program respect nal value produce single assignment previously produced entire code sequence 
example shows push transformations combined application traditional syntax preserving slicing produced greater simpli cation traditional slicing 
ect expressions complex statements interdependent slices tend smaller fewer nodes tend assign fewer variables 
course expression assigned increased size result transformation process 
case simple expression simpli cation improves nal amorphous slice worked example section illustrates system example 
example side ect removal phase illustrated 
amorphous slicer implemented wsl side ect free example side ects removed re written wsl 
side ect removal phase amorphous slicing wsl implemented publicly available 
conversion wsl currently performed hand 
example program program intended compute mean value elements array means odd numbers array 
values compute di erence mean mean evens odds 
program contains bug assignment operator place equality test operator testing ag variable denote outcome testing particular element array 
previously observed transformation tendency highlight bugs programs transformation meaning preserving renders program di erent syntax 
worked example shows combination slicing transformation improve transformation bug revealing tendency 
course set transformation rules complete amorphous slices exist theory algorithm 
statement minimal syntax preserving slices generally computable complete set transformations guarantee minimal amorphous slices 
example shows limited set transformation rules combined traditional syntax preserving slicing possible progress 
rest section steps application various components system showing ects example 
side ects program removed 
side ect free program shown obtained 
surprisingly bug involves mistaken side ect side ect removal tactic bug obvious 
side ect free version program contains tell tale conditional code appears anomalous clearly evaluate false making branch conditional redundant 
shown transformation slicing bug evident 
total evens odds scanf bug evens odds total total evens odds mean total abs mean abs mean program program sliced respect implementation amorphous slicer takes produces programs wsl 
presents wsl version side ect free program 
slicing wsl program variable syntax preserving slicing produces conventional slice 
traditional syntax preserving slicing exploit fact execute branch line :10.1.1.50.4405
tip ernst show compiler optimization techniques transform intermediate representation allow optimized syntax preserving slices constructed :10.1.1.26.990
optimizations included drt rule set reduce dependence 
example rule rule standard redundant computation removal optimizations 
applying rule code fragment causes code lines deleted 
applying rule code line transformed transformed slice shown 
note dependence variables evens line broken drt transformations applied 
applying drt algorithm code fragment lines transformed slice shown obtained 
total evens odds scanf bug evens odds total total evens odds mean total abs mean abs mean program side ect free version slicing variable amorphous slice obtained version depicted 
amorphous slice bug manifests fact assignment de ned terms number elements array mention variables evens remains 
presence bug evident 
general aim implementation amorphous slicing remove unwanted semantics program possible creating simplest possible program retains ect original variables interest 
course syntax preserving slicing minimal slices computable 
progress removing unwanted semantics may improve chances faults detected 
advantages disadvantages ast approach traditionally syntax preserving slicing performed system dependence graph variations :10.1.1.50.4405
binkley showed transformation rules incorporated sdg construct amorphous slices 
detailed algorithm amorphous slicing sdg harman binkley danicic :10.1.1.13.6694
section addresses advantages disadvantages approaches ast sdg amorphous slicing 
currently available implementations sdg algorithm codesurfer aristotle system target programming language examples section language 
broadly speaking advantages sdg approach ast approach control data dependence information locally available node computational ort involved preconditions transformations reduced execution order independence sdg removes need code motion transformations 
total evens odds false evens evens odds odds fi total total od evens fi odds fi mean total abs mean abs mean wsl program converted program disadvantages sdg approach include execution order independence sdg transformations harder apply granularity sdg representation occasionally coarse 
sdg syntax preserving slicing algorithm extended handle slicing programs goto statements non sdg approaches handling goto statements :10.1.1.50.4405
amorphous slicing goto statements issue transformed standard restructuring transformations 
section explains advantages sdg approach section explains disadvantages 
general sdg approach thought compilation contrast ast approach interpretive 
strengths weaknesses accrue choice strategies interpretation strategies apply 
section explores observation detail 
advantages sdg approach ast approach advantages sdg come having necessary control data ow information place 
long known simplify computation syntax preserving slices :10.1.1.50.4405
assists computation transformations amorphous slicing reformulating logical constraints terms dependence edges 
reformulation implementation easier ecient 
illustrate advantage consider statement order information ubiquitous ast 
information necessary ordering components captured dependence edges sdg speci cation order program source code 
deal statement order ast algorithm employ transformations achieve relatively simple result achieved single transformation sdg 
total evens false evens evens fi total total od evens fi mean total abs mean conventional slice variable program example consider programs shown ref 
ast approach requires rules allow statements pass 
instance push assignment rule allows statement pass statement yielding program program 
program assignments combined unfold assignment rule enabling simpli cation 
need push assignment rule sdg statement order represented 
fact sdgs program program identical 
program program 

general statements separated assignments variables applications push assignment rule required relocate assignment statement assignment achieved application flow edge removal rule sdg approach de ned rule flow edge removal allowable rhs label sdg sdg fv ug fx vg flow edge removal rule states expression propagated ow edge sdg assignment vertex labeled vertex rewriting allowed safe total evens total total od mean total abs mean transformed slice total evens total total od abs total mean total transformed slice target exactly ow dependence edge variable furthermore represents vertex de nes rewriting rule requires incoming ow edges subset incoming ow edges excluding edge :10.1.1.13.6694:10.1.1.13.6694
safety ensures rewritten graph transformed back sequential program 
advantages ast approach sdg approach sdg approach advantages disadvantages 
discussed 
rst true disadvantage 
second re ects granularity current implementations operate disadvantage merely current implementations approach 
rst disadvantage arises complete lack statement order information sdg 
cases lack information easy apply transformation rules 
transformation rules potentially applied incorrect situations additional edges added sdg denote statement execution order prevent application transformations 
total total total od abs total amorphous slice program variable total scanf total total abs total language version amorphous slice 


new edge rewritten edge potential problems flow edge removal flow edge removal rule excellent example problem 
example consider code 
rewriting ow dependence edge statement statement problematic impossible transform transformed graph sequential program introducing temporary variables undoing transformations 
reason dependences rewritten statement require statement statement rede ned 
example dependence requires statement follow statement satisfactory linear order exists 
note resulting sdg de ned expected semantics 
contrast ast approach assignment line fragment stuck attempt push forward remaining statements 
value assigned line pushed line 
problem requires inclusion statement order information sdg 
second disadvantage identi ed current implementation deals granularity program components represented sdg 
codesurfer aristotle statement level sdgs 
part sdg vertex statement source program 
main exception call statement includes multiple vertices parameter 
statement level granularity certain restrictions necessary particular transformations 
example consider ow edge 
statement level removing ow edge impossible reconstruct program transformed sdg introducing temporary variables incoming ow dependence edges vertex transformation needs restricted 
diculty overcome moving ner granularity sdg nodes 
operator level sdg original code rewritten code 

granularity problem sdg original graph transformed graph rewriting operator level enables rewritings problematic statement level 


od xn xn xn loc best case sliced worst case sliced xn examples best worst case includes vertex operator operand statement statement 
sdg possible keep separate multiple distinct de nitions variable reaches vertex 
illustrated shows operator level sdg code removal ow edge operator level sdg avoids granularity problem de nitions reach di erent operands example impossible transform resulting graph directly program 
graph semantically meaningful sucient information exists reconstruct program temporary variables allowed 
compilation verses interpretation sdg approach requires building sdg 
computationally expensive 
ort required build sdg thought front analysis ort may performed ast approach point constructing slice chosen criterion 
ort constructing sdg may wasted certain circumstances 
instance large function procedure turns omitted slices analyzed building sdg analysed ast algorithm 
situation single slice required computation ort involved rst building sdg subsequently applying slicing problem may outweigh computational ort producing slice directly ast 
situations slices computed ort required build sdg pays ort expended 
od od od od loc program amorphous slice respect synthetic program fragment reduced amorphous slicing empirical performance analysis authors implemented tool produces amorphous slices wsl built top fermat transformation workbench fermat available gpl www dur ac uk dcs mpw martin 
available web interface www brunel ac uk slicer execution time depends predominantly applicability push rules consequent manipulation ast code motion occurs 
section reports performance dependence reduction respect best worst cases 
performance degrades code deleted discovery code deleted requires repeated applications iteration embodied top level algorithm 
pathological case occur practice allows provide upper bound time taken compute amorphous slice terms lines code program sliced 
example fragment denotes pattern worst case rightmost column 
program assignment dependent previous ones assignment pushed 
order produce nal amorphous slice algorithm push line entire program transforming statement passes slicing iteration 
worst case human analysis yields value xn xn achieves result applying push rules times lines code 
worst case performance expected quadratic 
best case lines code deleted 
case best point view performance clearly attractive terms results produces slicing useful statements deleted 
fortunately best case terms performance somewhat pathological example merely provide lower bound computation time required produce amorphous slice 
archetypical code fragment typi es best case leftmost column 
program dependence reduced amorphous slice original program 
best case performance produces identity transformation involves checking statement program best case performance linear 
size loc best case worst case execution times seconds pentium iii mhz size slice viewed percentage reduction rate ranges best case performance worst case performance 
worst case amorphous slice single line code simpli cation produced dramatic 
combining patterns best case worst case generate synthetic program fragments denote cases precisely de ned level size reduction achieved 
example number lines code slice reduction rate construct example program fragment 
example fragment synthetic code fragment algorithm guaranteed consider lines code produce reduction size 
addition time complexity approach space complexity issue 
issue transformation approach lead expression expansion 
worst case space complexity possible exponential space complexity size program 
example consider program fragment xn xn xn application push transformation tactic expressions expanded 
example single application push expansion clearly exponential certain point expected exponential expansion impact execution times 
execution times example shown 
examples empirical study synthetic 
constructed explore best worst case performance tool 
provides de nite statement behaviour respect real program 
results execution times best worst cases time complexity shown 
shows execution times slicing programs di erent sizes achieve reduction rates worst case respectively 
worst case called case 
reduction example suggested anonymous referees 
size loc worst case impact space complexity execution times seconds pentium iii mhz statements quite reaches worst case value line remains 
size worst case program sliced increases size reduction approaches 
small units slice construction time order seconds 
currently observations remain experimental 
worst case results reported reason con dent optimisations algorithm improvements processor performance ensure times tend instantaneous computation amorphous slices 
allows trade precision speed implements anytime algorithm terminated time main loop central amorphous slicer see result produced far valid amorphous slice 
partial result guaranteed valid amorphous slice simply may small achieved little patience 
space complexity results show worst case space complexity leads exponential increase time complexity due ort processing exponentially increasing expression 
results shown 
size program increases lines code exponential expansion expressions kicks consequent impact time complexity 
exponential expression expansion require careful monitoring action avoid unacceptable performance implications 
amorphous conditioned slicing conditioned slicing variation traditional slicing slicing criterion augmented condition 
statements predicates ect values variables interest condition satis ed removed form conditioned slice 
conditioned slice thought conditioned program subsequently sliced 
conditioned program behave identically original condition satis ed 
conditioning program involve simpli cation lines executed condition met may removed 
traditionally conditioned slices constructed statement deletion produce slices 
reason combine conditioning process amorphous static slicing yield amorphous conditioned slicing 
prototype conditioned slicer called wsl implemented approach symbolic execution tool conditioned slicing programs wsl simplify transformation fermat 
fermat simplify allows implementation light weight imprecise theorem prover 
described detail 
size lines code best case touches horizontal axis deleted deleted deleted deleted deleted worst case deleted execution times best set worst cases exp data txt execution times worst case space complexity age personal age personal personal fi fi age income personal income personal personal personal income fi fi blind personal personal fi married age pc married age pc married widow pc pc fi fi fi married age income pc income pc pc pc income fi fi income personal income income personal income tax pc rate income income pc income tax tax rate income income tax tax income rate fi fi fi uk income taxation calculation program wsl personal pc income income personal tax pc rate income income pc tax tax rate income income tax tax income rate tax rate rate income rate syntax preserving conditioned slice amorphous conditioned slice combination syntax preserving conditioned slicing amorphous slicing mw proc lookup element var pos var count count element pos count fi count count od lookup array key array key array key array key 

fi fi original ideal interprocedural amorphous slice desirable result example consider uk tax calculation program 
program represents attempt capture uk tax regulations concerning computation amounts tax including tax payer tax year april april 
person personal allowance amount un income 
personal allowance depends status person re ected boolean variables blind married integer variable age 
tax bands tax charged rates rate rate rate 
width tax band subject status person xed individuals 
condition age income blind married slicing program variable tax syntax preserving conditioned slicing produces syntax preserving conditioned slice leftmost column 
replacing syntax preserving static slicer amorphous slicer described smaller amorphous conditioned slice rightmost column obtained 
way amorphous slicing may improve way conditioned slicing helps extract business rules condition interest 
related slicing introduced mark weiser subject extensive study 
shown intraprocedural slices computed eciently program dependence graph 
result extended interprocedural slicing :10.1.1.50.4405
rst non static slicing criterion dynamic slicing criterion introduced 
dynamic slicing criterion extended quasi static criterion dynamic static quasi static criteria brought single generic conditioned constrained criterion subsumes static dynamic quasi static criteria 
approaches slicing simplifying transformation create slices statement deletion 
choice motivated original application slicing debugging nature slice important 
restriction statement deletion necessary applications slicing emerged 
greater simpli cation power possible restriction statement deletion lifted clearly advantageous lift restriction situations syntax preservation unimportant 
authors indicated syntactic subset requirement syntax preserving slicing hindrance computation small slices 
thesis weiser immediately recognized acknowledged page possible slice constructed purely faithful subset original program syntax 
authors suggested ways combining slicing transformation variety applications including re ning precision syntax preserving slicing assisting testing identifying unobservable components optimising task scheduling register allocation optimisation partial evaluation restructuring cobol parallelization model checking 
amorphous slicing rst introduced harman danicic developed binkley harman binkley danicic ward :10.1.1.13.6694:10.1.1.13.6694
binkley approach uses system dependence graph ward approach uses novel syntax preserving slicing algorithm currently development augmented system producing semantic slices closely related amorphous slices 
binkley shown amorphous slicing aids program comprehension 
hierons harman danicic shown amorphous slices partly ameliorate equivalent mutant problem mutation testing 
approach described dependence reduction procedure boundaries simply push intraprocedural analysis bodies procedures iterate slicing dependence reduction bodies 
simple minded approach produce results particularly combined conditioning 
focus approach show scales suciently form basis development 
progress extend algorithm implementation exploit constant propagation loop unfolding collection domain speci transformations aimed producing increased simpli cation power 
hope combining advanced features existing dependence reduction approach results achieved variety specialised domains 
example consider program 
program typi ed constants procedure call machine generated code code uses libraries na 
slicing algorithm de ned intraprocedural constant propagation 
propagate constants procedure calls 
exploit constant loop bounds nite unfolding 
certain applications heuristic techniques loop unfolding produce signi cant results 
involve enhancements system exploit kinds transformations provide powerful amorphous slicing domain speci contexts 
summary described interprocedural amorphous slicing system wsl mixes dependence reduction transformations traditional slicing achieve smaller slices interprocedural level 
amorphous slice construction harder traditional syntax preserving slice construction 
shows case compares syntax tree approach familiar system dependence graph approach 
describes algorithm dependence reduction transformation showing combined syntax preserving slicing produce amorphous slices 
dependence reduction algorithm implemented part amorphous slicing system 
describes explains ts context slicing system combines amorphous slicing side ect removal slicing criterion guidance mechanized formal proofs program transformations employed 
empirical results executions implementation show scales applications unit level worst case somewhat pathological rare 
martin ward helpful interesting discussions fermat language wsl providing tools community gpl 
bene tted discussions slicing transformation ira baxter canfora jim cordy tom dean mike ernst bogdan korel jens krinke andrea de lucia jurgen yang 
extended version originally submitted nd ieee international workshop source code analysis manipulation scam 
referees original scam version helpful comments referees extended version comments suggestions 
project funded engineering physical sciences research council epsrc number gr 
harman danicic hu supported part epsrc gr gr gr development daimlerchrysler ag berlin 
binkley supported part national science foundation ccr 
agrawal 
slicing programs jump statements 
acm sigplan conference programming language design implementation pages orlando florida june 
proceedings sigplan notices june 
alfred aho ravi sethi je rey ullman 
compilers principles techniques tools 
addison wesley 
apt jacob vincent andrea schaerf 
alma imperative language supports declarative programming 
acm transactions programming languages systems september 
thomas ball susan horwitz 
slicing programs arbitrary control ow 
peter fritzson editor st conference automated algorithmic debugging pages link oping sweden 
springer 
available university wisconsin madison technical report extended form tr december 
keith bennett tim bull eddie younger luo 
reverse engineering safety critical systems 
ieee international conference software maintenance pages 
ieee computer society press los alamitos california usa 
keith bennett 
program transformations help reverse engineering 
ieee international conference software maintenance icsm pages bethesda maryland usa november 
ieee computer society press los alamitos california usa 
webster 
concept assignment problem program understanding 
th international conference software engineering baltimore maryland may 
ieee computer society press los alamitos california usa 
david binkley 
application program slicing regression testing 
mark harman keith gallagher editors information software technology special issue program slicing volume pages 
elsevier 
david binkley 
computing amorphous program slices dependence graphs data ow model 
acm symposium applied computing pages menger san antonio texas 
acm press new york ny usa 
david binkley keith brian gallagher 
program slicing 
marvin zelkowitz editor advances computing volume pages 
academic press 
david binkley mark harman ross christopher smith 
empirical study amorphous slicing program comprehension support tool 
th ieee international workshop program comprehension iwpc pages limerick ireland june 
ieee computer society press los alamitos california usa 
tim bull 
software maintenance program transformation wide spectrum language 
phd thesis university durham uk school engineering computer science 
canfora cimitile andrea de lucia 
conditioned program slicing 
mark harman keith gallagher editors information software technology special issue program slicing volume pages 
elsevier science 
jong deok choi jeanne ferrante 
static slicing presence goto statements 
acm transactions programming languages systems july 
thierry coquand erard huet 
calculus constructions 
information computation 
thierry coquand christine paulin 
inductively de ned types preliminary version 
martin mints editors proceedings int 
conf 
computer logic ussr dec volume lecture notes computer science pages 
springer verlag berlin 
james corbett matthew dwyer john shawn laubach corina pasareanu robby hongjun zheng 
bandera extracting nite state models java source code 
nd international conference software engineering icse pages 
ieee computer society press los alamitos california usa june 
cristina cornes courant jean christophe gerard huet pascal cesar munoz murthy christine paulin mohring benjamin werner 
coq proof assistant manual version 
technical report rt inria institut national de recherche en informatique en automatique july 
sebastian danicic chris fox mark harman rob mark hierons 
conditioned program slicer 
ieee international conference software maintenance icsm pages san jose california usa october 
ieee computer society press los alamitos california usa 
sebastian danicic mark harman 
espresso slicer generator 
acm symposium applied computing sac pages como italy march 
mohammed sebastian danicic john mark harman chris fox martin ward 
scalable approach conditioned slicing 
ieee working conference reverse engineering wcre richmond virginia usa october 
ieee computer society press los alamitos california usa 
selected consideration issue journal systems software 
john darlington rod burstall 
system automatically improves programs 
acta informatica 
das 
partial evaluation dependence graphs 
phd thesis university wisconsin madison 
andrea de lucia 
program slicing methods applications 
st ieee international workshop source code analysis manipulation pages florence italy 
ieee computer society press los alamitos california usa 
andrea de lucia anna rita malcolm munro 
understanding function behaviours program slicing 
th ieee workshop program comprehension pages berlin germany march 
ieee computer society press los alamitos california usa 
richard de richard lipton alan perlis 
social processes proofs theorems programs 
communications acm may 
earlier version appeared acm symposium principles programming languages popl los angeles california pp 

michael ernst :10.1.1.26.990
practical ne grained static slicing optimised code 
technical report msr tr microsoft research redmond wa july 
john field ramalingam 
identifying procedural structure cobol programs 
proceedings acm sigplan sigsoft workshop program analysis software tools engineering volume software notes sen pages september 
acm press 
john field ramalingam frank tip 
parametric program slicing 
nd acm symposium principles programming languages pages san francisco ca 
richard gerber hong 
slicing real time programs enhanced schedulability 
acm transactions programming languages systems may 
nicolas gold 
hypothesis concept assignment support software maintenance 
phd thesis department computer science university durham 
nicolas gold 
hypothesis concept assignment support software maintenance 
ieee international conference software maintenance icsm pages florence italy november 
ieee computer society press los alamitos california usa 
codesurfer slicing system 
rajiv gupta mary jean harrold mary lou approach regression testing slicing 
proceedings ieee conference software maintenance pages orlando florida usa 
ieee computer society press los alamitos california usa 
mark harman david binkley sebastian danicic :10.1.1.13.6694
amorphous program slicing 
journal systems software 
appear 
mark harman sebastian danicic 
program slicing simplify testing 
software testing veri cation reliability september 
mark harman sebastian danicic :10.1.1.13.6694
amorphous program slicing 
th ieee international workshop program iwpc pages michigan usa may 
ieee computer society press los alamitos california usa 
mark harman sebastian danicic 
new algorithm slicing unstructured programs 
journal software maintenance evolution 
mark harman nicolas gold robert mark hierons david binkley 
code extraction algorithms unify slicing concept assignment 
ieee working conference reverse engineering wcre richmond virginia usa october 
ieee computer society press los alamitos california usa 
mark harman robert mark hierons 
overview program slicing 
software focus 
mark harman lin hu robert hierons andr baresel sthamer 
improving evolutionary testing ag removal best gecco award winner 
gecco proceedings genetic evolutionary computation conference pages new york july 
morgan kaufmann publishers 
mark harman lin hu robert mark hierons zhang malcolm munro jos javier mari carmen joachim wegener 
post placement side ect removal algorithm 
ieee international conference software maintenance icsm pages montreal canada october 
ieee computer society press los alamitos california usa 
mark harman lin hu zhang malcolm munro 
amorphous slicing system combines slicing transformation 
st workshop analysis slicing transformation ast pages stuttgart october 
ieee computer society press los alamitos california usa 
mark harman lin hu zhang malcolm munro 
side ect removal transformation 
th ieee international workshop program comprehension iwpc pages toronto canada may 
ieee computer society press los alamitos california usa 
mark harman sebastian danicic 
analysis dynamic memory access amorphous slicing 
ieee international conference software maintenance icsm pages bethesda maryland usa november 
ieee computer society press los alamitos california usa 
robert mark hierons mark harman sebastian danicic 
program slicing assist detection equivalent mutants 
software testing veri cation reliability 
susan horwitz thomas reps david binkley 
interprocedural slicing dependence graphs 
acm sigplan conference programming language design implementation pages atlanta georgia june 
proceedings sigplan notices pp 
susan horwitz thomas reps david binkley 
interprocedural slicing dependence graphs 
acm transactions programming languages systems 

intelligent search acquisition business knowledge programs 
journal software maintenance research practice 
bogdan korel janusz laski 
dynamic program slicing 
information processing letters october 
jan ralf joost visser 
functional transformation systems 
th international workshop functional logic programming spain september 
online proceedings www upv es 
sumit kumar susan horwitz 
better slicing programs jumps switches 
proceedings th international conference fundamental approaches software engineering fase volume lecture notes computer science pages 
springer 
larsen mary jean harrold 
slicing object oriented software 
proceedings th international conference software engineering pages berlin 
liang mary jean harrold 
slicing objects system dependence graph 
ieee international conference software maintenance pages bethesda maryland usa november 
ieee computer society press los alamitos california usa 
shih wei liao amer diwan robert bosch jr monica lam 
suif explorer interactive interprocedural 
andrew chien marc snir editors proceedings acm sigplan symposium principles practise parallel programming ppopp volume acm sigplan notices pages may 
acm press 
james lyle david binkley 
program slicing presence pointers 
foundations software engineering pages orlando fl usa november 
mary jean harrold aristotle analysis tool 
maslov 
lazy array data ow dependence analysis 
acm editor conference record popl st acm sigplan sigact symposium principles programming languages papers symposium portland oregon january pages new york ny usa 
acm press 
michael ira baxter 
mechanical tool support high integrity software development 
high integrity systems 
ieee computer society press los alamitos california usa 
cindy norris lori pollock 
design implementation rap pdg register allocator 
software practice experience april 
karl ottenstein linda ottenstein 
program dependence graph software development environments 
sigplan notices 
sebastian danicic dave mohammed mark harman chris fox 
denotational interprocedural program slicer 
ieee working conference reverse engineering wcre richmond virginia usa october 
ieee computer society press los alamitos california usa 
helmut 
speci cation transformation programs formal approach software development 
springer 
christine paulin mohring benjamin werner 
synthesis ml programs system coq 
journal symbolic computation 
lyle ramshaw 
eliminating goto preserving program structure 
journal acm 
conor ryan paul walsh 
evolution provable parallel programs 
john koza kalyanmoy deb marco dorigo david fogel max garzon hitoshi iba rick riolo editors genetic programming proceedings second annual conference pages stanford university ca usa july 
morgan kaufmann 
sinha mary jean harrold 
analysis programs exception handling constructs 
international conference software maintenance pages 
ieee computer society press los alamitos california usa november 
sinha mary jean harrold gregg rothermel 
system dependence graph slicing programs arbitrary interprocedural control ow 
proceedings st international conference software engineering pages 
acm press may 
joseph stoy 
denotational semantics scott strachey approach programming language theory 
mit press 
third edition 
frank tip 
generation program analysis tools 
phd thesis centrum voor wiskunde en informatica amsterdam 
frank tip 
survey program slicing techniques 
journal programming languages september 
venkatesh 
semantic approach program slicing 
acm sigplan conference programming language design implementation pages toronto canada june 
proceedings sigplan notices pp 
martin ward 
proving program re nements transformations 
thesis oxford university 
martin ward 
reverse engineering formal transformation 
computer journal 
martin ward 
formal approach source code analysis manipulation 
st ieee international workshop source code analysis manipulation pages florence italy 
ieee computer society press los alamitos california usa 
martin ward 
program slicing fermat transformations 
th ieee annual computer software applications conference compsac pages oxford uk august 
ieee computer society press los alamitos california usa 
mark weiser 
program slices formal psychological practical investigations automatic program abstraction method 
phd thesis university michigan ann arbor mi 
mark weiser 
program slicing 
ieee transactions software engineering 
kenneth peter williams 
evolutionary algorithms automatic parallelization 
phd thesis university reading uk department computer science september 
zhang malcolm munro mark harman lin hu 
mechanized operational semantics wsl 
ieee international workshop source code analysis manipulation scam pages montreal canada october 
ieee computer society press los alamitos california usa 
zhang malcolm munro mark harman lin hu 
weakest precondition general recursive programs formalized coq 
th international conference theorem proving higher order logics tphols pages hampton virginia usa august 
springer verlag 
lncs 
zhao 
slicing aspect oriented software 
th ieee international workshop program comprehension pages paris france june 
ieee computer society press los alamitos california usa 

